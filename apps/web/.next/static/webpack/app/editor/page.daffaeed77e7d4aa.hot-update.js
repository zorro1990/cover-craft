"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/editor/page",{

/***/ "(app-pages-browser)/./src/lib/fabric/shape.ts":
/*!*********************************!*\
  !*** ./src/lib/fabric/shape.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCircle: function() { return /* binding */ createCircle; },\n/* harmony export */   createLine: function() { return /* binding */ createLine; },\n/* harmony export */   createRectangle: function() { return /* binding */ createRectangle; },\n/* harmony export */   finishDragDrawShape: function() { return /* binding */ finishDragDrawShape; },\n/* harmony export */   flipShapeHorizontal: function() { return /* binding */ flipShapeHorizontal; },\n/* harmony export */   flipShapeVertical: function() { return /* binding */ flipShapeVertical; },\n/* harmony export */   getShapeDimensions: function() { return /* binding */ getShapeDimensions; },\n/* harmony export */   getShapeTypeName: function() { return /* binding */ getShapeTypeName; },\n/* harmony export */   resetShapeSize: function() { return /* binding */ resetShapeSize; },\n/* harmony export */   startDragDrawShape: function() { return /* binding */ startDragDrawShape; },\n/* harmony export */   updateDragDrawShape: function() { return /* binding */ updateDragDrawShape; }\n/* harmony export */ });\n/* harmony import */ var fabric__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fabric */ \"(app-pages-browser)/./node_modules/fabric/dist/fabric.js\");\n/* harmony import */ var fabric__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fabric__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * Create a rectangle shape\n */ function createRectangle(canvas) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var _options_left, _options_top, _options_width, _options_height, _options_fill, _options_stroke, _options_strokeWidth, _options_opacity;\n    const rect = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Rect({\n        left: (_options_left = options.left) !== null && _options_left !== void 0 ? _options_left : 100,\n        top: (_options_top = options.top) !== null && _options_top !== void 0 ? _options_top : 100,\n        width: (_options_width = options.width) !== null && _options_width !== void 0 ? _options_width : 200,\n        height: (_options_height = options.height) !== null && _options_height !== void 0 ? _options_height : 150,\n        fill: (_options_fill = options.fill) !== null && _options_fill !== void 0 ? _options_fill : \"#3b82f6\",\n        stroke: (_options_stroke = options.stroke) !== null && _options_stroke !== void 0 ? _options_stroke : \"#1e40af\",\n        strokeWidth: (_options_strokeWidth = options.strokeWidth) !== null && _options_strokeWidth !== void 0 ? _options_strokeWidth : 2,\n        opacity: (_options_opacity = options.opacity) !== null && _options_opacity !== void 0 ? _options_opacity : 1,\n        selectable: true\n    });\n    canvas.add(rect);\n    canvas.setActiveObject(rect);\n    canvas.renderAll();\n    return rect;\n}\n/**\n * Create a circle shape\n */ function createCircle(canvas) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var _options_left, _options_top, _options_fill, _options_stroke, _options_strokeWidth, _options_opacity;\n    const circle = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Circle({\n        left: (_options_left = options.left) !== null && _options_left !== void 0 ? _options_left : 100,\n        top: (_options_top = options.top) !== null && _options_top !== void 0 ? _options_top : 100,\n        radius: options.width ? options.width / 2 : 75,\n        fill: (_options_fill = options.fill) !== null && _options_fill !== void 0 ? _options_fill : \"#10b981\",\n        stroke: (_options_stroke = options.stroke) !== null && _options_stroke !== void 0 ? _options_stroke : \"#047857\",\n        strokeWidth: (_options_strokeWidth = options.strokeWidth) !== null && _options_strokeWidth !== void 0 ? _options_strokeWidth : 2,\n        opacity: (_options_opacity = options.opacity) !== null && _options_opacity !== void 0 ? _options_opacity : 1,\n        selectable: true\n    });\n    canvas.add(circle);\n    canvas.setActiveObject(circle);\n    canvas.renderAll();\n    return circle;\n}\n/**\n * Create a line shape\n */ function createLine(canvas) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var _options_left, _options_top, _options_left1, _options_width, _options_top1, _options_height, _options_stroke, _options_strokeWidth, _options_opacity;\n    const line = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Line([\n        (_options_left = options.left) !== null && _options_left !== void 0 ? _options_left : 100,\n        (_options_top = options.top) !== null && _options_top !== void 0 ? _options_top : 100,\n        ((_options_left1 = options.left) !== null && _options_left1 !== void 0 ? _options_left1 : 100) + ((_options_width = options.width) !== null && _options_width !== void 0 ? _options_width : 200),\n        ((_options_top1 = options.top) !== null && _options_top1 !== void 0 ? _options_top1 : 100) + ((_options_height = options.height) !== null && _options_height !== void 0 ? _options_height : 0)\n    ], {\n        stroke: (_options_stroke = options.stroke) !== null && _options_stroke !== void 0 ? _options_stroke : \"#6b7280\",\n        strokeWidth: (_options_strokeWidth = options.strokeWidth) !== null && _options_strokeWidth !== void 0 ? _options_strokeWidth : 3,\n        opacity: (_options_opacity = options.opacity) !== null && _options_opacity !== void 0 ? _options_opacity : 1,\n        selectable: true\n    });\n    canvas.add(line);\n    canvas.setActiveObject(line);\n    canvas.renderAll();\n    return line;\n}\n/**\n * Get shape dimensions and properties\n */ function getShapeDimensions(object) {\n    const originalWidth = object.originalWidth || object.width || 0;\n    const originalHeight = object.originalHeight || object.height || 0;\n    const scaleX = object.scaleX || 1;\n    const scaleY = object.scaleY || 1;\n    return {\n        originalWidth,\n        originalHeight,\n        currentWidth: originalWidth * scaleX,\n        currentHeight: originalHeight * scaleY,\n        scaleX,\n        scaleY\n    };\n}\n/**\n * Reset shape to original size\n */ function resetShapeSize(object) {\n    const dimensions = getShapeDimensions(object);\n    object.set({\n        scaleX: 1,\n        scaleY: 1\n    });\n    object.setCoords();\n    if (object.canvas) {\n        object.canvas.renderAll();\n    }\n    return {\n        originalWidth: dimensions.originalWidth,\n        originalHeight: dimensions.originalHeight,\n        currentWidth: dimensions.originalWidth,\n        currentHeight: dimensions.originalHeight\n    };\n}\n/**\n * Flip shape horizontally\n */ function flipShapeHorizontal(object) {\n    object.set(\"flipX\", !object.flipX);\n    object.setCoords();\n    if (object.canvas) {\n        object.canvas.renderAll();\n    }\n}\n/**\n * Flip shape vertically\n */ function flipShapeVertical(object) {\n    object.set(\"flipY\", !object.flipY);\n    object.setCoords();\n    if (object.canvas) {\n        object.canvas.renderAll();\n    }\n}\n/**\n * Get shape type name for display\n */ function getShapeTypeName(type) {\n    const typeMap = {\n        rect: \"矩形\",\n        circle: \"圆形\",\n        line: \"直线\"\n    };\n    return typeMap[type] || type;\n}\n/**\n * 开始拖拽绘制形状\n * @param canvas Fabric.js Canvas 实例\n * @param type 形状类型\n * @param startPoint 起始点\n * @returns 临时形状对象\n */ function startDragDrawShape(canvas, type, startPoint) {\n    let shape = null;\n    switch(type){\n        case \"rectangle\":\n            shape = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Rect({\n                left: startPoint.x,\n                top: startPoint.y,\n                width: 0,\n                height: 0,\n                fill: \"rgba(59, 130, 246, 0.3)\",\n                stroke: \"#3b82f6\",\n                strokeWidth: 2,\n                selectable: false\n            });\n            break;\n        case \"circle\":\n            shape = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Circle({\n                left: startPoint.x,\n                top: startPoint.y,\n                radius: 0,\n                fill: \"rgba(59, 130, 246, 0.3)\",\n                stroke: \"#3b82f6\",\n                strokeWidth: 2,\n                selectable: false\n            });\n            break;\n        case \"line\":\n            shape = new fabric__WEBPACK_IMPORTED_MODULE_0__.fabric.Line([\n                startPoint.x,\n                startPoint.y,\n                startPoint.x,\n                startPoint.y\n            ], {\n                stroke: \"#3b82f6\",\n                strokeWidth: 2,\n                selectable: false\n            });\n            break;\n    }\n    if (shape) {\n        canvas.add(shape);\n        canvas.requestRenderAll();\n    }\n    return shape;\n}\n/**\n * 更新拖拽绘制中的形状\n * @param shape 形状对象\n * @param type 形状类型\n * @param startPoint 起始点\n * @param currentPoint 当前点\n */ function updateDragDrawShape(shape, type, startPoint, currentPoint) {\n    var _shape_canvas;\n    switch(type){\n        case \"rectangle\":\n            {\n                const rect = shape;\n                const width = currentPoint.x - startPoint.x;\n                const height = currentPoint.y - startPoint.y;\n                rect.set({\n                    width: Math.abs(width),\n                    height: Math.abs(height),\n                    left: width > 0 ? startPoint.x : currentPoint.x,\n                    top: height > 0 ? startPoint.y : currentPoint.y\n                });\n                break;\n            }\n        case \"circle\":\n            {\n                const circle = shape;\n                const radius = Math.sqrt(Math.pow(currentPoint.x - startPoint.x, 2) + Math.pow(currentPoint.y - startPoint.y, 2));\n                circle.set({\n                    radius\n                });\n                break;\n            }\n        case \"line\":\n            {\n                const line = shape;\n                line.set({\n                    x2: currentPoint.x,\n                    y2: currentPoint.y\n                });\n                break;\n            }\n    }\n    (_shape_canvas = shape.canvas) === null || _shape_canvas === void 0 ? void 0 : _shape_canvas.requestRenderAll();\n}\n/**\n * 完成拖拽绘制，固定形状\n * @param canvas Fabric.js Canvas 实例\n * @param shape 临时形状对象\n * @param type 形状类型\n */ function finishDragDrawShape(canvas, shape, type) {\n    // 移除临时形状\n    canvas.remove(shape);\n    // 创建最终形状（使用默认样式）\n    const finalShape = createShapeByType(canvas, type, {\n        left: shape.left,\n        top: shape.top,\n        ...type === \"rectangle\" && {\n            width: shape.width,\n            height: shape.height\n        },\n        ...type === \"circle\" && {\n            radius: shape.radius\n        },\n        ...type === \"line\" && {\n            x1: shape.x1,\n            y1: shape.y1,\n            x2: shape.x2,\n            y2: shape.y2\n        }\n    });\n    canvas.setActiveObject(finalShape);\n    canvas.requestRenderAll();\n}\n/**\n * 根据类型创建形状（内部辅助函数）\n */ function createShapeByType(canvas, type, options) {\n    switch(type){\n        case \"rectangle\":\n            return createRectangle(canvas, options);\n        case \"circle\":\n            return createCircle(canvas, options);\n        case \"line\":\n            return createLine(canvas, options);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZmFicmljL3NoYXBlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFhL0I7O0NBRUMsR0FDTSxTQUFTQyxnQkFDZEMsTUFBcUI7UUFDckJDLFVBQUFBLGlFQUF3QixDQUFDO1FBR2pCQSxlQUNEQSxjQUNFQSxnQkFDQ0EsaUJBQ0ZBLGVBQ0VBLGlCQUNLQSxzQkFDSkE7SUFSWCxNQUFNQyxPQUFPLElBQUlKLDBDQUFNQSxDQUFDSyxJQUFJLENBQUM7UUFDM0JDLE1BQU1ILENBQUFBLGdCQUFBQSxRQUFRRyxJQUFJLGNBQVpILDJCQUFBQSxnQkFBZ0I7UUFDdEJJLEtBQUtKLENBQUFBLGVBQUFBLFFBQVFJLEdBQUcsY0FBWEosMEJBQUFBLGVBQWU7UUFDcEJLLE9BQU9MLENBQUFBLGlCQUFBQSxRQUFRSyxLQUFLLGNBQWJMLDRCQUFBQSxpQkFBaUI7UUFDeEJNLFFBQVFOLENBQUFBLGtCQUFBQSxRQUFRTSxNQUFNLGNBQWROLDZCQUFBQSxrQkFBa0I7UUFDMUJPLE1BQU1QLENBQUFBLGdCQUFBQSxRQUFRTyxJQUFJLGNBQVpQLDJCQUFBQSxnQkFBZ0I7UUFDdEJRLFFBQVFSLENBQUFBLGtCQUFBQSxRQUFRUSxNQUFNLGNBQWRSLDZCQUFBQSxrQkFBa0I7UUFDMUJTLGFBQWFULENBQUFBLHVCQUFBQSxRQUFRUyxXQUFXLGNBQW5CVCxrQ0FBQUEsdUJBQXVCO1FBQ3BDVSxTQUFTVixDQUFBQSxtQkFBQUEsUUFBUVUsT0FBTyxjQUFmViw4QkFBQUEsbUJBQW1CO1FBQzVCVyxZQUFZO0lBQ2Q7SUFFQVosT0FBT2EsR0FBRyxDQUFDWDtJQUNYRixPQUFPYyxlQUFlLENBQUNaO0lBQ3ZCRixPQUFPZSxTQUFTO0lBRWhCLE9BQU9iO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNjLGFBQ2RoQixNQUFxQjtRQUNyQkMsVUFBQUEsaUVBQXdCLENBQUM7UUFHakJBLGVBQ0RBLGNBRUNBLGVBQ0VBLGlCQUNLQSxzQkFDSkE7SUFQWCxNQUFNZ0IsU0FBUyxJQUFJbkIsMENBQU1BLENBQUNvQixNQUFNLENBQUM7UUFDL0JkLE1BQU1ILENBQUFBLGdCQUFBQSxRQUFRRyxJQUFJLGNBQVpILDJCQUFBQSxnQkFBZ0I7UUFDdEJJLEtBQUtKLENBQUFBLGVBQUFBLFFBQVFJLEdBQUcsY0FBWEosMEJBQUFBLGVBQWU7UUFDcEJrQixRQUFRbEIsUUFBUUssS0FBSyxHQUFHTCxRQUFRSyxLQUFLLEdBQUcsSUFBSTtRQUM1Q0UsTUFBTVAsQ0FBQUEsZ0JBQUFBLFFBQVFPLElBQUksY0FBWlAsMkJBQUFBLGdCQUFnQjtRQUN0QlEsUUFBUVIsQ0FBQUEsa0JBQUFBLFFBQVFRLE1BQU0sY0FBZFIsNkJBQUFBLGtCQUFrQjtRQUMxQlMsYUFBYVQsQ0FBQUEsdUJBQUFBLFFBQVFTLFdBQVcsY0FBbkJULGtDQUFBQSx1QkFBdUI7UUFDcENVLFNBQVNWLENBQUFBLG1CQUFBQSxRQUFRVSxPQUFPLGNBQWZWLDhCQUFBQSxtQkFBbUI7UUFDNUJXLFlBQVk7SUFDZDtJQUVBWixPQUFPYSxHQUFHLENBQUNJO0lBQ1hqQixPQUFPYyxlQUFlLENBQUNHO0lBQ3ZCakIsT0FBT2UsU0FBUztJQUVoQixPQUFPRTtBQUNUO0FBRUE7O0NBRUMsR0FDTSxTQUFTRyxXQUNkcEIsTUFBcUI7UUFDckJDLFVBQUFBLGlFQUF3QixDQUFDO1FBSXJCQSxlQUNBQSxjQUNDQSxnQkFBd0JBLGdCQUN4QkEsZUFBdUJBLGlCQUdoQkEsaUJBQ0tBLHNCQUNKQTtJQVZiLE1BQU1vQixPQUFPLElBQUl2QiwwQ0FBTUEsQ0FBQ3dCLElBQUksQ0FDMUI7UUFDRXJCLENBQUFBLGdCQUFBQSxRQUFRRyxJQUFJLGNBQVpILDJCQUFBQSxnQkFBZ0I7UUFDaEJBLENBQUFBLGVBQUFBLFFBQVFJLEdBQUcsY0FBWEosMEJBQUFBLGVBQWU7UUFDZEEsQ0FBQUEsQ0FBQUEsaUJBQUFBLFFBQVFHLElBQUksY0FBWkgsNEJBQUFBLGlCQUFnQixHQUFFLElBQU1BLENBQUFBLENBQUFBLGlCQUFBQSxRQUFRSyxLQUFLLGNBQWJMLDRCQUFBQSxpQkFBaUIsR0FBRTtRQUMzQ0EsQ0FBQUEsQ0FBQUEsZ0JBQUFBLFFBQVFJLEdBQUcsY0FBWEosMkJBQUFBLGdCQUFlLEdBQUUsSUFBTUEsQ0FBQUEsQ0FBQUEsa0JBQUFBLFFBQVFNLE1BQU0sY0FBZE4sNkJBQUFBLGtCQUFrQjtLQUMzQyxFQUNEO1FBQ0VRLFFBQVFSLENBQUFBLGtCQUFBQSxRQUFRUSxNQUFNLGNBQWRSLDZCQUFBQSxrQkFBa0I7UUFDMUJTLGFBQWFULENBQUFBLHVCQUFBQSxRQUFRUyxXQUFXLGNBQW5CVCxrQ0FBQUEsdUJBQXVCO1FBQ3BDVSxTQUFTVixDQUFBQSxtQkFBQUEsUUFBUVUsT0FBTyxjQUFmViw4QkFBQUEsbUJBQW1CO1FBQzVCVyxZQUFZO0lBQ2Q7SUFHRlosT0FBT2EsR0FBRyxDQUFDUTtJQUNYckIsT0FBT2MsZUFBZSxDQUFDTztJQUN2QnJCLE9BQU9lLFNBQVM7SUFFaEIsT0FBT007QUFDVDtBQUVBOztDQUVDLEdBQ00sU0FBU0UsbUJBQW1CQyxNQUFxQjtJQUN0RCxNQUFNQyxnQkFBZ0IsT0FBZ0JBLGFBQWEsSUFBSUQsT0FBT2xCLEtBQUssSUFBSTtJQUN2RSxNQUFNb0IsaUJBQWlCLE9BQWdCQSxjQUFjLElBQUlGLE9BQU9qQixNQUFNLElBQUk7SUFDMUUsTUFBTW9CLFNBQVNILE9BQU9HLE1BQU0sSUFBSTtJQUNoQyxNQUFNQyxTQUFTSixPQUFPSSxNQUFNLElBQUk7SUFFaEMsT0FBTztRQUNMSDtRQUNBQztRQUNBRyxjQUFjSixnQkFBZ0JFO1FBQzlCRyxlQUFlSixpQkFBaUJFO1FBQ2hDRDtRQUNBQztJQUNGO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNHLGVBQ2RQLE1BQXFCO0lBT3JCLE1BQU1RLGFBQWFULG1CQUFtQkM7SUFFdENBLE9BQU9TLEdBQUcsQ0FBQztRQUNUTixRQUFRO1FBQ1JDLFFBQVE7SUFDVjtJQUNBSixPQUFPVSxTQUFTO0lBRWhCLElBQUlWLE9BQU94QixNQUFNLEVBQUU7UUFDakJ3QixPQUFPeEIsTUFBTSxDQUFDZSxTQUFTO0lBQ3pCO0lBRUEsT0FBTztRQUNMVSxlQUFlTyxXQUFXUCxhQUFhO1FBQ3ZDQyxnQkFBZ0JNLFdBQVdOLGNBQWM7UUFDekNHLGNBQWNHLFdBQVdQLGFBQWE7UUFDdENLLGVBQWVFLFdBQVdOLGNBQWM7SUFDMUM7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU1Msb0JBQW9CWCxNQUFxQjtJQUN2REEsT0FBT1MsR0FBRyxDQUFDLFNBQVMsQ0FBQ1QsT0FBT1ksS0FBSztJQUNqQ1osT0FBT1UsU0FBUztJQUVoQixJQUFJVixPQUFPeEIsTUFBTSxFQUFFO1FBQ2pCd0IsT0FBT3hCLE1BQU0sQ0FBQ2UsU0FBUztJQUN6QjtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTc0Isa0JBQWtCYixNQUFxQjtJQUNyREEsT0FBT1MsR0FBRyxDQUFDLFNBQVMsQ0FBQ1QsT0FBT2MsS0FBSztJQUNqQ2QsT0FBT1UsU0FBUztJQUVoQixJQUFJVixPQUFPeEIsTUFBTSxFQUFFO1FBQ2pCd0IsT0FBT3hCLE1BQU0sQ0FBQ2UsU0FBUztJQUN6QjtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTd0IsaUJBQWlCQyxJQUFZO0lBQzNDLE1BQU1DLFVBQWtDO1FBQ3RDdkMsTUFBTTtRQUNOZSxRQUFRO1FBQ1JJLE1BQU07SUFDUjtJQUVBLE9BQU9vQixPQUFPLENBQUNELEtBQUssSUFBSUE7QUFDMUI7QUFFQTs7Ozs7O0NBTUMsR0FDTSxTQUFTRSxtQkFDZDFDLE1BQXFCLEVBQ3JCd0MsSUFBcUMsRUFDckNHLFVBQW9DO0lBRXBDLElBQUlDLFFBQThCO0lBRWxDLE9BQVFKO1FBQ04sS0FBSztZQUNISSxRQUFRLElBQUk5QywwQ0FBTUEsQ0FBQ0ssSUFBSSxDQUFDO2dCQUN0QkMsTUFBTXVDLFdBQVdFLENBQUM7Z0JBQ2xCeEMsS0FBS3NDLFdBQVdHLENBQUM7Z0JBQ2pCeEMsT0FBTztnQkFDUEMsUUFBUTtnQkFDUkMsTUFBTTtnQkFDTkMsUUFBUTtnQkFDUkMsYUFBYTtnQkFDYkUsWUFBWTtZQUNkO1lBQ0E7UUFFRixLQUFLO1lBQ0hnQyxRQUFRLElBQUk5QywwQ0FBTUEsQ0FBQ29CLE1BQU0sQ0FBQztnQkFDeEJkLE1BQU11QyxXQUFXRSxDQUFDO2dCQUNsQnhDLEtBQUtzQyxXQUFXRyxDQUFDO2dCQUNqQjNCLFFBQVE7Z0JBQ1JYLE1BQU07Z0JBQ05DLFFBQVE7Z0JBQ1JDLGFBQWE7Z0JBQ2JFLFlBQVk7WUFDZDtZQUNBO1FBRUYsS0FBSztZQUNIZ0MsUUFBUSxJQUFJOUMsMENBQU1BLENBQUN3QixJQUFJLENBQUM7Z0JBQUNxQixXQUFXRSxDQUFDO2dCQUFFRixXQUFXRyxDQUFDO2dCQUFFSCxXQUFXRSxDQUFDO2dCQUFFRixXQUFXRyxDQUFDO2FBQUMsRUFBRTtnQkFDaEZyQyxRQUFRO2dCQUNSQyxhQUFhO2dCQUNiRSxZQUFZO1lBQ2Q7WUFDQTtJQUNKO0lBRUEsSUFBSWdDLE9BQU87UUFDVDVDLE9BQU9hLEdBQUcsQ0FBQytCO1FBQ1g1QyxPQUFPK0MsZ0JBQWdCO0lBQ3pCO0lBRUEsT0FBT0g7QUFDVDtBQUVBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNJLG9CQUNkSixLQUFvQixFQUNwQkosSUFBcUMsRUFDckNHLFVBQW9DLEVBQ3BDTSxZQUFzQztRQW9DdENMO0lBbENBLE9BQVFKO1FBQ04sS0FBSztZQUFhO2dCQUNoQixNQUFNdEMsT0FBTzBDO2dCQUNiLE1BQU10QyxRQUFRMkMsYUFBYUosQ0FBQyxHQUFHRixXQUFXRSxDQUFDO2dCQUMzQyxNQUFNdEMsU0FBUzBDLGFBQWFILENBQUMsR0FBR0gsV0FBV0csQ0FBQztnQkFDNUM1QyxLQUFLK0IsR0FBRyxDQUFDO29CQUNQM0IsT0FBTzRDLEtBQUtDLEdBQUcsQ0FBQzdDO29CQUNoQkMsUUFBUTJDLEtBQUtDLEdBQUcsQ0FBQzVDO29CQUNqQkgsTUFBTUUsUUFBUSxJQUFJcUMsV0FBV0UsQ0FBQyxHQUFHSSxhQUFhSixDQUFDO29CQUMvQ3hDLEtBQUtFLFNBQVMsSUFBSW9DLFdBQVdHLENBQUMsR0FBR0csYUFBYUgsQ0FBQztnQkFDakQ7Z0JBQ0E7WUFDRjtRQUVBLEtBQUs7WUFBVTtnQkFDYixNQUFNN0IsU0FBUzJCO2dCQUNmLE1BQU16QixTQUFTK0IsS0FBS0UsSUFBSSxDQUN0QkYsS0FBS0csR0FBRyxDQUFDSixhQUFhSixDQUFDLEdBQUdGLFdBQVdFLENBQUMsRUFBRSxLQUN4Q0ssS0FBS0csR0FBRyxDQUFDSixhQUFhSCxDQUFDLEdBQUdILFdBQVdHLENBQUMsRUFBRTtnQkFFMUM3QixPQUFPZ0IsR0FBRyxDQUFDO29CQUFFZDtnQkFBTztnQkFDcEI7WUFDRjtRQUVBLEtBQUs7WUFBUTtnQkFDWCxNQUFNRSxPQUFPdUI7Z0JBQ2J2QixLQUFLWSxHQUFHLENBQUM7b0JBQ1BxQixJQUFJTCxhQUFhSixDQUFDO29CQUNsQlUsSUFBSU4sYUFBYUgsQ0FBQztnQkFDcEI7Z0JBQ0E7WUFDRjtJQUNGO0tBRUFGLGdCQUFBQSxNQUFNNUMsTUFBTSxjQUFaNEMsb0NBQUFBLGNBQWNHLGdCQUFnQjtBQUNoQztBQUVBOzs7OztDQUtDLEdBQ00sU0FBU1Msb0JBQ2R4RCxNQUFxQixFQUNyQjRDLEtBQW9CLEVBQ3BCSixJQUFxQztJQUVyQyxTQUFTO0lBQ1R4QyxPQUFPeUQsTUFBTSxDQUFDYjtJQUVkLGlCQUFpQjtJQUNqQixNQUFNYyxhQUFhQyxrQkFBa0IzRCxRQUFRd0MsTUFBTTtRQUNqRHBDLE1BQU13QyxNQUFNeEMsSUFBSTtRQUNoQkMsS0FBS3VDLE1BQU12QyxHQUFHO1FBQ2QsR0FBSW1DLFNBQVMsZUFBZTtZQUFFbEMsT0FBTyxNQUF1QkEsS0FBSztZQUFFQyxRQUFRLE1BQXVCQSxNQUFNO1FBQUMsQ0FBQztRQUMxRyxHQUFJaUMsU0FBUyxZQUFZO1lBQUVyQixRQUFRLE1BQXlCQSxNQUFNO1FBQUMsQ0FBQztRQUNwRSxHQUFJcUIsU0FBUyxVQUFVO1lBQ3JCb0IsSUFBSSxNQUF1QkEsRUFBRTtZQUM3QkMsSUFBSSxNQUF1QkEsRUFBRTtZQUM3QlAsSUFBSSxNQUF1QkEsRUFBRTtZQUM3QkMsSUFBSSxNQUF1QkEsRUFBRTtRQUMvQixDQUFDO0lBQ0g7SUFFQXZELE9BQU9jLGVBQWUsQ0FBQzRDO0lBQ3ZCMUQsT0FBTytDLGdCQUFnQjtBQUN6QjtBQUVBOztDQUVDLEdBQ0QsU0FBU1ksa0JBQ1AzRCxNQUFxQixFQUNyQndDLElBQXFDLEVBQ3JDdkMsT0FBWTtJQUVaLE9BQVF1QztRQUNOLEtBQUs7WUFDSCxPQUFPekMsZ0JBQWdCQyxRQUFRQztRQUNqQyxLQUFLO1lBQ0gsT0FBT2UsYUFBYWhCLFFBQVFDO1FBQzlCLEtBQUs7WUFDSCxPQUFPbUIsV0FBV3BCLFFBQVFDO0lBQzlCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9mYWJyaWMvc2hhcGUudHM/MGZiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmYWJyaWMgfSBmcm9tICdmYWJyaWMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hhcGVPcHRpb25zIHtcbiAgbGVmdD86IG51bWJlclxuICB0b3A/OiBudW1iZXJcbiAgd2lkdGg/OiBudW1iZXJcbiAgaGVpZ2h0PzogbnVtYmVyXG4gIGZpbGw/OiBzdHJpbmdcbiAgc3Ryb2tlPzogc3RyaW5nXG4gIHN0cm9rZVdpZHRoPzogbnVtYmVyXG4gIG9wYWNpdHk/OiBudW1iZXJcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByZWN0YW5nbGUgc2hhcGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlY3RhbmdsZShcbiAgY2FudmFzOiBmYWJyaWMuQ2FudmFzLFxuICBvcHRpb25zOiBTaGFwZU9wdGlvbnMgPSB7fVxuKTogZmFicmljLlJlY3Qge1xuICBjb25zdCByZWN0ID0gbmV3IGZhYnJpYy5SZWN0KHtcbiAgICBsZWZ0OiBvcHRpb25zLmxlZnQgPz8gMTAwLFxuICAgIHRvcDogb3B0aW9ucy50b3AgPz8gMTAwLFxuICAgIHdpZHRoOiBvcHRpb25zLndpZHRoID8/IDIwMCxcbiAgICBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0ID8/IDE1MCxcbiAgICBmaWxsOiBvcHRpb25zLmZpbGwgPz8gJyMzYjgyZjYnLFxuICAgIHN0cm9rZTogb3B0aW9ucy5zdHJva2UgPz8gJyMxZTQwYWYnLFxuICAgIHN0cm9rZVdpZHRoOiBvcHRpb25zLnN0cm9rZVdpZHRoID8/IDIsXG4gICAgb3BhY2l0eTogb3B0aW9ucy5vcGFjaXR5ID8/IDEsXG4gICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgfSlcblxuICBjYW52YXMuYWRkKHJlY3QpXG4gIGNhbnZhcy5zZXRBY3RpdmVPYmplY3QocmVjdClcbiAgY2FudmFzLnJlbmRlckFsbCgpXG5cbiAgcmV0dXJuIHJlY3Rcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjaXJjbGUgc2hhcGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNpcmNsZShcbiAgY2FudmFzOiBmYWJyaWMuQ2FudmFzLFxuICBvcHRpb25zOiBTaGFwZU9wdGlvbnMgPSB7fVxuKTogZmFicmljLkNpcmNsZSB7XG4gIGNvbnN0IGNpcmNsZSA9IG5ldyBmYWJyaWMuQ2lyY2xlKHtcbiAgICBsZWZ0OiBvcHRpb25zLmxlZnQgPz8gMTAwLFxuICAgIHRvcDogb3B0aW9ucy50b3AgPz8gMTAwLFxuICAgIHJhZGl1czogb3B0aW9ucy53aWR0aCA/IG9wdGlvbnMud2lkdGggLyAyIDogNzUsXG4gICAgZmlsbDogb3B0aW9ucy5maWxsID8/ICcjMTBiOTgxJyxcbiAgICBzdHJva2U6IG9wdGlvbnMuc3Ryb2tlID8/ICcjMDQ3ODU3JyxcbiAgICBzdHJva2VXaWR0aDogb3B0aW9ucy5zdHJva2VXaWR0aCA/PyAyLFxuICAgIG9wYWNpdHk6IG9wdGlvbnMub3BhY2l0eSA/PyAxLFxuICAgIHNlbGVjdGFibGU6IHRydWUsXG4gIH0pXG5cbiAgY2FudmFzLmFkZChjaXJjbGUpXG4gIGNhbnZhcy5zZXRBY3RpdmVPYmplY3QoY2lyY2xlKVxuICBjYW52YXMucmVuZGVyQWxsKClcblxuICByZXR1cm4gY2lyY2xlXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbGluZSBzaGFwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGluZShcbiAgY2FudmFzOiBmYWJyaWMuQ2FudmFzLFxuICBvcHRpb25zOiBTaGFwZU9wdGlvbnMgPSB7fVxuKTogZmFicmljLkxpbmUge1xuICBjb25zdCBsaW5lID0gbmV3IGZhYnJpYy5MaW5lKFxuICAgIFtcbiAgICAgIG9wdGlvbnMubGVmdCA/PyAxMDAsXG4gICAgICBvcHRpb25zLnRvcCA/PyAxMDAsXG4gICAgICAob3B0aW9ucy5sZWZ0ID8/IDEwMCkgKyAob3B0aW9ucy53aWR0aCA/PyAyMDApLFxuICAgICAgKG9wdGlvbnMudG9wID8/IDEwMCkgKyAob3B0aW9ucy5oZWlnaHQgPz8gMCksXG4gICAgXSxcbiAgICB7XG4gICAgICBzdHJva2U6IG9wdGlvbnMuc3Ryb2tlID8/ICcjNmI3MjgwJyxcbiAgICAgIHN0cm9rZVdpZHRoOiBvcHRpb25zLnN0cm9rZVdpZHRoID8/IDMsXG4gICAgICBvcGFjaXR5OiBvcHRpb25zLm9wYWNpdHkgPz8gMSxcbiAgICAgIHNlbGVjdGFibGU6IHRydWUsXG4gICAgfVxuICApXG5cbiAgY2FudmFzLmFkZChsaW5lKVxuICBjYW52YXMuc2V0QWN0aXZlT2JqZWN0KGxpbmUpXG4gIGNhbnZhcy5yZW5kZXJBbGwoKVxuXG4gIHJldHVybiBsaW5lXG59XG5cbi8qKlxuICogR2V0IHNoYXBlIGRpbWVuc2lvbnMgYW5kIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXBlRGltZW5zaW9ucyhvYmplY3Q6IGZhYnJpYy5PYmplY3QpIHtcbiAgY29uc3Qgb3JpZ2luYWxXaWR0aCA9IChvYmplY3QgYXMgYW55KS5vcmlnaW5hbFdpZHRoIHx8IG9iamVjdC53aWR0aCB8fCAwXG4gIGNvbnN0IG9yaWdpbmFsSGVpZ2h0ID0gKG9iamVjdCBhcyBhbnkpLm9yaWdpbmFsSGVpZ2h0IHx8IG9iamVjdC5oZWlnaHQgfHwgMFxuICBjb25zdCBzY2FsZVggPSBvYmplY3Quc2NhbGVYIHx8IDFcbiAgY29uc3Qgc2NhbGVZID0gb2JqZWN0LnNjYWxlWSB8fCAxXG5cbiAgcmV0dXJuIHtcbiAgICBvcmlnaW5hbFdpZHRoLFxuICAgIG9yaWdpbmFsSGVpZ2h0LFxuICAgIGN1cnJlbnRXaWR0aDogb3JpZ2luYWxXaWR0aCAqIHNjYWxlWCxcbiAgICBjdXJyZW50SGVpZ2h0OiBvcmlnaW5hbEhlaWdodCAqIHNjYWxlWSxcbiAgICBzY2FsZVgsXG4gICAgc2NhbGVZLFxuICB9XG59XG5cbi8qKlxuICogUmVzZXQgc2hhcGUgdG8gb3JpZ2luYWwgc2l6ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRTaGFwZVNpemUoXG4gIG9iamVjdDogZmFicmljLk9iamVjdFxuKToge1xuICBvcmlnaW5hbFdpZHRoOiBudW1iZXJcbiAgb3JpZ2luYWxIZWlnaHQ6IG51bWJlclxuICBjdXJyZW50V2lkdGg6IG51bWJlclxuICBjdXJyZW50SGVpZ2h0OiBudW1iZXJcbn0ge1xuICBjb25zdCBkaW1lbnNpb25zID0gZ2V0U2hhcGVEaW1lbnNpb25zKG9iamVjdClcblxuICBvYmplY3Quc2V0KHtcbiAgICBzY2FsZVg6IDEsXG4gICAgc2NhbGVZOiAxLFxuICB9KVxuICBvYmplY3Quc2V0Q29vcmRzKClcblxuICBpZiAob2JqZWN0LmNhbnZhcykge1xuICAgIG9iamVjdC5jYW52YXMucmVuZGVyQWxsKClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb3JpZ2luYWxXaWR0aDogZGltZW5zaW9ucy5vcmlnaW5hbFdpZHRoLFxuICAgIG9yaWdpbmFsSGVpZ2h0OiBkaW1lbnNpb25zLm9yaWdpbmFsSGVpZ2h0LFxuICAgIGN1cnJlbnRXaWR0aDogZGltZW5zaW9ucy5vcmlnaW5hbFdpZHRoLFxuICAgIGN1cnJlbnRIZWlnaHQ6IGRpbWVuc2lvbnMub3JpZ2luYWxIZWlnaHQsXG4gIH1cbn1cblxuLyoqXG4gKiBGbGlwIHNoYXBlIGhvcml6b250YWxseVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxpcFNoYXBlSG9yaXpvbnRhbChvYmplY3Q6IGZhYnJpYy5PYmplY3QpIHtcbiAgb2JqZWN0LnNldCgnZmxpcFgnLCAhb2JqZWN0LmZsaXBYKVxuICBvYmplY3Quc2V0Q29vcmRzKClcblxuICBpZiAob2JqZWN0LmNhbnZhcykge1xuICAgIG9iamVjdC5jYW52YXMucmVuZGVyQWxsKClcbiAgfVxufVxuXG4vKipcbiAqIEZsaXAgc2hhcGUgdmVydGljYWxseVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxpcFNoYXBlVmVydGljYWwob2JqZWN0OiBmYWJyaWMuT2JqZWN0KSB7XG4gIG9iamVjdC5zZXQoJ2ZsaXBZJywgIW9iamVjdC5mbGlwWSlcbiAgb2JqZWN0LnNldENvb3JkcygpXG5cbiAgaWYgKG9iamVjdC5jYW52YXMpIHtcbiAgICBvYmplY3QuY2FudmFzLnJlbmRlckFsbCgpXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgc2hhcGUgdHlwZSBuYW1lIGZvciBkaXNwbGF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaGFwZVR5cGVOYW1lKHR5cGU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHR5cGVNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgcmVjdDogJ+efqeW9oicsXG4gICAgY2lyY2xlOiAn5ZyG5b2iJyxcbiAgICBsaW5lOiAn55u057q/JyxcbiAgfVxuXG4gIHJldHVybiB0eXBlTWFwW3R5cGVdIHx8IHR5cGVcbn1cblxuLyoqXG4gKiDlvIDlp4vmi5bmi73nu5jliLblvaLnirZcbiAqIEBwYXJhbSBjYW52YXMgRmFicmljLmpzIENhbnZhcyDlrp7kvotcbiAqIEBwYXJhbSB0eXBlIOW9oueKtuexu+Wei1xuICogQHBhcmFtIHN0YXJ0UG9pbnQg6LW35aeL54K5XG4gKiBAcmV0dXJucyDkuLTml7blvaLnirblr7nosaFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0RHJhZ0RyYXdTaGFwZShcbiAgY2FudmFzOiBmYWJyaWMuQ2FudmFzLFxuICB0eXBlOiAncmVjdGFuZ2xlJyB8ICdjaXJjbGUnIHwgJ2xpbmUnLFxuICBzdGFydFBvaW50OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH1cbik6IGZhYnJpYy5PYmplY3QgfCBudWxsIHtcbiAgbGV0IHNoYXBlOiBmYWJyaWMuT2JqZWN0IHwgbnVsbCA9IG51bGxcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdyZWN0YW5nbGUnOlxuICAgICAgc2hhcGUgPSBuZXcgZmFicmljLlJlY3Qoe1xuICAgICAgICBsZWZ0OiBzdGFydFBvaW50LngsXG4gICAgICAgIHRvcDogc3RhcnRQb2ludC55LFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBmaWxsOiAncmdiYSg1OSwgMTMwLCAyNDYsIDAuMyknLFxuICAgICAgICBzdHJva2U6ICcjM2I4MmY2JyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgfSlcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgc2hhcGUgPSBuZXcgZmFicmljLkNpcmNsZSh7XG4gICAgICAgIGxlZnQ6IHN0YXJ0UG9pbnQueCxcbiAgICAgICAgdG9wOiBzdGFydFBvaW50LnksXG4gICAgICAgIHJhZGl1czogMCxcbiAgICAgICAgZmlsbDogJ3JnYmEoNTksIDEzMCwgMjQ2LCAwLjMpJyxcbiAgICAgICAgc3Ryb2tlOiAnIzNiODJmNicsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnbGluZSc6XG4gICAgICBzaGFwZSA9IG5ldyBmYWJyaWMuTGluZShbc3RhcnRQb2ludC54LCBzdGFydFBvaW50LnksIHN0YXJ0UG9pbnQueCwgc3RhcnRQb2ludC55XSwge1xuICAgICAgICBzdHJva2U6ICcjM2I4MmY2JyxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgICAgfSlcbiAgICAgIGJyZWFrXG4gIH1cblxuICBpZiAoc2hhcGUpIHtcbiAgICBjYW52YXMuYWRkKHNoYXBlKVxuICAgIGNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKClcbiAgfVxuXG4gIHJldHVybiBzaGFwZVxufVxuXG4vKipcbiAqIOabtOaWsOaLluaLvee7mOWItuS4reeahOW9oueKtlxuICogQHBhcmFtIHNoYXBlIOW9oueKtuWvueixoVxuICogQHBhcmFtIHR5cGUg5b2i54q257G75Z6LXG4gKiBAcGFyYW0gc3RhcnRQb2ludCDotbflp4vngrlcbiAqIEBwYXJhbSBjdXJyZW50UG9pbnQg5b2T5YmN54K5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVEcmFnRHJhd1NoYXBlKFxuICBzaGFwZTogZmFicmljLk9iamVjdCxcbiAgdHlwZTogJ3JlY3RhbmdsZScgfCAnY2lyY2xlJyB8ICdsaW5lJyxcbiAgc3RhcnRQb2ludDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9LFxuICBjdXJyZW50UG9pbnQ6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfVxuKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3JlY3RhbmdsZSc6IHtcbiAgICAgIGNvbnN0IHJlY3QgPSBzaGFwZSBhcyBmYWJyaWMuUmVjdFxuICAgICAgY29uc3Qgd2lkdGggPSBjdXJyZW50UG9pbnQueCAtIHN0YXJ0UG9pbnQueFxuICAgICAgY29uc3QgaGVpZ2h0ID0gY3VycmVudFBvaW50LnkgLSBzdGFydFBvaW50LnlcbiAgICAgIHJlY3Quc2V0KHtcbiAgICAgICAgd2lkdGg6IE1hdGguYWJzKHdpZHRoKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLmFicyhoZWlnaHQpLFxuICAgICAgICBsZWZ0OiB3aWR0aCA+IDAgPyBzdGFydFBvaW50LnggOiBjdXJyZW50UG9pbnQueCxcbiAgICAgICAgdG9wOiBoZWlnaHQgPiAwID8gc3RhcnRQb2ludC55IDogY3VycmVudFBvaW50LnksXG4gICAgICB9KVxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBjYXNlICdjaXJjbGUnOiB7XG4gICAgICBjb25zdCBjaXJjbGUgPSBzaGFwZSBhcyBmYWJyaWMuQ2lyY2xlXG4gICAgICBjb25zdCByYWRpdXMgPSBNYXRoLnNxcnQoXG4gICAgICAgIE1hdGgucG93KGN1cnJlbnRQb2ludC54IC0gc3RhcnRQb2ludC54LCAyKSArXG4gICAgICAgIE1hdGgucG93KGN1cnJlbnRQb2ludC55IC0gc3RhcnRQb2ludC55LCAyKVxuICAgICAgKVxuICAgICAgY2lyY2xlLnNldCh7IHJhZGl1cyB9KVxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBjYXNlICdsaW5lJzoge1xuICAgICAgY29uc3QgbGluZSA9IHNoYXBlIGFzIGZhYnJpYy5MaW5lXG4gICAgICBsaW5lLnNldCh7XG4gICAgICAgIHgyOiBjdXJyZW50UG9pbnQueCxcbiAgICAgICAgeTI6IGN1cnJlbnRQb2ludC55LFxuICAgICAgfSlcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgc2hhcGUuY2FudmFzPy5yZXF1ZXN0UmVuZGVyQWxsKClcbn1cblxuLyoqXG4gKiDlrozmiJDmi5bmi73nu5jliLbvvIzlm7rlrprlvaLnirZcbiAqIEBwYXJhbSBjYW52YXMgRmFicmljLmpzIENhbnZhcyDlrp7kvotcbiAqIEBwYXJhbSBzaGFwZSDkuLTml7blvaLnirblr7nosaFcbiAqIEBwYXJhbSB0eXBlIOW9oueKtuexu+Wei1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmluaXNoRHJhZ0RyYXdTaGFwZShcbiAgY2FudmFzOiBmYWJyaWMuQ2FudmFzLFxuICBzaGFwZTogZmFicmljLk9iamVjdCxcbiAgdHlwZTogJ3JlY3RhbmdsZScgfCAnY2lyY2xlJyB8ICdsaW5lJ1xuKSB7XG4gIC8vIOenu+mZpOS4tOaXtuW9oueKtlxuICBjYW52YXMucmVtb3ZlKHNoYXBlKVxuXG4gIC8vIOWIm+W7uuacgOe7iOW9oueKtu+8iOS9v+eUqOm7mOiupOagt+W8j++8iVxuICBjb25zdCBmaW5hbFNoYXBlID0gY3JlYXRlU2hhcGVCeVR5cGUoY2FudmFzLCB0eXBlLCB7XG4gICAgbGVmdDogc2hhcGUubGVmdCxcbiAgICB0b3A6IHNoYXBlLnRvcCxcbiAgICAuLi4odHlwZSA9PT0gJ3JlY3RhbmdsZScgJiYgeyB3aWR0aDogKHNoYXBlIGFzIGZhYnJpYy5SZWN0KS53aWR0aCwgaGVpZ2h0OiAoc2hhcGUgYXMgZmFicmljLlJlY3QpLmhlaWdodCB9KSxcbiAgICAuLi4odHlwZSA9PT0gJ2NpcmNsZScgJiYgeyByYWRpdXM6IChzaGFwZSBhcyBmYWJyaWMuQ2lyY2xlKS5yYWRpdXMgfSksXG4gICAgLi4uKHR5cGUgPT09ICdsaW5lJyAmJiB7XG4gICAgICB4MTogKHNoYXBlIGFzIGZhYnJpYy5MaW5lKS54MSxcbiAgICAgIHkxOiAoc2hhcGUgYXMgZmFicmljLkxpbmUpLnkxLFxuICAgICAgeDI6IChzaGFwZSBhcyBmYWJyaWMuTGluZSkueDIsXG4gICAgICB5MjogKHNoYXBlIGFzIGZhYnJpYy5MaW5lKS55MixcbiAgICB9KSxcbiAgfSlcblxuICBjYW52YXMuc2V0QWN0aXZlT2JqZWN0KGZpbmFsU2hhcGUpXG4gIGNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKClcbn1cblxuLyoqXG4gKiDmoLnmja7nsbvlnovliJvlu7rlvaLnirbvvIjlhoXpg6jovoXliqnlh73mlbDvvIlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2hhcGVCeVR5cGUoXG4gIGNhbnZhczogZmFicmljLkNhbnZhcyxcbiAgdHlwZTogJ3JlY3RhbmdsZScgfCAnY2lyY2xlJyB8ICdsaW5lJyxcbiAgb3B0aW9uczogYW55XG4pOiBmYWJyaWMuT2JqZWN0IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAncmVjdGFuZ2xlJzpcbiAgICAgIHJldHVybiBjcmVhdGVSZWN0YW5nbGUoY2FudmFzLCBvcHRpb25zKVxuICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICByZXR1cm4gY3JlYXRlQ2lyY2xlKGNhbnZhcywgb3B0aW9ucylcbiAgICBjYXNlICdsaW5lJzpcbiAgICAgIHJldHVybiBjcmVhdGVMaW5lKGNhbnZhcywgb3B0aW9ucylcbiAgfVxufVxuIl0sIm5hbWVzIjpbImZhYnJpYyIsImNyZWF0ZVJlY3RhbmdsZSIsImNhbnZhcyIsIm9wdGlvbnMiLCJyZWN0IiwiUmVjdCIsImxlZnQiLCJ0b3AiLCJ3aWR0aCIsImhlaWdodCIsImZpbGwiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsIm9wYWNpdHkiLCJzZWxlY3RhYmxlIiwiYWRkIiwic2V0QWN0aXZlT2JqZWN0IiwicmVuZGVyQWxsIiwiY3JlYXRlQ2lyY2xlIiwiY2lyY2xlIiwiQ2lyY2xlIiwicmFkaXVzIiwiY3JlYXRlTGluZSIsImxpbmUiLCJMaW5lIiwiZ2V0U2hhcGVEaW1lbnNpb25zIiwib2JqZWN0Iiwib3JpZ2luYWxXaWR0aCIsIm9yaWdpbmFsSGVpZ2h0Iiwic2NhbGVYIiwic2NhbGVZIiwiY3VycmVudFdpZHRoIiwiY3VycmVudEhlaWdodCIsInJlc2V0U2hhcGVTaXplIiwiZGltZW5zaW9ucyIsInNldCIsInNldENvb3JkcyIsImZsaXBTaGFwZUhvcml6b250YWwiLCJmbGlwWCIsImZsaXBTaGFwZVZlcnRpY2FsIiwiZmxpcFkiLCJnZXRTaGFwZVR5cGVOYW1lIiwidHlwZSIsInR5cGVNYXAiLCJzdGFydERyYWdEcmF3U2hhcGUiLCJzdGFydFBvaW50Iiwic2hhcGUiLCJ4IiwieSIsInJlcXVlc3RSZW5kZXJBbGwiLCJ1cGRhdGVEcmFnRHJhd1NoYXBlIiwiY3VycmVudFBvaW50IiwiTWF0aCIsImFicyIsInNxcnQiLCJwb3ciLCJ4MiIsInkyIiwiZmluaXNoRHJhZ0RyYXdTaGFwZSIsInJlbW92ZSIsImZpbmFsU2hhcGUiLCJjcmVhdGVTaGFwZUJ5VHlwZSIsIngxIiwieTEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/fabric/shape.ts\n"));

/***/ })

});