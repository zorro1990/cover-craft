/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fabric";
exports.ids = ["vendor-chunks/fabric"];
exports.modules = {

/***/ "(ssr)/../../node_modules/fabric/dist/fabric.js":
/*!************************************************!*\
  !*** ../../node_modules/fabric/dist/fabric.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* build: `node build.js modules=ALL exclude=gestures,accessors,erasing requirejs minifier=uglifyjs` */ /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */ var fabric = fabric || {\n    version: \"5.3.0\"\n};\nif (true) {\n    exports.fabric = fabric;\n} else {}\n/* _AMD_END_ */ if (typeof document !== \"undefined\" && \"undefined\" !== \"undefined\") {} else {\n    // assume we're running under node.js when document/window are not present\n    var jsdom = __webpack_require__(/*! jsdom */ \"(ssr)/../../node_modules/jsdom/lib/api.js\");\n    var virtualWindow = new jsdom.JSDOM(decodeURIComponent(\"%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E\"), {\n        features: {\n            FetchExternalResources: [\n                \"img\"\n            ]\n        },\n        resources: \"usable\"\n    }).window;\n    fabric.document = virtualWindow.document;\n    fabric.jsdomImplForWrapper = (__webpack_require__(/*! jsdom/lib/jsdom/living/generated/utils */ \"(ssr)/../../node_modules/jsdom/lib/jsdom/living/generated/utils.js\").implForWrapper);\n    fabric.nodeCanvas = (__webpack_require__(/*! jsdom/lib/jsdom/utils */ \"(ssr)/../../node_modules/jsdom/lib/jsdom/utils.js\").Canvas);\n    fabric.window = virtualWindow;\n    DOMParser = fabric.window.DOMParser;\n}\n/**\n * True when in environment that supports touch events\n * @type boolean\n */ fabric.isTouchSupported = \"ontouchstart\" in fabric.window || \"ontouchstart\" in fabric.document || fabric.window && fabric.window.navigator && fabric.window.navigator.maxTouchPoints > 0;\n/**\n * True when in environment that's probably Node.js\n * @type boolean\n */ fabric.isLikelyNode = typeof Buffer !== \"undefined\" && \"undefined\" === \"undefined\";\n/* _FROM_SVG_START_ */ /**\n * Attributes parsed from all SVG elements\n * @type array\n */ fabric.SHARED_ATTRIBUTES = [\n    \"display\",\n    \"transform\",\n    \"fill\",\n    \"fill-opacity\",\n    \"fill-rule\",\n    \"opacity\",\n    \"stroke\",\n    \"stroke-dasharray\",\n    \"stroke-linecap\",\n    \"stroke-dashoffset\",\n    \"stroke-linejoin\",\n    \"stroke-miterlimit\",\n    \"stroke-opacity\",\n    \"stroke-width\",\n    \"id\",\n    \"paint-order\",\n    \"vector-effect\",\n    \"instantiated_by_use\",\n    \"clip-path\"\n];\n/* _FROM_SVG_END_ */ /**\n * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.\n */ fabric.DPI = 96;\nfabric.reNum = \"(?:[-+]?(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[eE][-+]?\\\\d+)?)\";\nfabric.commaWsp = \"(?:\\\\s+,?\\\\s*|,\\\\s*)\";\nfabric.rePathCommand = /([-+]?((\\d+\\.\\d+)|((\\d+)|(\\.\\d+)))(?:[eE][-+]?\\d+)?)/ig;\nfabric.reNonWord = /[ \\n\\.,;!\\?\\-]/;\nfabric.fontPaths = {};\nfabric.iMatrix = [\n    1,\n    0,\n    0,\n    1,\n    0,\n    0\n];\nfabric.svgNS = \"http://www.w3.org/2000/svg\";\n/**\n * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.\n * @since 1.7.14\n * @type Number\n * @default\n */ fabric.perfLimitSizeTotal = 2097152;\n/**\n * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000\n * @since 1.7.14\n * @type Number\n * @default\n */ fabric.maxCacheSideLimit = 4096;\n/**\n * Lowest pixel limit for cache canvases, set at 256PX\n * @since 1.7.14\n * @type Number\n * @default\n */ fabric.minCacheSideLimit = 256;\n/**\n * Cache Object for widths of chars in text rendering.\n */ fabric.charWidthsCache = {};\n/**\n * if webgl is enabled and available, textureSize will determine the size\n * of the canvas backend\n * @since 2.0.0\n * @type Number\n * @default\n */ fabric.textureSize = 2048;\n/**\n * When 'true', style information is not retained when copy/pasting text, making\n * pasted text use destination style.\n * Defaults to 'false'.\n * @type Boolean\n * @default\n */ fabric.disableStyleCopyPaste = false;\n/**\n * Enable webgl for filtering picture is available\n * A filtering backend will be initialized, this will both take memory and\n * time since a default 2048x2048 canvas will be created for the gl context\n * @since 2.0.0\n * @type Boolean\n * @default\n */ fabric.enableGLFiltering = true;\n/**\n * Device Pixel Ratio\n * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html\n */ fabric.devicePixelRatio = fabric.window.devicePixelRatio || fabric.window.webkitDevicePixelRatio || fabric.window.mozDevicePixelRatio || 1;\n/**\n * Browser-specific constant to adjust CanvasRenderingContext2D.shadowBlur value,\n * which is unitless and not rendered equally across browsers.\n *\n * Values that work quite well (as of October 2017) are:\n * - Chrome: 1.5\n * - Edge: 1.75\n * - Firefox: 0.9\n * - Safari: 0.95\n *\n * @since 2.0.0\n * @type Number\n * @default 1\n */ fabric.browserShadowBlurConstant = 1;\n/**\n * This object contains the result of arc to bezier conversion for faster retrieving if the same arc needs to be converted again.\n * It was an internal variable, is accessible since version 2.3.4\n */ fabric.arcToSegmentsCache = {};\n/**\n * This object keeps the results of the boundsOfCurve calculation mapped by the joined arguments necessary to calculate it.\n * It does speed up calculation, if you parse and add always the same paths, but in case of heavy usage of freedrawing\n * you do not get any speed benefit and you get a big object in memory.\n * The object was a private variable before, while now is appended to the lib so that you have access to it and you\n * can eventually clear it.\n * It was an internal variable, is accessible since version 2.3.4\n */ fabric.boundsOfCurveCache = {};\n/**\n * If disabled boundsOfCurveCache is not used. For apps that make heavy usage of pencil drawing probably disabling it is better\n * @default true\n */ fabric.cachesBoundsOfCurve = true;\n/**\n * Skip performance testing of setupGLContext and force the use of putImageData that seems to be the one that works best on\n * Chrome + old hardware. if your users are experiencing empty images after filtering you may try to force this to true\n * this has to be set before instantiating the filtering backend ( before filtering the first image )\n * @type Boolean\n * @default false\n */ fabric.forceGLPutImageData = false;\nfabric.initFilterBackend = function() {\n    if (fabric.enableGLFiltering && fabric.isWebglSupported && fabric.isWebglSupported(fabric.textureSize)) {\n        console.log(\"max texture size: \" + fabric.maxTextureSize);\n        return new fabric.WebglFilterBackend({\n            tileSize: fabric.textureSize\n        });\n    } else if (fabric.Canvas2dFilterBackend) {\n        return new fabric.Canvas2dFilterBackend();\n    }\n};\nif (typeof document !== \"undefined\" && \"undefined\" !== \"undefined\") {}\n(function() {\n    /**\n   * @private\n   * @param {String} eventName\n   * @param {Function} handler\n   */ function _removeEventListener(eventName, handler) {\n        if (!this.__eventListeners[eventName]) {\n            return;\n        }\n        var eventListener = this.__eventListeners[eventName];\n        if (handler) {\n            eventListener[eventListener.indexOf(handler)] = false;\n        } else {\n            fabric.util.array.fill(eventListener, false);\n        }\n    }\n    /**\n   * Observes specified event\n   * @memberOf fabric.Observable\n   * @alias on\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\n   * @param {Function} handler Function that receives a notification when an event of the specified type occurs\n   * @return {Self} thisArg\n   * @chainable\n   */ function on(eventName, handler) {\n        if (!this.__eventListeners) {\n            this.__eventListeners = {};\n        }\n        // one object with key/value pairs was passed\n        if (arguments.length === 1) {\n            for(var prop in eventName){\n                this.on(prop, eventName[prop]);\n            }\n        } else {\n            if (!this.__eventListeners[eventName]) {\n                this.__eventListeners[eventName] = [];\n            }\n            this.__eventListeners[eventName].push(handler);\n        }\n        return this;\n    }\n    function _once(eventName, handler) {\n        var _handler = (function() {\n            handler.apply(this, arguments);\n            this.off(eventName, _handler);\n        }).bind(this);\n        this.on(eventName, _handler);\n    }\n    function once(eventName, handler) {\n        // one object with key/value pairs was passed\n        if (arguments.length === 1) {\n            for(var prop in eventName){\n                _once.call(this, prop, eventName[prop]);\n            }\n        } else {\n            _once.call(this, eventName, handler);\n        }\n        return this;\n    }\n    /**\n   * Stops event observing for a particular event handler. Calling this method\n   * without arguments removes all handlers for all events\n   * @memberOf fabric.Observable\n   * @alias off\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\n   * @param {Function} handler Function to be deleted from EventListeners\n   * @return {Self} thisArg\n   * @chainable\n   */ function off(eventName, handler) {\n        if (!this.__eventListeners) {\n            return this;\n        }\n        // remove all key/value pairs (event name -> event handler)\n        if (arguments.length === 0) {\n            for(eventName in this.__eventListeners){\n                _removeEventListener.call(this, eventName);\n            }\n        } else if (arguments.length === 1 && typeof arguments[0] === \"object\") {\n            for(var prop in eventName){\n                _removeEventListener.call(this, prop, eventName[prop]);\n            }\n        } else {\n            _removeEventListener.call(this, eventName, handler);\n        }\n        return this;\n    }\n    /**\n   * Fires event with an optional options object\n   * @memberOf fabric.Observable\n   * @param {String} eventName Event name to fire\n   * @param {Object} [options] Options object\n   * @return {Self} thisArg\n   * @chainable\n   */ function fire(eventName, options) {\n        if (!this.__eventListeners) {\n            return this;\n        }\n        var listenersForEvent = this.__eventListeners[eventName];\n        if (!listenersForEvent) {\n            return this;\n        }\n        for(var i = 0, len = listenersForEvent.length; i < len; i++){\n            listenersForEvent[i] && listenersForEvent[i].call(this, options || {});\n        }\n        this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {\n            return value !== false;\n        });\n        return this;\n    }\n    /**\n   * @namespace fabric.Observable\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}\n   * @see {@link http://fabricjs.com/events|Events demo}\n   */ fabric.Observable = {\n        fire: fire,\n        on: on,\n        once: once,\n        off: off\n    };\n})();\n/**\n * @namespace fabric.Collection\n */ fabric.Collection = {\n    _objects: [],\n    /**\n   * Adds objects to collection, Canvas or Group, then renders canvas\n   * (if `renderOnAddRemove` is not `false`).\n   * in case of Group no changes to bounding box are made.\n   * Objects should be instances of (or inherit from) fabric.Object\n   * Use of this function is highly discouraged for groups.\n   * you can add a bunch of objects with the add method but then you NEED\n   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.\n   * @param {...fabric.Object} object Zero or more fabric instances\n   * @return {Self} thisArg\n   * @chainable\n   */ add: function() {\n        this._objects.push.apply(this._objects, arguments);\n        if (this._onObjectAdded) {\n            for(var i = 0, length = arguments.length; i < length; i++){\n                this._onObjectAdded(arguments[i]);\n            }\n        }\n        this.renderOnAddRemove && this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)\n   * An object should be an instance of (or inherit from) fabric.Object\n   * Use of this function is highly discouraged for groups.\n   * you can add a bunch of objects with the insertAt method but then you NEED\n   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.\n   * @param {Object} object Object to insert\n   * @param {Number} index Index to insert object at\n   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs\n   * @return {Self} thisArg\n   * @chainable\n   */ insertAt: function(object, index, nonSplicing) {\n        var objects = this._objects;\n        if (nonSplicing) {\n            objects[index] = object;\n        } else {\n            objects.splice(index, 0, object);\n        }\n        this._onObjectAdded && this._onObjectAdded(object);\n        this.renderOnAddRemove && this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)\n   * @param {...fabric.Object} object Zero or more fabric instances\n   * @return {Self} thisArg\n   * @chainable\n   */ remove: function() {\n        var objects = this._objects, index, somethingRemoved = false;\n        for(var i = 0, length = arguments.length; i < length; i++){\n            index = objects.indexOf(arguments[i]);\n            // only call onObjectRemoved if an object was actually removed\n            if (index !== -1) {\n                somethingRemoved = true;\n                objects.splice(index, 1);\n                this._onObjectRemoved && this._onObjectRemoved(arguments[i]);\n            }\n        }\n        this.renderOnAddRemove && somethingRemoved && this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Executes given function for each object in this group\n   * @param {Function} callback\n   *                   Callback invoked with current object as first argument,\n   *                   index - as second and an array of all objects - as third.\n   *                   Callback is invoked in a context of Global Object (e.g. `window`)\n   *                   when no `context` argument is given\n   *\n   * @param {Object} context Context (aka thisObject)\n   * @return {Self} thisArg\n   * @chainable\n   */ forEachObject: function(callback, context) {\n        var objects = this.getObjects();\n        for(var i = 0, len = objects.length; i < len; i++){\n            callback.call(context, objects[i], i, objects);\n        }\n        return this;\n    },\n    /**\n   * Returns an array of children objects of this instance\n   * Type parameter introduced in 1.3.10\n   * since 2.3.5 this method return always a COPY of the array;\n   * @param {String} [type] When specified, only objects of this type are returned\n   * @return {Array}\n   */ getObjects: function(type) {\n        if (typeof type === \"undefined\") {\n            return this._objects.concat();\n        }\n        return this._objects.filter(function(o) {\n            return o.type === type;\n        });\n    },\n    /**\n   * Returns object at specified index\n   * @param {Number} index\n   * @return {Self} thisArg\n   */ item: function(index) {\n        return this._objects[index];\n    },\n    /**\n   * Returns true if collection contains no objects\n   * @return {Boolean} true if collection is empty\n   */ isEmpty: function() {\n        return this._objects.length === 0;\n    },\n    /**\n   * Returns a size of a collection (i.e: length of an array containing its objects)\n   * @return {Number} Collection size\n   */ size: function() {\n        return this._objects.length;\n    },\n    /**\n   * Returns true if collection contains an object\n   * @param {Object} object Object to check against\n   * @param {Boolean} [deep=false] `true` to check all descendants, `false` to check only `_objects`\n   * @return {Boolean} `true` if collection contains an object\n   */ contains: function(object, deep) {\n        if (this._objects.indexOf(object) > -1) {\n            return true;\n        } else if (deep) {\n            return this._objects.some(function(obj) {\n                return typeof obj.contains === \"function\" && obj.contains(object, true);\n            });\n        }\n        return false;\n    },\n    /**\n   * Returns number representation of a collection complexity\n   * @return {Number} complexity\n   */ complexity: function() {\n        return this._objects.reduce(function(memo, current) {\n            memo += current.complexity ? current.complexity() : 0;\n            return memo;\n        }, 0);\n    }\n};\n/**\n * @namespace fabric.CommonMethods\n */ fabric.CommonMethods = {\n    /**\n   * Sets object's properties from options\n   * @param {Object} [options] Options object\n   */ _setOptions: function(options) {\n        for(var prop in options){\n            this.set(prop, options[prop]);\n        }\n    },\n    /**\n   * @private\n   * @param {Object} [filler] Options object\n   * @param {String} [property] property to set the Gradient to\n   */ _initGradient: function(filler, property) {\n        if (filler && filler.colorStops && !(filler instanceof fabric.Gradient)) {\n            this.set(property, new fabric.Gradient(filler));\n        }\n    },\n    /**\n   * @private\n   * @param {Object} [filler] Options object\n   * @param {String} [property] property to set the Pattern to\n   * @param {Function} [callback] callback to invoke after pattern load\n   */ _initPattern: function(filler, property, callback) {\n        if (filler && filler.source && !(filler instanceof fabric.Pattern)) {\n            this.set(property, new fabric.Pattern(filler, callback));\n        } else {\n            callback && callback();\n        }\n    },\n    /**\n   * @private\n   */ _setObject: function(obj) {\n        for(var prop in obj){\n            this._set(prop, obj[prop]);\n        }\n    },\n    /**\n   * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.\n   * @param {String|Object} key Property name or object (if object, iterate over the object properties)\n   * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ set: function(key, value) {\n        if (typeof key === \"object\") {\n            this._setObject(key);\n        } else {\n            this._set(key, value);\n        }\n        return this;\n    },\n    _set: function(key, value) {\n        this[key] = value;\n    },\n    /**\n   * Toggles specified property from `true` to `false` or from `false` to `true`\n   * @param {String} property Property to toggle\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ toggle: function(property) {\n        var value = this.get(property);\n        if (typeof value === \"boolean\") {\n            this.set(property, !value);\n        }\n        return this;\n    },\n    /**\n   * Basic getter\n   * @param {String} property Property name\n   * @return {*} value of a property\n   */ get: function(property) {\n        return this[property];\n    }\n};\n(function(global) {\n    var sqrt = Math.sqrt, atan2 = Math.atan2, pow = Math.pow, PiBy180 = Math.PI / 180, PiBy2 = Math.PI / 2;\n    /**\n   * @namespace fabric.util\n   */ fabric.util = {\n        /**\n     * Calculate the cos of an angle, avoiding returning floats for known results\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} angle the angle in radians or in degree\n     * @return {Number}\n     */ cos: function(angle) {\n            if (angle === 0) {\n                return 1;\n            }\n            if (angle < 0) {\n                // cos(a) = cos(-a)\n                angle = -angle;\n            }\n            var angleSlice = angle / PiBy2;\n            switch(angleSlice){\n                case 1:\n                case 3:\n                    return 0;\n                case 2:\n                    return -1;\n            }\n            return Math.cos(angle);\n        },\n        /**\n     * Calculate the sin of an angle, avoiding returning floats for known results\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} angle the angle in radians or in degree\n     * @return {Number}\n     */ sin: function(angle) {\n            if (angle === 0) {\n                return 0;\n            }\n            var angleSlice = angle / PiBy2, sign = 1;\n            if (angle < 0) {\n                // sin(-a) = -sin(a)\n                sign = -1;\n            }\n            switch(angleSlice){\n                case 1:\n                    return sign;\n                case 2:\n                    return 0;\n                case 3:\n                    return -sign;\n            }\n            return Math.sin(angle);\n        },\n        /**\n     * Removes value from an array.\n     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} array\n     * @param {*} value\n     * @return {Array} original array\n     */ removeFromArray: function(array, value) {\n            var idx = array.indexOf(value);\n            if (idx !== -1) {\n                array.splice(idx, 1);\n            }\n            return array;\n        },\n        /**\n     * Returns random number between 2 specified ones.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} min lower limit\n     * @param {Number} max upper limit\n     * @return {Number} random value (between min and max)\n     */ getRandomInt: function(min, max) {\n            return Math.floor(Math.random() * (max - min + 1)) + min;\n        },\n        /**\n     * Transforms degrees to radians.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} degrees value in degrees\n     * @return {Number} value in radians\n     */ degreesToRadians: function(degrees) {\n            return degrees * PiBy180;\n        },\n        /**\n     * Transforms radians to degrees.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} radians value in radians\n     * @return {Number} value in degrees\n     */ radiansToDegrees: function(radians) {\n            return radians / PiBy180;\n        },\n        /**\n     * Rotates `point` around `origin` with `radians`\n     * @static\n     * @memberOf fabric.util\n     * @param {fabric.Point} point The point to rotate\n     * @param {fabric.Point} origin The origin of the rotation\n     * @param {Number} radians The radians of the angle for the rotation\n     * @return {fabric.Point} The new rotated point\n     */ rotatePoint: function(point, origin, radians) {\n            var newPoint = new fabric.Point(point.x - origin.x, point.y - origin.y), v = fabric.util.rotateVector(newPoint, radians);\n            return new fabric.Point(v.x, v.y).addEquals(origin);\n        },\n        /**\n     * Rotates `vector` with `radians`\n     * @static\n     * @memberOf fabric.util\n     * @param {Object} vector The vector to rotate (x and y)\n     * @param {Number} radians The radians of the angle for the rotation\n     * @return {Object} The new rotated point\n     */ rotateVector: function(vector, radians) {\n            var sin = fabric.util.sin(radians), cos = fabric.util.cos(radians), rx = vector.x * cos - vector.y * sin, ry = vector.x * sin + vector.y * cos;\n            return {\n                x: rx,\n                y: ry\n            };\n        },\n        /**\n     * Creates a vetor from points represented as a point\n     * @static\n     * @memberOf fabric.util\n     *\n     * @typedef {Object} Point\n     * @property {number} x\n     * @property {number} y\n     *\n     * @param {Point} from\n     * @param {Point} to\n     * @returns {Point} vector\n     */ createVector: function(from, to) {\n            return new fabric.Point(to.x - from.x, to.y - from.y);\n        },\n        /**\n     * Calculates angle between 2 vectors using dot product\n     * @static\n     * @memberOf fabric.util\n     * @param {Point} a\n     * @param {Point} b\n     * @returns the angle in radian between the vectors\n     */ calcAngleBetweenVectors: function(a, b) {\n            return Math.acos((a.x * b.x + a.y * b.y) / (Math.hypot(a.x, a.y) * Math.hypot(b.x, b.y)));\n        },\n        /**\n     * @static\n     * @memberOf fabric.util\n     * @param {Point} v\n     * @returns {Point} vector representing the unit vector of pointing to the direction of `v`\n     */ getHatVector: function(v) {\n            return new fabric.Point(v.x, v.y).multiply(1 / Math.hypot(v.x, v.y));\n        },\n        /**\n     * @static\n     * @memberOf fabric.util\n     * @param {Point} A\n     * @param {Point} B\n     * @param {Point} C\n     * @returns {{ vector: Point, angle: number }} vector representing the bisector of A and A's angle\n     */ getBisector: function(A, B, C) {\n            var AB = fabric.util.createVector(A, B), AC = fabric.util.createVector(A, C);\n            var alpha = fabric.util.calcAngleBetweenVectors(AB, AC);\n            //  check if alpha is relative to AB->BC\n            var ro = fabric.util.calcAngleBetweenVectors(fabric.util.rotateVector(AB, alpha), AC);\n            var phi = alpha * (ro === 0 ? 1 : -1) / 2;\n            return {\n                vector: fabric.util.getHatVector(fabric.util.rotateVector(AB, phi)),\n                angle: alpha\n            };\n        },\n        /**\n     * Project stroke width on points returning 2 projections for each point as follows:\n     * - `miter`: 2 points corresponding to the outer boundary and the inner boundary of stroke.\n     * - `bevel`: 2 points corresponding to the bevel boundaries, tangent to the bisector.\n     * - `round`: same as `bevel`\n     * Used to calculate object's bounding box\n     * @static\n     * @memberOf fabric.util\n     * @param {Point[]} points\n     * @param {Object} options\n     * @param {number} options.strokeWidth\n     * @param {'miter'|'bevel'|'round'} options.strokeLineJoin\n     * @param {number} options.strokeMiterLimit https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit\n     * @param {boolean} options.strokeUniform\n     * @param {number} options.scaleX\n     * @param {number} options.scaleY\n     * @param {boolean} [openPath] whether the shape is open or not, affects the calculations of the first and last points\n     * @returns {fabric.Point[]} array of size 2n/4n of all suspected points\n     */ projectStrokeOnPoints: function(points, options, openPath) {\n            var coords = [], s = options.strokeWidth / 2, strokeUniformScalar = options.strokeUniform ? new fabric.Point(1 / options.scaleX, 1 / options.scaleY) : new fabric.Point(1, 1), getStrokeHatVector = function(v) {\n                var scalar = s / Math.hypot(v.x, v.y);\n                return new fabric.Point(v.x * scalar * strokeUniformScalar.x, v.y * scalar * strokeUniformScalar.y);\n            };\n            if (points.length <= 1) {\n                return coords;\n            }\n            points.forEach(function(p, index) {\n                var A = new fabric.Point(p.x, p.y), B, C;\n                if (index === 0) {\n                    C = points[index + 1];\n                    B = openPath ? getStrokeHatVector(fabric.util.createVector(C, A)).addEquals(A) : points[points.length - 1];\n                } else if (index === points.length - 1) {\n                    B = points[index - 1];\n                    C = openPath ? getStrokeHatVector(fabric.util.createVector(B, A)).addEquals(A) : points[0];\n                } else {\n                    B = points[index - 1];\n                    C = points[index + 1];\n                }\n                var bisector = fabric.util.getBisector(A, B, C), bisectorVector = bisector.vector, alpha = bisector.angle, scalar, miterVector;\n                if (options.strokeLineJoin === \"miter\") {\n                    scalar = -s / Math.sin(alpha / 2);\n                    miterVector = new fabric.Point(bisectorVector.x * scalar * strokeUniformScalar.x, bisectorVector.y * scalar * strokeUniformScalar.y);\n                    if (Math.hypot(miterVector.x, miterVector.y) / s <= options.strokeMiterLimit) {\n                        coords.push(A.add(miterVector));\n                        coords.push(A.subtract(miterVector));\n                        return;\n                    }\n                }\n                scalar = -s * Math.SQRT2;\n                miterVector = new fabric.Point(bisectorVector.x * scalar * strokeUniformScalar.x, bisectorVector.y * scalar * strokeUniformScalar.y);\n                coords.push(A.add(miterVector));\n                coords.push(A.subtract(miterVector));\n            });\n            return coords;\n        },\n        /**\n     * Apply transform t to point p\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Point} p The point to transform\n     * @param  {Array} t The transform\n     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied\n     * @return {fabric.Point} The transformed point\n     */ transformPoint: function(p, t, ignoreOffset) {\n            if (ignoreOffset) {\n                return new fabric.Point(t[0] * p.x + t[2] * p.y, t[1] * p.x + t[3] * p.y);\n            }\n            return new fabric.Point(t[0] * p.x + t[2] * p.y + t[4], t[1] * p.x + t[3] * p.y + t[5]);\n        },\n        /**\n     * Returns coordinates of points's bounding rectangle (left, top, width, height)\n     * @param {Array} points 4 points array\n     * @param {Array} [transform] an array of 6 numbers representing a 2x3 transform matrix\n     * @return {Object} Object with left, top, width, height properties\n     */ makeBoundingBoxFromPoints: function(points, transform) {\n            if (transform) {\n                for(var i = 0; i < points.length; i++){\n                    points[i] = fabric.util.transformPoint(points[i], transform);\n                }\n            }\n            var xPoints = [\n                points[0].x,\n                points[1].x,\n                points[2].x,\n                points[3].x\n            ], minX = fabric.util.array.min(xPoints), maxX = fabric.util.array.max(xPoints), width = maxX - minX, yPoints = [\n                points[0].y,\n                points[1].y,\n                points[2].y,\n                points[3].y\n            ], minY = fabric.util.array.min(yPoints), maxY = fabric.util.array.max(yPoints), height = maxY - minY;\n            return {\n                left: minX,\n                top: minY,\n                width: width,\n                height: height\n            };\n        },\n        /**\n     * Invert transformation t\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} t The transform\n     * @return {Array} The inverted transform\n     */ invertTransform: function(t) {\n            var a = 1 / (t[0] * t[3] - t[1] * t[2]), r = [\n                a * t[3],\n                -a * t[1],\n                -a * t[2],\n                a * t[0]\n            ], o = fabric.util.transformPoint({\n                x: t[4],\n                y: t[5]\n            }, r, true);\n            r[4] = -o.x;\n            r[5] = -o.y;\n            return r;\n        },\n        /**\n     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number|String} number number to operate on\n     * @param {Number} fractionDigits number of fraction digits to \"leave\"\n     * @return {Number}\n     */ toFixed: function(number, fractionDigits) {\n            return parseFloat(Number(number).toFixed(fractionDigits));\n        },\n        /**\n     * Converts from attribute value to pixel value if applicable.\n     * Returns converted pixels or original value not converted.\n     * @param {Number|String} value number to operate on\n     * @param {Number} fontSize\n     * @return {Number|String}\n     */ parseUnit: function(value, fontSize) {\n            var unit = /\\D{0,2}$/.exec(value), number = parseFloat(value);\n            if (!fontSize) {\n                fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\n            }\n            switch(unit[0]){\n                case \"mm\":\n                    return number * fabric.DPI / 25.4;\n                case \"cm\":\n                    return number * fabric.DPI / 2.54;\n                case \"in\":\n                    return number * fabric.DPI;\n                case \"pt\":\n                    return number * fabric.DPI / 72; // or * 4 / 3\n                case \"pc\":\n                    return number * fabric.DPI / 72 * 12; // or * 16\n                case \"em\":\n                    return number * fontSize;\n                default:\n                    return number;\n            }\n        },\n        /**\n     * Function which always returns `false`.\n     * @static\n     * @memberOf fabric.util\n     * @return {Boolean}\n     */ falseFunction: function() {\n            return false;\n        },\n        /**\n     * Returns klass \"Class\" object of given namespace\n     * @memberOf fabric.util\n     * @param {String} type Type of object (eg. 'circle')\n     * @param {String} namespace Namespace to get klass \"Class\" object from\n     * @return {Object} klass \"Class\"\n     */ getKlass: function(type, namespace) {\n            // capitalize first letter only\n            type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));\n            return fabric.util.resolveNamespace(namespace)[type];\n        },\n        /**\n     * Returns array of attributes for given svg that fabric parses\n     * @memberOf fabric.util\n     * @param {String} type Type of svg element (eg. 'circle')\n     * @return {Array} string names of supported attributes\n     */ getSvgAttributes: function(type) {\n            var attributes = [\n                \"instantiated_by_use\",\n                \"style\",\n                \"id\",\n                \"class\"\n            ];\n            switch(type){\n                case \"linearGradient\":\n                    attributes = attributes.concat([\n                        \"x1\",\n                        \"y1\",\n                        \"x2\",\n                        \"y2\",\n                        \"gradientUnits\",\n                        \"gradientTransform\"\n                    ]);\n                    break;\n                case \"radialGradient\":\n                    attributes = attributes.concat([\n                        \"gradientUnits\",\n                        \"gradientTransform\",\n                        \"cx\",\n                        \"cy\",\n                        \"r\",\n                        \"fx\",\n                        \"fy\",\n                        \"fr\"\n                    ]);\n                    break;\n                case \"stop\":\n                    attributes = attributes.concat([\n                        \"offset\",\n                        \"stop-color\",\n                        \"stop-opacity\"\n                    ]);\n                    break;\n            }\n            return attributes;\n        },\n        /**\n     * Returns object of given namespace\n     * @memberOf fabric.util\n     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'\n     * @return {Object} Object for given namespace (default fabric)\n     */ resolveNamespace: function(namespace) {\n            if (!namespace) {\n                return fabric;\n            }\n            var parts = namespace.split(\".\"), len = parts.length, i, obj = global || fabric.window;\n            for(i = 0; i < len; ++i){\n                obj = obj[parts[i]];\n            }\n            return obj;\n        },\n        /**\n     * Loads image element from given url and passes it to a callback\n     * @memberOf fabric.util\n     * @param {String} url URL representing an image\n     * @param {Function} callback Callback; invoked with loaded image\n     * @param {*} [context] Context to invoke callback in\n     * @param {Object} [crossOrigin] crossOrigin value to set image element to\n     */ loadImage: function(url, callback, context, crossOrigin) {\n            if (!url) {\n                callback && callback.call(context, url);\n                return;\n            }\n            var img = fabric.util.createImage();\n            /** @ignore */ var onLoadCallback = function() {\n                callback && callback.call(context, img, false);\n                img = img.onload = img.onerror = null;\n            };\n            img.onload = onLoadCallback;\n            /** @ignore */ img.onerror = function() {\n                fabric.log(\"Error loading \" + img.src);\n                callback && callback.call(context, null, true);\n                img = img.onload = img.onerror = null;\n            };\n            // data-urls appear to be buggy with crossOrigin\n            // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767\n            // see https://code.google.com/p/chromium/issues/detail?id=315152\n            //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069\n            // crossOrigin null is the same as not set.\n            if (url.indexOf(\"data\") !== 0 && crossOrigin !== undefined && crossOrigin !== null) {\n                img.crossOrigin = crossOrigin;\n            }\n            // IE10 / IE11-Fix: SVG contents from data: URI\n            // will only be available if the IMG is present\n            // in the DOM (and visible)\n            if (url.substring(0, 14) === \"data:image/svg\") {\n                img.onload = null;\n                fabric.util.loadImageInDom(img, onLoadCallback);\n            }\n            img.src = url;\n        },\n        /**\n     * Attaches SVG image with data: URL to the dom\n     * @memberOf fabric.util\n     * @param {Object} img Image object with data:image/svg src\n     * @param {Function} callback Callback; invoked with loaded image\n     * @return {Object} DOM element (div containing the SVG image)\n     */ loadImageInDom: function(img, onLoadCallback) {\n            var div = fabric.document.createElement(\"div\");\n            div.style.width = div.style.height = \"1px\";\n            div.style.left = div.style.top = \"-100%\";\n            div.style.position = \"absolute\";\n            div.appendChild(img);\n            fabric.document.querySelector(\"body\").appendChild(div);\n            /**\n       * Wrap in function to:\n       *   1. Call existing callback\n       *   2. Cleanup DOM\n       */ img.onload = function() {\n                onLoadCallback();\n                div.parentNode.removeChild(div);\n                div = null;\n            };\n        },\n        /**\n     * Creates corresponding fabric instances from their object representations\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} objects Objects to enliven\n     * @param {Function} callback Callback to invoke when all objects are created\n     * @param {String} namespace Namespace to get klass \"Class\" object from\n     * @param {Function} reviver Method for further parsing of object elements,\n     * called after each fabric object created.\n     */ enlivenObjects: function(objects, callback, namespace, reviver) {\n            objects = objects || [];\n            var enlivenedObjects = [], numLoadedObjects = 0, numTotalObjects = objects.length;\n            function onLoaded() {\n                if (++numLoadedObjects === numTotalObjects) {\n                    callback && callback(enlivenedObjects.filter(function(obj) {\n                        // filter out undefined objects (objects that gave error)\n                        return obj;\n                    }));\n                }\n            }\n            if (!numTotalObjects) {\n                callback && callback(enlivenedObjects);\n                return;\n            }\n            objects.forEach(function(o, index) {\n                // if sparse array\n                if (!o || !o.type) {\n                    onLoaded();\n                    return;\n                }\n                var klass = fabric.util.getKlass(o.type, namespace);\n                klass.fromObject(o, function(obj, error) {\n                    error || (enlivenedObjects[index] = obj);\n                    reviver && reviver(o, obj, error);\n                    onLoaded();\n                });\n            });\n        },\n        /**\n     * Creates corresponding fabric instances residing in an object, e.g. `clipPath`\n     * @see {@link fabric.Object.ENLIVEN_PROPS}\n     * @param {Object} object\n     * @param {Object} [context] assign enlived props to this object (pass null to skip this)\n     * @param {(objects:fabric.Object[]) => void} callback\n     */ enlivenObjectEnlivables: function(object, context, callback) {\n            var enlivenProps = fabric.Object.ENLIVEN_PROPS.filter(function(key) {\n                return !!object[key];\n            });\n            fabric.util.enlivenObjects(enlivenProps.map(function(key) {\n                return object[key];\n            }), function(enlivedProps) {\n                var objects = {};\n                enlivenProps.forEach(function(key, index) {\n                    objects[key] = enlivedProps[index];\n                    context && (context[key] = enlivedProps[index]);\n                });\n                callback && callback(objects);\n            });\n        },\n        /**\n     * Create and wait for loading of patterns\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} patterns Objects to enliven\n     * @param {Function} callback Callback to invoke when all objects are created\n     * called after each fabric object created.\n     */ enlivenPatterns: function(patterns, callback) {\n            patterns = patterns || [];\n            function onLoaded() {\n                if (++numLoadedPatterns === numPatterns) {\n                    callback && callback(enlivenedPatterns);\n                }\n            }\n            var enlivenedPatterns = [], numLoadedPatterns = 0, numPatterns = patterns.length;\n            if (!numPatterns) {\n                callback && callback(enlivenedPatterns);\n                return;\n            }\n            patterns.forEach(function(p, index) {\n                if (p && p.source) {\n                    new fabric.Pattern(p, function(pattern) {\n                        enlivenedPatterns[index] = pattern;\n                        onLoaded();\n                    });\n                } else {\n                    enlivenedPatterns[index] = p;\n                    onLoaded();\n                }\n            });\n        },\n        /**\n     * Groups SVG elements (usually those retrieved from SVG document)\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} elements SVG elements to group\n     * @param {Object} [options] Options object\n     * @param {String} path Value to set sourcePath to\n     * @return {fabric.Object|fabric.Group}\n     */ groupSVGElements: function(elements, options, path) {\n            var object;\n            if (elements && elements.length === 1) {\n                if (typeof path !== \"undefined\") {\n                    elements[0].sourcePath = path;\n                }\n                return elements[0];\n            }\n            if (options) {\n                if (options.width && options.height) {\n                    options.centerPoint = {\n                        x: options.width / 2,\n                        y: options.height / 2\n                    };\n                } else {\n                    delete options.width;\n                    delete options.height;\n                }\n            }\n            object = new fabric.Group(elements, options);\n            if (typeof path !== \"undefined\") {\n                object.sourcePath = path;\n            }\n            return object;\n        },\n        /**\n     * Populates an object with properties of another object\n     * @static\n     * @memberOf fabric.util\n     * @param {Object} source Source object\n     * @param {Object} destination Destination object\n     * @return {Array} properties Properties names to include\n     */ populateWithProperties: function(source, destination, properties) {\n            if (properties && Array.isArray(properties)) {\n                for(var i = 0, len = properties.length; i < len; i++){\n                    if (properties[i] in source) {\n                        destination[properties[i]] = source[properties[i]];\n                    }\n                }\n            }\n        },\n        /**\n     * Creates canvas element\n     * @static\n     * @memberOf fabric.util\n     * @return {CanvasElement} initialized canvas element\n     */ createCanvasElement: function() {\n            return fabric.document.createElement(\"canvas\");\n        },\n        /**\n     * Creates a canvas element that is a copy of another and is also painted\n     * @param {CanvasElement} canvas to copy size and content of\n     * @static\n     * @memberOf fabric.util\n     * @return {CanvasElement} initialized canvas element\n     */ copyCanvasElement: function(canvas) {\n            var newCanvas = fabric.util.createCanvasElement();\n            newCanvas.width = canvas.width;\n            newCanvas.height = canvas.height;\n            newCanvas.getContext(\"2d\").drawImage(canvas, 0, 0);\n            return newCanvas;\n        },\n        /**\n     * since 2.6.0 moved from canvas instance to utility.\n     * @param {CanvasElement} canvasEl to copy size and content of\n     * @param {String} format 'jpeg' or 'png', in some browsers 'webp' is ok too\n     * @param {Number} quality <= 1 and > 0\n     * @static\n     * @memberOf fabric.util\n     * @return {String} data url\n     */ toDataURL: function(canvasEl, format, quality) {\n            return canvasEl.toDataURL(\"image/\" + format, quality);\n        },\n        /**\n     * Creates image element (works on client and node)\n     * @static\n     * @memberOf fabric.util\n     * @return {HTMLImageElement} HTML image element\n     */ createImage: function() {\n            return fabric.document.createElement(\"img\");\n        },\n        /**\n     * Multiply matrix A by matrix B to nest transformations\n     * @static\n     * @memberOf fabric.util\n     * @param  {Array} a First transformMatrix\n     * @param  {Array} b Second transformMatrix\n     * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices\n     * @return {Array} The product of the two transform matrices\n     */ multiplyTransformMatrices: function(a, b, is2x2) {\n            // Matrix multiply a * b\n            return [\n                a[0] * b[0] + a[2] * b[1],\n                a[1] * b[0] + a[3] * b[1],\n                a[0] * b[2] + a[2] * b[3],\n                a[1] * b[2] + a[3] * b[3],\n                is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],\n                is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]\n            ];\n        },\n        /**\n     * Decomposes standard 2x3 matrix into transform components\n     * @static\n     * @memberOf fabric.util\n     * @param  {Array} a transformMatrix\n     * @return {Object} Components of transform\n     */ qrDecompose: function(a) {\n            var angle = atan2(a[1], a[0]), denom = pow(a[0], 2) + pow(a[1], 2), scaleX = sqrt(denom), scaleY = (a[0] * a[3] - a[2] * a[1]) / scaleX, skewX = atan2(a[0] * a[2] + a[1] * a[3], denom);\n            return {\n                angle: angle / PiBy180,\n                scaleX: scaleX,\n                scaleY: scaleY,\n                skewX: skewX / PiBy180,\n                skewY: 0,\n                translateX: a[4],\n                translateY: a[5]\n            };\n        },\n        /**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.angle] angle in degrees\n     * @return {Number[]} transform matrix\n     */ calcRotateMatrix: function(options) {\n            if (!options.angle) {\n                return fabric.iMatrix.concat();\n            }\n            var theta = fabric.util.degreesToRadians(options.angle), cos = fabric.util.cos(theta), sin = fabric.util.sin(theta);\n            return [\n                cos,\n                sin,\n                -sin,\n                cos,\n                0,\n                0\n            ];\n        },\n        /**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet.\n     * is called DimensionsTransformMatrix because those properties are the one that influence\n     * the size of the resulting box of the object.\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.scaleX]\n     * @param  {Number} [options.scaleY]\n     * @param  {Boolean} [options.flipX]\n     * @param  {Boolean} [options.flipY]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.skewY]\n     * @return {Number[]} transform matrix\n     */ calcDimensionsMatrix: function(options) {\n            var scaleX = typeof options.scaleX === \"undefined\" ? 1 : options.scaleX, scaleY = typeof options.scaleY === \"undefined\" ? 1 : options.scaleY, scaleMatrix = [\n                options.flipX ? -scaleX : scaleX,\n                0,\n                0,\n                options.flipY ? -scaleY : scaleY,\n                0,\n                0\n            ], multiply = fabric.util.multiplyTransformMatrices, degreesToRadians = fabric.util.degreesToRadians;\n            if (options.skewX) {\n                scaleMatrix = multiply(scaleMatrix, [\n                    1,\n                    0,\n                    Math.tan(degreesToRadians(options.skewX)),\n                    1\n                ], true);\n            }\n            if (options.skewY) {\n                scaleMatrix = multiply(scaleMatrix, [\n                    1,\n                    Math.tan(degreesToRadians(options.skewY)),\n                    0,\n                    1\n                ], true);\n            }\n            return scaleMatrix;\n        },\n        /**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.angle]\n     * @param  {Number} [options.scaleX]\n     * @param  {Number} [options.scaleY]\n     * @param  {Boolean} [options.flipX]\n     * @param  {Boolean} [options.flipY]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.translateX]\n     * @param  {Number} [options.translateY]\n     * @return {Number[]} transform matrix\n     */ composeMatrix: function(options) {\n            var matrix = [\n                1,\n                0,\n                0,\n                1,\n                options.translateX || 0,\n                options.translateY || 0\n            ], multiply = fabric.util.multiplyTransformMatrices;\n            if (options.angle) {\n                matrix = multiply(matrix, fabric.util.calcRotateMatrix(options));\n            }\n            if (options.scaleX !== 1 || options.scaleY !== 1 || options.skewX || options.skewY || options.flipX || options.flipY) {\n                matrix = multiply(matrix, fabric.util.calcDimensionsMatrix(options));\n            }\n            return matrix;\n        },\n        /**\n     * reset an object transform state to neutral. Top and left are not accounted for\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Object} target object to transform\n     */ resetObjectTransform: function(target) {\n            target.scaleX = 1;\n            target.scaleY = 1;\n            target.skewX = 0;\n            target.skewY = 0;\n            target.flipX = false;\n            target.flipY = false;\n            target.rotate(0);\n        },\n        /**\n     * Extract Object transform values\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Object} target object to read from\n     * @return {Object} Components of transform\n     */ saveObjectTransform: function(target) {\n            return {\n                scaleX: target.scaleX,\n                scaleY: target.scaleY,\n                skewX: target.skewX,\n                skewY: target.skewY,\n                angle: target.angle,\n                left: target.left,\n                flipX: target.flipX,\n                flipY: target.flipY,\n                top: target.top\n            };\n        },\n        /**\n     * Returns true if context has transparent pixel\n     * at specified location (taking tolerance into account)\n     * @param {CanvasRenderingContext2D} ctx context\n     * @param {Number} x x coordinate\n     * @param {Number} y y coordinate\n     * @param {Number} tolerance Tolerance\n     */ isTransparent: function(ctx, x, y, tolerance) {\n            // If tolerance is > 0 adjust start coords to take into account.\n            // If moves off Canvas fix to 0\n            if (tolerance > 0) {\n                if (x > tolerance) {\n                    x -= tolerance;\n                } else {\n                    x = 0;\n                }\n                if (y > tolerance) {\n                    y -= tolerance;\n                } else {\n                    y = 0;\n                }\n            }\n            var _isTransparent = true, i, temp, imageData = ctx.getImageData(x, y, tolerance * 2 || 1, tolerance * 2 || 1), l = imageData.data.length;\n            // Split image data - for tolerance > 1, pixelDataSize = 4;\n            for(i = 3; i < l; i += 4){\n                temp = imageData.data[i];\n                _isTransparent = temp <= 0;\n                if (_isTransparent === false) {\n                    break; // Stop if colour found\n                }\n            }\n            imageData = null;\n            return _isTransparent;\n        },\n        /**\n     * Parse preserveAspectRatio attribute from element\n     * @param {string} attribute to be parsed\n     * @return {Object} an object containing align and meetOrSlice attribute\n     */ parsePreserveAspectRatioAttribute: function(attribute) {\n            var meetOrSlice = \"meet\", alignX = \"Mid\", alignY = \"Mid\", aspectRatioAttrs = attribute.split(\" \"), align;\n            if (aspectRatioAttrs && aspectRatioAttrs.length) {\n                meetOrSlice = aspectRatioAttrs.pop();\n                if (meetOrSlice !== \"meet\" && meetOrSlice !== \"slice\") {\n                    align = meetOrSlice;\n                    meetOrSlice = \"meet\";\n                } else if (aspectRatioAttrs.length) {\n                    align = aspectRatioAttrs.pop();\n                }\n            }\n            //divide align in alignX and alignY\n            alignX = align !== \"none\" ? align.slice(1, 4) : \"none\";\n            alignY = align !== \"none\" ? align.slice(5, 8) : \"none\";\n            return {\n                meetOrSlice: meetOrSlice,\n                alignX: alignX,\n                alignY: alignY\n            };\n        },\n        /**\n     * Clear char widths cache for the given font family or all the cache if no\n     * fontFamily is specified.\n     * Use it if you know you are loading fonts in a lazy way and you are not waiting\n     * for custom fonts to load properly when adding text objects to the canvas.\n     * If a text object is added when its own font is not loaded yet, you will get wrong\n     * measurement and so wrong bounding boxes.\n     * After the font cache is cleared, either change the textObject text content or call\n     * initDimensions() to trigger a recalculation\n     * @memberOf fabric.util\n     * @param {String} [fontFamily] font family to clear\n     */ clearFabricFontCache: function(fontFamily) {\n            fontFamily = (fontFamily || \"\").toLowerCase();\n            if (!fontFamily) {\n                fabric.charWidthsCache = {};\n            } else if (fabric.charWidthsCache[fontFamily]) {\n                delete fabric.charWidthsCache[fontFamily];\n            }\n        },\n        /**\n     * Given current aspect ratio, determines the max width and height that can\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Number} ar aspect ratio\n     * @param {Number} maximumArea Maximum area you want to achieve\n     * @return {Object.x} Limited dimensions by X\n     * @return {Object.y} Limited dimensions by Y\n     */ limitDimsByArea: function(ar, maximumArea) {\n            var roughWidth = Math.sqrt(maximumArea * ar), perfLimitSizeY = Math.floor(maximumArea / roughWidth);\n            return {\n                x: Math.floor(roughWidth),\n                y: perfLimitSizeY\n            };\n        },\n        capValue: function(min, value, max) {\n            return Math.max(min, Math.min(value, max));\n        },\n        /**\n     * Finds the scale for the object source to fit inside the object destination,\n     * keeping aspect ratio intact.\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Object | fabric.Object} source\n     * @param {Number} source.height natural unscaled height of the object\n     * @param {Number} source.width natural unscaled width of the object\n     * @param {Object | fabric.Object} destination\n     * @param {Number} destination.height natural unscaled height of the object\n     * @param {Number} destination.width natural unscaled width of the object\n     * @return {Number} scale factor to apply to source to fit into destination\n     */ findScaleToFit: function(source, destination) {\n            return Math.min(destination.width / source.width, destination.height / source.height);\n        },\n        /**\n     * Finds the scale for the object source to cover entirely the object destination,\n     * keeping aspect ratio intact.\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Object | fabric.Object} source\n     * @param {Number} source.height natural unscaled height of the object\n     * @param {Number} source.width natural unscaled width of the object\n     * @param {Object | fabric.Object} destination\n     * @param {Number} destination.height natural unscaled height of the object\n     * @param {Number} destination.width natural unscaled width of the object\n     * @return {Number} scale factor to apply to source to cover destination\n     */ findScaleToCover: function(source, destination) {\n            return Math.max(destination.width / source.width, destination.height / source.height);\n        },\n        /**\n     * given an array of 6 number returns something like `\"matrix(...numbers)\"`\n     * @memberOf fabric.util\n     * @param {Array} transform an array with 6 numbers\n     * @return {String} transform matrix for svg\n     * @return {Object.y} Limited dimensions by Y\n     */ matrixToSVG: function(transform) {\n            return \"matrix(\" + transform.map(function(value) {\n                return fabric.util.toFixed(value, fabric.Object.NUM_FRACTION_DIGITS);\n            }).join(\" \") + \")\";\n        },\n        /**\n     * given an object and a transform, apply the inverse transform to the object,\n     * this is equivalent to remove from that object that transformation, so that\n     * added in a space with the removed transform, the object will be the same as before.\n     * Removing from an object a transform that scale by 2 is like scaling it by 1/2.\n     * Removing from an object a transfrom that rotate by 30deg is like rotating by 30deg\n     * in the opposite direction.\n     * This util is used to add objects inside transformed groups or nested groups.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */ removeTransformFromObject: function(object, transform) {\n            var inverted = fabric.util.invertTransform(transform), finalTransform = fabric.util.multiplyTransformMatrices(inverted, object.calcOwnMatrix());\n            fabric.util.applyTransformToObject(object, finalTransform);\n        },\n        /**\n     * given an object and a transform, apply the transform to the object.\n     * this is equivalent to change the space where the object is drawn.\n     * Adding to an object a transform that scale by 2 is like scaling it by 2.\n     * This is used when removing an object from an active selection for example.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */ addTransformToObject: function(object, transform) {\n            fabric.util.applyTransformToObject(object, fabric.util.multiplyTransformMatrices(transform, object.calcOwnMatrix()));\n        },\n        /**\n     * discard an object transform state and apply the one from the matrix.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */ applyTransformToObject: function(object, transform) {\n            var options = fabric.util.qrDecompose(transform), center = new fabric.Point(options.translateX, options.translateY);\n            object.flipX = false;\n            object.flipY = false;\n            object.set(\"scaleX\", options.scaleX);\n            object.set(\"scaleY\", options.scaleY);\n            object.skewX = options.skewX;\n            object.skewY = options.skewY;\n            object.angle = options.angle;\n            object.setPositionByOrigin(center, \"center\", \"center\");\n        },\n        /**\n     * given a width and height, return the size of the bounding box\n     * that can contains the box with width/height with applied transform\n     * described in options.\n     * Use to calculate the boxes around objects for controls.\n     * @memberOf fabric.util\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Object} options\n     * @param {Number} options.scaleX\n     * @param {Number} options.scaleY\n     * @param {Number} options.skewX\n     * @param {Number} options.skewY\n     * @return {Object.x} width of containing\n     * @return {Object.y} height of containing\n     */ sizeAfterTransform: function(width, height, options) {\n            var dimX = width / 2, dimY = height / 2, points = [\n                {\n                    x: -dimX,\n                    y: -dimY\n                },\n                {\n                    x: dimX,\n                    y: -dimY\n                },\n                {\n                    x: -dimX,\n                    y: dimY\n                },\n                {\n                    x: dimX,\n                    y: dimY\n                }\n            ], transformMatrix = fabric.util.calcDimensionsMatrix(options), bbox = fabric.util.makeBoundingBoxFromPoints(points, transformMatrix);\n            return {\n                x: bbox.width,\n                y: bbox.height\n            };\n        },\n        /**\n     * Merges 2 clip paths into one visually equal clip path\n     *\n     * **IMPORTANT**:\\\n     * Does **NOT** clone the arguments, clone them proir if necessary.\n     *\n     * Creates a wrapper (group) that contains one clip path and is clipped by the other so content is kept where both overlap.\n     * Use this method if both the clip paths may have nested clip paths of their own, so assigning one to the other's clip path property is not possible.\n     *\n     * In order to handle the `inverted` property we follow logic described in the following cases:\\\n     * **(1)** both clip paths are inverted - the clip paths pass the inverted prop to the wrapper and loose it themselves.\\\n     * **(2)** one is inverted and the other isn't - the wrapper shouldn't become inverted and the inverted clip path must clip the non inverted one to produce an identical visual effect.\\\n     * **(3)** both clip paths are not inverted - wrapper and clip paths remain unchanged.\n     *\n     * @memberOf fabric.util\n     * @param {fabric.Object} c1\n     * @param {fabric.Object} c2\n     * @returns {fabric.Object} merged clip path\n     */ mergeClipPaths: function(c1, c2) {\n            var a = c1, b = c2;\n            if (a.inverted && !b.inverted) {\n                //  case (2)\n                a = c2;\n                b = c1;\n            }\n            //  `b` becomes `a`'s clip path so we transform `b` to `a` coordinate plane\n            fabric.util.applyTransformToObject(b, fabric.util.multiplyTransformMatrices(fabric.util.invertTransform(a.calcTransformMatrix()), b.calcTransformMatrix()));\n            //  assign the `inverted` prop to the wrapping group\n            var inverted = a.inverted && b.inverted;\n            if (inverted) {\n                //  case (1)\n                a.inverted = b.inverted = false;\n            }\n            return new fabric.Group([\n                a\n            ], {\n                clipPath: b,\n                inverted: inverted\n            });\n        },\n        /**\n     * @memberOf fabric.util\n     * @param {Object} prevStyle first style to compare\n     * @param {Object} thisStyle second style to compare\n     * @param {boolean} forTextSpans whether to check overline, underline, and line-through properties\n     * @return {boolean} true if the style changed\n     */ hasStyleChanged: function(prevStyle, thisStyle, forTextSpans) {\n            forTextSpans = forTextSpans || false;\n            return prevStyle.fill !== thisStyle.fill || prevStyle.stroke !== thisStyle.stroke || prevStyle.strokeWidth !== thisStyle.strokeWidth || prevStyle.fontSize !== thisStyle.fontSize || prevStyle.fontFamily !== thisStyle.fontFamily || prevStyle.fontWeight !== thisStyle.fontWeight || prevStyle.fontStyle !== thisStyle.fontStyle || prevStyle.textBackgroundColor !== thisStyle.textBackgroundColor || prevStyle.deltaY !== thisStyle.deltaY || forTextSpans && (prevStyle.overline !== thisStyle.overline || prevStyle.underline !== thisStyle.underline || prevStyle.linethrough !== thisStyle.linethrough);\n        },\n        /**\n     * Returns the array form of a text object's inline styles property with styles grouped in ranges\n     * rather than per character. This format is less verbose, and is better suited for storage\n     * so it is used in serialization (not during runtime).\n     * @memberOf fabric.util\n     * @param {object} styles per character styles for a text object\n     * @param {String} text the text string that the styles are applied to\n     * @return {{start: number, end: number, style: object}[]}\n     */ stylesToArray: function(styles, text) {\n            // clone style structure to prevent mutation\n            var styles = fabric.util.object.clone(styles, true), textLines = text.split(\"\\n\"), charIndex = -1, prevStyle = {}, stylesArray = [];\n            //loop through each textLine\n            for(var i = 0; i < textLines.length; i++){\n                if (!styles[i]) {\n                    //no styles exist for this line, so add the line's length to the charIndex total\n                    charIndex += textLines[i].length;\n                    continue;\n                }\n                //loop through each character of the current line\n                for(var c = 0; c < textLines[i].length; c++){\n                    charIndex++;\n                    var thisStyle = styles[i][c];\n                    //check if style exists for this character\n                    if (thisStyle && Object.keys(thisStyle).length > 0) {\n                        var styleChanged = fabric.util.hasStyleChanged(prevStyle, thisStyle, true);\n                        if (styleChanged) {\n                            stylesArray.push({\n                                start: charIndex,\n                                end: charIndex + 1,\n                                style: thisStyle\n                            });\n                        } else {\n                            //if style is the same as previous character, increase end index\n                            stylesArray[stylesArray.length - 1].end++;\n                        }\n                    }\n                    prevStyle = thisStyle || {};\n                }\n            }\n            return stylesArray;\n        },\n        /**\n     * Returns the object form of the styles property with styles that are assigned per\n     * character rather than grouped by range. This format is more verbose, and is\n     * only used during runtime (not for serialization/storage)\n     * @memberOf fabric.util\n     * @param {Array} styles the serialized form of a text object's styles\n     * @param {String} text the text string that the styles are applied to\n     * @return {Object}\n     */ stylesFromArray: function(styles, text) {\n            if (!Array.isArray(styles)) {\n                return styles;\n            }\n            var textLines = text.split(\"\\n\"), charIndex = -1, styleIndex = 0, stylesObject = {};\n            //loop through each textLine\n            for(var i = 0; i < textLines.length; i++){\n                //loop through each character of the current line\n                for(var c = 0; c < textLines[i].length; c++){\n                    charIndex++;\n                    //check if there's a style collection that includes the current character\n                    if (styles[styleIndex] && styles[styleIndex].start <= charIndex && charIndex < styles[styleIndex].end) {\n                        //create object for line index if it doesn't exist\n                        stylesObject[i] = stylesObject[i] || {};\n                        //assign a style at this character's index\n                        stylesObject[i][c] = Object.assign({}, styles[styleIndex].style);\n                        //if character is at the end of the current style collection, move to the next\n                        if (charIndex === styles[styleIndex].end - 1) {\n                            styleIndex++;\n                        }\n                    }\n                }\n            }\n            return stylesObject;\n        }\n    };\n})( true ? exports : 0);\n(function() {\n    var _join = Array.prototype.join, commandLengths = {\n        m: 2,\n        l: 2,\n        h: 1,\n        v: 1,\n        c: 6,\n        s: 4,\n        q: 4,\n        t: 2,\n        a: 7\n    }, repeatedCommands = {\n        m: \"l\",\n        M: \"L\"\n    };\n    function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {\n        var costh2 = fabric.util.cos(th2), sinth2 = fabric.util.sin(th2), costh3 = fabric.util.cos(th3), sinth3 = fabric.util.sin(th3), toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1, toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1, cp1X = fromX + mT * (-cosTh * rx * sinth2 - sinTh * ry * costh2), cp1Y = fromY + mT * (-sinTh * rx * sinth2 + cosTh * ry * costh2), cp2X = toX + mT * (cosTh * rx * sinth3 + sinTh * ry * costh3), cp2Y = toY + mT * (sinTh * rx * sinth3 - cosTh * ry * costh3);\n        return [\n            \"C\",\n            cp1X,\n            cp1Y,\n            cp2X,\n            cp2Y,\n            toX,\n            toY\n        ];\n    }\n    /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp\n   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here\n   * http://mozilla.org/MPL/2.0/\n   */ function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {\n        var PI = Math.PI, th = rotateX * PI / 180, sinTh = fabric.util.sin(th), cosTh = fabric.util.cos(th), fromX = 0, fromY = 0;\n        rx = Math.abs(rx);\n        ry = Math.abs(ry);\n        var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5, py = -cosTh * toY * 0.5 + sinTh * toX * 0.5, rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px, pl = rx2 * ry2 - rx2 * py2 - ry2 * px2, root = 0;\n        if (pl < 0) {\n            var s = Math.sqrt(1 - pl / (rx2 * ry2));\n            rx *= s;\n            ry *= s;\n        } else {\n            root = (large === sweep ? -1.0 : 1.0) * Math.sqrt(pl / (rx2 * py2 + ry2 * px2));\n        }\n        var cx = root * rx * py / ry, cy = -root * ry * px / rx, cx1 = cosTh * cx - sinTh * cy + toX * 0.5, cy1 = sinTh * cx + cosTh * cy + toY * 0.5, mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry), dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);\n        if (sweep === 0 && dtheta > 0) {\n            dtheta -= 2 * PI;\n        } else if (sweep === 1 && dtheta < 0) {\n            dtheta += 2 * PI;\n        }\n        // Convert into cubic bezier segments <= 90deg\n        var segments = Math.ceil(Math.abs(dtheta / PI * 2)), result = [], mDelta = dtheta / segments, mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2), th3 = mTheta + mDelta;\n        for(var i = 0; i < segments; i++){\n            result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);\n            fromX = result[i][5];\n            fromY = result[i][6];\n            mTheta = th3;\n            th3 += mDelta;\n        }\n        return result;\n    }\n    /*\n   * Private\n   */ function calcVectorAngle(ux, uy, vx, vy) {\n        var ta = Math.atan2(uy, ux), tb = Math.atan2(vy, vx);\n        if (tb >= ta) {\n            return tb - ta;\n        } else {\n            return 2 * Math.PI - (ta - tb);\n        }\n    }\n    /**\n   * Calculate bounding box of a beziercurve\n   * @param {Number} x0 starting point\n   * @param {Number} y0\n   * @param {Number} x1 first control point\n   * @param {Number} y1\n   * @param {Number} x2 secondo control point\n   * @param {Number} y2\n   * @param {Number} x3 end of bezier\n   * @param {Number} y3\n   */ // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.\n    // TODO: can we normalize this with the starting points set at 0 and then translated the bbox?\n    function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {\n        var argsString;\n        if (fabric.cachesBoundsOfCurve) {\n            argsString = _join.call(arguments);\n            if (fabric.boundsOfCurveCache[argsString]) {\n                return fabric.boundsOfCurveCache[argsString];\n            }\n        }\n        var sqrt = Math.sqrt, min = Math.min, max = Math.max, abs = Math.abs, tvalues = [], bounds = [\n            [],\n            []\n        ], a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n        for(var i = 0; i < 2; ++i){\n            if (i > 0) {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n            if (abs(a) < 1e-12) {\n                if (abs(b) < 1e-12) {\n                    continue;\n                }\n                t = -c / b;\n                if (0 < t && t < 1) {\n                    tvalues.push(t);\n                }\n                continue;\n            }\n            b2ac = b * b - 4 * c * a;\n            if (b2ac < 0) {\n                continue;\n            }\n            sqrtb2ac = sqrt(b2ac);\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if (0 < t1 && t1 < 1) {\n                tvalues.push(t1);\n            }\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if (0 < t2 && t2 < 1) {\n                tvalues.push(t2);\n            }\n        }\n        var x, y, j = tvalues.length, jlen = j, mt;\n        while(j--){\n            t = tvalues[j];\n            mt = 1 - t;\n            x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n            bounds[0][j] = x;\n            y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n            bounds[1][j] = y;\n        }\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n        var result = [\n            {\n                x: min.apply(null, bounds[0]),\n                y: min.apply(null, bounds[1])\n            },\n            {\n                x: max.apply(null, bounds[0]),\n                y: max.apply(null, bounds[1])\n            }\n        ];\n        if (fabric.cachesBoundsOfCurve) {\n            fabric.boundsOfCurveCache[argsString] = result;\n        }\n        return result;\n    }\n    /**\n   * Converts arc to a bunch of bezier curves\n   * @param {Number} fx starting point x\n   * @param {Number} fy starting point y\n   * @param {Array} coords Arc command\n   */ function fromArcToBeziers(fx, fy, coords) {\n        var rx = coords[1], ry = coords[2], rot = coords[3], large = coords[4], sweep = coords[5], tx = coords[6], ty = coords[7], segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);\n        for(var i = 0, len = segsNorm.length; i < len; i++){\n            segsNorm[i][1] += fx;\n            segsNorm[i][2] += fy;\n            segsNorm[i][3] += fx;\n            segsNorm[i][4] += fy;\n            segsNorm[i][5] += fx;\n            segsNorm[i][6] += fy;\n        }\n        return segsNorm;\n    }\n    ;\n    /**\n   * This function take a parsed SVG path and make it simpler for fabricJS logic.\n   * simplification consist of: only UPPERCASE absolute commands ( relative converted to absolute )\n   * S converted in C, T converted in Q, A converted in C.\n   * @param {Array} path the array of commands of a parsed svg path for fabric.Path\n   * @return {Array} the simplified array of commands of a parsed svg path for fabric.Path\n   */ function makePathSimpler(path) {\n        // x and y represent the last point of the path. the previous command point.\n        // we add them to each relative command to make it an absolute comment.\n        // we also swap the v V h H with L, because are easier to transform.\n        var x = 0, y = 0, len = path.length, // x1 and y1 represent the last point of the subpath. the subpath is started with\n        // m or M command. When a z or Z command is drawn, x and y need to be resetted to\n        // the last x1 and y1.\n        x1 = 0, y1 = 0, current, i, converted, // previous will host the letter of the previous command, to handle S and T.\n        // controlX and controlY will host the previous reflected control point\n        destinationPath = [], previous, controlX, controlY;\n        for(i = 0; i < len; ++i){\n            converted = false;\n            current = path[i].slice(0);\n            switch(current[0]){\n                case \"l\":\n                    current[0] = \"L\";\n                    current[1] += x;\n                    current[2] += y;\n                // falls through\n                case \"L\":\n                    x = current[1];\n                    y = current[2];\n                    break;\n                case \"h\":\n                    current[1] += x;\n                // falls through\n                case \"H\":\n                    current[0] = \"L\";\n                    current[2] = y;\n                    x = current[1];\n                    break;\n                case \"v\":\n                    current[1] += y;\n                // falls through\n                case \"V\":\n                    current[0] = \"L\";\n                    y = current[1];\n                    current[1] = x;\n                    current[2] = y;\n                    break;\n                case \"m\":\n                    current[0] = \"M\";\n                    current[1] += x;\n                    current[2] += y;\n                // falls through\n                case \"M\":\n                    x = current[1];\n                    y = current[2];\n                    x1 = current[1];\n                    y1 = current[2];\n                    break;\n                case \"c\":\n                    current[0] = \"C\";\n                    current[1] += x;\n                    current[2] += y;\n                    current[3] += x;\n                    current[4] += y;\n                    current[5] += x;\n                    current[6] += y;\n                // falls through\n                case \"C\":\n                    controlX = current[3];\n                    controlY = current[4];\n                    x = current[5];\n                    y = current[6];\n                    break;\n                case \"s\":\n                    current[0] = \"S\";\n                    current[1] += x;\n                    current[2] += y;\n                    current[3] += x;\n                    current[4] += y;\n                // falls through\n                case \"S\":\n                    // would be sScC but since we are swapping sSc for C, we check just that.\n                    if (previous === \"C\") {\n                        // calculate reflection of previous control points\n                        controlX = 2 * x - controlX;\n                        controlY = 2 * y - controlY;\n                    } else {\n                        // If there is no previous command or if the previous command was not a C, c, S, or s,\n                        // the control point is coincident with the current point\n                        controlX = x;\n                        controlY = y;\n                    }\n                    x = current[3];\n                    y = current[4];\n                    current[0] = \"C\";\n                    current[5] = current[3];\n                    current[6] = current[4];\n                    current[3] = current[1];\n                    current[4] = current[2];\n                    current[1] = controlX;\n                    current[2] = controlY;\n                    // current[3] and current[4] are NOW the second control point.\n                    // we keep it for the next reflection.\n                    controlX = current[3];\n                    controlY = current[4];\n                    break;\n                case \"q\":\n                    current[0] = \"Q\";\n                    current[1] += x;\n                    current[2] += y;\n                    current[3] += x;\n                    current[4] += y;\n                // falls through\n                case \"Q\":\n                    controlX = current[1];\n                    controlY = current[2];\n                    x = current[3];\n                    y = current[4];\n                    break;\n                case \"t\":\n                    current[0] = \"T\";\n                    current[1] += x;\n                    current[2] += y;\n                // falls through\n                case \"T\":\n                    if (previous === \"Q\") {\n                        // calculate reflection of previous control point\n                        controlX = 2 * x - controlX;\n                        controlY = 2 * y - controlY;\n                    } else {\n                        // If there is no previous command or if the previous command was not a Q, q, T or t,\n                        // assume the control point is coincident with the current point\n                        controlX = x;\n                        controlY = y;\n                    }\n                    current[0] = \"Q\";\n                    x = current[1];\n                    y = current[2];\n                    current[1] = controlX;\n                    current[2] = controlY;\n                    current[3] = x;\n                    current[4] = y;\n                    break;\n                case \"a\":\n                    current[0] = \"A\";\n                    current[6] += x;\n                    current[7] += y;\n                // falls through\n                case \"A\":\n                    converted = true;\n                    destinationPath = destinationPath.concat(fromArcToBeziers(x, y, current));\n                    x = current[6];\n                    y = current[7];\n                    break;\n                case \"z\":\n                case \"Z\":\n                    x = x1;\n                    y = y1;\n                    break;\n                default:\n            }\n            if (!converted) {\n                destinationPath.push(current);\n            }\n            previous = current[0];\n        }\n        return destinationPath;\n    }\n    ;\n    /**\n   * Calc length from point x1,y1 to x2,y2\n   * @param {Number} x1 starting point x\n   * @param {Number} y1 starting point y\n   * @param {Number} x2 starting point x\n   * @param {Number} y2 starting point y\n   * @return {Number} length of segment\n   */ function calcLineLength(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    // functions for the Cubic beizer\n    // taken from: https://github.com/konvajs/konva/blob/7.0.5/src/shapes/Path.ts#L350\n    function CB1(t) {\n        return t * t * t;\n    }\n    function CB2(t) {\n        return 3 * t * t * (1 - t);\n    }\n    function CB3(t) {\n        return 3 * t * (1 - t) * (1 - t);\n    }\n    function CB4(t) {\n        return (1 - t) * (1 - t) * (1 - t);\n    }\n    function getPointOnCubicBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        return function(pct) {\n            var c1 = CB1(pct), c2 = CB2(pct), c3 = CB3(pct), c4 = CB4(pct);\n            return {\n                x: p4x * c1 + p3x * c2 + p2x * c3 + p1x * c4,\n                y: p4y * c1 + p3y * c2 + p2y * c3 + p1y * c4\n            };\n        };\n    }\n    function getTangentCubicIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        return function(pct) {\n            var invT = 1 - pct, tangentX = 3 * invT * invT * (p2x - p1x) + 6 * invT * pct * (p3x - p2x) + 3 * pct * pct * (p4x - p3x), tangentY = 3 * invT * invT * (p2y - p1y) + 6 * invT * pct * (p3y - p2y) + 3 * pct * pct * (p4y - p3y);\n            return Math.atan2(tangentY, tangentX);\n        };\n    }\n    function QB1(t) {\n        return t * t;\n    }\n    function QB2(t) {\n        return 2 * t * (1 - t);\n    }\n    function QB3(t) {\n        return (1 - t) * (1 - t);\n    }\n    function getPointOnQuadraticBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y) {\n        return function(pct) {\n            var c1 = QB1(pct), c2 = QB2(pct), c3 = QB3(pct);\n            return {\n                x: p3x * c1 + p2x * c2 + p1x * c3,\n                y: p3y * c1 + p2y * c2 + p1y * c3\n            };\n        };\n    }\n    function getTangentQuadraticIterator(p1x, p1y, p2x, p2y, p3x, p3y) {\n        return function(pct) {\n            var invT = 1 - pct, tangentX = 2 * invT * (p2x - p1x) + 2 * pct * (p3x - p2x), tangentY = 2 * invT * (p2y - p1y) + 2 * pct * (p3y - p2y);\n            return Math.atan2(tangentY, tangentX);\n        };\n    }\n    // this will run over a path segment ( a cubic or quadratic segment) and approximate it\n    // with 100 segemnts. This will good enough to calculate the length of the curve\n    function pathIterator(iterator, x1, y1) {\n        var tempP = {\n            x: x1,\n            y: y1\n        }, p, tmpLen = 0, perc;\n        for(perc = 1; perc <= 100; perc += 1){\n            p = iterator(perc / 100);\n            tmpLen += calcLineLength(tempP.x, tempP.y, p.x, p.y);\n            tempP = p;\n        }\n        return tmpLen;\n    }\n    /**\n   * Given a pathInfo, and a distance in pixels, find the percentage from 0 to 1\n   * that correspond to that pixels run over the path.\n   * The percentage will be then used to find the correct point on the canvas for the path.\n   * @param {Array} segInfo fabricJS collection of information on a parsed path\n   * @param {Number} distance from starting point, in pixels.\n   * @return {Object} info object with x and y ( the point on canvas ) and angle, the tangent on that point;\n   */ function findPercentageForDistance(segInfo, distance) {\n        var perc = 0, tmpLen = 0, iterator = segInfo.iterator, tempP = {\n            x: segInfo.x,\n            y: segInfo.y\n        }, p, nextLen, nextStep = 0.01, angleFinder = segInfo.angleFinder, lastPerc;\n        // nextStep > 0.0001 covers 0.00015625 that 1/64th of 1/100\n        // the path\n        while(tmpLen < distance && nextStep > 0.0001){\n            p = iterator(perc);\n            lastPerc = perc;\n            nextLen = calcLineLength(tempP.x, tempP.y, p.x, p.y);\n            // compare tmpLen each cycle with distance, decide next perc to test.\n            if (nextLen + tmpLen > distance) {\n                // we discard this step and we make smaller steps.\n                perc -= nextStep;\n                nextStep /= 2;\n            } else {\n                tempP = p;\n                perc += nextStep;\n                tmpLen += nextLen;\n            }\n        }\n        p.angle = angleFinder(lastPerc);\n        return p;\n    }\n    /**\n   * Run over a parsed and simplifed path and extrac some informations.\n   * informations are length of each command and starting point\n   * @param {Array} path fabricJS parsed path commands\n   * @return {Array} path commands informations\n   */ function getPathSegmentsInfo(path) {\n        var totalLength = 0, len = path.length, current, //x2 and y2 are the coords of segment start\n        //x1 and y1 are the coords of the current point\n        x1 = 0, y1 = 0, x2 = 0, y2 = 0, info = [], iterator, tempInfo, angleFinder;\n        for(var i = 0; i < len; i++){\n            current = path[i];\n            tempInfo = {\n                x: x1,\n                y: y1,\n                command: current[0]\n            };\n            switch(current[0]){\n                case \"M\":\n                    tempInfo.length = 0;\n                    x2 = x1 = current[1];\n                    y2 = y1 = current[2];\n                    break;\n                case \"L\":\n                    tempInfo.length = calcLineLength(x1, y1, current[1], current[2]);\n                    x1 = current[1];\n                    y1 = current[2];\n                    break;\n                case \"C\":\n                    iterator = getPointOnCubicBezierIterator(x1, y1, current[1], current[2], current[3], current[4], current[5], current[6]);\n                    angleFinder = getTangentCubicIterator(x1, y1, current[1], current[2], current[3], current[4], current[5], current[6]);\n                    tempInfo.iterator = iterator;\n                    tempInfo.angleFinder = angleFinder;\n                    tempInfo.length = pathIterator(iterator, x1, y1);\n                    x1 = current[5];\n                    y1 = current[6];\n                    break;\n                case \"Q\":\n                    iterator = getPointOnQuadraticBezierIterator(x1, y1, current[1], current[2], current[3], current[4]);\n                    angleFinder = getTangentQuadraticIterator(x1, y1, current[1], current[2], current[3], current[4]);\n                    tempInfo.iterator = iterator;\n                    tempInfo.angleFinder = angleFinder;\n                    tempInfo.length = pathIterator(iterator, x1, y1);\n                    x1 = current[3];\n                    y1 = current[4];\n                    break;\n                case \"Z\":\n                case \"z\":\n                    // we add those in order to ease calculations later\n                    tempInfo.destX = x2;\n                    tempInfo.destY = y2;\n                    tempInfo.length = calcLineLength(x1, y1, x2, y2);\n                    x1 = x2;\n                    y1 = y2;\n                    break;\n            }\n            totalLength += tempInfo.length;\n            info.push(tempInfo);\n        }\n        info.push({\n            length: totalLength,\n            x: x1,\n            y: y1\n        });\n        return info;\n    }\n    function getPointOnPath(path, distance, infos) {\n        if (!infos) {\n            infos = getPathSegmentsInfo(path);\n        }\n        var i = 0;\n        while(distance - infos[i].length > 0 && i < infos.length - 2){\n            distance -= infos[i].length;\n            i++;\n        }\n        // var distance = infos[infos.length - 1] * perc;\n        var segInfo = infos[i], segPercent = distance / segInfo.length, command = segInfo.command, segment = path[i], info;\n        switch(command){\n            case \"M\":\n                return {\n                    x: segInfo.x,\n                    y: segInfo.y,\n                    angle: 0\n                };\n            case \"Z\":\n            case \"z\":\n                info = new fabric.Point(segInfo.x, segInfo.y).lerp(new fabric.Point(segInfo.destX, segInfo.destY), segPercent);\n                info.angle = Math.atan2(segInfo.destY - segInfo.y, segInfo.destX - segInfo.x);\n                return info;\n            case \"L\":\n                info = new fabric.Point(segInfo.x, segInfo.y).lerp(new fabric.Point(segment[1], segment[2]), segPercent);\n                info.angle = Math.atan2(segment[2] - segInfo.y, segment[1] - segInfo.x);\n                return info;\n            case \"C\":\n                return findPercentageForDistance(segInfo, distance);\n            case \"Q\":\n                return findPercentageForDistance(segInfo, distance);\n        }\n    }\n    /**\n   *\n   * @param {string} pathString\n   * @return {(string|number)[][]} An array of SVG path commands\n   * @example <caption>Usage</caption>\n   * parsePath('M 3 4 Q 3 5 2 1 4 0 Q 9 12 2 1 4 0') === [\n   *   ['M', 3, 4],\n   *   ['Q', 3, 5, 2, 1, 4, 0],\n   *   ['Q', 9, 12, 2, 1, 4, 0],\n   * ];\n   *\n   */ function parsePath(pathString) {\n        var result = [], coords = [], currentPath, parsed, re = fabric.rePathCommand, rNumber = \"[-+]?(?:\\\\d*\\\\.\\\\d+|\\\\d+\\\\.?)(?:[eE][-+]?\\\\d+)?\\\\s*\", rNumberCommaWsp = \"(\" + rNumber + \")\" + fabric.commaWsp, rFlagCommaWsp = \"([01])\" + fabric.commaWsp + \"?\", rArcSeq = rNumberCommaWsp + \"?\" + rNumberCommaWsp + \"?\" + rNumberCommaWsp + rFlagCommaWsp + rFlagCommaWsp + rNumberCommaWsp + \"?(\" + rNumber + \")\", regArcArgumentSequence = new RegExp(rArcSeq, \"g\"), match, coordsStr, // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)\n        path;\n        if (!pathString || !pathString.match) {\n            return result;\n        }\n        path = pathString.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);\n        for(var i = 0, coordsParsed, len = path.length; i < len; i++){\n            currentPath = path[i];\n            coordsStr = currentPath.slice(1).trim();\n            coords.length = 0;\n            var command = currentPath.charAt(0);\n            coordsParsed = [\n                command\n            ];\n            if (command.toLowerCase() === \"a\") {\n                // arcs have special flags that apparently don't require spaces so handle special\n                for(var args; args = regArcArgumentSequence.exec(coordsStr);){\n                    for(var j = 1; j < args.length; j++){\n                        coords.push(args[j]);\n                    }\n                }\n            } else {\n                while(match = re.exec(coordsStr)){\n                    coords.push(match[0]);\n                }\n            }\n            for(var j = 0, jlen = coords.length; j < jlen; j++){\n                parsed = parseFloat(coords[j]);\n                if (!isNaN(parsed)) {\n                    coordsParsed.push(parsed);\n                }\n            }\n            var commandLength = commandLengths[command.toLowerCase()], repeatedCommand = repeatedCommands[command] || command;\n            if (coordsParsed.length - 1 > commandLength) {\n                for(var k = 1, klen = coordsParsed.length; k < klen; k += commandLength){\n                    result.push([\n                        command\n                    ].concat(coordsParsed.slice(k, k + commandLength)));\n                    command = repeatedCommand;\n                }\n            } else {\n                result.push(coordsParsed);\n            }\n        }\n        return result;\n    }\n    ;\n    /**\n   *\n   * Converts points to a smooth SVG path\n   * @param {{ x: number,y: number }[]} points Array of points\n   * @param {number} [correction] Apply a correction to the path (usually we use `width / 1000`). If value is undefined 0 is used as the correction value.\n   * @return {(string|number)[][]} An array of SVG path commands\n   */ function getSmoothPathFromPoints(points, correction) {\n        var path = [], i, p1 = new fabric.Point(points[0].x, points[0].y), p2 = new fabric.Point(points[1].x, points[1].y), len = points.length, multSignX = 1, multSignY = 0, manyPoints = len > 2;\n        correction = correction || 0;\n        if (manyPoints) {\n            multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;\n            multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;\n        }\n        path.push([\n            \"M\",\n            p1.x - multSignX * correction,\n            p1.y - multSignY * correction\n        ]);\n        for(i = 1; i < len; i++){\n            if (!p1.eq(p2)) {\n                var midPoint = p1.midPointFrom(p2);\n                // p1 is our bezier control point\n                // midpoint is our endpoint\n                // start point is p(i-1) value.\n                path.push([\n                    \"Q\",\n                    p1.x,\n                    p1.y,\n                    midPoint.x,\n                    midPoint.y\n                ]);\n            }\n            p1 = points[i];\n            if (i + 1 < points.length) {\n                p2 = points[i + 1];\n            }\n        }\n        if (manyPoints) {\n            multSignX = p1.x > points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;\n            multSignY = p1.y > points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;\n        }\n        path.push([\n            \"L\",\n            p1.x + multSignX * correction,\n            p1.y + multSignY * correction\n        ]);\n        return path;\n    }\n    /**\n   * Transform a path by transforming each segment.\n   * it has to be a simplified path or it won't work.\n   * WARNING: this depends from pathOffset for correct operation\n   * @param {Array} path fabricJS parsed and simplified path commands\n   * @param {Array} transform matrix that represent the transformation\n   * @param {Object} [pathOffset] the fabric.Path pathOffset\n   * @param {Number} pathOffset.x\n   * @param {Number} pathOffset.y\n   * @returns {Array} the transformed path\n   */ function transformPath(path, transform, pathOffset) {\n        if (pathOffset) {\n            transform = fabric.util.multiplyTransformMatrices(transform, [\n                1,\n                0,\n                0,\n                1,\n                -pathOffset.x,\n                -pathOffset.y\n            ]);\n        }\n        return path.map(function(pathSegment) {\n            var newSegment = pathSegment.slice(0), point = {};\n            for(var i = 1; i < pathSegment.length - 1; i += 2){\n                point.x = pathSegment[i];\n                point.y = pathSegment[i + 1];\n                point = fabric.util.transformPoint(point, transform);\n                newSegment[i] = point.x;\n                newSegment[i + 1] = point.y;\n            }\n            return newSegment;\n        });\n    }\n    /**\n   * Join path commands to go back to svg format\n   * @param {Array} pathData fabricJS parsed path commands\n   * @return {String} joined path 'M 0 0 L 20 30'\n   */ fabric.util.joinPath = function(pathData) {\n        return pathData.map(function(segment) {\n            return segment.join(\" \");\n        }).join(\" \");\n    };\n    fabric.util.parsePath = parsePath;\n    fabric.util.makePathSimpler = makePathSimpler;\n    fabric.util.getSmoothPathFromPoints = getSmoothPathFromPoints;\n    fabric.util.getPathSegmentsInfo = getPathSegmentsInfo;\n    fabric.util.getBoundsOfCurve = getBoundsOfCurve;\n    fabric.util.getPointOnPath = getPointOnPath;\n    fabric.util.transformPath = transformPath;\n})();\n(function() {\n    var slice = Array.prototype.slice;\n    /**\n   * Invokes method on all items in a given array\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} method Name of a method to invoke\n   * @return {Array}\n   */ function invoke(array, method) {\n        var args = slice.call(arguments, 2), result = [];\n        for(var i = 0, len = array.length; i < len; i++){\n            result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);\n        }\n        return result;\n    }\n    /**\n   * Finds maximum value in array (not necessarily \"first\" one)\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} byProperty\n   * @return {*}\n   */ function max(array, byProperty) {\n        return find(array, byProperty, function(value1, value2) {\n            return value1 >= value2;\n        });\n    }\n    /**\n   * Finds minimum value in array (not necessarily \"first\" one)\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} byProperty\n   * @return {*}\n   */ function min(array, byProperty) {\n        return find(array, byProperty, function(value1, value2) {\n            return value1 < value2;\n        });\n    }\n    /**\n   * @private\n   */ function fill(array, value) {\n        var k = array.length;\n        while(k--){\n            array[k] = value;\n        }\n        return array;\n    }\n    /**\n   * @private\n   */ function find(array, byProperty, condition) {\n        if (!array || array.length === 0) {\n            return;\n        }\n        var i = array.length - 1, result = byProperty ? array[i][byProperty] : array[i];\n        if (byProperty) {\n            while(i--){\n                if (condition(array[i][byProperty], result)) {\n                    result = array[i][byProperty];\n                }\n            }\n        } else {\n            while(i--){\n                if (condition(array[i], result)) {\n                    result = array[i];\n                }\n            }\n        }\n        return result;\n    }\n    /**\n   * @namespace fabric.util.array\n   */ fabric.util.array = {\n        fill: fill,\n        invoke: invoke,\n        min: min,\n        max: max\n    };\n})();\n(function() {\n    /**\n   * Copies all enumerable properties of one js object to another\n   * this does not and cannot compete with generic utils.\n   * Does not clone or extend fabric.Object subclasses.\n   * This is mostly for internal use and has extra handling for fabricJS objects\n   * it skips the canvas and group properties in deep cloning.\n   * @memberOf fabric.util.object\n   * @param {Object} destination Where to copy to\n   * @param {Object} source Where to copy from\n   * @param {Boolean} [deep] Whether to extend nested objects\n   * @return {Object}\n   */ function extend(destination, source, deep) {\n        // JScript DontEnum bug is not taken care of\n        // the deep clone is for internal use, is not meant to avoid\n        // javascript traps or cloning html element or self referenced objects.\n        if (deep) {\n            if (!fabric.isLikelyNode && source instanceof Element) {\n                // avoid cloning deep images, canvases,\n                destination = source;\n            } else if (source instanceof Array) {\n                destination = [];\n                for(var i = 0, len = source.length; i < len; i++){\n                    destination[i] = extend({}, source[i], deep);\n                }\n            } else if (source && typeof source === \"object\") {\n                for(var property in source){\n                    if (property === \"canvas\" || property === \"group\") {\n                        // we do not want to clone this props at all.\n                        // we want to keep the keys in the copy\n                        destination[property] = null;\n                    } else if (source.hasOwnProperty(property)) {\n                        destination[property] = extend({}, source[property], deep);\n                    }\n                }\n            } else {\n                // this sounds odd for an extend but is ok for recursive use\n                destination = source;\n            }\n        } else {\n            for(var property in source){\n                destination[property] = source[property];\n            }\n        }\n        return destination;\n    }\n    /**\n   * Creates an empty object and copies all enumerable properties of another object to it\n   * This method is mostly for internal use, and not intended for duplicating shapes in canvas. \n   * @memberOf fabric.util.object\n   * @param {Object} object Object to clone\n   * @param {Boolean} [deep] Whether to clone nested objects\n   * @return {Object}\n   */ //TODO: this function return an empty object if you try to clone null\n    function clone(object, deep) {\n        return extend({}, object, deep);\n    }\n    /** @namespace fabric.util.object */ fabric.util.object = {\n        extend: extend,\n        clone: clone\n    };\n    fabric.util.object.extend(fabric.util, fabric.Observable);\n})();\n(function() {\n    /**\n   * Camelizes a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to camelize\n   * @return {String} Camelized version of a string\n   */ function camelize(string) {\n        return string.replace(/-+(.)?/g, function(match, character) {\n            return character ? character.toUpperCase() : \"\";\n        });\n    }\n    /**\n   * Capitalizes a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to capitalize\n   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized\n   * and other letters stay untouched, if false first letter is capitalized\n   * and other letters are converted to lowercase.\n   * @return {String} Capitalized version of a string\n   */ function capitalize(string, firstLetterOnly) {\n        return string.charAt(0).toUpperCase() + (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());\n    }\n    /**\n   * Escapes XML in a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to escape\n   * @return {String} Escaped version of a string\n   */ function escapeXml(string) {\n        return string.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&apos;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n    /**\n   * Divide a string in the user perceived single units\n   * @memberOf fabric.util.string\n   * @param {String} textstring String to escape\n   * @return {Array} array containing the graphemes\n   */ function graphemeSplit(textstring) {\n        var i = 0, chr, graphemes = [];\n        for(i = 0, chr; i < textstring.length; i++){\n            if ((chr = getWholeChar(textstring, i)) === false) {\n                continue;\n            }\n            graphemes.push(chr);\n        }\n        return graphemes;\n    }\n    // taken from mdn in the charAt doc page.\n    function getWholeChar(str, i) {\n        var code = str.charCodeAt(i);\n        if (isNaN(code)) {\n            return \"\"; // Position not found\n        }\n        if (code < 0xD800 || code > 0xDFFF) {\n            return str.charAt(i);\n        }\n        // High surrogate (could change last hex to 0xDB7F to treat high private\n        // surrogates as single characters)\n        if (0xD800 <= code && code <= 0xDBFF) {\n            if (str.length <= i + 1) {\n                throw \"High surrogate without following low surrogate\";\n            }\n            var next = str.charCodeAt(i + 1);\n            if (0xDC00 > next || next > 0xDFFF) {\n                throw \"High surrogate without following low surrogate\";\n            }\n            return str.charAt(i) + str.charAt(i + 1);\n        }\n        // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n        if (i === 0) {\n            throw \"Low surrogate without preceding high surrogate\";\n        }\n        var prev = str.charCodeAt(i - 1);\n        // (could change last hex to 0xDB7F to treat high private\n        // surrogates as single characters)\n        if (0xD800 > prev || prev > 0xDBFF) {\n            throw \"Low surrogate without preceding high surrogate\";\n        }\n        // We can pass over low surrogates now as the second component\n        // in a pair which we have already processed\n        return false;\n    }\n    /**\n   * String utilities\n   * @namespace fabric.util.string\n   */ fabric.util.string = {\n        camelize: camelize,\n        capitalize: capitalize,\n        escapeXml: escapeXml,\n        graphemeSplit: graphemeSplit\n    };\n})();\n(function() {\n    var slice = Array.prototype.slice, emptyFunction = function() {}, IS_DONTENUM_BUGGY = function() {\n        for(var p in {\n            toString: 1\n        }){\n            if (p === \"toString\") {\n                return false;\n            }\n        }\n        return true;\n    }(), /** @ignore */ addMethods = function(klass, source, parent) {\n        for(var property in source){\n            if (property in klass.prototype && typeof klass.prototype[property] === \"function\" && (source[property] + \"\").indexOf(\"callSuper\") > -1) {\n                klass.prototype[property] = function(property) {\n                    return function() {\n                        var superclass = this.constructor.superclass;\n                        this.constructor.superclass = parent;\n                        var returnValue = source[property].apply(this, arguments);\n                        this.constructor.superclass = superclass;\n                        if (property !== \"initialize\") {\n                            return returnValue;\n                        }\n                    };\n                }(property);\n            } else {\n                klass.prototype[property] = source[property];\n            }\n            if (IS_DONTENUM_BUGGY) {\n                if (source.toString !== Object.prototype.toString) {\n                    klass.prototype.toString = source.toString;\n                }\n                if (source.valueOf !== Object.prototype.valueOf) {\n                    klass.prototype.valueOf = source.valueOf;\n                }\n            }\n        }\n    };\n    function Subclass() {}\n    function callSuper(methodName) {\n        var parentMethod = null, _this = this;\n        // climb prototype chain to find method not equal to callee's method\n        while(_this.constructor.superclass){\n            var superClassMethod = _this.constructor.superclass.prototype[methodName];\n            if (_this[methodName] !== superClassMethod) {\n                parentMethod = superClassMethod;\n                break;\n            }\n            // eslint-disable-next-line\n            _this = _this.constructor.superclass.prototype;\n        }\n        if (!parentMethod) {\n            return console.log(\"tried to callSuper \" + methodName + \", method not found in prototype chain\", this);\n        }\n        return arguments.length > 1 ? parentMethod.apply(this, slice.call(arguments, 1)) : parentMethod.call(this);\n    }\n    /**\n   * Helper for creation of \"classes\".\n   * @memberOf fabric.util\n   * @param {Function} [parent] optional \"Class\" to inherit from\n   * @param {Object} [properties] Properties shared by all instances of this class\n   *                  (be careful modifying objects defined here as this would affect all instances)\n   */ function createClass() {\n        var parent = null, properties = slice.call(arguments, 0);\n        if (typeof properties[0] === \"function\") {\n            parent = properties.shift();\n        }\n        function klass() {\n            this.initialize.apply(this, arguments);\n        }\n        klass.superclass = parent;\n        klass.subclasses = [];\n        if (parent) {\n            Subclass.prototype = parent.prototype;\n            klass.prototype = new Subclass();\n            parent.subclasses.push(klass);\n        }\n        for(var i = 0, length = properties.length; i < length; i++){\n            addMethods(klass, properties[i], parent);\n        }\n        if (!klass.prototype.initialize) {\n            klass.prototype.initialize = emptyFunction;\n        }\n        klass.prototype.constructor = klass;\n        klass.prototype.callSuper = callSuper;\n        return klass;\n    }\n    fabric.util.createClass = createClass;\n})();\n(function() {\n    // since ie11 can use addEventListener but they do not support options, i need to check\n    var couldUseAttachEvent = !!fabric.document.createElement(\"div\").attachEvent, touchEvents = [\n        \"touchstart\",\n        \"touchmove\",\n        \"touchend\"\n    ];\n    /**\n   * Adds an event listener to an element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {String} eventName\n   * @param {Function} handler\n   */ fabric.util.addListener = function(element, eventName, handler, options) {\n        element && element.addEventListener(eventName, handler, couldUseAttachEvent ? false : options);\n    };\n    /**\n   * Removes an event listener from an element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {String} eventName\n   * @param {Function} handler\n   */ fabric.util.removeListener = function(element, eventName, handler, options) {\n        element && element.removeEventListener(eventName, handler, couldUseAttachEvent ? false : options);\n    };\n    function getTouchInfo(event) {\n        var touchProp = event.changedTouches;\n        if (touchProp && touchProp[0]) {\n            return touchProp[0];\n        }\n        return event;\n    }\n    fabric.util.getPointer = function(event) {\n        var element = event.target, scroll = fabric.util.getScrollLeftTop(element), _evt = getTouchInfo(event);\n        return {\n            x: _evt.clientX + scroll.left,\n            y: _evt.clientY + scroll.top\n        };\n    };\n    fabric.util.isTouchEvent = function(event) {\n        return touchEvents.indexOf(event.type) > -1 || event.pointerType === \"touch\";\n    };\n})();\n(function() {\n    /**\n   * Cross-browser wrapper for setting element's style\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {Object} styles\n   * @return {HTMLElement} Element that was passed as a first argument\n   */ function setStyle(element, styles) {\n        var elementStyle = element.style;\n        if (!elementStyle) {\n            return element;\n        }\n        if (typeof styles === \"string\") {\n            element.style.cssText += \";\" + styles;\n            return styles.indexOf(\"opacity\") > -1 ? setOpacity(element, styles.match(/opacity:\\s*(\\d?\\.?\\d*)/)[1]) : element;\n        }\n        for(var property in styles){\n            if (property === \"opacity\") {\n                setOpacity(element, styles[property]);\n            } else {\n                var normalizedProperty = property === \"float\" || property === \"cssFloat\" ? typeof elementStyle.styleFloat === \"undefined\" ? \"cssFloat\" : \"styleFloat\" : property;\n                elementStyle.setProperty(normalizedProperty, styles[property]);\n            }\n        }\n        return element;\n    }\n    var parseEl = fabric.document.createElement(\"div\"), supportsOpacity = typeof parseEl.style.opacity === \"string\", supportsFilters = typeof parseEl.style.filter === \"string\", reOpacity = /alpha\\s*\\(\\s*opacity\\s*=\\s*([^\\)]+)\\)/, /** @ignore */ setOpacity = function(element) {\n        return element;\n    };\n    if (supportsOpacity) {\n        /** @ignore */ setOpacity = function(element, value) {\n            element.style.opacity = value;\n            return element;\n        };\n    } else if (supportsFilters) {\n        /** @ignore */ setOpacity = function(element, value) {\n            var es = element.style;\n            if (element.currentStyle && !element.currentStyle.hasLayout) {\n                es.zoom = 1;\n            }\n            if (reOpacity.test(es.filter)) {\n                value = value >= 0.9999 ? \"\" : \"alpha(opacity=\" + value * 100 + \")\";\n                es.filter = es.filter.replace(reOpacity, value);\n            } else {\n                es.filter += \" alpha(opacity=\" + value * 100 + \")\";\n            }\n            return element;\n        };\n    }\n    fabric.util.setStyle = setStyle;\n})();\n(function() {\n    var _slice = Array.prototype.slice;\n    /**\n   * Takes id and returns an element with that id (if one exists in a document)\n   * @memberOf fabric.util\n   * @param {String|HTMLElement} id\n   * @return {HTMLElement|null}\n   */ function getById(id) {\n        return typeof id === \"string\" ? fabric.document.getElementById(id) : id;\n    }\n    var sliceCanConvertNodelists, /**\n       * Converts an array-like object (e.g. arguments or NodeList) to an array\n       * @memberOf fabric.util\n       * @param {Object} arrayLike\n       * @return {Array}\n       */ toArray = function(arrayLike) {\n        return _slice.call(arrayLike, 0);\n    };\n    try {\n        sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;\n    } catch (err) {}\n    if (!sliceCanConvertNodelists) {\n        toArray = function(arrayLike) {\n            var arr = new Array(arrayLike.length), i = arrayLike.length;\n            while(i--){\n                arr[i] = arrayLike[i];\n            }\n            return arr;\n        };\n    }\n    /**\n   * Creates specified element with specified attributes\n   * @memberOf fabric.util\n   * @param {String} tagName Type of an element to create\n   * @param {Object} [attributes] Attributes to set on an element\n   * @return {HTMLElement} Newly created element\n   */ function makeElement(tagName, attributes) {\n        var el = fabric.document.createElement(tagName);\n        for(var prop in attributes){\n            if (prop === \"class\") {\n                el.className = attributes[prop];\n            } else if (prop === \"for\") {\n                el.htmlFor = attributes[prop];\n            } else {\n                el.setAttribute(prop, attributes[prop]);\n            }\n        }\n        return el;\n    }\n    /**\n   * Adds class to an element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to add class to\n   * @param {String} className Class to add to an element\n   */ function addClass(element, className) {\n        if (element && (\" \" + element.className + \" \").indexOf(\" \" + className + \" \") === -1) {\n            element.className += (element.className ? \" \" : \"\") + className;\n        }\n    }\n    /**\n   * Wraps element with another element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to wrap\n   * @param {HTMLElement|String} wrapper Element to wrap with\n   * @param {Object} [attributes] Attributes to set on a wrapper\n   * @return {HTMLElement} wrapper\n   */ function wrapElement(element, wrapper, attributes) {\n        if (typeof wrapper === \"string\") {\n            wrapper = makeElement(wrapper, attributes);\n        }\n        if (element.parentNode) {\n            element.parentNode.replaceChild(wrapper, element);\n        }\n        wrapper.appendChild(element);\n        return wrapper;\n    }\n    /**\n   * Returns element scroll offsets\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to operate on\n   * @return {Object} Object with left/top values\n   */ function getScrollLeftTop(element) {\n        var left = 0, top = 0, docElement = fabric.document.documentElement, body = fabric.document.body || {\n            scrollLeft: 0,\n            scrollTop: 0\n        };\n        // While loop checks (and then sets element to) .parentNode OR .host\n        //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,\n        //  but the .parentNode of a root ShadowDOM node will always be null, instead\n        //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938\n        while(element && (element.parentNode || element.host)){\n            // Set element to element parent, or 'host' in case of ShadowDOM\n            element = element.parentNode || element.host;\n            if (element === fabric.document) {\n                left = body.scrollLeft || docElement.scrollLeft || 0;\n                top = body.scrollTop || docElement.scrollTop || 0;\n            } else {\n                left += element.scrollLeft || 0;\n                top += element.scrollTop || 0;\n            }\n            if (element.nodeType === 1 && element.style.position === \"fixed\") {\n                break;\n            }\n        }\n        return {\n            left: left,\n            top: top\n        };\n    }\n    /**\n   * Returns offset for a given element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to get offset for\n   * @return {Object} Object with \"left\" and \"top\" properties\n   */ function getElementOffset(element) {\n        var docElem, doc = element && element.ownerDocument, box = {\n            left: 0,\n            top: 0\n        }, offset = {\n            left: 0,\n            top: 0\n        }, scrollLeftTop, offsetAttributes = {\n            borderLeftWidth: \"left\",\n            borderTopWidth: \"top\",\n            paddingLeft: \"left\",\n            paddingTop: \"top\"\n        };\n        if (!doc) {\n            return offset;\n        }\n        for(var attr in offsetAttributes){\n            offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;\n        }\n        docElem = doc.documentElement;\n        if (typeof element.getBoundingClientRect !== \"undefined\") {\n            box = element.getBoundingClientRect();\n        }\n        scrollLeftTop = getScrollLeftTop(element);\n        return {\n            left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,\n            top: box.top + scrollLeftTop.top - (docElem.clientTop || 0) + offset.top\n        };\n    }\n    /**\n   * Returns style attribute value of a given element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to get style attribute for\n   * @param {String} attr Style attribute to get for element\n   * @return {String} Style attribute value of the given element.\n   */ var getElementStyle;\n    if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {\n        getElementStyle = function(element, attr) {\n            var style = fabric.document.defaultView.getComputedStyle(element, null);\n            return style ? style[attr] : undefined;\n        };\n    } else {\n        getElementStyle = function(element, attr) {\n            var value = element.style[attr];\n            if (!value && element.currentStyle) {\n                value = element.currentStyle[attr];\n            }\n            return value;\n        };\n    }\n    (function() {\n        var style = fabric.document.documentElement.style, selectProp = \"userSelect\" in style ? \"userSelect\" : \"MozUserSelect\" in style ? \"MozUserSelect\" : \"WebkitUserSelect\" in style ? \"WebkitUserSelect\" : \"KhtmlUserSelect\" in style ? \"KhtmlUserSelect\" : \"\";\n        /**\n     * Makes element unselectable\n     * @memberOf fabric.util\n     * @param {HTMLElement} element Element to make unselectable\n     * @return {HTMLElement} Element that was passed in\n     */ function makeElementUnselectable(element) {\n            if (typeof element.onselectstart !== \"undefined\") {\n                element.onselectstart = fabric.util.falseFunction;\n            }\n            if (selectProp) {\n                element.style[selectProp] = \"none\";\n            } else if (typeof element.unselectable === \"string\") {\n                element.unselectable = \"on\";\n            }\n            return element;\n        }\n        /**\n     * Makes element selectable\n     * @memberOf fabric.util\n     * @param {HTMLElement} element Element to make selectable\n     * @return {HTMLElement} Element that was passed in\n     */ function makeElementSelectable(element) {\n            if (typeof element.onselectstart !== \"undefined\") {\n                element.onselectstart = null;\n            }\n            if (selectProp) {\n                element.style[selectProp] = \"\";\n            } else if (typeof element.unselectable === \"string\") {\n                element.unselectable = \"\";\n            }\n            return element;\n        }\n        fabric.util.makeElementUnselectable = makeElementUnselectable;\n        fabric.util.makeElementSelectable = makeElementSelectable;\n    })();\n    function getNodeCanvas(element) {\n        var impl = fabric.jsdomImplForWrapper(element);\n        return impl._canvas || impl._image;\n    }\n    ;\n    function cleanUpJsdomNode(element) {\n        if (!fabric.isLikelyNode) {\n            return;\n        }\n        var impl = fabric.jsdomImplForWrapper(element);\n        if (impl) {\n            impl._image = null;\n            impl._canvas = null;\n            // unsure if necessary\n            impl._currentSrc = null;\n            impl._attributes = null;\n            impl._classList = null;\n        }\n    }\n    function setImageSmoothing(ctx, value) {\n        ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;\n        ctx.imageSmoothingEnabled = value;\n    }\n    /**\n   * setImageSmoothing sets the context imageSmoothingEnabled property.\n   * Used by canvas and by ImageObject.\n   * @memberOf fabric.util\n   * @since 4.0.0\n   * @param {HTMLRenderingContext2D} ctx to set on\n   * @param {Boolean} value true or false\n   */ fabric.util.setImageSmoothing = setImageSmoothing;\n    fabric.util.getById = getById;\n    fabric.util.toArray = toArray;\n    fabric.util.addClass = addClass;\n    fabric.util.makeElement = makeElement;\n    fabric.util.wrapElement = wrapElement;\n    fabric.util.getScrollLeftTop = getScrollLeftTop;\n    fabric.util.getElementOffset = getElementOffset;\n    fabric.util.getNodeCanvas = getNodeCanvas;\n    fabric.util.cleanUpJsdomNode = cleanUpJsdomNode;\n})();\n(function() {\n    function addParamToUrl(url, param) {\n        return url + (/\\?/.test(url) ? \"&\" : \"?\") + param;\n    }\n    function emptyFn() {}\n    /**\n   * Cross-browser abstraction for sending XMLHttpRequest\n   * @memberOf fabric.util\n   * @param {String} url URL to send XMLHttpRequest to\n   * @param {Object} [options] Options object\n   * @param {String} [options.method=\"GET\"]\n   * @param {String} [options.parameters] parameters to append to url in GET or in body\n   * @param {String} [options.body] body to send with POST or PUT request\n   * @param {Function} options.onComplete Callback to invoke when request is completed\n   * @return {XMLHttpRequest} request\n   */ function request(url, options) {\n        options || (options = {});\n        var method = options.method ? options.method.toUpperCase() : \"GET\", onComplete = options.onComplete || function() {}, xhr = new fabric.window.XMLHttpRequest(), body = options.body || options.parameters;\n        /** @ignore */ xhr.onreadystatechange = function() {\n            if (xhr.readyState === 4) {\n                onComplete(xhr);\n                xhr.onreadystatechange = emptyFn;\n            }\n        };\n        if (method === \"GET\") {\n            body = null;\n            if (typeof options.parameters === \"string\") {\n                url = addParamToUrl(url, options.parameters);\n            }\n        }\n        xhr.open(method, url, true);\n        if (method === \"POST\" || method === \"PUT\") {\n            xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        }\n        xhr.send(body);\n        return xhr;\n    }\n    fabric.util.request = request;\n})();\n/**\n * Wrapper around `console.log` (when available)\n * @param {*} [values] Values to log\n */ fabric.log = console.log;\n/**\n * Wrapper around `console.warn` (when available)\n * @param {*} [values] Values to log as a warning\n */ fabric.warn = console.warn;\n(function() {\n    var extend = fabric.util.object.extend, clone = fabric.util.object.clone;\n    /**\n   * @typedef {Object} AnimationOptions\n   * Animation of a value or list of values.\n   * When using lists, think of something like this:\n   * fabric.util.animate({\n   *   startValue: [1, 2, 3],\n   *   endValue: [2, 4, 6],\n   *   onChange: function([a, b, c]) {\n   *     canvas.zoomToPoint({x: b, y: c}, a)\n   *     canvas.renderAll()\n   *   }\n   * });\n   * @example\n   * @property {Function} [onChange] Callback; invoked on every value change\n   * @property {Function} [onComplete] Callback; invoked when value change is completed\n   * @example\n   * // Note: startValue, endValue, and byValue must match the type\n   * var animationOptions = { startValue: 0, endValue: 1, byValue: 0.25 }\n   * var animationOptions = { startValue: [0, 1], endValue: [1, 2], byValue: [0.25, 0.25] }\n   * @property {number | number[]} [startValue=0] Starting value\n   * @property {number | number[]} [endValue=100] Ending value\n   * @property {number | number[]} [byValue=100] Value to modify the property by\n   * @property {Function} [easing] Easing function\n   * @property {Number} [duration=500] Duration of change (in ms)\n   * @property {Function} [abort] Additional function with logic. If returns true, animation aborts.\n   *\n   * @typedef {() => void} CancelFunction\n   *\n   * @typedef {Object} AnimationCurrentState\n   * @property {number | number[]} currentValue value in range [`startValue`, `endValue`]\n   * @property {number} completionRate value in range [0, 1]\n   * @property {number} durationRate value in range [0, 1]\n   *\n   * @typedef {(AnimationOptions & AnimationCurrentState & { cancel: CancelFunction }} AnimationContext\n   */ /**\n   * Array holding all running animations\n   * @memberof fabric\n   * @type {AnimationContext[]}\n   */ var RUNNING_ANIMATIONS = [];\n    fabric.util.object.extend(RUNNING_ANIMATIONS, {\n        /**\n     * cancel all running animations at the next requestAnimFrame\n     * @returns {AnimationContext[]}\n     */ cancelAll: function() {\n            var animations = this.splice(0);\n            animations.forEach(function(animation) {\n                animation.cancel();\n            });\n            return animations;\n        },\n        /**\n     * cancel all running animations attached to canvas at the next requestAnimFrame\n     * @param {fabric.Canvas} canvas\n     * @returns {AnimationContext[]}\n     */ cancelByCanvas: function(canvas) {\n            if (!canvas) {\n                return [];\n            }\n            var cancelled = this.filter(function(animation) {\n                return typeof animation.target === \"object\" && animation.target.canvas === canvas;\n            });\n            cancelled.forEach(function(animation) {\n                animation.cancel();\n            });\n            return cancelled;\n        },\n        /**\n     * cancel all running animations for target at the next requestAnimFrame\n     * @param {*} target\n     * @returns {AnimationContext[]}\n     */ cancelByTarget: function(target) {\n            var cancelled = this.findAnimationsByTarget(target);\n            cancelled.forEach(function(animation) {\n                animation.cancel();\n            });\n            return cancelled;\n        },\n        /**\n     *\n     * @param {CancelFunction} cancelFunc the function returned by animate\n     * @returns {number}\n     */ findAnimationIndex: function(cancelFunc) {\n            return this.indexOf(this.findAnimation(cancelFunc));\n        },\n        /**\n     *\n     * @param {CancelFunction} cancelFunc the function returned by animate\n     * @returns {AnimationContext | undefined} animation's options object\n     */ findAnimation: function(cancelFunc) {\n            return this.find(function(animation) {\n                return animation.cancel === cancelFunc;\n            });\n        },\n        /**\n     *\n     * @param {*} target the object that is assigned to the target property of the animation context\n     * @returns {AnimationContext[]} array of animation options object associated with target\n     */ findAnimationsByTarget: function(target) {\n            if (!target) {\n                return [];\n            }\n            return this.filter(function(animation) {\n                return animation.target === target;\n            });\n        }\n    });\n    function noop() {\n        return false;\n    }\n    function defaultEasing(t, b, c, d) {\n        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n    }\n    /**\n   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.\n   * @memberOf fabric.util\n   * @param {AnimationOptions} [options] Animation options\n   * @example\n   * // Note: startValue, endValue, and byValue must match the type\n   * fabric.util.animate({ startValue: 0, endValue: 1, byValue: 0.25 })\n   * fabric.util.animate({ startValue: [0, 1], endValue: [1, 2], byValue: [0.25, 0.25] })\n   * @returns {CancelFunction} cancel function\n   */ function animate(options) {\n        options || (options = {});\n        var cancel = false, context, removeFromRegistry = function() {\n            var index = fabric.runningAnimations.indexOf(context);\n            return index > -1 && fabric.runningAnimations.splice(index, 1)[0];\n        };\n        context = extend(clone(options), {\n            cancel: function() {\n                cancel = true;\n                return removeFromRegistry();\n            },\n            currentValue: \"startValue\" in options ? options.startValue : 0,\n            completionRate: 0,\n            durationRate: 0\n        });\n        fabric.runningAnimations.push(context);\n        requestAnimFrame(function(timestamp) {\n            var start = timestamp || +new Date(), duration = options.duration || 500, finish = start + duration, time, onChange = options.onChange || noop, abort = options.abort || noop, onComplete = options.onComplete || noop, easing = options.easing || defaultEasing, isMany = \"startValue\" in options ? options.startValue.length > 0 : false, startValue = \"startValue\" in options ? options.startValue : 0, endValue = \"endValue\" in options ? options.endValue : 100, byValue = options.byValue || (isMany ? startValue.map(function(value, i) {\n                return endValue[i] - startValue[i];\n            }) : endValue - startValue);\n            options.onStart && options.onStart();\n            (function tick(ticktime) {\n                time = ticktime || +new Date();\n                var currentTime = time > finish ? duration : time - start, timePerc = currentTime / duration, current = isMany ? startValue.map(function(_value, i) {\n                    return easing(currentTime, startValue[i], byValue[i], duration);\n                }) : easing(currentTime, startValue, byValue, duration), valuePerc = isMany ? Math.abs((current[0] - startValue[0]) / byValue[0]) : Math.abs((current - startValue) / byValue);\n                //  update context\n                context.currentValue = isMany ? current.slice() : current;\n                context.completionRate = valuePerc;\n                context.durationRate = timePerc;\n                if (cancel) {\n                    return;\n                }\n                if (abort(current, valuePerc, timePerc)) {\n                    removeFromRegistry();\n                    return;\n                }\n                if (time > finish) {\n                    //  update context\n                    context.currentValue = isMany ? endValue.slice() : endValue;\n                    context.completionRate = 1;\n                    context.durationRate = 1;\n                    //  execute callbacks\n                    onChange(isMany ? endValue.slice() : endValue, 1, 1);\n                    onComplete(endValue, 1, 1);\n                    removeFromRegistry();\n                    return;\n                } else {\n                    onChange(current, valuePerc, timePerc);\n                    requestAnimFrame(tick);\n                }\n            })(start);\n        });\n        return context.cancel;\n    }\n    var _requestAnimFrame = fabric.window.requestAnimationFrame || fabric.window.webkitRequestAnimationFrame || fabric.window.mozRequestAnimationFrame || fabric.window.oRequestAnimationFrame || fabric.window.msRequestAnimationFrame || function(callback) {\n        return fabric.window.setTimeout(callback, 1000 / 60);\n    };\n    var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;\n    /**\n   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method\n   * @memberOf fabric.util\n   * @param {Function} callback Callback to invoke\n   * @param {DOMElement} element optional Element to associate with animation\n   */ function requestAnimFrame() {\n        return _requestAnimFrame.apply(fabric.window, arguments);\n    }\n    function cancelAnimFrame() {\n        return _cancelAnimFrame.apply(fabric.window, arguments);\n    }\n    fabric.util.animate = animate;\n    fabric.util.requestAnimFrame = requestAnimFrame;\n    fabric.util.cancelAnimFrame = cancelAnimFrame;\n    fabric.runningAnimations = RUNNING_ANIMATIONS;\n})();\n(function() {\n    // Calculate an in-between color. Returns a \"rgba()\" string.\n    // Credit: Edwin Martin <edwin@bitstorm.org>\n    //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js\n    function calculateColor(begin, end, pos) {\n        var color = \"rgba(\" + parseInt(begin[0] + pos * (end[0] - begin[0]), 10) + \",\" + parseInt(begin[1] + pos * (end[1] - begin[1]), 10) + \",\" + parseInt(begin[2] + pos * (end[2] - begin[2]), 10);\n        color += \",\" + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);\n        color += \")\";\n        return color;\n    }\n    /**\n   * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.\n   * @memberOf fabric.util\n   * @param {String} fromColor The starting color in hex or rgb(a) format.\n   * @param {String} toColor The starting color in hex or rgb(a) format.\n   * @param {Number} [duration] Duration of change (in ms).\n   * @param {Object} [options] Animation options\n   * @param {Function} [options.onChange] Callback; invoked on every value change\n   * @param {Function} [options.onComplete] Callback; invoked when value change is completed\n   * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.\n   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.\n   * @returns {Function} abort function\n   */ function animateColor(fromColor, toColor, duration, options) {\n        var startColor = new fabric.Color(fromColor).getSource(), endColor = new fabric.Color(toColor).getSource(), originalOnComplete = options.onComplete, originalOnChange = options.onChange;\n        options = options || {};\n        return fabric.util.animate(fabric.util.object.extend(options, {\n            duration: duration || 500,\n            startValue: startColor,\n            endValue: endColor,\n            byValue: endColor,\n            easing: function(currentTime, startValue, byValue, duration) {\n                var posValue = options.colorEasing ? options.colorEasing(currentTime, duration) : 1 - Math.cos(currentTime / duration * (Math.PI / 2));\n                return calculateColor(startValue, byValue, posValue);\n            },\n            // has to take in account for color restoring;\n            onComplete: function(current, valuePerc, timePerc) {\n                if (originalOnComplete) {\n                    return originalOnComplete(calculateColor(endColor, endColor, 0), valuePerc, timePerc);\n                }\n            },\n            onChange: function(current, valuePerc, timePerc) {\n                if (originalOnChange) {\n                    if (Array.isArray(current)) {\n                        return originalOnChange(calculateColor(current, current, 0), valuePerc, timePerc);\n                    }\n                    originalOnChange(current, valuePerc, timePerc);\n                }\n            }\n        }));\n    }\n    fabric.util.animateColor = animateColor;\n})();\n(function() {\n    function normalize(a, c, p, s) {\n        if (a < Math.abs(c)) {\n            a = c;\n            s = p / 4;\n        } else {\n            //handle the 0/0 case:\n            if (c === 0 && a === 0) {\n                s = p / (2 * Math.PI) * Math.asin(1);\n            } else {\n                s = p / (2 * Math.PI) * Math.asin(c / a);\n            }\n        }\n        return {\n            a: a,\n            c: c,\n            p: p,\n            s: s\n        };\n    }\n    function elastic(opts, t, d) {\n        return opts.a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p);\n    }\n    /**\n   * Cubic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutCubic(t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t + 1) + b;\n    }\n    /**\n   * Cubic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutCubic(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * t * t * t + b;\n        }\n        return c / 2 * ((t -= 2) * t * t + 2) + b;\n    }\n    /**\n   * Quartic easing in\n   * @memberOf fabric.util.ease\n   */ function easeInQuart(t, b, c, d) {\n        return c * (t /= d) * t * t * t + b;\n    }\n    /**\n   * Quartic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutQuart(t, b, c, d) {\n        return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n    }\n    /**\n   * Quartic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutQuart(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * t * t * t * t + b;\n        }\n        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n    }\n    /**\n   * Quintic easing in\n   * @memberOf fabric.util.ease\n   */ function easeInQuint(t, b, c, d) {\n        return c * (t /= d) * t * t * t * t + b;\n    }\n    /**\n   * Quintic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutQuint(t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n    }\n    /**\n   * Quintic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutQuint(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * t * t * t * t * t + b;\n        }\n        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n    }\n    /**\n   * Sinusoidal easing in\n   * @memberOf fabric.util.ease\n   */ function easeInSine(t, b, c, d) {\n        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n    }\n    /**\n   * Sinusoidal easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutSine(t, b, c, d) {\n        return c * Math.sin(t / d * (Math.PI / 2)) + b;\n    }\n    /**\n   * Sinusoidal easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutSine(t, b, c, d) {\n        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n    }\n    /**\n   * Exponential easing in\n   * @memberOf fabric.util.ease\n   */ function easeInExpo(t, b, c, d) {\n        return t === 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n    }\n    /**\n   * Exponential easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutExpo(t, b, c, d) {\n        return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n    }\n    /**\n   * Exponential easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutExpo(t, b, c, d) {\n        if (t === 0) {\n            return b;\n        }\n        if (t === d) {\n            return b + c;\n        }\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n        }\n        return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n    }\n    /**\n   * Circular easing in\n   * @memberOf fabric.util.ease\n   */ function easeInCirc(t, b, c, d) {\n        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n    }\n    /**\n   * Circular easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutCirc(t, b, c, d) {\n        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n    }\n    /**\n   * Circular easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutCirc(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n        }\n        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n    }\n    /**\n   * Elastic easing in\n   * @memberOf fabric.util.ease\n   */ function easeInElastic(t, b, c, d) {\n        var s = 1.70158, p = 0, a = c;\n        if (t === 0) {\n            return b;\n        }\n        t /= d;\n        if (t === 1) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * 0.3;\n        }\n        var opts = normalize(a, c, p, s);\n        return -elastic(opts, t, d) + b;\n    }\n    /**\n   * Elastic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutElastic(t, b, c, d) {\n        var s = 1.70158, p = 0, a = c;\n        if (t === 0) {\n            return b;\n        }\n        t /= d;\n        if (t === 1) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * 0.3;\n        }\n        var opts = normalize(a, c, p, s);\n        return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p) + opts.c + b;\n    }\n    /**\n   * Elastic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutElastic(t, b, c, d) {\n        var s = 1.70158, p = 0, a = c;\n        if (t === 0) {\n            return b;\n        }\n        t /= d / 2;\n        if (t === 2) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * (0.3 * 1.5);\n        }\n        var opts = normalize(a, c, p, s);\n        if (t < 1) {\n            return -0.5 * elastic(opts, t, d) + b;\n        }\n        return opts.a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p) * 0.5 + opts.c + b;\n    }\n    /**\n   * Backwards easing in\n   * @memberOf fabric.util.ease\n   */ function easeInBack(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        return c * (t /= d) * t * ((s + 1) * t - s) + b;\n    }\n    /**\n   * Backwards easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutBack(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n    }\n    /**\n   * Backwards easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutBack(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;\n        }\n        return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;\n    }\n    /**\n   * Bouncing easing in\n   * @memberOf fabric.util.ease\n   */ function easeInBounce(t, b, c, d) {\n        return c - easeOutBounce(d - t, 0, c, d) + b;\n    }\n    /**\n   * Bouncing easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutBounce(t, b, c, d) {\n        if ((t /= d) < 1 / 2.75) {\n            return c * (7.5625 * t * t) + b;\n        } else if (t < 2 / 2.75) {\n            return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;\n        } else if (t < 2.5 / 2.75) {\n            return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;\n        } else {\n            return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;\n        }\n    }\n    /**\n   * Bouncing easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutBounce(t, b, c, d) {\n        if (t < d / 2) {\n            return easeInBounce(t * 2, 0, c, d) * 0.5 + b;\n        }\n        return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;\n    }\n    /**\n   * Easing functions\n   * See <a href=\"http://gizma.com/easing/\">Easing Equations by Robert Penner</a>\n   * @namespace fabric.util.ease\n   */ fabric.util.ease = {\n        /**\n     * Quadratic easing in\n     * @memberOf fabric.util.ease\n     */ easeInQuad: function(t, b, c, d) {\n            return c * (t /= d) * t + b;\n        },\n        /**\n     * Quadratic easing out\n     * @memberOf fabric.util.ease\n     */ easeOutQuad: function(t, b, c, d) {\n            return -c * (t /= d) * (t - 2) + b;\n        },\n        /**\n     * Quadratic easing in and out\n     * @memberOf fabric.util.ease\n     */ easeInOutQuad: function(t, b, c, d) {\n            t /= d / 2;\n            if (t < 1) {\n                return c / 2 * t * t + b;\n            }\n            return -c / 2 * (--t * (t - 2) - 1) + b;\n        },\n        /**\n     * Cubic easing in\n     * @memberOf fabric.util.ease\n     */ easeInCubic: function(t, b, c, d) {\n            return c * (t /= d) * t * t + b;\n        },\n        easeOutCubic: easeOutCubic,\n        easeInOutCubic: easeInOutCubic,\n        easeInQuart: easeInQuart,\n        easeOutQuart: easeOutQuart,\n        easeInOutQuart: easeInOutQuart,\n        easeInQuint: easeInQuint,\n        easeOutQuint: easeOutQuint,\n        easeInOutQuint: easeInOutQuint,\n        easeInSine: easeInSine,\n        easeOutSine: easeOutSine,\n        easeInOutSine: easeInOutSine,\n        easeInExpo: easeInExpo,\n        easeOutExpo: easeOutExpo,\n        easeInOutExpo: easeInOutExpo,\n        easeInCirc: easeInCirc,\n        easeOutCirc: easeOutCirc,\n        easeInOutCirc: easeInOutCirc,\n        easeInElastic: easeInElastic,\n        easeOutElastic: easeOutElastic,\n        easeInOutElastic: easeInOutElastic,\n        easeInBack: easeInBack,\n        easeOutBack: easeOutBack,\n        easeInOutBack: easeInOutBack,\n        easeInBounce: easeInBounce,\n        easeOutBounce: easeOutBounce,\n        easeInOutBounce: easeInOutBounce\n    };\n})();\n(function(global) {\n    \"use strict\";\n    /**\n   * @name fabric\n   * @namespace\n   */ var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, clone = fabric.util.object.clone, toFixed = fabric.util.toFixed, parseUnit = fabric.util.parseUnit, multiplyTransformMatrices = fabric.util.multiplyTransformMatrices, svgValidTagNames = [\n        \"path\",\n        \"circle\",\n        \"polygon\",\n        \"polyline\",\n        \"ellipse\",\n        \"rect\",\n        \"line\",\n        \"image\",\n        \"text\"\n    ], svgViewBoxElements = [\n        \"symbol\",\n        \"image\",\n        \"marker\",\n        \"pattern\",\n        \"view\",\n        \"svg\"\n    ], svgInvalidAncestors = [\n        \"pattern\",\n        \"defs\",\n        \"symbol\",\n        \"metadata\",\n        \"clipPath\",\n        \"mask\",\n        \"desc\"\n    ], svgValidParents = [\n        \"symbol\",\n        \"g\",\n        \"a\",\n        \"svg\",\n        \"clipPath\",\n        \"defs\"\n    ], attributesMap = {\n        cx: \"left\",\n        x: \"left\",\n        r: \"radius\",\n        cy: \"top\",\n        y: \"top\",\n        display: \"visible\",\n        visibility: \"visible\",\n        transform: \"transformMatrix\",\n        \"fill-opacity\": \"fillOpacity\",\n        \"fill-rule\": \"fillRule\",\n        \"font-family\": \"fontFamily\",\n        \"font-size\": \"fontSize\",\n        \"font-style\": \"fontStyle\",\n        \"font-weight\": \"fontWeight\",\n        \"letter-spacing\": \"charSpacing\",\n        \"paint-order\": \"paintFirst\",\n        \"stroke-dasharray\": \"strokeDashArray\",\n        \"stroke-dashoffset\": \"strokeDashOffset\",\n        \"stroke-linecap\": \"strokeLineCap\",\n        \"stroke-linejoin\": \"strokeLineJoin\",\n        \"stroke-miterlimit\": \"strokeMiterLimit\",\n        \"stroke-opacity\": \"strokeOpacity\",\n        \"stroke-width\": \"strokeWidth\",\n        \"text-decoration\": \"textDecoration\",\n        \"text-anchor\": \"textAnchor\",\n        opacity: \"opacity\",\n        \"clip-path\": \"clipPath\",\n        \"clip-rule\": \"clipRule\",\n        \"vector-effect\": \"strokeUniform\",\n        \"image-rendering\": \"imageSmoothing\"\n    }, colorAttributes = {\n        stroke: \"strokeOpacity\",\n        fill: \"fillOpacity\"\n    }, fSize = \"font-size\", cPath = \"clip-path\";\n    fabric.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);\n    fabric.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);\n    fabric.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);\n    fabric.svgValidParentsRegEx = getSvgRegex(svgValidParents);\n    fabric.cssRules = {};\n    fabric.gradientDefs = {};\n    fabric.clipPaths = {};\n    function normalizeAttr(attr) {\n        // transform attribute names\n        if (attr in attributesMap) {\n            return attributesMap[attr];\n        }\n        return attr;\n    }\n    function normalizeValue(attr, value, parentAttributes, fontSize) {\n        var isArray = Array.isArray(value), parsed;\n        if ((attr === \"fill\" || attr === \"stroke\") && value === \"none\") {\n            value = \"\";\n        } else if (attr === \"strokeUniform\") {\n            return value === \"non-scaling-stroke\";\n        } else if (attr === \"strokeDashArray\") {\n            if (value === \"none\") {\n                value = null;\n            } else {\n                value = value.replace(/,/g, \" \").split(/\\s+/).map(parseFloat);\n            }\n        } else if (attr === \"transformMatrix\") {\n            if (parentAttributes && parentAttributes.transformMatrix) {\n                value = multiplyTransformMatrices(parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));\n            } else {\n                value = fabric.parseTransformAttribute(value);\n            }\n        } else if (attr === \"visible\") {\n            value = value !== \"none\" && value !== \"hidden\";\n            // display=none on parent element always takes precedence over child element\n            if (parentAttributes && parentAttributes.visible === false) {\n                value = false;\n            }\n        } else if (attr === \"opacity\") {\n            value = parseFloat(value);\n            if (parentAttributes && typeof parentAttributes.opacity !== \"undefined\") {\n                value *= parentAttributes.opacity;\n            }\n        } else if (attr === \"textAnchor\" /* text-anchor */ ) {\n            value = value === \"start\" ? \"left\" : value === \"end\" ? \"right\" : \"center\";\n        } else if (attr === \"charSpacing\") {\n            // parseUnit returns px and we convert it to em\n            parsed = parseUnit(value, fontSize) / fontSize * 1000;\n        } else if (attr === \"paintFirst\") {\n            var fillIndex = value.indexOf(\"fill\");\n            var strokeIndex = value.indexOf(\"stroke\");\n            var value = \"fill\";\n            if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {\n                value = \"stroke\";\n            } else if (fillIndex === -1 && strokeIndex > -1) {\n                value = \"stroke\";\n            }\n        } else if (attr === \"href\" || attr === \"xlink:href\" || attr === \"font\") {\n            return value;\n        } else if (attr === \"imageSmoothing\") {\n            return value === \"optimizeQuality\";\n        } else {\n            parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);\n        }\n        return !isArray && isNaN(parsed) ? value : parsed;\n    }\n    /**\n    * @private\n    */ function getSvgRegex(arr) {\n        return new RegExp(\"^(\" + arr.join(\"|\") + \")\\\\b\", \"i\");\n    }\n    /**\n   * @private\n   * @param {Object} attributes Array of attributes to parse\n   */ function _setStrokeFillOpacity(attributes) {\n        for(var attr in colorAttributes){\n            if (typeof attributes[colorAttributes[attr]] === \"undefined\" || attributes[attr] === \"\") {\n                continue;\n            }\n            if (typeof attributes[attr] === \"undefined\") {\n                if (!fabric.Object.prototype[attr]) {\n                    continue;\n                }\n                attributes[attr] = fabric.Object.prototype[attr];\n            }\n            if (attributes[attr].indexOf(\"url(\") === 0) {\n                continue;\n            }\n            var color = new fabric.Color(attributes[attr]);\n            attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();\n        }\n        return attributes;\n    }\n    /**\n   * @private\n   */ function _getMultipleNodes(doc, nodeNames) {\n        var nodeName, nodeArray = [], nodeList, i, len;\n        for(i = 0, len = nodeNames.length; i < len; i++){\n            nodeName = nodeNames[i];\n            nodeList = doc.getElementsByTagName(nodeName);\n            nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));\n        }\n        return nodeArray;\n    }\n    /**\n   * Parses \"transform\" attribute, returning an array of values\n   * @static\n   * @function\n   * @memberOf fabric\n   * @param {String} attributeValue String containing attribute value\n   * @return {Array} Array of 6 elements representing transformation matrix\n   */ fabric.parseTransformAttribute = function() {\n        function rotateMatrix(matrix, args) {\n            var cos = fabric.util.cos(args[0]), sin = fabric.util.sin(args[0]), x = 0, y = 0;\n            if (args.length === 3) {\n                x = args[1];\n                y = args[2];\n            }\n            matrix[0] = cos;\n            matrix[1] = sin;\n            matrix[2] = -sin;\n            matrix[3] = cos;\n            matrix[4] = x - (cos * x - sin * y);\n            matrix[5] = y - (sin * x + cos * y);\n        }\n        function scaleMatrix(matrix, args) {\n            var multiplierX = args[0], multiplierY = args.length === 2 ? args[1] : args[0];\n            matrix[0] = multiplierX;\n            matrix[3] = multiplierY;\n        }\n        function skewMatrix(matrix, args, pos) {\n            matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));\n        }\n        function translateMatrix(matrix, args) {\n            matrix[4] = args[0];\n            if (args.length === 2) {\n                matrix[5] = args[1];\n            }\n        }\n        // identity matrix\n        var iMatrix = fabric.iMatrix, // == begin transform regexp\n        number = fabric.reNum, commaWsp = fabric.commaWsp, skewX = \"(?:(skewX)\\\\s*\\\\(\\\\s*(\" + number + \")\\\\s*\\\\))\", skewY = \"(?:(skewY)\\\\s*\\\\(\\\\s*(\" + number + \")\\\\s*\\\\))\", rotate = \"(?:(rotate)\\\\s*\\\\(\\\\s*(\" + number + \")(?:\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \"))?\\\\s*\\\\))\", scale = \"(?:(scale)\\\\s*\\\\(\\\\s*(\" + number + \")(?:\" + commaWsp + \"(\" + number + \"))?\\\\s*\\\\))\", translate = \"(?:(translate)\\\\s*\\\\(\\\\s*(\" + number + \")(?:\" + commaWsp + \"(\" + number + \"))?\\\\s*\\\\))\", matrix = \"(?:(matrix)\\\\s*\\\\(\\\\s*\" + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + \"\\\\s*\\\\))\", transform = \"(?:\" + matrix + \"|\" + translate + \"|\" + scale + \"|\" + rotate + \"|\" + skewX + \"|\" + skewY + \")\", transforms = \"(?:\" + transform + \"(?:\" + commaWsp + \"*\" + transform + \")*\" + \")\", transformList = \"^\\\\s*(?:\" + transforms + \"?)\\\\s*$\", // http://www.w3.org/TR/SVG/coords.html#TransformAttribute\n        reTransformList = new RegExp(transformList), // == end transform regexp\n        reTransform = new RegExp(transform, \"g\");\n        return function(attributeValue) {\n            // start with identity matrix\n            var matrix = iMatrix.concat(), matrices = [];\n            // return if no argument was given or\n            // an argument does not match transform attribute regexp\n            if (!attributeValue || attributeValue && !reTransformList.test(attributeValue)) {\n                return matrix;\n            }\n            attributeValue.replace(reTransform, function(match) {\n                var m = new RegExp(transform).exec(match).filter(function(match) {\n                    // match !== '' && match != null\n                    return !!match;\n                }), operation = m[1], args = m.slice(2).map(parseFloat);\n                switch(operation){\n                    case \"translate\":\n                        translateMatrix(matrix, args);\n                        break;\n                    case \"rotate\":\n                        args[0] = fabric.util.degreesToRadians(args[0]);\n                        rotateMatrix(matrix, args);\n                        break;\n                    case \"scale\":\n                        scaleMatrix(matrix, args);\n                        break;\n                    case \"skewX\":\n                        skewMatrix(matrix, args, 2);\n                        break;\n                    case \"skewY\":\n                        skewMatrix(matrix, args, 1);\n                        break;\n                    case \"matrix\":\n                        matrix = args;\n                        break;\n                }\n                // snapshot current matrix into matrices array\n                matrices.push(matrix.concat());\n                // reset\n                matrix = iMatrix.concat();\n            });\n            var combinedMatrix = matrices[0];\n            while(matrices.length > 1){\n                matrices.shift();\n                combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);\n            }\n            return combinedMatrix;\n        };\n    }();\n    /**\n   * @private\n   */ function parseStyleString(style, oStyle) {\n        var attr, value;\n        style.replace(/;\\s*$/, \"\").split(\";\").forEach(function(chunk) {\n            var pair = chunk.split(\":\");\n            attr = pair[0].trim().toLowerCase();\n            value = pair[1].trim();\n            oStyle[attr] = value;\n        });\n    }\n    /**\n   * @private\n   */ function parseStyleObject(style, oStyle) {\n        var attr, value;\n        for(var prop in style){\n            if (typeof style[prop] === \"undefined\") {\n                continue;\n            }\n            attr = prop.toLowerCase();\n            value = style[prop];\n            oStyle[attr] = value;\n        }\n    }\n    /**\n   * @private\n   */ function getGlobalStylesForElement(element, svgUid) {\n        var styles = {};\n        for(var rule in fabric.cssRules[svgUid]){\n            if (elementMatchesRule(element, rule.split(\" \"))) {\n                for(var property in fabric.cssRules[svgUid][rule]){\n                    styles[property] = fabric.cssRules[svgUid][rule][property];\n                }\n            }\n        }\n        return styles;\n    }\n    /**\n   * @private\n   */ function elementMatchesRule(element, selectors) {\n        var firstMatching, parentMatching = true;\n        //start from rightmost selector.\n        firstMatching = selectorMatches(element, selectors.pop());\n        if (firstMatching && selectors.length) {\n            parentMatching = doesSomeParentMatch(element, selectors);\n        }\n        return firstMatching && parentMatching && selectors.length === 0;\n    }\n    function doesSomeParentMatch(element, selectors) {\n        var selector, parentMatching = true;\n        while(element.parentNode && element.parentNode.nodeType === 1 && selectors.length){\n            if (parentMatching) {\n                selector = selectors.pop();\n            }\n            element = element.parentNode;\n            parentMatching = selectorMatches(element, selector);\n        }\n        return selectors.length === 0;\n    }\n    /**\n   * @private\n   */ function selectorMatches(element, selector) {\n        var nodeName = element.nodeName, classNames = element.getAttribute(\"class\"), id = element.getAttribute(\"id\"), matcher, i;\n        // i check if a selector matches slicing away part from it.\n        // if i get empty string i should match\n        matcher = new RegExp(\"^\" + nodeName, \"i\");\n        selector = selector.replace(matcher, \"\");\n        if (id && selector.length) {\n            matcher = new RegExp(\"#\" + id + \"(?![a-zA-Z\\\\-]+)\", \"i\");\n            selector = selector.replace(matcher, \"\");\n        }\n        if (classNames && selector.length) {\n            classNames = classNames.split(\" \");\n            for(i = classNames.length; i--;){\n                matcher = new RegExp(\"\\\\.\" + classNames[i] + \"(?![a-zA-Z\\\\-]+)\", \"i\");\n                selector = selector.replace(matcher, \"\");\n            }\n        }\n        return selector.length === 0;\n    }\n    /**\n   * @private\n   * to support IE8 missing getElementById on SVGdocument and on node xmlDOM\n   */ function elementById(doc, id) {\n        var el;\n        doc.getElementById && (el = doc.getElementById(id));\n        if (el) {\n            return el;\n        }\n        var node, i, len, nodelist = doc.getElementsByTagName(\"*\");\n        for(i = 0, len = nodelist.length; i < len; i++){\n            node = nodelist[i];\n            if (id === node.getAttribute(\"id\")) {\n                return node;\n            }\n        }\n    }\n    /**\n   * @private\n   */ function parseUseDirectives(doc) {\n        var nodelist = _getMultipleNodes(doc, [\n            \"use\",\n            \"svg:use\"\n        ]), i = 0;\n        while(nodelist.length && i < nodelist.length){\n            var el = nodelist[i], xlinkAttribute = el.getAttribute(\"xlink:href\") || el.getAttribute(\"href\");\n            if (xlinkAttribute === null) {\n                return;\n            }\n            var xlink = xlinkAttribute.slice(1), x = el.getAttribute(\"x\") || 0, y = el.getAttribute(\"y\") || 0, el2 = elementById(doc, xlink).cloneNode(true), currentTrans = (el2.getAttribute(\"transform\") || \"\") + \" translate(\" + x + \", \" + y + \")\", parentNode, oldLength = nodelist.length, attr, j, attrs, len, namespace = fabric.svgNS;\n            applyViewboxTransform(el2);\n            if (/^svg$/i.test(el2.nodeName)) {\n                var el3 = el2.ownerDocument.createElementNS(namespace, \"g\");\n                for(j = 0, attrs = el2.attributes, len = attrs.length; j < len; j++){\n                    attr = attrs.item(j);\n                    el3.setAttributeNS(namespace, attr.nodeName, attr.nodeValue);\n                }\n                // el2.firstChild != null\n                while(el2.firstChild){\n                    el3.appendChild(el2.firstChild);\n                }\n                el2 = el3;\n            }\n            for(j = 0, attrs = el.attributes, len = attrs.length; j < len; j++){\n                attr = attrs.item(j);\n                if (attr.nodeName === \"x\" || attr.nodeName === \"y\" || attr.nodeName === \"xlink:href\" || attr.nodeName === \"href\") {\n                    continue;\n                }\n                if (attr.nodeName === \"transform\") {\n                    currentTrans = attr.nodeValue + \" \" + currentTrans;\n                } else {\n                    el2.setAttribute(attr.nodeName, attr.nodeValue);\n                }\n            }\n            el2.setAttribute(\"transform\", currentTrans);\n            el2.setAttribute(\"instantiated_by_use\", \"1\");\n            el2.removeAttribute(\"id\");\n            parentNode = el.parentNode;\n            parentNode.replaceChild(el2, el);\n            // some browsers do not shorten nodelist after replaceChild (IE8)\n            if (nodelist.length === oldLength) {\n                i++;\n            }\n        }\n    }\n    // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute\n    // matches, e.g.: +14.56e-12, etc.\n    var reViewBoxAttrValue = new RegExp(\"^\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*,?\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*,?\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*,?\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*\" + \"$\");\n    /**\n   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements\n   */ function applyViewboxTransform(element) {\n        if (!fabric.svgViewBoxElementsRegEx.test(element.nodeName)) {\n            return {};\n        }\n        var viewBoxAttr = element.getAttribute(\"viewBox\"), scaleX = 1, scaleY = 1, minX = 0, minY = 0, viewBoxWidth, viewBoxHeight, matrix, el, widthAttr = element.getAttribute(\"width\"), heightAttr = element.getAttribute(\"height\"), x = element.getAttribute(\"x\") || 0, y = element.getAttribute(\"y\") || 0, preserveAspectRatio = element.getAttribute(\"preserveAspectRatio\") || \"\", missingViewBox = !viewBoxAttr || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue)), missingDimAttr = !widthAttr || !heightAttr || widthAttr === \"100%\" || heightAttr === \"100%\", toBeParsed = missingViewBox && missingDimAttr, parsedDim = {}, translateMatrix = \"\", widthDiff = 0, heightDiff = 0;\n        parsedDim.width = 0;\n        parsedDim.height = 0;\n        parsedDim.toBeParsed = toBeParsed;\n        if (missingViewBox) {\n            if ((x || y) && element.parentNode && element.parentNode.nodeName !== \"#document\") {\n                translateMatrix = \" translate(\" + parseUnit(x) + \" \" + parseUnit(y) + \") \";\n                matrix = (element.getAttribute(\"transform\") || \"\") + translateMatrix;\n                element.setAttribute(\"transform\", matrix);\n                element.removeAttribute(\"x\");\n                element.removeAttribute(\"y\");\n            }\n        }\n        if (toBeParsed) {\n            return parsedDim;\n        }\n        if (missingViewBox) {\n            parsedDim.width = parseUnit(widthAttr);\n            parsedDim.height = parseUnit(heightAttr);\n            // set a transform for elements that have x y and are inner(only) SVGs\n            return parsedDim;\n        }\n        minX = -parseFloat(viewBoxAttr[1]);\n        minY = -parseFloat(viewBoxAttr[2]);\n        viewBoxWidth = parseFloat(viewBoxAttr[3]);\n        viewBoxHeight = parseFloat(viewBoxAttr[4]);\n        parsedDim.minX = minX;\n        parsedDim.minY = minY;\n        parsedDim.viewBoxWidth = viewBoxWidth;\n        parsedDim.viewBoxHeight = viewBoxHeight;\n        if (!missingDimAttr) {\n            parsedDim.width = parseUnit(widthAttr);\n            parsedDim.height = parseUnit(heightAttr);\n            scaleX = parsedDim.width / viewBoxWidth;\n            scaleY = parsedDim.height / viewBoxHeight;\n        } else {\n            parsedDim.width = viewBoxWidth;\n            parsedDim.height = viewBoxHeight;\n        }\n        // default is to preserve aspect ratio\n        preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);\n        if (preserveAspectRatio.alignX !== \"none\") {\n            //translate all container for the effect of Mid, Min, Max\n            if (preserveAspectRatio.meetOrSlice === \"meet\") {\n                scaleY = scaleX = scaleX > scaleY ? scaleY : scaleX;\n            // calculate additional translation to move the viewbox\n            }\n            if (preserveAspectRatio.meetOrSlice === \"slice\") {\n                scaleY = scaleX = scaleX > scaleY ? scaleX : scaleY;\n            // calculate additional translation to move the viewbox\n            }\n            widthDiff = parsedDim.width - viewBoxWidth * scaleX;\n            heightDiff = parsedDim.height - viewBoxHeight * scaleX;\n            if (preserveAspectRatio.alignX === \"Mid\") {\n                widthDiff /= 2;\n            }\n            if (preserveAspectRatio.alignY === \"Mid\") {\n                heightDiff /= 2;\n            }\n            if (preserveAspectRatio.alignX === \"Min\") {\n                widthDiff = 0;\n            }\n            if (preserveAspectRatio.alignY === \"Min\") {\n                heightDiff = 0;\n            }\n        }\n        if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {\n            return parsedDim;\n        }\n        if ((x || y) && element.parentNode.nodeName !== \"#document\") {\n            translateMatrix = \" translate(\" + parseUnit(x) + \" \" + parseUnit(y) + \") \";\n        }\n        matrix = translateMatrix + \" matrix(\" + scaleX + \" 0\" + \" 0 \" + scaleY + \" \" + (minX * scaleX + widthDiff) + \" \" + (minY * scaleY + heightDiff) + \") \";\n        // seems unused.\n        // parsedDim.viewboxTransform = fabric.parseTransformAttribute(matrix);\n        if (element.nodeName === \"svg\") {\n            el = element.ownerDocument.createElementNS(fabric.svgNS, \"g\");\n            // element.firstChild != null\n            while(element.firstChild){\n                el.appendChild(element.firstChild);\n            }\n            element.appendChild(el);\n        } else {\n            el = element;\n            el.removeAttribute(\"x\");\n            el.removeAttribute(\"y\");\n            matrix = el.getAttribute(\"transform\") + matrix;\n        }\n        el.setAttribute(\"transform\", matrix);\n        return parsedDim;\n    }\n    function hasAncestorWithNodeName(element, nodeName) {\n        while(element && (element = element.parentNode)){\n            if (element.nodeName && nodeName.test(element.nodeName.replace(\"svg:\", \"\")) && !element.getAttribute(\"instantiated_by_use\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback\n   * @static\n   * @function\n   * @memberOf fabric\n   * @param {SVGDocument} doc SVG document to parse\n   * @param {Function} callback Callback to call when parsing is finished;\n   * It's being passed an array of elements (parsed from a document).\n   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n   * @param {Object} [parsingOptions] options for parsing document\n   * @param {String} [parsingOptions.crossOrigin] crossOrigin settings\n   */ fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {\n        if (!doc) {\n            return;\n        }\n        parseUseDirectives(doc);\n        var svgUid = fabric.Object.__uid++, i, len, options = applyViewboxTransform(doc), descendants = fabric.util.toArray(doc.getElementsByTagName(\"*\"));\n        options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;\n        options.svgUid = svgUid;\n        if (descendants.length === 0 && fabric.isLikelyNode) {\n            // we're likely in node, where \"o3-xml\" library fails to gEBTN(\"*\")\n            // https://github.com/ajaxorg/node-o3-xml/issues/21\n            descendants = doc.selectNodes('//*[name(.)!=\"svg\"]');\n            var arr = [];\n            for(i = 0, len = descendants.length; i < len; i++){\n                arr[i] = descendants[i];\n            }\n            descendants = arr;\n        }\n        var elements = descendants.filter(function(el) {\n            applyViewboxTransform(el);\n            return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace(\"svg:\", \"\")) && !hasAncestorWithNodeName(el, fabric.svgInvalidAncestorsRegEx); // http://www.w3.org/TR/SVG/struct.html#DefsElement\n        });\n        if (!elements || elements && !elements.length) {\n            callback && callback([], {});\n            return;\n        }\n        var clipPaths = {};\n        descendants.filter(function(el) {\n            return el.nodeName.replace(\"svg:\", \"\") === \"clipPath\";\n        }).forEach(function(el) {\n            var id = el.getAttribute(\"id\");\n            clipPaths[id] = fabric.util.toArray(el.getElementsByTagName(\"*\")).filter(function(el) {\n                return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace(\"svg:\", \"\"));\n            });\n        });\n        fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);\n        fabric.cssRules[svgUid] = fabric.getCSSRules(doc);\n        fabric.clipPaths[svgUid] = clipPaths;\n        // Precedence of rules:   style > class > attribute\n        fabric.parseElements(elements, function(instances, elements) {\n            if (callback) {\n                callback(instances, options, elements, descendants);\n                delete fabric.gradientDefs[svgUid];\n                delete fabric.cssRules[svgUid];\n                delete fabric.clipPaths[svgUid];\n            }\n        }, clone(options), reviver, parsingOptions);\n    };\n    function recursivelyParseGradientsXlink(doc, gradient) {\n        var gradientsAttrs = [\n            \"gradientTransform\",\n            \"x1\",\n            \"x2\",\n            \"y1\",\n            \"y2\",\n            \"gradientUnits\",\n            \"cx\",\n            \"cy\",\n            \"r\",\n            \"fx\",\n            \"fy\"\n        ], xlinkAttr = \"xlink:href\", xLink = gradient.getAttribute(xlinkAttr).slice(1), referencedGradient = elementById(doc, xLink);\n        if (referencedGradient && referencedGradient.getAttribute(xlinkAttr)) {\n            recursivelyParseGradientsXlink(doc, referencedGradient);\n        }\n        gradientsAttrs.forEach(function(attr) {\n            if (referencedGradient && !gradient.hasAttribute(attr) && referencedGradient.hasAttribute(attr)) {\n                gradient.setAttribute(attr, referencedGradient.getAttribute(attr));\n            }\n        });\n        if (!gradient.children.length) {\n            var referenceClone = referencedGradient.cloneNode(true);\n            while(referenceClone.firstChild){\n                gradient.appendChild(referenceClone.firstChild);\n            }\n        }\n        gradient.removeAttribute(xlinkAttr);\n    }\n    var reFontDeclaration = new RegExp(\"(normal|italic)?\\\\s*(normal|small-caps)?\\\\s*\" + \"(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\\\s*(\" + fabric.reNum + \"(?:px|cm|mm|em|pt|pc|in)*)(?:\\\\/(normal|\" + fabric.reNum + \"))?\\\\s+(.*)\");\n    extend(fabric, {\n        /**\n     * Parses a short font declaration, building adding its properties to a style object\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {String} value font declaration\n     * @param {Object} oStyle definition\n     */ parseFontDeclaration: function(value, oStyle) {\n            var match = value.match(reFontDeclaration);\n            if (!match) {\n                return;\n            }\n            var fontStyle = match[1], // font variant is not used\n            // fontVariant = match[2],\n            fontWeight = match[3], fontSize = match[4], lineHeight = match[5], fontFamily = match[6];\n            if (fontStyle) {\n                oStyle.fontStyle = fontStyle;\n            }\n            if (fontWeight) {\n                oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);\n            }\n            if (fontSize) {\n                oStyle.fontSize = parseUnit(fontSize);\n            }\n            if (fontFamily) {\n                oStyle.fontFamily = fontFamily;\n            }\n            if (lineHeight) {\n                oStyle.lineHeight = lineHeight === \"normal\" ? 1 : lineHeight;\n            }\n        },\n        /**\n     * Parses an SVG document, returning all of the gradient declarations found in it\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {SVGDocument} doc SVG document to parse\n     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element\n     */ getGradientDefs: function(doc) {\n            var tagArray = [\n                \"linearGradient\",\n                \"radialGradient\",\n                \"svg:linearGradient\",\n                \"svg:radialGradient\"\n            ], elList = _getMultipleNodes(doc, tagArray), el, j = 0, gradientDefs = {};\n            j = elList.length;\n            while(j--){\n                el = elList[j];\n                if (el.getAttribute(\"xlink:href\")) {\n                    recursivelyParseGradientsXlink(doc, el);\n                }\n                gradientDefs[el.getAttribute(\"id\")] = el;\n            }\n            return gradientDefs;\n        },\n        /**\n     * Returns an object of attributes' name/value, given element and an array of attribute names;\n     * Parses parent \"g\" nodes recursively upwards.\n     * @static\n     * @memberOf fabric\n     * @param {DOMElement} element Element to parse\n     * @param {Array} attributes Array of attributes to parse\n     * @return {Object} object containing parsed attributes' names/values\n     */ parseAttributes: function(element, attributes, svgUid) {\n            if (!element) {\n                return;\n            }\n            var value, parentAttributes = {}, fontSize, parentFontSize;\n            if (typeof svgUid === \"undefined\") {\n                svgUid = element.getAttribute(\"svgUid\");\n            }\n            // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards\n            if (element.parentNode && fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)) {\n                parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);\n            }\n            var ownAttributes = attributes.reduce(function(memo, attr) {\n                value = element.getAttribute(attr);\n                if (value) {\n                    memo[attr] = value;\n                }\n                return memo;\n            }, {});\n            // add values parsed from style, which take precedence over attributes\n            // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)\n            var cssAttrs = extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element));\n            ownAttributes = extend(ownAttributes, cssAttrs);\n            if (cssAttrs[cPath]) {\n                element.setAttribute(cPath, cssAttrs[cPath]);\n            }\n            fontSize = parentFontSize = parentAttributes.fontSize || fabric.Text.DEFAULT_SVG_FONT_SIZE;\n            if (ownAttributes[fSize]) {\n                // looks like the minimum should be 9px when dealing with ems. this is what looks like in browsers.\n                ownAttributes[fSize] = fontSize = parseUnit(ownAttributes[fSize], parentFontSize);\n            }\n            var normalizedAttr, normalizedValue, normalizedStyle = {};\n            for(var attr in ownAttributes){\n                normalizedAttr = normalizeAttr(attr);\n                normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);\n                normalizedStyle[normalizedAttr] = normalizedValue;\n            }\n            if (normalizedStyle && normalizedStyle.font) {\n                fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);\n            }\n            var mergedAttrs = extend(parentAttributes, normalizedStyle);\n            return fabric.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);\n        },\n        /**\n     * Transforms an array of svg elements to corresponding fabric.* instances\n     * @static\n     * @memberOf fabric\n     * @param {Array} elements Array of elements to parse\n     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)\n     * @param {Object} [options] Options object\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     */ parseElements: function(elements, callback, options, reviver, parsingOptions) {\n            new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();\n        },\n        /**\n     * Parses \"style\" attribute, retuning an object with values\n     * @static\n     * @memberOf fabric\n     * @param {SVGElement} element Element to parse\n     * @return {Object} Objects with values parsed from style attribute of an element\n     */ parseStyleAttribute: function(element) {\n            var oStyle = {}, style = element.getAttribute(\"style\");\n            if (!style) {\n                return oStyle;\n            }\n            if (typeof style === \"string\") {\n                parseStyleString(style, oStyle);\n            } else {\n                parseStyleObject(style, oStyle);\n            }\n            return oStyle;\n        },\n        /**\n     * Parses \"points\" attribute, returning an array of values\n     * @static\n     * @memberOf fabric\n     * @param {String} points points attribute string\n     * @return {Array} array of points\n     */ parsePointsAttribute: function(points) {\n            // points attribute is required and must not be empty\n            if (!points) {\n                return null;\n            }\n            // replace commas with whitespace and remove bookending whitespace\n            points = points.replace(/,/g, \" \").trim();\n            points = points.split(/\\s+/);\n            var parsedPoints = [], i, len;\n            for(i = 0, len = points.length; i < len; i += 2){\n                parsedPoints.push({\n                    x: parseFloat(points[i]),\n                    y: parseFloat(points[i + 1])\n                });\n            }\n            // odd number of points is an error\n            // if (parsedPoints.length % 2 !== 0) {\n            //   return null;\n            // }\n            return parsedPoints;\n        },\n        /**\n     * Returns CSS rules for a given SVG document\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {SVGDocument} doc SVG document to parse\n     * @return {Object} CSS rules of this document\n     */ getCSSRules: function(doc) {\n            var styles = doc.getElementsByTagName(\"style\"), i, len, allRules = {}, rules;\n            // very crude parsing of style contents\n            for(i = 0, len = styles.length; i < len; i++){\n                var styleContents = styles[i].textContent;\n                // remove comments\n                styleContents = styleContents.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\");\n                if (styleContents.trim() === \"\") {\n                    continue;\n                }\n                // recovers all the rule in this form `body { style code... }`\n                // rules = styleContents.match(/[^{]*\\{[\\s\\S]*?\\}/g);\n                rules = styleContents.split(\"}\");\n                // remove empty rules.\n                rules = rules.filter(function(rule) {\n                    return rule.trim();\n                });\n                // at this point we have hopefully an array of rules `body { style code... `\n                // eslint-disable-next-line no-loop-func\n                rules.forEach(function(rule) {\n                    var match = rule.split(\"{\"), ruleObj = {}, declaration = match[1].trim(), propertyValuePairs = declaration.split(\";\").filter(function(pair) {\n                        return pair.trim();\n                    });\n                    for(i = 0, len = propertyValuePairs.length; i < len; i++){\n                        var pair = propertyValuePairs[i].split(\":\"), property = pair[0].trim(), value = pair[1].trim();\n                        ruleObj[property] = value;\n                    }\n                    rule = match[0].trim();\n                    rule.split(\",\").forEach(function(_rule) {\n                        _rule = _rule.replace(/^svg/i, \"\").trim();\n                        if (_rule === \"\") {\n                            return;\n                        }\n                        if (allRules[_rule]) {\n                            fabric.util.object.extend(allRules[_rule], ruleObj);\n                        } else {\n                            allRules[_rule] = fabric.util.object.clone(ruleObj);\n                        }\n                    });\n                });\n            }\n            return allRules;\n        },\n        /**\n     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.\n     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)\n     * @memberOf fabric\n     * @param {String} url\n     * @param {Function} callback\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     * @param {Object} [options] Object containing options for parsing\n     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources\n     */ loadSVGFromURL: function(url, callback, reviver, options) {\n            url = url.replace(/^\\n\\s*/, \"\").trim();\n            new fabric.util.request(url, {\n                method: \"get\",\n                onComplete: onComplete\n            });\n            function onComplete(r) {\n                var xml = r.responseXML;\n                if (!xml || !xml.documentElement) {\n                    callback && callback(null);\n                    return false;\n                }\n                fabric.parseSVGDocument(xml.documentElement, function(results, _options, elements, allElements) {\n                    callback && callback(results, _options, elements, allElements);\n                }, reviver, options);\n            }\n        },\n        /**\n     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects\n     * @memberOf fabric\n     * @param {String} string\n     * @param {Function} callback\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     * @param {Object} [options] Object containing options for parsing\n     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources\n     */ loadSVGFromString: function(string, callback, reviver, options) {\n            var parser = new fabric.window.DOMParser(), doc = parser.parseFromString(string.trim(), \"text/xml\");\n            fabric.parseSVGDocument(doc.documentElement, function(results, _options, elements, allElements) {\n                callback(results, _options, elements, allElements);\n            }, reviver, options);\n        }\n    });\n})( true ? exports : 0);\nfabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions, doc) {\n    this.elements = elements;\n    this.callback = callback;\n    this.options = options;\n    this.reviver = reviver;\n    this.svgUid = options && options.svgUid || 0;\n    this.parsingOptions = parsingOptions;\n    this.regexUrl = /^url\\(['\"]?#([^'\"]+)['\"]?\\)/g;\n    this.doc = doc;\n};\n(function(proto) {\n    proto.parse = function() {\n        this.instances = new Array(this.elements.length);\n        this.numElements = this.elements.length;\n        this.createObjects();\n    };\n    proto.createObjects = function() {\n        var _this = this;\n        this.elements.forEach(function(element, i) {\n            element.setAttribute(\"svgUid\", _this.svgUid);\n            _this.createObject(element, i);\n        });\n    };\n    proto.findTag = function(el) {\n        return fabric[fabric.util.string.capitalize(el.tagName.replace(\"svg:\", \"\"))];\n    };\n    proto.createObject = function(el, index) {\n        var klass = this.findTag(el);\n        if (klass && klass.fromElement) {\n            try {\n                klass.fromElement(el, this.createCallback(index, el), this.options);\n            } catch (err) {\n                fabric.log(err);\n            }\n        } else {\n            this.checkIfDone();\n        }\n    };\n    proto.createCallback = function(index, el) {\n        var _this = this;\n        return function(obj) {\n            var _options;\n            _this.resolveGradient(obj, el, \"fill\");\n            _this.resolveGradient(obj, el, \"stroke\");\n            if (obj instanceof fabric.Image && obj._originalElement) {\n                _options = obj.parsePreserveAspectRatioAttribute(el);\n            }\n            obj._removeTransformMatrix(_options);\n            _this.resolveClipPath(obj, el);\n            _this.reviver && _this.reviver(el, obj);\n            _this.instances[index] = obj;\n            _this.checkIfDone();\n        };\n    };\n    proto.extractPropertyDefinition = function(obj, property, storage) {\n        var value = obj[property], regex = this.regexUrl;\n        if (!regex.test(value)) {\n            return;\n        }\n        regex.lastIndex = 0;\n        var id = regex.exec(value)[1];\n        regex.lastIndex = 0;\n        return fabric[storage][this.svgUid][id];\n    };\n    proto.resolveGradient = function(obj, el, property) {\n        var gradientDef = this.extractPropertyDefinition(obj, property, \"gradientDefs\");\n        if (gradientDef) {\n            var opacityAttr = el.getAttribute(property + \"-opacity\");\n            var gradient = fabric.Gradient.fromElement(gradientDef, obj, opacityAttr, this.options);\n            obj.set(property, gradient);\n        }\n    };\n    proto.createClipPathCallback = function(obj, container) {\n        return function(_newObj) {\n            _newObj._removeTransformMatrix();\n            _newObj.fillRule = _newObj.clipRule;\n            container.push(_newObj);\n        };\n    };\n    proto.resolveClipPath = function(obj, usingElement) {\n        var clipPath = this.extractPropertyDefinition(obj, \"clipPath\", \"clipPaths\"), element, klass, objTransformInv, container, gTransform, options;\n        if (clipPath) {\n            container = [];\n            objTransformInv = fabric.util.invertTransform(obj.calcTransformMatrix());\n            // move the clipPath tag as sibling to the real element that is using it\n            var clipPathTag = clipPath[0].parentNode;\n            var clipPathOwner = usingElement;\n            while(clipPathOwner.parentNode && clipPathOwner.getAttribute(\"clip-path\") !== obj.clipPath){\n                clipPathOwner = clipPathOwner.parentNode;\n            }\n            clipPathOwner.parentNode.appendChild(clipPathTag);\n            for(var i = 0; i < clipPath.length; i++){\n                element = clipPath[i];\n                klass = this.findTag(element);\n                klass.fromElement(element, this.createClipPathCallback(obj, container), this.options);\n            }\n            if (container.length === 1) {\n                clipPath = container[0];\n            } else {\n                clipPath = new fabric.Group(container);\n            }\n            gTransform = fabric.util.multiplyTransformMatrices(objTransformInv, clipPath.calcTransformMatrix());\n            if (clipPath.clipPath) {\n                this.resolveClipPath(clipPath, clipPathOwner);\n            }\n            var options = fabric.util.qrDecompose(gTransform);\n            clipPath.flipX = false;\n            clipPath.flipY = false;\n            clipPath.set(\"scaleX\", options.scaleX);\n            clipPath.set(\"scaleY\", options.scaleY);\n            clipPath.angle = options.angle;\n            clipPath.skewX = options.skewX;\n            clipPath.skewY = 0;\n            clipPath.setPositionByOrigin({\n                x: options.translateX,\n                y: options.translateY\n            }, \"center\", \"center\");\n            obj.clipPath = clipPath;\n        } else {\n            // if clip-path does not resolve to any element, delete the property.\n            delete obj.clipPath;\n        }\n    };\n    proto.checkIfDone = function() {\n        if (--this.numElements === 0) {\n            this.instances = this.instances.filter(function(el) {\n                // eslint-disable-next-line no-eq-null, eqeqeq\n                return el != null;\n            });\n            this.callback(this.instances, this.elements);\n        }\n    };\n})(fabric.ElementsParser.prototype);\n(function(global) {\n    \"use strict\";\n    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */ var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Point) {\n        fabric.warn(\"fabric.Point is already defined\");\n        return;\n    }\n    fabric.Point = Point;\n    /**\n   * Point class\n   * @class fabric.Point\n   * @memberOf fabric\n   * @constructor\n   * @param {Number} x\n   * @param {Number} y\n   * @return {fabric.Point} thisArg\n   */ function Point(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    Point.prototype = /** @lends fabric.Point.prototype */ {\n        type: \"point\",\n        constructor: Point,\n        /**\n     * Adds another point to this one and returns another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} new Point instance with added values\n     */ add: function(that) {\n            return new Point(this.x + that.x, this.y + that.y);\n        },\n        /**\n     * Adds another point to this one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ addEquals: function(that) {\n            this.x += that.x;\n            this.y += that.y;\n            return this;\n        },\n        /**\n     * Adds value to this point and returns a new one\n     * @param {Number} scalar\n     * @return {fabric.Point} new Point with added value\n     */ scalarAdd: function(scalar) {\n            return new Point(this.x + scalar, this.y + scalar);\n        },\n        /**\n     * Adds value to this point\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ scalarAddEquals: function(scalar) {\n            this.x += scalar;\n            this.y += scalar;\n            return this;\n        },\n        /**\n     * Subtracts another point from this point and returns a new one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} new Point object with subtracted values\n     */ subtract: function(that) {\n            return new Point(this.x - that.x, this.y - that.y);\n        },\n        /**\n     * Subtracts another point from this point\n     * @param {fabric.Point} that\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ subtractEquals: function(that) {\n            this.x -= that.x;\n            this.y -= that.y;\n            return this;\n        },\n        /**\n     * Subtracts value from this point and returns a new one\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */ scalarSubtract: function(scalar) {\n            return new Point(this.x - scalar, this.y - scalar);\n        },\n        /**\n     * Subtracts value from this point\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ scalarSubtractEquals: function(scalar) {\n            this.x -= scalar;\n            this.y -= scalar;\n            return this;\n        },\n        /**\n     * Multiplies this point by a value and returns a new one\n     * TODO: rename in scalarMultiply in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */ multiply: function(scalar) {\n            return new Point(this.x * scalar, this.y * scalar);\n        },\n        /**\n     * Multiplies this point by a value\n     * TODO: rename in scalarMultiplyEquals in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ multiplyEquals: function(scalar) {\n            this.x *= scalar;\n            this.y *= scalar;\n            return this;\n        },\n        /**\n     * Divides this point by a value and returns a new one\n     * TODO: rename in scalarDivide in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */ divide: function(scalar) {\n            return new Point(this.x / scalar, this.y / scalar);\n        },\n        /**\n     * Divides this point by a value\n     * TODO: rename in scalarDivideEquals in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ divideEquals: function(scalar) {\n            this.x /= scalar;\n            this.y /= scalar;\n            return this;\n        },\n        /**\n     * Returns true if this point is equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ eq: function(that) {\n            return this.x === that.x && this.y === that.y;\n        },\n        /**\n     * Returns true if this point is less than another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ lt: function(that) {\n            return this.x < that.x && this.y < that.y;\n        },\n        /**\n     * Returns true if this point is less than or equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ lte: function(that) {\n            return this.x <= that.x && this.y <= that.y;\n        },\n        /**\n\n     * Returns true if this point is greater another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ gt: function(that) {\n            return this.x > that.x && this.y > that.y;\n        },\n        /**\n     * Returns true if this point is greater than or equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ gte: function(that) {\n            return this.x >= that.x && this.y >= that.y;\n        },\n        /**\n     * Returns new point which is the result of linear interpolation with this one and another one\n     * @param {fabric.Point} that\n     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5\n     * @return {fabric.Point}\n     */ lerp: function(that, t) {\n            if (typeof t === \"undefined\") {\n                t = 0.5;\n            }\n            t = Math.max(Math.min(1, t), 0);\n            return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);\n        },\n        /**\n     * Returns distance from this point and another one\n     * @param {fabric.Point} that\n     * @return {Number}\n     */ distanceFrom: function(that) {\n            var dx = this.x - that.x, dy = this.y - that.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        },\n        /**\n     * Returns the point between this point and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */ midPointFrom: function(that) {\n            return this.lerp(that);\n        },\n        /**\n     * Returns a new point which is the min of this and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */ min: function(that) {\n            return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));\n        },\n        /**\n     * Returns a new point which is the max of this and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */ max: function(that) {\n            return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));\n        },\n        /**\n     * Returns string representation of this point\n     * @return {String}\n     */ toString: function() {\n            return this.x + \",\" + this.y;\n        },\n        /**\n     * Sets x/y of this point\n     * @param {Number} x\n     * @param {Number} y\n     * @chainable\n     */ setXY: function(x, y) {\n            this.x = x;\n            this.y = y;\n            return this;\n        },\n        /**\n     * Sets x of this point\n     * @param {Number} x\n     * @chainable\n     */ setX: function(x) {\n            this.x = x;\n            return this;\n        },\n        /**\n     * Sets y of this point\n     * @param {Number} y\n     * @chainable\n     */ setY: function(y) {\n            this.y = y;\n            return this;\n        },\n        /**\n     * Sets x/y of this point from another point\n     * @param {fabric.Point} that\n     * @chainable\n     */ setFromPoint: function(that) {\n            this.x = that.x;\n            this.y = that.y;\n            return this;\n        },\n        /**\n     * Swaps x/y of this point and another point\n     * @param {fabric.Point} that\n     */ swap: function(that) {\n            var x = this.x, y = this.y;\n            this.x = that.x;\n            this.y = that.y;\n            that.x = x;\n            that.y = y;\n        },\n        /**\n     * return a cloned instance of the point\n     * @return {fabric.Point}\n     */ clone: function() {\n            return new Point(this.x, this.y);\n        }\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */ var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Intersection) {\n        fabric.warn(\"fabric.Intersection is already defined\");\n        return;\n    }\n    /**\n   * Intersection class\n   * @class fabric.Intersection\n   * @memberOf fabric\n   * @constructor\n   */ function Intersection(status) {\n        this.status = status;\n        this.points = [];\n    }\n    fabric.Intersection = Intersection;\n    fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {\n        constructor: Intersection,\n        /**\n     * Appends a point to intersection\n     * @param {fabric.Point} point\n     * @return {fabric.Intersection} thisArg\n     * @chainable\n     */ appendPoint: function(point) {\n            this.points.push(point);\n            return this;\n        },\n        /**\n     * Appends points to intersection\n     * @param {Array} points\n     * @return {fabric.Intersection} thisArg\n     * @chainable\n     */ appendPoints: function(points) {\n            this.points = this.points.concat(points);\n            return this;\n        }\n    };\n    /**\n   * Checks if one line intersects another\n   * TODO: rename in intersectSegmentSegment\n   * @static\n   * @param {fabric.Point} a1\n   * @param {fabric.Point} a2\n   * @param {fabric.Point} b1\n   * @param {fabric.Point} b2\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectLineLine = function(a1, a2, b1, b2) {\n        var result, uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x), ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x), uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n        if (uB !== 0) {\n            var ua = uaT / uB, ub = ubT / uB;\n            if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n                result = new Intersection(\"Intersection\");\n                result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));\n            } else {\n                result = new Intersection();\n            }\n        } else {\n            if (uaT === 0 || ubT === 0) {\n                result = new Intersection(\"Coincident\");\n            } else {\n                result = new Intersection(\"Parallel\");\n            }\n        }\n        return result;\n    };\n    /**\n   * Checks if line intersects polygon\n   * TODO: rename in intersectSegmentPolygon\n   * fix detection of coincident\n   * @static\n   * @param {fabric.Point} a1\n   * @param {fabric.Point} a2\n   * @param {Array} points\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {\n        var result = new Intersection(), length = points.length, b1, b2, inter, i;\n        for(i = 0; i < length; i++){\n            b1 = points[i];\n            b2 = points[(i + 1) % length];\n            inter = Intersection.intersectLineLine(a1, a2, b1, b2);\n            result.appendPoints(inter.points);\n        }\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        return result;\n    };\n    /**\n   * Checks if polygon intersects another polygon\n   * @static\n   * @param {Array} points1\n   * @param {Array} points2\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectPolygonPolygon = function(points1, points2) {\n        var result = new Intersection(), length = points1.length, i;\n        for(i = 0; i < length; i++){\n            var a1 = points1[i], a2 = points1[(i + 1) % length], inter = Intersection.intersectLinePolygon(a1, a2, points2);\n            result.appendPoints(inter.points);\n        }\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        return result;\n    };\n    /**\n   * Checks if polygon intersects rectangle\n   * @static\n   * @param {Array} points\n   * @param {fabric.Point} r1\n   * @param {fabric.Point} r2\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectPolygonRectangle = function(points, r1, r2) {\n        var min = r1.min(r2), max = r1.max(r2), topRight = new fabric.Point(max.x, min.y), bottomLeft = new fabric.Point(min.x, max.y), inter1 = Intersection.intersectLinePolygon(min, topRight, points), inter2 = Intersection.intersectLinePolygon(topRight, max, points), inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points), inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points), result = new Intersection();\n        result.appendPoints(inter1.points);\n        result.appendPoints(inter2.points);\n        result.appendPoints(inter3.points);\n        result.appendPoints(inter4.points);\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        return result;\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Color) {\n        fabric.warn(\"fabric.Color is already defined.\");\n        return;\n    }\n    /**\n   * Color class\n   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;\n   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.\n   *\n   * @class fabric.Color\n   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list\n   * @return {fabric.Color} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}\n   */ function Color(color) {\n        if (!color) {\n            this.setSource([\n                0,\n                0,\n                0,\n                1\n            ]);\n        } else {\n            this._tryParsingColor(color);\n        }\n    }\n    fabric.Color = Color;\n    fabric.Color.prototype = /** @lends fabric.Color.prototype */ {\n        /**\n     * @private\n     * @param {String|Array} color Color value to parse\n     */ _tryParsingColor: function(color) {\n            var source;\n            if (color in Color.colorNameMap) {\n                color = Color.colorNameMap[color];\n            }\n            if (color === \"transparent\") {\n                source = [\n                    255,\n                    255,\n                    255,\n                    0\n                ];\n            }\n            if (!source) {\n                source = Color.sourceFromHex(color);\n            }\n            if (!source) {\n                source = Color.sourceFromRgb(color);\n            }\n            if (!source) {\n                source = Color.sourceFromHsl(color);\n            }\n            if (!source) {\n                //if color is not recognize let's make black as canvas does\n                source = [\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n            }\n            if (source) {\n                this.setSource(source);\n            }\n        },\n        /**\n     * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\n     * @private\n     * @param {Number} r Red color value\n     * @param {Number} g Green color value\n     * @param {Number} b Blue color value\n     * @return {Array} Hsl color\n     */ _rgbToHsl: function(r, g, b) {\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            var h, s, l, max = fabric.util.array.max([\n                r,\n                g,\n                b\n            ]), min = fabric.util.array.min([\n                r,\n                g,\n                b\n            ]);\n            l = (max + min) / 2;\n            if (max === min) {\n                h = s = 0; // achromatic\n            } else {\n                var d = max - min;\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                switch(max){\n                    case r:\n                        h = (g - b) / d + (g < b ? 6 : 0);\n                        break;\n                    case g:\n                        h = (b - r) / d + 2;\n                        break;\n                    case b:\n                        h = (r - g) / d + 4;\n                        break;\n                }\n                h /= 6;\n            }\n            return [\n                Math.round(h * 360),\n                Math.round(s * 100),\n                Math.round(l * 100)\n            ];\n        },\n        /**\n     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])\n     * @return {Array}\n     */ getSource: function() {\n            return this._source;\n        },\n        /**\n     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])\n     * @param {Array} source\n     */ setSource: function(source) {\n            this._source = source;\n        },\n        /**\n     * Returns color representation in RGB format\n     * @return {String} ex: rgb(0-255,0-255,0-255)\n     */ toRgb: function() {\n            var source = this.getSource();\n            return \"rgb(\" + source[0] + \",\" + source[1] + \",\" + source[2] + \")\";\n        },\n        /**\n     * Returns color representation in RGBA format\n     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)\n     */ toRgba: function() {\n            var source = this.getSource();\n            return \"rgba(\" + source[0] + \",\" + source[1] + \",\" + source[2] + \",\" + source[3] + \")\";\n        },\n        /**\n     * Returns color representation in HSL format\n     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)\n     */ toHsl: function() {\n            var source = this.getSource(), hsl = this._rgbToHsl(source[0], source[1], source[2]);\n            return \"hsl(\" + hsl[0] + \",\" + hsl[1] + \"%,\" + hsl[2] + \"%)\";\n        },\n        /**\n     * Returns color representation in HSLA format\n     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)\n     */ toHsla: function() {\n            var source = this.getSource(), hsl = this._rgbToHsl(source[0], source[1], source[2]);\n            return \"hsla(\" + hsl[0] + \",\" + hsl[1] + \"%,\" + hsl[2] + \"%,\" + source[3] + \")\";\n        },\n        /**\n     * Returns color representation in HEX format\n     * @return {String} ex: FF5555\n     */ toHex: function() {\n            var source = this.getSource(), r, g, b;\n            r = source[0].toString(16);\n            r = r.length === 1 ? \"0\" + r : r;\n            g = source[1].toString(16);\n            g = g.length === 1 ? \"0\" + g : g;\n            b = source[2].toString(16);\n            b = b.length === 1 ? \"0\" + b : b;\n            return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();\n        },\n        /**\n     * Returns color representation in HEXA format\n     * @return {String} ex: FF5555CC\n     */ toHexa: function() {\n            var source = this.getSource(), a;\n            a = Math.round(source[3] * 255);\n            a = a.toString(16);\n            a = a.length === 1 ? \"0\" + a : a;\n            return this.toHex() + a.toUpperCase();\n        },\n        /**\n     * Gets value of alpha channel for this color\n     * @return {Number} 0-1\n     */ getAlpha: function() {\n            return this.getSource()[3];\n        },\n        /**\n     * Sets value of alpha channel for this color\n     * @param {Number} alpha Alpha value 0-1\n     * @return {fabric.Color} thisArg\n     */ setAlpha: function(alpha) {\n            var source = this.getSource();\n            source[3] = alpha;\n            this.setSource(source);\n            return this;\n        },\n        /**\n     * Transforms color to its grayscale representation\n     * @return {fabric.Color} thisArg\n     */ toGrayscale: function() {\n            var source = this.getSource(), average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10), currentAlpha = source[3];\n            this.setSource([\n                average,\n                average,\n                average,\n                currentAlpha\n            ]);\n            return this;\n        },\n        /**\n     * Transforms color to its black and white representation\n     * @param {Number} threshold\n     * @return {fabric.Color} thisArg\n     */ toBlackWhite: function(threshold) {\n            var source = this.getSource(), average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), currentAlpha = source[3];\n            threshold = threshold || 127;\n            average = Number(average) < Number(threshold) ? 0 : 255;\n            this.setSource([\n                average,\n                average,\n                average,\n                currentAlpha\n            ]);\n            return this;\n        },\n        /**\n     * Overlays color with another color\n     * @param {String|fabric.Color} otherColor\n     * @return {fabric.Color} thisArg\n     */ overlayWith: function(otherColor) {\n            if (!(otherColor instanceof Color)) {\n                otherColor = new Color(otherColor);\n            }\n            var result = [], alpha = this.getAlpha(), otherAlpha = 0.5, source = this.getSource(), otherSource = otherColor.getSource(), i;\n            for(i = 0; i < 3; i++){\n                result.push(Math.round(source[i] * (1 - otherAlpha) + otherSource[i] * otherAlpha));\n            }\n            result[3] = alpha;\n            this.setSource(result);\n            return this;\n        }\n    };\n    /**\n   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ // eslint-disable-next-line max-len\n    fabric.Color.reRGBa = /^rgba?\\(\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*(?:\\s*,\\s*((?:\\d*\\.?\\d+)?)\\s*)?\\)$/i;\n    /**\n   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ fabric.Color.reHSLa = /^hsla?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}\\%)\\s*,\\s*(\\d{1,3}\\%)\\s*(?:\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*)?\\)$/i;\n    /**\n   * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;\n    /**\n   * Map of the 148 color names with HEX code\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   * @see: https://www.w3.org/TR/css3-color/#svg-color\n   */ fabric.Color.colorNameMap = {\n        aliceblue: \"#F0F8FF\",\n        antiquewhite: \"#FAEBD7\",\n        aqua: \"#00FFFF\",\n        aquamarine: \"#7FFFD4\",\n        azure: \"#F0FFFF\",\n        beige: \"#F5F5DC\",\n        bisque: \"#FFE4C4\",\n        black: \"#000000\",\n        blanchedalmond: \"#FFEBCD\",\n        blue: \"#0000FF\",\n        blueviolet: \"#8A2BE2\",\n        brown: \"#A52A2A\",\n        burlywood: \"#DEB887\",\n        cadetblue: \"#5F9EA0\",\n        chartreuse: \"#7FFF00\",\n        chocolate: \"#D2691E\",\n        coral: \"#FF7F50\",\n        cornflowerblue: \"#6495ED\",\n        cornsilk: \"#FFF8DC\",\n        crimson: \"#DC143C\",\n        cyan: \"#00FFFF\",\n        darkblue: \"#00008B\",\n        darkcyan: \"#008B8B\",\n        darkgoldenrod: \"#B8860B\",\n        darkgray: \"#A9A9A9\",\n        darkgrey: \"#A9A9A9\",\n        darkgreen: \"#006400\",\n        darkkhaki: \"#BDB76B\",\n        darkmagenta: \"#8B008B\",\n        darkolivegreen: \"#556B2F\",\n        darkorange: \"#FF8C00\",\n        darkorchid: \"#9932CC\",\n        darkred: \"#8B0000\",\n        darksalmon: \"#E9967A\",\n        darkseagreen: \"#8FBC8F\",\n        darkslateblue: \"#483D8B\",\n        darkslategray: \"#2F4F4F\",\n        darkslategrey: \"#2F4F4F\",\n        darkturquoise: \"#00CED1\",\n        darkviolet: \"#9400D3\",\n        deeppink: \"#FF1493\",\n        deepskyblue: \"#00BFFF\",\n        dimgray: \"#696969\",\n        dimgrey: \"#696969\",\n        dodgerblue: \"#1E90FF\",\n        firebrick: \"#B22222\",\n        floralwhite: \"#FFFAF0\",\n        forestgreen: \"#228B22\",\n        fuchsia: \"#FF00FF\",\n        gainsboro: \"#DCDCDC\",\n        ghostwhite: \"#F8F8FF\",\n        gold: \"#FFD700\",\n        goldenrod: \"#DAA520\",\n        gray: \"#808080\",\n        grey: \"#808080\",\n        green: \"#008000\",\n        greenyellow: \"#ADFF2F\",\n        honeydew: \"#F0FFF0\",\n        hotpink: \"#FF69B4\",\n        indianred: \"#CD5C5C\",\n        indigo: \"#4B0082\",\n        ivory: \"#FFFFF0\",\n        khaki: \"#F0E68C\",\n        lavender: \"#E6E6FA\",\n        lavenderblush: \"#FFF0F5\",\n        lawngreen: \"#7CFC00\",\n        lemonchiffon: \"#FFFACD\",\n        lightblue: \"#ADD8E6\",\n        lightcoral: \"#F08080\",\n        lightcyan: \"#E0FFFF\",\n        lightgoldenrodyellow: \"#FAFAD2\",\n        lightgray: \"#D3D3D3\",\n        lightgrey: \"#D3D3D3\",\n        lightgreen: \"#90EE90\",\n        lightpink: \"#FFB6C1\",\n        lightsalmon: \"#FFA07A\",\n        lightseagreen: \"#20B2AA\",\n        lightskyblue: \"#87CEFA\",\n        lightslategray: \"#778899\",\n        lightslategrey: \"#778899\",\n        lightsteelblue: \"#B0C4DE\",\n        lightyellow: \"#FFFFE0\",\n        lime: \"#00FF00\",\n        limegreen: \"#32CD32\",\n        linen: \"#FAF0E6\",\n        magenta: \"#FF00FF\",\n        maroon: \"#800000\",\n        mediumaquamarine: \"#66CDAA\",\n        mediumblue: \"#0000CD\",\n        mediumorchid: \"#BA55D3\",\n        mediumpurple: \"#9370DB\",\n        mediumseagreen: \"#3CB371\",\n        mediumslateblue: \"#7B68EE\",\n        mediumspringgreen: \"#00FA9A\",\n        mediumturquoise: \"#48D1CC\",\n        mediumvioletred: \"#C71585\",\n        midnightblue: \"#191970\",\n        mintcream: \"#F5FFFA\",\n        mistyrose: \"#FFE4E1\",\n        moccasin: \"#FFE4B5\",\n        navajowhite: \"#FFDEAD\",\n        navy: \"#000080\",\n        oldlace: \"#FDF5E6\",\n        olive: \"#808000\",\n        olivedrab: \"#6B8E23\",\n        orange: \"#FFA500\",\n        orangered: \"#FF4500\",\n        orchid: \"#DA70D6\",\n        palegoldenrod: \"#EEE8AA\",\n        palegreen: \"#98FB98\",\n        paleturquoise: \"#AFEEEE\",\n        palevioletred: \"#DB7093\",\n        papayawhip: \"#FFEFD5\",\n        peachpuff: \"#FFDAB9\",\n        peru: \"#CD853F\",\n        pink: \"#FFC0CB\",\n        plum: \"#DDA0DD\",\n        powderblue: \"#B0E0E6\",\n        purple: \"#800080\",\n        rebeccapurple: \"#663399\",\n        red: \"#FF0000\",\n        rosybrown: \"#BC8F8F\",\n        royalblue: \"#4169E1\",\n        saddlebrown: \"#8B4513\",\n        salmon: \"#FA8072\",\n        sandybrown: \"#F4A460\",\n        seagreen: \"#2E8B57\",\n        seashell: \"#FFF5EE\",\n        sienna: \"#A0522D\",\n        silver: \"#C0C0C0\",\n        skyblue: \"#87CEEB\",\n        slateblue: \"#6A5ACD\",\n        slategray: \"#708090\",\n        slategrey: \"#708090\",\n        snow: \"#FFFAFA\",\n        springgreen: \"#00FF7F\",\n        steelblue: \"#4682B4\",\n        tan: \"#D2B48C\",\n        teal: \"#008080\",\n        thistle: \"#D8BFD8\",\n        tomato: \"#FF6347\",\n        turquoise: \"#40E0D0\",\n        violet: \"#EE82EE\",\n        wheat: \"#F5DEB3\",\n        white: \"#FFFFFF\",\n        whitesmoke: \"#F5F5F5\",\n        yellow: \"#FFFF00\",\n        yellowgreen: \"#9ACD32\"\n    };\n    /**\n   * @private\n   * @param {Number} p\n   * @param {Number} q\n   * @param {Number} t\n   * @return {Number}\n   */ function hue2rgb(p, q, t) {\n        if (t < 0) {\n            t += 1;\n        }\n        if (t > 1) {\n            t -= 1;\n        }\n        if (t < 1 / 6) {\n            return p + (q - p) * 6 * t;\n        }\n        if (t < 1 / 2) {\n            return q;\n        }\n        if (t < 2 / 3) {\n            return p + (q - p) * (2 / 3 - t) * 6;\n        }\n        return p;\n    }\n    /**\n   * Returns new color object, when given a color in RGB format\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)\n   * @return {fabric.Color}\n   */ fabric.Color.fromRgb = function(color) {\n        return Color.fromSource(Color.sourceFromRgb(color));\n    };\n    /**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)\n   * @return {Array} source\n   */ fabric.Color.sourceFromRgb = function(color) {\n        var match = color.match(Color.reRGBa);\n        if (match) {\n            var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1), g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1), b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);\n            return [\n                parseInt(r, 10),\n                parseInt(g, 10),\n                parseInt(b, 10),\n                match[4] ? parseFloat(match[4]) : 1\n            ];\n        }\n    };\n    /**\n   * Returns new color object, when given a color in RGBA format\n   * @static\n   * @function\n   * @memberOf fabric.Color\n   * @param {String} color\n   * @return {fabric.Color}\n   */ fabric.Color.fromRgba = Color.fromRgb;\n    /**\n   * Returns new color object, when given a color in HSL format\n   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)\n   * @memberOf fabric.Color\n   * @return {fabric.Color}\n   */ fabric.Color.fromHsl = function(color) {\n        return Color.fromSource(Color.sourceFromHsl(color));\n    };\n    /**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.\n   * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)\n   * @return {Array} source\n   * @see http://http://www.w3.org/TR/css3-color/#hsl-color\n   */ fabric.Color.sourceFromHsl = function(color) {\n        var match = color.match(Color.reHSLa);\n        if (!match) {\n            return;\n        }\n        var h = (parseFloat(match[1]) % 360 + 360) % 360 / 360, s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1), l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1), r, g, b;\n        if (s === 0) {\n            r = g = b = l;\n        } else {\n            var q = l <= 0.5 ? l * (s + 1) : l + s - l * s, p = l * 2 - q;\n            r = hue2rgb(p, q, h + 1 / 3);\n            g = hue2rgb(p, q, h);\n            b = hue2rgb(p, q, h - 1 / 3);\n        }\n        return [\n            Math.round(r * 255),\n            Math.round(g * 255),\n            Math.round(b * 255),\n            match[4] ? parseFloat(match[4]) : 1\n        ];\n    };\n    /**\n   * Returns new color object, when given a color in HSLA format\n   * @static\n   * @function\n   * @memberOf fabric.Color\n   * @param {String} color\n   * @return {fabric.Color}\n   */ fabric.Color.fromHsla = Color.fromHsl;\n    /**\n   * Returns new color object, when given a color in HEX format\n   * @static\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: FF5555\n   * @return {fabric.Color}\n   */ fabric.Color.fromHex = function(color) {\n        return Color.fromSource(Color.sourceFromHex(color));\n    };\n    /**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format\n   * @static\n   * @memberOf fabric.Color\n   * @param {String} color ex: FF5555 or FF5544CC (RGBa)\n   * @return {Array} source\n   */ fabric.Color.sourceFromHex = function(color) {\n        if (color.match(Color.reHex)) {\n            var value = color.slice(color.indexOf(\"#\") + 1), isShortNotation = value.length === 3 || value.length === 4, isRGBa = value.length === 8 || value.length === 4, r = isShortNotation ? value.charAt(0) + value.charAt(0) : value.substring(0, 2), g = isShortNotation ? value.charAt(1) + value.charAt(1) : value.substring(2, 4), b = isShortNotation ? value.charAt(2) + value.charAt(2) : value.substring(4, 6), a = isRGBa ? isShortNotation ? value.charAt(3) + value.charAt(3) : value.substring(6, 8) : \"FF\";\n            return [\n                parseInt(r, 16),\n                parseInt(g, 16),\n                parseInt(b, 16),\n                parseFloat((parseInt(a, 16) / 255).toFixed(2))\n            ];\n        }\n    };\n    /**\n   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])\n   * @static\n   * @memberOf fabric.Color\n   * @param {Array} source\n   * @return {fabric.Color}\n   */ fabric.Color.fromSource = function(source) {\n        var oColor = new Color();\n        oColor.setSource(source);\n        return oColor;\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), scaleMap = [\n        \"e\",\n        \"se\",\n        \"s\",\n        \"sw\",\n        \"w\",\n        \"nw\",\n        \"n\",\n        \"ne\",\n        \"e\"\n    ], skewMap = [\n        \"ns\",\n        \"nesw\",\n        \"ew\",\n        \"nwse\"\n    ], controls = {}, LEFT = \"left\", TOP = \"top\", RIGHT = \"right\", BOTTOM = \"bottom\", CENTER = \"center\", opposite = {\n        top: BOTTOM,\n        bottom: TOP,\n        left: RIGHT,\n        right: LEFT,\n        center: CENTER\n    }, radiansToDegrees = fabric.util.radiansToDegrees, sign = Math.sign || function(x) {\n        return (x > 0) - (x < 0) || +x;\n    };\n    /**\n   * Combine control position and object angle to find the control direction compared\n   * to the object center.\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   * @param {fabric.Control} control the control class\n   * @return {Number} 0 - 7 a quadrant number\n   */ function findCornerQuadrant(fabricObject, control) {\n        var cornerAngle = fabricObject.angle + radiansToDegrees(Math.atan2(control.y, control.x)) + 360;\n        return Math.round(cornerAngle % 360 / 45);\n    }\n    function fireEvent(eventName, options) {\n        var target = options.transform.target, canvas = target.canvas, canvasOptions = fabric.util.object.clone(options);\n        canvasOptions.target = target;\n        canvas && canvas.fire(\"object:\" + eventName, canvasOptions);\n        target.fire(eventName, options);\n    }\n    /**\n   * Inspect event and fabricObject properties to understand if the scaling action\n   * @param {Event} eventData from the user action\n   * @param {fabric.Object} fabricObject the fabric object about to scale\n   * @return {Boolean} true if scale is proportional\n   */ function scaleIsProportional(eventData, fabricObject) {\n        var canvas = fabricObject.canvas, uniScaleKey = canvas.uniScaleKey, uniformIsToggled = eventData[uniScaleKey];\n        return canvas.uniformScaling && !uniformIsToggled || !canvas.uniformScaling && uniformIsToggled;\n    }\n    /**\n   * Checks if transform is centered\n   * @param {Object} transform transform data\n   * @return {Boolean} true if transform is centered\n   */ function isTransformCentered(transform) {\n        return transform.originX === CENTER && transform.originY === CENTER;\n    }\n    /**\n   * Inspect fabricObject to understand if the current scaling action is allowed\n   * @param {fabric.Object} fabricObject the fabric object about to scale\n   * @param {String} by 'x' or 'y' or ''\n   * @param {Boolean} scaleProportionally true if we are trying to scale proportionally\n   * @return {Boolean} true if scaling is not allowed at current conditions\n   */ function scalingIsForbidden(fabricObject, by, scaleProportionally) {\n        var lockX = fabricObject.lockScalingX, lockY = fabricObject.lockScalingY;\n        if (lockX && lockY) {\n            return true;\n        }\n        if (!by && (lockX || lockY) && scaleProportionally) {\n            return true;\n        }\n        if (lockX && by === \"x\") {\n            return true;\n        }\n        if (lockY && by === \"y\") {\n            return true;\n        }\n        return false;\n    }\n    /**\n   * return the correct cursor style for the scale action\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function scaleCursorStyleHandler(eventData, control, fabricObject) {\n        var notAllowed = \"not-allowed\", scaleProportionally = scaleIsProportional(eventData, fabricObject), by = \"\";\n        if (control.x !== 0 && control.y === 0) {\n            by = \"x\";\n        } else if (control.x === 0 && control.y !== 0) {\n            by = \"y\";\n        }\n        if (scalingIsForbidden(fabricObject, by, scaleProportionally)) {\n            return notAllowed;\n        }\n        var n = findCornerQuadrant(fabricObject, control);\n        return scaleMap[n] + \"-resize\";\n    }\n    /**\n   * return the correct cursor style for the skew action\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function skewCursorStyleHandler(eventData, control, fabricObject) {\n        var notAllowed = \"not-allowed\";\n        if (control.x !== 0 && fabricObject.lockSkewingY) {\n            return notAllowed;\n        }\n        if (control.y !== 0 && fabricObject.lockSkewingX) {\n            return notAllowed;\n        }\n        var n = findCornerQuadrant(fabricObject, control) % 4;\n        return skewMap[n] + \"-resize\";\n    }\n    /**\n   * Combine skew and scale style handlers to cover fabric standard use case\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function scaleSkewCursorStyleHandler(eventData, control, fabricObject) {\n        if (eventData[fabricObject.canvas.altActionKey]) {\n            return controls.skewCursorStyleHandler(eventData, control, fabricObject);\n        }\n        return controls.scaleCursorStyleHandler(eventData, control, fabricObject);\n    }\n    /**\n   * Inspect event, control and fabricObject to return the correct action name\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} an action name\n   */ function scaleOrSkewActionName(eventData, control, fabricObject) {\n        var isAlternative = eventData[fabricObject.canvas.altActionKey];\n        if (control.x === 0) {\n            // then is scaleY or skewX\n            return isAlternative ? \"skewX\" : \"scaleY\";\n        }\n        if (control.y === 0) {\n            // then is scaleY or skewX\n            return isAlternative ? \"skewY\" : \"scaleX\";\n        }\n    }\n    /**\n   * Find the correct style for the control that is used for rotation.\n   * this function is very simple and it just take care of not-allowed or standard cursor\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function rotationStyleHandler(eventData, control, fabricObject) {\n        if (fabricObject.lockRotation) {\n            return \"not-allowed\";\n        }\n        return control.cursorStyle;\n    }\n    function commonEventInfo(eventData, transform, x, y) {\n        return {\n            e: eventData,\n            transform: transform,\n            pointer: {\n                x: x,\n                y: y\n            }\n        };\n    }\n    /**\n   * Wrap an action handler with saving/restoring object position on the transform.\n   * this is the code that permits to objects to keep their position while transforming.\n   * @param {Function} actionHandler the function to wrap\n   * @return {Function} a function with an action handler signature\n   */ function wrapWithFixedAnchor(actionHandler) {\n        return function(eventData, transform, x, y) {\n            var target = transform.target, centerPoint = target.getCenterPoint(), constraint = target.translateToOriginPoint(centerPoint, transform.originX, transform.originY), actionPerformed = actionHandler(eventData, transform, x, y);\n            target.setPositionByOrigin(constraint, transform.originX, transform.originY);\n            return actionPerformed;\n        };\n    }\n    /**\n   * Wrap an action handler with firing an event if the action is performed\n   * @param {Function} actionHandler the function to wrap\n   * @return {Function} a function with an action handler signature\n   */ function wrapWithFireEvent(eventName, actionHandler) {\n        return function(eventData, transform, x, y) {\n            var actionPerformed = actionHandler(eventData, transform, x, y);\n            if (actionPerformed) {\n                fireEvent(eventName, commonEventInfo(eventData, transform, x, y));\n            }\n            return actionPerformed;\n        };\n    }\n    /**\n   * Transforms a point described by x and y in a distance from the top left corner of the object\n   * bounding box.\n   * @param {Object} transform\n   * @param {String} originX\n   * @param {String} originY\n   * @param {number} x\n   * @param {number} y\n   * @return {Fabric.Point} the normalized point\n   */ function getLocalPoint(transform, originX, originY, x, y) {\n        var target = transform.target, control = target.controls[transform.corner], zoom = target.canvas.getZoom(), padding = target.padding / zoom, localPoint = target.toLocalPoint(new fabric.Point(x, y), originX, originY);\n        if (localPoint.x >= padding) {\n            localPoint.x -= padding;\n        }\n        if (localPoint.x <= -padding) {\n            localPoint.x += padding;\n        }\n        if (localPoint.y >= padding) {\n            localPoint.y -= padding;\n        }\n        if (localPoint.y <= padding) {\n            localPoint.y += padding;\n        }\n        localPoint.x -= control.offsetX;\n        localPoint.y -= control.offsetY;\n        return localPoint;\n    }\n    /**\n   * Detect if the fabric object is flipped on one side.\n   * @param {fabric.Object} target\n   * @return {Boolean} true if one flip, but not two.\n   */ function targetHasOneFlip(target) {\n        return target.flipX !== target.flipY;\n    }\n    /**\n   * Utility function to compensate the scale factor when skew is applied on both axes\n   * @private\n   */ function compensateScaleForSkew(target, oppositeSkew, scaleToCompensate, axis, reference) {\n        if (target[oppositeSkew] !== 0) {\n            var newDim = target._getTransformedDimensions()[axis];\n            var newValue = reference / newDim * target[scaleToCompensate];\n            target.set(scaleToCompensate, newValue);\n        }\n    }\n    /**\n   * Action handler for skewing on the X axis\n   * @private\n   */ function skewObjectX(eventData, transform, x, y) {\n        var target = transform.target, // find how big the object would be, if there was no skewX. takes in account scaling\n        dimNoSkew = target._getTransformedDimensions(0, target.skewY), localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y), // the mouse is in the center of the object, and we want it to stay there.\n        // so the object will grow twice as much as the mouse.\n        // this makes the skew growth to localPoint * 2 - dimNoSkew.\n        totalSkewSize = Math.abs(localPoint.x * 2) - dimNoSkew.x, currentSkew = target.skewX, newSkew;\n        if (totalSkewSize < 2) {\n            // let's make it easy to go back to position 0.\n            newSkew = 0;\n        } else {\n            newSkew = radiansToDegrees(Math.atan2(totalSkewSize / target.scaleX, dimNoSkew.y / target.scaleY));\n            // now we have to find the sign of the skew.\n            // it mostly depend on the origin of transformation.\n            if (transform.originX === LEFT && transform.originY === BOTTOM) {\n                newSkew = -newSkew;\n            }\n            if (transform.originX === RIGHT && transform.originY === TOP) {\n                newSkew = -newSkew;\n            }\n            if (targetHasOneFlip(target)) {\n                newSkew = -newSkew;\n            }\n        }\n        var hasSkewed = currentSkew !== newSkew;\n        if (hasSkewed) {\n            var dimBeforeSkewing = target._getTransformedDimensions().y;\n            target.set(\"skewX\", newSkew);\n            compensateScaleForSkew(target, \"skewY\", \"scaleY\", \"y\", dimBeforeSkewing);\n        }\n        return hasSkewed;\n    }\n    /**\n   * Action handler for skewing on the Y axis\n   * @private\n   */ function skewObjectY(eventData, transform, x, y) {\n        var target = transform.target, // find how big the object would be, if there was no skewX. takes in account scaling\n        dimNoSkew = target._getTransformedDimensions(target.skewX, 0), localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y), // the mouse is in the center of the object, and we want it to stay there.\n        // so the object will grow twice as much as the mouse.\n        // this makes the skew growth to localPoint * 2 - dimNoSkew.\n        totalSkewSize = Math.abs(localPoint.y * 2) - dimNoSkew.y, currentSkew = target.skewY, newSkew;\n        if (totalSkewSize < 2) {\n            // let's make it easy to go back to position 0.\n            newSkew = 0;\n        } else {\n            newSkew = radiansToDegrees(Math.atan2(totalSkewSize / target.scaleY, dimNoSkew.x / target.scaleX));\n            // now we have to find the sign of the skew.\n            // it mostly depend on the origin of transformation.\n            if (transform.originX === LEFT && transform.originY === BOTTOM) {\n                newSkew = -newSkew;\n            }\n            if (transform.originX === RIGHT && transform.originY === TOP) {\n                newSkew = -newSkew;\n            }\n            if (targetHasOneFlip(target)) {\n                newSkew = -newSkew;\n            }\n        }\n        var hasSkewed = currentSkew !== newSkew;\n        if (hasSkewed) {\n            var dimBeforeSkewing = target._getTransformedDimensions().x;\n            target.set(\"skewY\", newSkew);\n            compensateScaleForSkew(target, \"skewX\", \"scaleX\", \"x\", dimBeforeSkewing);\n        }\n        return hasSkewed;\n    }\n    /**\n   * Wrapped Action handler for skewing on the Y axis, takes care of the\n   * skew direction and determine the correct transform origin for the anchor point\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function skewHandlerX(eventData, transform, x, y) {\n        // step1 figure out and change transform origin.\n        // if skewX > 0 and originY bottom we anchor on right\n        // if skewX > 0 and originY top we anchor on left\n        // if skewX < 0 and originY bottom we anchor on left\n        // if skewX < 0 and originY top we anchor on right\n        // if skewX is 0, we look for mouse position to understand where are we going.\n        var target = transform.target, currentSkew = target.skewX, originX, originY = transform.originY;\n        if (target.lockSkewingX) {\n            return false;\n        }\n        if (currentSkew === 0) {\n            var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);\n            if (localPointFromCenter.x > 0) {\n                // we are pulling right, anchor left;\n                originX = LEFT;\n            } else {\n                // we are pulling right, anchor right\n                originX = RIGHT;\n            }\n        } else {\n            if (currentSkew > 0) {\n                originX = originY === TOP ? LEFT : RIGHT;\n            }\n            if (currentSkew < 0) {\n                originX = originY === TOP ? RIGHT : LEFT;\n            }\n            // is the object flipped on one side only? swap the origin.\n            if (targetHasOneFlip(target)) {\n                originX = originX === LEFT ? RIGHT : LEFT;\n            }\n        }\n        // once we have the origin, we find the anchor point\n        transform.originX = originX;\n        var finalHandler = wrapWithFireEvent(\"skewing\", wrapWithFixedAnchor(skewObjectX));\n        return finalHandler(eventData, transform, x, y);\n    }\n    /**\n   * Wrapped Action handler for skewing on the Y axis, takes care of the\n   * skew direction and determine the correct transform origin for the anchor point\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function skewHandlerY(eventData, transform, x, y) {\n        // step1 figure out and change transform origin.\n        // if skewY > 0 and originX left we anchor on top\n        // if skewY > 0 and originX right we anchor on bottom\n        // if skewY < 0 and originX left we anchor on bottom\n        // if skewY < 0 and originX right we anchor on top\n        // if skewY is 0, we look for mouse position to understand where are we going.\n        var target = transform.target, currentSkew = target.skewY, originY, originX = transform.originX;\n        if (target.lockSkewingY) {\n            return false;\n        }\n        if (currentSkew === 0) {\n            var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);\n            if (localPointFromCenter.y > 0) {\n                // we are pulling down, anchor up;\n                originY = TOP;\n            } else {\n                // we are pulling up, anchor down\n                originY = BOTTOM;\n            }\n        } else {\n            if (currentSkew > 0) {\n                originY = originX === LEFT ? TOP : BOTTOM;\n            }\n            if (currentSkew < 0) {\n                originY = originX === LEFT ? BOTTOM : TOP;\n            }\n            // is the object flipped on one side only? swap the origin.\n            if (targetHasOneFlip(target)) {\n                originY = originY === TOP ? BOTTOM : TOP;\n            }\n        }\n        // once we have the origin, we find the anchor point\n        transform.originY = originY;\n        var finalHandler = wrapWithFireEvent(\"skewing\", wrapWithFixedAnchor(skewObjectY));\n        return finalHandler(eventData, transform, x, y);\n    }\n    /**\n   * Action handler for rotation and snapping, without anchor point.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   * @private\n   */ function rotationWithSnapping(eventData, transform, x, y) {\n        var t = transform, target = t.target, pivotPoint = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY);\n        if (target.lockRotation) {\n            return false;\n        }\n        var lastAngle = Math.atan2(t.ey - pivotPoint.y, t.ex - pivotPoint.x), curAngle = Math.atan2(y - pivotPoint.y, x - pivotPoint.x), angle = radiansToDegrees(curAngle - lastAngle + t.theta), hasRotated = true;\n        if (target.snapAngle > 0) {\n            var snapAngle = target.snapAngle, snapThreshold = target.snapThreshold || snapAngle, rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle, leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;\n            if (Math.abs(angle - leftAngleLocked) < snapThreshold) {\n                angle = leftAngleLocked;\n            } else if (Math.abs(angle - rightAngleLocked) < snapThreshold) {\n                angle = rightAngleLocked;\n            }\n        }\n        // normalize angle to positive value\n        if (angle < 0) {\n            angle = 360 + angle;\n        }\n        angle %= 360;\n        hasRotated = target.angle !== angle;\n        target.angle = angle;\n        return hasRotated;\n    }\n    /**\n   * Basic scaling logic, reused with different constrain for scaling X,Y, freely or equally.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @param {Object} options additional information for scaling\n   * @param {String} options.by 'x', 'y', 'equally' or '' to indicate type of scaling\n   * @return {Boolean} true if some change happened\n   * @private\n   */ function scaleObject(eventData, transform, x, y, options) {\n        options = options || {};\n        var target = transform.target, lockScalingX = target.lockScalingX, lockScalingY = target.lockScalingY, by = options.by, newPoint, scaleX, scaleY, dim, scaleProportionally = scaleIsProportional(eventData, target), forbidScaling = scalingIsForbidden(target, by, scaleProportionally), signX, signY, gestureScale = transform.gestureScale;\n        if (forbidScaling) {\n            return false;\n        }\n        if (gestureScale) {\n            scaleX = transform.scaleX * gestureScale;\n            scaleY = transform.scaleY * gestureScale;\n        } else {\n            newPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y);\n            // use of sign: We use sign to detect change of direction of an action. sign usually change when\n            // we cross the origin point with the mouse. So a scale flip for example. There is an issue when scaling\n            // by center and scaling using one middle control ( default: mr, mt, ml, mb), the mouse movement can easily\n            // cross many time the origin point and flip the object. so we need a way to filter out the noise.\n            // This ternary here should be ok to filter out X scaling when we want Y only and vice versa.\n            signX = by !== \"y\" ? sign(newPoint.x) : 1;\n            signY = by !== \"x\" ? sign(newPoint.y) : 1;\n            if (!transform.signX) {\n                transform.signX = signX;\n            }\n            if (!transform.signY) {\n                transform.signY = signY;\n            }\n            if (target.lockScalingFlip && (transform.signX !== signX || transform.signY !== signY)) {\n                return false;\n            }\n            dim = target._getTransformedDimensions();\n            // missing detection of flip and logic to switch the origin\n            if (scaleProportionally && !by) {\n                // uniform scaling\n                var distance = Math.abs(newPoint.x) + Math.abs(newPoint.y), original = transform.original, originalDistance = Math.abs(dim.x * original.scaleX / target.scaleX) + Math.abs(dim.y * original.scaleY / target.scaleY), scale = distance / originalDistance;\n                scaleX = original.scaleX * scale;\n                scaleY = original.scaleY * scale;\n            } else {\n                scaleX = Math.abs(newPoint.x * target.scaleX / dim.x);\n                scaleY = Math.abs(newPoint.y * target.scaleY / dim.y);\n            }\n            // if we are scaling by center, we need to double the scale\n            if (isTransformCentered(transform)) {\n                scaleX *= 2;\n                scaleY *= 2;\n            }\n            if (transform.signX !== signX && by !== \"y\") {\n                transform.originX = opposite[transform.originX];\n                scaleX *= -1;\n                transform.signX = signX;\n            }\n            if (transform.signY !== signY && by !== \"x\") {\n                transform.originY = opposite[transform.originY];\n                scaleY *= -1;\n                transform.signY = signY;\n            }\n        }\n        // minScale is taken are in the setter.\n        var oldScaleX = target.scaleX, oldScaleY = target.scaleY;\n        if (!by) {\n            !lockScalingX && target.set(\"scaleX\", scaleX);\n            !lockScalingY && target.set(\"scaleY\", scaleY);\n        } else {\n            // forbidden cases already handled on top here.\n            by === \"x\" && target.set(\"scaleX\", scaleX);\n            by === \"y\" && target.set(\"scaleY\", scaleY);\n        }\n        return oldScaleX !== target.scaleX || oldScaleY !== target.scaleY;\n    }\n    /**\n   * Generic scaling logic, to scale from corners either equally or freely.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scaleObjectFromCorner(eventData, transform, x, y) {\n        return scaleObject(eventData, transform, x, y);\n    }\n    /**\n   * Scaling logic for the X axis.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scaleObjectX(eventData, transform, x, y) {\n        return scaleObject(eventData, transform, x, y, {\n            by: \"x\"\n        });\n    }\n    /**\n   * Scaling logic for the Y axis.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scaleObjectY(eventData, transform, x, y) {\n        return scaleObject(eventData, transform, x, y, {\n            by: \"y\"\n        });\n    }\n    /**\n   * Composed action handler to either scale Y or skew X\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scalingYOrSkewingX(eventData, transform, x, y) {\n        // ok some safety needed here.\n        if (eventData[transform.target.canvas.altActionKey]) {\n            return controls.skewHandlerX(eventData, transform, x, y);\n        }\n        return controls.scalingY(eventData, transform, x, y);\n    }\n    /**\n   * Composed action handler to either scale X or skew Y\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scalingXOrSkewingY(eventData, transform, x, y) {\n        // ok some safety needed here.\n        if (eventData[transform.target.canvas.altActionKey]) {\n            return controls.skewHandlerY(eventData, transform, x, y);\n        }\n        return controls.scalingX(eventData, transform, x, y);\n    }\n    /**\n   * Action handler to change textbox width\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function changeWidth(eventData, transform, x, y) {\n        var target = transform.target, localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y), strokePadding = target.strokeWidth / (target.strokeUniform ? target.scaleX : 1), multiplier = isTransformCentered(transform) ? 2 : 1, oldWidth = target.width, newWidth = Math.abs(localPoint.x * multiplier / target.scaleX) - strokePadding;\n        target.set(\"width\", Math.max(newWidth, 0));\n        return oldWidth !== newWidth;\n    }\n    /**\n   * Action handler\n   * @private\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if the translation occurred\n   */ function dragHandler(eventData, transform, x, y) {\n        var target = transform.target, newLeft = x - transform.offsetX, newTop = y - transform.offsetY, moveX = !target.get(\"lockMovementX\") && target.left !== newLeft, moveY = !target.get(\"lockMovementY\") && target.top !== newTop;\n        moveX && target.set(\"left\", newLeft);\n        moveY && target.set(\"top\", newTop);\n        if (moveX || moveY) {\n            fireEvent(\"moving\", commonEventInfo(eventData, transform, x, y));\n        }\n        return moveX || moveY;\n    }\n    controls.scaleCursorStyleHandler = scaleCursorStyleHandler;\n    controls.skewCursorStyleHandler = skewCursorStyleHandler;\n    controls.scaleSkewCursorStyleHandler = scaleSkewCursorStyleHandler;\n    controls.rotationWithSnapping = wrapWithFireEvent(\"rotating\", wrapWithFixedAnchor(rotationWithSnapping));\n    controls.scalingEqually = wrapWithFireEvent(\"scaling\", wrapWithFixedAnchor(scaleObjectFromCorner));\n    controls.scalingX = wrapWithFireEvent(\"scaling\", wrapWithFixedAnchor(scaleObjectX));\n    controls.scalingY = wrapWithFireEvent(\"scaling\", wrapWithFixedAnchor(scaleObjectY));\n    controls.scalingYOrSkewingX = scalingYOrSkewingX;\n    controls.scalingXOrSkewingY = scalingXOrSkewingY;\n    controls.changeWidth = wrapWithFireEvent(\"resizing\", wrapWithFixedAnchor(changeWidth));\n    controls.skewHandlerX = skewHandlerX;\n    controls.skewHandlerY = skewHandlerY;\n    controls.dragHandler = dragHandler;\n    controls.scaleOrSkewActionName = scaleOrSkewActionName;\n    controls.rotationStyleHandler = rotationStyleHandler;\n    controls.fireEvent = fireEvent;\n    controls.wrapWithFixedAnchor = wrapWithFixedAnchor;\n    controls.wrapWithFireEvent = wrapWithFireEvent;\n    controls.getLocalPoint = getLocalPoint;\n    fabric.controlsUtils = controls;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), degreesToRadians = fabric.util.degreesToRadians, controls = fabric.controlsUtils;\n    /**\n   * Render a round control, as per fabric features.\n   * This function is written to respect object properties like transparentCorners, cornerSize\n   * cornerColor, cornerStrokeColor\n   * plus the addition of offsetY and offsetX.\n   * @param {CanvasRenderingContext2D} ctx context to render on\n   * @param {Number} left x coordinate where the control center should be\n   * @param {Number} top y coordinate where the control center should be\n   * @param {Object} styleOverride override for fabric.Object controls style\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   */ function renderCircleControl(ctx, left, top, styleOverride, fabricObject) {\n        styleOverride = styleOverride || {};\n        var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize, ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize, transparentCorners = typeof styleOverride.transparentCorners !== \"undefined\" ? styleOverride.transparentCorners : fabricObject.transparentCorners, methodName = transparentCorners ? \"stroke\" : \"fill\", stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor), myLeft = left, myTop = top, size;\n        ctx.save();\n        ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;\n        ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;\n        // as soon as fabric react v5, remove ie11, use proper ellipse code.\n        if (xSize > ySize) {\n            size = xSize;\n            ctx.scale(1.0, ySize / xSize);\n            myTop = top * xSize / ySize;\n        } else if (ySize > xSize) {\n            size = ySize;\n            ctx.scale(xSize / ySize, 1.0);\n            myLeft = left * ySize / xSize;\n        } else {\n            size = xSize;\n        }\n        // this is still wrong\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.arc(myLeft, myTop, size / 2, 0, 2 * Math.PI, false);\n        ctx[methodName]();\n        if (stroke) {\n            ctx.stroke();\n        }\n        ctx.restore();\n    }\n    /**\n   * Render a square control, as per fabric features.\n   * This function is written to respect object properties like transparentCorners, cornerSize\n   * cornerColor, cornerStrokeColor\n   * plus the addition of offsetY and offsetX.\n   * @param {CanvasRenderingContext2D} ctx context to render on\n   * @param {Number} left x coordinate where the control center should be\n   * @param {Number} top y coordinate where the control center should be\n   * @param {Object} styleOverride override for fabric.Object controls style\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   */ function renderSquareControl(ctx, left, top, styleOverride, fabricObject) {\n        styleOverride = styleOverride || {};\n        var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize, ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize, transparentCorners = typeof styleOverride.transparentCorners !== \"undefined\" ? styleOverride.transparentCorners : fabricObject.transparentCorners, methodName = transparentCorners ? \"stroke\" : \"fill\", stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor), xSizeBy2 = xSize / 2, ySizeBy2 = ySize / 2;\n        ctx.save();\n        ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;\n        ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;\n        // this is still wrong\n        ctx.lineWidth = 1;\n        ctx.translate(left, top);\n        ctx.rotate(degreesToRadians(fabricObject.angle));\n        // this does not work, and fixed with ( && ) does not make sense.\n        // to have real transparent corners we need the controls on upperCanvas\n        // transparentCorners || ctx.clearRect(-xSizeBy2, -ySizeBy2, xSize, ySize);\n        ctx[methodName + \"Rect\"](-xSizeBy2, -ySizeBy2, xSize, ySize);\n        if (stroke) {\n            ctx.strokeRect(-xSizeBy2, -ySizeBy2, xSize, ySize);\n        }\n        ctx.restore();\n    }\n    controls.renderCircleControl = renderCircleControl;\n    controls.renderSquareControl = renderSquareControl;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    function Control(options) {\n        for(var i in options){\n            this[i] = options[i];\n        }\n    }\n    fabric.Control = Control;\n    fabric.Control.prototype = /** @lends fabric.Control.prototype */ {\n        /**\n     * keep track of control visibility.\n     * mainly for backward compatibility.\n     * if you do not want to see a control, you can remove it\n     * from the controlset.\n     * @type {Boolean}\n     * @default true\n     */ visible: true,\n        /**\n     * Name of the action that the control will likely execute.\n     * This is optional. FabricJS uses to identify what the user is doing for some\n     * extra optimizations. If you are writing a custom control and you want to know\n     * somewhere else in the code what is going on, you can use this string here.\n     * you can also provide a custom getActionName if your control run multiple actions\n     * depending on some external state.\n     * default to scale since is the most common, used on 4 corners by default\n     * @type {String}\n     * @default 'scale'\n     */ actionName: \"scale\",\n        /**\n     * Drawing angle of the control.\n     * NOT used for now, but name marked as needed for internal logic\n     * example: to reuse the same drawing function for different rotated controls\n     * @type {Number}\n     * @default 0\n     */ angle: 0,\n        /**\n     * Relative position of the control. X\n     * 0,0 is the center of the Object, while -0.5 (left) or 0.5 (right) are the extremities\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */ x: 0,\n        /**\n     * Relative position of the control. Y\n     * 0,0 is the center of the Object, while -0.5 (top) or 0.5 (bottom) are the extremities\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */ y: 0,\n        /**\n     * Horizontal offset of the control from the defined position. In pixels\n     * Positive offset moves the control to the right, negative to the left.\n     * It used when you want to have position of control that does not scale with\n     * the bounding box. Example: rotation control is placed at x:0, y: 0.5 on\n     * the boundindbox, with an offset of 30 pixels vertically. Those 30 pixels will\n     * stay 30 pixels no matter how the object is big. Another example is having 2\n     * controls in the corner, that stay in the same position when the object scale.\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */ offsetX: 0,\n        /**\n     * Vertical offset of the control from the defined position. In pixels\n     * Positive offset moves the control to the bottom, negative to the top.\n     * @type {Number}\n     * @default 0\n     */ offsetY: 0,\n        /**\n     * Sets the length of the control. If null, defaults to object's cornerSize.\n     * Expects both sizeX and sizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ sizeX: null,\n        /**\n     * Sets the height of the control. If null, defaults to object's cornerSize.\n     * Expects both sizeX and sizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ sizeY: null,\n        /**\n     * Sets the length of the touch area of the control. If null, defaults to object's touchCornerSize.\n     * Expects both touchSizeX and touchSizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ touchSizeX: null,\n        /**\n     * Sets the height of the touch area of the control. If null, defaults to object's touchCornerSize.\n     * Expects both touchSizeX and touchSizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ touchSizeY: null,\n        /**\n     * Css cursor style to display when the control is hovered.\n     * if the method `cursorStyleHandler` is provided, this property is ignored.\n     * @type {String}\n     * @default 'crosshair'\n     */ cursorStyle: \"crosshair\",\n        /**\n     * If controls has an offsetY or offsetX, draw a line that connects\n     * the control to the bounding box\n     * @type {Boolean}\n     * @default false\n     */ withConnection: false,\n        /**\n     * The control actionHandler, provide one to handle action ( control being moved )\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */ actionHandler: function() {},\n        /**\n     * The control handler for mouse down, provide one to handle mouse down on control\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */ mouseDownHandler: function() {},\n        /**\n     * The control mouseUpHandler, provide one to handle an effect on mouse up.\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */ mouseUpHandler: function() {},\n        /**\n     * Returns control actionHandler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */ getActionHandler: function() {\n            return this.actionHandler;\n        },\n        /**\n     * Returns control mouseDown handler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */ getMouseDownHandler: function() {\n            return this.mouseDownHandler;\n        },\n        /**\n     * Returns control mouseUp handler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */ getMouseUpHandler: function() {\n            return this.mouseUpHandler;\n        },\n        /**\n     * Returns control cursorStyle for css using cursorStyle. If you need a more elaborate\n     * function you can pass one in the constructor\n     * the cursorStyle property\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Control} control the current control ( likely this)\n     * @param {fabric.Object} object on which the control is displayed\n     * @return {String}\n     */ cursorStyleHandler: function(eventData, control /* fabricObject */ ) {\n            return control.cursorStyle;\n        },\n        /**\n     * Returns the action name. The basic implementation just return the actionName property.\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Control} control the current control ( likely this)\n     * @param {fabric.Object} object on which the control is displayed\n     * @return {String}\n     */ getActionName: function(eventData, control /* fabricObject */ ) {\n            return control.actionName;\n        },\n        /**\n     * Returns controls visibility\n     * @param {fabric.Object} object on which the control is displayed\n     * @param {String} controlKey key where the control is memorized on the\n     * @return {Boolean}\n     */ getVisibility: function(fabricObject, controlKey) {\n            var objectVisibility = fabricObject._controlsVisibility;\n            if (objectVisibility && typeof objectVisibility[controlKey] !== \"undefined\") {\n                return objectVisibility[controlKey];\n            }\n            return this.visible;\n        },\n        /**\n     * Sets controls visibility\n     * @param {Boolean} visibility for the object\n     * @return {Void}\n     */ setVisibility: function(visibility /* name, fabricObject */ ) {\n            this.visible = visibility;\n        },\n        positionHandler: function(dim, finalMatrix /*, fabricObject, currentControl */ ) {\n            var point = fabric.util.transformPoint({\n                x: this.x * dim.x + this.offsetX,\n                y: this.y * dim.y + this.offsetY\n            }, finalMatrix);\n            return point;\n        },\n        /**\n     * Returns the coords for this control based on object values.\n     * @param {Number} objectAngle angle from the fabric object holding the control\n     * @param {Number} objectCornerSize cornerSize from the fabric object holding the control (or touchCornerSize if\n     *   isTouch is true)\n     * @param {Number} centerX x coordinate where the control center should be\n     * @param {Number} centerY y coordinate where the control center should be\n     * @param {boolean} isTouch true if touch corner, false if normal corner\n     */ calcCornerCoords: function(objectAngle, objectCornerSize, centerX, centerY, isTouch) {\n            var cosHalfOffset, sinHalfOffset, cosHalfOffsetComp, sinHalfOffsetComp, xSize = isTouch ? this.touchSizeX : this.sizeX, ySize = isTouch ? this.touchSizeY : this.sizeY;\n            if (xSize && ySize && xSize !== ySize) {\n                // handle rectangular corners\n                var controlTriangleAngle = Math.atan2(ySize, xSize);\n                var cornerHypotenuse = Math.sqrt(xSize * xSize + ySize * ySize) / 2;\n                var newTheta = controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);\n                var newThetaComp = Math.PI / 2 - controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);\n                cosHalfOffset = cornerHypotenuse * fabric.util.cos(newTheta);\n                sinHalfOffset = cornerHypotenuse * fabric.util.sin(newTheta);\n                // use complementary angle for two corners\n                cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newThetaComp);\n                sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newThetaComp);\n            } else {\n                // handle square corners\n                // use default object corner size unless size is defined\n                var cornerSize = xSize && ySize ? xSize : objectCornerSize;\n                /* 0.7071067812 stands for sqrt(2)/2 */ cornerHypotenuse = cornerSize * 0.7071067812;\n                // complementary angles are equal since they're both 45 degrees\n                var newTheta = fabric.util.degreesToRadians(45 - objectAngle);\n                cosHalfOffset = cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newTheta);\n                sinHalfOffset = sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newTheta);\n            }\n            return {\n                tl: {\n                    x: centerX - sinHalfOffsetComp,\n                    y: centerY - cosHalfOffsetComp\n                },\n                tr: {\n                    x: centerX + cosHalfOffset,\n                    y: centerY - sinHalfOffset\n                },\n                bl: {\n                    x: centerX - cosHalfOffset,\n                    y: centerY + sinHalfOffset\n                },\n                br: {\n                    x: centerX + sinHalfOffsetComp,\n                    y: centerY + cosHalfOffsetComp\n                }\n            };\n        },\n        /**\n    * Render function for the control.\n    * When this function runs the context is unscaled. unrotate. Just retina scaled.\n    * all the functions will have to translate to the point left,top before starting Drawing\n    * if they want to draw a control where the position is detected.\n    * left and top are the result of the positionHandler function\n    * @param {RenderingContext2D} ctx the context where the control will be drawn\n    * @param {Number} left position of the canvas where we are about to render the control.\n    * @param {Number} top position of the canvas where we are about to render the control.\n    * @param {Object} styleOverride\n    * @param {fabric.Object} fabricObject the object where the control is about to be rendered\n    */ render: function(ctx, left, top, styleOverride, fabricObject) {\n            styleOverride = styleOverride || {};\n            switch(styleOverride.cornerStyle || fabricObject.cornerStyle){\n                case \"circle\":\n                    fabric.controlsUtils.renderCircleControl.call(this, ctx, left, top, styleOverride, fabricObject);\n                    break;\n                default:\n                    fabric.controlsUtils.renderSquareControl.call(this, ctx, left, top, styleOverride, fabricObject);\n            }\n        }\n    };\n})( true ? exports : 0);\n(function() {\n    /* _FROM_SVG_START_ */ function getColorStop(el, multiplier) {\n        var style = el.getAttribute(\"style\"), offset = el.getAttribute(\"offset\") || 0, color, colorAlpha, opacity, i;\n        // convert percents to absolute values\n        offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);\n        offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;\n        if (style) {\n            var keyValuePairs = style.split(/\\s*;\\s*/);\n            if (keyValuePairs[keyValuePairs.length - 1] === \"\") {\n                keyValuePairs.pop();\n            }\n            for(i = keyValuePairs.length; i--;){\n                var split = keyValuePairs[i].split(/\\s*:\\s*/), key = split[0].trim(), value = split[1].trim();\n                if (key === \"stop-color\") {\n                    color = value;\n                } else if (key === \"stop-opacity\") {\n                    opacity = value;\n                }\n            }\n        }\n        if (!color) {\n            color = el.getAttribute(\"stop-color\") || \"rgb(0,0,0)\";\n        }\n        if (!opacity) {\n            opacity = el.getAttribute(\"stop-opacity\");\n        }\n        color = new fabric.Color(color);\n        colorAlpha = color.getAlpha();\n        opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);\n        opacity *= colorAlpha * multiplier;\n        return {\n            offset: offset,\n            color: color.toRgb(),\n            opacity: opacity\n        };\n    }\n    function getLinearCoords(el) {\n        return {\n            x1: el.getAttribute(\"x1\") || 0,\n            y1: el.getAttribute(\"y1\") || 0,\n            x2: el.getAttribute(\"x2\") || \"100%\",\n            y2: el.getAttribute(\"y2\") || 0\n        };\n    }\n    function getRadialCoords(el) {\n        return {\n            x1: el.getAttribute(\"fx\") || el.getAttribute(\"cx\") || \"50%\",\n            y1: el.getAttribute(\"fy\") || el.getAttribute(\"cy\") || \"50%\",\n            r1: 0,\n            x2: el.getAttribute(\"cx\") || \"50%\",\n            y2: el.getAttribute(\"cy\") || \"50%\",\n            r2: el.getAttribute(\"r\") || \"50%\"\n        };\n    }\n    /* _FROM_SVG_END_ */ var clone = fabric.util.object.clone;\n    /**\n   * Gradient class\n   * @class fabric.Gradient\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}\n   * @see {@link fabric.Gradient#initialize} for constructor definition\n   */ fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {\n        /**\n     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups\n     * @type Number\n     * @default 0\n     */ offsetX: 0,\n        /**\n     * Vertical offset for aligning gradients coming from SVG when outside pathgroups\n     * @type Number\n     * @default 0\n     */ offsetY: 0,\n        /**\n     * A transform matrix to apply to the gradient before painting.\n     * Imported from svg gradients, is not applied with the current transform in the center.\n     * Before this transform is applied, the origin point is at the top left corner of the object\n     * plus the addition of offsetY and offsetX.\n     * @type Number[]\n     * @default null\n     */ gradientTransform: null,\n        /**\n     * coordinates units for coords.\n     * If `pixels`, the number of coords are in the same unit of width / height.\n     * If set as `percentage` the coords are still a number, but 1 means 100% of width\n     * for the X and 100% of the height for the y. It can be bigger than 1 and negative.\n     * allowed values pixels or percentage.\n     * @type String\n     * @default 'pixels'\n     */ gradientUnits: \"pixels\",\n        /**\n     * Gradient type linear or radial\n     * @type String\n     * @default 'pixels'\n     */ type: \"linear\",\n        /**\n     * Constructor\n     * @param {Object} options Options object with type, coords, gradientUnits and colorStops\n     * @param {Object} [options.type] gradient type linear or radial\n     * @param {Object} [options.gradientUnits] gradient units\n     * @param {Object} [options.offsetX] SVG import compatibility\n     * @param {Object} [options.offsetY] SVG import compatibility\n     * @param {Object[]} options.colorStops contains the colorstops.\n     * @param {Object} options.coords contains the coords of the gradient\n     * @param {Number} [options.coords.x1] X coordiante of the first point for linear or of the focal point for radial\n     * @param {Number} [options.coords.y1] Y coordiante of the first point for linear or of the focal point for radial\n     * @param {Number} [options.coords.x2] X coordiante of the second point for linear or of the center point for radial\n     * @param {Number} [options.coords.y2] Y coordiante of the second point for linear or of the center point for radial\n     * @param {Number} [options.coords.r1] only for radial gradient, radius of the inner circle\n     * @param {Number} [options.coords.r2] only for radial gradient, radius of the external circle\n     * @return {fabric.Gradient} thisArg\n     */ initialize: function(options) {\n            options || (options = {});\n            options.coords || (options.coords = {});\n            var coords, _this = this;\n            // sets everything, then coords and colorstops get sets again\n            Object.keys(options).forEach(function(option) {\n                _this[option] = options[option];\n            });\n            if (this.id) {\n                this.id += \"_\" + fabric.Object.__uid++;\n            } else {\n                this.id = fabric.Object.__uid++;\n            }\n            coords = {\n                x1: options.coords.x1 || 0,\n                y1: options.coords.y1 || 0,\n                x2: options.coords.x2 || 0,\n                y2: options.coords.y2 || 0\n            };\n            if (this.type === \"radial\") {\n                coords.r1 = options.coords.r1 || 0;\n                coords.r2 = options.coords.r2 || 0;\n            }\n            this.coords = coords;\n            this.colorStops = options.colorStops.slice();\n        },\n        /**\n     * Adds another colorStop\n     * @param {Object} colorStop Object with offset and color\n     * @return {fabric.Gradient} thisArg\n     */ addColorStop: function(colorStops) {\n            for(var position in colorStops){\n                var color = new fabric.Color(colorStops[position]);\n                this.colorStops.push({\n                    offset: parseFloat(position),\n                    color: color.toRgb(),\n                    opacity: color.getAlpha()\n                });\n            }\n            return this;\n        },\n        /**\n     * Returns object representation of a gradient\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object}\n     */ toObject: function(propertiesToInclude) {\n            var object = {\n                type: this.type,\n                coords: this.coords,\n                colorStops: this.colorStops,\n                offsetX: this.offsetX,\n                offsetY: this.offsetY,\n                gradientUnits: this.gradientUnits,\n                gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform\n            };\n            fabric.util.populateWithProperties(this, object, propertiesToInclude);\n            return object;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns SVG representation of an gradient\n     * @param {Object} object Object to create a gradient for\n     * @return {String} SVG representation of an gradient (linear/radial)\n     */ toSVG: function(object, options) {\n            var coords = clone(this.coords, true), i, len, options = options || {}, markup, commonAttributes, colorStops = clone(this.colorStops, true), needsSwap = coords.r1 > coords.r2, transform = this.gradientTransform ? this.gradientTransform.concat() : fabric.iMatrix.concat(), offsetX = -this.offsetX, offsetY = -this.offsetY, withViewport = !!options.additionalTransform, gradientUnits = this.gradientUnits === \"pixels\" ? \"userSpaceOnUse\" : \"objectBoundingBox\";\n            // colorStops must be sorted ascending\n            colorStops.sort(function(a, b) {\n                return a.offset - b.offset;\n            });\n            if (gradientUnits === \"objectBoundingBox\") {\n                offsetX /= object.width;\n                offsetY /= object.height;\n            } else {\n                offsetX += object.width / 2;\n                offsetY += object.height / 2;\n            }\n            if (object.type === \"path\" && this.gradientUnits !== \"percentage\") {\n                offsetX -= object.pathOffset.x;\n                offsetY -= object.pathOffset.y;\n            }\n            transform[4] -= offsetX;\n            transform[5] -= offsetY;\n            commonAttributes = 'id=\"SVGID_' + this.id + '\" gradientUnits=\"' + gradientUnits + '\"';\n            commonAttributes += ' gradientTransform=\"' + (withViewport ? options.additionalTransform + \" \" : \"\") + fabric.util.matrixToSVG(transform) + '\" ';\n            if (this.type === \"linear\") {\n                markup = [\n                    \"<linearGradient \",\n                    commonAttributes,\n                    ' x1=\"',\n                    coords.x1,\n                    '\" y1=\"',\n                    coords.y1,\n                    '\" x2=\"',\n                    coords.x2,\n                    '\" y2=\"',\n                    coords.y2,\n                    '\">\\n'\n                ];\n            } else if (this.type === \"radial\") {\n                // svg radial gradient has just 1 radius. the biggest.\n                markup = [\n                    \"<radialGradient \",\n                    commonAttributes,\n                    ' cx=\"',\n                    needsSwap ? coords.x1 : coords.x2,\n                    '\" cy=\"',\n                    needsSwap ? coords.y1 : coords.y2,\n                    '\" r=\"',\n                    needsSwap ? coords.r1 : coords.r2,\n                    '\" fx=\"',\n                    needsSwap ? coords.x2 : coords.x1,\n                    '\" fy=\"',\n                    needsSwap ? coords.y2 : coords.y1,\n                    '\">\\n'\n                ];\n            }\n            if (this.type === \"radial\") {\n                if (needsSwap) {\n                    // svg goes from internal to external radius. if radius are inverted, swap color stops.\n                    colorStops = colorStops.concat();\n                    colorStops.reverse();\n                    for(i = 0, len = colorStops.length; i < len; i++){\n                        colorStops[i].offset = 1 - colorStops[i].offset;\n                    }\n                }\n                var minRadius = Math.min(coords.r1, coords.r2);\n                if (minRadius > 0) {\n                    // i have to shift all colorStops and add new one in 0.\n                    var maxRadius = Math.max(coords.r1, coords.r2), percentageShift = minRadius / maxRadius;\n                    for(i = 0, len = colorStops.length; i < len; i++){\n                        colorStops[i].offset += percentageShift * (1 - colorStops[i].offset);\n                    }\n                }\n            }\n            for(i = 0, len = colorStops.length; i < len; i++){\n                var colorStop = colorStops[i];\n                markup.push(\"<stop \", 'offset=\"', colorStop.offset * 100 + \"%\", '\" style=\"stop-color:', colorStop.color, typeof colorStop.opacity !== \"undefined\" ? \";stop-opacity: \" + colorStop.opacity : \";\", '\"/>\\n');\n            }\n            markup.push(this.type === \"linear\" ? \"</linearGradient>\\n\" : \"</radialGradient>\\n\");\n            return markup.join(\"\");\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns an instance of CanvasGradient\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @return {CanvasGradient}\n     */ toLive: function(ctx) {\n            var gradient, coords = fabric.util.object.clone(this.coords), i, len;\n            if (!this.type) {\n                return;\n            }\n            if (this.type === \"linear\") {\n                gradient = ctx.createLinearGradient(coords.x1, coords.y1, coords.x2, coords.y2);\n            } else if (this.type === \"radial\") {\n                gradient = ctx.createRadialGradient(coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);\n            }\n            for(i = 0, len = this.colorStops.length; i < len; i++){\n                var color = this.colorStops[i].color, opacity = this.colorStops[i].opacity, offset = this.colorStops[i].offset;\n                if (typeof opacity !== \"undefined\") {\n                    color = new fabric.Color(color).setAlpha(opacity).toRgba();\n                }\n                gradient.addColorStop(offset, color);\n            }\n            return gradient;\n        }\n    });\n    fabric.util.object.extend(fabric.Gradient, {\n        /* _FROM_SVG_START_ */ /**\n     * Returns {@link fabric.Gradient} instance from an SVG element\n     * @static\n     * @memberOf fabric.Gradient\n     * @param {SVGGradientElement} el SVG gradient element\n     * @param {fabric.Object} instance\n     * @param {String} opacityAttr A fill-opacity or stroke-opacity attribute to multiply to each stop's opacity.\n     * @param {Object} svgOptions an object containing the size of the SVG in order to parse correctly gradients\n     * that uses gradientUnits as 'userSpaceOnUse' and percentages.\n     * @param {Object.number} viewBoxWidth width part of the viewBox attribute on svg\n     * @param {Object.number} viewBoxHeight height part of the viewBox attribute on svg\n     * @param {Object.number} width width part of the svg tag if viewBox is not specified\n     * @param {Object.number} height height part of the svg tag if viewBox is not specified\n     * @return {fabric.Gradient} Gradient instance\n     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement\n     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement\n     */ fromElement: function(el, instance, opacityAttr, svgOptions) {\n            /**\n       *  @example:\n       *\n       *  <linearGradient id=\"linearGrad1\">\n       *    <stop offset=\"0%\" stop-color=\"white\"/>\n       *    <stop offset=\"100%\" stop-color=\"black\"/>\n       *  </linearGradient>\n       *\n       *  OR\n       *\n       *  <linearGradient id=\"linearGrad2\">\n       *    <stop offset=\"0\" style=\"stop-color:rgb(255,255,255)\"/>\n       *    <stop offset=\"1\" style=\"stop-color:rgb(0,0,0)\"/>\n       *  </linearGradient>\n       *\n       *  OR\n       *\n       *  <radialGradient id=\"radialGrad1\">\n       *    <stop offset=\"0%\" stop-color=\"white\" stop-opacity=\"1\" />\n       *    <stop offset=\"50%\" stop-color=\"black\" stop-opacity=\"0.5\" />\n       *    <stop offset=\"100%\" stop-color=\"white\" stop-opacity=\"1\" />\n       *  </radialGradient>\n       *\n       *  OR\n       *\n       *  <radialGradient id=\"radialGrad2\">\n       *    <stop offset=\"0\" stop-color=\"rgb(255,255,255)\" />\n       *    <stop offset=\"0.5\" stop-color=\"rgb(0,0,0)\" />\n       *    <stop offset=\"1\" stop-color=\"rgb(255,255,255)\" />\n       *  </radialGradient>\n       *\n       */ var multiplier = parseFloat(opacityAttr) / (/%$/.test(opacityAttr) ? 100 : 1);\n            multiplier = multiplier < 0 ? 0 : multiplier > 1 ? 1 : multiplier;\n            if (isNaN(multiplier)) {\n                multiplier = 1;\n            }\n            var colorStopEls = el.getElementsByTagName(\"stop\"), type, gradientUnits = el.getAttribute(\"gradientUnits\") === \"userSpaceOnUse\" ? \"pixels\" : \"percentage\", gradientTransform = el.getAttribute(\"gradientTransform\") || \"\", colorStops = [], coords, i, offsetX = 0, offsetY = 0, transformMatrix;\n            if (el.nodeName === \"linearGradient\" || el.nodeName === \"LINEARGRADIENT\") {\n                type = \"linear\";\n                coords = getLinearCoords(el);\n            } else {\n                type = \"radial\";\n                coords = getRadialCoords(el);\n            }\n            for(i = colorStopEls.length; i--;){\n                colorStops.push(getColorStop(colorStopEls[i], multiplier));\n            }\n            transformMatrix = fabric.parseTransformAttribute(gradientTransform);\n            __convertPercentUnitsToValues(instance, coords, svgOptions, gradientUnits);\n            if (gradientUnits === \"pixels\") {\n                offsetX = -instance.left;\n                offsetY = -instance.top;\n            }\n            var gradient = new fabric.Gradient({\n                id: el.getAttribute(\"id\"),\n                type: type,\n                coords: coords,\n                colorStops: colorStops,\n                gradientUnits: gradientUnits,\n                gradientTransform: transformMatrix,\n                offsetX: offsetX,\n                offsetY: offsetY\n            });\n            return gradient;\n        }\n    });\n    /**\n   * @private\n   */ function __convertPercentUnitsToValues(instance, options, svgOptions, gradientUnits) {\n        var propValue, finalValue;\n        Object.keys(options).forEach(function(prop) {\n            propValue = options[prop];\n            if (propValue === \"Infinity\") {\n                finalValue = 1;\n            } else if (propValue === \"-Infinity\") {\n                finalValue = 0;\n            } else {\n                finalValue = parseFloat(options[prop], 10);\n                if (typeof propValue === \"string\" && /^(\\d+\\.\\d+)%|(\\d+)%$/.test(propValue)) {\n                    finalValue *= 0.01;\n                    if (gradientUnits === \"pixels\") {\n                        // then we need to fix those percentages here in svg parsing\n                        if (prop === \"x1\" || prop === \"x2\" || prop === \"r2\") {\n                            finalValue *= svgOptions.viewBoxWidth || svgOptions.width;\n                        }\n                        if (prop === \"y1\" || prop === \"y2\") {\n                            finalValue *= svgOptions.viewBoxHeight || svgOptions.height;\n                        }\n                    }\n                }\n            }\n            options[prop] = finalValue;\n        });\n    }\n})();\n(function() {\n    \"use strict\";\n    var toFixed = fabric.util.toFixed;\n    /**\n   * Pattern class\n   * @class fabric.Pattern\n   * @see {@link http://fabricjs.com/patterns|Pattern demo}\n   * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}\n   * @see {@link fabric.Pattern#initialize} for constructor definition\n   */ fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {\n        /**\n     * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)\n     * @type String\n     * @default\n     */ repeat: \"repeat\",\n        /**\n     * Pattern horizontal offset from object's left/top corner\n     * @type Number\n     * @default\n     */ offsetX: 0,\n        /**\n     * Pattern vertical offset from object's left/top corner\n     * @type Number\n     * @default\n     */ offsetY: 0,\n        /**\n     * crossOrigin value (one of \"\", \"anonymous\", \"use-credentials\")\n     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes\n     * @type String\n     * @default\n     */ crossOrigin: \"\",\n        /**\n     * transform matrix to change the pattern, imported from svgs.\n     * @type Array\n     * @default\n     */ patternTransform: null,\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @param {Function} [callback] function to invoke after callback init.\n     * @return {fabric.Pattern} thisArg\n     */ initialize: function(options, callback) {\n            options || (options = {});\n            this.id = fabric.Object.__uid++;\n            this.setOptions(options);\n            if (!options.source || options.source && typeof options.source !== \"string\") {\n                callback && callback(this);\n                return;\n            } else {\n                // img src string\n                var _this = this;\n                this.source = fabric.util.createImage();\n                fabric.util.loadImage(options.source, function(img, isError) {\n                    _this.source = img;\n                    callback && callback(_this, isError);\n                }, null, this.crossOrigin);\n            }\n        },\n        /**\n     * Returns object representation of a pattern\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of a pattern instance\n     */ toObject: function(propertiesToInclude) {\n            var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, source, object;\n            // <img> element\n            if (typeof this.source.src === \"string\") {\n                source = this.source.src;\n            } else if (typeof this.source === \"object\" && this.source.toDataURL) {\n                source = this.source.toDataURL();\n            }\n            object = {\n                type: \"pattern\",\n                source: source,\n                repeat: this.repeat,\n                crossOrigin: this.crossOrigin,\n                offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),\n                offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),\n                patternTransform: this.patternTransform ? this.patternTransform.concat() : null\n            };\n            fabric.util.populateWithProperties(this, object, propertiesToInclude);\n            return object;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns SVG representation of a pattern\n     * @param {fabric.Object} object\n     * @return {String} SVG representation of a pattern\n     */ toSVG: function(object) {\n            var patternSource = typeof this.source === \"function\" ? this.source() : this.source, patternWidth = patternSource.width / object.width, patternHeight = patternSource.height / object.height, patternOffsetX = this.offsetX / object.width, patternOffsetY = this.offsetY / object.height, patternImgSrc = \"\";\n            if (this.repeat === \"repeat-x\" || this.repeat === \"no-repeat\") {\n                patternHeight = 1;\n                if (patternOffsetY) {\n                    patternHeight += Math.abs(patternOffsetY);\n                }\n            }\n            if (this.repeat === \"repeat-y\" || this.repeat === \"no-repeat\") {\n                patternWidth = 1;\n                if (patternOffsetX) {\n                    patternWidth += Math.abs(patternOffsetX);\n                }\n            }\n            if (patternSource.src) {\n                patternImgSrc = patternSource.src;\n            } else if (patternSource.toDataURL) {\n                patternImgSrc = patternSource.toDataURL();\n            }\n            return '<pattern id=\"SVGID_' + this.id + '\" x=\"' + patternOffsetX + '\" y=\"' + patternOffsetY + '\" width=\"' + patternWidth + '\" height=\"' + patternHeight + '\">\\n' + '<image x=\"0\" y=\"0\"' + ' width=\"' + patternSource.width + '\" height=\"' + patternSource.height + '\" xlink:href=\"' + patternImgSrc + '\"></image>\\n' + \"</pattern>\\n\";\n        },\n        /* _TO_SVG_END_ */ setOptions: function(options) {\n            for(var prop in options){\n                this[prop] = options[prop];\n            }\n        },\n        /**\n     * Returns an instance of CanvasPattern\n     * @param {CanvasRenderingContext2D} ctx Context to create pattern\n     * @return {CanvasPattern}\n     */ toLive: function(ctx) {\n            var source = this.source;\n            // if the image failed to load, return, and allow rest to continue loading\n            if (!source) {\n                return \"\";\n            }\n            // if an image\n            if (typeof source.src !== \"undefined\") {\n                if (!source.complete) {\n                    return \"\";\n                }\n                if (source.naturalWidth === 0 || source.naturalHeight === 0) {\n                    return \"\";\n                }\n            }\n            return ctx.createPattern(source, this.repeat);\n        }\n    });\n})();\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), toFixed = fabric.util.toFixed;\n    if (fabric.Shadow) {\n        fabric.warn(\"fabric.Shadow is already defined.\");\n        return;\n    }\n    /**\n   * Shadow class\n   * @class fabric.Shadow\n   * @see {@link http://fabricjs.com/shadows|Shadow demo}\n   * @see {@link fabric.Shadow#initialize} for constructor definition\n   */ fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {\n        /**\n     * Shadow color\n     * @type String\n     * @default\n     */ color: \"rgb(0,0,0)\",\n        /**\n     * Shadow blur\n     * @type Number\n     */ blur: 0,\n        /**\n     * Shadow horizontal offset\n     * @type Number\n     * @default\n     */ offsetX: 0,\n        /**\n     * Shadow vertical offset\n     * @type Number\n     * @default\n     */ offsetY: 0,\n        /**\n     * Whether the shadow should affect stroke operations\n     * @type Boolean\n     * @default\n     */ affectStroke: false,\n        /**\n     * Indicates whether toObject should include default values\n     * @type Boolean\n     * @default\n     */ includeDefaultValues: true,\n        /**\n     * When `false`, the shadow will scale with the object.\n     * When `true`, the shadow's offsetX, offsetY, and blur will not be affected by the object's scale.\n     * default to false\n     * @type Boolean\n     * @default\n     */ nonScaling: false,\n        /**\n     * Constructor\n     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. \"rgba(0,0,0,0.2) 2px 2px 10px\")\n     * @return {fabric.Shadow} thisArg\n     */ initialize: function(options) {\n            if (typeof options === \"string\") {\n                options = this._parseShadow(options);\n            }\n            for(var prop in options){\n                this[prop] = options[prop];\n            }\n            this.id = fabric.Object.__uid++;\n        },\n        /**\n     * @private\n     * @param {String} shadow Shadow value to parse\n     * @return {Object} Shadow object with color, offsetX, offsetY and blur\n     */ _parseShadow: function(shadow) {\n            var shadowStr = shadow.trim(), offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [], color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, \"\") || \"rgb(0,0,0)\";\n            return {\n                color: color.trim(),\n                offsetX: parseFloat(offsetsAndBlur[1], 10) || 0,\n                offsetY: parseFloat(offsetsAndBlur[2], 10) || 0,\n                blur: parseFloat(offsetsAndBlur[3], 10) || 0\n            };\n        },\n        /**\n     * Returns a string representation of an instance\n     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow\n     * @return {String} Returns CSS3 text-shadow declaration\n     */ toString: function() {\n            return [\n                this.offsetX,\n                this.offsetY,\n                this.blur,\n                this.color\n            ].join(\"px \");\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns SVG representation of a shadow\n     * @param {fabric.Object} object\n     * @return {String} SVG representation of a shadow\n     */ toSVG: function(object) {\n            var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, offset = fabric.util.rotateVector({\n                x: this.offsetX,\n                y: this.offsetY\n            }, fabric.util.degreesToRadians(-object.angle)), BLUR_BOX = 20, color = new fabric.Color(this.color);\n            if (object.width && object.height) {\n                //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion\n                // we add some extra space to filter box to contain the blur ( 20 )\n                fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;\n                fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;\n            }\n            if (object.flipX) {\n                offset.x *= -1;\n            }\n            if (object.flipY) {\n                offset.y *= -1;\n            }\n            return '<filter id=\"SVGID_' + this.id + '\" y=\"-' + fBoxY + '%\" height=\"' + (100 + 2 * fBoxY) + '%\" ' + 'x=\"-' + fBoxX + '%\" width=\"' + (100 + 2 * fBoxX) + '%\" ' + \">\\n\" + '\t<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"' + toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '\"></feGaussianBlur>\\n' + '\t<feOffset dx=\"' + toFixed(offset.x, NUM_FRACTION_DIGITS) + '\" dy=\"' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '\" result=\"oBlur\" ></feOffset>\\n' + '\t<feFlood flood-color=\"' + color.toRgb() + '\" flood-opacity=\"' + color.getAlpha() + '\"/>\\n' + '\t<feComposite in2=\"oBlur\" operator=\"in\" />\\n' + \"\t<feMerge>\\n\" + \"\t\t<feMergeNode></feMergeNode>\\n\" + '\t\t<feMergeNode in=\"SourceGraphic\"></feMergeNode>\\n' + \"\t</feMerge>\\n\" + \"</filter>\\n\";\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns object representation of a shadow\n     * @return {Object} Object representation of a shadow instance\n     */ toObject: function() {\n            if (this.includeDefaultValues) {\n                return {\n                    color: this.color,\n                    blur: this.blur,\n                    offsetX: this.offsetX,\n                    offsetY: this.offsetY,\n                    affectStroke: this.affectStroke,\n                    nonScaling: this.nonScaling\n                };\n            }\n            var obj = {}, proto = fabric.Shadow.prototype;\n            [\n                \"color\",\n                \"blur\",\n                \"offsetX\",\n                \"offsetY\",\n                \"affectStroke\",\n                \"nonScaling\"\n            ].forEach(function(prop) {\n                if (this[prop] !== proto[prop]) {\n                    obj[prop] = this[prop];\n                }\n            }, this);\n            return obj;\n        }\n    });\n    /**\n   * Regex matching shadow offsetX, offsetY and blur (ex: \"2px 2px 10px rgba(0,0,0,0.2)\", \"rgb(0,255,0) 2px 2px\")\n   * @static\n   * @field\n   * @memberOf fabric.Shadow\n   */ // eslint-disable-next-line max-len\n    fabric.Shadow.reOffsetsAndBlur = /(?:\\s|^)(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?(\\d+(?:\\.\\d*)?(?:px)?)?(?:\\s?|$)(?:$|\\s)/;\n})( true ? exports : 0);\n(function() {\n    \"use strict\";\n    if (fabric.StaticCanvas) {\n        fabric.warn(\"fabric.StaticCanvas is already defined.\");\n        return;\n    }\n    // aliases for faster resolution\n    var extend = fabric.util.object.extend, getElementOffset = fabric.util.getElementOffset, removeFromArray = fabric.util.removeFromArray, toFixed = fabric.util.toFixed, transformPoint = fabric.util.transformPoint, invertTransform = fabric.util.invertTransform, getNodeCanvas = fabric.util.getNodeCanvas, createCanvasElement = fabric.util.createCanvasElement, CANVAS_INIT_ERROR = new Error(\"Could not initialize `canvas` element\");\n    /**\n   * Static canvas class\n   * @class fabric.StaticCanvas\n   * @mixes fabric.Collection\n   * @mixes fabric.Observable\n   * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}\n   * @see {@link fabric.StaticCanvas#initialize} for constructor definition\n   * @fires before:render\n   * @fires after:render\n   * @fires canvas:cleared\n   * @fires object:added\n   * @fires object:removed\n   */ fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.StaticCanvas.prototype */ {\n        /**\n     * Constructor\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(el, options) {\n            options || (options = {});\n            this.renderAndResetBound = this.renderAndReset.bind(this);\n            this.requestRenderAllBound = this.requestRenderAll.bind(this);\n            this._initStatic(el, options);\n        },\n        /**\n     * Background color of canvas instance.\n     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.\n     * @type {(String|fabric.Pattern)}\n     * @default\n     */ backgroundColor: \"\",\n        /**\n     * Background image of canvas instance.\n     * since 2.4.0 image caching is active, please when putting an image as background, add to the\n     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom\n     * vale. As an alternative you can disable image objectCaching\n     * @type fabric.Image\n     * @default\n     */ backgroundImage: null,\n        /**\n     * Overlay color of canvas instance.\n     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}\n     * @since 1.3.9\n     * @type {(String|fabric.Pattern)}\n     * @default\n     */ overlayColor: \"\",\n        /**\n     * Overlay image of canvas instance.\n     * since 2.4.0 image caching is active, please when putting an image as overlay, add to the\n     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom\n     * vale. As an alternative you can disable image objectCaching\n     * @type fabric.Image\n     * @default\n     */ overlayImage: null,\n        /**\n     * Indicates whether toObject/toDatalessObject should include default values\n     * if set to false, takes precedence over the object value.\n     * @type Boolean\n     * @default\n     */ includeDefaultValues: true,\n        /**\n     * Indicates whether objects' state should be saved\n     * @type Boolean\n     * @default\n     */ stateful: false,\n        /**\n     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},\n     * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.\n     * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once\n     * since the renders are quequed and executed one per frame.\n     * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )\n     * Left default to true to do not break documentation and old app, fiddles.\n     * @type Boolean\n     * @default\n     */ renderOnAddRemove: true,\n        /**\n     * Indicates whether object controls (borders/controls) are rendered above overlay image\n     * @type Boolean\n     * @default\n     */ controlsAboveOverlay: false,\n        /**\n     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas\n     * @type Boolean\n     * @default\n     */ allowTouchScrolling: false,\n        /**\n     * Indicates whether this canvas will use image smoothing, this is on by default in browsers\n     * @type Boolean\n     * @default\n     */ imageSmoothingEnabled: true,\n        /**\n     * The transformation (a Canvas 2D API transform matrix) which focuses the viewport\n     * @type Array\n     * @example <caption>Default transform</caption>\n     * canvas.viewportTransform = [1, 0, 0, 1, 0, 0];\n     * @example <caption>Scale by 70% and translate toward bottom-right by 50, without skewing</caption>\n     * canvas.viewportTransform = [0.7, 0, 0, 0.7, 50, 50];\n     * @default\n     */ viewportTransform: fabric.iMatrix.concat(),\n        /**\n     * if set to false background image is not affected by viewport transform\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */ backgroundVpt: true,\n        /**\n     * if set to false overlya image is not affected by viewport transform\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */ overlayVpt: true,\n        /**\n     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens\n     * @type Boolean\n     * @default\n     */ enableRetinaScaling: true,\n        /**\n     * Describe canvas element extension over design\n     * properties are tl,tr,bl,br.\n     * if canvas is not zoomed/panned those points are the four corner of canvas\n     * if canvas is viewportTransformed you those points indicate the extension\n     * of canvas element in plain untrasformed coordinates\n     * The coordinates get updated with @method calcViewportBoundaries.\n     * @memberOf fabric.StaticCanvas.prototype\n     */ vptCoords: {},\n        /**\n     * Based on vptCoords and object.aCoords, skip rendering of objects that\n     * are not included in current viewport.\n     * May greatly help in applications with crowded canvas and use of zoom/pan\n     * If One of the corner of the bounding box of the object is on the canvas\n     * the objects get rendered.\n     * @memberOf fabric.StaticCanvas.prototype\n     * @type Boolean\n     * @default\n     */ skipOffscreen: true,\n        /**\n     * a fabricObject that, without stroke define a clipping area with their shape. filled in black\n     * the clipPath object gets used when the canvas has rendered, and the context is placed in the\n     * top left corner of the canvas.\n     * clipPath will clip away controls, if you do not want this to happen use controlsAboveOverlay = true\n     * @type fabric.Object\n     */ clipPath: undefined,\n        /**\n     * @private\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     */ _initStatic: function(el, options) {\n            var cb = this.requestRenderAllBound;\n            this._objects = [];\n            this._createLowerCanvas(el);\n            this._initOptions(options);\n            // only initialize retina scaling once\n            if (!this.interactive) {\n                this._initRetinaScaling();\n            }\n            if (options.overlayImage) {\n                this.setOverlayImage(options.overlayImage, cb);\n            }\n            if (options.backgroundImage) {\n                this.setBackgroundImage(options.backgroundImage, cb);\n            }\n            if (options.backgroundColor) {\n                this.setBackgroundColor(options.backgroundColor, cb);\n            }\n            if (options.overlayColor) {\n                this.setOverlayColor(options.overlayColor, cb);\n            }\n            this.calcOffset();\n        },\n        /**\n     * @private\n     */ _isRetinaScaling: function() {\n            return fabric.devicePixelRatio > 1 && this.enableRetinaScaling;\n        },\n        /**\n     * @private\n     * @return {Number} retinaScaling if applied, otherwise 1;\n     */ getRetinaScaling: function() {\n            return this._isRetinaScaling() ? Math.max(1, fabric.devicePixelRatio) : 1;\n        },\n        /**\n     * @private\n     */ _initRetinaScaling: function() {\n            if (!this._isRetinaScaling()) {\n                return;\n            }\n            var scaleRatio = fabric.devicePixelRatio;\n            this.__initRetinaScaling(scaleRatio, this.lowerCanvasEl, this.contextContainer);\n            if (this.upperCanvasEl) {\n                this.__initRetinaScaling(scaleRatio, this.upperCanvasEl, this.contextTop);\n            }\n        },\n        __initRetinaScaling: function(scaleRatio, canvas, context) {\n            canvas.setAttribute(\"width\", this.width * scaleRatio);\n            canvas.setAttribute(\"height\", this.height * scaleRatio);\n            context.scale(scaleRatio, scaleRatio);\n        },\n        /**\n     * Calculates canvas element offset relative to the document\n     * This method is also attached as \"resize\" event handler of window\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ calcOffset: function() {\n            this._offset = getElementOffset(this.lowerCanvasEl);\n            return this;\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to\n     * @param {Function} callback callback to invoke when image is loaded and set as an overlay\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}\n     * @example <caption>Normal overlayImage with left/top = 0</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   // Needed to position overlayImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>overlayImage with different properties</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>\n     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img, isError) {\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\n     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));\n     * });\n     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   width: canvas.width,\n     *   height: canvas.height,\n     *   // Needed to position overlayImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>overlayImage loaded from cross-origin</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top',\n     *   crossOrigin: 'anonymous'\n     * });\n     */ setOverlayImage: function(image, callback, options) {\n            return this.__setBgOverlayImage(\"overlayImage\", image, callback, options);\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to\n     * @param {Function} callback Callback to invoke when image is loaded and set as background\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/djnr8o7a/28/|jsFiddle demo}\n     * @example <caption>Normal backgroundImage with left/top = 0</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   // Needed to position backgroundImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>backgroundImage with different properties</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>\n     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img, isError) {\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\n     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));\n     * });\n     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   width: canvas.width,\n     *   height: canvas.height,\n     *   // Needed to position backgroundImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>backgroundImage loaded from cross-origin</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top',\n     *   crossOrigin: 'anonymous'\n     * });\n     */ // TODO: fix stretched examples\n        setBackgroundImage: function(image, callback, options) {\n            return this.__setBgOverlayImage(\"backgroundImage\", image, callback, options);\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas\n     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to\n     * @param {Function} callback Callback to invoke when foreground color is set\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}\n     * @example <caption>Normal overlayColor - color value</caption>\n     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as overlayColor</caption>\n     * canvas.setOverlayColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\n     * }, canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>\n     * canvas.setOverlayColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\n     *   repeat: 'repeat',\n     *   offsetX: 200,\n     *   offsetY: 100\n     * }, canvas.renderAll.bind(canvas));\n     */ setOverlayColor: function(overlayColor, callback) {\n            return this.__setBgOverlayColor(\"overlayColor\", overlayColor, callback);\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas\n     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to\n     * @param {Function} callback Callback to invoke when background color is set\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}\n     * @example <caption>Normal backgroundColor - color value</caption>\n     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as backgroundColor</caption>\n     * canvas.setBackgroundColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\n     * }, canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>\n     * canvas.setBackgroundColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\n     *   repeat: 'repeat',\n     *   offsetX: 200,\n     *   offsetY: 100\n     * }, canvas.renderAll.bind(canvas));\n     */ setBackgroundColor: function(backgroundColor, callback) {\n            return this.__setBgOverlayColor(\"backgroundColor\", backgroundColor, callback);\n        },\n        /**\n     * @private\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}\n     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})\n     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to\n     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay. The first argument is the created image, the second argument is a flag indicating whether an error occurred or not.\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.\n     */ __setBgOverlayImage: function(property, image, callback, options) {\n            if (typeof image === \"string\") {\n                fabric.util.loadImage(image, function(img, isError) {\n                    if (img) {\n                        var instance = new fabric.Image(img, options);\n                        this[property] = instance;\n                        instance.canvas = this;\n                    }\n                    callback && callback(img, isError);\n                }, this, options && options.crossOrigin);\n            } else {\n                options && image.setOptions(options);\n                this[property] = image;\n                image && (image.canvas = this);\n                callback && callback(image, false);\n            }\n            return this;\n        },\n        /**\n     * @private\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}\n     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})\n     * @param {(Object|String|null)} color Object with pattern information, color value or null\n     * @param {Function} [callback] Callback is invoked when color is set\n     */ __setBgOverlayColor: function(property, color, callback) {\n            this[property] = color;\n            this._initGradient(color, property);\n            this._initPattern(color, property, callback);\n            return this;\n        },\n        /**\n     * @private\n     */ _createCanvasElement: function() {\n            var element = createCanvasElement();\n            if (!element) {\n                throw CANVAS_INIT_ERROR;\n            }\n            if (!element.style) {\n                element.style = {};\n            }\n            if (typeof element.getContext === \"undefined\") {\n                throw CANVAS_INIT_ERROR;\n            }\n            return element;\n        },\n        /**\n     * @private\n     * @param {Object} [options] Options object\n     */ _initOptions: function(options) {\n            var lowerCanvasEl = this.lowerCanvasEl;\n            this._setOptions(options);\n            this.width = this.width || parseInt(lowerCanvasEl.width, 10) || 0;\n            this.height = this.height || parseInt(lowerCanvasEl.height, 10) || 0;\n            if (!this.lowerCanvasEl.style) {\n                return;\n            }\n            lowerCanvasEl.width = this.width;\n            lowerCanvasEl.height = this.height;\n            lowerCanvasEl.style.width = this.width + \"px\";\n            lowerCanvasEl.style.height = this.height + \"px\";\n            this.viewportTransform = this.viewportTransform.slice();\n        },\n        /**\n     * Creates a bottom canvas\n     * @private\n     * @param {HTMLElement} [canvasEl]\n     */ _createLowerCanvas: function(canvasEl) {\n            // canvasEl === 'HTMLCanvasElement' does not work on jsdom/node\n            if (canvasEl && canvasEl.getContext) {\n                this.lowerCanvasEl = canvasEl;\n            } else {\n                this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();\n            }\n            fabric.util.addClass(this.lowerCanvasEl, \"lower-canvas\");\n            this._originalCanvasStyle = this.lowerCanvasEl.style;\n            if (this.interactive) {\n                this._applyCanvasStyle(this.lowerCanvasEl);\n            }\n            this.contextContainer = this.lowerCanvasEl.getContext(\"2d\");\n        },\n        /**\n     * Returns canvas width (in px)\n     * @return {Number}\n     */ getWidth: function() {\n            return this.width;\n        },\n        /**\n     * Returns canvas height (in px)\n     * @return {Number}\n     */ getHeight: function() {\n            return this.height;\n        },\n        /**\n     * Sets width of this canvas instance\n     * @param {Number|String} value                         Value to set width to\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setWidth: function(value, options) {\n            return this.setDimensions({\n                width: value\n            }, options);\n        },\n        /**\n     * Sets height of this canvas instance\n     * @param {Number|String} value                         Value to set height to\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setHeight: function(value, options) {\n            return this.setDimensions({\n                height: value\n            }, options);\n        },\n        /**\n     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)\n     * @param {Object}        dimensions                    Object with width/height properties\n     * @param {Number|String} [dimensions.width]            Width of canvas element\n     * @param {Number|String} [dimensions.height]           Height of canvas element\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ setDimensions: function(dimensions, options) {\n            var cssValue;\n            options = options || {};\n            for(var prop in dimensions){\n                cssValue = dimensions[prop];\n                if (!options.cssOnly) {\n                    this._setBackstoreDimension(prop, dimensions[prop]);\n                    cssValue += \"px\";\n                    this.hasLostContext = true;\n                }\n                if (!options.backstoreOnly) {\n                    this._setCssDimension(prop, cssValue);\n                }\n            }\n            if (this._isCurrentlyDrawing) {\n                this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);\n            }\n            this._initRetinaScaling();\n            this.calcOffset();\n            if (!options.cssOnly) {\n                this.requestRenderAll();\n            }\n            return this;\n        },\n        /**\n     * Helper for setting width/height\n     * @private\n     * @param {String} prop property (width|height)\n     * @param {Number} value value to set property to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ _setBackstoreDimension: function(prop, value) {\n            this.lowerCanvasEl[prop] = value;\n            if (this.upperCanvasEl) {\n                this.upperCanvasEl[prop] = value;\n            }\n            if (this.cacheCanvasEl) {\n                this.cacheCanvasEl[prop] = value;\n            }\n            this[prop] = value;\n            return this;\n        },\n        /**\n     * Helper for setting css width/height\n     * @private\n     * @param {String} prop property (width|height)\n     * @param {String} value value to set property to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ _setCssDimension: function(prop, value) {\n            this.lowerCanvasEl.style[prop] = value;\n            if (this.upperCanvasEl) {\n                this.upperCanvasEl.style[prop] = value;\n            }\n            if (this.wrapperEl) {\n                this.wrapperEl.style[prop] = value;\n            }\n            return this;\n        },\n        /**\n     * Returns canvas zoom level\n     * @return {Number}\n     */ getZoom: function() {\n            return this.viewportTransform[0];\n        },\n        /**\n     * Sets viewport transformation of this canvas instance\n     * @param {Array} vpt a Canvas 2D API transform matrix\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setViewportTransform: function(vpt) {\n            var activeObject = this._activeObject, backgroundObject = this.backgroundImage, overlayObject = this.overlayImage, object, i, len;\n            this.viewportTransform = vpt;\n            for(i = 0, len = this._objects.length; i < len; i++){\n                object = this._objects[i];\n                object.group || object.setCoords(true);\n            }\n            if (activeObject) {\n                activeObject.setCoords();\n            }\n            if (backgroundObject) {\n                backgroundObject.setCoords(true);\n            }\n            if (overlayObject) {\n                overlayObject.setCoords(true);\n            }\n            this.calcViewportBoundaries();\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Sets zoom level of this canvas instance, the zoom centered around point\n     * meaning that following zoom to point with the same point will have the visual\n     * effect of the zoom originating from that point. The point won't move.\n     * It has nothing to do with canvas center or visual center of the viewport.\n     * @param {fabric.Point} point to zoom with respect to\n     * @param {Number} value to set zoom to, less than 1 zooms out\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ zoomToPoint: function(point, value) {\n            // TODO: just change the scale, preserve other transformations\n            var before = point, vpt = this.viewportTransform.slice(0);\n            point = transformPoint(point, invertTransform(this.viewportTransform));\n            vpt[0] = value;\n            vpt[3] = value;\n            var after = transformPoint(point, vpt);\n            vpt[4] += before.x - after.x;\n            vpt[5] += before.y - after.y;\n            return this.setViewportTransform(vpt);\n        },\n        /**\n     * Sets zoom level of this canvas instance\n     * @param {Number} value to set zoom to, less than 1 zooms out\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setZoom: function(value) {\n            this.zoomToPoint(new fabric.Point(0, 0), value);\n            return this;\n        },\n        /**\n     * Pan viewport so as to place point at top left corner of canvas\n     * @param {fabric.Point} point to move to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ absolutePan: function(point) {\n            var vpt = this.viewportTransform.slice(0);\n            vpt[4] = -point.x;\n            vpt[5] = -point.y;\n            return this.setViewportTransform(vpt);\n        },\n        /**\n     * Pans viewpoint relatively\n     * @param {fabric.Point} point (position vector) to move by\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ relativePan: function(point) {\n            return this.absolutePan(new fabric.Point(-point.x - this.viewportTransform[4], -point.y - this.viewportTransform[5]));\n        },\n        /**\n     * Returns &lt;canvas> element corresponding to this instance\n     * @return {HTMLCanvasElement}\n     */ getElement: function() {\n            return this.lowerCanvasEl;\n        },\n        /**\n     * @private\n     * @param {fabric.Object} obj Object that was added\n     */ _onObjectAdded: function(obj) {\n            this.stateful && obj.setupState();\n            obj._set(\"canvas\", this);\n            obj.setCoords();\n            this.fire(\"object:added\", {\n                target: obj\n            });\n            obj.fire(\"added\");\n        },\n        /**\n     * @private\n     * @param {fabric.Object} obj Object that was removed\n     */ _onObjectRemoved: function(obj) {\n            this.fire(\"object:removed\", {\n                target: obj\n            });\n            obj.fire(\"removed\");\n            delete obj.canvas;\n        },\n        /**\n     * Clears specified context of canvas element\n     * @param {CanvasRenderingContext2D} ctx Context to clear\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ clearContext: function(ctx) {\n            ctx.clearRect(0, 0, this.width, this.height);\n            return this;\n        },\n        /**\n     * Returns context of canvas where objects are drawn\n     * @return {CanvasRenderingContext2D}\n     */ getContext: function() {\n            return this.contextContainer;\n        },\n        /**\n     * Clears all contexts (background, main, top) of an instance\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ clear: function() {\n            this.remove.apply(this, this.getObjects());\n            this.backgroundImage = null;\n            this.overlayImage = null;\n            this.backgroundColor = \"\";\n            this.overlayColor = \"\";\n            if (this._hasITextHandlers) {\n                this.off(\"mouse:up\", this._mouseUpITextHandler);\n                this._iTextInstances = null;\n                this._hasITextHandlers = false;\n            }\n            this.clearContext(this.contextContainer);\n            this.fire(\"canvas:cleared\");\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Renders the canvas\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderAll: function() {\n            var canvasToDrawOn = this.contextContainer;\n            this.renderCanvas(canvasToDrawOn, this._objects);\n            return this;\n        },\n        /**\n     * Function created to be instance bound at initialization\n     * used in requestAnimationFrame rendering\n     * Let the fabricJS call it. If you call it manually you could have more\n     * animationFrame stacking on to of each other\n     * for an imperative rendering, use canvas.renderAll\n     * @private\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderAndReset: function() {\n            this.isRendering = 0;\n            this.renderAll();\n        },\n        /**\n     * Append a renderAll request to next animation frame.\n     * unless one is already in progress, in that case nothing is done\n     * a boolean flag will avoid appending more.\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ requestRenderAll: function() {\n            if (!this.isRendering) {\n                this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound);\n            }\n            return this;\n        },\n        /**\n     * Calculate the position of the 4 corner of canvas with current viewportTransform.\n     * helps to determinate when an object is in the current rendering viewport using\n     * object absolute coordinates ( aCoords )\n     * @return {Object} points.tl\n     * @chainable\n     */ calcViewportBoundaries: function() {\n            var points = {}, width = this.width, height = this.height, iVpt = invertTransform(this.viewportTransform);\n            points.tl = transformPoint({\n                x: 0,\n                y: 0\n            }, iVpt);\n            points.br = transformPoint({\n                x: width,\n                y: height\n            }, iVpt);\n            points.tr = new fabric.Point(points.br.x, points.tl.y);\n            points.bl = new fabric.Point(points.tl.x, points.br.y);\n            this.vptCoords = points;\n            return points;\n        },\n        cancelRequestedRender: function() {\n            if (this.isRendering) {\n                fabric.util.cancelAnimFrame(this.isRendering);\n                this.isRendering = 0;\n            }\n        },\n        /**\n     * Renders background, objects, overlay and controls.\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Array} objects to render\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderCanvas: function(ctx, objects) {\n            var v = this.viewportTransform, path = this.clipPath;\n            this.cancelRequestedRender();\n            this.calcViewportBoundaries();\n            this.clearContext(ctx);\n            fabric.util.setImageSmoothing(ctx, this.imageSmoothingEnabled);\n            this.fire(\"before:render\", {\n                ctx: ctx\n            });\n            this._renderBackground(ctx);\n            ctx.save();\n            //apply viewport transform once for all rendering process\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            this._renderObjects(ctx, objects);\n            ctx.restore();\n            if (!this.controlsAboveOverlay && this.interactive) {\n                this.drawControls(ctx);\n            }\n            if (path) {\n                path.canvas = this;\n                // needed to setup a couple of variables\n                path.shouldCache();\n                path._transformDone = true;\n                path.renderCache({\n                    forClipping: true\n                });\n                this.drawClipPathOnCanvas(ctx);\n            }\n            this._renderOverlay(ctx);\n            if (this.controlsAboveOverlay && this.interactive) {\n                this.drawControls(ctx);\n            }\n            this.fire(\"after:render\", {\n                ctx: ctx\n            });\n        },\n        /**\n     * Paint the cached clipPath on the lowerCanvasEl\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawClipPathOnCanvas: function(ctx) {\n            var v = this.viewportTransform, path = this.clipPath;\n            ctx.save();\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            // DEBUG: uncomment this line, comment the following\n            // ctx.globalAlpha = 0.4;\n            ctx.globalCompositeOperation = \"destination-in\";\n            path.transform(ctx);\n            ctx.scale(1 / path.zoomX, 1 / path.zoomY);\n            ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Array} objects to render\n     */ _renderObjects: function(ctx, objects) {\n            var i, len;\n            for(i = 0, len = objects.length; i < len; ++i){\n                objects[i] && objects[i].render(ctx);\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {string} property 'background' or 'overlay'\n     */ _renderBackgroundOrOverlay: function(ctx, property) {\n            var fill = this[property + \"Color\"], object = this[property + \"Image\"], v = this.viewportTransform, needsVpt = this[property + \"Vpt\"];\n            if (!fill && !object) {\n                return;\n            }\n            if (fill) {\n                ctx.save();\n                ctx.beginPath();\n                ctx.moveTo(0, 0);\n                ctx.lineTo(this.width, 0);\n                ctx.lineTo(this.width, this.height);\n                ctx.lineTo(0, this.height);\n                ctx.closePath();\n                ctx.fillStyle = fill.toLive ? fill.toLive(ctx, this) : fill;\n                if (needsVpt) {\n                    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n                }\n                ctx.transform(1, 0, 0, 1, fill.offsetX || 0, fill.offsetY || 0);\n                var m = fill.gradientTransform || fill.patternTransform;\n                m && ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n                ctx.fill();\n                ctx.restore();\n            }\n            if (object) {\n                ctx.save();\n                if (needsVpt) {\n                    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n                }\n                object.render(ctx);\n                ctx.restore();\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderBackground: function(ctx) {\n            this._renderBackgroundOrOverlay(ctx, \"background\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderOverlay: function(ctx) {\n            this._renderBackgroundOrOverlay(ctx, \"overlay\");\n        },\n        /**\n     * Returns coordinates of a center of canvas.\n     * Returned value is an object with top and left properties\n     * @return {Object} object with \"top\" and \"left\" number values\n     * @deprecated migrate to `getCenterPoint`\n     */ getCenter: function() {\n            return {\n                top: this.height / 2,\n                left: this.width / 2\n            };\n        },\n        /**\n     * Returns coordinates of a center of canvas.\n     * @return {fabric.Point} \n     */ getCenterPoint: function() {\n            return new fabric.Point(this.width / 2, this.height / 2);\n        },\n        /**\n     * Centers object horizontally in the canvas\n     * @param {fabric.Object} object Object to center horizontally\n     * @return {fabric.Canvas} thisArg\n     */ centerObjectH: function(object) {\n            return this._centerObject(object, new fabric.Point(this.getCenterPoint().x, object.getCenterPoint().y));\n        },\n        /**\n     * Centers object vertically in the canvas\n     * @param {fabric.Object} object Object to center vertically\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ centerObjectV: function(object) {\n            return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenterPoint().y));\n        },\n        /**\n     * Centers object vertically and horizontally in the canvas\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ centerObject: function(object) {\n            var center = this.getCenterPoint();\n            return this._centerObject(object, center);\n        },\n        /**\n     * Centers object vertically and horizontally in the viewport\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ viewportCenterObject: function(object) {\n            var vpCenter = this.getVpCenter();\n            return this._centerObject(object, vpCenter);\n        },\n        /**\n     * Centers object horizontally in the viewport, object.top is unchanged\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ viewportCenterObjectH: function(object) {\n            var vpCenter = this.getVpCenter();\n            this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));\n            return this;\n        },\n        /**\n     * Centers object Vertically in the viewport, object.top is unchanged\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ viewportCenterObjectV: function(object) {\n            var vpCenter = this.getVpCenter();\n            return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));\n        },\n        /**\n     * Calculate the point in canvas that correspond to the center of actual viewport.\n     * @return {fabric.Point} vpCenter, viewport center\n     * @chainable\n     */ getVpCenter: function() {\n            var center = this.getCenterPoint(), iVpt = invertTransform(this.viewportTransform);\n            return transformPoint(center, iVpt);\n        },\n        /**\n     * @private\n     * @param {fabric.Object} object Object to center\n     * @param {fabric.Point} center Center point\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ _centerObject: function(object, center) {\n            object.setPositionByOrigin(center, \"center\", \"center\");\n            object.setCoords();\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Returns dataless JSON representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {String} json string\n     */ toDatalessJSON: function(propertiesToInclude) {\n            return this.toDatalessObject(propertiesToInclude);\n        },\n        /**\n     * Returns object representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this._toObjectMethod(\"toObject\", propertiesToInclude);\n        },\n        /**\n     * Returns dataless object representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            return this._toObjectMethod(\"toDatalessObject\", propertiesToInclude);\n        },\n        /**\n     * @private\n     */ _toObjectMethod: function(methodName, propertiesToInclude) {\n            var clipPath = this.clipPath, data = {\n                version: fabric.version,\n                objects: this._toObjects(methodName, propertiesToInclude)\n            };\n            if (clipPath && !clipPath.excludeFromExport) {\n                data.clipPath = this._toObject(this.clipPath, methodName, propertiesToInclude);\n            }\n            extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));\n            fabric.util.populateWithProperties(this, data, propertiesToInclude);\n            return data;\n        },\n        /**\n     * @private\n     */ _toObjects: function(methodName, propertiesToInclude) {\n            return this._objects.filter(function(object) {\n                return !object.excludeFromExport;\n            }).map(function(instance) {\n                return this._toObject(instance, methodName, propertiesToInclude);\n            }, this);\n        },\n        /**\n     * @private\n     */ _toObject: function(instance, methodName, propertiesToInclude) {\n            var originalValue;\n            if (!this.includeDefaultValues) {\n                originalValue = instance.includeDefaultValues;\n                instance.includeDefaultValues = false;\n            }\n            var object = instance[methodName](propertiesToInclude);\n            if (!this.includeDefaultValues) {\n                instance.includeDefaultValues = originalValue;\n            }\n            return object;\n        },\n        /**\n     * @private\n     */ __serializeBgOverlay: function(methodName, propertiesToInclude) {\n            var data = {}, bgImage = this.backgroundImage, overlayImage = this.overlayImage, bgColor = this.backgroundColor, overlayColor = this.overlayColor;\n            if (bgColor && bgColor.toObject) {\n                if (!bgColor.excludeFromExport) {\n                    data.background = bgColor.toObject(propertiesToInclude);\n                }\n            } else if (bgColor) {\n                data.background = bgColor;\n            }\n            if (overlayColor && overlayColor.toObject) {\n                if (!overlayColor.excludeFromExport) {\n                    data.overlay = overlayColor.toObject(propertiesToInclude);\n                }\n            } else if (overlayColor) {\n                data.overlay = overlayColor;\n            }\n            if (bgImage && !bgImage.excludeFromExport) {\n                data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);\n            }\n            if (overlayImage && !overlayImage.excludeFromExport) {\n                data.overlayImage = this._toObject(overlayImage, methodName, propertiesToInclude);\n            }\n            return data;\n        },\n        /* _TO_SVG_START_ */ /**\n     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,\n     * a zoomed canvas will then produce zoomed SVG output.\n     * @type Boolean\n     * @default\n     */ svgViewportTransformation: true,\n        /**\n     * Returns SVG representation of canvas\n     * @function\n     * @param {Object} [options] Options object for SVG output\n     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included\n     * @param {Object} [options.viewBox] SVG viewbox object\n     * @param {Number} [options.viewBox.x] x-coordinate of viewbox\n     * @param {Number} [options.viewBox.y] y-coordinate of viewbox\n     * @param {Number} [options.viewBox.width] Width of viewbox\n     * @param {Number} [options.viewBox.height] Height of viewbox\n     * @param {String} [options.encoding=UTF-8] Encoding of SVG output\n     * @param {String} [options.width] desired width of svg with or without units\n     * @param {String} [options.height] desired height of svg with or without units\n     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.\n     * @return {String} SVG string\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}\n     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}\n     * @example <caption>Normal SVG output</caption>\n     * var svg = canvas.toSVG();\n     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>\n     * var svg = canvas.toSVG({suppressPreamble: true});\n     * @example <caption>SVG output with viewBox attribute</caption>\n     * var svg = canvas.toSVG({\n     *   viewBox: {\n     *     x: 100,\n     *     y: 100,\n     *     width: 200,\n     *     height: 300\n     *   }\n     * });\n     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>\n     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});\n     * @example <caption>Modify SVG output with reviver function</caption>\n     * var svg = canvas.toSVG(null, function(svg) {\n     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');\n     * });\n     */ toSVG: function(options, reviver) {\n            options || (options = {});\n            options.reviver = reviver;\n            var markup = [];\n            this._setSVGPreamble(markup, options);\n            this._setSVGHeader(markup, options);\n            if (this.clipPath) {\n                markup.push('<g clip-path=\"url(#' + this.clipPath.clipPathId + ')\" >\\n');\n            }\n            this._setSVGBgOverlayColor(markup, \"background\");\n            this._setSVGBgOverlayImage(markup, \"backgroundImage\", reviver);\n            this._setSVGObjects(markup, reviver);\n            if (this.clipPath) {\n                markup.push(\"</g>\\n\");\n            }\n            this._setSVGBgOverlayColor(markup, \"overlay\");\n            this._setSVGBgOverlayImage(markup, \"overlayImage\", reviver);\n            markup.push(\"</svg>\");\n            return markup.join(\"\");\n        },\n        /**\n     * @private\n     */ _setSVGPreamble: function(markup, options) {\n            if (options.suppressPreamble) {\n                return;\n            }\n            markup.push('<?xml version=\"1.0\" encoding=\"', options.encoding || \"UTF-8\", '\" standalone=\"no\" ?>\\n', '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" ', '\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n');\n        },\n        /**\n     * @private\n     */ _setSVGHeader: function(markup, options) {\n            var width = options.width || this.width, height = options.height || this.height, vpt, viewBox = 'viewBox=\"0 0 ' + this.width + \" \" + this.height + '\" ', NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            if (options.viewBox) {\n                viewBox = 'viewBox=\"' + options.viewBox.x + \" \" + options.viewBox.y + \" \" + options.viewBox.width + \" \" + options.viewBox.height + '\" ';\n            } else {\n                if (this.svgViewportTransformation) {\n                    vpt = this.viewportTransform;\n                    viewBox = 'viewBox=\"' + toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + \" \" + toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + \" \" + toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + \" \" + toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '\" ';\n                }\n            }\n            markup.push(\"<svg \", 'xmlns=\"http://www.w3.org/2000/svg\" ', 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ', 'version=\"1.1\" ', 'width=\"', width, '\" ', 'height=\"', height, '\" ', viewBox, 'xml:space=\"preserve\">\\n', \"<desc>Created with Fabric.js \", fabric.version, \"</desc>\\n\", \"<defs>\\n\", this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(options), \"</defs>\\n\");\n        },\n        createSVGClipPathMarkup: function(options) {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                clipPath.clipPathId = \"CLIPPATH_\" + fabric.Object.__uid++;\n                return '<clipPath id=\"' + clipPath.clipPathId + '\" >\\n' + this.clipPath.toClipPathSVG(options.reviver) + \"</clipPath>\\n\";\n            }\n            return \"\";\n        },\n        /**\n     * Creates markup containing SVG referenced elements like patterns, gradients etc.\n     * @return {String}\n     */ createSVGRefElementsMarkup: function() {\n            var _this = this, markup = [\n                \"background\",\n                \"overlay\"\n            ].map(function(prop) {\n                var fill = _this[prop + \"Color\"];\n                if (fill && fill.toLive) {\n                    var shouldTransform = _this[prop + \"Vpt\"], vpt = _this.viewportTransform, object = {\n                        width: _this.width / (shouldTransform ? vpt[0] : 1),\n                        height: _this.height / (shouldTransform ? vpt[3] : 1)\n                    };\n                    return fill.toSVG(object, {\n                        additionalTransform: shouldTransform ? fabric.util.matrixToSVG(vpt) : \"\"\n                    });\n                }\n            });\n            return markup.join(\"\");\n        },\n        /**\n     * Creates markup containing SVG font faces,\n     * font URLs for font faces must be collected by developers\n     * and are not extracted from the DOM by fabricjs\n     * @param {Array} objects Array of fabric objects\n     * @return {String}\n     */ createSVGFontFacesMarkup: function() {\n            var markup = \"\", fontList = {}, obj, fontFamily, style, row, rowIndex, _char, charIndex, i, len, fontPaths = fabric.fontPaths, objects = [];\n            this._objects.forEach(function add(object) {\n                objects.push(object);\n                if (object._objects) {\n                    object._objects.forEach(add);\n                }\n            });\n            for(i = 0, len = objects.length; i < len; i++){\n                obj = objects[i];\n                fontFamily = obj.fontFamily;\n                if (obj.type.indexOf(\"text\") === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {\n                    continue;\n                }\n                fontList[fontFamily] = true;\n                if (!obj.styles) {\n                    continue;\n                }\n                style = obj.styles;\n                for(rowIndex in style){\n                    row = style[rowIndex];\n                    for(charIndex in row){\n                        _char = row[charIndex];\n                        fontFamily = _char.fontFamily;\n                        if (!fontList[fontFamily] && fontPaths[fontFamily]) {\n                            fontList[fontFamily] = true;\n                        }\n                    }\n                }\n            }\n            for(var j in fontList){\n                markup += [\n                    \"\t\t@font-face {\\n\",\n                    \"\t\t\tfont-family: '\",\n                    j,\n                    \"';\\n\",\n                    \"\t\t\tsrc: url('\",\n                    fontPaths[j],\n                    \"');\\n\",\n                    \"\t\t}\\n\"\n                ].join(\"\");\n            }\n            if (markup) {\n                markup = [\n                    '\t<style type=\"text/css\">',\n                    \"<![CDATA[\\n\",\n                    markup,\n                    \"]]>\",\n                    \"</style>\\n\"\n                ].join(\"\");\n            }\n            return markup;\n        },\n        /**\n     * @private\n     */ _setSVGObjects: function(markup, reviver) {\n            var instance, i, len, objects = this._objects;\n            for(i = 0, len = objects.length; i < len; i++){\n                instance = objects[i];\n                if (instance.excludeFromExport) {\n                    continue;\n                }\n                this._setSVGObject(markup, instance, reviver);\n            }\n        },\n        /**\n     * @private\n     */ _setSVGObject: function(markup, instance, reviver) {\n            markup.push(instance.toSVG(reviver));\n        },\n        /**\n     * @private\n     */ _setSVGBgOverlayImage: function(markup, property, reviver) {\n            if (this[property] && !this[property].excludeFromExport && this[property].toSVG) {\n                markup.push(this[property].toSVG(reviver));\n            }\n        },\n        /**\n     * @private\n     */ _setSVGBgOverlayColor: function(markup, property) {\n            var filler = this[property + \"Color\"], vpt = this.viewportTransform, finalWidth = this.width, finalHeight = this.height;\n            if (!filler) {\n                return;\n            }\n            if (filler.toLive) {\n                var repeat = filler.repeat, iVpt = fabric.util.invertTransform(vpt), shouldInvert = this[property + \"Vpt\"], additionalTransform = shouldInvert ? fabric.util.matrixToSVG(iVpt) : \"\";\n                markup.push('<rect transform=\"' + additionalTransform + \" translate(\", finalWidth / 2, \",\", finalHeight / 2, ')\"', ' x=\"', filler.offsetX - finalWidth / 2, '\" y=\"', filler.offsetY - finalHeight / 2, '\" ', 'width=\"', repeat === \"repeat-y\" || repeat === \"no-repeat\" ? filler.source.width : finalWidth, '\" height=\"', repeat === \"repeat-x\" || repeat === \"no-repeat\" ? filler.source.height : finalHeight, '\" fill=\"url(#SVGID_' + filler.id + ')\"', \"></rect>\\n\");\n            } else {\n                markup.push('<rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" ', 'fill=\"', filler, '\"', \"></rect>\\n\");\n            }\n        },\n        /* _TO_SVG_END_ */ /**\n     * Moves an object or the objects of a multiple selection\n     * to the bottom of the stack of drawn objects\n     * @param {fabric.Object} object Object to send to back\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ sendToBack: function(object) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, objs;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = objs.length; i--;){\n                    obj = objs[i];\n                    removeFromArray(this._objects, obj);\n                    this._objects.unshift(obj);\n                }\n            } else {\n                removeFromArray(this._objects, object);\n                this._objects.unshift(object);\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Moves an object or the objects of a multiple selection\n     * to the top of the stack of drawn objects\n     * @param {fabric.Object} object Object to send\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ bringToFront: function(object) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, objs;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = 0; i < objs.length; i++){\n                    obj = objs[i];\n                    removeFromArray(this._objects, obj);\n                    this._objects.push(obj);\n                }\n            } else {\n                removeFromArray(this._objects, object);\n                this._objects.push(object);\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Moves an object or a selection down in stack of drawn objects\n     * An optional parameter, intersecting allows to move the object in behind\n     * the first intersecting object. Where intersection is calculated with\n     * bounding box. If no intersection is found, there will not be change in the\n     * stack.\n     * @param {fabric.Object} object Object to send\n     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ sendBackwards: function(object, intersecting) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, idx, newIdx, objs, objsMoved = 0;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = 0; i < objs.length; i++){\n                    obj = objs[i];\n                    idx = this._objects.indexOf(obj);\n                    if (idx > 0 + objsMoved) {\n                        newIdx = idx - 1;\n                        removeFromArray(this._objects, obj);\n                        this._objects.splice(newIdx, 0, obj);\n                    }\n                    objsMoved++;\n                }\n            } else {\n                idx = this._objects.indexOf(object);\n                if (idx !== 0) {\n                    // if object is not on the bottom of stack\n                    newIdx = this._findNewLowerIndex(object, idx, intersecting);\n                    removeFromArray(this._objects, object);\n                    this._objects.splice(newIdx, 0, object);\n                }\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * @private\n     */ _findNewLowerIndex: function(object, idx, intersecting) {\n            var newIdx, i;\n            if (intersecting) {\n                newIdx = idx;\n                // traverse down the stack looking for the nearest intersecting object\n                for(i = idx - 1; i >= 0; --i){\n                    var isIntersecting = object.intersectsWithObject(this._objects[i]) || object.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(object);\n                    if (isIntersecting) {\n                        newIdx = i;\n                        break;\n                    }\n                }\n            } else {\n                newIdx = idx - 1;\n            }\n            return newIdx;\n        },\n        /**\n     * Moves an object or a selection up in stack of drawn objects\n     * An optional parameter, intersecting allows to move the object in front\n     * of the first intersecting object. Where intersection is calculated with\n     * bounding box. If no intersection is found, there will not be change in the\n     * stack.\n     * @param {fabric.Object} object Object to send\n     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ bringForward: function(object, intersecting) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, idx, newIdx, objs, objsMoved = 0;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = objs.length; i--;){\n                    obj = objs[i];\n                    idx = this._objects.indexOf(obj);\n                    if (idx < this._objects.length - 1 - objsMoved) {\n                        newIdx = idx + 1;\n                        removeFromArray(this._objects, obj);\n                        this._objects.splice(newIdx, 0, obj);\n                    }\n                    objsMoved++;\n                }\n            } else {\n                idx = this._objects.indexOf(object);\n                if (idx !== this._objects.length - 1) {\n                    // if object is not on top of stack (last item in an array)\n                    newIdx = this._findNewUpperIndex(object, idx, intersecting);\n                    removeFromArray(this._objects, object);\n                    this._objects.splice(newIdx, 0, object);\n                }\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * @private\n     */ _findNewUpperIndex: function(object, idx, intersecting) {\n            var newIdx, i, len;\n            if (intersecting) {\n                newIdx = idx;\n                // traverse up the stack looking for the nearest intersecting object\n                for(i = idx + 1, len = this._objects.length; i < len; ++i){\n                    var isIntersecting = object.intersectsWithObject(this._objects[i]) || object.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(object);\n                    if (isIntersecting) {\n                        newIdx = i;\n                        break;\n                    }\n                }\n            } else {\n                newIdx = idx + 1;\n            }\n            return newIdx;\n        },\n        /**\n     * Moves an object to specified level in stack of drawn objects\n     * @param {fabric.Object} object Object to send\n     * @param {Number} index Position to move to\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ moveTo: function(object, index) {\n            removeFromArray(this._objects, object);\n            this._objects.splice(index, 0, object);\n            return this.renderOnAddRemove && this.requestRenderAll();\n        },\n        /**\n     * Clears a canvas element and dispose objects\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ dispose: function() {\n            // cancel eventually ongoing renders\n            if (this.isRendering) {\n                fabric.util.cancelAnimFrame(this.isRendering);\n                this.isRendering = 0;\n            }\n            this.forEachObject(function(object) {\n                object.dispose && object.dispose();\n            });\n            this._objects = [];\n            if (this.backgroundImage && this.backgroundImage.dispose) {\n                this.backgroundImage.dispose();\n            }\n            this.backgroundImage = null;\n            if (this.overlayImage && this.overlayImage.dispose) {\n                this.overlayImage.dispose();\n            }\n            this.overlayImage = null;\n            this._iTextInstances = null;\n            this.contextContainer = null;\n            // restore canvas style\n            this.lowerCanvasEl.classList.remove(\"lower-canvas\");\n            fabric.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle);\n            delete this._originalCanvasStyle;\n            // restore canvas size to original size in case retina scaling was applied\n            this.lowerCanvasEl.setAttribute(\"width\", this.width);\n            this.lowerCanvasEl.setAttribute(\"height\", this.height);\n            fabric.util.cleanUpJsdomNode(this.lowerCanvasEl);\n            this.lowerCanvasEl = undefined;\n            return this;\n        },\n        /**\n     * Returns a string representation of an instance\n     * @return {String} string representation of an instance\n     */ toString: function() {\n            return \"#<fabric.Canvas (\" + this.complexity() + \"): \" + \"{ objects: \" + this._objects.length + \" }>\";\n        }\n    });\n    extend(fabric.StaticCanvas.prototype, fabric.Observable);\n    extend(fabric.StaticCanvas.prototype, fabric.Collection);\n    extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);\n    extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {\n        /**\n     * @static\n     * @type String\n     * @default\n     */ EMPTY_JSON: '{\"objects\": [], \"background\": \"white\"}',\n        /**\n     * Provides a way to check support of some of the canvas methods\n     * (either those of HTMLCanvasElement itself, or rendering context)\n     *\n     * @param {String} methodName Method to check support for;\n     *                            Could be one of \"setLineDash\"\n     * @return {Boolean | null} `true` if method is supported (or at least exists),\n     *                          `null` if canvas element or context can not be initialized\n     */ supports: function(methodName) {\n            var el = createCanvasElement();\n            if (!el || !el.getContext) {\n                return null;\n            }\n            var ctx = el.getContext(\"2d\");\n            if (!ctx) {\n                return null;\n            }\n            switch(methodName){\n                case \"setLineDash\":\n                    return typeof ctx.setLineDash !== \"undefined\";\n                default:\n                    return null;\n            }\n        }\n    });\n    /**\n   * Returns Object representation of canvas\n   * this alias is provided because if you call JSON.stringify on an instance,\n   * the toJSON object will be invoked if it exists.\n   * Having a toJSON method means you can do JSON.stringify(myCanvas)\n   * @function\n   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @return {Object} JSON compatible object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}\n   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}\n   * @example <caption>JSON without additional properties</caption>\n   * var json = canvas.toJSON();\n   * @example <caption>JSON with additional properties included</caption>\n   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY']);\n   * @example <caption>JSON without default values</caption>\n   * canvas.includeDefaultValues = false;\n   * var json = canvas.toJSON();\n   */ fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;\n    if (fabric.isLikelyNode) {\n        fabric.StaticCanvas.prototype.createPNGStream = function() {\n            var impl = getNodeCanvas(this.lowerCanvasEl);\n            return impl && impl.createPNGStream();\n        };\n        fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {\n            var impl = getNodeCanvas(this.lowerCanvasEl);\n            return impl && impl.createJPEGStream(opts);\n        };\n    }\n})();\n/**\n * BaseBrush class\n * @class fabric.BaseBrush\n * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}\n */ fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {\n    /**\n   * Color of a brush\n   * @type String\n   * @default\n   */ color: \"rgb(0, 0, 0)\",\n    /**\n   * Width of a brush, has to be a Number, no string literals\n   * @type Number\n   * @default\n   */ width: 1,\n    /**\n   * Shadow object representing shadow of this shape.\n   * <b>Backwards incompatibility note:</b> This property replaces \"shadowColor\" (String), \"shadowOffsetX\" (Number),\n   * \"shadowOffsetY\" (Number) and \"shadowBlur\" (Number) since v1.2.12\n   * @type fabric.Shadow\n   * @default\n   */ shadow: null,\n    /**\n   * Line endings style of a brush (one of \"butt\", \"round\", \"square\")\n   * @type String\n   * @default\n   */ strokeLineCap: \"round\",\n    /**\n   * Corner style of a brush (one of \"bevel\", \"round\", \"miter\")\n   * @type String\n   * @default\n   */ strokeLineJoin: \"round\",\n    /**\n   * Maximum miter length (used for strokeLineJoin = \"miter\") of a brush's\n   * @type Number\n   * @default\n   */ strokeMiterLimit: 10,\n    /**\n   * Stroke Dash Array.\n   * @type Array\n   * @default\n   */ strokeDashArray: null,\n    /**\n   * When `true`, the free drawing is limited to the whiteboard size. Default to false.\n   * @type Boolean\n   * @default false\n  */ limitedToCanvasSize: false,\n    /**\n   * Sets brush styles\n   * @private\n   * @param {CanvasRenderingContext2D} ctx\n   */ _setBrushStyles: function(ctx) {\n        ctx.strokeStyle = this.color;\n        ctx.lineWidth = this.width;\n        ctx.lineCap = this.strokeLineCap;\n        ctx.miterLimit = this.strokeMiterLimit;\n        ctx.lineJoin = this.strokeLineJoin;\n        ctx.setLineDash(this.strokeDashArray || []);\n    },\n    /**\n   * Sets the transformation on given context\n   * @param {RenderingContext2d} ctx context to render on\n   * @private\n   */ _saveAndTransform: function(ctx) {\n        var v = this.canvas.viewportTransform;\n        ctx.save();\n        ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n    },\n    /**\n   * Sets brush shadow styles\n   * @private\n   */ _setShadow: function() {\n        if (!this.shadow) {\n            return;\n        }\n        var canvas = this.canvas, shadow = this.shadow, ctx = canvas.contextTop, zoom = canvas.getZoom();\n        if (canvas && canvas._isRetinaScaling()) {\n            zoom *= fabric.devicePixelRatio;\n        }\n        ctx.shadowColor = shadow.color;\n        ctx.shadowBlur = shadow.blur * zoom;\n        ctx.shadowOffsetX = shadow.offsetX * zoom;\n        ctx.shadowOffsetY = shadow.offsetY * zoom;\n    },\n    needsFullRender: function() {\n        var color = new fabric.Color(this.color);\n        return color.getAlpha() < 1 || !!this.shadow;\n    },\n    /**\n   * Removes brush shadow styles\n   * @private\n   */ _resetShadow: function() {\n        var ctx = this.canvas.contextTop;\n        ctx.shadowColor = \"\";\n        ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\n    },\n    /**\n   * Check is pointer is outside canvas boundaries\n   * @param {Object} pointer\n   * @private\n  */ _isOutSideCanvas: function(pointer) {\n        return pointer.x < 0 || pointer.x > this.canvas.getWidth() || pointer.y < 0 || pointer.y > this.canvas.getHeight();\n    }\n});\n(function() {\n    /**\n   * PencilBrush class\n   * @class fabric.PencilBrush\n   * @extends fabric.BaseBrush\n   */ fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {\n        /**\n     * Discard points that are less than `decimate` pixel distant from each other\n     * @type Number\n     * @default 0.4\n     */ decimate: 0.4,\n        /**\n     * Draws a straight line between last recorded point to current pointer\n     * Used for `shift` functionality\n     *\n     * @type boolean\n     * @default false\n     */ drawStraightLine: false,\n        /**\n     * The event modifier key that makes the brush draw a straight line.\n     * If `null` or 'none' or any other string that is not a modifier key the feature is disabled.\n     * @type {'altKey' | 'shiftKey' | 'ctrlKey' | 'none' | undefined | null}\n     */ straightLineKey: \"shiftKey\",\n        /**\n     * Constructor\n     * @param {fabric.Canvas} canvas\n     * @return {fabric.PencilBrush} Instance of a pencil brush\n     */ initialize: function(canvas) {\n            this.canvas = canvas;\n            this._points = [];\n        },\n        needsFullRender: function() {\n            return this.callSuper(\"needsFullRender\") || this._hasStraightLine;\n        },\n        /**\n     * Invoked inside on mouse down and mouse move\n     * @param {Object} pointer\n     */ _drawSegment: function(ctx, p1, p2) {\n            var midPoint = p1.midPointFrom(p2);\n            ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\n            return midPoint;\n        },\n        /**\n     * Invoked on mouse down\n     * @param {Object} pointer\n     */ onMouseDown: function(pointer, options) {\n            if (!this.canvas._isMainEvent(options.e)) {\n                return;\n            }\n            this.drawStraightLine = options.e[this.straightLineKey];\n            this._prepareForDrawing(pointer);\n            // capture coordinates immediately\n            // this allows to draw dots (when movement never occurs)\n            this._captureDrawingPath(pointer);\n            this._render();\n        },\n        /**\n     * Invoked on mouse move\n     * @param {Object} pointer\n     */ onMouseMove: function(pointer, options) {\n            if (!this.canvas._isMainEvent(options.e)) {\n                return;\n            }\n            this.drawStraightLine = options.e[this.straightLineKey];\n            if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {\n                return;\n            }\n            if (this._captureDrawingPath(pointer) && this._points.length > 1) {\n                if (this.needsFullRender()) {\n                    // redraw curve\n                    // clear top canvas\n                    this.canvas.clearContext(this.canvas.contextTop);\n                    this._render();\n                } else {\n                    var points = this._points, length = points.length, ctx = this.canvas.contextTop;\n                    // draw the curve update\n                    this._saveAndTransform(ctx);\n                    if (this.oldEnd) {\n                        ctx.beginPath();\n                        ctx.moveTo(this.oldEnd.x, this.oldEnd.y);\n                    }\n                    this.oldEnd = this._drawSegment(ctx, points[length - 2], points[length - 1], true);\n                    ctx.stroke();\n                    ctx.restore();\n                }\n            }\n        },\n        /**\n     * Invoked on mouse up\n     */ onMouseUp: function(options) {\n            if (!this.canvas._isMainEvent(options.e)) {\n                return true;\n            }\n            this.drawStraightLine = false;\n            this.oldEnd = undefined;\n            this._finalizeAndAddPath();\n            return false;\n        },\n        /**\n     * @private\n     * @param {Object} pointer Actual mouse position related to the canvas.\n     */ _prepareForDrawing: function(pointer) {\n            var p = new fabric.Point(pointer.x, pointer.y);\n            this._reset();\n            this._addPoint(p);\n            this.canvas.contextTop.moveTo(p.x, p.y);\n        },\n        /**\n     * @private\n     * @param {fabric.Point} point Point to be added to points array\n     */ _addPoint: function(point) {\n            if (this._points.length > 1 && point.eq(this._points[this._points.length - 1])) {\n                return false;\n            }\n            if (this.drawStraightLine && this._points.length > 1) {\n                this._hasStraightLine = true;\n                this._points.pop();\n            }\n            this._points.push(point);\n            return true;\n        },\n        /**\n     * Clear points array and set contextTop canvas style.\n     * @private\n     */ _reset: function() {\n            this._points = [];\n            this._setBrushStyles(this.canvas.contextTop);\n            this._setShadow();\n            this._hasStraightLine = false;\n        },\n        /**\n     * @private\n     * @param {Object} pointer Actual mouse position related to the canvas.\n     */ _captureDrawingPath: function(pointer) {\n            var pointerPoint = new fabric.Point(pointer.x, pointer.y);\n            return this._addPoint(pointerPoint);\n        },\n        /**\n     * Draw a smooth path on the topCanvas using quadraticCurveTo\n     * @private\n     * @param {CanvasRenderingContext2D} [ctx]\n     */ _render: function(ctx) {\n            var i, len, p1 = this._points[0], p2 = this._points[1];\n            ctx = ctx || this.canvas.contextTop;\n            this._saveAndTransform(ctx);\n            ctx.beginPath();\n            //if we only have 2 points in the path and they are the same\n            //it means that the user only clicked the canvas without moving the mouse\n            //then we should be drawing a dot. A path isn't drawn between two identical dots\n            //that's why we set them apart a bit\n            if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {\n                var width = this.width / 1000;\n                p1 = new fabric.Point(p1.x, p1.y);\n                p2 = new fabric.Point(p2.x, p2.y);\n                p1.x -= width;\n                p2.x += width;\n            }\n            ctx.moveTo(p1.x, p1.y);\n            for(i = 1, len = this._points.length; i < len; i++){\n                // we pick the point between pi + 1 & pi + 2 as the\n                // end point and p1 as our control point.\n                this._drawSegment(ctx, p1, p2);\n                p1 = this._points[i];\n                p2 = this._points[i + 1];\n            }\n            // Draw last line as a straight line while\n            // we wait for the next point to be able to calculate\n            // the bezier control point\n            ctx.lineTo(p1.x, p1.y);\n            ctx.stroke();\n            ctx.restore();\n        },\n        /**\n     * Converts points to SVG path\n     * @param {Array} points Array of points\n     * @return {(string|number)[][]} SVG path commands\n     */ convertPointsToSVGPath: function(points) {\n            var correction = this.width / 1000;\n            return fabric.util.getSmoothPathFromPoints(points, correction);\n        },\n        /**\n     * @private\n     * @param {(string|number)[][]} pathData SVG path commands\n     * @returns {boolean}\n     */ _isEmptySVGPath: function(pathData) {\n            var pathString = fabric.util.joinPath(pathData);\n            return pathString === \"M 0 0 Q 0 0 0 0 L 0 0\";\n        },\n        /**\n     * Creates fabric.Path object to add on canvas\n     * @param {(string|number)[][]} pathData Path data\n     * @return {fabric.Path} Path to add on canvas\n     */ createPath: function(pathData) {\n            var path = new fabric.Path(pathData, {\n                fill: null,\n                stroke: this.color,\n                strokeWidth: this.width,\n                strokeLineCap: this.strokeLineCap,\n                strokeMiterLimit: this.strokeMiterLimit,\n                strokeLineJoin: this.strokeLineJoin,\n                strokeDashArray: this.strokeDashArray\n            });\n            if (this.shadow) {\n                this.shadow.affectStroke = true;\n                path.shadow = new fabric.Shadow(this.shadow);\n            }\n            return path;\n        },\n        /**\n     * Decimate points array with the decimate value\n     */ decimatePoints: function(points, distance) {\n            if (points.length <= 2) {\n                return points;\n            }\n            var zoom = this.canvas.getZoom(), adjustedDistance = Math.pow(distance / zoom, 2), i, l = points.length - 1, lastPoint = points[0], newPoints = [\n                lastPoint\n            ], cDistance;\n            for(i = 1; i < l - 1; i++){\n                cDistance = Math.pow(lastPoint.x - points[i].x, 2) + Math.pow(lastPoint.y - points[i].y, 2);\n                if (cDistance >= adjustedDistance) {\n                    lastPoint = points[i];\n                    newPoints.push(lastPoint);\n                }\n            }\n            /**\n       * Add the last point from the original line to the end of the array.\n       * This ensures decimate doesn't delete the last point on the line, and ensures the line is > 1 point.\n       */ newPoints.push(points[l]);\n            return newPoints;\n        },\n        /**\n     * On mouseup after drawing the path on contextTop canvas\n     * we use the points captured to create an new fabric path object\n     * and add it to the fabric canvas.\n     */ _finalizeAndAddPath: function() {\n            var ctx = this.canvas.contextTop;\n            ctx.closePath();\n            if (this.decimate) {\n                this._points = this.decimatePoints(this._points, this.decimate);\n            }\n            var pathData = this.convertPointsToSVGPath(this._points);\n            if (this._isEmptySVGPath(pathData)) {\n                // do not create 0 width/height paths, as they are\n                // rendered inconsistently across browsers\n                // Firefox 4, for example, renders a dot,\n                // whereas Chrome 10 renders nothing\n                this.canvas.requestRenderAll();\n                return;\n            }\n            var path = this.createPath(pathData);\n            this.canvas.clearContext(this.canvas.contextTop);\n            this.canvas.fire(\"before:path:created\", {\n                path: path\n            });\n            this.canvas.add(path);\n            this.canvas.requestRenderAll();\n            path.setCoords();\n            this._resetShadow();\n            // fire event 'path' created\n            this.canvas.fire(\"path:created\", {\n                path: path\n            });\n        }\n    });\n})();\n/**\n * CircleBrush class\n * @class fabric.CircleBrush\n */ fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {\n    /**\n   * Width of a brush\n   * @type Number\n   * @default\n   */ width: 10,\n    /**\n   * Constructor\n   * @param {fabric.Canvas} canvas\n   * @return {fabric.CircleBrush} Instance of a circle brush\n   */ initialize: function(canvas) {\n        this.canvas = canvas;\n        this.points = [];\n    },\n    /**\n   * Invoked inside on mouse down and mouse move\n   * @param {Object} pointer\n   */ drawDot: function(pointer) {\n        var point = this.addPoint(pointer), ctx = this.canvas.contextTop;\n        this._saveAndTransform(ctx);\n        this.dot(ctx, point);\n        ctx.restore();\n    },\n    dot: function(ctx, point) {\n        ctx.fillStyle = point.fill;\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);\n        ctx.closePath();\n        ctx.fill();\n    },\n    /**\n   * Invoked on mouse down\n   */ onMouseDown: function(pointer) {\n        this.points.length = 0;\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._setShadow();\n        this.drawDot(pointer);\n    },\n    /**\n   * Render the full state of the brush\n   * @private\n   */ _render: function() {\n        var ctx = this.canvas.contextTop, i, len, points = this.points;\n        this._saveAndTransform(ctx);\n        for(i = 0, len = points.length; i < len; i++){\n            this.dot(ctx, points[i]);\n        }\n        ctx.restore();\n    },\n    /**\n   * Invoked on mouse move\n   * @param {Object} pointer\n   */ onMouseMove: function(pointer) {\n        if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {\n            return;\n        }\n        if (this.needsFullRender()) {\n            this.canvas.clearContext(this.canvas.contextTop);\n            this.addPoint(pointer);\n            this._render();\n        } else {\n            this.drawDot(pointer);\n        }\n    },\n    /**\n   * Invoked on mouse up\n   */ onMouseUp: function() {\n        var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i, len;\n        this.canvas.renderOnAddRemove = false;\n        var circles = [];\n        for(i = 0, len = this.points.length; i < len; i++){\n            var point = this.points[i], circle = new fabric.Circle({\n                radius: point.radius,\n                left: point.x,\n                top: point.y,\n                originX: \"center\",\n                originY: \"center\",\n                fill: point.fill\n            });\n            this.shadow && (circle.shadow = new fabric.Shadow(this.shadow));\n            circles.push(circle);\n        }\n        var group = new fabric.Group(circles);\n        group.canvas = this.canvas;\n        this.canvas.fire(\"before:path:created\", {\n            path: group\n        });\n        this.canvas.add(group);\n        this.canvas.fire(\"path:created\", {\n            path: group\n        });\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._resetShadow();\n        this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\n        this.canvas.requestRenderAll();\n    },\n    /**\n   * @param {Object} pointer\n   * @return {fabric.Point} Just added pointer point\n   */ addPoint: function(pointer) {\n        var pointerPoint = new fabric.Point(pointer.x, pointer.y), circleRadius = fabric.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) / 2, circleColor = new fabric.Color(this.color).setAlpha(fabric.util.getRandomInt(0, 100) / 100).toRgba();\n        pointerPoint.radius = circleRadius;\n        pointerPoint.fill = circleColor;\n        this.points.push(pointerPoint);\n        return pointerPoint;\n    }\n});\n/**\n * SprayBrush class\n * @class fabric.SprayBrush\n */ fabric.SprayBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {\n    /**\n   * Width of a spray\n   * @type Number\n   * @default\n   */ width: 10,\n    /**\n   * Density of a spray (number of dots per chunk)\n   * @type Number\n   * @default\n   */ density: 20,\n    /**\n   * Width of spray dots\n   * @type Number\n   * @default\n   */ dotWidth: 1,\n    /**\n   * Width variance of spray dots\n   * @type Number\n   * @default\n   */ dotWidthVariance: 1,\n    /**\n   * Whether opacity of a dot should be random\n   * @type Boolean\n   * @default\n   */ randomOpacity: false,\n    /**\n   * Whether overlapping dots (rectangles) should be removed (for performance reasons)\n   * @type Boolean\n   * @default\n   */ optimizeOverlapping: true,\n    /**\n   * Constructor\n   * @param {fabric.Canvas} canvas\n   * @return {fabric.SprayBrush} Instance of a spray brush\n   */ initialize: function(canvas) {\n        this.canvas = canvas;\n        this.sprayChunks = [];\n    },\n    /**\n   * Invoked on mouse down\n   * @param {Object} pointer\n   */ onMouseDown: function(pointer) {\n        this.sprayChunks.length = 0;\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._setShadow();\n        this.addSprayChunk(pointer);\n        this.render(this.sprayChunkPoints);\n    },\n    /**\n   * Invoked on mouse move\n   * @param {Object} pointer\n   */ onMouseMove: function(pointer) {\n        if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {\n            return;\n        }\n        this.addSprayChunk(pointer);\n        this.render(this.sprayChunkPoints);\n    },\n    /**\n   * Invoked on mouse up\n   */ onMouseUp: function() {\n        var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;\n        this.canvas.renderOnAddRemove = false;\n        var rects = [];\n        for(var i = 0, ilen = this.sprayChunks.length; i < ilen; i++){\n            var sprayChunk = this.sprayChunks[i];\n            for(var j = 0, jlen = sprayChunk.length; j < jlen; j++){\n                var rect = new fabric.Rect({\n                    width: sprayChunk[j].width,\n                    height: sprayChunk[j].width,\n                    left: sprayChunk[j].x + 1,\n                    top: sprayChunk[j].y + 1,\n                    originX: \"center\",\n                    originY: \"center\",\n                    fill: this.color\n                });\n                rects.push(rect);\n            }\n        }\n        if (this.optimizeOverlapping) {\n            rects = this._getOptimizedRects(rects);\n        }\n        var group = new fabric.Group(rects);\n        this.shadow && group.set(\"shadow\", new fabric.Shadow(this.shadow));\n        this.canvas.fire(\"before:path:created\", {\n            path: group\n        });\n        this.canvas.add(group);\n        this.canvas.fire(\"path:created\", {\n            path: group\n        });\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._resetShadow();\n        this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\n        this.canvas.requestRenderAll();\n    },\n    /**\n   * @private\n   * @param {Array} rects\n   */ _getOptimizedRects: function(rects) {\n        // avoid creating duplicate rects at the same coordinates\n        var uniqueRects = {}, key, i, len;\n        for(i = 0, len = rects.length; i < len; i++){\n            key = rects[i].left + \"\" + rects[i].top;\n            if (!uniqueRects[key]) {\n                uniqueRects[key] = rects[i];\n            }\n        }\n        var uniqueRectsArray = [];\n        for(key in uniqueRects){\n            uniqueRectsArray.push(uniqueRects[key]);\n        }\n        return uniqueRectsArray;\n    },\n    /**\n   * Render new chunk of spray brush\n   */ render: function(sprayChunk) {\n        var ctx = this.canvas.contextTop, i, len;\n        ctx.fillStyle = this.color;\n        this._saveAndTransform(ctx);\n        for(i = 0, len = sprayChunk.length; i < len; i++){\n            var point = sprayChunk[i];\n            if (typeof point.opacity !== \"undefined\") {\n                ctx.globalAlpha = point.opacity;\n            }\n            ctx.fillRect(point.x, point.y, point.width, point.width);\n        }\n        ctx.restore();\n    },\n    /**\n   * Render all spray chunks\n   */ _render: function() {\n        var ctx = this.canvas.contextTop, i, ilen;\n        ctx.fillStyle = this.color;\n        this._saveAndTransform(ctx);\n        for(i = 0, ilen = this.sprayChunks.length; i < ilen; i++){\n            this.render(this.sprayChunks[i]);\n        }\n        ctx.restore();\n    },\n    /**\n   * @param {Object} pointer\n   */ addSprayChunk: function(pointer) {\n        this.sprayChunkPoints = [];\n        var x, y, width, radius = this.width / 2, i;\n        for(i = 0; i < this.density; i++){\n            x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);\n            y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);\n            if (this.dotWidthVariance) {\n                width = fabric.util.getRandomInt(// bottom clamp width to 1\n                Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance);\n            } else {\n                width = this.dotWidth;\n            }\n            var point = new fabric.Point(x, y);\n            point.width = width;\n            if (this.randomOpacity) {\n                point.opacity = fabric.util.getRandomInt(0, 100) / 100;\n            }\n            this.sprayChunkPoints.push(point);\n        }\n        this.sprayChunks.push(this.sprayChunkPoints);\n    }\n});\n/**\n * PatternBrush class\n * @class fabric.PatternBrush\n * @extends fabric.BaseBrush\n */ fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {\n    getPatternSrc: function() {\n        var dotWidth = 20, dotDistance = 5, patternCanvas = fabric.util.createCanvasElement(), patternCtx = patternCanvas.getContext(\"2d\");\n        patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;\n        patternCtx.fillStyle = this.color;\n        patternCtx.beginPath();\n        patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);\n        patternCtx.closePath();\n        patternCtx.fill();\n        return patternCanvas;\n    },\n    getPatternSrcFunction: function() {\n        return String(this.getPatternSrc).replace(\"this.color\", '\"' + this.color + '\"');\n    },\n    /**\n   * Creates \"pattern\" instance property\n   * @param {CanvasRenderingContext2D} ctx\n   */ getPattern: function(ctx) {\n        return ctx.createPattern(this.source || this.getPatternSrc(), \"repeat\");\n    },\n    /**\n   * Sets brush styles\n   * @param {CanvasRenderingContext2D} ctx\n   */ _setBrushStyles: function(ctx) {\n        this.callSuper(\"_setBrushStyles\", ctx);\n        ctx.strokeStyle = this.getPattern(ctx);\n    },\n    /**\n   * Creates path\n   */ createPath: function(pathData) {\n        var path = this.callSuper(\"createPath\", pathData), topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);\n        path.stroke = new fabric.Pattern({\n            source: this.source || this.getPatternSrcFunction(),\n            offsetX: -topLeft.x,\n            offsetY: -topLeft.y\n        });\n        return path;\n    }\n});\n(function() {\n    var getPointer = fabric.util.getPointer, degreesToRadians = fabric.util.degreesToRadians, isTouchEvent = fabric.util.isTouchEvent;\n    /**\n   * Canvas class\n   * @class fabric.Canvas\n   * @extends fabric.StaticCanvas\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}\n   * @see {@link fabric.Canvas#initialize} for constructor definition\n   *\n   * @fires object:modified at the end of a transform or any change when statefull is true\n   * @fires object:rotating while an object is being rotated from the control\n   * @fires object:scaling while an object is being scaled by controls\n   * @fires object:moving while an object is being dragged\n   * @fires object:skewing while an object is being skewed from the controls\n   *\n   * @fires before:transform before a transform is is started\n   * @fires before:selection:cleared\n   * @fires selection:cleared\n   * @fires selection:updated\n   * @fires selection:created\n   *\n   * @fires path:created after a drawing operation ends and the path is added\n   * @fires mouse:down\n   * @fires mouse:move\n   * @fires mouse:up\n   * @fires mouse:down:before  on mouse down, before the inner fabric logic runs\n   * @fires mouse:move:before on mouse move, before the inner fabric logic runs\n   * @fires mouse:up:before on mouse up, before the inner fabric logic runs\n   * @fires mouse:over\n   * @fires mouse:out\n   * @fires mouse:dblclick whenever a native dbl click event fires on the canvas.\n   *\n   * @fires dragover\n   * @fires dragenter\n   * @fires dragleave\n   * @fires drop:before before drop event. same native event. This is added to handle edge cases\n   * @fires drop\n   * @fires after:render at the end of the render process, receives the context in the callback\n   * @fires before:render at start the render process, receives the context in the callback\n   *\n   */ fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {\n        /**\n     * Constructor\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(el, options) {\n            options || (options = {});\n            this.renderAndResetBound = this.renderAndReset.bind(this);\n            this.requestRenderAllBound = this.requestRenderAll.bind(this);\n            this._initStatic(el, options);\n            this._initInteractive();\n            this._createCacheCanvas();\n        },\n        /**\n     * When true, objects can be transformed by one side (unproportionally)\n     * when dragged on the corners that normally would not do that.\n     * @type Boolean\n     * @default\n     * @since fabric 4.0 // changed name and default value\n     */ uniformScaling: true,\n        /**\n     * Indicates which key switches uniform scaling.\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled.\n     * totally wrong named. this sounds like `uniform scaling`\n     * if Canvas.uniformScaling is true, pressing this will set it to false\n     * and viceversa.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ uniScaleKey: \"shiftKey\",\n        /**\n     * When true, objects use center point as the origin of scale transformation.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredScaling: false,\n        /**\n     * When true, objects use center point as the origin of rotate transformation.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredRotation: false,\n        /**\n     * Indicates which key enable centered Transform\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled feature disabled.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ centeredKey: \"altKey\",\n        /**\n     * Indicates which key enable alternate action on corner\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled feature disabled.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ altActionKey: \"shiftKey\",\n        /**\n     * Indicates that canvas is interactive. This property should not be changed.\n     * @type Boolean\n     * @default\n     */ interactive: true,\n        /**\n     * Indicates whether group selection should be enabled\n     * @type Boolean\n     * @default\n     */ selection: true,\n        /**\n     * Indicates which key or keys enable multiple click selection\n     * Pass value as a string or array of strings\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or empty or containing any other string that is not a modifier key\n     * feature is disabled.\n     * @since 1.6.2\n     * @type String|Array\n     * @default\n     */ selectionKey: \"shiftKey\",\n        /**\n     * Indicates which key enable alternative selection\n     * in case of target overlapping with active object\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * For a series of reason that come from the general expectations on how\n     * things should work, this feature works only for preserveObjectStacking true.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled.\n     * @since 1.6.5\n     * @type null|String\n     * @default\n     */ altSelectionKey: null,\n        /**\n     * Color of selection\n     * @type String\n     * @default\n     */ selectionColor: \"rgba(100, 100, 255, 0.3)\",\n        /**\n     * Default dash array pattern\n     * If not empty the selection border is dashed\n     * @type Array\n     */ selectionDashArray: [],\n        /**\n     * Color of the border of selection (usually slightly darker than color of selection itself)\n     * @type String\n     * @default\n     */ selectionBorderColor: \"rgba(255, 255, 255, 0.3)\",\n        /**\n     * Width of a line used in object/group selection\n     * @type Number\n     * @default\n     */ selectionLineWidth: 1,\n        /**\n     * Select only shapes that are fully contained in the dragged selection rectangle.\n     * @type Boolean\n     * @default\n     */ selectionFullyContained: false,\n        /**\n     * Default cursor value used when hovering over an object on canvas\n     * @type String\n     * @default\n     */ hoverCursor: \"move\",\n        /**\n     * Default cursor value used when moving an object on canvas\n     * @type String\n     * @default\n     */ moveCursor: \"move\",\n        /**\n     * Default cursor value used for the entire canvas\n     * @type String\n     * @default\n     */ defaultCursor: \"default\",\n        /**\n     * Cursor value used during free drawing\n     * @type String\n     * @default\n     */ freeDrawingCursor: \"crosshair\",\n        /**\n     * Cursor value used for disabled elements ( corners with disabled action )\n     * @type String\n     * @since 2.0.0\n     * @default\n     */ notAllowedCursor: \"not-allowed\",\n        /**\n     * Default element class that's given to wrapper (div) element of canvas\n     * @type String\n     * @default\n     */ containerClass: \"canvas-container\",\n        /**\n     * When true, object detection happens on per-pixel basis rather than on per-bounding-box\n     * @type Boolean\n     * @default\n     */ perPixelTargetFind: false,\n        /**\n     * Number of pixels around target pixel to tolerate (consider active) during object detection\n     * @type Number\n     * @default\n     */ targetFindTolerance: 0,\n        /**\n     * When true, target detection is skipped. Target detection will return always undefined.\n     * click selection won't work anymore, events will fire with no targets.\n     * if something is selected before setting it to true, it will be deselected at the first click.\n     * area selection will still work. check the `selection` property too.\n     * if you deactivate both, you should look into staticCanvas.\n     * @type Boolean\n     * @default\n     */ skipTargetFind: false,\n        /**\n     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.\n     * After mousedown, mousemove creates a shape,\n     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}\n     * @type Boolean\n     * @default\n     */ isDrawingMode: false,\n        /**\n     * Indicates whether objects should remain in current stack position when selected.\n     * When false objects are brought to top and rendered as part of the selection group\n     * @type Boolean\n     * @default\n     */ preserveObjectStacking: false,\n        /**\n     * Indicates the angle that an object will lock to while rotating.\n     * @type Number\n     * @since 1.6.7\n     * @default\n     */ snapAngle: 0,\n        /**\n     * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.\n     * When `null`, the snapThreshold will default to the snapAngle.\n     * @type null|Number\n     * @since 1.6.7\n     * @default\n     */ snapThreshold: null,\n        /**\n     * Indicates if the right click on canvas can output the context menu or not\n     * @type Boolean\n     * @since 1.6.5\n     * @default\n     */ stopContextMenu: false,\n        /**\n     * Indicates if the canvas can fire right click events\n     * @type Boolean\n     * @since 1.6.5\n     * @default\n     */ fireRightClick: false,\n        /**\n     * Indicates if the canvas can fire middle click events\n     * @type Boolean\n     * @since 1.7.8\n     * @default\n     */ fireMiddleClick: false,\n        /**\n     * Keep track of the subTargets for Mouse Events\n     * @type fabric.Object[]\n     */ targets: [],\n        /**\n     * When the option is enabled, PointerEvent is used instead of MouseEvent.\n     * @type Boolean\n     * @default\n     */ enablePointerEvents: false,\n        /**\n     * Keep track of the hovered target\n     * @type fabric.Object\n     * @private\n     */ _hoveredTarget: null,\n        /**\n     * hold the list of nested targets hovered\n     * @type fabric.Object[]\n     * @private\n     */ _hoveredTargets: [],\n        /**\n     * @private\n     */ _initInteractive: function() {\n            this._currentTransform = null;\n            this._groupSelector = null;\n            this._initWrapperElement();\n            this._createUpperCanvas();\n            this._initEventListeners();\n            this._initRetinaScaling();\n            this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);\n            this.calcOffset();\n        },\n        /**\n     * Divides objects in two groups, one to render immediately\n     * and one to render as activeGroup.\n     * @return {Array} objects to render immediately and pushes the other in the activeGroup.\n     */ _chooseObjectsToRender: function() {\n            var activeObjects = this.getActiveObjects(), object, objsToRender, activeGroupObjects;\n            if (activeObjects.length > 0 && !this.preserveObjectStacking) {\n                objsToRender = [];\n                activeGroupObjects = [];\n                for(var i = 0, length = this._objects.length; i < length; i++){\n                    object = this._objects[i];\n                    if (activeObjects.indexOf(object) === -1) {\n                        objsToRender.push(object);\n                    } else {\n                        activeGroupObjects.push(object);\n                    }\n                }\n                if (activeObjects.length > 1) {\n                    this._activeObject._objects = activeGroupObjects;\n                }\n                objsToRender.push.apply(objsToRender, activeGroupObjects);\n            } else {\n                objsToRender = this._objects;\n            }\n            return objsToRender;\n        },\n        /**\n     * Renders both the top canvas and the secondary container canvas.\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderAll: function() {\n            if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {\n                this.clearContext(this.contextTop);\n                this.contextTopDirty = false;\n            }\n            if (this.hasLostContext) {\n                this.renderTopLayer(this.contextTop);\n                this.hasLostContext = false;\n            }\n            var canvasToDrawOn = this.contextContainer;\n            this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());\n            return this;\n        },\n        renderTopLayer: function(ctx) {\n            ctx.save();\n            if (this.isDrawingMode && this._isCurrentlyDrawing) {\n                this.freeDrawingBrush && this.freeDrawingBrush._render();\n                this.contextTopDirty = true;\n            }\n            // we render the top context - last object\n            if (this.selection && this._groupSelector) {\n                this._drawSelection(ctx);\n                this.contextTopDirty = true;\n            }\n            ctx.restore();\n        },\n        /**\n     * Method to render only the top canvas.\n     * Also used to render the group selection box.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ renderTop: function() {\n            var ctx = this.contextTop;\n            this.clearContext(ctx);\n            this.renderTopLayer(ctx);\n            this.fire(\"after:render\");\n            return this;\n        },\n        /**\n     * @private\n     */ _normalizePointer: function(object, pointer) {\n            var m = object.calcTransformMatrix(), invertedM = fabric.util.invertTransform(m), vptPointer = this.restorePointerVpt(pointer);\n            return fabric.util.transformPoint(vptPointer, invertedM);\n        },\n        /**\n     * Returns true if object is transparent at a certain location\n     * @param {fabric.Object} target Object to check\n     * @param {Number} x Left coordinate\n     * @param {Number} y Top coordinate\n     * @return {Boolean}\n     */ isTargetTransparent: function(target, x, y) {\n            // in case the target is the activeObject, we cannot execute this optimization\n            // because we need to draw controls too.\n            if (target.shouldCache() && target._cacheCanvas && target !== this._activeObject) {\n                var normalizedPointer = this._normalizePointer(target, {\n                    x: x,\n                    y: y\n                }), targetRelativeX = Math.max(target.cacheTranslationX + normalizedPointer.x * target.zoomX, 0), targetRelativeY = Math.max(target.cacheTranslationY + normalizedPointer.y * target.zoomY, 0);\n                var isTransparent = fabric.util.isTransparent(target._cacheContext, Math.round(targetRelativeX), Math.round(targetRelativeY), this.targetFindTolerance);\n                return isTransparent;\n            }\n            var ctx = this.contextCache, originalColor = target.selectionBackgroundColor, v = this.viewportTransform;\n            target.selectionBackgroundColor = \"\";\n            this.clearContext(ctx);\n            ctx.save();\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            target.render(ctx);\n            ctx.restore();\n            target.selectionBackgroundColor = originalColor;\n            var isTransparent = fabric.util.isTransparent(ctx, x, y, this.targetFindTolerance);\n            return isTransparent;\n        },\n        /**\n     * takes an event and determines if selection key has been pressed\n     * @private\n     * @param {Event} e Event object\n     */ _isSelectionKeyPressed: function(e) {\n            var selectionKeyPressed = false;\n            if (Array.isArray(this.selectionKey)) {\n                selectionKeyPressed = !!this.selectionKey.find(function(key) {\n                    return e[key] === true;\n                });\n            } else {\n                selectionKeyPressed = e[this.selectionKey];\n            }\n            return selectionKeyPressed;\n        },\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */ _shouldClearSelection: function(e, target) {\n            var activeObjects = this.getActiveObjects(), activeObject = this._activeObject;\n            return !target || target && activeObject && activeObjects.length > 1 && activeObjects.indexOf(target) === -1 && activeObject !== target && !this._isSelectionKeyPressed(e) || target && !target.evented || target && !target.selectable && activeObject && activeObject !== target;\n        },\n        /**\n     * centeredScaling from object can't override centeredScaling from canvas.\n     * this should be fixed, since object setting should take precedence over canvas.\n     * also this should be something that will be migrated in the control properties.\n     * as ability to define the origin of the transformation that the control provide.\n     * @private\n     * @param {fabric.Object} target\n     * @param {String} action\n     * @param {Boolean} altKey\n     */ _shouldCenterTransform: function(target, action, altKey) {\n            if (!target) {\n                return;\n            }\n            var centerTransform;\n            if (action === \"scale\" || action === \"scaleX\" || action === \"scaleY\" || action === \"resizing\") {\n                centerTransform = this.centeredScaling || target.centeredScaling;\n            } else if (action === \"rotate\") {\n                centerTransform = this.centeredRotation || target.centeredRotation;\n            }\n            return centerTransform ? !altKey : altKey;\n        },\n        /**\n     * should disappear before release 4.0\n     * @private\n     */ _getOriginFromCorner: function(target, corner) {\n            var origin = {\n                x: target.originX,\n                y: target.originY\n            };\n            if (corner === \"ml\" || corner === \"tl\" || corner === \"bl\") {\n                origin.x = \"right\";\n            } else if (corner === \"mr\" || corner === \"tr\" || corner === \"br\") {\n                origin.x = \"left\";\n            }\n            if (corner === \"tl\" || corner === \"mt\" || corner === \"tr\") {\n                origin.y = \"bottom\";\n            } else if (corner === \"bl\" || corner === \"mb\" || corner === \"br\") {\n                origin.y = \"top\";\n            }\n            return origin;\n        },\n        /**\n     * @private\n     * @param {Boolean} alreadySelected true if target is already selected\n     * @param {String} corner a string representing the corner ml, mr, tl ...\n     * @param {Event} e Event object\n     * @param {fabric.Object} [target] inserted back to help overriding. Unused\n     */ _getActionFromCorner: function(alreadySelected, corner, e, target) {\n            if (!corner || !alreadySelected) {\n                return \"drag\";\n            }\n            var control = target.controls[corner];\n            return control.getActionName(e, control, target);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */ _setupCurrentTransform: function(e, target, alreadySelected) {\n            if (!target) {\n                return;\n            }\n            var pointer = this.getPointer(e), corner = target.__corner, control = target.controls[corner], actionHandler = alreadySelected && corner ? control.getActionHandler(e, target, control) : fabric.controlsUtils.dragHandler, action = this._getActionFromCorner(alreadySelected, corner, e, target), origin = this._getOriginFromCorner(target, corner), altKey = e[this.centeredKey], transform = {\n                target: target,\n                action: action,\n                actionHandler: actionHandler,\n                corner: corner,\n                scaleX: target.scaleX,\n                scaleY: target.scaleY,\n                skewX: target.skewX,\n                skewY: target.skewY,\n                // used by transation\n                offsetX: pointer.x - target.left,\n                offsetY: pointer.y - target.top,\n                originX: origin.x,\n                originY: origin.y,\n                ex: pointer.x,\n                ey: pointer.y,\n                lastX: pointer.x,\n                lastY: pointer.y,\n                // unsure they are useful anymore.\n                // left: target.left,\n                // top: target.top,\n                theta: degreesToRadians(target.angle),\n                // end of unsure\n                width: target.width * target.scaleX,\n                shiftKey: e.shiftKey,\n                altKey: altKey,\n                original: fabric.util.saveObjectTransform(target)\n            };\n            if (this._shouldCenterTransform(target, action, altKey)) {\n                transform.originX = \"center\";\n                transform.originY = \"center\";\n            }\n            transform.original.originX = origin.x;\n            transform.original.originY = origin.y;\n            this._currentTransform = transform;\n            this._beforeTransform(e);\n        },\n        /**\n     * Set the cursor type of the canvas element\n     * @param {String} value Cursor type of the canvas element.\n     * @see http://www.w3.org/TR/css3-ui/#cursor\n     */ setCursor: function(value) {\n            this.upperCanvasEl.style.cursor = value;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx to draw the selection on\n     */ _drawSelection: function(ctx) {\n            var selector = this._groupSelector, viewportStart = new fabric.Point(selector.ex, selector.ey), start = fabric.util.transformPoint(viewportStart, this.viewportTransform), viewportExtent = new fabric.Point(selector.ex + selector.left, selector.ey + selector.top), extent = fabric.util.transformPoint(viewportExtent, this.viewportTransform), minX = Math.min(start.x, extent.x), minY = Math.min(start.y, extent.y), maxX = Math.max(start.x, extent.x), maxY = Math.max(start.y, extent.y), strokeOffset = this.selectionLineWidth / 2;\n            if (this.selectionColor) {\n                ctx.fillStyle = this.selectionColor;\n                ctx.fillRect(minX, minY, maxX - minX, maxY - minY);\n            }\n            if (!this.selectionLineWidth || !this.selectionBorderColor) {\n                return;\n            }\n            ctx.lineWidth = this.selectionLineWidth;\n            ctx.strokeStyle = this.selectionBorderColor;\n            minX += strokeOffset;\n            minY += strokeOffset;\n            maxX -= strokeOffset;\n            maxY -= strokeOffset;\n            // selection border\n            fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);\n            ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);\n        },\n        /**\n     * Method that determines what object we are clicking on\n     * the skipGroup parameter is for internal use, is needed for shift+click action\n     * 11/09/2018 TODO: would be cool if findTarget could discern between being a full target\n     * or the outside part of the corner.\n     * @param {Event} e mouse event\n     * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through\n     * @return {fabric.Object} the target found\n     */ findTarget: function(e, skipGroup) {\n            if (this.skipTargetFind) {\n                return;\n            }\n            var ignoreZoom = true, pointer = this.getPointer(e, ignoreZoom), activeObject = this._activeObject, aObjects = this.getActiveObjects(), activeTarget, activeTargetSubs, isTouch = isTouchEvent(e), shouldLookForActive = aObjects.length > 1 && !skipGroup || aObjects.length === 1;\n            // first check current group (if one exists)\n            // active group does not check sub targets like normal groups.\n            // if active group just exits.\n            this.targets = [];\n            // if we hit the corner of an activeObject, let's return that.\n            if (shouldLookForActive && activeObject._findTargetCorner(pointer, isTouch)) {\n                return activeObject;\n            }\n            if (aObjects.length > 1 && !skipGroup && activeObject === this._searchPossibleTargets([\n                activeObject\n            ], pointer)) {\n                return activeObject;\n            }\n            if (aObjects.length === 1 && activeObject === this._searchPossibleTargets([\n                activeObject\n            ], pointer)) {\n                if (!this.preserveObjectStacking) {\n                    return activeObject;\n                } else {\n                    activeTarget = activeObject;\n                    activeTargetSubs = this.targets;\n                    this.targets = [];\n                }\n            }\n            var target = this._searchPossibleTargets(this._objects, pointer);\n            if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {\n                target = activeTarget;\n                this.targets = activeTargetSubs;\n            }\n            return target;\n        },\n        /**\n     * Checks point is inside the object.\n     * @param {Object} [pointer] x,y object of point coordinates we want to check.\n     * @param {fabric.Object} obj Object to test against\n     * @param {Object} [globalPointer] x,y object of point coordinates relative to canvas used to search per pixel target.\n     * @return {Boolean} true if point is contained within an area of given object\n     * @private\n     */ _checkTarget: function(pointer, obj, globalPointer) {\n            if (obj && obj.visible && obj.evented && // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html\n            // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html\n            obj.containsPoint(pointer)) {\n                if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {\n                    var isTransparent = this.isTargetTransparent(obj, globalPointer.x, globalPointer.y);\n                    if (!isTransparent) {\n                        return true;\n                    }\n                } else {\n                    return true;\n                }\n            }\n        },\n        /**\n     * Function used to search inside objects an object that contains pointer in bounding box or that contains pointerOnCanvas when painted\n     * @param {Array} [objects] objects array to look into\n     * @param {Object} [pointer] x,y object of point coordinates we want to check.\n     * @return {fabric.Object} object that contains pointer\n     * @private\n     */ _searchPossibleTargets: function(objects, pointer) {\n            // Cache all targets where their bounding box contains point.\n            var target, i = objects.length, subTarget;\n            // Do not check for currently grouped objects, since we check the parent group itself.\n            // until we call this function specifically to search inside the activeGroup\n            while(i--){\n                var objToCheck = objects[i];\n                var pointerToUse = objToCheck.group ? this._normalizePointer(objToCheck.group, pointer) : pointer;\n                if (this._checkTarget(pointerToUse, objToCheck, pointer)) {\n                    target = objects[i];\n                    if (target.subTargetCheck && target instanceof fabric.Group) {\n                        subTarget = this._searchPossibleTargets(target._objects, pointer);\n                        subTarget && this.targets.push(subTarget);\n                    }\n                    break;\n                }\n            }\n            return target;\n        },\n        /**\n     * Returns pointer coordinates without the effect of the viewport\n     * @param {Object} pointer with \"x\" and \"y\" number values\n     * @return {Object} object with \"x\" and \"y\" number values\n     */ restorePointerVpt: function(pointer) {\n            return fabric.util.transformPoint(pointer, fabric.util.invertTransform(this.viewportTransform));\n        },\n        /**\n     * Returns pointer coordinates relative to canvas.\n     * Can return coordinates with or without viewportTransform.\n     * ignoreZoom false gives back coordinates that represent\n     * the point clicked on canvas element.\n     * ignoreZoom true gives back coordinates after being processed\n     * by the viewportTransform ( sort of coordinates of what is displayed\n     * on the canvas where you are clicking.\n     * ignoreZoom true = HTMLElement coordinates relative to top,left\n     * ignoreZoom false, default = fabric space coordinates, the same used for shape position\n     * To interact with your shapes top and left you want to use ignoreZoom true\n     * most of the time, while ignoreZoom false will give you coordinates\n     * compatible with the object.oCoords system.\n     * of the time.\n     * @param {Event} e\n     * @param {Boolean} ignoreZoom\n     * @return {Object} object with \"x\" and \"y\" number values\n     */ getPointer: function(e, ignoreZoom) {\n            // return cached values if we are in the event processing chain\n            if (this._absolutePointer && !ignoreZoom) {\n                return this._absolutePointer;\n            }\n            if (this._pointer && ignoreZoom) {\n                return this._pointer;\n            }\n            var pointer = getPointer(e), upperCanvasEl = this.upperCanvasEl, bounds = upperCanvasEl.getBoundingClientRect(), boundsWidth = bounds.width || 0, boundsHeight = bounds.height || 0, cssScale;\n            if (!boundsWidth || !boundsHeight) {\n                if (\"top\" in bounds && \"bottom\" in bounds) {\n                    boundsHeight = Math.abs(bounds.top - bounds.bottom);\n                }\n                if (\"right\" in bounds && \"left\" in bounds) {\n                    boundsWidth = Math.abs(bounds.right - bounds.left);\n                }\n            }\n            this.calcOffset();\n            pointer.x = pointer.x - this._offset.left;\n            pointer.y = pointer.y - this._offset.top;\n            if (!ignoreZoom) {\n                pointer = this.restorePointerVpt(pointer);\n            }\n            var retinaScaling = this.getRetinaScaling();\n            if (retinaScaling !== 1) {\n                pointer.x /= retinaScaling;\n                pointer.y /= retinaScaling;\n            }\n            if (boundsWidth === 0 || boundsHeight === 0) {\n                // If bounds are not available (i.e. not visible), do not apply scale.\n                cssScale = {\n                    width: 1,\n                    height: 1\n                };\n            } else {\n                cssScale = {\n                    width: upperCanvasEl.width / boundsWidth,\n                    height: upperCanvasEl.height / boundsHeight\n                };\n            }\n            return {\n                x: pointer.x * cssScale.width,\n                y: pointer.y * cssScale.height\n            };\n        },\n        /**\n     * @private\n     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized\n     */ _createUpperCanvas: function() {\n            var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\\s*lower-canvas\\s*/, \"\"), lowerCanvasEl = this.lowerCanvasEl, upperCanvasEl = this.upperCanvasEl;\n            // there is no need to create a new upperCanvas element if we have already one.\n            if (upperCanvasEl) {\n                upperCanvasEl.className = \"\";\n            } else {\n                upperCanvasEl = this._createCanvasElement();\n                this.upperCanvasEl = upperCanvasEl;\n            }\n            fabric.util.addClass(upperCanvasEl, \"upper-canvas \" + lowerCanvasClass);\n            this.wrapperEl.appendChild(upperCanvasEl);\n            this._copyCanvasStyle(lowerCanvasEl, upperCanvasEl);\n            this._applyCanvasStyle(upperCanvasEl);\n            this.contextTop = upperCanvasEl.getContext(\"2d\");\n        },\n        /**\n     * Returns context of top canvas where interactions are drawn\n     * @returns {CanvasRenderingContext2D}\n     */ getTopContext: function() {\n            return this.contextTop;\n        },\n        /**\n     * @private\n     */ _createCacheCanvas: function() {\n            this.cacheCanvasEl = this._createCanvasElement();\n            this.cacheCanvasEl.setAttribute(\"width\", this.width);\n            this.cacheCanvasEl.setAttribute(\"height\", this.height);\n            this.contextCache = this.cacheCanvasEl.getContext(\"2d\");\n        },\n        /**\n     * @private\n     */ _initWrapperElement: function() {\n            this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, \"div\", {\n                \"class\": this.containerClass\n            });\n            fabric.util.setStyle(this.wrapperEl, {\n                width: this.width + \"px\",\n                height: this.height + \"px\",\n                position: \"relative\"\n            });\n            fabric.util.makeElementUnselectable(this.wrapperEl);\n        },\n        /**\n     * @private\n     * @param {HTMLElement} element canvas element to apply styles on\n     */ _applyCanvasStyle: function(element) {\n            var width = this.width || element.width, height = this.height || element.height;\n            fabric.util.setStyle(element, {\n                position: \"absolute\",\n                width: width + \"px\",\n                height: height + \"px\",\n                left: 0,\n                top: 0,\n                \"touch-action\": this.allowTouchScrolling ? \"manipulation\" : \"none\",\n                \"-ms-touch-action\": this.allowTouchScrolling ? \"manipulation\" : \"none\"\n            });\n            element.width = width;\n            element.height = height;\n            fabric.util.makeElementUnselectable(element);\n        },\n        /**\n     * Copy the entire inline style from one element (fromEl) to another (toEl)\n     * @private\n     * @param {Element} fromEl Element style is copied from\n     * @param {Element} toEl Element copied style is applied to\n     */ _copyCanvasStyle: function(fromEl, toEl) {\n            toEl.style.cssText = fromEl.style.cssText;\n        },\n        /**\n     * Returns context of canvas where object selection is drawn\n     * @return {CanvasRenderingContext2D}\n     */ getSelectionContext: function() {\n            return this.contextTop;\n        },\n        /**\n     * Returns &lt;canvas> element on which object selection is drawn\n     * @return {HTMLCanvasElement}\n     */ getSelectionElement: function() {\n            return this.upperCanvasEl;\n        },\n        /**\n     * Returns currently active object\n     * @return {fabric.Object} active object\n     */ getActiveObject: function() {\n            return this._activeObject;\n        },\n        /**\n     * Returns an array with the current selected objects\n     * @return {fabric.Object} active object\n     */ getActiveObjects: function() {\n            var active = this._activeObject;\n            if (active) {\n                if (active.type === \"activeSelection\" && active._objects) {\n                    return active._objects.slice(0);\n                } else {\n                    return [\n                        active\n                    ];\n                }\n            }\n            return [];\n        },\n        /**\n     * @private\n     * @param {fabric.Object} obj Object that was removed\n     */ _onObjectRemoved: function(obj) {\n            // removing active object should fire \"selection:cleared\" events\n            if (obj === this._activeObject) {\n                this.fire(\"before:selection:cleared\", {\n                    target: obj\n                });\n                this._discardActiveObject();\n                this.fire(\"selection:cleared\", {\n                    target: obj\n                });\n                obj.fire(\"deselected\");\n            }\n            if (obj === this._hoveredTarget) {\n                this._hoveredTarget = null;\n                this._hoveredTargets = [];\n            }\n            this.callSuper(\"_onObjectRemoved\", obj);\n        },\n        /**\n     * @private\n     * Compares the old activeObject with the current one and fires correct events\n     * @param {fabric.Object} obj old activeObject\n     */ _fireSelectionEvents: function(oldObjects, e) {\n            var somethingChanged = false, objects = this.getActiveObjects(), added = [], removed = [];\n            oldObjects.forEach(function(oldObject) {\n                if (objects.indexOf(oldObject) === -1) {\n                    somethingChanged = true;\n                    oldObject.fire(\"deselected\", {\n                        e: e,\n                        target: oldObject\n                    });\n                    removed.push(oldObject);\n                }\n            });\n            objects.forEach(function(object) {\n                if (oldObjects.indexOf(object) === -1) {\n                    somethingChanged = true;\n                    object.fire(\"selected\", {\n                        e: e,\n                        target: object\n                    });\n                    added.push(object);\n                }\n            });\n            if (oldObjects.length > 0 && objects.length > 0) {\n                somethingChanged && this.fire(\"selection:updated\", {\n                    e: e,\n                    selected: added,\n                    deselected: removed\n                });\n            } else if (objects.length > 0) {\n                this.fire(\"selection:created\", {\n                    e: e,\n                    selected: added\n                });\n            } else if (oldObjects.length > 0) {\n                this.fire(\"selection:cleared\", {\n                    e: e,\n                    deselected: removed\n                });\n            }\n        },\n        /**\n     * Sets given object as the only active object on canvas\n     * @param {fabric.Object} object Object to set as an active one\n     * @param {Event} [e] Event (passed along when firing \"object:selected\")\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ setActiveObject: function(object, e) {\n            var currentActives = this.getActiveObjects();\n            this._setActiveObject(object, e);\n            this._fireSelectionEvents(currentActives, e);\n            return this;\n        },\n        /**\n     * This is a private method for now.\n     * This is supposed to be equivalent to setActiveObject but without firing\n     * any event. There is commitment to have this stay this way.\n     * This is the functional part of setActiveObject.\n     * @private\n     * @param {Object} object to set as active\n     * @param {Event} [e] Event (passed along when firing \"object:selected\")\n     * @return {Boolean} true if the selection happened\n     */ _setActiveObject: function(object, e) {\n            if (this._activeObject === object) {\n                return false;\n            }\n            if (!this._discardActiveObject(e, object)) {\n                return false;\n            }\n            if (object.onSelect({\n                e: e\n            })) {\n                return false;\n            }\n            this._activeObject = object;\n            return true;\n        },\n        /**\n     * This is a private method for now.\n     * This is supposed to be equivalent to discardActiveObject but without firing\n     * any events. There is commitment to have this stay this way.\n     * This is the functional part of discardActiveObject.\n     * @param {Event} [e] Event (passed along when firing \"object:deselected\")\n     * @param {Object} object to set as active\n     * @return {Boolean} true if the selection happened\n     * @private\n     */ _discardActiveObject: function(e, object) {\n            var obj = this._activeObject;\n            if (obj) {\n                // onDeselect return TRUE to cancel selection;\n                if (obj.onDeselect({\n                    e: e,\n                    object: object\n                })) {\n                    return false;\n                }\n                this._activeObject = null;\n            }\n            return true;\n        },\n        /**\n     * Discards currently active object and fire events. If the function is called by fabric\n     * as a consequence of a mouse event, the event is passed as a parameter and\n     * sent to the fire function for the custom events. When used as a method the\n     * e param does not have any application.\n     * @param {event} e\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ discardActiveObject: function(e) {\n            var currentActives = this.getActiveObjects(), activeObject = this.getActiveObject();\n            if (currentActives.length) {\n                this.fire(\"before:selection:cleared\", {\n                    target: activeObject,\n                    e: e\n                });\n            }\n            this._discardActiveObject(e);\n            this._fireSelectionEvents(currentActives, e);\n            return this;\n        },\n        /**\n     * Clears a canvas element and removes all event listeners\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ dispose: function() {\n            var wrapper = this.wrapperEl;\n            this.removeListeners();\n            wrapper.removeChild(this.upperCanvasEl);\n            wrapper.removeChild(this.lowerCanvasEl);\n            this.contextCache = null;\n            this.contextTop = null;\n            [\n                \"upperCanvasEl\",\n                \"cacheCanvasEl\"\n            ].forEach((function(element) {\n                fabric.util.cleanUpJsdomNode(this[element]);\n                this[element] = undefined;\n            }).bind(this));\n            if (wrapper.parentNode) {\n                wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);\n            }\n            delete this.wrapperEl;\n            fabric.StaticCanvas.prototype.dispose.call(this);\n            return this;\n        },\n        /**\n     * Clears all contexts (background, main, top) of an instance\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ clear: function() {\n            // this.discardActiveGroup();\n            this.discardActiveObject();\n            this.clearContext(this.contextTop);\n            return this.callSuper(\"clear\");\n        },\n        /**\n     * Draws objects' controls (borders/controls)\n     * @param {CanvasRenderingContext2D} ctx Context to render controls on\n     */ drawControls: function(ctx) {\n            var activeObject = this._activeObject;\n            if (activeObject) {\n                activeObject._renderControls(ctx);\n            }\n        },\n        /**\n     * @private\n     */ _toObject: function(instance, methodName, propertiesToInclude) {\n            //If the object is part of the current selection group, it should\n            //be transformed appropriately\n            //i.e. it should be serialised as it would appear if the selection group\n            //were to be destroyed.\n            var originalProperties = this._realizeGroupTransformOnObject(instance), object = this.callSuper(\"_toObject\", instance, methodName, propertiesToInclude);\n            //Undo the damage we did by changing all of its properties\n            this._unwindGroupTransformOnObject(instance, originalProperties);\n            return object;\n        },\n        /**\n     * Realises an object's group transformation on it\n     * @private\n     * @param {fabric.Object} [instance] the object to transform (gets mutated)\n     * @returns the original values of instance which were changed\n     */ _realizeGroupTransformOnObject: function(instance) {\n            if (instance.group && instance.group.type === \"activeSelection\" && this._activeObject === instance.group) {\n                var layoutProps = [\n                    \"angle\",\n                    \"flipX\",\n                    \"flipY\",\n                    \"left\",\n                    \"scaleX\",\n                    \"scaleY\",\n                    \"skewX\",\n                    \"skewY\",\n                    \"top\"\n                ];\n                //Copy all the positionally relevant properties across now\n                var originalValues = {};\n                layoutProps.forEach(function(prop) {\n                    originalValues[prop] = instance[prop];\n                });\n                fabric.util.addTransformToObject(instance, this._activeObject.calcOwnMatrix());\n                return originalValues;\n            } else {\n                return null;\n            }\n        },\n        /**\n     * Restores the changed properties of instance\n     * @private\n     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)\n     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject\n     */ _unwindGroupTransformOnObject: function(instance, originalValues) {\n            if (originalValues) {\n                instance.set(originalValues);\n            }\n        },\n        /**\n     * @private\n     */ _setSVGObject: function(markup, instance, reviver) {\n            //If the object is in a selection group, simulate what would happen to that\n            //object when the group is deselected\n            var originalProperties = this._realizeGroupTransformOnObject(instance);\n            this.callSuper(\"_setSVGObject\", markup, instance, reviver);\n            this._unwindGroupTransformOnObject(instance, originalProperties);\n        },\n        setViewportTransform: function(vpt) {\n            if (this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing) {\n                this._activeObject.clearContextTop();\n            }\n            fabric.StaticCanvas.prototype.setViewportTransform.call(this, vpt);\n        }\n    });\n    // copying static properties manually to work around Opera's bug,\n    // where \"prototype\" property is enumerable and overrides existing prototype\n    for(var prop in fabric.StaticCanvas){\n        if (prop !== \"prototype\") {\n            fabric.Canvas[prop] = fabric.StaticCanvas[prop];\n        }\n    }\n})();\n(function() {\n    var addListener = fabric.util.addListener, removeListener = fabric.util.removeListener, RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1, addEventOptions = {\n        passive: false\n    };\n    function checkClick(e, value) {\n        return e.button && e.button === value - 1;\n    }\n    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\n        /**\n     * Contains the id of the touch event that owns the fabric transform\n     * @type Number\n     * @private\n     */ mainTouchId: null,\n        /**\n     * Adds mouse listeners to canvas\n     * @private\n     */ _initEventListeners: function() {\n            // in case we initialized the class twice. This should not happen normally\n            // but in some kind of applications where the canvas element may be changed\n            // this is a workaround to having double listeners.\n            this.removeListeners();\n            this._bindEvents();\n            this.addOrRemove(addListener, \"add\");\n        },\n        /**\n     * return an event prefix pointer or mouse.\n     * @private\n     */ _getEventPrefix: function() {\n            return this.enablePointerEvents ? \"pointer\" : \"mouse\";\n        },\n        addOrRemove: function(functor, eventjsFunctor) {\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            functor(fabric.window, \"resize\", this._onResize);\n            functor(canvasElement, eventTypePrefix + \"down\", this._onMouseDown);\n            functor(canvasElement, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            functor(canvasElement, eventTypePrefix + \"out\", this._onMouseOut);\n            functor(canvasElement, eventTypePrefix + \"enter\", this._onMouseEnter);\n            functor(canvasElement, \"wheel\", this._onMouseWheel);\n            functor(canvasElement, \"contextmenu\", this._onContextMenu);\n            functor(canvasElement, \"dblclick\", this._onDoubleClick);\n            functor(canvasElement, \"dragover\", this._onDragOver);\n            functor(canvasElement, \"dragenter\", this._onDragEnter);\n            functor(canvasElement, \"dragleave\", this._onDragLeave);\n            functor(canvasElement, \"drop\", this._onDrop);\n            if (!this.enablePointerEvents) {\n                functor(canvasElement, \"touchstart\", this._onTouchStart, addEventOptions);\n            }\n            if (typeof eventjs !== \"undefined\" && eventjsFunctor in eventjs) {\n                eventjs[eventjsFunctor](canvasElement, \"gesture\", this._onGesture);\n                eventjs[eventjsFunctor](canvasElement, \"drag\", this._onDrag);\n                eventjs[eventjsFunctor](canvasElement, \"orientation\", this._onOrientationChange);\n                eventjs[eventjsFunctor](canvasElement, \"shake\", this._onShake);\n                eventjs[eventjsFunctor](canvasElement, \"longpress\", this._onLongPress);\n            }\n        },\n        /**\n     * Removes all event listeners\n     */ removeListeners: function() {\n            this.addOrRemove(removeListener, \"remove\");\n            // if you dispose on a mouseDown, before mouse up, you need to clean document to...\n            var eventTypePrefix = this._getEventPrefix();\n            removeListener(fabric.document, eventTypePrefix + \"up\", this._onMouseUp);\n            removeListener(fabric.document, \"touchend\", this._onTouchEnd, addEventOptions);\n            removeListener(fabric.document, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            removeListener(fabric.document, \"touchmove\", this._onMouseMove, addEventOptions);\n        },\n        /**\n     * @private\n     */ _bindEvents: function() {\n            if (this.eventsBound) {\n                // for any reason we pass here twice we do not want to bind events twice.\n                return;\n            }\n            this._onMouseDown = this._onMouseDown.bind(this);\n            this._onTouchStart = this._onTouchStart.bind(this);\n            this._onMouseMove = this._onMouseMove.bind(this);\n            this._onMouseUp = this._onMouseUp.bind(this);\n            this._onTouchEnd = this._onTouchEnd.bind(this);\n            this._onResize = this._onResize.bind(this);\n            this._onGesture = this._onGesture.bind(this);\n            this._onDrag = this._onDrag.bind(this);\n            this._onShake = this._onShake.bind(this);\n            this._onLongPress = this._onLongPress.bind(this);\n            this._onOrientationChange = this._onOrientationChange.bind(this);\n            this._onMouseWheel = this._onMouseWheel.bind(this);\n            this._onMouseOut = this._onMouseOut.bind(this);\n            this._onMouseEnter = this._onMouseEnter.bind(this);\n            this._onContextMenu = this._onContextMenu.bind(this);\n            this._onDoubleClick = this._onDoubleClick.bind(this);\n            this._onDragOver = this._onDragOver.bind(this);\n            this._onDragEnter = this._simpleEventHandler.bind(this, \"dragenter\");\n            this._onDragLeave = this._simpleEventHandler.bind(this, \"dragleave\");\n            this._onDrop = this._onDrop.bind(this);\n            this.eventsBound = true;\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js gesture\n     * @param {Event} [self] Inner Event object\n     */ _onGesture: function(e, self) {\n            this.__onTransformGesture && this.__onTransformGesture(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js drag\n     * @param {Event} [self] Inner Event object\n     */ _onDrag: function(e, self) {\n            this.__onDrag && this.__onDrag(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on wheel event\n     */ _onMouseWheel: function(e) {\n            this.__onMouseWheel(e);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onMouseOut: function(e) {\n            var target = this._hoveredTarget;\n            this.fire(\"mouse:out\", {\n                target: target,\n                e: e\n            });\n            this._hoveredTarget = null;\n            target && target.fire(\"mouseout\", {\n                e: e\n            });\n            var _this = this;\n            this._hoveredTargets.forEach(function(_target) {\n                _this.fire(\"mouse:out\", {\n                    target: target,\n                    e: e\n                });\n                _target && target.fire(\"mouseout\", {\n                    e: e\n                });\n            });\n            this._hoveredTargets = [];\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mouseenter\n     */ _onMouseEnter: function(e) {\n            // This find target and consequent 'mouse:over' is used to\n            // clear old instances on hovered target.\n            // calling findTarget has the side effect of killing target.__corner.\n            // as a short term fix we are not firing this if we are currently transforming.\n            // as a long term fix we need to separate the action of finding a target with the\n            // side effects we added to it.\n            if (!this._currentTransform && !this.findTarget(e)) {\n                this.fire(\"mouse:over\", {\n                    target: null,\n                    e: e\n                });\n                this._hoveredTarget = null;\n                this._hoveredTargets = [];\n            }\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js orientation change\n     * @param {Event} [self] Inner Event object\n     */ _onOrientationChange: function(e, self) {\n            this.__onOrientationChange && this.__onOrientationChange(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     * @param {Event} [self] Inner Event object\n     */ _onShake: function(e, self) {\n            this.__onShake && this.__onShake(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     * @param {Event} [self] Inner Event object\n     */ _onLongPress: function(e, self) {\n            this.__onLongPress && this.__onLongPress(e, self);\n        },\n        /**\n     * prevent default to allow drop event to be fired\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     */ _onDragOver: function(e) {\n            e.preventDefault();\n            var target = this._simpleEventHandler(\"dragover\", e);\n            this._fireEnterLeaveEvents(target, e);\n        },\n        /**\n     * `drop:before` is a an event that allow you to schedule logic\n     * before the `drop` event. Prefer `drop` event always, but if you need\n     * to run some drop-disabling logic on an event, since there is no way\n     * to handle event handlers ordering, use `drop:before`\n     * @param {Event} e\n     */ _onDrop: function(e) {\n            this._simpleEventHandler(\"drop:before\", e);\n            return this._simpleEventHandler(\"drop\", e);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onContextMenu: function(e) {\n            if (this.stopContextMenu) {\n                e.stopPropagation();\n                e.preventDefault();\n            }\n            return false;\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onDoubleClick: function(e) {\n            this._cacheTransformEventData(e);\n            this._handleEvent(e, \"dblclick\");\n            this._resetTransformEventData(e);\n        },\n        /**\n     * Return a the id of an event.\n     * returns either the pointerId or the identifier or 0 for the mouse event\n     * @private\n     * @param {Event} evt Event object\n     */ getPointerId: function(evt) {\n            var changedTouches = evt.changedTouches;\n            if (changedTouches) {\n                return changedTouches[0] && changedTouches[0].identifier;\n            }\n            if (this.enablePointerEvents) {\n                return evt.pointerId;\n            }\n            return -1;\n        },\n        /**\n     * Determines if an event has the id of the event that is considered main\n     * @private\n     * @param {evt} event Event object\n     */ _isMainEvent: function(evt) {\n            if (evt.isPrimary === true) {\n                return true;\n            }\n            if (evt.isPrimary === false) {\n                return false;\n            }\n            if (evt.type === \"touchend\" && evt.touches.length === 0) {\n                return true;\n            }\n            if (evt.changedTouches) {\n                return evt.changedTouches[0].identifier === this.mainTouchId;\n            }\n            return true;\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onTouchStart: function(e) {\n            e.preventDefault();\n            if (this.mainTouchId === null) {\n                this.mainTouchId = this.getPointerId(e);\n            }\n            this.__onMouseDown(e);\n            this._resetTransformEventData();\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            addListener(fabric.document, \"touchend\", this._onTouchEnd, addEventOptions);\n            addListener(fabric.document, \"touchmove\", this._onMouseMove, addEventOptions);\n            // Unbind mousedown to prevent double triggers from touch devices\n            removeListener(canvasElement, eventTypePrefix + \"down\", this._onMouseDown);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onMouseDown: function(e) {\n            this.__onMouseDown(e);\n            this._resetTransformEventData();\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            removeListener(canvasElement, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            addListener(fabric.document, eventTypePrefix + \"up\", this._onMouseUp);\n            addListener(fabric.document, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onTouchEnd: function(e) {\n            if (e.touches.length > 0) {\n                // if there are still touches stop here\n                return;\n            }\n            this.__onMouseUp(e);\n            this._resetTransformEventData();\n            this.mainTouchId = null;\n            var eventTypePrefix = this._getEventPrefix();\n            removeListener(fabric.document, \"touchend\", this._onTouchEnd, addEventOptions);\n            removeListener(fabric.document, \"touchmove\", this._onMouseMove, addEventOptions);\n            var _this = this;\n            if (this._willAddMouseDown) {\n                clearTimeout(this._willAddMouseDown);\n            }\n            this._willAddMouseDown = setTimeout(function() {\n                // Wait 400ms before rebinding mousedown to prevent double triggers\n                // from touch devices\n                addListener(_this.upperCanvasEl, eventTypePrefix + \"down\", _this._onMouseDown);\n                _this._willAddMouseDown = 0;\n            }, 400);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */ _onMouseUp: function(e) {\n            this.__onMouseUp(e);\n            this._resetTransformEventData();\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            if (this._isMainEvent(e)) {\n                removeListener(fabric.document, eventTypePrefix + \"up\", this._onMouseUp);\n                removeListener(fabric.document, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n                addListener(canvasElement, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */ _onMouseMove: function(e) {\n            !this.allowTouchScrolling && e.preventDefault && e.preventDefault();\n            this.__onMouseMove(e);\n        },\n        /**\n     * @private\n     */ _onResize: function() {\n            this.calcOffset();\n        },\n        /**\n     * Decides whether the canvas should be redrawn in mouseup and mousedown events.\n     * @private\n     * @param {Object} target\n     */ _shouldRender: function(target) {\n            var activeObject = this._activeObject;\n            if (!!activeObject !== !!target || activeObject && target && activeObject !== target) {\n                // this covers: switch of target, from target to no target, selection of target\n                // multiSelection with key and mouse\n                return true;\n            } else if (activeObject && activeObject.isEditing) {\n                // if we mouse up/down over a editing textbox a cursor change,\n                // there is no need to re render\n                return false;\n            }\n            return false;\n        },\n        /**\n     * Method that defines the actions when mouse is released on canvas.\n     * The method resets the currentTransform parameters, store the image corner\n     * position in the image object and render the canvas on top.\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */ __onMouseUp: function(e) {\n            var target, transform = this._currentTransform, groupSelector = this._groupSelector, shouldRender = false, isClick = !groupSelector || groupSelector.left === 0 && groupSelector.top === 0;\n            this._cacheTransformEventData(e);\n            target = this._target;\n            this._handleEvent(e, \"up:before\");\n            // if right/middle click just fire events and return\n            // target undefined will make the _handleEvent search the target\n            if (checkClick(e, RIGHT_CLICK)) {\n                if (this.fireRightClick) {\n                    this._handleEvent(e, \"up\", RIGHT_CLICK, isClick);\n                }\n                return;\n            }\n            if (checkClick(e, MIDDLE_CLICK)) {\n                if (this.fireMiddleClick) {\n                    this._handleEvent(e, \"up\", MIDDLE_CLICK, isClick);\n                }\n                this._resetTransformEventData();\n                return;\n            }\n            if (this.isDrawingMode && this._isCurrentlyDrawing) {\n                this._onMouseUpInDrawingMode(e);\n                return;\n            }\n            if (!this._isMainEvent(e)) {\n                return;\n            }\n            if (transform) {\n                this._finalizeCurrentTransform(e);\n                shouldRender = transform.actionPerformed;\n            }\n            if (!isClick) {\n                var targetWasActive = target === this._activeObject;\n                this._maybeGroupObjects(e);\n                if (!shouldRender) {\n                    shouldRender = this._shouldRender(target) || !targetWasActive && target === this._activeObject;\n                }\n            }\n            var corner, pointer;\n            if (target) {\n                corner = target._findTargetCorner(this.getPointer(e, true), fabric.util.isTouchEvent(e));\n                if (target.selectable && target !== this._activeObject && target.activeOn === \"up\") {\n                    this.setActiveObject(target, e);\n                    shouldRender = true;\n                } else {\n                    var control = target.controls[corner], mouseUpHandler = control && control.getMouseUpHandler(e, target, control);\n                    if (mouseUpHandler) {\n                        pointer = this.getPointer(e);\n                        mouseUpHandler(e, transform, pointer.x, pointer.y);\n                    }\n                }\n                target.isMoving = false;\n            }\n            // if we are ending up a transform on a different control or a new object\n            // fire the original mouse up from the corner that started the transform\n            if (transform && (transform.target !== target || transform.corner !== corner)) {\n                var originalControl = transform.target && transform.target.controls[transform.corner], originalMouseUpHandler = originalControl && originalControl.getMouseUpHandler(e, target, control);\n                pointer = pointer || this.getPointer(e);\n                originalMouseUpHandler && originalMouseUpHandler(e, transform, pointer.x, pointer.y);\n            }\n            this._setCursorFromEvent(e, target);\n            this._handleEvent(e, \"up\", LEFT_CLICK, isClick);\n            this._groupSelector = null;\n            this._currentTransform = null;\n            // reset the target information about which corner is selected\n            target && (target.__corner = 0);\n            if (shouldRender) {\n                this.requestRenderAll();\n            } else if (!isClick) {\n                this.renderTop();\n            }\n        },\n        /**\n     * @private\n     * Handle event firing for target and subtargets\n     * @param {Event} e event from mouse\n     * @param {String} eventType event to fire (up, down or move)\n     * @return {Fabric.Object} target return the the target found, for internal reasons.\n     */ _simpleEventHandler: function(eventType, e) {\n            var target = this.findTarget(e), targets = this.targets, options = {\n                e: e,\n                target: target,\n                subTargets: targets\n            };\n            this.fire(eventType, options);\n            target && target.fire(eventType, options);\n            if (!targets) {\n                return target;\n            }\n            for(var i = 0; i < targets.length; i++){\n                targets[i].fire(eventType, options);\n            }\n            return target;\n        },\n        /**\n     * @private\n     * Handle event firing for target and subtargets\n     * @param {Event} e event from mouse\n     * @param {String} eventType event to fire (up, down or move)\n     * @param {fabric.Object} targetObj receiving event\n     * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right\n     * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.\n     */ _handleEvent: function(e, eventType, button, isClick) {\n            var target = this._target, targets = this.targets || [], options = {\n                e: e,\n                target: target,\n                subTargets: targets,\n                button: button || LEFT_CLICK,\n                isClick: isClick || false,\n                pointer: this._pointer,\n                absolutePointer: this._absolutePointer,\n                transform: this._currentTransform\n            };\n            if (eventType === \"up\") {\n                options.currentTarget = this.findTarget(e);\n                options.currentSubTargets = this.targets;\n            }\n            this.fire(\"mouse:\" + eventType, options);\n            target && target.fire(\"mouse\" + eventType, options);\n            for(var i = 0; i < targets.length; i++){\n                targets[i].fire(\"mouse\" + eventType, options);\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event\n     */ _finalizeCurrentTransform: function(e) {\n            var transform = this._currentTransform, target = transform.target, options = {\n                e: e,\n                target: target,\n                transform: transform,\n                action: transform.action\n            };\n            if (target._scaling) {\n                target._scaling = false;\n            }\n            target.setCoords();\n            if (transform.actionPerformed || this.stateful && target.hasStateChanged()) {\n                this._fire(\"modified\", options);\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onMouseDownInDrawingMode: function(e) {\n            this._isCurrentlyDrawing = true;\n            if (this.getActiveObject()) {\n                this.discardActiveObject(e).requestRenderAll();\n            }\n            var pointer = this.getPointer(e);\n            this.freeDrawingBrush.onMouseDown(pointer, {\n                e: e,\n                pointer: pointer\n            });\n            this._handleEvent(e, \"down\");\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */ _onMouseMoveInDrawingMode: function(e) {\n            if (this._isCurrentlyDrawing) {\n                var pointer = this.getPointer(e);\n                this.freeDrawingBrush.onMouseMove(pointer, {\n                    e: e,\n                    pointer: pointer\n                });\n            }\n            this.setCursor(this.freeDrawingCursor);\n            this._handleEvent(e, \"move\");\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */ _onMouseUpInDrawingMode: function(e) {\n            var pointer = this.getPointer(e);\n            this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({\n                e: e,\n                pointer: pointer\n            });\n            this._handleEvent(e, \"up\");\n        },\n        /**\n     * Method that defines the actions when mouse is clicked on canvas.\n     * The method inits the currentTransform parameters and renders all the\n     * canvas so the current image can be placed on the top canvas and the rest\n     * in on the container one.\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ __onMouseDown: function(e) {\n            this._cacheTransformEventData(e);\n            this._handleEvent(e, \"down:before\");\n            var target = this._target;\n            // if right click just fire events\n            if (checkClick(e, RIGHT_CLICK)) {\n                if (this.fireRightClick) {\n                    this._handleEvent(e, \"down\", RIGHT_CLICK);\n                }\n                return;\n            }\n            if (checkClick(e, MIDDLE_CLICK)) {\n                if (this.fireMiddleClick) {\n                    this._handleEvent(e, \"down\", MIDDLE_CLICK);\n                }\n                return;\n            }\n            if (this.isDrawingMode) {\n                this._onMouseDownInDrawingMode(e);\n                return;\n            }\n            if (!this._isMainEvent(e)) {\n                return;\n            }\n            // ignore if some object is being transformed at this moment\n            if (this._currentTransform) {\n                return;\n            }\n            var pointer = this._pointer;\n            // save pointer for check in __onMouseUp event\n            this._previousPointer = pointer;\n            var shouldRender = this._shouldRender(target), shouldGroup = this._shouldGroup(e, target);\n            if (this._shouldClearSelection(e, target)) {\n                this.discardActiveObject(e);\n            } else if (shouldGroup) {\n                this._handleGrouping(e, target);\n                target = this._activeObject;\n            }\n            if (this.selection && (!target || !target.selectable && !target.isEditing && target !== this._activeObject)) {\n                this._groupSelector = {\n                    ex: this._absolutePointer.x,\n                    ey: this._absolutePointer.y,\n                    top: 0,\n                    left: 0\n                };\n            }\n            if (target) {\n                var alreadySelected = target === this._activeObject;\n                if (target.selectable && target.activeOn === \"down\") {\n                    this.setActiveObject(target, e);\n                }\n                var corner = target._findTargetCorner(this.getPointer(e, true), fabric.util.isTouchEvent(e));\n                target.__corner = corner;\n                if (target === this._activeObject && (corner || !shouldGroup)) {\n                    this._setupCurrentTransform(e, target, alreadySelected);\n                    var control = target.controls[corner], pointer = this.getPointer(e), mouseDownHandler = control && control.getMouseDownHandler(e, target, control);\n                    if (mouseDownHandler) {\n                        mouseDownHandler(e, this._currentTransform, pointer.x, pointer.y);\n                    }\n                }\n            }\n            this._handleEvent(e, \"down\");\n            // we must renderAll so that we update the visuals\n            (shouldRender || shouldGroup) && this.requestRenderAll();\n        },\n        /**\n     * reset cache form common information needed during event processing\n     * @private\n     */ _resetTransformEventData: function() {\n            this._target = null;\n            this._pointer = null;\n            this._absolutePointer = null;\n        },\n        /**\n     * Cache common information needed during event processing\n     * @private\n     * @param {Event} e Event object fired on event\n     */ _cacheTransformEventData: function(e) {\n            // reset in order to avoid stale caching\n            this._resetTransformEventData();\n            this._pointer = this.getPointer(e, true);\n            this._absolutePointer = this.restorePointerVpt(this._pointer);\n            this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e) || null;\n        },\n        /**\n     * @private\n     */ _beforeTransform: function(e) {\n            var t = this._currentTransform;\n            this.stateful && t.target.saveState();\n            this.fire(\"before:transform\", {\n                e: e,\n                transform: t\n            });\n        },\n        /**\n     * Method that defines the actions when mouse is hovering the canvas.\n     * The currentTransform parameter will define whether the user is rotating/scaling/translating\n     * an image or neither of them (only hovering). A group selection is also possible and would cancel\n     * all any other type of action.\n     * In case of an image transformation only the top canvas will be rendered.\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */ __onMouseMove: function(e) {\n            this._handleEvent(e, \"move:before\");\n            this._cacheTransformEventData(e);\n            var target, pointer;\n            if (this.isDrawingMode) {\n                this._onMouseMoveInDrawingMode(e);\n                return;\n            }\n            if (!this._isMainEvent(e)) {\n                return;\n            }\n            var groupSelector = this._groupSelector;\n            // We initially clicked in an empty area, so we draw a box for multiple selection\n            if (groupSelector) {\n                pointer = this._absolutePointer;\n                groupSelector.left = pointer.x - groupSelector.ex;\n                groupSelector.top = pointer.y - groupSelector.ey;\n                this.renderTop();\n            } else if (!this._currentTransform) {\n                target = this.findTarget(e) || null;\n                this._setCursorFromEvent(e, target);\n                this._fireOverOutEvents(target, e);\n            } else {\n                this._transformObject(e);\n            }\n            this._handleEvent(e, \"move\");\n            this._resetTransformEventData();\n        },\n        /**\n     * Manage the mouseout, mouseover events for the fabric object on the canvas\n     * @param {Fabric.Object} target the target where the target from the mousemove event\n     * @param {Event} e Event object fired on mousemove\n     * @private\n     */ _fireOverOutEvents: function(target, e) {\n            var _hoveredTarget = this._hoveredTarget, _hoveredTargets = this._hoveredTargets, targets = this.targets, length = Math.max(_hoveredTargets.length, targets.length);\n            this.fireSyntheticInOutEvents(target, e, {\n                oldTarget: _hoveredTarget,\n                evtOut: \"mouseout\",\n                canvasEvtOut: \"mouse:out\",\n                evtIn: \"mouseover\",\n                canvasEvtIn: \"mouse:over\"\n            });\n            for(var i = 0; i < length; i++){\n                this.fireSyntheticInOutEvents(targets[i], e, {\n                    oldTarget: _hoveredTargets[i],\n                    evtOut: \"mouseout\",\n                    evtIn: \"mouseover\"\n                });\n            }\n            this._hoveredTarget = target;\n            this._hoveredTargets = this.targets.concat();\n        },\n        /**\n     * Manage the dragEnter, dragLeave events for the fabric objects on the canvas\n     * @param {Fabric.Object} target the target where the target from the onDrag event\n     * @param {Event} e Event object fired on ondrag\n     * @private\n     */ _fireEnterLeaveEvents: function(target, e) {\n            var _draggedoverTarget = this._draggedoverTarget, _hoveredTargets = this._hoveredTargets, targets = this.targets, length = Math.max(_hoveredTargets.length, targets.length);\n            this.fireSyntheticInOutEvents(target, e, {\n                oldTarget: _draggedoverTarget,\n                evtOut: \"dragleave\",\n                evtIn: \"dragenter\"\n            });\n            for(var i = 0; i < length; i++){\n                this.fireSyntheticInOutEvents(targets[i], e, {\n                    oldTarget: _hoveredTargets[i],\n                    evtOut: \"dragleave\",\n                    evtIn: \"dragenter\"\n                });\n            }\n            this._draggedoverTarget = target;\n        },\n        /**\n     * Manage the synthetic in/out events for the fabric objects on the canvas\n     * @param {Fabric.Object} target the target where the target from the supported events\n     * @param {Event} e Event object fired\n     * @param {Object} config configuration for the function to work\n     * @param {String} config.targetName property on the canvas where the old target is stored\n     * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out\n     * @param {String} config.evtOut name of the event to fire for out\n     * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in\n     * @param {String} config.evtIn name of the event to fire for in\n     * @private\n     */ fireSyntheticInOutEvents: function(target, e, config) {\n            var inOpt, outOpt, oldTarget = config.oldTarget, outFires, inFires, targetChanged = oldTarget !== target, canvasEvtIn = config.canvasEvtIn, canvasEvtOut = config.canvasEvtOut;\n            if (targetChanged) {\n                inOpt = {\n                    e: e,\n                    target: target,\n                    previousTarget: oldTarget\n                };\n                outOpt = {\n                    e: e,\n                    target: oldTarget,\n                    nextTarget: target\n                };\n            }\n            inFires = target && targetChanged;\n            outFires = oldTarget && targetChanged;\n            if (outFires) {\n                canvasEvtOut && this.fire(canvasEvtOut, outOpt);\n                oldTarget.fire(config.evtOut, outOpt);\n            }\n            if (inFires) {\n                canvasEvtIn && this.fire(canvasEvtIn, inOpt);\n                target.fire(config.evtIn, inOpt);\n            }\n        },\n        /**\n     * Method that defines actions when an Event Mouse Wheel\n     * @param {Event} e Event object fired on mouseup\n     */ __onMouseWheel: function(e) {\n            this._cacheTransformEventData(e);\n            this._handleEvent(e, \"wheel\");\n            this._resetTransformEventData();\n        },\n        /**\n     * @private\n     * @param {Event} e Event fired on mousemove\n     */ _transformObject: function(e) {\n            var pointer = this.getPointer(e), transform = this._currentTransform;\n            transform.reset = false;\n            transform.shiftKey = e.shiftKey;\n            transform.altKey = e[this.centeredKey];\n            this._performTransformAction(e, transform, pointer);\n            transform.actionPerformed && this.requestRenderAll();\n        },\n        /**\n     * @private\n     */ _performTransformAction: function(e, transform, pointer) {\n            var x = pointer.x, y = pointer.y, action = transform.action, actionPerformed = false, actionHandler = transform.actionHandler;\n            // this object could be created from the function in the control handlers\n            if (actionHandler) {\n                actionPerformed = actionHandler(e, transform, x, y);\n            }\n            if (action === \"drag\" && actionPerformed) {\n                transform.target.isMoving = true;\n                this.setCursor(transform.target.moveCursor || this.moveCursor);\n            }\n            transform.actionPerformed = transform.actionPerformed || actionPerformed;\n        },\n        /**\n     * @private\n     */ _fire: fabric.controlsUtils.fireEvent,\n        /**\n     * Sets the cursor depending on where the canvas is being hovered.\n     * Note: very buggy in Opera\n     * @param {Event} e Event object\n     * @param {Object} target Object that the mouse is hovering, if so.\n     */ _setCursorFromEvent: function(e, target) {\n            if (!target) {\n                this.setCursor(this.defaultCursor);\n                return false;\n            }\n            var hoverCursor = target.hoverCursor || this.hoverCursor, activeSelection = this._activeObject && this._activeObject.type === \"activeSelection\" ? this._activeObject : null, // only show proper corner when group selection is not active\n            corner = (!activeSelection || !activeSelection.contains(target)) && target._findTargetCorner(this.getPointer(e, true));\n            if (!corner) {\n                if (target.subTargetCheck) {\n                    // hoverCursor should come from top-most subTarget,\n                    // so we walk the array backwards\n                    this.targets.concat().reverse().map(function(_target) {\n                        hoverCursor = _target.hoverCursor || hoverCursor;\n                    });\n                }\n                this.setCursor(hoverCursor);\n            } else {\n                this.setCursor(this.getCornerCursor(corner, target, e));\n            }\n        },\n        /**\n     * @private\n     */ getCornerCursor: function(corner, target, e) {\n            var control = target.controls[corner];\n            return control.cursorStyleHandler(e, control, target);\n        }\n    });\n})();\n(function() {\n    var min = Math.min, max = Math.max;\n    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     * @return {Boolean}\n     */ _shouldGroup: function(e, target) {\n            var activeObject = this._activeObject;\n            return activeObject && this._isSelectionKeyPressed(e) && target && target.selectable && this.selection && (activeObject !== target || activeObject.type === \"activeSelection\") && !target.onSelect({\n                e: e\n            });\n        },\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */ _handleGrouping: function(e, target) {\n            var activeObject = this._activeObject;\n            // avoid multi select when shift click on a corner\n            if (activeObject.__corner) {\n                return;\n            }\n            if (target === activeObject) {\n                // if it's a group, find target again, using activeGroup objects\n                target = this.findTarget(e, true);\n                // if even object is not found or we are on activeObjectCorner, bail out\n                if (!target || !target.selectable) {\n                    return;\n                }\n            }\n            if (activeObject && activeObject.type === \"activeSelection\") {\n                this._updateActiveSelection(target, e);\n            } else {\n                this._createActiveSelection(target, e);\n            }\n        },\n        /**\n     * @private\n     */ _updateActiveSelection: function(target, e) {\n            var activeSelection = this._activeObject, currentActiveObjects = activeSelection._objects.slice(0);\n            if (activeSelection.contains(target)) {\n                activeSelection.removeWithUpdate(target);\n                this._hoveredTarget = target;\n                this._hoveredTargets = this.targets.concat();\n                if (activeSelection.size() === 1) {\n                    // activate last remaining object\n                    this._setActiveObject(activeSelection.item(0), e);\n                }\n            } else {\n                activeSelection.addWithUpdate(target);\n                this._hoveredTarget = activeSelection;\n                this._hoveredTargets = this.targets.concat();\n            }\n            this._fireSelectionEvents(currentActiveObjects, e);\n        },\n        /**\n     * @private\n     */ _createActiveSelection: function(target, e) {\n            var currentActives = this.getActiveObjects(), group = this._createGroup(target);\n            this._hoveredTarget = group;\n            // ISSUE 4115: should we consider subTargets here?\n            // this._hoveredTargets = [];\n            // this._hoveredTargets = this.targets.concat();\n            this._setActiveObject(group, e);\n            this._fireSelectionEvents(currentActives, e);\n        },\n        /**\n     * @private\n     * @param {Object} target\n     */ _createGroup: function(target) {\n            var objects = this._objects, isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target), groupObjects = isActiveLower ? [\n                this._activeObject,\n                target\n            ] : [\n                target,\n                this._activeObject\n            ];\n            this._activeObject.isEditing && this._activeObject.exitEditing();\n            return new fabric.ActiveSelection(groupObjects, {\n                canvas: this\n            });\n        },\n        /**\n     * @private\n     * @param {Event} e mouse event\n     */ _groupSelectedObjects: function(e) {\n            var group = this._collectObjects(e), aGroup;\n            // do not create group for 1 element only\n            if (group.length === 1) {\n                this.setActiveObject(group[0], e);\n            } else if (group.length > 1) {\n                aGroup = new fabric.ActiveSelection(group.reverse(), {\n                    canvas: this\n                });\n                this.setActiveObject(aGroup, e);\n            }\n        },\n        /**\n     * @private\n     */ _collectObjects: function(e) {\n            var group = [], currentObject, x1 = this._groupSelector.ex, y1 = this._groupSelector.ey, x2 = x1 + this._groupSelector.left, y2 = y1 + this._groupSelector.top, selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)), selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)), allowIntersect = !this.selectionFullyContained, isClick = x1 === x2 && y1 === y2;\n            // we iterate reverse order to collect top first in case of click.\n            for(var i = this._objects.length; i--;){\n                currentObject = this._objects[i];\n                if (!currentObject || !currentObject.selectable || !currentObject.visible) {\n                    continue;\n                }\n                if (allowIntersect && currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2, true) || currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2, true) || allowIntersect && currentObject.containsPoint(selectionX1Y1, null, true) || allowIntersect && currentObject.containsPoint(selectionX2Y2, null, true)) {\n                    group.push(currentObject);\n                    // only add one object if it's a click\n                    if (isClick) {\n                        break;\n                    }\n                }\n            }\n            if (group.length > 1) {\n                group = group.filter(function(object) {\n                    return !object.onSelect({\n                        e: e\n                    });\n                });\n            }\n            return group;\n        },\n        /**\n     * @private\n     */ _maybeGroupObjects: function(e) {\n            if (this.selection && this._groupSelector) {\n                this._groupSelectedObjects(e);\n            }\n            this.setCursor(this.defaultCursor);\n            // clear selection and current transformation\n            this._groupSelector = null;\n        }\n    });\n})();\n(function() {\n    fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n        /**\n     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately\n     * @param {Object} [options] Options object\n     * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\n     * @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\n     * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}\n     * @example <caption>Generate jpeg dataURL with lower quality</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'jpeg',\n     *   quality: 0.8\n     * });\n     * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'png',\n     *   left: 100,\n     *   top: 100,\n     *   width: 200,\n     *   height: 200\n     * });\n     * @example <caption>Generate double scaled png dataURL</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'png',\n     *   multiplier: 2\n     * });\n     */ toDataURL: function(options) {\n            options || (options = {});\n            var format = options.format || \"png\", quality = options.quality || 1, multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? this.getRetinaScaling() : 1), canvasEl = this.toCanvasElement(multiplier, options);\n            return fabric.util.toDataURL(canvasEl, format, quality);\n        },\n        /**\n     * Create a new HTMLCanvas element painted with the current canvas content.\n     * No need to resize the actual one or repaint it.\n     * Will transfer object ownership to a new canvas, paint it, and set everything back.\n     * This is an intermediary step used to get to a dataUrl but also it is useful to\n     * create quick image copies of a canvas without passing for the dataUrl string\n     * @param {Number} [multiplier] a zoom factor.\n     * @param {Object} [cropping] Cropping informations\n     * @param {Number} [cropping.left] Cropping left offset.\n     * @param {Number} [cropping.top] Cropping top offset.\n     * @param {Number} [cropping.width] Cropping width.\n     * @param {Number} [cropping.height] Cropping height.\n     */ toCanvasElement: function(multiplier, cropping) {\n            multiplier = multiplier || 1;\n            cropping = cropping || {};\n            var scaledWidth = (cropping.width || this.width) * multiplier, scaledHeight = (cropping.height || this.height) * multiplier, zoom = this.getZoom(), originalWidth = this.width, originalHeight = this.height, newZoom = zoom * multiplier, vp = this.viewportTransform, translateX = (vp[4] - (cropping.left || 0)) * multiplier, translateY = (vp[5] - (cropping.top || 0)) * multiplier, originalInteractive = this.interactive, newVp = [\n                newZoom,\n                0,\n                0,\n                newZoom,\n                translateX,\n                translateY\n            ], originalRetina = this.enableRetinaScaling, canvasEl = fabric.util.createCanvasElement(), originalContextTop = this.contextTop;\n            canvasEl.width = scaledWidth;\n            canvasEl.height = scaledHeight;\n            this.contextTop = null;\n            this.enableRetinaScaling = false;\n            this.interactive = false;\n            this.viewportTransform = newVp;\n            this.width = scaledWidth;\n            this.height = scaledHeight;\n            this.calcViewportBoundaries();\n            this.renderCanvas(canvasEl.getContext(\"2d\"), this._objects);\n            this.viewportTransform = vp;\n            this.width = originalWidth;\n            this.height = originalHeight;\n            this.calcViewportBoundaries();\n            this.interactive = originalInteractive;\n            this.enableRetinaScaling = originalRetina;\n            this.contextTop = originalContextTop;\n            return canvasEl;\n        }\n    });\n})();\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n    /**\n   * Populates canvas with data from the specified JSON.\n   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}\n   * @param {String|Object} json JSON string or object\n   * @param {Function} callback Callback, invoked when json is parsed\n   *                            and corresponding objects (e.g: {@link fabric.Image})\n   *                            are initialized\n   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.\n   * @return {fabric.Canvas} instance\n   * @chainable\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}\n   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}\n   * @example <caption>loadFromJSON</caption>\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));\n   * @example <caption>loadFromJSON with reviver</caption>\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {\n   *   // `o` = json object\n   *   // `object` = fabric.Object instance\n   *   // ... do some stuff ...\n   * });\n   */ loadFromJSON: function(json, callback, reviver) {\n        if (!json) {\n            return;\n        }\n        // serialize if it wasn't already\n        var serialized = typeof json === \"string\" ? JSON.parse(json) : fabric.util.object.clone(json);\n        var _this = this, clipPath = serialized.clipPath, renderOnAddRemove = this.renderOnAddRemove;\n        this.renderOnAddRemove = false;\n        delete serialized.clipPath;\n        this._enlivenObjects(serialized.objects, function(enlivenedObjects) {\n            _this.clear();\n            _this._setBgOverlay(serialized, function() {\n                if (clipPath) {\n                    _this._enlivenObjects([\n                        clipPath\n                    ], function(enlivenedCanvasClip) {\n                        _this.clipPath = enlivenedCanvasClip[0];\n                        _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);\n                    });\n                } else {\n                    _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);\n                }\n            });\n        }, reviver);\n        return this;\n    },\n    /**\n   * @private\n   * @param {Object} serialized Object with background and overlay information\n   * @param {Array} restored canvas objects\n   * @param {Function} cached renderOnAddRemove callback\n   * @param {Function} callback Invoked after all background and overlay images/patterns loaded\n   */ __setupCanvas: function(serialized, enlivenedObjects, renderOnAddRemove, callback) {\n        var _this = this;\n        enlivenedObjects.forEach(function(obj, index) {\n            // we splice the array just in case some custom classes restored from JSON\n            // will add more object to canvas at canvas init.\n            _this.insertAt(obj, index);\n        });\n        this.renderOnAddRemove = renderOnAddRemove;\n        // remove parts i cannot set as options\n        delete serialized.objects;\n        delete serialized.backgroundImage;\n        delete serialized.overlayImage;\n        delete serialized.background;\n        delete serialized.overlay;\n        // this._initOptions does too many things to just\n        // call it. Normally loading an Object from JSON\n        // create the Object instance. Here the Canvas is\n        // already an instance and we are just loading things over it\n        this._setOptions(serialized);\n        this.renderAll();\n        callback && callback();\n    },\n    /**\n   * @private\n   * @param {Object} serialized Object with background and overlay information\n   * @param {Function} callback Invoked after all background and overlay images/patterns loaded\n   */ _setBgOverlay: function(serialized, callback) {\n        var loaded = {\n            backgroundColor: false,\n            overlayColor: false,\n            backgroundImage: false,\n            overlayImage: false\n        };\n        if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {\n            callback && callback();\n            return;\n        }\n        var cbIfLoaded = function() {\n            if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {\n                callback && callback();\n            }\n        };\n        this.__setBgOverlay(\"backgroundImage\", serialized.backgroundImage, loaded, cbIfLoaded);\n        this.__setBgOverlay(\"overlayImage\", serialized.overlayImage, loaded, cbIfLoaded);\n        this.__setBgOverlay(\"backgroundColor\", serialized.background, loaded, cbIfLoaded);\n        this.__setBgOverlay(\"overlayColor\", serialized.overlay, loaded, cbIfLoaded);\n    },\n    /**\n   * @private\n   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)\n   * @param {(Object|String)} value Value to set\n   * @param {Object} loaded Set loaded property to true if property is set\n   * @param {Object} callback Callback function to invoke after property is set\n   */ __setBgOverlay: function(property, value, loaded, callback) {\n        var _this = this;\n        if (!value) {\n            loaded[property] = true;\n            callback && callback();\n            return;\n        }\n        if (property === \"backgroundImage\" || property === \"overlayImage\") {\n            fabric.util.enlivenObjects([\n                value\n            ], function(enlivedObject) {\n                _this[property] = enlivedObject[0];\n                loaded[property] = true;\n                callback && callback();\n            });\n        } else {\n            this[\"set\" + fabric.util.string.capitalize(property, true)](value, function() {\n                loaded[property] = true;\n                callback && callback();\n            });\n        }\n    },\n    /**\n   * @private\n   * @param {Array} objects\n   * @param {Function} callback\n   * @param {Function} [reviver]\n   */ _enlivenObjects: function(objects, callback, reviver) {\n        if (!objects || objects.length === 0) {\n            callback && callback([]);\n            return;\n        }\n        fabric.util.enlivenObjects(objects, function(enlivenedObjects) {\n            callback && callback(enlivenedObjects);\n        }, null, reviver);\n    },\n    /**\n   * @private\n   * @param {String} format\n   * @param {Function} callback\n   */ _toDataURL: function(format, callback) {\n        this.clone(function(clone) {\n            callback(clone.toDataURL(format));\n        });\n    },\n    /**\n   * @private\n   * @param {String} format\n   * @param {Number} multiplier\n   * @param {Function} callback\n   */ _toDataURLWithMultiplier: function(format, multiplier, callback) {\n        this.clone(function(clone) {\n            callback(clone.toDataURLWithMultiplier(format, multiplier));\n        });\n    },\n    /**\n   * Clones canvas instance\n   * @param {Object} [callback] Receives cloned instance as a first argument\n   * @param {Array} [properties] Array of properties to include in the cloned canvas and children\n   */ clone: function(callback, properties) {\n        var data = JSON.stringify(this.toJSON(properties));\n        this.cloneWithoutData(function(clone) {\n            clone.loadFromJSON(data, function() {\n                callback && callback(clone);\n            });\n        });\n    },\n    /**\n   * Clones canvas instance without cloning existing data.\n   * This essentially copies canvas dimensions, clipping properties, etc.\n   * but leaves data empty (so that you can populate it with your own)\n   * @param {Object} [callback] Receives cloned instance as a first argument\n   */ cloneWithoutData: function(callback) {\n        var el = fabric.util.createCanvasElement();\n        el.width = this.width;\n        el.height = this.height;\n        var clone = new fabric.Canvas(el);\n        if (this.backgroundImage) {\n            clone.setBackgroundImage(this.backgroundImage.src, function() {\n                clone.renderAll();\n                callback && callback(clone);\n            });\n            clone.backgroundImageOpacity = this.backgroundImageOpacity;\n            clone.backgroundImageStretch = this.backgroundImageStretch;\n        } else {\n            callback && callback(clone);\n        }\n    }\n});\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, clone = fabric.util.object.clone, toFixed = fabric.util.toFixed, capitalize = fabric.util.string.capitalize, degreesToRadians = fabric.util.degreesToRadians, objectCaching = !fabric.isLikelyNode, ALIASING_LIMIT = 2;\n    if (fabric.Object) {\n        return;\n    }\n    /**\n   * Root object class from which all 2d shape classes inherit from\n   * @class fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}\n   * @see {@link fabric.Object#initialize} for constructor definition\n   *\n   * @fires added\n   * @fires removed\n   *\n   * @fires selected\n   * @fires deselected\n   * @fires modified\n   * @fires modified\n   * @fires moved\n   * @fires scaled\n   * @fires rotated\n   * @fires skewed\n   *\n   * @fires rotating\n   * @fires scaling\n   * @fires moving\n   * @fires skewing\n   *\n   * @fires mousedown\n   * @fires mouseup\n   * @fires mouseover\n   * @fires mouseout\n   * @fires mousewheel\n   * @fires mousedblclick\n   *\n   * @fires dragover\n   * @fires dragenter\n   * @fires dragleave\n   * @fires drop\n   */ fabric.Object = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.Object.prototype */ {\n        /**\n     * Type of an object (rect, circle, path, etc.).\n     * Note that this property is meant to be read-only and not meant to be modified.\n     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.\n     * @type String\n     * @default\n     */ type: \"object\",\n        /**\n     * Horizontal origin of transformation of an object (one of \"left\", \"right\", \"center\")\n     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups\n     * @type String\n     * @default\n     */ originX: \"left\",\n        /**\n     * Vertical origin of transformation of an object (one of \"top\", \"bottom\", \"center\")\n     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups\n     * @type String\n     * @default\n     */ originY: \"top\",\n        /**\n     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}\n     * @type Number\n     * @default\n     */ top: 0,\n        /**\n     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}\n     * @type Number\n     * @default\n     */ left: 0,\n        /**\n     * Object width\n     * @type Number\n     * @default\n     */ width: 0,\n        /**\n     * Object height\n     * @type Number\n     * @default\n     */ height: 0,\n        /**\n     * Object scale factor (horizontal)\n     * @type Number\n     * @default\n     */ scaleX: 1,\n        /**\n     * Object scale factor (vertical)\n     * @type Number\n     * @default\n     */ scaleY: 1,\n        /**\n     * When true, an object is rendered as flipped horizontally\n     * @type Boolean\n     * @default\n     */ flipX: false,\n        /**\n     * When true, an object is rendered as flipped vertically\n     * @type Boolean\n     * @default\n     */ flipY: false,\n        /**\n     * Opacity of an object\n     * @type Number\n     * @default\n     */ opacity: 1,\n        /**\n     * Angle of rotation of an object (in degrees)\n     * @type Number\n     * @default\n     */ angle: 0,\n        /**\n     * Angle of skew on x axes of an object (in degrees)\n     * @type Number\n     * @default\n     */ skewX: 0,\n        /**\n     * Angle of skew on y axes of an object (in degrees)\n     * @type Number\n     * @default\n     */ skewY: 0,\n        /**\n     * Size of object's controlling corners (in pixels)\n     * @type Number\n     * @default\n     */ cornerSize: 13,\n        /**\n     * Size of object's controlling corners when touch interaction is detected\n     * @type Number\n     * @default\n     */ touchCornerSize: 24,\n        /**\n     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)\n     * @type Boolean\n     * @default\n     */ transparentCorners: true,\n        /**\n     * Default cursor value used when hovering over this object on canvas\n     * @type String\n     * @default\n     */ hoverCursor: null,\n        /**\n     * Default cursor value used when moving this object on canvas\n     * @type String\n     * @default\n     */ moveCursor: null,\n        /**\n     * Padding between object and its controlling borders (in pixels)\n     * @type Number\n     * @default\n     */ padding: 0,\n        /**\n     * Color of controlling borders of an object (when it's active)\n     * @type String\n     * @default\n     */ borderColor: \"rgb(178,204,255)\",\n        /**\n     * Array specifying dash pattern of an object's borders (hasBorder must be true)\n     * @since 1.6.2\n     * @type Array\n     */ borderDashArray: null,\n        /**\n     * Color of controlling corners of an object (when it's active)\n     * @type String\n     * @default\n     */ cornerColor: \"rgb(178,204,255)\",\n        /**\n     * Color of controlling corners of an object (when it's active and transparentCorners false)\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ cornerStrokeColor: null,\n        /**\n     * Specify style of control, 'rect' or 'circle'\n     * @since 1.6.2\n     * @type String\n     */ cornerStyle: \"rect\",\n        /**\n     * Array specifying dash pattern of an object's control (hasBorder must be true)\n     * @since 1.6.2\n     * @type Array\n     */ cornerDashArray: null,\n        /**\n     * When true, this object will use center point as the origin of transformation\n     * when being scaled via the controls.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredScaling: false,\n        /**\n     * When true, this object will use center point as the origin of transformation\n     * when being rotated via the controls.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredRotation: true,\n        /**\n     * Color of object's fill\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */ fill: \"rgb(0,0,0)\",\n        /**\n     * Fill rule used to fill an object\n     * accepted values are nonzero, evenodd\n     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)\n     * @type String\n     * @default\n     */ fillRule: \"nonzero\",\n        /**\n     * Composite rule used for canvas globalCompositeOperation\n     * @type String\n     * @default\n     */ globalCompositeOperation: \"source-over\",\n        /**\n     * Background color of an object.\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */ backgroundColor: \"\",\n        /**\n     * Selection Background color of an object. colored layer behind the object when it is active.\n     * does not mix good with globalCompositeOperation methods.\n     * @type String\n     * @default\n     */ selectionBackgroundColor: \"\",\n        /**\n     * When defined, an object is rendered via stroke and this property specifies its color\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */ stroke: null,\n        /**\n     * Width of a stroke used to render this object\n     * @type Number\n     * @default\n     */ strokeWidth: 1,\n        /**\n     * Array specifying dash pattern of an object's stroke (stroke must be defined)\n     * @type Array\n     */ strokeDashArray: null,\n        /**\n     * Line offset of an object's stroke\n     * @type Number\n     * @default\n     */ strokeDashOffset: 0,\n        /**\n     * Line endings style of an object's stroke (one of \"butt\", \"round\", \"square\")\n     * @type String\n     * @default\n     */ strokeLineCap: \"butt\",\n        /**\n     * Corner style of an object's stroke (one of \"bevel\", \"round\", \"miter\")\n     * @type String\n     * @default\n     */ strokeLineJoin: \"miter\",\n        /**\n     * Maximum miter length (used for strokeLineJoin = \"miter\") of an object's stroke\n     * @type Number\n     * @default\n     */ strokeMiterLimit: 4,\n        /**\n     * Shadow object representing shadow of this shape\n     * @type fabric.Shadow\n     * @default\n     */ shadow: null,\n        /**\n     * Opacity of object's controlling borders when object is active and moving\n     * @type Number\n     * @default\n     */ borderOpacityWhenMoving: 0.4,\n        /**\n     * Scale factor of object's controlling borders\n     * bigger number will make a thicker border\n     * border is 1, so this is basically a border thickness\n     * since there is no way to change the border itself.\n     * @type Number\n     * @default\n     */ borderScaleFactor: 1,\n        /**\n     * Minimum allowed scale value of an object\n     * @type Number\n     * @default\n     */ minScaleLimit: 0,\n        /**\n     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).\n     * But events still fire on it.\n     * @type Boolean\n     * @default\n     */ selectable: true,\n        /**\n     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4\n     * @type Boolean\n     * @default\n     */ evented: true,\n        /**\n     * When set to `false`, an object is not rendered on canvas\n     * @type Boolean\n     * @default\n     */ visible: true,\n        /**\n     * When set to `false`, object's controls are not displayed and can not be used to manipulate object\n     * @type Boolean\n     * @default\n     */ hasControls: true,\n        /**\n     * When set to `false`, object's controlling borders are not rendered\n     * @type Boolean\n     * @default\n     */ hasBorders: true,\n        /**\n     * When set to `true`, objects are \"found\" on canvas on per-pixel basis rather than according to bounding box\n     * @type Boolean\n     * @default\n     */ perPixelTargetFind: false,\n        /**\n     * When `false`, default object's values are not included in its serialization\n     * @type Boolean\n     * @default\n     */ includeDefaultValues: true,\n        /**\n     * When `true`, object horizontal movement is locked\n     * @type Boolean\n     * @default\n     */ lockMovementX: false,\n        /**\n     * When `true`, object vertical movement is locked\n     * @type Boolean\n     * @default\n     */ lockMovementY: false,\n        /**\n     * When `true`, object rotation is locked\n     * @type Boolean\n     * @default\n     */ lockRotation: false,\n        /**\n     * When `true`, object horizontal scaling is locked\n     * @type Boolean\n     * @default\n     */ lockScalingX: false,\n        /**\n     * When `true`, object vertical scaling is locked\n     * @type Boolean\n     * @default\n     */ lockScalingY: false,\n        /**\n     * When `true`, object horizontal skewing is locked\n     * @type Boolean\n     * @default\n     */ lockSkewingX: false,\n        /**\n     * When `true`, object vertical skewing is locked\n     * @type Boolean\n     * @default\n     */ lockSkewingY: false,\n        /**\n     * When `true`, object cannot be flipped by scaling into negative values\n     * @type Boolean\n     * @default\n     */ lockScalingFlip: false,\n        /**\n     * When `true`, object is not exported in OBJECT/JSON\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */ excludeFromExport: false,\n        /**\n     * When `true`, object is cached on an additional canvas.\n     * When `false`, object is not cached unless necessary ( clipPath )\n     * default to true\n     * @since 1.7.0\n     * @type Boolean\n     * @default true\n     */ objectCaching: objectCaching,\n        /**\n     * When `true`, object properties are checked for cache invalidation. In some particular\n     * situation you may want this to be disabled ( spray brush, very big, groups)\n     * or if your application does not allow you to modify properties for groups child you want\n     * to disable it for groups.\n     * default to false\n     * since 1.7.0\n     * @type Boolean\n     * @default false\n     */ statefullCache: false,\n        /**\n     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled\n     * too much and will be redrawn with correct details at the end of scaling.\n     * this setting is performance and application dependant.\n     * default to true\n     * since 1.7.0\n     * @type Boolean\n     * @default true\n     */ noScaleCache: true,\n        /**\n     * When `false`, the stoke width will scale with the object.\n     * When `true`, the stroke will always match the exact pixel size entered for stroke width.\n     * this Property does not work on Text classes or drawing call that uses strokeText,fillText methods\n     * default to false\n     * @since 2.6.0\n     * @type Boolean\n     * @default false\n     * @type Boolean\n     * @default false\n     */ strokeUniform: false,\n        /**\n     * When set to `true`, object's cache will be rerendered next render call.\n     * since 1.7.0\n     * @type Boolean\n     * @default true\n     */ dirty: true,\n        /**\n     * keeps the value of the last hovered corner during mouse move.\n     * 0 is no corner, or 'mt', 'ml', 'mtr' etc..\n     * It should be private, but there is no harm in using it as\n     * a read-only property.\n     * @type number|string|any\n     * @default 0\n     */ __corner: 0,\n        /**\n     * Determines if the fill or the stroke is drawn first (one of \"fill\" or \"stroke\")\n     * @type String\n     * @default\n     */ paintFirst: \"fill\",\n        /**\n     * When 'down', object is set to active on mousedown/touchstart\n     * When 'up', object is set to active on mouseup/touchend\n     * Experimental. Let's see if this breaks anything before supporting officially\n     * @private\n     * since 4.4.0\n     * @type String\n     * @default 'down'\n     */ activeOn: \"down\",\n        /**\n     * List of properties to consider when checking if state\n     * of an object is changed (fabric.Object#hasStateChanged)\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: (\"top left width height scaleX scaleY flipX flipY originX originY transformMatrix \" + \"stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit \" + \"angle opacity fill globalCompositeOperation shadow visible backgroundColor \" + \"skewX skewY fillRule paintFirst clipPath strokeUniform\").split(\" \"),\n        /**\n     * List of properties to consider when checking if cache needs refresh\n     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single\n     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty\n     * and refreshed at the next render\n     * @type Array\n     */ cacheProperties: (\"fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform\" + \" strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath\").split(\" \"),\n        /**\n     * List of properties to consider for animating colors.\n     * @type Array\n     */ colorProperties: \"fill stroke backgroundColor\".split(\" \"),\n        /**\n     * a fabricObject that, without stroke define a clipping area with their shape. filled in black\n     * the clipPath object gets used when the object has rendered, and the context is placed in the center\n     * of the object cacheCanvas.\n     * If you want 0,0 of a clipPath to align with an object center, use clipPath.originX/Y to 'center'\n     * @type fabric.Object\n     */ clipPath: undefined,\n        /**\n     * Meaningful ONLY when the object is used as clipPath.\n     * if true, the clipPath will make the object clip to the outside of the clipPath\n     * since 2.4.0\n     * @type boolean\n     * @default false\n     */ inverted: false,\n        /**\n     * Meaningful ONLY when the object is used as clipPath.\n     * if true, the clipPath will have its top and left relative to canvas, and will\n     * not be influenced by the object transform. This will make the clipPath relative\n     * to the canvas, but clipping just a particular object.\n     * WARNING this is beta, this feature may change or be renamed.\n     * since 2.4.0\n     * @type boolean\n     * @default false\n     */ absolutePositioned: false,\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            if (options) {\n                this.setOptions(options);\n            }\n        },\n        /**\n     * Create a the canvas used to keep the cached copy of the object\n     * @private\n     */ _createCacheCanvas: function() {\n            this._cacheProperties = {};\n            this._cacheCanvas = fabric.util.createCanvasElement();\n            this._cacheContext = this._cacheCanvas.getContext(\"2d\");\n            this._updateCacheCanvas();\n            // if canvas gets created, is empty, so dirty.\n            this.dirty = true;\n        },\n        /**\n     * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal\n     * and each side do not cross fabric.cacheSideLimit\n     * those numbers are configurable so that you can get as much detail as you want\n     * making bargain with performances.\n     * @param {Object} dims\n     * @param {Object} dims.width width of canvas\n     * @param {Object} dims.height height of canvas\n     * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */ _limitCacheSize: function(dims) {\n            var perfLimitSizeTotal = fabric.perfLimitSizeTotal, width = dims.width, height = dims.height, max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit;\n            if (width <= max && height <= max && width * height <= perfLimitSizeTotal) {\n                if (width < min) {\n                    dims.width = min;\n                }\n                if (height < min) {\n                    dims.height = min;\n                }\n                return dims;\n            }\n            var ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal), capValue = fabric.util.capValue, x = capValue(min, limitedDims.x, max), y = capValue(min, limitedDims.y, max);\n            if (width > x) {\n                dims.zoomX /= width / x;\n                dims.width = x;\n                dims.capped = true;\n            }\n            if (height > y) {\n                dims.zoomY /= height / y;\n                dims.height = y;\n                dims.capped = true;\n            }\n            return dims;\n        },\n        /**\n     * Return the dimension and the zoom level needed to create a cache canvas\n     * big enough to host the object to be cached.\n     * @private\n     * @return {Object}.x width of object to be cached\n     * @return {Object}.y height of object to be cached\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */ _getCacheCanvasDimensions: function() {\n            var objectScale = this.getTotalObjectScaling(), // caculate dimensions without skewing\n            dim = this._getTransformedDimensions(0, 0), neededX = dim.x * objectScale.scaleX / this.scaleX, neededY = dim.y * objectScale.scaleY / this.scaleY;\n            return {\n                // for sure this ALIASING_LIMIT is slightly creating problem\n                // in situation in which the cache canvas gets an upper limit\n                // also objectScale contains already scaleX and scaleY\n                width: neededX + ALIASING_LIMIT,\n                height: neededY + ALIASING_LIMIT,\n                zoomX: objectScale.scaleX,\n                zoomY: objectScale.scaleY,\n                x: neededX,\n                y: neededY\n            };\n        },\n        /**\n     * Update width and height of the canvas for cache\n     * returns true or false if canvas needed resize.\n     * @private\n     * @return {Boolean} true if the canvas has been resized\n     */ _updateCacheCanvas: function() {\n            var targetCanvas = this.canvas;\n            if (this.noScaleCache && targetCanvas && targetCanvas._currentTransform) {\n                var target = targetCanvas._currentTransform.target, action = targetCanvas._currentTransform.action;\n                if (this === target && action.slice && action.slice(0, 5) === \"scale\") {\n                    return false;\n                }\n            }\n            var canvas = this._cacheCanvas, dims = this._limitCacheSize(this._getCacheCanvasDimensions()), minCacheSize = fabric.minCacheSideLimit, width = dims.width, height = dims.height, drawingWidth, drawingHeight, zoomX = dims.zoomX, zoomY = dims.zoomY, dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight, zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY, shouldRedraw = dimensionsChanged || zoomChanged, additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;\n            if (dimensionsChanged) {\n                var canvasWidth = this._cacheCanvas.width, canvasHeight = this._cacheCanvas.height, sizeGrowing = width > canvasWidth || height > canvasHeight, sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) && canvasWidth > minCacheSize && canvasHeight > minCacheSize;\n                shouldResizeCanvas = sizeGrowing || sizeShrinking;\n                if (sizeGrowing && !dims.capped && (width > minCacheSize || height > minCacheSize)) {\n                    additionalWidth = width * 0.1;\n                    additionalHeight = height * 0.1;\n                }\n            }\n            if (this instanceof fabric.Text && this.path) {\n                shouldRedraw = true;\n                shouldResizeCanvas = true;\n                additionalWidth += this.getHeightOfLine(0) * this.zoomX;\n                additionalHeight += this.getHeightOfLine(0) * this.zoomY;\n            }\n            if (shouldRedraw) {\n                if (shouldResizeCanvas) {\n                    canvas.width = Math.ceil(width + additionalWidth);\n                    canvas.height = Math.ceil(height + additionalHeight);\n                } else {\n                    this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);\n                    this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);\n                }\n                drawingWidth = dims.x / 2;\n                drawingHeight = dims.y / 2;\n                this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;\n                this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;\n                this.cacheWidth = width;\n                this.cacheHeight = height;\n                this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);\n                this._cacheContext.scale(zoomX, zoomY);\n                this.zoomX = zoomX;\n                this.zoomY = zoomY;\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Sets object's properties from options\n     * @param {Object} [options] Options object\n     */ setOptions: function(options) {\n            this._setOptions(options);\n            this._initGradient(options.fill, \"fill\");\n            this._initGradient(options.stroke, \"stroke\");\n            this._initPattern(options.fill, \"fill\");\n            this._initPattern(options.stroke, \"stroke\");\n        },\n        /**\n     * Transforms context when rendering an object\n     * @param {CanvasRenderingContext2D} ctx Context\n     */ transform: function(ctx) {\n            var needFullTransform = this.group && !this.group._transformDone || this.group && this.canvas && ctx === this.canvas.contextTop;\n            var m = this.calcTransformMatrix(!needFullTransform);\n            ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n        },\n        /**\n     * Returns an object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, object = {\n                type: this.type,\n                version: fabric.version,\n                originX: this.originX,\n                originY: this.originY,\n                left: toFixed(this.left, NUM_FRACTION_DIGITS),\n                top: toFixed(this.top, NUM_FRACTION_DIGITS),\n                width: toFixed(this.width, NUM_FRACTION_DIGITS),\n                height: toFixed(this.height, NUM_FRACTION_DIGITS),\n                fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill,\n                stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke,\n                strokeWidth: toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),\n                strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,\n                strokeLineCap: this.strokeLineCap,\n                strokeDashOffset: this.strokeDashOffset,\n                strokeLineJoin: this.strokeLineJoin,\n                strokeUniform: this.strokeUniform,\n                strokeMiterLimit: toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),\n                scaleX: toFixed(this.scaleX, NUM_FRACTION_DIGITS),\n                scaleY: toFixed(this.scaleY, NUM_FRACTION_DIGITS),\n                angle: toFixed(this.angle, NUM_FRACTION_DIGITS),\n                flipX: this.flipX,\n                flipY: this.flipY,\n                opacity: toFixed(this.opacity, NUM_FRACTION_DIGITS),\n                shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow,\n                visible: this.visible,\n                backgroundColor: this.backgroundColor,\n                fillRule: this.fillRule,\n                paintFirst: this.paintFirst,\n                globalCompositeOperation: this.globalCompositeOperation,\n                skewX: toFixed(this.skewX, NUM_FRACTION_DIGITS),\n                skewY: toFixed(this.skewY, NUM_FRACTION_DIGITS)\n            };\n            if (this.clipPath && !this.clipPath.excludeFromExport) {\n                object.clipPath = this.clipPath.toObject(propertiesToInclude);\n                object.clipPath.inverted = this.clipPath.inverted;\n                object.clipPath.absolutePositioned = this.clipPath.absolutePositioned;\n            }\n            fabric.util.populateWithProperties(this, object, propertiesToInclude);\n            if (!this.includeDefaultValues) {\n                object = this._removeDefaultValues(object);\n            }\n            return object;\n        },\n        /**\n     * Returns (dataless) object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            // will be overwritten by subclasses\n            return this.toObject(propertiesToInclude);\n        },\n        /**\n     * @private\n     * @param {Object} object\n     */ _removeDefaultValues: function(object) {\n            var prototype = fabric.util.getKlass(object.type).prototype, stateProperties = prototype.stateProperties;\n            stateProperties.forEach(function(prop) {\n                if (prop === \"left\" || prop === \"top\") {\n                    return;\n                }\n                if (object[prop] === prototype[prop]) {\n                    delete object[prop];\n                }\n                // basically a check for [] === []\n                if (Array.isArray(object[prop]) && Array.isArray(prototype[prop]) && object[prop].length === 0 && prototype[prop].length === 0) {\n                    delete object[prop];\n                }\n            });\n            return object;\n        },\n        /**\n     * Returns a string representation of an instance\n     * @return {String}\n     */ toString: function() {\n            return \"#<fabric.\" + capitalize(this.type) + \">\";\n        },\n        /**\n     * Return the object scale factor counting also the group scaling\n     * @return {Object} object with scaleX and scaleY properties\n     */ getObjectScaling: function() {\n            // if the object is a top level one, on the canvas, we go for simple aritmetic\n            // otherwise the complex method with angles will return approximations and decimals\n            // and will likely kill the cache when not needed\n            // https://github.com/fabricjs/fabric.js/issues/7157\n            if (!this.group) {\n                return {\n                    scaleX: this.scaleX,\n                    scaleY: this.scaleY\n                };\n            }\n            // if we are inside a group total zoom calculation is complex, we defer to generic matrices\n            var options = fabric.util.qrDecompose(this.calcTransformMatrix());\n            return {\n                scaleX: Math.abs(options.scaleX),\n                scaleY: Math.abs(options.scaleY)\n            };\n        },\n        /**\n     * Return the object scale factor counting also the group scaling, zoom and retina\n     * @return {Object} object with scaleX and scaleY properties\n     */ getTotalObjectScaling: function() {\n            var scale = this.getObjectScaling(), scaleX = scale.scaleX, scaleY = scale.scaleY;\n            if (this.canvas) {\n                var zoom = this.canvas.getZoom();\n                var retina = this.canvas.getRetinaScaling();\n                scaleX *= zoom * retina;\n                scaleY *= zoom * retina;\n            }\n            return {\n                scaleX: scaleX,\n                scaleY: scaleY\n            };\n        },\n        /**\n     * Return the object opacity counting also the group property\n     * @return {Number}\n     */ getObjectOpacity: function() {\n            var opacity = this.opacity;\n            if (this.group) {\n                opacity *= this.group.getObjectOpacity();\n            }\n            return opacity;\n        },\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Object} thisArg\n     */ _set: function(key, value) {\n            var shouldConstrainValue = key === \"scaleX\" || key === \"scaleY\", isChanged = this[key] !== value, groupNeedsUpdate = false;\n            if (shouldConstrainValue) {\n                value = this._constrainScale(value);\n            }\n            if (key === \"scaleX\" && value < 0) {\n                this.flipX = !this.flipX;\n                value *= -1;\n            } else if (key === \"scaleY\" && value < 0) {\n                this.flipY = !this.flipY;\n                value *= -1;\n            } else if (key === \"shadow\" && value && !(value instanceof fabric.Shadow)) {\n                value = new fabric.Shadow(value);\n            } else if (key === \"dirty\" && this.group) {\n                this.group.set(\"dirty\", value);\n            }\n            this[key] = value;\n            if (isChanged) {\n                groupNeedsUpdate = this.group && this.group.isOnACache();\n                if (this.cacheProperties.indexOf(key) > -1) {\n                    this.dirty = true;\n                    groupNeedsUpdate && this.group.set(\"dirty\", true);\n                } else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {\n                    this.group.set(\"dirty\", true);\n                }\n            }\n            return this;\n        },\n        /**\n     * This callback function is called by the parent group of an object every\n     * time a non-delegated property changes on the group. It is passed the key\n     * and value as parameters. Not adding in this function's signature to avoid\n     * Travis build error about unused variables.\n     */ setOnGroup: function() {\n        // implemented by sub-classes, as needed.\n        },\n        /**\n     * Retrieves viewportTransform from Object's canvas if possible\n     * @method getViewportTransform\n     * @memberOf fabric.Object.prototype\n     * @return {Array}\n     */ getViewportTransform: function() {\n            if (this.canvas && this.canvas.viewportTransform) {\n                return this.canvas.viewportTransform;\n            }\n            return fabric.iMatrix.concat();\n        },\n        /*\n     * @private\n     * return if the object would be visible in rendering\n     * @memberOf fabric.Object.prototype\n     * @return {Boolean}\n     */ isNotVisible: function() {\n            return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;\n        },\n        /**\n     * Renders an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ render: function(ctx) {\n            // do not render if width/height are zeros or object is not visible\n            if (this.isNotVisible()) {\n                return;\n            }\n            if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {\n                return;\n            }\n            ctx.save();\n            this._setupCompositeOperation(ctx);\n            this.drawSelectionBackground(ctx);\n            this.transform(ctx);\n            this._setOpacity(ctx);\n            this._setShadow(ctx, this);\n            if (this.shouldCache()) {\n                this.renderCache();\n                this.drawCacheOnCanvas(ctx);\n            } else {\n                this._removeCacheCanvas();\n                this.dirty = false;\n                this.drawObject(ctx);\n                if (this.objectCaching && this.statefullCache) {\n                    this.saveState({\n                        propertySet: \"cacheProperties\"\n                    });\n                }\n            }\n            ctx.restore();\n        },\n        renderCache: function(options) {\n            options = options || {};\n            if (!this._cacheCanvas || !this._cacheContext) {\n                this._createCacheCanvas();\n            }\n            if (this.isCacheDirty()) {\n                this.statefullCache && this.saveState({\n                    propertySet: \"cacheProperties\"\n                });\n                this.drawObject(this._cacheContext, options.forClipping);\n                this.dirty = false;\n            }\n        },\n        /**\n     * Remove cacheCanvas and its dimensions from the objects\n     */ _removeCacheCanvas: function() {\n            this._cacheCanvas = null;\n            this._cacheContext = null;\n            this.cacheWidth = 0;\n            this.cacheHeight = 0;\n        },\n        /**\n     * return true if the object will draw a stroke\n     * Does not consider text styles. This is just a shortcut used at rendering time\n     * We want it to be an approximation and be fast.\n     * wrote to avoid extra caching, it has to return true when stroke happens,\n     * can guess when it will not happen at 100% chance, does not matter if it misses\n     * some use case where the stroke is invisible.\n     * @since 3.0.0\n     * @returns Boolean\n     */ hasStroke: function() {\n            return this.stroke && this.stroke !== \"transparent\" && this.strokeWidth !== 0;\n        },\n        /**\n     * return true if the object will draw a fill\n     * Does not consider text styles. This is just a shortcut used at rendering time\n     * We want it to be an approximation and be fast.\n     * wrote to avoid extra caching, it has to return true when fill happens,\n     * can guess when it will not happen at 100% chance, does not matter if it misses\n     * some use case where the fill is invisible.\n     * @since 3.0.0\n     * @returns Boolean\n     */ hasFill: function() {\n            return this.fill && this.fill !== \"transparent\";\n        },\n        /**\n     * When set to `true`, force the object to have its own cache, even if it is inside a group\n     * it may be needed when your object behave in a particular way on the cache and always needs\n     * its own isolated canvas to render correctly.\n     * Created to be overridden\n     * since 1.7.12\n     * @returns Boolean\n     */ needsItsOwnCache: function() {\n            if (this.paintFirst === \"stroke\" && this.hasFill() && this.hasStroke() && typeof this.shadow === \"object\") {\n                return true;\n            }\n            if (this.clipPath) {\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * objectCaching is a global flag, wins over everything\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * Read as: cache if is needed, or if the feature is enabled but we are not already caching.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.group || !this.group.isOnACache());\n            return this.ownCaching;\n        },\n        /**\n     * Check if this object or a child object will cast a shadow\n     * used by Group.shouldCache to know if child has a shadow recursively\n     * @return {Boolean}\n     */ willDrawShadow: function() {\n            return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);\n        },\n        /**\n     * Execute the drawing operation for an object clipPath\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {fabric.Object} clipPath\n     */ drawClipPathOnCache: function(ctx, clipPath) {\n            ctx.save();\n            // DEBUG: uncomment this line, comment the following\n            // ctx.globalAlpha = 0.4\n            if (clipPath.inverted) {\n                ctx.globalCompositeOperation = \"destination-out\";\n            } else {\n                ctx.globalCompositeOperation = \"destination-in\";\n            }\n            //ctx.scale(1 / 2, 1 / 2);\n            if (clipPath.absolutePositioned) {\n                var m = fabric.util.invertTransform(this.calcTransformMatrix());\n                ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            }\n            clipPath.transform(ctx);\n            ctx.scale(1 / clipPath.zoomX, 1 / clipPath.zoomY);\n            ctx.drawImage(clipPath._cacheCanvas, -clipPath.cacheTranslationX, -clipPath.cacheTranslationY);\n            ctx.restore();\n        },\n        /**\n     * Execute the drawing operation for an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawObject: function(ctx, forClipping) {\n            var originalFill = this.fill, originalStroke = this.stroke;\n            if (forClipping) {\n                this.fill = \"black\";\n                this.stroke = \"\";\n                this._setClippingProperties(ctx);\n            } else {\n                this._renderBackground(ctx);\n            }\n            this._render(ctx);\n            this._drawClipPath(ctx, this.clipPath);\n            this.fill = originalFill;\n            this.stroke = originalStroke;\n        },\n        /**\n     * Prepare clipPath state and cache and draw it on instance's cache\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {fabric.Object} clipPath\n     */ _drawClipPath: function(ctx, clipPath) {\n            if (!clipPath) {\n                return;\n            }\n            // needed to setup a couple of variables\n            // path canvas gets overridden with this one.\n            // TODO find a better solution?\n            clipPath.canvas = this.canvas;\n            clipPath.shouldCache();\n            clipPath._transformDone = true;\n            clipPath.renderCache({\n                forClipping: true\n            });\n            this.drawClipPathOnCache(ctx, clipPath);\n        },\n        /**\n     * Paint the cached copy of the object on the target context.\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawCacheOnCanvas: function(ctx) {\n            ctx.scale(1 / this.zoomX, 1 / this.zoomY);\n            ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);\n        },\n        /**\n     * Check if cache is dirty\n     * @param {Boolean} skipCanvas skip canvas checks because this object is painted\n     * on parent canvas.\n     */ isCacheDirty: function(skipCanvas) {\n            if (this.isNotVisible()) {\n                return false;\n            }\n            if (this._cacheCanvas && this._cacheContext && !skipCanvas && this._updateCacheCanvas()) {\n                // in this case the context is already cleared.\n                return true;\n            } else {\n                if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged(\"cacheProperties\")) {\n                    if (this._cacheCanvas && this._cacheContext && !skipCanvas) {\n                        var width = this.cacheWidth / this.zoomX;\n                        var height = this.cacheHeight / this.zoomY;\n                        this._cacheContext.clearRect(-width / 2, -height / 2, width, height);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Draws a background for the object big as its untransformed dimensions\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderBackground: function(ctx) {\n            if (!this.backgroundColor) {\n                return;\n            }\n            var dim = this._getNonTransformedDimensions();\n            ctx.fillStyle = this.backgroundColor;\n            ctx.fillRect(-dim.x / 2, -dim.y / 2, dim.x, dim.y);\n            // if there is background color no other shadows\n            // should be casted\n            this._removeShadow(ctx);\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _setOpacity: function(ctx) {\n            if (this.group && !this.group._transformDone) {\n                ctx.globalAlpha = this.getObjectOpacity();\n            } else {\n                ctx.globalAlpha *= this.opacity;\n            }\n        },\n        _setStrokeStyles: function(ctx, decl) {\n            var stroke = decl.stroke;\n            if (stroke) {\n                ctx.lineWidth = decl.strokeWidth;\n                ctx.lineCap = decl.strokeLineCap;\n                ctx.lineDashOffset = decl.strokeDashOffset;\n                ctx.lineJoin = decl.strokeLineJoin;\n                ctx.miterLimit = decl.strokeMiterLimit;\n                if (stroke.toLive) {\n                    if (stroke.gradientUnits === \"percentage\" || stroke.gradientTransform || stroke.patternTransform) {\n                        // need to transform gradient in a pattern.\n                        // this is a slow process. If you are hitting this codepath, and the object\n                        // is not using caching, you should consider switching it on.\n                        // we need a canvas as big as the current object caching canvas.\n                        this._applyPatternForTransformedGradient(ctx, stroke);\n                    } else {\n                        // is a simple gradient or pattern\n                        ctx.strokeStyle = stroke.toLive(ctx, this);\n                        this._applyPatternGradientTransform(ctx, stroke);\n                    }\n                } else {\n                    // is a color\n                    ctx.strokeStyle = decl.stroke;\n                }\n            }\n        },\n        _setFillStyles: function(ctx, decl) {\n            var fill = decl.fill;\n            if (fill) {\n                if (fill.toLive) {\n                    ctx.fillStyle = fill.toLive(ctx, this);\n                    this._applyPatternGradientTransform(ctx, decl.fill);\n                } else {\n                    ctx.fillStyle = fill;\n                }\n            }\n        },\n        _setClippingProperties: function(ctx) {\n            ctx.globalAlpha = 1;\n            ctx.strokeStyle = \"transparent\";\n            ctx.fillStyle = \"#000000\";\n        },\n        /**\n     * @private\n     * Sets line dash\n     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on\n     * @param {Array} dashArray array representing dashes\n     */ _setLineDash: function(ctx, dashArray) {\n            if (!dashArray || dashArray.length === 0) {\n                return;\n            }\n            // Spec requires the concatenation of two copies the dash list when the number of elements is odd\n            if (1 & dashArray.length) {\n                dashArray.push.apply(dashArray, dashArray);\n            }\n            ctx.setLineDash(dashArray);\n        },\n        /**\n     * Renders controls and borders for the object\n     * the context here is not transformed\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [styleOverride] properties to override the object style\n     */ _renderControls: function(ctx, styleOverride) {\n            var vpt = this.getViewportTransform(), matrix = this.calcTransformMatrix(), options, drawBorders, drawControls;\n            styleOverride = styleOverride || {};\n            drawBorders = typeof styleOverride.hasBorders !== \"undefined\" ? styleOverride.hasBorders : this.hasBorders;\n            drawControls = typeof styleOverride.hasControls !== \"undefined\" ? styleOverride.hasControls : this.hasControls;\n            matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);\n            options = fabric.util.qrDecompose(matrix);\n            ctx.save();\n            ctx.translate(options.translateX, options.translateY);\n            ctx.lineWidth = 1 * this.borderScaleFactor;\n            if (!this.group) {\n                ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\n            }\n            if (this.flipX) {\n                options.angle -= 180;\n            }\n            ctx.rotate(degreesToRadians(this.group ? options.angle : this.angle));\n            if (styleOverride.forActiveSelection || this.group) {\n                drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);\n            } else {\n                drawBorders && this.drawBorders(ctx, styleOverride);\n            }\n            drawControls && this.drawControls(ctx, styleOverride);\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _setShadow: function(ctx) {\n            if (!this.shadow) {\n                return;\n            }\n            var shadow = this.shadow, canvas = this.canvas, scaling, multX = canvas && canvas.viewportTransform[0] || 1, multY = canvas && canvas.viewportTransform[3] || 1;\n            if (shadow.nonScaling) {\n                scaling = {\n                    scaleX: 1,\n                    scaleY: 1\n                };\n            } else {\n                scaling = this.getObjectScaling();\n            }\n            if (canvas && canvas._isRetinaScaling()) {\n                multX *= fabric.devicePixelRatio;\n                multY *= fabric.devicePixelRatio;\n            }\n            ctx.shadowColor = shadow.color;\n            ctx.shadowBlur = shadow.blur * fabric.browserShadowBlurConstant * (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;\n            ctx.shadowOffsetX = shadow.offsetX * multX * scaling.scaleX;\n            ctx.shadowOffsetY = shadow.offsetY * multY * scaling.scaleY;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _removeShadow: function(ctx) {\n            if (!this.shadow) {\n                return;\n            }\n            ctx.shadowColor = \"\";\n            ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} filler fabric.Pattern or fabric.Gradient\n     * @return {Object} offset.offsetX offset for text rendering\n     * @return {Object} offset.offsetY offset for text rendering\n     */ _applyPatternGradientTransform: function(ctx, filler) {\n            if (!filler || !filler.toLive) {\n                return {\n                    offsetX: 0,\n                    offsetY: 0\n                };\n            }\n            var t = filler.gradientTransform || filler.patternTransform;\n            var offsetX = -this.width / 2 + filler.offsetX || 0, offsetY = -this.height / 2 + filler.offsetY || 0;\n            if (filler.gradientUnits === \"percentage\") {\n                ctx.transform(this.width, 0, 0, this.height, offsetX, offsetY);\n            } else {\n                ctx.transform(1, 0, 0, 1, offsetX, offsetY);\n            }\n            if (t) {\n                ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);\n            }\n            return {\n                offsetX: offsetX,\n                offsetY: offsetY\n            };\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderPaintInOrder: function(ctx) {\n            if (this.paintFirst === \"stroke\") {\n                this._renderStroke(ctx);\n                this._renderFill(ctx);\n            } else {\n                this._renderFill(ctx);\n                this._renderStroke(ctx);\n            }\n        },\n        /**\n     * @private\n     * function that actually render something on the context.\n     * empty here to allow Obects to work on tests to benchmark fabric functionalites\n     * not related to rendering\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function() {},\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderFill: function(ctx) {\n            if (!this.fill) {\n                return;\n            }\n            ctx.save();\n            this._setFillStyles(ctx, this);\n            if (this.fillRule === \"evenodd\") {\n                ctx.fill(\"evenodd\");\n            } else {\n                ctx.fill();\n            }\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderStroke: function(ctx) {\n            if (!this.stroke || this.strokeWidth === 0) {\n                return;\n            }\n            if (this.shadow && !this.shadow.affectStroke) {\n                this._removeShadow(ctx);\n            }\n            ctx.save();\n            if (this.strokeUniform && this.group) {\n                var scaling = this.getObjectScaling();\n                ctx.scale(1 / scaling.scaleX, 1 / scaling.scaleY);\n            } else if (this.strokeUniform) {\n                ctx.scale(1 / this.scaleX, 1 / this.scaleY);\n            }\n            this._setLineDash(ctx, this.strokeDashArray);\n            this._setStrokeStyles(ctx, this);\n            ctx.stroke();\n            ctx.restore();\n        },\n        /**\n     * This function try to patch the missing gradientTransform on canvas gradients.\n     * transforming a context to transform the gradient, is going to transform the stroke too.\n     * we want to transform the gradient but not the stroke operation, so we create\n     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.\n     * this method has drwabacks: is slow, is in low resolution, needs a patch for when the size\n     * is limited.\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {fabric.Gradient} filler a fabric gradient instance\n     */ _applyPatternForTransformedGradient: function(ctx, filler) {\n            var dims = this._limitCacheSize(this._getCacheCanvasDimensions()), pCanvas = fabric.util.createCanvasElement(), pCtx, retinaScaling = this.canvas.getRetinaScaling(), width = dims.x / this.scaleX / retinaScaling, height = dims.y / this.scaleY / retinaScaling;\n            pCanvas.width = width;\n            pCanvas.height = height;\n            pCtx = pCanvas.getContext(\"2d\");\n            pCtx.beginPath();\n            pCtx.moveTo(0, 0);\n            pCtx.lineTo(width, 0);\n            pCtx.lineTo(width, height);\n            pCtx.lineTo(0, height);\n            pCtx.closePath();\n            pCtx.translate(width / 2, height / 2);\n            pCtx.scale(dims.zoomX / this.scaleX / retinaScaling, dims.zoomY / this.scaleY / retinaScaling);\n            this._applyPatternGradientTransform(pCtx, filler);\n            pCtx.fillStyle = filler.toLive(ctx);\n            pCtx.fill();\n            ctx.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2);\n            ctx.scale(retinaScaling * this.scaleX / dims.zoomX, retinaScaling * this.scaleY / dims.zoomY);\n            ctx.strokeStyle = pCtx.createPattern(pCanvas, \"no-repeat\");\n        },\n        /**\n     * This function is an helper for svg import. it returns the center of the object in the svg\n     * untransformed coordinates\n     * @private\n     * @return {Object} center point from element coordinates\n     */ _findCenterFromElement: function() {\n            return {\n                x: this.left + this.width / 2,\n                y: this.top + this.height / 2\n            };\n        },\n        /**\n     * This function is an helper for svg import. it decompose the transformMatrix\n     * and assign properties to object.\n     * untransformed coordinates\n     * @private\n     * @chainable\n     */ _assignTransformMatrixProps: function() {\n            if (this.transformMatrix) {\n                var options = fabric.util.qrDecompose(this.transformMatrix);\n                this.flipX = false;\n                this.flipY = false;\n                this.set(\"scaleX\", options.scaleX);\n                this.set(\"scaleY\", options.scaleY);\n                this.angle = options.angle;\n                this.skewX = options.skewX;\n                this.skewY = 0;\n            }\n        },\n        /**\n     * This function is an helper for svg import. it removes the transform matrix\n     * and set to object properties that fabricjs can handle\n     * @private\n     * @param {Object} preserveAspectRatioOptions\n     * @return {thisArg}\n     */ _removeTransformMatrix: function(preserveAspectRatioOptions) {\n            var center = this._findCenterFromElement();\n            if (this.transformMatrix) {\n                this._assignTransformMatrixProps();\n                center = fabric.util.transformPoint(center, this.transformMatrix);\n            }\n            this.transformMatrix = null;\n            if (preserveAspectRatioOptions) {\n                this.scaleX *= preserveAspectRatioOptions.scaleX;\n                this.scaleY *= preserveAspectRatioOptions.scaleY;\n                this.cropX = preserveAspectRatioOptions.cropX;\n                this.cropY = preserveAspectRatioOptions.cropY;\n                center.x += preserveAspectRatioOptions.offsetLeft;\n                center.y += preserveAspectRatioOptions.offsetTop;\n                this.width = preserveAspectRatioOptions.width;\n                this.height = preserveAspectRatioOptions.height;\n            }\n            this.setPositionByOrigin(center, \"center\", \"center\");\n        },\n        /**\n     * Clones an instance, using a callback method will work for every object.\n     * @param {Function} callback Callback is invoked with a clone as a first argument\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     */ clone: function(callback, propertiesToInclude) {\n            var objectForm = this.toObject(propertiesToInclude);\n            if (this.constructor.fromObject) {\n                this.constructor.fromObject(objectForm, callback);\n            } else {\n                fabric.Object._fromObject(\"Object\", objectForm, callback);\n            }\n        },\n        /**\n     * Creates an instance of fabric.Image out of an object\n     * makes use of toCanvasElement.\n     * Once this method was based on toDataUrl and loadImage, so it also had a quality\n     * and format option. toCanvasElement is faster and produce no loss of quality.\n     * If you need to get a real Jpeg or Png from an object, using toDataURL is the right way to do it.\n     * toCanvasElement and then toBlob from the obtained canvas is also a good option.\n     * This method is sync now, but still support the callback because we did not want to break.\n     * When fabricJS 5.0 will be planned, this will probably be changed to not have a callback.\n     * @param {Function} callback callback, invoked with an instance as a first argument\n     * @param {Object} [options] for clone as image, passed to toDataURL\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {fabric.Object} thisArg\n     */ cloneAsImage: function(callback, options) {\n            var canvasEl = this.toCanvasElement(options);\n            if (callback) {\n                callback(new fabric.Image(canvasEl));\n            }\n            return this;\n        },\n        /**\n     * Converts an object into a HTMLCanvas element\n     * @param {Object} options Options object\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {HTMLCanvasElement} Returns DOM element <canvas> with the fabric.Object\n     */ toCanvasElement: function(options) {\n            options || (options = {});\n            var utils = fabric.util, origParams = utils.saveObjectTransform(this), originalGroup = this.group, originalShadow = this.shadow, abs = Math.abs, multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? fabric.devicePixelRatio : 1);\n            delete this.group;\n            if (options.withoutTransform) {\n                utils.resetObjectTransform(this);\n            }\n            if (options.withoutShadow) {\n                this.shadow = null;\n            }\n            var el = fabric.util.createCanvasElement(), // skip canvas zoom and calculate with setCoords now.\n            boundingRect = this.getBoundingRect(true, true), shadow = this.shadow, scaling, shadowOffset = {\n                x: 0,\n                y: 0\n            }, shadowBlur, width, height;\n            if (shadow) {\n                shadowBlur = shadow.blur;\n                if (shadow.nonScaling) {\n                    scaling = {\n                        scaleX: 1,\n                        scaleY: 1\n                    };\n                } else {\n                    scaling = this.getObjectScaling();\n                }\n                // consider non scaling shadow.\n                shadowOffset.x = 2 * Math.round(abs(shadow.offsetX) + shadowBlur) * abs(scaling.scaleX);\n                shadowOffset.y = 2 * Math.round(abs(shadow.offsetY) + shadowBlur) * abs(scaling.scaleY);\n            }\n            width = boundingRect.width + shadowOffset.x;\n            height = boundingRect.height + shadowOffset.y;\n            // if the current width/height is not an integer\n            // we need to make it so.\n            el.width = Math.ceil(width);\n            el.height = Math.ceil(height);\n            var canvas = new fabric.StaticCanvas(el, {\n                enableRetinaScaling: false,\n                renderOnAddRemove: false,\n                skipOffscreen: false\n            });\n            if (options.format === \"jpeg\") {\n                canvas.backgroundColor = \"#fff\";\n            }\n            this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), \"center\", \"center\");\n            var originalCanvas = this.canvas;\n            canvas.add(this);\n            var canvasEl = canvas.toCanvasElement(multiplier || 1, options);\n            this.shadow = originalShadow;\n            this.set(\"canvas\", originalCanvas);\n            if (originalGroup) {\n                this.group = originalGroup;\n            }\n            this.set(origParams).setCoords();\n            // canvas.dispose will call image.dispose that will nullify the elements\n            // since this canvas is a simple element for the process, we remove references\n            // to objects in this way in order to avoid object trashing.\n            canvas._objects = [];\n            canvas.dispose();\n            canvas = null;\n            return canvasEl;\n        },\n        /**\n     * Converts an object into a data-url-like string\n     * @param {Object} options Options object\n     * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\n     */ toDataURL: function(options) {\n            options || (options = {});\n            return fabric.util.toDataURL(this.toCanvasElement(options), options.format || \"png\", options.quality || 1);\n        },\n        /**\n     * Returns true if specified type is identical to the type of an instance\n     * @param {String} type Type to check against\n     * @return {Boolean}\n     */ isType: function(type) {\n            return arguments.length > 1 ? Array.from(arguments).includes(this.type) : this.type === type;\n        },\n        /**\n     * Returns complexity of an instance\n     * @return {Number} complexity of this instance (is 1 unless subclassed)\n     */ complexity: function() {\n            return 1;\n        },\n        /**\n     * Returns a JSON representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} JSON\n     */ toJSON: function(propertiesToInclude) {\n            // delegate, not alias\n            return this.toObject(propertiesToInclude);\n        },\n        /**\n     * Sets \"angle\" of an instance with centered rotation\n     * @param {Number} angle Angle value (in degrees)\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ rotate: function(angle) {\n            var shouldCenterOrigin = (this.originX !== \"center\" || this.originY !== \"center\") && this.centeredRotation;\n            if (shouldCenterOrigin) {\n                this._setOriginToCenter();\n            }\n            this.set(\"angle\", angle);\n            if (shouldCenterOrigin) {\n                this._resetOrigin();\n            }\n            return this;\n        },\n        /**\n     * Centers object horizontally on canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ centerH: function() {\n            this.canvas && this.canvas.centerObjectH(this);\n            return this;\n        },\n        /**\n     * Centers object horizontally on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ viewportCenterH: function() {\n            this.canvas && this.canvas.viewportCenterObjectH(this);\n            return this;\n        },\n        /**\n     * Centers object vertically on canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ centerV: function() {\n            this.canvas && this.canvas.centerObjectV(this);\n            return this;\n        },\n        /**\n     * Centers object vertically on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ viewportCenterV: function() {\n            this.canvas && this.canvas.viewportCenterObjectV(this);\n            return this;\n        },\n        /**\n     * Centers object vertically and horizontally on canvas to which is was added last\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ center: function() {\n            this.canvas && this.canvas.centerObject(this);\n            return this;\n        },\n        /**\n     * Centers object on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ viewportCenter: function() {\n            this.canvas && this.canvas.viewportCenterObject(this);\n            return this;\n        },\n        /**\n     * Returns coordinates of a pointer relative to an object\n     * @param {Event} e Event to operate upon\n     * @param {Object} [pointer] Pointer to operate upon (instead of event)\n     * @return {Object} Coordinates of a pointer (x, y)\n     */ getLocalPointer: function(e, pointer) {\n            pointer = pointer || this.canvas.getPointer(e);\n            var pClicked = new fabric.Point(pointer.x, pointer.y), objectLeftTop = this._getLeftTopCoords();\n            if (this.angle) {\n                pClicked = fabric.util.rotatePoint(pClicked, objectLeftTop, degreesToRadians(-this.angle));\n            }\n            return {\n                x: pClicked.x - objectLeftTop.x,\n                y: pClicked.y - objectLeftTop.y\n            };\n        },\n        /**\n     * Sets canvas globalCompositeOperation for specific object\n     * custom composition operation for the particular object can be specified using globalCompositeOperation property\n     * @param {CanvasRenderingContext2D} ctx Rendering canvas context\n     */ _setupCompositeOperation: function(ctx) {\n            if (this.globalCompositeOperation) {\n                ctx.globalCompositeOperation = this.globalCompositeOperation;\n            }\n        },\n        /**\n     * cancel instance's running animations\n     * override if necessary to dispose artifacts such as `clipPath`\n     */ dispose: function() {\n            if (fabric.runningAnimations) {\n                fabric.runningAnimations.cancelByTarget(this);\n            }\n        }\n    });\n    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Object);\n    extend(fabric.Object.prototype, fabric.Observable);\n    /**\n   * Defines the number of fraction digits to use when serializing object values.\n   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.\n   * @static\n   * @memberOf fabric.Object\n   * @constant\n   * @type Number\n   */ fabric.Object.NUM_FRACTION_DIGITS = 2;\n    /**\n   * Defines which properties should be enlivened from the object passed to {@link fabric.Object._fromObject}\n   * @static\n   * @memberOf fabric.Object\n   * @constant\n   * @type string[]\n   */ fabric.Object.ENLIVEN_PROPS = [\n        \"clipPath\"\n    ];\n    fabric.Object._fromObject = function(className, object, callback, extraParam) {\n        var klass = fabric[className];\n        object = clone(object, true);\n        fabric.util.enlivenPatterns([\n            object.fill,\n            object.stroke\n        ], function(patterns) {\n            if (typeof patterns[0] !== \"undefined\") {\n                object.fill = patterns[0];\n            }\n            if (typeof patterns[1] !== \"undefined\") {\n                object.stroke = patterns[1];\n            }\n            fabric.util.enlivenObjectEnlivables(object, object, function() {\n                var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);\n                callback && callback(instance);\n            });\n        });\n    };\n    /**\n   * Unique id used internally when creating SVG elements\n   * @static\n   * @memberOf fabric.Object\n   * @type Number\n   */ fabric.Object.__uid = 0;\n})( true ? exports : 0);\n(function() {\n    var degreesToRadians = fabric.util.degreesToRadians, originXOffset = {\n        left: -0.5,\n        center: 0,\n        right: 0.5\n    }, originYOffset = {\n        top: -0.5,\n        center: 0,\n        bottom: 0.5\n    };\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Translates the coordinates from a set of origin to another (based on the object's dimensions)\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'\n     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {\n            var x = point.x, y = point.y, offsetX, offsetY, dim;\n            if (typeof fromOriginX === \"string\") {\n                fromOriginX = originXOffset[fromOriginX];\n            } else {\n                fromOriginX -= 0.5;\n            }\n            if (typeof toOriginX === \"string\") {\n                toOriginX = originXOffset[toOriginX];\n            } else {\n                toOriginX -= 0.5;\n            }\n            offsetX = toOriginX - fromOriginX;\n            if (typeof fromOriginY === \"string\") {\n                fromOriginY = originYOffset[fromOriginY];\n            } else {\n                fromOriginY -= 0.5;\n            }\n            if (typeof toOriginY === \"string\") {\n                toOriginY = originYOffset[toOriginY];\n            } else {\n                toOriginY -= 0.5;\n            }\n            offsetY = toOriginY - fromOriginY;\n            if (offsetX || offsetY) {\n                dim = this._getTransformedDimensions();\n                x = point.x + offsetX * dim.x;\n                y = point.y + offsetY * dim.y;\n            }\n            return new fabric.Point(x, y);\n        },\n        /**\n     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ translateToCenterPoint: function(point, originX, originY) {\n            var p = this.translateToGivenOrigin(point, originX, originY, \"center\", \"center\");\n            if (this.angle) {\n                return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));\n            }\n            return p;\n        },\n        /**\n     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)\n     * @param {fabric.Point} center The point which corresponds to center of the object\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ translateToOriginPoint: function(center, originX, originY) {\n            var p = this.translateToGivenOrigin(center, \"center\", \"center\", originX, originY);\n            if (this.angle) {\n                return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));\n            }\n            return p;\n        },\n        /**\n     * Returns the real center coordinates of the object\n     * @return {fabric.Point}\n     */ getCenterPoint: function() {\n            var leftTop = new fabric.Point(this.left, this.top);\n            return this.translateToCenterPoint(leftTop, this.originX, this.originY);\n        },\n        /**\n     * Returns the coordinates of the object based on center coordinates\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @return {fabric.Point}\n     */ // getOriginPoint: function(center) {\n        //   return this.translateToOriginPoint(center, this.originX, this.originY);\n        // },\n        /**\n     * Returns the coordinates of the object as if it has a different origin\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ getPointByOrigin: function(originX, originY) {\n            var center = this.getCenterPoint();\n            return this.translateToOriginPoint(center, originX, originY);\n        },\n        /**\n     * Returns the point in local coordinates\n     * @param {fabric.Point} point The point relative to the global coordinate system\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ toLocalPoint: function(point, originX, originY) {\n            var center = this.getCenterPoint(), p, p2;\n            if (typeof originX !== \"undefined\" && typeof originY !== \"undefined\") {\n                p = this.translateToGivenOrigin(center, \"center\", \"center\", originX, originY);\n            } else {\n                p = new fabric.Point(this.left, this.top);\n            }\n            p2 = new fabric.Point(point.x, point.y);\n            if (this.angle) {\n                p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));\n            }\n            return p2.subtractEquals(p);\n        },\n        /**\n     * Returns the point in global coordinates\n     * @param {fabric.Point} The point relative to the local coordinate system\n     * @return {fabric.Point}\n     */ // toGlobalPoint: function(point) {\n        //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));\n        // },\n        /**\n     * Sets the position of the object taking into consideration the object's origin\n     * @param {fabric.Point} pos The new position of the object\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {void}\n     */ setPositionByOrigin: function(pos, originX, originY) {\n            var center = this.translateToCenterPoint(pos, originX, originY), position = this.translateToOriginPoint(center, this.originX, this.originY);\n            this.set(\"left\", position.x);\n            this.set(\"top\", position.y);\n        },\n        /**\n     * @param {String} to One of 'left', 'center', 'right'\n     */ adjustPosition: function(to) {\n            var angle = degreesToRadians(this.angle), hypotFull = this.getScaledWidth(), xFull = fabric.util.cos(angle) * hypotFull, yFull = fabric.util.sin(angle) * hypotFull, offsetFrom, offsetTo;\n            //TODO: this function does not consider mixed situation like top, center.\n            if (typeof this.originX === \"string\") {\n                offsetFrom = originXOffset[this.originX];\n            } else {\n                offsetFrom = this.originX - 0.5;\n            }\n            if (typeof to === \"string\") {\n                offsetTo = originXOffset[to];\n            } else {\n                offsetTo = to - 0.5;\n            }\n            this.left += xFull * (offsetTo - offsetFrom);\n            this.top += yFull * (offsetTo - offsetFrom);\n            this.setCoords();\n            this.originX = to;\n        },\n        /**\n     * Sets the origin/position of the object to it's center point\n     * @private\n     * @return {void}\n     */ _setOriginToCenter: function() {\n            this._originalOriginX = this.originX;\n            this._originalOriginY = this.originY;\n            var center = this.getCenterPoint();\n            this.originX = \"center\";\n            this.originY = \"center\";\n            this.left = center.x;\n            this.top = center.y;\n        },\n        /**\n     * Resets the origin/position of the object to it's original origin\n     * @private\n     * @return {void}\n     */ _resetOrigin: function() {\n            var originPoint = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY);\n            this.originX = this._originalOriginX;\n            this.originY = this._originalOriginY;\n            this.left = originPoint.x;\n            this.top = originPoint.y;\n            this._originalOriginX = null;\n            this._originalOriginY = null;\n        },\n        /**\n     * @private\n     */ _getLeftTopCoords: function() {\n            return this.translateToOriginPoint(this.getCenterPoint(), \"left\", \"top\");\n        }\n    });\n})();\n(function() {\n    function arrayFromCoords(coords) {\n        return [\n            new fabric.Point(coords.tl.x, coords.tl.y),\n            new fabric.Point(coords.tr.x, coords.tr.y),\n            new fabric.Point(coords.br.x, coords.br.y),\n            new fabric.Point(coords.bl.x, coords.bl.y)\n        ];\n    }\n    var util = fabric.util, degreesToRadians = util.degreesToRadians, multiplyMatrices = util.multiplyTransformMatrices, transformPoint = util.transformPoint;\n    util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Describe object's corner position in canvas element coordinates.\n     * properties are depending on control keys and padding the main controls.\n     * each property is an object with x, y and corner.\n     * The `corner` property contains in a similar manner the 4 points of the\n     * interactive area of the corner.\n     * The coordinates depends from the controls positionHandler and are used\n     * to draw and locate controls\n     * @memberOf fabric.Object.prototype\n     */ oCoords: null,\n        /**\n     * Describe object's corner position in canvas object absolute coordinates\n     * properties are tl,tr,bl,br and describe the four main corner.\n     * each property is an object with x, y, instance of Fabric.Point.\n     * The coordinates depends from this properties: width, height, scaleX, scaleY\n     * skewX, skewY, angle, strokeWidth, top, left.\n     * Those coordinates are useful to understand where an object is. They get updated\n     * with oCoords but they do not need to be updated when zoom or panning change.\n     * The coordinates get updated with @method setCoords.\n     * You can calculate them without updating with @method calcACoords();\n     * @memberOf fabric.Object.prototype\n     */ aCoords: null,\n        /**\n     * Describe object's corner position in canvas element coordinates.\n     * includes padding. Used of object detection.\n     * set and refreshed with setCoords.\n     * @memberOf fabric.Object.prototype\n     */ lineCoords: null,\n        /**\n     * storage for object transform matrix\n     */ ownMatrixCache: null,\n        /**\n     * storage for object full transform matrix\n     */ matrixCache: null,\n        /**\n     * custom controls interface\n     * controls are added by default_controls.js\n     */ controls: {},\n        /**\n     * return correct set of coordinates for intersection\n     * this will return either aCoords or lineCoords.\n     * @param {Boolean} absolute will return aCoords if true or lineCoords\n     * @return {Object} {tl, tr, br, bl} points\n     */ _getCoords: function(absolute, calculate) {\n            if (calculate) {\n                return absolute ? this.calcACoords() : this.calcLineCoords();\n            }\n            if (!this.aCoords || !this.lineCoords) {\n                this.setCoords(true);\n            }\n            return absolute ? this.aCoords : this.lineCoords;\n        },\n        /**\n     * return correct set of coordinates for intersection\n     * this will return either aCoords or lineCoords.\n     * The coords are returned in an array.\n     * @return {Array} [tl, tr, br, bl] of points\n     */ getCoords: function(absolute, calculate) {\n            return arrayFromCoords(this._getCoords(absolute, calculate));\n        },\n        /**\n     * Checks if object intersects with an area formed by 2 points\n     * @param {Object} pointTL top-left point of area\n     * @param {Object} pointBR bottom-right point of area\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object intersects with an area formed by 2 points\n     */ intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {\n            var coords = this.getCoords(absolute, calculate), intersection = fabric.Intersection.intersectPolygonRectangle(coords, pointTL, pointBR);\n            return intersection.status === \"Intersection\";\n        },\n        /**\n     * Checks if object intersects with another object\n     * @param {Object} other Object to test\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object intersects with another object\n     */ intersectsWithObject: function(other, absolute, calculate) {\n            var intersection = fabric.Intersection.intersectPolygonPolygon(this.getCoords(absolute, calculate), other.getCoords(absolute, calculate));\n            return intersection.status === \"Intersection\" || other.isContainedWithinObject(this, absolute, calculate) || this.isContainedWithinObject(other, absolute, calculate);\n        },\n        /**\n     * Checks if object is fully contained within area of another object\n     * @param {Object} other Object to test\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is fully contained within area of another object\n     */ isContainedWithinObject: function(other, absolute, calculate) {\n            var points = this.getCoords(absolute, calculate), otherCoords = absolute ? other.aCoords : other.lineCoords, i = 0, lines = other._getImageLines(otherCoords);\n            for(; i < 4; i++){\n                if (!other.containsPoint(points[i], lines)) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        /**\n     * Checks if object is fully contained within area formed by 2 points\n     * @param {Object} pointTL top-left point of area\n     * @param {Object} pointBR bottom-right point of area\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is fully contained within area formed by 2 points\n     */ isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {\n            var boundingRect = this.getBoundingRect(absolute, calculate);\n            return boundingRect.left >= pointTL.x && boundingRect.left + boundingRect.width <= pointBR.x && boundingRect.top >= pointTL.y && boundingRect.top + boundingRect.height <= pointBR.y;\n        },\n        /**\n     * Checks if point is inside the object\n     * @param {fabric.Point} point Point to check against\n     * @param {Object} [lines] object returned from @method _getImageLines\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if point is inside the object\n     */ containsPoint: function(point, lines, absolute, calculate) {\n            var coords = this._getCoords(absolute, calculate), lines = lines || this._getImageLines(coords), xPoints = this._findCrossPoints(point, lines);\n            // if xPoints is odd then point is inside the object\n            return xPoints !== 0 && xPoints % 2 === 1;\n        },\n        /**\n     * Checks if object is contained within the canvas with current viewportTransform\n     * the check is done stopping at first point that appears on screen\n     * @param {Boolean} [calculate] use coordinates of current position instead of .aCoords\n     * @return {Boolean} true if object is fully or partially contained within canvas\n     */ isOnScreen: function(calculate) {\n            if (!this.canvas) {\n                return false;\n            }\n            var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;\n            var points = this.getCoords(true, calculate);\n            // if some point is on screen, the object is on screen.\n            if (points.some(function(point) {\n                return point.x <= pointBR.x && point.x >= pointTL.x && point.y <= pointBR.y && point.y >= pointTL.y;\n            })) {\n                return true;\n            }\n            // no points on screen, check intersection with absolute coordinates\n            if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {\n                return true;\n            }\n            return this._containsCenterOfCanvas(pointTL, pointBR, calculate);\n        },\n        /**\n     * Checks if the object contains the midpoint between canvas extremities\n     * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen\n     * @private\n     * @param {Fabric.Point} pointTL Top Left point\n     * @param {Fabric.Point} pointBR Top Right point\n     * @param {Boolean} calculate use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if the object contains the point\n     */ _containsCenterOfCanvas: function(pointTL, pointBR, calculate) {\n            // worst case scenario the object is so big that contains the screen\n            var centerPoint = {\n                x: (pointTL.x + pointBR.x) / 2,\n                y: (pointTL.y + pointBR.y) / 2\n            };\n            if (this.containsPoint(centerPoint, null, true, calculate)) {\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Checks if object is partially contained within the canvas with current viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is partially contained within canvas\n     */ isPartiallyOnScreen: function(calculate) {\n            if (!this.canvas) {\n                return false;\n            }\n            var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;\n            if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {\n                return true;\n            }\n            var allPointsAreOutside = this.getCoords(true, calculate).every(function(point) {\n                return (point.x >= pointBR.x || point.x <= pointTL.x) && (point.y >= pointBR.y || point.y <= pointTL.y);\n            });\n            return allPointsAreOutside && this._containsCenterOfCanvas(pointTL, pointBR, calculate);\n        },\n        /**\n     * Method that returns an object with the object edges in it, given the coordinates of the corners\n     * @private\n     * @param {Object} oCoords Coordinates of the object corners\n     */ _getImageLines: function(oCoords) {\n            var lines = {\n                topline: {\n                    o: oCoords.tl,\n                    d: oCoords.tr\n                },\n                rightline: {\n                    o: oCoords.tr,\n                    d: oCoords.br\n                },\n                bottomline: {\n                    o: oCoords.br,\n                    d: oCoords.bl\n                },\n                leftline: {\n                    o: oCoords.bl,\n                    d: oCoords.tl\n                }\n            };\n            // // debugging\n            // if (this.canvas.contextTop) {\n            //   this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);\n            //\n            //   this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);\n            //\n            //   this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);\n            //\n            //   this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);\n            // }\n            return lines;\n        },\n        /**\n     * Helper method to determine how many cross points are between the 4 object edges\n     * and the horizontal line determined by a point on canvas\n     * @private\n     * @param {fabric.Point} point Point to check\n     * @param {Object} lines Coordinates of the object being evaluated\n     */ // remove yi, not used but left code here just in case.\n        _findCrossPoints: function(point, lines) {\n            var b1, b2, a1, a2, xi, xcount = 0, iLine;\n            for(var lineKey in lines){\n                iLine = lines[lineKey];\n                // optimisation 1: line below point. no cross\n                if (iLine.o.y < point.y && iLine.d.y < point.y) {\n                    continue;\n                }\n                // optimisation 2: line above point. no cross\n                if (iLine.o.y >= point.y && iLine.d.y >= point.y) {\n                    continue;\n                }\n                // optimisation 3: vertical line case\n                if (iLine.o.x === iLine.d.x && iLine.o.x >= point.x) {\n                    xi = iLine.o.x;\n                // yi = point.y;\n                } else {\n                    b1 = 0;\n                    b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);\n                    a1 = point.y - b1 * point.x;\n                    a2 = iLine.o.y - b2 * iLine.o.x;\n                    xi = -(a1 - a2) / (b1 - b2);\n                // yi = a1 + b1 * xi;\n                }\n                // dont count xi < point.x cases\n                if (xi >= point.x) {\n                    xcount += 1;\n                }\n                // optimisation 4: specific for square images\n                if (xcount === 2) {\n                    break;\n                }\n            }\n            return xcount;\n        },\n        /**\n     * Returns coordinates of object's bounding rectangle (left, top, width, height)\n     * the box is intended as aligned to axis of canvas.\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords\n     * @return {Object} Object with left, top, width, height properties\n     */ getBoundingRect: function(absolute, calculate) {\n            var coords = this.getCoords(absolute, calculate);\n            return util.makeBoundingBoxFromPoints(coords);\n        },\n        /**\n     * Returns width of an object's bounding box counting transformations\n     * before 2.0 it was named getWidth();\n     * @return {Number} width value\n     */ getScaledWidth: function() {\n            return this._getTransformedDimensions().x;\n        },\n        /**\n     * Returns height of an object bounding box counting transformations\n     * before 2.0 it was named getHeight();\n     * @return {Number} height value\n     */ getScaledHeight: function() {\n            return this._getTransformedDimensions().y;\n        },\n        /**\n     * Makes sure the scale is valid and modifies it if necessary\n     * @private\n     * @param {Number} value\n     * @return {Number}\n     */ _constrainScale: function(value) {\n            if (Math.abs(value) < this.minScaleLimit) {\n                if (value < 0) {\n                    return -this.minScaleLimit;\n                } else {\n                    return this.minScaleLimit;\n                }\n            } else if (value === 0) {\n                return 0.0001;\n            }\n            return value;\n        },\n        /**\n     * Scales an object (equally by x and y)\n     * @param {Number} value Scale factor\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ scale: function(value) {\n            this._set(\"scaleX\", value);\n            this._set(\"scaleY\", value);\n            return this.setCoords();\n        },\n        /**\n     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)\n     * @param {Number} value New width value\n     * @param {Boolean} absolute ignore viewport\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ scaleToWidth: function(value, absolute) {\n            // adjust to bounding rect factor so that rotated shapes would fit as well\n            var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();\n            return this.scale(value / this.width / boundingRectFactor);\n        },\n        /**\n     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)\n     * @param {Number} value New height value\n     * @param {Boolean} absolute ignore viewport\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ scaleToHeight: function(value, absolute) {\n            // adjust to bounding rect factor so that rotated shapes would fit as well\n            var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();\n            return this.scale(value / this.height / boundingRectFactor);\n        },\n        calcLineCoords: function() {\n            var vpt = this.getViewportTransform(), padding = this.padding, angle = degreesToRadians(this.angle), cos = util.cos(angle), sin = util.sin(angle), cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP, cosPMinusSinP = cosP - sinP, aCoords = this.calcACoords();\n            var lineCoords = {\n                tl: transformPoint(aCoords.tl, vpt),\n                tr: transformPoint(aCoords.tr, vpt),\n                bl: transformPoint(aCoords.bl, vpt),\n                br: transformPoint(aCoords.br, vpt)\n            };\n            if (padding) {\n                lineCoords.tl.x -= cosPMinusSinP;\n                lineCoords.tl.y -= cosPSinP;\n                lineCoords.tr.x += cosPSinP;\n                lineCoords.tr.y -= cosPMinusSinP;\n                lineCoords.bl.x -= cosPSinP;\n                lineCoords.bl.y += cosPMinusSinP;\n                lineCoords.br.x += cosPMinusSinP;\n                lineCoords.br.y += cosPSinP;\n            }\n            return lineCoords;\n        },\n        calcOCoords: function() {\n            var rotateMatrix = this._calcRotateMatrix(), translateMatrix = this._calcTranslateMatrix(), vpt = this.getViewportTransform(), startMatrix = multiplyMatrices(vpt, translateMatrix), finalMatrix = multiplyMatrices(startMatrix, rotateMatrix), finalMatrix = multiplyMatrices(finalMatrix, [\n                1 / vpt[0],\n                0,\n                0,\n                1 / vpt[3],\n                0,\n                0\n            ]), dim = this._calculateCurrentDimensions(), coords = {};\n            this.forEachControl(function(control, key, fabricObject) {\n                coords[key] = control.positionHandler(dim, finalMatrix, fabricObject);\n            });\n            // debug code\n            // var canvas = this.canvas;\n            // setTimeout(function() {\n            //   canvas.contextTop.clearRect(0, 0, 700, 700);\n            //   canvas.contextTop.fillStyle = 'green';\n            //   Object.keys(coords).forEach(function(key) {\n            //     var control = coords[key];\n            //     canvas.contextTop.fillRect(control.x, control.y, 3, 3);\n            //   });\n            // }, 50);\n            return coords;\n        },\n        calcACoords: function() {\n            var rotateMatrix = this._calcRotateMatrix(), translateMatrix = this._calcTranslateMatrix(), finalMatrix = multiplyMatrices(translateMatrix, rotateMatrix), dim = this._getTransformedDimensions(), w = dim.x / 2, h = dim.y / 2;\n            return {\n                // corners\n                tl: transformPoint({\n                    x: -w,\n                    y: -h\n                }, finalMatrix),\n                tr: transformPoint({\n                    x: w,\n                    y: -h\n                }, finalMatrix),\n                bl: transformPoint({\n                    x: -w,\n                    y: h\n                }, finalMatrix),\n                br: transformPoint({\n                    x: w,\n                    y: h\n                }, finalMatrix)\n            };\n        },\n        /**\n     * Sets corner and controls position coordinates based on current angle, width and height, left and top.\n     * oCoords are used to find the corners\n     * aCoords are used to quickly find an object on the canvas\n     * lineCoords are used to quickly find object during pointer events.\n     * See {@link https://github.com/fabricjs/fabric.js/wiki/When-to-call-setCoords} and {@link http://fabricjs.com/fabric-gotchas}\n     *\n     * @param {Boolean} [skipCorners] skip calculation of oCoords.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ setCoords: function(skipCorners) {\n            this.aCoords = this.calcACoords();\n            // in case we are in a group, for how the inner group target check works,\n            // lineCoords are exactly aCoords. Since the vpt gets absorbed by the normalized pointer.\n            this.lineCoords = this.group ? this.aCoords : this.calcLineCoords();\n            if (skipCorners) {\n                return this;\n            }\n            // set coordinates of the draggable boxes in the corners used to scale/rotate the image\n            this.oCoords = this.calcOCoords();\n            this._setCornerCoords && this._setCornerCoords();\n            return this;\n        },\n        /**\n     * calculate rotation matrix of an object\n     * @return {Array} rotation matrix for the object\n     */ _calcRotateMatrix: function() {\n            return util.calcRotateMatrix(this);\n        },\n        /**\n     * calculate the translation matrix for an object transform\n     * @return {Array} rotation matrix for the object\n     */ _calcTranslateMatrix: function() {\n            var center = this.getCenterPoint();\n            return [\n                1,\n                0,\n                0,\n                1,\n                center.x,\n                center.y\n            ];\n        },\n        transformMatrixKey: function(skipGroup) {\n            var sep = \"_\", prefix = \"\";\n            if (!skipGroup && this.group) {\n                prefix = this.group.transformMatrixKey(skipGroup) + sep;\n            }\n            ;\n            return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY + sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY + sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;\n        },\n        /**\n     * calculate transform matrix that represents the current transformations from the\n     * object's properties.\n     * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations\n     * There are some situation in which this is useful to avoid the fake rotation.\n     * @return {Array} transform matrix for the object\n     */ calcTransformMatrix: function(skipGroup) {\n            var matrix = this.calcOwnMatrix();\n            if (skipGroup || !this.group) {\n                return matrix;\n            }\n            var key = this.transformMatrixKey(skipGroup), cache = this.matrixCache || (this.matrixCache = {});\n            if (cache.key === key) {\n                return cache.value;\n            }\n            if (this.group) {\n                matrix = multiplyMatrices(this.group.calcTransformMatrix(false), matrix);\n            }\n            cache.key = key;\n            cache.value = matrix;\n            return matrix;\n        },\n        /**\n     * calculate transform matrix that represents the current transformations from the\n     * object's properties, this matrix does not include the group transformation\n     * @return {Array} transform matrix for the object\n     */ calcOwnMatrix: function() {\n            var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});\n            if (cache.key === key) {\n                return cache.value;\n            }\n            var tMatrix = this._calcTranslateMatrix(), options = {\n                angle: this.angle,\n                translateX: tMatrix[4],\n                translateY: tMatrix[5],\n                scaleX: this.scaleX,\n                scaleY: this.scaleY,\n                skewX: this.skewX,\n                skewY: this.skewY,\n                flipX: this.flipX,\n                flipY: this.flipY\n            };\n            cache.key = key;\n            cache.value = util.composeMatrix(options);\n            return cache.value;\n        },\n        /*\n     * Calculate object dimensions from its properties\n     * @private\n     * @return {Object} .x width dimension\n     * @return {Object} .y height dimension\n     */ _getNonTransformedDimensions: function() {\n            var strokeWidth = this.strokeWidth, w = this.width + strokeWidth, h = this.height + strokeWidth;\n            return {\n                x: w,\n                y: h\n            };\n        },\n        /*\n     * Calculate object bounding box dimensions from its properties scale, skew.\n     * @param {Number} skewX, a value to override current skewX\n     * @param {Number} skewY, a value to override current skewY\n     * @private\n     * @return {Object} .x width dimension\n     * @return {Object} .y height dimension\n     */ _getTransformedDimensions: function(skewX, skewY) {\n            if (typeof skewX === \"undefined\") {\n                skewX = this.skewX;\n            }\n            if (typeof skewY === \"undefined\") {\n                skewY = this.skewY;\n            }\n            var dimensions, dimX, dimY, noSkew = skewX === 0 && skewY === 0;\n            if (this.strokeUniform) {\n                dimX = this.width;\n                dimY = this.height;\n            } else {\n                dimensions = this._getNonTransformedDimensions();\n                dimX = dimensions.x;\n                dimY = dimensions.y;\n            }\n            if (noSkew) {\n                return this._finalizeDimensions(dimX * this.scaleX, dimY * this.scaleY);\n            }\n            var bbox = util.sizeAfterTransform(dimX, dimY, {\n                scaleX: this.scaleX,\n                scaleY: this.scaleY,\n                skewX: skewX,\n                skewY: skewY\n            });\n            return this._finalizeDimensions(bbox.x, bbox.y);\n        },\n        /*\n     * Calculate object bounding box dimensions from its properties scale, skew.\n     * @param Number width width of the bbox\n     * @param Number height height of the bbox\n     * @private\n     * @return {Object} .x finalized width dimension\n     * @return {Object} .y finalized height dimension\n     */ _finalizeDimensions: function(width, height) {\n            return this.strokeUniform ? {\n                x: width + this.strokeWidth,\n                y: height + this.strokeWidth\n            } : {\n                x: width,\n                y: height\n            };\n        },\n        /*\n     * Calculate object dimensions for controls box, including padding and canvas zoom.\n     * and active selection\n     * private\n     */ _calculateCurrentDimensions: function() {\n            var vpt = this.getViewportTransform(), dim = this._getTransformedDimensions(), p = transformPoint(dim, vpt, true);\n            return p.scalarAdd(2 * this.padding);\n        }\n    });\n})();\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n    /**\n   * Moves an object to the bottom of the stack of drawn objects\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ sendToBack: function() {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);\n        } else if (this.canvas) {\n            this.canvas.sendToBack(this);\n        }\n        return this;\n    },\n    /**\n   * Moves an object to the top of the stack of drawn objects\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ bringToFront: function() {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);\n        } else if (this.canvas) {\n            this.canvas.bringToFront(this);\n        }\n        return this;\n    },\n    /**\n   * Moves an object down in stack of drawn objects\n   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ sendBackwards: function(intersecting) {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);\n        } else if (this.canvas) {\n            this.canvas.sendBackwards(this, intersecting);\n        }\n        return this;\n    },\n    /**\n   * Moves an object up in stack of drawn objects\n   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ bringForward: function(intersecting) {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);\n        } else if (this.canvas) {\n            this.canvas.bringForward(this, intersecting);\n        }\n        return this;\n    },\n    /**\n   * Moves an object to specified level in stack of drawn objects\n   * @param {Number} index New position of object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ moveTo: function(index) {\n        if (this.group && this.group.type !== \"activeSelection\") {\n            fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);\n        } else if (this.canvas) {\n            this.canvas.moveTo(this, index);\n        }\n        return this;\n    }\n});\n/* _TO_SVG_START_ */ (function() {\n    function getSvgColorString(prop, value) {\n        if (!value) {\n            return prop + \": none; \";\n        } else if (value.toLive) {\n            return prop + \": url(#SVGID_\" + value.id + \"); \";\n        } else {\n            var color = new fabric.Color(value), str = prop + \": \" + color.toRgb() + \"; \", opacity = color.getAlpha();\n            if (opacity !== 1) {\n                //change the color in rgb + opacity\n                str += prop + \"-opacity: \" + opacity.toString() + \"; \";\n            }\n            return str;\n        }\n    }\n    var toFixed = fabric.util.toFixed;\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Returns styles-string for svg-export\n     * @param {Boolean} skipShadow a boolean to skip shadow filter output\n     * @return {String}\n     */ getSvgStyles: function(skipShadow) {\n            var fillRule = this.fillRule ? this.fillRule : \"nonzero\", strokeWidth = this.strokeWidth ? this.strokeWidth : \"0\", strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(\" \") : \"none\", strokeDashOffset = this.strokeDashOffset ? this.strokeDashOffset : \"0\", strokeLineCap = this.strokeLineCap ? this.strokeLineCap : \"butt\", strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : \"miter\", strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : \"4\", opacity = typeof this.opacity !== \"undefined\" ? this.opacity : \"1\", visibility = this.visible ? \"\" : \" visibility: hidden;\", filter = skipShadow ? \"\" : this.getSvgFilter(), fill = getSvgColorString(\"fill\", this.fill), stroke = getSvgColorString(\"stroke\", this.stroke);\n            return [\n                stroke,\n                \"stroke-width: \",\n                strokeWidth,\n                \"; \",\n                \"stroke-dasharray: \",\n                strokeDashArray,\n                \"; \",\n                \"stroke-linecap: \",\n                strokeLineCap,\n                \"; \",\n                \"stroke-dashoffset: \",\n                strokeDashOffset,\n                \"; \",\n                \"stroke-linejoin: \",\n                strokeLineJoin,\n                \"; \",\n                \"stroke-miterlimit: \",\n                strokeMiterLimit,\n                \"; \",\n                fill,\n                \"fill-rule: \",\n                fillRule,\n                \"; \",\n                \"opacity: \",\n                opacity,\n                \";\",\n                filter,\n                visibility\n            ].join(\"\");\n        },\n        /**\n     * Returns styles-string for svg-export\n     * @param {Object} style the object from which to retrieve style properties\n     * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.\n     * @return {String}\n     */ getSvgSpanStyles: function(style, useWhiteSpace) {\n            var term = \"; \";\n            var fontFamily = style.fontFamily ? \"font-family: \" + (style.fontFamily.indexOf(\"'\") === -1 && style.fontFamily.indexOf('\"') === -1 ? \"'\" + style.fontFamily + \"'\" : style.fontFamily) + term : \"\";\n            var strokeWidth = style.strokeWidth ? \"stroke-width: \" + style.strokeWidth + term : \"\", fontFamily = fontFamily, fontSize = style.fontSize ? \"font-size: \" + style.fontSize + \"px\" + term : \"\", fontStyle = style.fontStyle ? \"font-style: \" + style.fontStyle + term : \"\", fontWeight = style.fontWeight ? \"font-weight: \" + style.fontWeight + term : \"\", fill = style.fill ? getSvgColorString(\"fill\", style.fill) : \"\", stroke = style.stroke ? getSvgColorString(\"stroke\", style.stroke) : \"\", textDecoration = this.getSvgTextDecoration(style), deltaY = style.deltaY ? \"baseline-shift: \" + -style.deltaY + \"; \" : \"\";\n            if (textDecoration) {\n                textDecoration = \"text-decoration: \" + textDecoration + term;\n            }\n            return [\n                stroke,\n                strokeWidth,\n                fontFamily,\n                fontSize,\n                fontStyle,\n                fontWeight,\n                textDecoration,\n                fill,\n                deltaY,\n                useWhiteSpace ? \"white-space: pre; \" : \"\"\n            ].join(\"\");\n        },\n        /**\n     * Returns text-decoration property for svg-export\n     * @param {Object} style the object from which to retrieve style properties\n     * @return {String}\n     */ getSvgTextDecoration: function(style) {\n            return [\n                \"overline\",\n                \"underline\",\n                \"line-through\"\n            ].filter(function(decoration) {\n                return style[decoration.replace(\"-\", \"\")];\n            }).join(\" \");\n        },\n        /**\n     * Returns filter for svg shadow\n     * @return {String}\n     */ getSvgFilter: function() {\n            return this.shadow ? \"filter: url(#SVGID_\" + this.shadow.id + \");\" : \"\";\n        },\n        /**\n     * Returns id attribute for svg output\n     * @return {String}\n     */ getSvgCommons: function() {\n            return [\n                this.id ? 'id=\"' + this.id + '\" ' : \"\",\n                this.clipPath ? 'clip-path=\"url(#' + this.clipPath.clipPathId + ')\" ' : \"\"\n            ].join(\"\");\n        },\n        /**\n     * Returns transform-string for svg-export\n     * @param {Boolean} use the full transform or the single object one.\n     * @return {String}\n     */ getSvgTransform: function(full, additionalTransform) {\n            var transform = full ? this.calcTransformMatrix() : this.calcOwnMatrix(), svgTransform = 'transform=\"' + fabric.util.matrixToSVG(transform);\n            return svgTransform + (additionalTransform || \"\") + '\" ';\n        },\n        _setSVGBg: function(textBgRects) {\n            if (this.backgroundColor) {\n                var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n                textBgRects.push(\"\t\t<rect \", this._getFillAttributes(this.backgroundColor), ' x=\"', toFixed(-this.width / 2, NUM_FRACTION_DIGITS), '\" y=\"', toFixed(-this.height / 2, NUM_FRACTION_DIGITS), '\" width=\"', toFixed(this.width, NUM_FRACTION_DIGITS), '\" height=\"', toFixed(this.height, NUM_FRACTION_DIGITS), '\"></rect>\\n');\n            }\n        },\n        /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toSVG: function(reviver) {\n            return this._createBaseSVGMarkup(this._toSVG(reviver), {\n                reviver: reviver\n            });\n        },\n        /**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toClipPathSVG: function(reviver) {\n            return \"\t\" + this._createBaseClipPathSVGMarkup(this._toSVG(reviver), {\n                reviver: reviver\n            });\n        },\n        /**\n     * @private\n     */ _createBaseClipPathSVGMarkup: function(objectMarkup, options) {\n            options = options || {};\n            var reviver = options.reviver, additionalTransform = options.additionalTransform || \"\", commonPieces = [\n                this.getSvgTransform(true, additionalTransform),\n                this.getSvgCommons()\n            ].join(\"\"), // insert commons in the markup, style and svgCommons\n            index = objectMarkup.indexOf(\"COMMON_PARTS\");\n            objectMarkup[index] = commonPieces;\n            return reviver ? reviver(objectMarkup.join(\"\")) : objectMarkup.join(\"\");\n        },\n        /**\n     * @private\n     */ _createBaseSVGMarkup: function(objectMarkup, options) {\n            options = options || {};\n            var noStyle = options.noStyle, reviver = options.reviver, styleInfo = noStyle ? \"\" : 'style=\"' + this.getSvgStyles() + '\" ', shadowInfo = options.withShadow ? 'style=\"' + this.getSvgFilter() + '\" ' : \"\", clipPath = this.clipPath, vectorEffect = this.strokeUniform ? 'vector-effect=\"non-scaling-stroke\" ' : \"\", absoluteClipPath = clipPath && clipPath.absolutePositioned, stroke = this.stroke, fill = this.fill, shadow = this.shadow, commonPieces, markup = [], clipPathMarkup, // insert commons in the markup, style and svgCommons\n            index = objectMarkup.indexOf(\"COMMON_PARTS\"), additionalTransform = options.additionalTransform;\n            if (clipPath) {\n                clipPath.clipPathId = \"CLIPPATH_\" + fabric.Object.__uid++;\n                clipPathMarkup = '<clipPath id=\"' + clipPath.clipPathId + '\" >\\n' + clipPath.toClipPathSVG(reviver) + \"</clipPath>\\n\";\n            }\n            if (absoluteClipPath) {\n                markup.push(\"<g \", shadowInfo, this.getSvgCommons(), \" >\\n\");\n            }\n            markup.push(\"<g \", this.getSvgTransform(false), !absoluteClipPath ? shadowInfo + this.getSvgCommons() : \"\", \" >\\n\");\n            commonPieces = [\n                styleInfo,\n                vectorEffect,\n                noStyle ? \"\" : this.addPaintOrder(),\n                \" \",\n                additionalTransform ? 'transform=\"' + additionalTransform + '\" ' : \"\"\n            ].join(\"\");\n            objectMarkup[index] = commonPieces;\n            if (fill && fill.toLive) {\n                markup.push(fill.toSVG(this));\n            }\n            if (stroke && stroke.toLive) {\n                markup.push(stroke.toSVG(this));\n            }\n            if (shadow) {\n                markup.push(shadow.toSVG(this));\n            }\n            if (clipPath) {\n                markup.push(clipPathMarkup);\n            }\n            markup.push(objectMarkup.join(\"\"));\n            markup.push(\"</g>\\n\");\n            absoluteClipPath && markup.push(\"</g>\\n\");\n            return reviver ? reviver(markup.join(\"\")) : markup.join(\"\");\n        },\n        addPaintOrder: function() {\n            return this.paintFirst !== \"fill\" ? ' paint-order=\"' + this.paintFirst + '\" ' : \"\";\n        }\n    });\n})();\n/* _TO_SVG_END_ */ (function() {\n    var extend = fabric.util.object.extend, originalSet = \"stateProperties\";\n    /*\n    Depends on `stateProperties`\n  */ function saveProps(origin, destination, props) {\n        var tmpObj = {}, deep = true;\n        props.forEach(function(prop) {\n            tmpObj[prop] = origin[prop];\n        });\n        extend(origin[destination], tmpObj, deep);\n    }\n    function _isEqual(origValue, currentValue, firstPass) {\n        if (origValue === currentValue) {\n            // if the objects are identical, return\n            return true;\n        } else if (Array.isArray(origValue)) {\n            if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {\n                return false;\n            }\n            for(var i = 0, len = origValue.length; i < len; i++){\n                if (!_isEqual(origValue[i], currentValue[i])) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (origValue && typeof origValue === \"object\") {\n            var keys = Object.keys(origValue), key;\n            if (!currentValue || typeof currentValue !== \"object\" || !firstPass && keys.length !== Object.keys(currentValue).length) {\n                return false;\n            }\n            for(var i = 0, len = keys.length; i < len; i++){\n                key = keys[i];\n                // since clipPath is in the statefull cache list and the clipPath objects\n                // would be iterated as an object, this would lead to possible infinite recursion\n                // we do not want to compare those.\n                if (key === \"canvas\" || key === \"group\") {\n                    continue;\n                }\n                if (!_isEqual(origValue[key], currentValue[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Returns true if object state (one of its state properties) was changed\n     * @param {String} [propertySet] optional name for the set of property we want to save\n     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called\n     */ hasStateChanged: function(propertySet) {\n            propertySet = propertySet || originalSet;\n            var dashedPropertySet = \"_\" + propertySet;\n            if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {\n                return true;\n            }\n            return !_isEqual(this[dashedPropertySet], this, true);\n        },\n        /**\n     * Saves state of an object\n     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\n     * @return {fabric.Object} thisArg\n     */ saveState: function(options) {\n            var propertySet = options && options.propertySet || originalSet, destination = \"_\" + propertySet;\n            if (!this[destination]) {\n                return this.setupState(options);\n            }\n            saveProps(this, destination, this[propertySet]);\n            if (options && options.stateProperties) {\n                saveProps(this, destination, options.stateProperties);\n            }\n            return this;\n        },\n        /**\n     * Setups state of an object\n     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\n     * @return {fabric.Object} thisArg\n     */ setupState: function(options) {\n            options = options || {};\n            var propertySet = options.propertySet || originalSet;\n            options.propertySet = propertySet;\n            this[\"_\" + propertySet] = {};\n            this.saveState(options);\n            return this;\n        }\n    });\n})();\n(function() {\n    var degreesToRadians = fabric.util.degreesToRadians;\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Determines which corner has been clicked\n     * @private\n     * @param {Object} pointer The pointer indicating the mouse position\n     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found\n     */ _findTargetCorner: function(pointer, forTouch) {\n            // objects in group, anykind, are not self modificable,\n            // must not return an hovered corner.\n            if (!this.hasControls || this.group || !this.canvas || this.canvas._activeObject !== this) {\n                return false;\n            }\n            var ex = pointer.x, ey = pointer.y, xPoints, lines, keys = Object.keys(this.oCoords), j = keys.length - 1, i;\n            this.__corner = 0;\n            // cycle in reverse order so we pick first the one on top\n            for(; j >= 0; j--){\n                i = keys[j];\n                if (!this.isControlVisible(i)) {\n                    continue;\n                }\n                lines = this._getImageLines(forTouch ? this.oCoords[i].touchCorner : this.oCoords[i].corner);\n                // // debugging\n                //\n                // this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);\n                //\n                // this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);\n                //\n                // this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);\n                //\n                // this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);\n                xPoints = this._findCrossPoints({\n                    x: ex,\n                    y: ey\n                }, lines);\n                if (xPoints !== 0 && xPoints % 2 === 1) {\n                    this.__corner = i;\n                    return i;\n                }\n            }\n            return false;\n        },\n        /**\n     * Calls a function for each control. The function gets called,\n     * with the control, the object that is calling the iterator and the control's key\n     * @param {Function} fn function to iterate over the controls over\n     */ forEachControl: function(fn) {\n            for(var i in this.controls){\n                fn(this.controls[i], i, this);\n            }\n            ;\n        },\n        /**\n     * Sets the coordinates of the draggable boxes in the corners of\n     * the image used to scale/rotate it.\n     * note: if we would switch to ROUND corner area, all of this would disappear.\n     * everything would resolve to a single point and a pythagorean theorem for the distance\n     * @private\n     */ _setCornerCoords: function() {\n            var coords = this.oCoords;\n            for(var control in coords){\n                var controlObject = this.controls[control];\n                coords[control].corner = controlObject.calcCornerCoords(this.angle, this.cornerSize, coords[control].x, coords[control].y, false);\n                coords[control].touchCorner = controlObject.calcCornerCoords(this.angle, this.touchCornerSize, coords[control].x, coords[control].y, true);\n            }\n        },\n        /**\n     * Draws a colored layer behind the object, inside its selection borders.\n     * Requires public options: padding, selectionBackgroundColor\n     * this function is called when the context is transformed\n     * has checks to be skipped when the object is on a staticCanvas\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawSelectionBackground: function(ctx) {\n            if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this) {\n                return this;\n            }\n            ctx.save();\n            var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(), vpt = this.canvas.viewportTransform;\n            ctx.translate(center.x, center.y);\n            ctx.scale(1 / vpt[0], 1 / vpt[3]);\n            ctx.rotate(degreesToRadians(this.angle));\n            ctx.fillStyle = this.selectionBackgroundColor;\n            ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Draws borders of an object's bounding box.\n     * Requires public properties: width, height\n     * Requires public options: padding, borderColor\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawBorders: function(ctx, styleOverride) {\n            styleOverride = styleOverride || {};\n            var wh = this._calculateCurrentDimensions(), strokeWidth = this.borderScaleFactor, width = wh.x + strokeWidth, height = wh.y + strokeWidth, hasControls = typeof styleOverride.hasControls !== \"undefined\" ? styleOverride.hasControls : this.hasControls, shouldStroke = false;\n            ctx.save();\n            ctx.strokeStyle = styleOverride.borderColor || this.borderColor;\n            this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);\n            ctx.strokeRect(-width / 2, -height / 2, width, height);\n            if (hasControls) {\n                ctx.beginPath();\n                this.forEachControl(function(control, key, fabricObject) {\n                    // in this moment, the ctx is centered on the object.\n                    // width and height of the above function are the size of the bbox.\n                    if (control.withConnection && control.getVisibility(fabricObject, key)) {\n                        // reset movement for each control\n                        shouldStroke = true;\n                        ctx.moveTo(control.x * width, control.y * height);\n                        ctx.lineTo(control.x * width + control.offsetX, control.y * height + control.offsetY);\n                    }\n                });\n                if (shouldStroke) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Draws borders of an object's bounding box when it is inside a group.\n     * Requires public properties: width, height\n     * Requires public options: padding, borderColor\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {object} options object representing current object parameters\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawBordersInGroup: function(ctx, options, styleOverride) {\n            styleOverride = styleOverride || {};\n            var bbox = fabric.util.sizeAfterTransform(this.width, this.height, options), strokeWidth = this.strokeWidth, strokeUniform = this.strokeUniform, borderScaleFactor = this.borderScaleFactor, width = bbox.x + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleX) + borderScaleFactor, height = bbox.y + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleY) + borderScaleFactor;\n            ctx.save();\n            this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);\n            ctx.strokeStyle = styleOverride.borderColor || this.borderColor;\n            ctx.strokeRect(-width / 2, -height / 2, width, height);\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Draws corners of an object's bounding box.\n     * Requires public properties: width, height\n     * Requires public options: cornerSize, padding\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawControls: function(ctx, styleOverride) {\n            styleOverride = styleOverride || {};\n            ctx.save();\n            var retinaScaling = this.canvas.getRetinaScaling(), matrix, p;\n            ctx.setTransform(retinaScaling, 0, 0, retinaScaling, 0, 0);\n            ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;\n            if (!this.transparentCorners) {\n                ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;\n            }\n            this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray);\n            this.setCoords();\n            if (this.group) {\n                // fabricJS does not really support drawing controls inside groups,\n                // this piece of code here helps having at least the control in places.\n                // If an application needs to show some objects as selected because of some UI state\n                // can still call Object._renderControls() on any object they desire, independently of groups.\n                // using no padding, circular controls and hiding the rotating cursor is higly suggested,\n                matrix = this.group.calcTransformMatrix();\n            }\n            this.forEachControl(function(control, key, fabricObject) {\n                p = fabricObject.oCoords[key];\n                if (control.getVisibility(fabricObject, key)) {\n                    if (matrix) {\n                        p = fabric.util.transformPoint(p, matrix);\n                    }\n                    control.render(ctx, p.x, p.y, styleOverride, fabricObject);\n                }\n            });\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Returns true if the specified control is visible, false otherwise.\n     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\n     * @returns {Boolean} true if the specified control is visible, false otherwise\n     */ isControlVisible: function(controlKey) {\n            return this.controls[controlKey] && this.controls[controlKey].getVisibility(this, controlKey);\n        },\n        /**\n     * Sets the visibility of the specified control.\n     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\n     * @param {Boolean} visible true to set the specified control visible, false otherwise\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ setControlVisible: function(controlKey, visible) {\n            if (!this._controlsVisibility) {\n                this._controlsVisibility = {};\n            }\n            this._controlsVisibility[controlKey] = visible;\n            return this;\n        },\n        /**\n     * Sets the visibility state of object controls.\n     * @param {Object} [options] Options object\n     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it\n     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it\n     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it\n     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it\n     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it\n     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it\n     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it\n     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it\n     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ setControlsVisibility: function(options) {\n            options || (options = {});\n            for(var p in options){\n                this.setControlVisible(p, options[p]);\n            }\n            return this;\n        },\n        /**\n     * This callback function is called every time _discardActiveObject or _setActiveObject\n     * try to to deselect this object. If the function returns true, the process is cancelled\n     * @param {Object} [options] options sent from the upper functions\n     * @param {Event} [options.e] event if the process is generated by an event\n     */ onDeselect: function() {\n        // implemented by sub-classes, as needed.\n        },\n        /**\n     * This callback function is called every time _discardActiveObject or _setActiveObject\n     * try to to select this object. If the function returns true, the process is cancelled\n     * @param {Object} [options] options sent from the upper functions\n     * @param {Event} [options.e] event if the process is generated by an event\n     */ onSelect: function() {\n        // implemented by sub-classes, as needed.\n        }\n    });\n})();\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n    /**\n   * Animation duration (in ms) for fx* methods\n   * @type Number\n   * @default\n   */ FX_DURATION: 500,\n    /**\n   * Centers object horizontally with animation.\n   * @param {fabric.Object} object Object to center\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.AnimationContext} context\n   */ fxCenterObjectH: function(object, callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: object.left,\n            endValue: this.getCenterPoint().x,\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                object.set(\"left\", value);\n                _this.requestRenderAll();\n                onChange();\n            },\n            onComplete: function() {\n                object.setCoords();\n                onComplete();\n            }\n        });\n    },\n    /**\n   * Centers object vertically with animation.\n   * @param {fabric.Object} object Object to center\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.AnimationContext} context\n   */ fxCenterObjectV: function(object, callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: object.top,\n            endValue: this.getCenterPoint().y,\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                object.set(\"top\", value);\n                _this.requestRenderAll();\n                onChange();\n            },\n            onComplete: function() {\n                object.setCoords();\n                onComplete();\n            }\n        });\n    },\n    /**\n   * Same as `fabric.Canvas#remove` but animated\n   * @param {fabric.Object} object Object to remove\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.AnimationContext} context\n   */ fxRemove: function(object, callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: object.opacity,\n            endValue: 0,\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                object.set(\"opacity\", value);\n                _this.requestRenderAll();\n                onChange();\n            },\n            onComplete: function() {\n                _this.remove(object);\n                onComplete();\n            }\n        });\n    }\n});\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n    /**\n   * Animates object's properties\n   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)\n   * @param {Number|Object} value Value to animate property to (if string was given first) or options object\n   * @return {fabric.Object} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}\n   * @return {fabric.AnimationContext | fabric.AnimationContext[]} animation context (or an array if passed multiple properties)\n   *\n   * As object  multiple properties\n   *\n   * object.animate({ left: ..., top: ... });\n   * object.animate({ left: ..., top: ... }, { duration: ... });\n   *\n   * As string  one property\n   *\n   * object.animate('left', ...);\n   * object.animate('left', { duration: ... });\n   *\n   */ animate: function() {\n        if (arguments[0] && typeof arguments[0] === \"object\") {\n            var propsToAnimate = [], prop, skipCallbacks, out = [];\n            for(prop in arguments[0]){\n                propsToAnimate.push(prop);\n            }\n            for(var i = 0, len = propsToAnimate.length; i < len; i++){\n                prop = propsToAnimate[i];\n                skipCallbacks = i !== len - 1;\n                out.push(this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks));\n            }\n            return out;\n        } else {\n            return this._animate.apply(this, arguments);\n        }\n    },\n    /**\n   * @private\n   * @param {String} property Property to animate\n   * @param {String} to Value to animate to\n   * @param {Object} [options] Options object\n   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked\n   */ _animate: function(property, to, options, skipCallbacks) {\n        var _this = this, propPair;\n        to = to.toString();\n        if (!options) {\n            options = {};\n        } else {\n            options = fabric.util.object.clone(options);\n        }\n        if (~property.indexOf(\".\")) {\n            propPair = property.split(\".\");\n        }\n        var propIsColor = _this.colorProperties.indexOf(property) > -1 || propPair && _this.colorProperties.indexOf(propPair[1]) > -1;\n        var currentValue = propPair ? this.get(propPair[0])[propPair[1]] : this.get(property);\n        if (!(\"from\" in options)) {\n            options.from = currentValue;\n        }\n        if (!propIsColor) {\n            if (~to.indexOf(\"=\")) {\n                to = currentValue + parseFloat(to.replace(\"=\", \"\"));\n            } else {\n                to = parseFloat(to);\n            }\n        }\n        var _options = {\n            target: this,\n            startValue: options.from,\n            endValue: to,\n            byValue: options.by,\n            easing: options.easing,\n            duration: options.duration,\n            abort: options.abort && function(value, valueProgress, timeProgress) {\n                return options.abort.call(_this, value, valueProgress, timeProgress);\n            },\n            onChange: function(value, valueProgress, timeProgress) {\n                if (propPair) {\n                    _this[propPair[0]][propPair[1]] = value;\n                } else {\n                    _this.set(property, value);\n                }\n                if (skipCallbacks) {\n                    return;\n                }\n                options.onChange && options.onChange(value, valueProgress, timeProgress);\n            },\n            onComplete: function(value, valueProgress, timeProgress) {\n                if (skipCallbacks) {\n                    return;\n                }\n                _this.setCoords();\n                options.onComplete && options.onComplete(value, valueProgress, timeProgress);\n            }\n        };\n        if (propIsColor) {\n            return fabric.util.animateColor(_options.startValue, _options.endValue, _options.duration, _options);\n        } else {\n            return fabric.util.animate(_options);\n        }\n    }\n});\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, clone = fabric.util.object.clone, coordProps = {\n        x1: 1,\n        x2: 1,\n        y1: 1,\n        y2: 1\n    };\n    if (fabric.Line) {\n        fabric.warn(\"fabric.Line is already defined\");\n        return;\n    }\n    /**\n   * Line class\n   * @class fabric.Line\n   * @extends fabric.Object\n   * @see {@link fabric.Line#initialize} for constructor definition\n   */ fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"line\",\n        /**\n     * x value or first line edge\n     * @type Number\n     * @default\n     */ x1: 0,\n        /**\n     * y value or first line edge\n     * @type Number\n     * @default\n     */ y1: 0,\n        /**\n     * x value or second line edge\n     * @type Number\n     * @default\n     */ x2: 0,\n        /**\n     * y value or second line edge\n     * @type Number\n     * @default\n     */ y2: 0,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"x1\", \"x2\", \"y1\", \"y2\"),\n        /**\n     * Constructor\n     * @param {Array} [points] Array of points\n     * @param {Object} [options] Options object\n     * @return {fabric.Line} thisArg\n     */ initialize: function(points, options) {\n            if (!points) {\n                points = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n            }\n            this.callSuper(\"initialize\", options);\n            this.set(\"x1\", points[0]);\n            this.set(\"y1\", points[1]);\n            this.set(\"x2\", points[2]);\n            this.set(\"y2\", points[3]);\n            this._setWidthHeight(options);\n        },\n        /**\n     * @private\n     * @param {Object} [options] Options\n     */ _setWidthHeight: function(options) {\n            options || (options = {});\n            this.width = Math.abs(this.x2 - this.x1);\n            this.height = Math.abs(this.y2 - this.y1);\n            this.left = \"left\" in options ? options.left : this._getLeftToOriginX();\n            this.top = \"top\" in options ? options.top : this._getTopToOriginY();\n        },\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     */ _set: function(key, value) {\n            this.callSuper(\"_set\", key, value);\n            if (typeof coordProps[key] !== \"undefined\") {\n                this._setWidthHeight();\n            }\n            return this;\n        },\n        /**\n     * @private\n     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.\n     */ _getLeftToOriginX: makeEdgeToOriginGetter({\n            origin: \"originX\",\n            axis1: \"x1\",\n            axis2: \"x2\",\n            dimension: \"width\"\n        }, {\n            nearest: \"left\",\n            center: \"center\",\n            farthest: \"right\"\n        }),\n        /**\n     * @private\n     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.\n     */ _getTopToOriginY: makeEdgeToOriginGetter({\n            origin: \"originY\",\n            axis1: \"y1\",\n            axis2: \"y2\",\n            dimension: \"height\"\n        }, {\n            nearest: \"top\",\n            center: \"center\",\n            farthest: \"bottom\"\n        }),\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            ctx.beginPath();\n            var p = this.calcLinePoints();\n            ctx.moveTo(p.x1, p.y1);\n            ctx.lineTo(p.x2, p.y2);\n            ctx.lineWidth = this.strokeWidth;\n            // TODO: test this\n            // make sure setting \"fill\" changes color of a line\n            // (by copying fillStyle to strokeStyle, since line is stroked, not filled)\n            var origStrokeStyle = ctx.strokeStyle;\n            ctx.strokeStyle = this.stroke || ctx.fillStyle;\n            this.stroke && this._renderStroke(ctx);\n            ctx.strokeStyle = origStrokeStyle;\n        },\n        /**\n     * This function is an helper for svg import. it returns the center of the object in the svg\n     * untransformed coordinates\n     * @private\n     * @return {Object} center point from element coordinates\n     */ _findCenterFromElement: function() {\n            return {\n                x: (this.x1 + this.x2) / 2,\n                y: (this.y1 + this.y2) / 2\n            };\n        },\n        /**\n     * Returns object representation of an instance\n     * @method toObject\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return extend(this.callSuper(\"toObject\", propertiesToInclude), this.calcLinePoints());\n        },\n        /*\n     * Calculate object dimensions from its properties\n     * @private\n     */ _getNonTransformedDimensions: function() {\n            var dim = this.callSuper(\"_getNonTransformedDimensions\");\n            if (this.strokeLineCap === \"butt\") {\n                if (this.width === 0) {\n                    dim.y -= this.strokeWidth;\n                }\n                if (this.height === 0) {\n                    dim.x -= this.strokeWidth;\n                }\n            }\n            return dim;\n        },\n        /**\n     * Recalculates line points given width and height\n     * @private\n     */ calcLinePoints: function() {\n            var xMult = this.x1 <= this.x2 ? -1 : 1, yMult = this.y1 <= this.y2 ? -1 : 1, x1 = xMult * this.width * 0.5, y1 = yMult * this.height * 0.5, x2 = xMult * this.width * -0.5, y2 = yMult * this.height * -0.5;\n            return {\n                x1: x1,\n                x2: x2,\n                y1: y1,\n                y2: y2\n            };\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var p = this.calcLinePoints();\n            return [\n                \"<line \",\n                \"COMMON_PARTS\",\n                'x1=\"',\n                p.x1,\n                '\" y1=\"',\n                p.y1,\n                '\" x2=\"',\n                p.x2,\n                '\" y2=\"',\n                p.y2,\n                '\" />\\n'\n            ];\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})\n   * @static\n   * @memberOf fabric.Line\n   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement\n   */ fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x1 y1 x2 y2\".split(\" \"));\n    /**\n   * Returns fabric.Line instance from an SVG element\n   * @static\n   * @memberOf fabric.Line\n   * @param {SVGElement} element Element to parse\n   * @param {Object} [options] Options object\n   * @param {Function} [callback] callback function invoked after parsing\n   */ fabric.Line.fromElement = function(element, callback, options) {\n        options = options || {};\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES), points = [\n            parsedAttributes.x1 || 0,\n            parsedAttributes.y1 || 0,\n            parsedAttributes.x2 || 0,\n            parsedAttributes.y2 || 0\n        ];\n        callback(new fabric.Line(points, extend(parsedAttributes, options)));\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Line instance from an object representation\n   * @static\n   * @memberOf fabric.Line\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   */ fabric.Line.fromObject = function(object, callback) {\n        function _callback(instance) {\n            delete instance.points;\n            callback && callback(instance);\n        }\n        ;\n        var options = clone(object, true);\n        options.points = [\n            object.x1,\n            object.y1,\n            object.x2,\n            object.y2\n        ];\n        fabric.Object._fromObject(\"Line\", options, _callback, \"points\");\n    };\n    /**\n   * Produces a function that calculates distance from canvas edge to Line origin.\n   */ function makeEdgeToOriginGetter(propertyNames, originValues) {\n        var origin = propertyNames.origin, axis1 = propertyNames.axis1, axis2 = propertyNames.axis2, dimension = propertyNames.dimension, nearest = originValues.nearest, center = originValues.center, farthest = originValues.farthest;\n        return function() {\n            switch(this.get(origin)){\n                case nearest:\n                    return Math.min(this.get(axis1), this.get(axis2));\n                case center:\n                    return Math.min(this.get(axis1), this.get(axis2)) + 0.5 * this.get(dimension);\n                case farthest:\n                    return Math.max(this.get(axis1), this.get(axis2));\n            }\n        };\n    }\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), degreesToRadians = fabric.util.degreesToRadians;\n    if (fabric.Circle) {\n        fabric.warn(\"fabric.Circle is already defined.\");\n        return;\n    }\n    /**\n   * Circle class\n   * @class fabric.Circle\n   * @extends fabric.Object\n   * @see {@link fabric.Circle#initialize} for constructor definition\n   */ fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"circle\",\n        /**\n     * Radius of this circle\n     * @type Number\n     * @default\n     */ radius: 0,\n        /**\n     * degrees of start of the circle.\n     * probably will change to degrees in next major version\n     * @type Number 0 - 359\n     * @default 0\n     */ startAngle: 0,\n        /**\n     * End angle of the circle\n     * probably will change to degrees in next major version\n     * @type Number 1 - 360\n     * @default 360\n     */ endAngle: 360,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"radius\", \"startAngle\", \"endAngle\"),\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Circle} thisArg\n     */ _set: function(key, value) {\n            this.callSuper(\"_set\", key, value);\n            if (key === \"radius\") {\n                this.setRadius(value);\n            }\n            return this;\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"radius\",\n                \"startAngle\",\n                \"endAngle\"\n            ].concat(propertiesToInclude));\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var svgString, x = 0, y = 0, angle = (this.endAngle - this.startAngle) % 360;\n            if (angle === 0) {\n                svgString = [\n                    \"<circle \",\n                    \"COMMON_PARTS\",\n                    'cx=\"' + x + '\" cy=\"' + y + '\" ',\n                    'r=\"',\n                    this.radius,\n                    '\" />\\n'\n                ];\n            } else {\n                var start = degreesToRadians(this.startAngle), end = degreesToRadians(this.endAngle), radius = this.radius, startX = fabric.util.cos(start) * radius, startY = fabric.util.sin(start) * radius, endX = fabric.util.cos(end) * radius, endY = fabric.util.sin(end) * radius, largeFlag = angle > 180 ? \"1\" : \"0\";\n                svgString = [\n                    '<path d=\"M ' + startX + \" \" + startY,\n                    \" A \" + radius + \" \" + radius,\n                    \" 0 \",\n                    +largeFlag + \" 1\",\n                    \" \" + endX + \" \" + endY,\n                    '\" ',\n                    \"COMMON_PARTS\",\n                    \" />\\n\"\n                ];\n            }\n            return svgString;\n        },\n        /* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render on\n     */ _render: function(ctx) {\n            ctx.beginPath();\n            ctx.arc(0, 0, this.radius, degreesToRadians(this.startAngle), degreesToRadians(this.endAngle), false);\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns horizontal radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRadiusX: function() {\n            return this.get(\"radius\") * this.get(\"scaleX\");\n        },\n        /**\n     * Returns vertical radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRadiusY: function() {\n            return this.get(\"radius\") * this.get(\"scaleY\");\n        },\n        /**\n     * Sets radius of an object (and updates width accordingly)\n     * @return {fabric.Circle} thisArg\n     */ setRadius: function(value) {\n            this.radius = value;\n            return this.set(\"width\", value * 2).set(\"height\", value * 2);\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})\n   * @static\n   * @memberOf fabric.Circle\n   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement\n   */ fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"cx cy r\".split(\" \"));\n    /**\n   * Returns {@link fabric.Circle} instance from an SVG element\n   * @static\n   * @memberOf fabric.Circle\n   * @param {SVGElement} element Element to parse\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   * @param {Object} [options] Options object\n   * @throws {Error} If value of `r` attribute is missing or invalid\n   */ fabric.Circle.fromElement = function(element, callback) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);\n        if (!isValidRadius(parsedAttributes)) {\n            throw new Error(\"value of `r` attribute is required and can not be negative\");\n        }\n        parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;\n        parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;\n        callback(new fabric.Circle(parsedAttributes));\n    };\n    /**\n   * @private\n   */ function isValidRadius(attributes) {\n        return \"radius\" in attributes && attributes.radius >= 0;\n    }\n    /* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Circle} instance from an object representation\n   * @static\n   * @memberOf fabric.Circle\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   * @return {void}\n   */ fabric.Circle.fromObject = function(object, callback) {\n        fabric.Object._fromObject(\"Circle\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Triangle) {\n        fabric.warn(\"fabric.Triangle is already defined\");\n        return;\n    }\n    /**\n   * Triangle class\n   * @class fabric.Triangle\n   * @extends fabric.Object\n   * @return {fabric.Triangle} thisArg\n   * @see {@link fabric.Triangle#initialize} for constructor definition\n   */ fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"triangle\",\n        /**\n     * Width is set to 100 to compensate the old initialize code that was setting it to 100\n     * @type Number\n     * @default\n     */ width: 100,\n        /**\n     * Height is set to 100 to compensate the old initialize code that was setting it to 100\n     * @type Number\n     * @default\n     */ height: 100,\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            var widthBy2 = this.width / 2, heightBy2 = this.height / 2;\n            ctx.beginPath();\n            ctx.moveTo(-widthBy2, heightBy2);\n            ctx.lineTo(0, -heightBy2);\n            ctx.lineTo(widthBy2, heightBy2);\n            ctx.closePath();\n            this._renderPaintInOrder(ctx);\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var widthBy2 = this.width / 2, heightBy2 = this.height / 2, points = [\n                -widthBy2 + \" \" + heightBy2,\n                \"0 \" + -heightBy2,\n                widthBy2 + \" \" + heightBy2\n            ].join(\",\");\n            return [\n                \"<polygon \",\n                \"COMMON_PARTS\",\n                'points=\"',\n                points,\n                '\" />'\n            ];\n        }\n    });\n    /**\n   * Returns {@link fabric.Triangle} instance from an object representation\n   * @static\n   * @memberOf fabric.Triangle\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   */ fabric.Triangle.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Triangle\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), piBy2 = Math.PI * 2;\n    if (fabric.Ellipse) {\n        fabric.warn(\"fabric.Ellipse is already defined.\");\n        return;\n    }\n    /**\n   * Ellipse class\n   * @class fabric.Ellipse\n   * @extends fabric.Object\n   * @return {fabric.Ellipse} thisArg\n   * @see {@link fabric.Ellipse#initialize} for constructor definition\n   */ fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"ellipse\",\n        /**\n     * Horizontal radius\n     * @type Number\n     * @default\n     */ rx: 0,\n        /**\n     * Vertical radius\n     * @type Number\n     * @default\n     */ ry: 0,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"rx\", \"ry\"),\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @return {fabric.Ellipse} thisArg\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            this.set(\"rx\", options && options.rx || 0);\n            this.set(\"ry\", options && options.ry || 0);\n        },\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Ellipse} thisArg\n     */ _set: function(key, value) {\n            this.callSuper(\"_set\", key, value);\n            switch(key){\n                case \"rx\":\n                    this.rx = value;\n                    this.set(\"width\", value * 2);\n                    break;\n                case \"ry\":\n                    this.ry = value;\n                    this.set(\"height\", value * 2);\n                    break;\n            }\n            return this;\n        },\n        /**\n     * Returns horizontal radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRx: function() {\n            return this.get(\"rx\") * this.get(\"scaleX\");\n        },\n        /**\n     * Returns Vertical radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRy: function() {\n            return this.get(\"ry\") * this.get(\"scaleY\");\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"rx\",\n                \"ry\"\n            ].concat(propertiesToInclude));\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            return [\n                \"<ellipse \",\n                \"COMMON_PARTS\",\n                'cx=\"0\" cy=\"0\" ',\n                'rx=\"',\n                this.rx,\n                '\" ry=\"',\n                this.ry,\n                '\" />\\n'\n            ];\n        },\n        /* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render on\n     */ _render: function(ctx) {\n            ctx.beginPath();\n            ctx.save();\n            ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);\n            ctx.arc(0, 0, this.rx, 0, piBy2, false);\n            ctx.restore();\n            this._renderPaintInOrder(ctx);\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})\n   * @static\n   * @memberOf fabric.Ellipse\n   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement\n   */ fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"cx cy rx ry\".split(\" \"));\n    /**\n   * Returns {@link fabric.Ellipse} instance from an SVG element\n   * @static\n   * @memberOf fabric.Ellipse\n   * @param {SVGElement} element Element to parse\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   * @return {fabric.Ellipse}\n   */ fabric.Ellipse.fromElement = function(element, callback) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);\n        parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;\n        parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;\n        callback(new fabric.Ellipse(parsedAttributes));\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Ellipse} instance from an object representation\n   * @static\n   * @memberOf fabric.Ellipse\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   * @return {void}\n   */ fabric.Ellipse.fromObject = function(object, callback) {\n        fabric.Object._fromObject(\"Ellipse\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend;\n    if (fabric.Rect) {\n        fabric.warn(\"fabric.Rect is already defined\");\n        return;\n    }\n    /**\n   * Rectangle class\n   * @class fabric.Rect\n   * @extends fabric.Object\n   * @return {fabric.Rect} thisArg\n   * @see {@link fabric.Rect#initialize} for constructor definition\n   */ fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {\n        /**\n     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: fabric.Object.prototype.stateProperties.concat(\"rx\", \"ry\"),\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"rect\",\n        /**\n     * Horizontal border radius\n     * @type Number\n     * @default\n     */ rx: 0,\n        /**\n     * Vertical border radius\n     * @type Number\n     * @default\n     */ ry: 0,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"rx\", \"ry\"),\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            this._initRxRy();\n        },\n        /**\n     * Initializes rx/ry attributes\n     * @private\n     */ _initRxRy: function() {\n            if (this.rx && !this.ry) {\n                this.ry = this.rx;\n            } else if (this.ry && !this.rx) {\n                this.rx = this.ry;\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            // 1x1 case (used in spray brush) optimization was removed because\n            // with caching and higher zoom level this makes more damage than help\n            var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0, ry = this.ry ? Math.min(this.ry, this.height / 2) : 0, w = this.width, h = this.height, x = -this.width / 2, y = -this.height / 2, isRounded = rx !== 0 || ry !== 0, /* \"magic number\" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */ k = 1 - 0.5522847498;\n            ctx.beginPath();\n            ctx.moveTo(x + rx, y);\n            ctx.lineTo(x + w - rx, y);\n            isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);\n            ctx.lineTo(x + w, y + h - ry);\n            isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);\n            ctx.lineTo(x + rx, y + h);\n            isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);\n            ctx.lineTo(x, y + ry);\n            isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);\n            ctx.closePath();\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"rx\",\n                \"ry\"\n            ].concat(propertiesToInclude));\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var x = -this.width / 2, y = -this.height / 2;\n            return [\n                \"<rect \",\n                \"COMMON_PARTS\",\n                'x=\"',\n                x,\n                '\" y=\"',\n                y,\n                '\" rx=\"',\n                this.rx,\n                '\" ry=\"',\n                this.ry,\n                '\" width=\"',\n                this.width,\n                '\" height=\"',\n                this.height,\n                '\" />\\n'\n            ];\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)\n   * @static\n   * @memberOf fabric.Rect\n   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement\n   */ fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x y rx ry width height\".split(\" \"));\n    /**\n   * Returns {@link fabric.Rect} instance from an SVG element\n   * @static\n   * @memberOf fabric.Rect\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Rect.fromElement = function(element, callback, options) {\n        if (!element) {\n            return callback(null);\n        }\n        options = options || {};\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);\n        parsedAttributes.left = parsedAttributes.left || 0;\n        parsedAttributes.top = parsedAttributes.top || 0;\n        parsedAttributes.height = parsedAttributes.height || 0;\n        parsedAttributes.width = parsedAttributes.width || 0;\n        var rect = new fabric.Rect(extend(options ? fabric.util.object.clone(options) : {}, parsedAttributes));\n        rect.visible = rect.visible && rect.width > 0 && rect.height > 0;\n        callback(rect);\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Rect} instance from an object representation\n   * @static\n   * @memberOf fabric.Rect\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created\n   */ fabric.Rect.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Rect\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, min = fabric.util.array.min, max = fabric.util.array.max, toFixed = fabric.util.toFixed, projectStrokeOnPoints = fabric.util.projectStrokeOnPoints;\n    if (fabric.Polyline) {\n        fabric.warn(\"fabric.Polyline is already defined\");\n        return;\n    }\n    /**\n   * Polyline class\n   * @class fabric.Polyline\n   * @extends fabric.Object\n   * @see {@link fabric.Polyline#initialize} for constructor definition\n   */ fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"polyline\",\n        /**\n     * Points array\n     * @type Array\n     * @default\n     */ points: null,\n        /**\n     * WARNING: Feature in progress\n     * Calculate the exact bounding box taking in account strokeWidth on acute angles\n     * this will be turned to true by default on fabric 6.0\n     * maybe will be left in as an optimization since calculations may be slow\n     * @deprecated\n     * @type Boolean\n     * @default false\n     */ exactBoundingBox: false,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"points\"),\n        /**\n     * Constructor\n     * @param {Array} points Array of points (where each point is an object with x and y)\n     * @param {Object} [options] Options object\n     * @return {fabric.Polyline} thisArg\n     * @example\n     * var poly = new fabric.Polyline([\n     *     { x: 10, y: 10 },\n     *     { x: 50, y: 30 },\n     *     { x: 40, y: 70 },\n     *     { x: 60, y: 50 },\n     *     { x: 100, y: 150 },\n     *     { x: 40, y: 100 }\n     *   ], {\n     *   stroke: 'red',\n     *   left: 100,\n     *   top: 100\n     * });\n     */ initialize: function(points, options) {\n            options = options || {};\n            this.points = points || [];\n            this.callSuper(\"initialize\", options);\n            this._setPositionDimensions(options);\n        },\n        /**\n     * @private\n     */ _projectStrokeOnPoints: function() {\n            return projectStrokeOnPoints(this.points, this, true);\n        },\n        _setPositionDimensions: function(options) {\n            var calcDim = this._calcDimensions(options), correctLeftTop, correctSize = this.exactBoundingBox ? this.strokeWidth : 0;\n            this.width = calcDim.width - correctSize;\n            this.height = calcDim.height - correctSize;\n            if (!options.fromSVG) {\n                correctLeftTop = this.translateToGivenOrigin({\n                    // this looks bad, but is one way to keep it optional for now.\n                    x: calcDim.left - this.strokeWidth / 2 + correctSize / 2,\n                    y: calcDim.top - this.strokeWidth / 2 + correctSize / 2\n                }, \"left\", \"top\", this.originX, this.originY);\n            }\n            if (typeof options.left === \"undefined\") {\n                this.left = options.fromSVG ? calcDim.left : correctLeftTop.x;\n            }\n            if (typeof options.top === \"undefined\") {\n                this.top = options.fromSVG ? calcDim.top : correctLeftTop.y;\n            }\n            this.pathOffset = {\n                x: calcDim.left + this.width / 2 + correctSize / 2,\n                y: calcDim.top + this.height / 2 + correctSize / 2\n            };\n        },\n        /**\n     * Calculate the polygon min and max point from points array,\n     * returning an object with left, top, width, height to measure the\n     * polygon size\n     * @return {Object} object.left X coordinate of the polygon leftmost point\n     * @return {Object} object.top Y coordinate of the polygon topmost point\n     * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point\n     * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point\n     * @private\n     */ _calcDimensions: function() {\n            var points = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points, minX = min(points, \"x\") || 0, minY = min(points, \"y\") || 0, maxX = max(points, \"x\") || 0, maxY = max(points, \"y\") || 0, width = maxX - minX, height = maxY - minY;\n            return {\n                left: minX,\n                top: minY,\n                width: width,\n                height: height\n            };\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return extend(this.callSuper(\"toObject\", propertiesToInclude), {\n                points: this.points.concat()\n            });\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            for(var i = 0, len = this.points.length; i < len; i++){\n                points.push(toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), \",\", toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), \" \");\n            }\n            return [\n                \"<\" + this.type + \" \",\n                \"COMMON_PARTS\",\n                'points=\"',\n                points.join(\"\"),\n                '\" />\\n'\n            ];\n        },\n        /* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ commonRender: function(ctx) {\n            var point, len = this.points.length, x = this.pathOffset.x, y = this.pathOffset.y;\n            if (!len || isNaN(this.points[len - 1].y)) {\n                // do not draw if no points or odd points\n                // NaN comes from parseFloat of a empty string in parser\n                return false;\n            }\n            ctx.beginPath();\n            ctx.moveTo(this.points[0].x - x, this.points[0].y - y);\n            for(var i = 0; i < len; i++){\n                point = this.points[i];\n                ctx.lineTo(point.x - x, point.y - y);\n            }\n            return true;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            if (!this.commonRender(ctx)) {\n                return;\n            }\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns complexity of an instance\n     * @return {Number} complexity of this instance\n     */ complexity: function() {\n            return this.get(\"points\").length;\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})\n   * @static\n   * @memberOf fabric.Polyline\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement\n   */ fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\n    /**\n   * Returns fabric.Polyline instance from an SVG element\n   * @static\n   * @memberOf fabric.Polyline\n   * @param {SVGElement} element Element to parser\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Polyline.fromElementGenerator = function(_class) {\n        return function(element, callback, options) {\n            if (!element) {\n                return callback(null);\n            }\n            options || (options = {});\n            var points = fabric.parsePointsAttribute(element.getAttribute(\"points\")), parsedAttributes = fabric.parseAttributes(element, fabric[_class].ATTRIBUTE_NAMES);\n            parsedAttributes.fromSVG = true;\n            callback(new fabric[_class](points, extend(parsedAttributes, options)));\n        };\n    };\n    fabric.Polyline.fromElement = fabric.Polyline.fromElementGenerator(\"Polyline\");\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Polyline instance from an object representation\n   * @static\n   * @memberOf fabric.Polyline\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   */ fabric.Polyline.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Polyline\", object, callback, \"points\");\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), projectStrokeOnPoints = fabric.util.projectStrokeOnPoints;\n    if (fabric.Polygon) {\n        fabric.warn(\"fabric.Polygon is already defined\");\n        return;\n    }\n    /**\n   * Polygon class\n   * @class fabric.Polygon\n   * @extends fabric.Polyline\n   * @see {@link fabric.Polygon#initialize} for constructor definition\n   */ fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"polygon\",\n        /**\n     * @private\n     */ _projectStrokeOnPoints: function() {\n            return projectStrokeOnPoints(this.points, this);\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            if (!this.commonRender(ctx)) {\n                return;\n            }\n            ctx.closePath();\n            this._renderPaintInOrder(ctx);\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)\n   * @static\n   * @memberOf fabric.Polygon\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement\n   */ fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\n    /**\n   * Returns {@link fabric.Polygon} instance from an SVG element\n   * @static\n   * @memberOf fabric.Polygon\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Polygon.fromElement = fabric.Polyline.fromElementGenerator(\"Polygon\");\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Polygon instance from an object representation\n   * @static\n   * @memberOf fabric.Polygon\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   * @return {void}\n   */ fabric.Polygon.fromObject = function(object, callback) {\n        fabric.Object._fromObject(\"Polygon\", object, callback, \"points\");\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), min = fabric.util.array.min, max = fabric.util.array.max, extend = fabric.util.object.extend, clone = fabric.util.object.clone, toFixed = fabric.util.toFixed;\n    if (fabric.Path) {\n        fabric.warn(\"fabric.Path is already defined\");\n        return;\n    }\n    /**\n   * Path class\n   * @class fabric.Path\n   * @extends fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}\n   * @see {@link fabric.Path#initialize} for constructor definition\n   */ fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"path\",\n        /**\n     * Array of path points\n     * @type Array\n     * @default\n     */ path: null,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"path\", \"fillRule\"),\n        stateProperties: fabric.Object.prototype.stateProperties.concat(\"path\"),\n        /**\n     * Constructor\n     * @param {Array|String} path Path data (sequence of coordinates and corresponding \"command\" tokens)\n     * @param {Object} [options] Options object\n     * @return {fabric.Path} thisArg\n     */ initialize: function(path, options) {\n            options = clone(options || {});\n            delete options.path;\n            this.callSuper(\"initialize\", options);\n            this._setPath(path || [], options);\n        },\n        /**\n    * @private\n    * @param {Array|String} path Path data (sequence of coordinates and corresponding \"command\" tokens)\n    * @param {Object} [options] Options object\n    */ _setPath: function(path, options) {\n            this.path = fabric.util.makePathSimpler(Array.isArray(path) ? path : fabric.util.parsePath(path));\n            fabric.Polyline.prototype._setPositionDimensions.call(this, options || {});\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render path on\n     */ _renderPathCommands: function(ctx) {\n            var current, subpathStartX = 0, subpathStartY = 0, x = 0, y = 0, controlX = 0, controlY = 0, l = -this.pathOffset.x, t = -this.pathOffset.y;\n            ctx.beginPath();\n            for(var i = 0, len = this.path.length; i < len; ++i){\n                current = this.path[i];\n                switch(current[0]){\n                    case \"L\":\n                        x = current[1];\n                        y = current[2];\n                        ctx.lineTo(x + l, y + t);\n                        break;\n                    case \"M\":\n                        x = current[1];\n                        y = current[2];\n                        subpathStartX = x;\n                        subpathStartY = y;\n                        ctx.moveTo(x + l, y + t);\n                        break;\n                    case \"C\":\n                        x = current[5];\n                        y = current[6];\n                        controlX = current[3];\n                        controlY = current[4];\n                        ctx.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);\n                        break;\n                    case \"Q\":\n                        ctx.quadraticCurveTo(current[1] + l, current[2] + t, current[3] + l, current[4] + t);\n                        x = current[3];\n                        y = current[4];\n                        controlX = current[1];\n                        controlY = current[2];\n                        break;\n                    case \"z\":\n                    case \"Z\":\n                        x = subpathStartX;\n                        y = subpathStartY;\n                        ctx.closePath();\n                        break;\n                }\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render path on\n     */ _render: function(ctx) {\n            this._renderPathCommands(ctx);\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns string representation of an instance\n     * @return {String} string representation of an instance\n     */ toString: function() {\n            return \"#<fabric.Path (\" + this.complexity() + '): { \"top\": ' + this.top + ', \"left\": ' + this.left + \" }>\";\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return extend(this.callSuper(\"toObject\", propertiesToInclude), {\n                path: this.path.map(function(item) {\n                    return item.slice();\n                })\n            });\n        },\n        /**\n     * Returns dataless object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            var o = this.toObject([\n                \"sourcePath\"\n            ].concat(propertiesToInclude));\n            if (o.sourcePath) {\n                delete o.path;\n            }\n            return o;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var path = fabric.util.joinPath(this.path);\n            return [\n                \"<path \",\n                \"COMMON_PARTS\",\n                'd=\"',\n                path,\n                '\" stroke-linecap=\"round\" ',\n                \"/>\\n\"\n            ];\n        },\n        _getOffsetTransform: function() {\n            var digits = fabric.Object.NUM_FRACTION_DIGITS;\n            return \" translate(\" + toFixed(-this.pathOffset.x, digits) + \", \" + toFixed(-this.pathOffset.y, digits) + \")\";\n        },\n        /**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toClipPathSVG: function(reviver) {\n            var additionalTransform = this._getOffsetTransform();\n            return \"\t\" + this._createBaseClipPathSVGMarkup(this._toSVG(), {\n                reviver: reviver,\n                additionalTransform: additionalTransform\n            });\n        },\n        /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toSVG: function(reviver) {\n            var additionalTransform = this._getOffsetTransform();\n            return this._createBaseSVGMarkup(this._toSVG(), {\n                reviver: reviver,\n                additionalTransform: additionalTransform\n            });\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns number representation of an instance complexity\n     * @return {Number} complexity of this instance\n     */ complexity: function() {\n            return this.path.length;\n        },\n        /**\n     * @private\n     */ _calcDimensions: function() {\n            var aX = [], aY = [], current, subpathStartX = 0, subpathStartY = 0, x = 0, y = 0, bounds;\n            for(var i = 0, len = this.path.length; i < len; ++i){\n                current = this.path[i];\n                switch(current[0]){\n                    case \"L\":\n                        x = current[1];\n                        y = current[2];\n                        bounds = [];\n                        break;\n                    case \"M\":\n                        x = current[1];\n                        y = current[2];\n                        subpathStartX = x;\n                        subpathStartY = y;\n                        bounds = [];\n                        break;\n                    case \"C\":\n                        bounds = fabric.util.getBoundsOfCurve(x, y, current[1], current[2], current[3], current[4], current[5], current[6]);\n                        x = current[5];\n                        y = current[6];\n                        break;\n                    case \"Q\":\n                        bounds = fabric.util.getBoundsOfCurve(x, y, current[1], current[2], current[1], current[2], current[3], current[4]);\n                        x = current[3];\n                        y = current[4];\n                        break;\n                    case \"z\":\n                    case \"Z\":\n                        x = subpathStartX;\n                        y = subpathStartY;\n                        break;\n                }\n                bounds.forEach(function(point) {\n                    aX.push(point.x);\n                    aY.push(point.y);\n                });\n                aX.push(x);\n                aY.push(y);\n            }\n            var minX = min(aX) || 0, minY = min(aY) || 0, maxX = max(aX) || 0, maxY = max(aY) || 0, deltaX = maxX - minX, deltaY = maxY - minY;\n            return {\n                left: minX,\n                top: minY,\n                width: deltaX,\n                height: deltaY\n            };\n        }\n    });\n    /**\n   * Creates an instance of fabric.Path from an object\n   * @static\n   * @memberOf fabric.Path\n   * @param {Object} object\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   */ fabric.Path.fromObject = function(object, callback) {\n        if (typeof object.sourcePath === \"string\") {\n            var pathUrl = object.sourcePath;\n            fabric.loadSVGFromURL(pathUrl, function(elements) {\n                var path = elements[0];\n                path.setOptions(object);\n                if (object.clipPath) {\n                    fabric.util.enlivenObjects([\n                        object.clipPath\n                    ], function(elivenedObjects) {\n                        path.clipPath = elivenedObjects[0];\n                        callback && callback(path);\n                    });\n                } else {\n                    callback && callback(path);\n                }\n            });\n        } else {\n            fabric.Object._fromObject(\"Path\", object, callback, \"path\");\n        }\n    };\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)\n   * @static\n   * @memberOf fabric.Path\n   * @see http://www.w3.org/TR/SVG/paths.html#PathElement\n   */ fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat([\n        \"d\"\n    ]);\n    /**\n   * Creates an instance of fabric.Path from an SVG <path> element\n   * @static\n   * @memberOf fabric.Path\n   * @param {SVGElement} element to parse\n   * @param {Function} callback Callback to invoke when an fabric.Path instance is created\n   * @param {Object} [options] Options object\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   */ fabric.Path.fromElement = function(element, callback, options) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);\n        parsedAttributes.fromSVG = true;\n        callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));\n    };\n/* _FROM_SVG_END_ */ })( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), min = fabric.util.array.min, max = fabric.util.array.max;\n    if (fabric.Group) {\n        return;\n    }\n    /**\n   * Group class\n   * @class fabric.Group\n   * @extends fabric.Object\n   * @mixes fabric.Collection\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}\n   * @see {@link fabric.Group#initialize} for constructor definition\n   */ fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"group\",\n        /**\n     * Width of stroke\n     * @type Number\n     * @default\n     */ strokeWidth: 0,\n        /**\n     * Indicates if click, mouseover, mouseout events & hoverCursor should also check for subtargets\n     * @type Boolean\n     * @default\n     */ subTargetCheck: false,\n        /**\n     * Groups are container, do not render anything on theyr own, ence no cache properties\n     * @type Array\n     * @default\n     */ cacheProperties: [],\n        /**\n     * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still\n     * available setting this boolean to true.\n     * @type Boolean\n     * @since 2.0.0\n     * @default\n     */ useSetOnGroup: false,\n        /**\n     * Constructor\n     * @param {Object} objects Group objects\n     * @param {Object} [options] Options object\n     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.\n     * @return {Object} thisArg\n     */ initialize: function(objects, options, isAlreadyGrouped) {\n            options = options || {};\n            this._objects = [];\n            // if objects enclosed in a group have been grouped already,\n            // we cannot change properties of objects.\n            // Thus we need to set options to group without objects,\n            isAlreadyGrouped && this.callSuper(\"initialize\", options);\n            this._objects = objects || [];\n            for(var i = this._objects.length; i--;){\n                this._objects[i].group = this;\n            }\n            if (!isAlreadyGrouped) {\n                var center = options && options.centerPoint;\n                // we want to set origins before calculating the bounding box.\n                // so that the topleft can be set with that in mind.\n                // if specific top and left are passed, are overwritten later\n                // with the callSuper('initialize', options)\n                if (options.originX !== undefined) {\n                    this.originX = options.originX;\n                }\n                if (options.originY !== undefined) {\n                    this.originY = options.originY;\n                }\n                // if coming from svg i do not want to calc bounds.\n                // i assume width and height are passed along options\n                center || this._calcBounds();\n                this._updateObjectsCoords(center);\n                delete options.centerPoint;\n                this.callSuper(\"initialize\", options);\n            } else {\n                this._updateObjectsACoords();\n            }\n            this.setCoords();\n        },\n        /**\n     * @private\n     */ _updateObjectsACoords: function() {\n            var skipControls = true;\n            for(var i = this._objects.length; i--;){\n                this._objects[i].setCoords(skipControls);\n            }\n        },\n        /**\n     * @private\n     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change\n     */ _updateObjectsCoords: function(center) {\n            var center = center || this.getCenterPoint();\n            for(var i = this._objects.length; i--;){\n                this._updateObjectCoords(this._objects[i], center);\n            }\n        },\n        /**\n     * @private\n     * @param {Object} object\n     * @param {fabric.Point} center, current center of group.\n     */ _updateObjectCoords: function(object, center) {\n            var objectLeft = object.left, objectTop = object.top, skipControls = true;\n            object.set({\n                left: objectLeft - center.x,\n                top: objectTop - center.y\n            });\n            object.group = this;\n            object.setCoords(skipControls);\n        },\n        /**\n     * Returns string represenation of a group\n     * @return {String}\n     */ toString: function() {\n            return \"#<fabric.Group: (\" + this.complexity() + \")>\";\n        },\n        /**\n     * Adds an object to a group; Then recalculates group's dimension, position.\n     * @param {Object} object\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ addWithUpdate: function(object) {\n            var nested = !!this.group;\n            this._restoreObjectsState();\n            fabric.util.resetObjectTransform(this);\n            if (object) {\n                if (nested) {\n                    // if this group is inside another group, we need to pre transform the object\n                    fabric.util.removeTransformFromObject(object, this.group.calcTransformMatrix());\n                }\n                this._objects.push(object);\n                object.group = this;\n                object._set(\"canvas\", this.canvas);\n            }\n            this._calcBounds();\n            this._updateObjectsCoords();\n            this.dirty = true;\n            if (nested) {\n                this.group.addWithUpdate();\n            } else {\n                this.setCoords();\n            }\n            return this;\n        },\n        /**\n     * Removes an object from a group; Then recalculates group's dimension, position.\n     * @param {Object} object\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ removeWithUpdate: function(object) {\n            this._restoreObjectsState();\n            fabric.util.resetObjectTransform(this);\n            this.remove(object);\n            this._calcBounds();\n            this._updateObjectsCoords();\n            this.setCoords();\n            this.dirty = true;\n            return this;\n        },\n        /**\n     * @private\n     */ _onObjectAdded: function(object) {\n            this.dirty = true;\n            object.group = this;\n            object._set(\"canvas\", this.canvas);\n        },\n        /**\n     * @private\n     */ _onObjectRemoved: function(object) {\n            this.dirty = true;\n            delete object.group;\n        },\n        /**\n     * @private\n     */ _set: function(key, value) {\n            var i = this._objects.length;\n            if (this.useSetOnGroup) {\n                while(i--){\n                    this._objects[i].setOnGroup(key, value);\n                }\n            }\n            if (key === \"canvas\") {\n                while(i--){\n                    this._objects[i]._set(key, value);\n                }\n            }\n            fabric.Object.prototype._set.call(this, key, value);\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var _includeDefaultValues = this.includeDefaultValues;\n            var objsToObject = this._objects.filter(function(obj) {\n                return !obj.excludeFromExport;\n            }).map(function(obj) {\n                var originalDefaults = obj.includeDefaultValues;\n                obj.includeDefaultValues = _includeDefaultValues;\n                var _obj = obj.toObject(propertiesToInclude);\n                obj.includeDefaultValues = originalDefaults;\n                return _obj;\n            });\n            var obj = fabric.Object.prototype.toObject.call(this, propertiesToInclude);\n            obj.objects = objsToObject;\n            return obj;\n        },\n        /**\n     * Returns object representation of an instance, in dataless mode.\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            var objsToObject, sourcePath = this.sourcePath;\n            if (sourcePath) {\n                objsToObject = sourcePath;\n            } else {\n                var _includeDefaultValues = this.includeDefaultValues;\n                objsToObject = this._objects.map(function(obj) {\n                    var originalDefaults = obj.includeDefaultValues;\n                    obj.includeDefaultValues = _includeDefaultValues;\n                    var _obj = obj.toDatalessObject(propertiesToInclude);\n                    obj.includeDefaultValues = originalDefaults;\n                    return _obj;\n                });\n            }\n            var obj = fabric.Object.prototype.toDatalessObject.call(this, propertiesToInclude);\n            obj.objects = objsToObject;\n            return obj;\n        },\n        /**\n     * Renders instance on a given context\n     * @param {CanvasRenderingContext2D} ctx context to render instance on\n     */ render: function(ctx) {\n            this._transformDone = true;\n            this.callSuper(\"render\", ctx);\n            this._transformDone = false;\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group is already cached.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            var ownCache = fabric.Object.prototype.shouldCache.call(this);\n            if (ownCache) {\n                for(var i = 0, len = this._objects.length; i < len; i++){\n                    if (this._objects[i].willDrawShadow()) {\n                        this.ownCaching = false;\n                        return false;\n                    }\n                }\n            }\n            return ownCache;\n        },\n        /**\n     * Check if this object or a child object will cast a shadow\n     * @return {Boolean}\n     */ willDrawShadow: function() {\n            if (fabric.Object.prototype.willDrawShadow.call(this)) {\n                return true;\n            }\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                if (this._objects[i].willDrawShadow()) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Check if this group or its parent group are caching, recursively up\n     * @return {Boolean}\n     */ isOnACache: function() {\n            return this.ownCaching || this.group && this.group.isOnACache();\n        },\n        /**\n     * Execute the drawing operation for an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawObject: function(ctx) {\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                this._objects[i].render(ctx);\n            }\n            this._drawClipPath(ctx, this.clipPath);\n        },\n        /**\n     * Check if cache is dirty\n     */ isCacheDirty: function(skipCanvas) {\n            if (this.callSuper(\"isCacheDirty\", skipCanvas)) {\n                return true;\n            }\n            if (!this.statefullCache) {\n                return false;\n            }\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                if (this._objects[i].isCacheDirty(true)) {\n                    if (this._cacheCanvas) {\n                        // if this group has not a cache canvas there is nothing to clean\n                        var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;\n                        this._cacheContext.clearRect(-x / 2, -y / 2, x, y);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Restores original state of each of group objects (original state is that which was before group was created).\n     * if the nested boolean is true, the original state will be restored just for the\n     * first group and not for all the group chain\n     * @private\n     * @param {Boolean} nested tell the function to restore object state up to the parent group and not more\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ _restoreObjectsState: function() {\n            var groupMatrix = this.calcOwnMatrix();\n            this._objects.forEach(function(object) {\n                // instead of using _this = this;\n                fabric.util.addTransformToObject(object, groupMatrix);\n                delete object.group;\n                object.setCoords();\n            });\n            return this;\n        },\n        /**\n     * Destroys a group (restoring state of its objects)\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ destroy: function() {\n            // when group is destroyed objects needs to get a repaint to be eventually\n            // displayed on canvas.\n            this._objects.forEach(function(object) {\n                object.set(\"dirty\", true);\n            });\n            return this._restoreObjectsState();\n        },\n        dispose: function() {\n            this.callSuper(\"dispose\");\n            this.forEachObject(function(object) {\n                object.dispose && object.dispose();\n            });\n            this._objects = [];\n        },\n        /**\n     * make a group an active selection, remove the group from canvas\n     * the group has to be on canvas for this to work.\n     * @return {fabric.ActiveSelection} thisArg\n     * @chainable\n     */ toActiveSelection: function() {\n            if (!this.canvas) {\n                return;\n            }\n            var objects = this._objects, canvas = this.canvas;\n            this._objects = [];\n            var options = this.toObject();\n            delete options.objects;\n            var activeSelection = new fabric.ActiveSelection([]);\n            activeSelection.set(options);\n            activeSelection.type = \"activeSelection\";\n            canvas.remove(this);\n            objects.forEach(function(object) {\n                object.group = activeSelection;\n                object.dirty = true;\n                canvas.add(object);\n            });\n            activeSelection.canvas = canvas;\n            activeSelection._objects = objects;\n            canvas._activeObject = activeSelection;\n            activeSelection.setCoords();\n            return activeSelection;\n        },\n        /**\n     * Destroys a group (restoring state of its objects)\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ ungroupOnCanvas: function() {\n            return this._restoreObjectsState();\n        },\n        /**\n     * Sets coordinates of all objects inside group\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ setObjectsCoords: function() {\n            var skipControls = true;\n            this.forEachObject(function(object) {\n                object.setCoords(skipControls);\n            });\n            return this;\n        },\n        /**\n     * @private\n     */ _calcBounds: function(onlyWidthHeight) {\n            var aX = [], aY = [], o, prop, coords, props = [\n                \"tr\",\n                \"br\",\n                \"bl\",\n                \"tl\"\n            ], i = 0, iLen = this._objects.length, j, jLen = props.length;\n            for(; i < iLen; ++i){\n                o = this._objects[i];\n                coords = o.calcACoords();\n                for(j = 0; j < jLen; j++){\n                    prop = props[j];\n                    aX.push(coords[prop].x);\n                    aY.push(coords[prop].y);\n                }\n                o.aCoords = coords;\n            }\n            this._getBounds(aX, aY, onlyWidthHeight);\n        },\n        /**\n     * @private\n     */ _getBounds: function(aX, aY, onlyWidthHeight) {\n            var minXY = new fabric.Point(min(aX), min(aY)), maxXY = new fabric.Point(max(aX), max(aY)), top = minXY.y || 0, left = minXY.x || 0, width = maxXY.x - minXY.x || 0, height = maxXY.y - minXY.y || 0;\n            this.width = width;\n            this.height = height;\n            if (!onlyWidthHeight) {\n                // the bounding box always finds the topleft most corner.\n                // whatever is the group origin, we set up here the left/top position.\n                this.setPositionByOrigin({\n                    x: left,\n                    y: top\n                }, \"left\", \"top\");\n            }\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ _toSVG: function(reviver) {\n            var svgString = [\n                \"<g \",\n                \"COMMON_PARTS\",\n                \" >\\n\"\n            ];\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                svgString.push(\"\t\t\", this._objects[i].toSVG(reviver));\n            }\n            svgString.push(\"</g>\\n\");\n            return svgString;\n        },\n        /**\n     * Returns styles-string for svg-export, specific version for group\n     * @return {String}\n     */ getSvgStyles: function() {\n            var opacity = typeof this.opacity !== \"undefined\" && this.opacity !== 1 ? \"opacity: \" + this.opacity + \";\" : \"\", visibility = this.visible ? \"\" : \" visibility: hidden;\";\n            return [\n                opacity,\n                this.getSvgFilter(),\n                visibility\n            ].join(\"\");\n        },\n        /**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toClipPathSVG: function(reviver) {\n            var svgString = [];\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                svgString.push(\"\t\", this._objects[i].toClipPathSVG(reviver));\n            }\n            return this._createBaseClipPathSVGMarkup(svgString, {\n                reviver: reviver\n            });\n        }\n    });\n    /**\n   * Returns {@link fabric.Group} instance from an object representation\n   * @static\n   * @memberOf fabric.Group\n   * @param {Object} object Object to create a group from\n   * @param {Function} [callback] Callback to invoke when an group instance is created\n   */ fabric.Group.fromObject = function(object, callback) {\n        var objects = object.objects, options = fabric.util.object.clone(object, true);\n        delete options.objects;\n        if (typeof objects === \"string\") {\n            // it has to be an url or something went wrong.\n            fabric.loadSVGFromURL(objects, function(elements) {\n                var group = fabric.util.groupSVGElements(elements, object, objects);\n                var clipPath = options.clipPath;\n                delete options.clipPath;\n                group.set(options);\n                if (clipPath) {\n                    fabric.util.enlivenObjects([\n                        clipPath\n                    ], function(elivenedObjects) {\n                        group.clipPath = elivenedObjects[0];\n                        callback && callback(group);\n                    });\n                } else {\n                    callback && callback(group);\n                }\n            });\n            return;\n        }\n        fabric.util.enlivenObjects(objects, function(enlivenedObjects) {\n            fabric.util.enlivenObjectEnlivables(object, options, function() {\n                callback && callback(new fabric.Group(enlivenedObjects, options, true));\n            });\n        });\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    if (fabric.ActiveSelection) {\n        return;\n    }\n    /**\n   * Group class\n   * @class fabric.ActiveSelection\n   * @extends fabric.Group\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}\n   * @see {@link fabric.ActiveSelection#initialize} for constructor definition\n   */ fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"activeSelection\",\n        /**\n     * Constructor\n     * @param {Object} objects ActiveSelection objects\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(objects, options) {\n            options = options || {};\n            this._objects = objects || [];\n            for(var i = this._objects.length; i--;){\n                this._objects[i].group = this;\n            }\n            if (options.originX) {\n                this.originX = options.originX;\n            }\n            if (options.originY) {\n                this.originY = options.originY;\n            }\n            this._calcBounds();\n            this._updateObjectsCoords();\n            fabric.Object.prototype.initialize.call(this, options);\n            this.setCoords();\n        },\n        /**\n     * Change te activeSelection to a normal group,\n     * High level function that automatically adds it to canvas as\n     * active object. no events fired.\n     * @since 2.0.0\n     * @return {fabric.Group}\n     */ toGroup: function() {\n            var objects = this._objects.concat();\n            this._objects = [];\n            var options = fabric.Object.prototype.toObject.call(this);\n            var newGroup = new fabric.Group([]);\n            delete options.type;\n            newGroup.set(options);\n            objects.forEach(function(object) {\n                object.canvas.remove(object);\n                object.group = newGroup;\n            });\n            newGroup._objects = objects;\n            if (!this.canvas) {\n                return newGroup;\n            }\n            var canvas = this.canvas;\n            canvas.add(newGroup);\n            canvas._activeObject = newGroup;\n            newGroup.setCoords();\n            return newGroup;\n        },\n        /**\n     * If returns true, deselection is cancelled.\n     * @since 2.0.0\n     * @return {Boolean} [cancel]\n     */ onDeselect: function() {\n            this.destroy();\n            return false;\n        },\n        /**\n     * Returns string representation of a group\n     * @return {String}\n     */ toString: function() {\n            return \"#<fabric.ActiveSelection: (\" + this.complexity() + \")>\";\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * objectCaching is a global flag, wins over everything\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            return false;\n        },\n        /**\n     * Check if this group or its parent group are caching, recursively up\n     * @return {Boolean}\n     */ isOnACache: function() {\n            return false;\n        },\n        /**\n     * Renders controls and borders for the object\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [styleOverride] properties to override the object style\n     * @param {Object} [childrenOverride] properties to override the children overrides\n     */ _renderControls: function(ctx, styleOverride, childrenOverride) {\n            ctx.save();\n            ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\n            this.callSuper(\"_renderControls\", ctx, styleOverride);\n            childrenOverride = childrenOverride || {};\n            if (typeof childrenOverride.hasControls === \"undefined\") {\n                childrenOverride.hasControls = false;\n            }\n            childrenOverride.forActiveSelection = true;\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                this._objects[i]._renderControls(ctx, childrenOverride);\n            }\n            ctx.restore();\n        }\n    });\n    /**\n   * Returns {@link fabric.ActiveSelection} instance from an object representation\n   * @static\n   * @memberOf fabric.ActiveSelection\n   * @param {Object} object Object to create a group from\n   * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created\n   */ fabric.ActiveSelection.fromObject = function(object, callback) {\n        fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {\n            delete object.objects;\n            callback && callback(new fabric.ActiveSelection(enlivenedObjects, object, true));\n        });\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var extend = fabric.util.object.extend;\n    if (!global.fabric) {\n        global.fabric = {};\n    }\n    if (global.fabric.Image) {\n        fabric.warn(\"fabric.Image is already defined.\");\n        return;\n    }\n    /**\n   * Image class\n   * @class fabric.Image\n   * @extends fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}\n   * @see {@link fabric.Image#initialize} for constructor definition\n   */ fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"image\",\n        /**\n     * Width of a stroke.\n     * For image quality a stroke multiple of 2 gives better results.\n     * @type Number\n     * @default\n     */ strokeWidth: 0,\n        /**\n     * When calling {@link fabric.Image.getSrc}, return value from element src with `element.getAttribute('src')`.\n     * This allows for relative urls as image src.\n     * @since 2.7.0\n     * @type Boolean\n     * @default\n     */ srcFromAttribute: false,\n        /**\n     * private\n     * contains last value of scaleX to detect\n     * if the Image got resized after the last Render\n     * @type Number\n     */ _lastScaleX: 1,\n        /**\n     * private\n     * contains last value of scaleY to detect\n     * if the Image got resized after the last Render\n     * @type Number\n     */ _lastScaleY: 1,\n        /**\n     * private\n     * contains last value of scaling applied by the apply filter chain\n     * @type Number\n     */ _filterScalingX: 1,\n        /**\n     * private\n     * contains last value of scaling applied by the apply filter chain\n     * @type Number\n     */ _filterScalingY: 1,\n        /**\n     * minimum scale factor under which any resizeFilter is triggered to resize the image\n     * 0 will disable the automatic resize. 1 will trigger automatically always.\n     * number bigger than 1 are not implemented yet.\n     * @type Number\n     */ minimumScaleTrigger: 0.5,\n        /**\n     * List of properties to consider when checking if\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: fabric.Object.prototype.stateProperties.concat(\"cropX\", \"cropY\"),\n        /**\n     * List of properties to consider when checking if cache needs refresh\n     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single\n     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty\n     * and refreshed at the next render\n     * @type Array\n     */ cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"cropX\", \"cropY\"),\n        /**\n     * key used to retrieve the texture representing this image\n     * @since 2.0.0\n     * @type String\n     * @default\n     */ cacheKey: \"\",\n        /**\n     * Image crop in pixels from original image size.\n     * @since 2.0.0\n     * @type Number\n     * @default\n     */ cropX: 0,\n        /**\n     * Image crop in pixels from original image size.\n     * @since 2.0.0\n     * @type Number\n     * @default\n     */ cropY: 0,\n        /**\n     * Indicates whether this canvas will use image smoothing when painting this image.\n     * Also influence if the cacheCanvas for this image uses imageSmoothing\n     * @since 4.0.0-beta.11\n     * @type Boolean\n     * @default\n     */ imageSmoothing: true,\n        /**\n     * Constructor\n     * Image can be initialized with any canvas drawable or a string.\n     * The string should be a url and will be loaded as an image.\n     * Canvas and Image element work out of the box, while videos require extra code to work.\n     * Please check video element events for seeking.\n     * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} element Image element\n     * @param {Object} [options] Options object\n     * @param {function} [callback] callback function to call after eventual filters applied.\n     * @return {fabric.Image} thisArg\n     */ initialize: function(element, options) {\n            options || (options = {});\n            this.filters = [];\n            this.cacheKey = \"texture\" + fabric.Object.__uid++;\n            this.callSuper(\"initialize\", options);\n            this._initElement(element, options);\n        },\n        /**\n     * Returns image element which this instance if based on\n     * @return {HTMLImageElement} Image element\n     */ getElement: function() {\n            return this._element || {};\n        },\n        /**\n     * Sets image element for this instance to a specified one.\n     * If filters defined they are applied to new image.\n     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.\n     * @param {HTMLImageElement} element\n     * @param {Object} [options] Options object\n     * @return {fabric.Image} thisArg\n     * @chainable\n     */ setElement: function(element, options) {\n            this.removeTexture(this.cacheKey);\n            this.removeTexture(this.cacheKey + \"_filtered\");\n            this._element = element;\n            this._originalElement = element;\n            this._initConfig(options);\n            if (this.filters.length !== 0) {\n                this.applyFilters();\n            }\n            // resizeFilters work on the already filtered copy.\n            // we need to apply resizeFilters AFTER normal filters.\n            // applyResizeFilters is run more often than normal filters\n            // and is triggered by user interactions rather than dev code\n            if (this.resizeFilter) {\n                this.applyResizeFilters();\n            }\n            return this;\n        },\n        /**\n     * Delete a single texture if in webgl mode\n     */ removeTexture: function(key) {\n            var backend = fabric.filterBackend;\n            if (backend && backend.evictCachesForKey) {\n                backend.evictCachesForKey(key);\n            }\n        },\n        /**\n     * Delete textures, reference to elements and eventually JSDOM cleanup\n     */ dispose: function() {\n            this.callSuper(\"dispose\");\n            this.removeTexture(this.cacheKey);\n            this.removeTexture(this.cacheKey + \"_filtered\");\n            this._cacheContext = undefined;\n            [\n                \"_originalElement\",\n                \"_element\",\n                \"_filteredEl\",\n                \"_cacheCanvas\"\n            ].forEach((function(element) {\n                fabric.util.cleanUpJsdomNode(this[element]);\n                this[element] = undefined;\n            }).bind(this));\n        },\n        /**\n     * Get the crossOrigin value (of the corresponding image element)\n     */ getCrossOrigin: function() {\n            return this._originalElement && (this._originalElement.crossOrigin || null);\n        },\n        /**\n     * Returns original size of an image\n     * @return {Object} Object with \"width\" and \"height\" properties\n     */ getOriginalSize: function() {\n            var element = this.getElement();\n            return {\n                width: element.naturalWidth || element.width,\n                height: element.naturalHeight || element.height\n            };\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _stroke: function(ctx) {\n            if (!this.stroke || this.strokeWidth === 0) {\n                return;\n            }\n            var w = this.width / 2, h = this.height / 2;\n            ctx.beginPath();\n            ctx.moveTo(-w, -h);\n            ctx.lineTo(w, -h);\n            ctx.lineTo(w, h);\n            ctx.lineTo(-w, h);\n            ctx.lineTo(-w, -h);\n            ctx.closePath();\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var filters = [];\n            this.filters.forEach(function(filterObj) {\n                if (filterObj) {\n                    filters.push(filterObj.toObject());\n                }\n            });\n            var object = extend(this.callSuper(\"toObject\", [\n                \"cropX\",\n                \"cropY\"\n            ].concat(propertiesToInclude)), {\n                src: this.getSrc(),\n                crossOrigin: this.getCrossOrigin(),\n                filters: filters\n            });\n            if (this.resizeFilter) {\n                object.resizeFilter = this.resizeFilter.toObject();\n            }\n            return object;\n        },\n        /**\n     * Returns true if an image has crop applied, inspecting values of cropX,cropY,width,height.\n     * @return {Boolean}\n     */ hasCrop: function() {\n            return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var svgString = [], imageMarkup = [], strokeSvg, element = this._element, x = -this.width / 2, y = -this.height / 2, clipPath = \"\", imageRendering = \"\";\n            if (!element) {\n                return [];\n            }\n            if (this.hasCrop()) {\n                var clipPathId = fabric.Object.__uid++;\n                svgString.push('<clipPath id=\"imageCrop_' + clipPathId + '\">\\n', '\t<rect x=\"' + x + '\" y=\"' + y + '\" width=\"' + this.width + '\" height=\"' + this.height + '\" />\\n', \"</clipPath>\\n\");\n                clipPath = ' clip-path=\"url(#imageCrop_' + clipPathId + ')\" ';\n            }\n            if (!this.imageSmoothing) {\n                imageRendering = '\" image-rendering=\"optimizeSpeed';\n            }\n            imageMarkup.push(\"\t<image \", \"COMMON_PARTS\", 'xlink:href=\"', this.getSvgSrc(true), '\" x=\"', x - this.cropX, '\" y=\"', y - this.cropY, // we're essentially moving origin of transformation from top/left corner to the center of the shape\n            // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left\n            // so that object's center aligns with container's left/top\n            '\" width=\"', element.width || element.naturalWidth, '\" height=\"', element.height || element.height, imageRendering, '\"', clipPath, \"></image>\\n\");\n            if (this.stroke || this.strokeDashArray) {\n                var origFill = this.fill;\n                this.fill = null;\n                strokeSvg = [\n                    \"\t<rect \",\n                    'x=\"',\n                    x,\n                    '\" y=\"',\n                    y,\n                    '\" width=\"',\n                    this.width,\n                    '\" height=\"',\n                    this.height,\n                    '\" style=\"',\n                    this.getSvgStyles(),\n                    '\"/>\\n'\n                ];\n                this.fill = origFill;\n            }\n            if (this.paintFirst !== \"fill\") {\n                svgString = svgString.concat(strokeSvg, imageMarkup);\n            } else {\n                svgString = svgString.concat(imageMarkup, strokeSvg);\n            }\n            return svgString;\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns source of an image\n     * @param {Boolean} filtered indicates if the src is needed for svg\n     * @return {String} Source of an image\n     */ getSrc: function(filtered) {\n            var element = filtered ? this._element : this._originalElement;\n            if (element) {\n                if (element.toDataURL) {\n                    return element.toDataURL();\n                }\n                if (this.srcFromAttribute) {\n                    return element.getAttribute(\"src\");\n                } else {\n                    return element.src;\n                }\n            } else {\n                return this.src || \"\";\n            }\n        },\n        /**\n     * Sets source of an image\n     * @param {String} src Source string (URL)\n     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)\n     * @param {Object} [options] Options object\n     * @param {String} [options.crossOrigin] crossOrigin value (one of \"\", \"anonymous\", \"use-credentials\")\n     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes\n     * @return {fabric.Image} thisArg\n     * @chainable\n     */ setSrc: function(src, callback, options) {\n            fabric.util.loadImage(src, function(img, isError) {\n                this.setElement(img, options);\n                this._setWidthHeight();\n                callback && callback(this, isError);\n            }, this, options && options.crossOrigin);\n            return this;\n        },\n        /**\n     * Returns string representation of an instance\n     * @return {String} String representation of an instance\n     */ toString: function() {\n            return '#<fabric.Image: { src: \"' + this.getSrc() + '\" }>';\n        },\n        applyResizeFilters: function() {\n            var filter = this.resizeFilter, minimumScale = this.minimumScaleTrigger, objectScale = this.getTotalObjectScaling(), scaleX = objectScale.scaleX, scaleY = objectScale.scaleY, elementToFilter = this._filteredEl || this._originalElement;\n            if (this.group) {\n                this.set(\"dirty\", true);\n            }\n            if (!filter || scaleX > minimumScale && scaleY > minimumScale) {\n                this._element = elementToFilter;\n                this._filterScalingX = 1;\n                this._filterScalingY = 1;\n                this._lastScaleX = scaleX;\n                this._lastScaleY = scaleY;\n                return;\n            }\n            if (!fabric.filterBackend) {\n                fabric.filterBackend = fabric.initFilterBackend();\n            }\n            var canvasEl = fabric.util.createCanvasElement(), cacheKey = this._filteredEl ? this.cacheKey + \"_filtered\" : this.cacheKey, sourceWidth = elementToFilter.width, sourceHeight = elementToFilter.height;\n            canvasEl.width = sourceWidth;\n            canvasEl.height = sourceHeight;\n            this._element = canvasEl;\n            this._lastScaleX = filter.scaleX = scaleX;\n            this._lastScaleY = filter.scaleY = scaleY;\n            fabric.filterBackend.applyFilters([\n                filter\n            ], elementToFilter, sourceWidth, sourceHeight, this._element, cacheKey);\n            this._filterScalingX = canvasEl.width / this._originalElement.width;\n            this._filterScalingY = canvasEl.height / this._originalElement.height;\n        },\n        /**\n     * Applies filters assigned to this image (from \"filters\" array) or from filter param\n     * @method applyFilters\n     * @param {Array} filters to be applied\n     * @param {Boolean} forResizing specify if the filter operation is a resize operation\n     * @return {thisArg} return the fabric.Image object\n     * @chainable\n     */ applyFilters: function(filters) {\n            filters = filters || this.filters || [];\n            filters = filters.filter(function(filter) {\n                return filter && !filter.isNeutralState();\n            });\n            this.set(\"dirty\", true);\n            // needs to clear out or WEBGL will not resize correctly\n            this.removeTexture(this.cacheKey + \"_filtered\");\n            if (filters.length === 0) {\n                this._element = this._originalElement;\n                this._filteredEl = null;\n                this._filterScalingX = 1;\n                this._filterScalingY = 1;\n                return this;\n            }\n            var imgElement = this._originalElement, sourceWidth = imgElement.naturalWidth || imgElement.width, sourceHeight = imgElement.naturalHeight || imgElement.height;\n            if (this._element === this._originalElement) {\n                // if the element is the same we need to create a new element\n                var canvasEl = fabric.util.createCanvasElement();\n                canvasEl.width = sourceWidth;\n                canvasEl.height = sourceHeight;\n                this._element = canvasEl;\n                this._filteredEl = canvasEl;\n            } else {\n                // clear the existing element to get new filter data\n                // also dereference the eventual resized _element\n                this._element = this._filteredEl;\n                this._filteredEl.getContext(\"2d\").clearRect(0, 0, sourceWidth, sourceHeight);\n                // we also need to resize again at next renderAll, so remove saved _lastScaleX/Y\n                this._lastScaleX = 1;\n                this._lastScaleY = 1;\n            }\n            if (!fabric.filterBackend) {\n                fabric.filterBackend = fabric.initFilterBackend();\n            }\n            fabric.filterBackend.applyFilters(filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey);\n            if (this._originalElement.width !== this._element.width || this._originalElement.height !== this._element.height) {\n                this._filterScalingX = this._element.width / this._originalElement.width;\n                this._filterScalingY = this._element.height / this._originalElement.height;\n            }\n            return this;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            fabric.util.setImageSmoothing(ctx, this.imageSmoothing);\n            if (this.isMoving !== true && this.resizeFilter && this._needsResize()) {\n                this.applyResizeFilters();\n            }\n            this._stroke(ctx);\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Paint the cached copy of the object on the target context.\n     * it will set the imageSmoothing for the draw operation\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawCacheOnCanvas: function(ctx) {\n            fabric.util.setImageSmoothing(ctx, this.imageSmoothing);\n            fabric.Object.prototype.drawCacheOnCanvas.call(this, ctx);\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * This is the special image version where we would like to avoid caching where possible.\n     * Essentially images do not benefit from caching. They may require caching, and in that\n     * case we do it. Also caching an image usually ends in a loss of details.\n     * A full performance audit should be done.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            return this.needsItsOwnCache();\n        },\n        _renderFill: function(ctx) {\n            var elementToDraw = this._element;\n            if (!elementToDraw) {\n                return;\n            }\n            var scaleX = this._filterScalingX, scaleY = this._filterScalingY, w = this.width, h = this.height, min = Math.min, max = Math.max, // crop values cannot be lesser than 0.\n            cropX = max(this.cropX, 0), cropY = max(this.cropY, 0), elWidth = elementToDraw.naturalWidth || elementToDraw.width, elHeight = elementToDraw.naturalHeight || elementToDraw.height, sX = cropX * scaleX, sY = cropY * scaleY, // the width height cannot exceed element width/height, starting from the crop offset.\n            sW = min(w * scaleX, elWidth - sX), sH = min(h * scaleY, elHeight - sY), x = -w / 2, y = -h / 2, maxDestW = min(w, elWidth / scaleX - cropX), maxDestH = min(h, elHeight / scaleY - cropY);\n            elementToDraw && ctx.drawImage(elementToDraw, sX, sY, sW, sH, x, y, maxDestW, maxDestH);\n        },\n        /**\n     * needed to check if image needs resize\n     * @private\n     */ _needsResize: function() {\n            var scale = this.getTotalObjectScaling();\n            return scale.scaleX !== this._lastScaleX || scale.scaleY !== this._lastScaleY;\n        },\n        /**\n     * @private\n     */ _resetWidthHeight: function() {\n            this.set(this.getOriginalSize());\n        },\n        /**\n     * The Image class's initialization method. This method is automatically\n     * called by the constructor.\n     * @private\n     * @param {HTMLImageElement|String} element The element representing the image\n     * @param {Object} [options] Options object\n     */ _initElement: function(element, options) {\n            this.setElement(fabric.util.getById(element), options);\n            fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);\n        },\n        /**\n     * @private\n     * @param {Object} [options] Options object\n     */ _initConfig: function(options) {\n            options || (options = {});\n            this.setOptions(options);\n            this._setWidthHeight(options);\n        },\n        /**\n     * @private\n     * @param {Array} filters to be initialized\n     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created\n     */ _initFilters: function(filters, callback) {\n            if (filters && filters.length) {\n                fabric.util.enlivenObjects(filters, function(enlivenedObjects) {\n                    callback && callback(enlivenedObjects);\n                }, \"fabric.Image.filters\");\n            } else {\n                callback && callback();\n            }\n        },\n        /**\n     * @private\n     * Set the width and the height of the image object, using the element or the\n     * options.\n     * @param {Object} [options] Object with width/height properties\n     */ _setWidthHeight: function(options) {\n            options || (options = {});\n            var el = this.getElement();\n            this.width = options.width || el.naturalWidth || el.width || 0;\n            this.height = options.height || el.naturalHeight || el.height || 0;\n        },\n        /**\n     * Calculate offset for center and scale factor for the image in order to respect\n     * the preserveAspectRatio attribute\n     * @private\n     * @return {Object}\n     */ parsePreserveAspectRatioAttribute: function() {\n            var pAR = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || \"\"), rWidth = this._element.width, rHeight = this._element.height, scaleX = 1, scaleY = 1, offsetLeft = 0, offsetTop = 0, cropX = 0, cropY = 0, offset, pWidth = this.width, pHeight = this.height, parsedAttributes = {\n                width: pWidth,\n                height: pHeight\n            };\n            if (pAR && (pAR.alignX !== \"none\" || pAR.alignY !== \"none\")) {\n                if (pAR.meetOrSlice === \"meet\") {\n                    scaleX = scaleY = fabric.util.findScaleToFit(this._element, parsedAttributes);\n                    offset = (pWidth - rWidth * scaleX) / 2;\n                    if (pAR.alignX === \"Min\") {\n                        offsetLeft = -offset;\n                    }\n                    if (pAR.alignX === \"Max\") {\n                        offsetLeft = offset;\n                    }\n                    offset = (pHeight - rHeight * scaleY) / 2;\n                    if (pAR.alignY === \"Min\") {\n                        offsetTop = -offset;\n                    }\n                    if (pAR.alignY === \"Max\") {\n                        offsetTop = offset;\n                    }\n                }\n                if (pAR.meetOrSlice === \"slice\") {\n                    scaleX = scaleY = fabric.util.findScaleToCover(this._element, parsedAttributes);\n                    offset = rWidth - pWidth / scaleX;\n                    if (pAR.alignX === \"Mid\") {\n                        cropX = offset / 2;\n                    }\n                    if (pAR.alignX === \"Max\") {\n                        cropX = offset;\n                    }\n                    offset = rHeight - pHeight / scaleY;\n                    if (pAR.alignY === \"Mid\") {\n                        cropY = offset / 2;\n                    }\n                    if (pAR.alignY === \"Max\") {\n                        cropY = offset;\n                    }\n                    rWidth = pWidth / scaleX;\n                    rHeight = pHeight / scaleY;\n                }\n            } else {\n                scaleX = pWidth / rWidth;\n                scaleY = pHeight / rHeight;\n            }\n            return {\n                width: rWidth,\n                height: rHeight,\n                scaleX: scaleX,\n                scaleY: scaleY,\n                offsetLeft: offsetLeft,\n                offsetTop: offsetTop,\n                cropX: cropX,\n                cropY: cropY\n            };\n        }\n    });\n    /**\n   * Default CSS class name for canvas\n   * @static\n   * @type String\n   * @default\n   */ fabric.Image.CSS_CANVAS = \"canvas-img\";\n    /**\n   * Alias for getSrc\n   * @static\n   */ fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;\n    /**\n   * Creates an instance of fabric.Image from its object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} callback Callback to invoke when an image instance is created\n   */ fabric.Image.fromObject = function(_object, callback) {\n        var object = fabric.util.object.clone(_object);\n        fabric.util.loadImage(object.src, function(img, isError) {\n            if (isError) {\n                callback && callback(null, true);\n                return;\n            }\n            fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {\n                object.filters = filters || [];\n                fabric.Image.prototype._initFilters.call(object, [\n                    object.resizeFilter\n                ], function(resizeFilters) {\n                    object.resizeFilter = resizeFilters[0];\n                    fabric.util.enlivenObjectEnlivables(object, object, function() {\n                        var image = new fabric.Image(img, object);\n                        callback(image, false);\n                    });\n                });\n            });\n        }, null, object.crossOrigin);\n    };\n    /**\n   * Creates an instance of fabric.Image from an URL string\n   * @static\n   * @param {String} url URL to create an image from\n   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument). Second argument is a boolean indicating if an error occurred or not.\n   * @param {Object} [imgOptions] Options object\n   */ fabric.Image.fromURL = function(url, callback, imgOptions) {\n        fabric.util.loadImage(url, function(img, isError) {\n            callback && callback(new fabric.Image(img, imgOptions), isError);\n        }, null, imgOptions && imgOptions.crossOrigin);\n    };\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})\n   * @static\n   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}\n   */ fabric.Image.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x y width height preserveAspectRatio xlink:href crossOrigin image-rendering\".split(\" \"));\n    /**\n   * Returns {@link fabric.Image} instance from an SVG element\n   * @static\n   * @param {SVGElement} element Element to parse\n   * @param {Object} [options] Options object\n   * @param {Function} callback Callback to execute when fabric.Image object is created\n   * @return {fabric.Image} Instance of fabric.Image\n   */ fabric.Image.fromElement = function(element, callback, options) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);\n        fabric.Image.fromURL(parsedAttributes[\"xlink:href\"], callback, extend(options ? fabric.util.object.clone(options) : {}, parsedAttributes));\n    };\n/* _FROM_SVG_END_ */ })( true ? exports : 0);\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n    /**\n   * @private\n   * @return {Number} angle value\n   */ _getAngleValueForStraighten: function() {\n        var angle = this.angle % 360;\n        if (angle > 0) {\n            return Math.round((angle - 1) / 90) * 90;\n        }\n        return Math.round(angle / 90) * 90;\n    },\n    /**\n   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ straighten: function() {\n        return this.rotate(this._getAngleValueForStraighten());\n    },\n    /**\n   * Same as {@link fabric.Object.prototype.straighten} but with animation\n   * @param {Object} callbacks Object with callback functions\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.Object} thisArg\n   */ fxStraighten: function(callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: this.get(\"angle\"),\n            endValue: this._getAngleValueForStraighten(),\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                _this.rotate(value);\n                onChange();\n            },\n            onComplete: function() {\n                _this.setCoords();\n                onComplete();\n            }\n        });\n    }\n});\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n    /**\n   * Straightens object, then rerenders canvas\n   * @param {fabric.Object} object Object to straighten\n   * @return {fabric.Canvas} thisArg\n   * @chainable\n   */ straightenObject: function(object) {\n        object.straighten();\n        this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated\n   * @param {fabric.Object} object Object to straighten\n   * @return {fabric.Canvas} thisArg\n   */ fxStraightenObject: function(object) {\n        return object.fxStraighten({\n            onChange: this.requestRenderAllBound\n        });\n    }\n});\n(function() {\n    \"use strict\";\n    /**\n   * Tests if webgl supports certain precision\n   * @param {WebGL} Canvas WebGL context to test on\n   * @param {String} Precision to test can be any of following: 'lowp', 'mediump', 'highp'\n   * @returns {Boolean} Whether the user's browser WebGL supports given precision.\n   */ function testPrecision(gl, precision) {\n        var fragmentSource = \"precision \" + precision + \" float;\\nvoid main(){}\";\n        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, fragmentSource);\n        gl.compileShader(fragmentShader);\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n   * Indicate whether this filtering backend is supported by the user's browser.\n   * @param {Number} tileSize check if the tileSize is supported\n   * @returns {Boolean} Whether the user's browser supports WebGL.\n   */ fabric.isWebglSupported = function(tileSize) {\n        if (fabric.isLikelyNode) {\n            return false;\n        }\n        tileSize = tileSize || fabric.WebglFilterBackend.prototype.tileSize;\n        var canvas = document.createElement(\"canvas\");\n        var gl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\n        var isSupported = false;\n        // eslint-disable-next-line\n        if (gl) {\n            fabric.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n            isSupported = fabric.maxTextureSize >= tileSize;\n            var precisions = [\n                \"highp\",\n                \"mediump\",\n                \"lowp\"\n            ];\n            for(var i = 0; i < 3; i++){\n                if (testPrecision(gl, precisions[i])) {\n                    fabric.webGlPrecision = precisions[i];\n                    break;\n                }\n                ;\n            }\n        }\n        this.isSupported = isSupported;\n        return isSupported;\n    };\n    fabric.WebglFilterBackend = WebglFilterBackend;\n    /**\n   * WebGL filter backend.\n   */ function WebglFilterBackend(options) {\n        if (options && options.tileSize) {\n            this.tileSize = options.tileSize;\n        }\n        this.setupGLContext(this.tileSize, this.tileSize);\n        this.captureGPUInfo();\n    }\n    ;\n    WebglFilterBackend.prototype = /** @lends fabric.WebglFilterBackend.prototype */ {\n        tileSize: 2048,\n        /**\n     * Experimental. This object is a sort of repository of help layers used to avoid\n     * of recreating them during frequent filtering. If you are previewing a filter with\n     * a slider you probably do not want to create help layers every filter step.\n     * in this object there will be appended some canvases, created once, resized sometimes\n     * cleared never. Clearing is left to the developer.\n     **/ resources: {},\n        /**\n     * Setup a WebGL context suitable for filtering, and bind any needed event handlers.\n     */ setupGLContext: function(width, height) {\n            this.dispose();\n            this.createWebGLCanvas(width, height);\n            // eslint-disable-next-line\n            this.aPosition = new Float32Array([\n                0,\n                0,\n                0,\n                1,\n                1,\n                0,\n                1,\n                1\n            ]);\n            this.chooseFastestCopyGLTo2DMethod(width, height);\n        },\n        /**\n     * Pick a method to copy data from GL context to 2d canvas.  In some browsers using\n     * putImageData is faster than drawImage for that specific operation.\n     */ chooseFastestCopyGLTo2DMethod: function(width, height) {\n            var canMeasurePerf = typeof window.performance !== \"undefined\", canUseImageData;\n            try {\n                new ImageData(1, 1);\n                canUseImageData = true;\n            } catch (e) {\n                canUseImageData = false;\n            }\n            // eslint-disable-next-line no-undef\n            var canUseArrayBuffer = typeof ArrayBuffer !== \"undefined\";\n            // eslint-disable-next-line no-undef\n            var canUseUint8Clamped = typeof Uint8ClampedArray !== \"undefined\";\n            if (!(canMeasurePerf && canUseImageData && canUseArrayBuffer && canUseUint8Clamped)) {\n                return;\n            }\n            var targetCanvas = fabric.util.createCanvasElement();\n            // eslint-disable-next-line no-undef\n            var imageBuffer = new ArrayBuffer(width * height * 4);\n            if (fabric.forceGLPutImageData) {\n                this.imageBuffer = imageBuffer;\n                this.copyGLTo2D = copyGLTo2DPutImageData;\n                return;\n            }\n            var testContext = {\n                imageBuffer: imageBuffer,\n                destinationWidth: width,\n                destinationHeight: height,\n                targetCanvas: targetCanvas\n            };\n            var startTime, drawImageTime, putImageDataTime;\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            startTime = window.performance.now();\n            copyGLTo2DDrawImage.call(testContext, this.gl, testContext);\n            drawImageTime = window.performance.now() - startTime;\n            startTime = window.performance.now();\n            copyGLTo2DPutImageData.call(testContext, this.gl, testContext);\n            putImageDataTime = window.performance.now() - startTime;\n            if (drawImageTime > putImageDataTime) {\n                this.imageBuffer = imageBuffer;\n                this.copyGLTo2D = copyGLTo2DPutImageData;\n            } else {\n                this.copyGLTo2D = copyGLTo2DDrawImage;\n            }\n        },\n        /**\n     * Create a canvas element and associated WebGL context and attaches them as\n     * class properties to the GLFilterBackend class.\n     */ createWebGLCanvas: function(width, height) {\n            var canvas = fabric.util.createCanvasElement();\n            canvas.width = width;\n            canvas.height = height;\n            var glOptions = {\n                alpha: true,\n                premultipliedAlpha: false,\n                depth: false,\n                stencil: false,\n                antialias: false\n            }, gl = canvas.getContext(\"webgl\", glOptions);\n            if (!gl) {\n                gl = canvas.getContext(\"experimental-webgl\", glOptions);\n            }\n            if (!gl) {\n                return;\n            }\n            gl.clearColor(0, 0, 0, 0);\n            // this canvas can fire webglcontextlost and webglcontextrestored\n            this.canvas = canvas;\n            this.gl = gl;\n        },\n        /**\n     * Attempts to apply the requested filters to the source provided, drawing the filtered output\n     * to the provided target canvas.\n     *\n     * @param {Array} filters The filters to apply.\n     * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.\n     * @param {Number} width The width of the source input.\n     * @param {Number} height The height of the source input.\n     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.\n     * @param {String|undefined} cacheKey A key used to cache resources related to the source. If\n     * omitted, caching will be skipped.\n     */ applyFilters: function(filters, source, width, height, targetCanvas, cacheKey) {\n            var gl = this.gl;\n            var cachedTexture;\n            if (cacheKey) {\n                cachedTexture = this.getCachedTexture(cacheKey, source);\n            }\n            var pipelineState = {\n                originalWidth: source.width || source.originalWidth,\n                originalHeight: source.height || source.originalHeight,\n                sourceWidth: width,\n                sourceHeight: height,\n                destinationWidth: width,\n                destinationHeight: height,\n                context: gl,\n                sourceTexture: this.createTexture(gl, width, height, !cachedTexture && source),\n                targetTexture: this.createTexture(gl, width, height),\n                originalTexture: cachedTexture || this.createTexture(gl, width, height, !cachedTexture && source),\n                passes: filters.length,\n                webgl: true,\n                aPosition: this.aPosition,\n                programCache: this.programCache,\n                pass: 0,\n                filterBackend: this,\n                targetCanvas: targetCanvas\n            };\n            var tempFbo = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);\n            filters.forEach(function(filter) {\n                filter && filter.applyTo(pipelineState);\n            });\n            resizeCanvasIfNeeded(pipelineState);\n            this.copyGLTo2D(gl, pipelineState);\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            gl.deleteTexture(pipelineState.sourceTexture);\n            gl.deleteTexture(pipelineState.targetTexture);\n            gl.deleteFramebuffer(tempFbo);\n            targetCanvas.getContext(\"2d\").setTransform(1, 0, 0, 1, 0, 0);\n            return pipelineState;\n        },\n        /**\n     * Detach event listeners, remove references, and clean up caches.\n     */ dispose: function() {\n            if (this.canvas) {\n                this.canvas = null;\n                this.gl = null;\n            }\n            this.clearWebGLCaches();\n        },\n        /**\n     * Wipe out WebGL-related caches.\n     */ clearWebGLCaches: function() {\n            this.programCache = {};\n            this.textureCache = {};\n        },\n        /**\n     * Create a WebGL texture object.\n     *\n     * Accepts specific dimensions to initialize the texture to or a source image.\n     *\n     * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.\n     * @param {Number} width The width to initialize the texture at.\n     * @param {Number} height The height to initialize the texture.\n     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.\n     * @param {Number} filterType gl.NEAREST or gl.LINEAR usually, webgl numeri constants\n     * @returns {WebGLTexture}\n     */ createTexture: function(gl, width, height, textureImageSource, filterType) {\n            var texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterType || gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterType || gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            if (textureImageSource) {\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);\n            } else {\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n            }\n            return texture;\n        },\n        /**\n     * Can be optionally used to get a texture from the cache array\n     *\n     * If an existing texture is not found, a new texture is created and cached.\n     *\n     * @param {String} uniqueId A cache key to use to find an existing texture.\n     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the\n     * texture cache entry if one does not already exist.\n     */ getCachedTexture: function(uniqueId, textureImageSource) {\n            if (this.textureCache[uniqueId]) {\n                return this.textureCache[uniqueId];\n            } else {\n                var texture = this.createTexture(this.gl, textureImageSource.width, textureImageSource.height, textureImageSource);\n                this.textureCache[uniqueId] = texture;\n                return texture;\n            }\n        },\n        /**\n     * Clear out cached resources related to a source image that has been\n     * filtered previously.\n     *\n     * @param {String} cacheKey The cache key provided when the source image was filtered.\n     */ evictCachesForKey: function(cacheKey) {\n            if (this.textureCache[cacheKey]) {\n                this.gl.deleteTexture(this.textureCache[cacheKey]);\n                delete this.textureCache[cacheKey];\n            }\n        },\n        copyGLTo2D: copyGLTo2DDrawImage,\n        /**\n     * Attempt to extract GPU information strings from a WebGL context.\n     *\n     * Useful information when debugging or blacklisting specific GPUs.\n     *\n     * @returns {Object} A GPU info object with renderer and vendor strings.\n     */ captureGPUInfo: function() {\n            if (this.gpuInfo) {\n                return this.gpuInfo;\n            }\n            var gl = this.gl, gpuInfo = {\n                renderer: \"\",\n                vendor: \"\"\n            };\n            if (!gl) {\n                return gpuInfo;\n            }\n            var ext = gl.getExtension(\"WEBGL_debug_renderer_info\");\n            if (ext) {\n                var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);\n                var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);\n                if (renderer) {\n                    gpuInfo.renderer = renderer.toLowerCase();\n                }\n                if (vendor) {\n                    gpuInfo.vendor = vendor.toLowerCase();\n                }\n            }\n            this.gpuInfo = gpuInfo;\n            return gpuInfo;\n        }\n    };\n})();\nfunction resizeCanvasIfNeeded(pipelineState) {\n    var targetCanvas = pipelineState.targetCanvas, width = targetCanvas.width, height = targetCanvas.height, dWidth = pipelineState.destinationWidth, dHeight = pipelineState.destinationHeight;\n    if (width !== dWidth || height !== dHeight) {\n        targetCanvas.width = dWidth;\n        targetCanvas.height = dHeight;\n    }\n}\n/**\n * Copy an input WebGL canvas on to an output 2D canvas.\n *\n * The WebGL canvas is assumed to be upside down, with the top-left pixel of the\n * desired output image appearing in the bottom-left corner of the WebGL canvas.\n *\n * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.\n * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.\n * @param {Object} pipelineState The 2D target canvas to copy on to.\n */ function copyGLTo2DDrawImage(gl, pipelineState) {\n    var glCanvas = gl.canvas, targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext(\"2d\");\n    ctx.translate(0, targetCanvas.height); // move it down again\n    ctx.scale(1, -1); // vertical flip\n    // where is my image on the big glcanvas?\n    var sourceY = glCanvas.height - targetCanvas.height;\n    ctx.drawImage(glCanvas, 0, sourceY, targetCanvas.width, targetCanvas.height, 0, 0, targetCanvas.width, targetCanvas.height);\n}\n/**\n * Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData\n * API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra).\n *\n * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.\n * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.\n * @param {Object} pipelineState The 2D target canvas to copy on to.\n */ function copyGLTo2DPutImageData(gl, pipelineState) {\n    var targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext(\"2d\"), dWidth = pipelineState.destinationWidth, dHeight = pipelineState.destinationHeight, numBytes = dWidth * dHeight * 4;\n    // eslint-disable-next-line no-undef\n    var u8 = new Uint8Array(this.imageBuffer, 0, numBytes);\n    // eslint-disable-next-line no-undef\n    var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);\n    gl.readPixels(0, 0, dWidth, dHeight, gl.RGBA, gl.UNSIGNED_BYTE, u8);\n    var imgData = new ImageData(u8Clamped, dWidth, dHeight);\n    ctx.putImageData(imgData, 0, 0);\n}\n(function() {\n    \"use strict\";\n    var noop = function() {};\n    fabric.Canvas2dFilterBackend = Canvas2dFilterBackend;\n    /**\n   * Canvas 2D filter backend.\n   */ function Canvas2dFilterBackend() {}\n    ;\n    Canvas2dFilterBackend.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */ {\n        evictCachesForKey: noop,\n        dispose: noop,\n        clearWebGLCaches: noop,\n        /**\n     * Experimental. This object is a sort of repository of help layers used to avoid\n     * of recreating them during frequent filtering. If you are previewing a filter with\n     * a slider you probably do not want to create help layers every filter step.\n     * in this object there will be appended some canvases, created once, resized sometimes\n     * cleared never. Clearing is left to the developer.\n     **/ resources: {},\n        /**\n     * Apply a set of filters against a source image and draw the filtered output\n     * to the provided destination canvas.\n     *\n     * @param {EnhancedFilter} filters The filter to apply.\n     * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.\n     * @param {Number} sourceWidth The width of the source input.\n     * @param {Number} sourceHeight The height of the source input.\n     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.\n     */ applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {\n            var ctx = targetCanvas.getContext(\"2d\");\n            ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);\n            var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);\n            var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);\n            var pipelineState = {\n                sourceWidth: sourceWidth,\n                sourceHeight: sourceHeight,\n                imageData: imageData,\n                originalEl: sourceElement,\n                originalImageData: originalImageData,\n                canvasEl: targetCanvas,\n                ctx: ctx,\n                filterBackend: this\n            };\n            filters.forEach(function(filter) {\n                filter.applyTo(pipelineState);\n            });\n            if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {\n                targetCanvas.width = pipelineState.imageData.width;\n                targetCanvas.height = pipelineState.imageData.height;\n            }\n            ctx.putImageData(pipelineState.imageData, 0, 0);\n            return pipelineState;\n        }\n    };\n})();\n/**\n * @namespace fabric.Image.filters\n * @memberOf fabric.Image\n * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}\n * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n */ fabric.Image = fabric.Image || {};\nfabric.Image.filters = fabric.Image.filters || {};\n/**\n * Root filter class from which all filter classes inherit from\n * @class fabric.Image.filters.BaseFilter\n * @memberOf fabric.Image.filters\n */ fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {\n    /**\n   * Filter type\n   * @param {String} type\n   * @default\n   */ type: \"BaseFilter\",\n    /**\n   * Array of attributes to send with buffers. do not modify\n   * @private\n   */ vertexSource: \"attribute vec2 aPosition;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vTexCoord = aPosition;\\n\" + \"gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\\n\" + \"}\",\n    fragmentSource: \"precision highp float;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"void main() {\\n\" + \"gl_FragColor = texture2D(uTexture, vTexCoord);\\n\" + \"}\",\n    /**\n   * Constructor\n   * @param {Object} [options] Options object\n   */ initialize: function(options) {\n        if (options) {\n            this.setOptions(options);\n        }\n    },\n    /**\n   * Sets filter's properties from options\n   * @param {Object} [options] Options object\n   */ setOptions: function(options) {\n        for(var prop in options){\n            this[prop] = options[prop];\n        }\n    },\n    /**\n   * Compile this filter's shader program.\n   *\n   * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.\n   * @param {String} fragmentSource fragmentShader source for compilation\n   * @param {String} vertexSource vertexShader source for compilation\n   */ createProgram: function(gl, fragmentSource, vertexSource) {\n        fragmentSource = fragmentSource || this.fragmentSource;\n        vertexSource = vertexSource || this.vertexSource;\n        if (fabric.webGlPrecision !== \"highp\") {\n            fragmentSource = fragmentSource.replace(/precision highp float/g, \"precision \" + fabric.webGlPrecision + \" float\");\n        }\n        var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vertexShader, vertexSource);\n        gl.compileShader(vertexShader);\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n            throw new Error(// eslint-disable-next-line prefer-template\n            \"Vertex shader compile error for \" + this.type + \": \" + gl.getShaderInfoLog(vertexShader));\n        }\n        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, fragmentSource);\n        gl.compileShader(fragmentShader);\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n            throw new Error(// eslint-disable-next-line prefer-template\n            \"Fragment shader compile error for \" + this.type + \": \" + gl.getShaderInfoLog(fragmentShader));\n        }\n        var program = gl.createProgram();\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.linkProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            throw new Error(// eslint-disable-next-line prefer-template\n            'Shader link error for \"${this.type}\" ' + gl.getProgramInfoLog(program));\n        }\n        var attributeLocations = this.getAttributeLocations(gl, program);\n        var uniformLocations = this.getUniformLocations(gl, program) || {};\n        uniformLocations.uStepW = gl.getUniformLocation(program, \"uStepW\");\n        uniformLocations.uStepH = gl.getUniformLocation(program, \"uStepH\");\n        return {\n            program: program,\n            attributeLocations: attributeLocations,\n            uniformLocations: uniformLocations\n        };\n    },\n    /**\n   * Return a map of attribute names to WebGLAttributeLocation objects.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.\n   * @returns {Object} A map of attribute names to attribute locations.\n   */ getAttributeLocations: function(gl, program) {\n        return {\n            aPosition: gl.getAttribLocation(program, \"aPosition\")\n        };\n    },\n    /**\n   * Return a map of uniform names to WebGLUniformLocation objects.\n   *\n   * Intended to be overridden by subclasses.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.\n   * @returns {Object} A map of uniform names to uniform locations.\n   */ getUniformLocations: function() {\n        // in case i do not need any special uniform i need to return an empty object\n        return {};\n    },\n    /**\n   * Send attribute data from this filter to its shader program on the GPU.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {Object} attributeLocations A map of shader attribute names to their locations.\n   */ sendAttributeData: function(gl, attributeLocations, aPositionData) {\n        var attributeLocation = attributeLocations.aPosition;\n        var buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.enableVertexAttribArray(attributeLocation);\n        gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);\n        gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);\n    },\n    _setupFrameBuffer: function(options) {\n        var gl = options.context, width, height;\n        if (options.passes > 1) {\n            width = options.destinationWidth;\n            height = options.destinationHeight;\n            if (options.sourceWidth !== width || options.sourceHeight !== height) {\n                gl.deleteTexture(options.targetTexture);\n                options.targetTexture = options.filterBackend.createTexture(gl, width, height);\n            }\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, options.targetTexture, 0);\n        } else {\n            // draw last filter on canvas and not to framebuffer.\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            gl.finish();\n        }\n    },\n    _swapTextures: function(options) {\n        options.passes--;\n        options.pass++;\n        var temp = options.targetTexture;\n        options.targetTexture = options.sourceTexture;\n        options.sourceTexture = temp;\n    },\n    /**\n   * Generic isNeutral implementation for one parameter based filters.\n   * Used only in image applyFilters to discard filters that will not have an effect\n   * on the image\n   * Other filters may need their own version ( ColorMatrix, HueRotation, gamma, ComposedFilter )\n   * @param {Object} options\n   **/ isNeutralState: function() {\n        var main = this.mainParameter, _class = fabric.Image.filters[this.type].prototype;\n        if (main) {\n            if (Array.isArray(_class[main])) {\n                for(var i = _class[main].length; i--;){\n                    if (this[main][i] !== _class[main][i]) {\n                        return false;\n                    }\n                }\n                return true;\n            } else {\n                return _class[main] === this[main];\n            }\n        } else {\n            return false;\n        }\n    },\n    /**\n   * Apply this filter to the input image data provided.\n   *\n   * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be executed\n   * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */ applyTo: function(options) {\n        if (options.webgl) {\n            this._setupFrameBuffer(options);\n            this.applyToWebGL(options);\n            this._swapTextures(options);\n        } else {\n            this.applyTo2d(options);\n        }\n    },\n    /**\n   * Retrieves the cached shader.\n   * @param {Object} options\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */ retrieveShader: function(options) {\n        if (!options.programCache.hasOwnProperty(this.type)) {\n            options.programCache[this.type] = this.createProgram(options.context);\n        }\n        return options.programCache[this.type];\n    },\n    /**\n   * Apply this filter using webgl.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be executed\n   * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n   * @param {WebGLTexture} options.originalTexture The texture of the original input image.\n   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */ applyToWebGL: function(options) {\n        var gl = options.context;\n        var shader = this.retrieveShader(options);\n        if (options.pass === 0 && options.originalTexture) {\n            gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);\n        } else {\n            gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);\n        }\n        gl.useProgram(shader.program);\n        this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);\n        gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);\n        gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);\n        this.sendUniformData(gl, shader.uniformLocations);\n        gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    },\n    bindAdditionalTexture: function(gl, texture, textureUnit) {\n        gl.activeTexture(textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        // reset active texture to 0 as usual\n        gl.activeTexture(gl.TEXTURE0);\n    },\n    unbindAdditionalTexture: function(gl, textureUnit) {\n        gl.activeTexture(textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.activeTexture(gl.TEXTURE0);\n    },\n    getMainParameter: function() {\n        return this[this.mainParameter];\n    },\n    setMainParameter: function(value) {\n        this[this.mainParameter] = value;\n    },\n    /**\n   * Send uniform data from this filter to its shader program on the GPU.\n   *\n   * Intended to be overridden by subclasses.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {Object} uniformLocations A map of shader uniform names to their locations.\n   */ sendUniformData: function() {\n    // Intentionally left blank.  Override me in subclasses.\n    },\n    /**\n   * If needed by a 2d filter, this functions can create an helper canvas to be used\n   * remember that options.targetCanvas is available for use till end of chain.\n   */ createHelpLayer: function(options) {\n        if (!options.helpLayer) {\n            var helpLayer = document.createElement(\"canvas\");\n            helpLayer.width = options.sourceWidth;\n            helpLayer.height = options.sourceHeight;\n            options.helpLayer = helpLayer;\n        }\n    },\n    /**\n   * Returns object representation of an instance\n   * @return {Object} Object representation of an instance\n   */ toObject: function() {\n        var object = {\n            type: this.type\n        }, mainP = this.mainParameter;\n        if (mainP) {\n            object[mainP] = this[mainP];\n        }\n        return object;\n    },\n    /**\n   * Returns a JSON representation of an instance\n   * @return {Object} JSON\n   */ toJSON: function() {\n        // delegate, not alias\n        return this.toObject();\n    }\n});\nfabric.Image.filters.BaseFilter.fromObject = function(object, callback) {\n    var filter = new fabric.Image.filters[object.type](object);\n    callback && callback(filter);\n    return filter;\n};\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Color Matrix filter class\n   * @class fabric.Image.filters.ColorMatrix\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}\n   * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}\n   * @example <caption>Kodachrome filter</caption>\n   * var filter = new fabric.Image.filters.ColorMatrix({\n   *  matrix: [\n       1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,\n       -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,\n       -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,\n       0, 0, 0, 1, 0\n      ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"ColorMatrix\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"uniform mat4 uColorMatrix;\\n\" + \"uniform vec4 uConstants;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"color *= uColorMatrix;\\n\" + \"color += uConstants;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Colormatrix for pixels.\n     * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning\n     * outside the -1, 1 range.\n     * 0.0039215686 is the part of 1 that get translated to 1 in 2d\n     * @param {Array} matrix array of 20 numbers.\n     * @default\n     */ matrix: [\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        mainParameter: \"matrix\",\n        /**\n     * Lock the colormatrix on the color part, skipping alpha, mainly for non webgl scenario\n     * to save some calculation\n     * @type Boolean\n     * @default true\n     */ colorsOnly: true,\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            // create a new array instead mutating the prototype with push\n            this.matrix = this.matrix.slice(0);\n        },\n        /**\n     * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, iLen = data.length, m = this.matrix, r, g, b, a, i, colorsOnly = this.colorsOnly;\n            for(i = 0; i < iLen; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                if (colorsOnly) {\n                    data[i] = r * m[0] + g * m[1] + b * m[2] + m[4] * 255;\n                    data[i + 1] = r * m[5] + g * m[6] + b * m[7] + m[9] * 255;\n                    data[i + 2] = r * m[10] + g * m[11] + b * m[12] + m[14] * 255;\n                } else {\n                    a = data[i + 3];\n                    data[i] = r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[4] * 255;\n                    data[i + 1] = r * m[5] + g * m[6] + b * m[7] + a * m[8] + m[9] * 255;\n                    data[i + 2] = r * m[10] + g * m[11] + b * m[12] + a * m[13] + m[14] * 255;\n                    data[i + 3] = r * m[15] + g * m[16] + b * m[17] + a * m[18] + m[19] * 255;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uColorMatrix: gl.getUniformLocation(program, \"uColorMatrix\"),\n                uConstants: gl.getUniformLocation(program, \"uConstants\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var m = this.matrix, matrix = [\n                m[0],\n                m[1],\n                m[2],\n                m[3],\n                m[5],\n                m[6],\n                m[7],\n                m[8],\n                m[10],\n                m[11],\n                m[12],\n                m[13],\n                m[15],\n                m[16],\n                m[17],\n                m[18]\n            ], constants = [\n                m[4],\n                m[9],\n                m[14],\n                m[19]\n            ];\n            gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix);\n            gl.uniform4fv(uniformLocations.uConstants, constants);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] function to invoke after filter creation\n   * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix\n   */ fabric.Image.filters.ColorMatrix.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Brightness filter class\n   * @class fabric.Image.filters.Brightness\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Brightness({\n   *   brightness: 0.05\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Brightness\",\n        /**\n     * Fragment source for the brightness program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uBrightness;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"color.rgb += uBrightness;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Brightness value, from -1 to 1.\n     * translated to -255 to 255 for 2d\n     * 0.0039215686 is the part of 1 that get translated to 1 in 2d\n     * @param {Number} brightness\n     * @default\n     */ brightness: 0,\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"brightness\",\n        /**\n    * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n    *\n    * @param {Object} options\n    * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n    */ applyTo2d: function(options) {\n            if (this.brightness === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, i, len = data.length, brightness = Math.round(this.brightness * 255);\n            for(i = 0; i < len; i += 4){\n                data[i] = data[i] + brightness;\n                data[i + 1] = data[i + 1] + brightness;\n                data[i + 2] = data[i + 2] + brightness;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uBrightness: gl.getUniformLocation(program, \"uBrightness\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uBrightness, this.brightness);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness\n   */ fabric.Image.filters.Brightness.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Adapted from <a href=\"http://www.html5rocks.com/en/tutorials/canvas/imagefilters/\">html5rocks article</a>\n   * @class fabric.Image.filters.Convolute\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example <caption>Sharpen filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 0, -1,  0,\n   *            -1,  5, -1,\n   *             0, -1,  0 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Blur filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 1/9, 1/9, 1/9,\n   *             1/9, 1/9, 1/9,\n   *             1/9, 1/9, 1/9 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Emboss filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 1,   1,  1,\n   *             1, 0.7, -1,\n   *            -1,  -1, -1 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Emboss filter with opaqueness</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   opaque: true,\n   *   matrix: [ 1,   1,  1,\n   *             1, 0.7, -1,\n   *            -1,  -1, -1 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Convolute\",\n        /*\n     * Opaque value (true/false)\n     */ opaque: false,\n        /*\n     * matrix for the filter, max 9x9\n     */ matrix: [\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0\n        ],\n        /**\n     * Fragment source for the brightness program\n     */ fragmentSource: {\n            Convolute_3_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[9];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 3.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 3.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_3_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[9];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 3.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 3.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\",\n            Convolute_5_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[25];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 5.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 5.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_5_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[25];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 5.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 5.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\",\n            Convolute_7_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[49];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 7.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 7.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_7_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[49];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 7.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 7.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\",\n            Convolute_9_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[81];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 9.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 9.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_9_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[81];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 9.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 9.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\"\n        },\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Convolute.prototype\n     * @param {Object} [options] Options object\n     * @param {Boolean} [options.opaque=false] Opaque value (true/false)\n     * @param {Array} [options.matrix] Filter matrix\n     */ /**\n    * Retrieves the cached shader.\n    * @param {Object} options\n    * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n    * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n    */ retrieveShader: function(options) {\n            var size = Math.sqrt(this.matrix.length);\n            var cacheKey = this.type + \"_\" + size + \"_\" + (this.opaque ? 1 : 0);\n            var shaderSource = this.fragmentSource[cacheKey];\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        /**\n     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, weights = this.matrix, side = Math.round(Math.sqrt(weights.length)), halfSide = Math.floor(side / 2), sw = imageData.width, sh = imageData.height, output = options.ctx.createImageData(sw, sh), dst = output.data, // go through the destination image pixels\n            alphaFac = this.opaque ? 1 : 0, r, g, b, a, dstOff, scx, scy, srcOff, wt, x, y, cx, cy;\n            for(y = 0; y < sh; y++){\n                for(x = 0; x < sw; x++){\n                    dstOff = (y * sw + x) * 4;\n                    // calculate the weighed sum of the source image pixels that\n                    // fall under the convolution matrix\n                    r = 0;\n                    g = 0;\n                    b = 0;\n                    a = 0;\n                    for(cy = 0; cy < side; cy++){\n                        for(cx = 0; cx < side; cx++){\n                            scy = y + cy - halfSide;\n                            scx = x + cx - halfSide;\n                            // eslint-disable-next-line max-depth\n                            if (scy < 0 || scy >= sh || scx < 0 || scx >= sw) {\n                                continue;\n                            }\n                            srcOff = (scy * sw + scx) * 4;\n                            wt = weights[cy * side + cx];\n                            r += data[srcOff] * wt;\n                            g += data[srcOff + 1] * wt;\n                            b += data[srcOff + 2] * wt;\n                            // eslint-disable-next-line max-depth\n                            if (!alphaFac) {\n                                a += data[srcOff + 3] * wt;\n                            }\n                        }\n                    }\n                    dst[dstOff] = r;\n                    dst[dstOff + 1] = g;\n                    dst[dstOff + 2] = b;\n                    if (!alphaFac) {\n                        dst[dstOff + 3] = a;\n                    } else {\n                        dst[dstOff + 3] = data[dstOff + 3];\n                    }\n                }\n            }\n            options.imageData = output;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uMatrix: gl.getUniformLocation(program, \"uMatrix\"),\n                uOpaque: gl.getUniformLocation(program, \"uOpaque\"),\n                uHalfSize: gl.getUniformLocation(program, \"uHalfSize\"),\n                uSize: gl.getUniformLocation(program, \"uSize\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1fv(uniformLocations.uMatrix, this.matrix);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return extend(this.callSuper(\"toObject\"), {\n                opaque: this.opaque,\n                matrix: this.matrix\n            });\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute\n   */ fabric.Image.filters.Convolute.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Grayscale image filter class\n   * @class fabric.Image.filters.Grayscale\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Grayscale();\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Grayscale\",\n        fragmentSource: {\n            average: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float average = (color.r + color.b + color.g) / 3.0;\\n\" + \"gl_FragColor = vec4(average, average, average, color.a);\\n\" + \"}\",\n            lightness: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform int uMode;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 col = texture2D(uTexture, vTexCoord);\\n\" + \"float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\\n\" + \"gl_FragColor = vec4(average, average, average, col.a);\\n\" + \"}\",\n            luminosity: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform int uMode;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 col = texture2D(uTexture, vTexCoord);\\n\" + \"float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\\n\" + \"gl_FragColor = vec4(average, average, average, col.a);\\n\" + \"}\"\n        },\n        /**\n     * Grayscale mode, between 'average', 'lightness', 'luminosity'\n     * @param {String} type\n     * @default\n     */ mode: \"average\",\n        mainParameter: \"mode\",\n        /**\n     * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, i, len = data.length, value, mode = this.mode;\n            for(i = 0; i < len; i += 4){\n                if (mode === \"average\") {\n                    value = (data[i] + data[i + 1] + data[i + 2]) / 3;\n                } else if (mode === \"lightness\") {\n                    value = (Math.min(data[i], data[i + 1], data[i + 2]) + Math.max(data[i], data[i + 1], data[i + 2])) / 2;\n                } else if (mode === \"luminosity\") {\n                    value = 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];\n                }\n                data[i] = value;\n                data[i + 1] = value;\n                data[i + 2] = value;\n            }\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var cacheKey = this.type + \"_\" + this.mode;\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                var shaderSource = this.fragmentSource[this.mode];\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uMode: gl.getUniformLocation(program, \"uMode\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            // default average mode.\n            var mode = 1;\n            gl.uniform1i(uniformLocations.uMode, mode);\n        },\n        /**\n     * Grayscale filter isNeutralState implementation\n     * The filter is never neutral\n     * on the image\n     **/ isNeutralState: function() {\n            return false;\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale\n   */ fabric.Image.filters.Grayscale.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Invert filter class\n   * @class fabric.Image.filters.Invert\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Invert();\n   * object.filters.push(filter);\n   * object.applyFilters(canvas.renderAll.bind(canvas));\n   */ filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Invert\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform int uInvert;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"if (uInvert == 1) {\\n\" + \"gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\\n\" + \"} else {\\n\" + \"gl_FragColor = color;\\n\" + \"}\\n\" + \"}\",\n        /**\n     * Filter invert. if false, does nothing\n     * @param {Boolean} invert\n     * @default\n     */ invert: true,\n        mainParameter: \"invert\",\n        /**\n     * Apply the Invert operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, i, len = data.length;\n            for(i = 0; i < len; i += 4){\n                data[i] = 255 - data[i];\n                data[i + 1] = 255 - data[i + 1];\n                data[i + 2] = 255 - data[i + 2];\n            }\n        },\n        /**\n     * Invert filter isNeutralState implementation\n     * Used only in image applyFilters to discard filters that will not have an effect\n     * on the image\n     * @param {Object} options\n     **/ isNeutralState: function() {\n            return !this.invert;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uInvert: gl.getUniformLocation(program, \"uInvert\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1i(uniformLocations.uInvert, this.invert);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert\n   */ fabric.Image.filters.Invert.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Noise filter class\n   * @class fabric.Image.filters.Noise\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Noise({\n   *   noise: 700\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Noise\",\n        /**\n     * Fragment source for the noise program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uStepH;\\n\" + \"uniform float uNoise;\\n\" + \"uniform float uSeed;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"float rand(vec2 co, float seed, float vScale) {\\n\" + \"return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\\n\" + \"}\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"noise\",\n        /**\n     * Noise value, from\n     * @param {Number} noise\n     * @default\n     */ noise: 0,\n        /**\n     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            if (this.noise === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, i, len = data.length, noise = this.noise, rand;\n            for(i = 0, len = data.length; i < len; i += 4){\n                rand = (0.5 - Math.random()) * noise;\n                data[i] += rand;\n                data[i + 1] += rand;\n                data[i + 2] += rand;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uNoise: gl.getUniformLocation(program, \"uNoise\"),\n                uSeed: gl.getUniformLocation(program, \"uSeed\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uNoise, this.noise / 255);\n            gl.uniform1f(uniformLocations.uSeed, Math.random());\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return extend(this.callSuper(\"toObject\"), {\n                noise: this.noise\n            });\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise\n   */ fabric.Image.filters.Noise.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Pixelate filter class\n   * @class fabric.Image.filters.Pixelate\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Pixelate({\n   *   blocksize: 8\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Pixelate\",\n        blocksize: 4,\n        mainParameter: \"blocksize\",\n        /**\n     * Fragment source for the Pixelate program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uBlocksize;\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"float blockW = uBlocksize * uStepW;\\n\" + \"float blockH = uBlocksize * uStepW;\\n\" + \"int posX = int(vTexCoord.x / blockW);\\n\" + \"int posY = int(vTexCoord.y / blockH);\\n\" + \"float fposX = float(posX);\\n\" + \"float fposY = float(posY);\\n\" + \"vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\\n\" + \"vec4 color = texture2D(uTexture, squareCoords);\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, iLen = imageData.height, jLen = imageData.width, index, i, j, r, g, b, a, _i, _j, _iLen, _jLen;\n            for(i = 0; i < iLen; i += this.blocksize){\n                for(j = 0; j < jLen; j += this.blocksize){\n                    index = i * 4 * jLen + j * 4;\n                    r = data[index];\n                    g = data[index + 1];\n                    b = data[index + 2];\n                    a = data[index + 3];\n                    _iLen = Math.min(i + this.blocksize, iLen);\n                    _jLen = Math.min(j + this.blocksize, jLen);\n                    for(_i = i; _i < _iLen; _i++){\n                        for(_j = j; _j < _jLen; _j++){\n                            index = _i * 4 * jLen + _j * 4;\n                            data[index] = r;\n                            data[index + 1] = g;\n                            data[index + 2] = b;\n                            data[index + 3] = a;\n                        }\n                    }\n                }\n            }\n        },\n        /**\n     * Indicate when the filter is not gonna apply changes to the image\n     **/ isNeutralState: function() {\n            return this.blocksize === 1;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uBlocksize: gl.getUniformLocation(program, \"uBlocksize\"),\n                uStepW: gl.getUniformLocation(program, \"uStepW\"),\n                uStepH: gl.getUniformLocation(program, \"uStepH\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate\n   */ fabric.Image.filters.Pixelate.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Remove white filter class\n   * @class fabric.Image.filters.RemoveColor\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.RemoveColor#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.RemoveColor({\n   *   threshold: 0.2,\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.RemoveColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveColor.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"RemoveColor\",\n        /**\n     * Color to remove, in any format understood by fabric.Color.\n     * @param {String} type\n     * @default\n     */ color: \"#FFFFFF\",\n        /**\n     * Fragment source for the brightness program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec4 uLow;\\n\" + \"uniform vec4 uHigh;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"gl_FragColor = texture2D(uTexture, vTexCoord);\\n\" + \"if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\\n\" + \"gl_FragColor.a = 0.0;\\n\" + \"}\\n\" + \"}\",\n        /**\n     * distance to actual color, as value up or down from each r,g,b\n     * between 0 and 1\n     **/ distance: 0.02,\n        /**\n     * For color to remove inside distance, use alpha channel for a smoother deletion\n     * NOT IMPLEMENTED YET\n     **/ useAlpha: false,\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.RemoveWhite.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.color=#RRGGBB] Threshold value\n     * @param {Number} [options.distance=10] Distance value\n     */ /**\n     * Applies filter to canvas element\n     * @param {Object} canvasEl Canvas element to apply filter to\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, i, distance = this.distance * 255, r, g, b, source = new fabric.Color(this.color).getSource(), lowC = [\n                source[0] - distance,\n                source[1] - distance,\n                source[2] - distance\n            ], highC = [\n                source[0] + distance,\n                source[1] + distance,\n                source[2] + distance\n            ];\n            for(i = 0; i < data.length; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                if (r > lowC[0] && g > lowC[1] && b > lowC[2] && r < highC[0] && g < highC[1] && b < highC[2]) {\n                    data[i + 3] = 0;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uLow: gl.getUniformLocation(program, \"uLow\"),\n                uHigh: gl.getUniformLocation(program, \"uHigh\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var source = new fabric.Color(this.color).getSource(), distance = parseFloat(this.distance), lowC = [\n                0 + source[0] / 255 - distance,\n                0 + source[1] / 255 - distance,\n                0 + source[2] / 255 - distance,\n                1\n            ], highC = [\n                source[0] / 255 + distance,\n                source[1] / 255 + distance,\n                source[2] / 255 + distance,\n                1\n            ];\n            gl.uniform4fv(uniformLocations.uLow, lowC);\n            gl.uniform4fv(uniformLocations.uHigh, highC);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return extend(this.callSuper(\"toObject\"), {\n                color: this.color,\n                distance: this.distance\n            });\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.RemoveColor} Instance of fabric.Image.filters.RemoveWhite\n   */ fabric.Image.filters.RemoveColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    var matrices = {\n        Brownie: [\n            0.59970,\n            0.34553,\n            -0.27082,\n            0,\n            0.186,\n            -0.03770,\n            0.86095,\n            0.15059,\n            0,\n            -0.1449,\n            0.24113,\n            -0.07441,\n            0.44972,\n            0,\n            -0.02965,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Vintage: [\n            0.62793,\n            0.32021,\n            -0.03965,\n            0,\n            0.03784,\n            0.02578,\n            0.64411,\n            0.03259,\n            0,\n            0.02926,\n            0.04660,\n            -0.08512,\n            0.52416,\n            0,\n            0.02023,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Kodachrome: [\n            1.12855,\n            -0.39673,\n            -0.03992,\n            0,\n            0.24991,\n            -0.16404,\n            1.08352,\n            -0.05498,\n            0,\n            0.09698,\n            -0.16786,\n            -0.56034,\n            1.60148,\n            0,\n            0.13972,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Technicolor: [\n            1.91252,\n            -0.85453,\n            -0.09155,\n            0,\n            0.04624,\n            -0.30878,\n            1.76589,\n            -0.10601,\n            0,\n            -0.27589,\n            -0.23110,\n            -0.75018,\n            1.84759,\n            0,\n            0.12137,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Polaroid: [\n            1.438,\n            -0.062,\n            -0.062,\n            0,\n            0,\n            -0.122,\n            1.378,\n            -0.122,\n            0,\n            0,\n            -0.016,\n            -0.016,\n            1.483,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Sepia: [\n            0.393,\n            0.769,\n            0.189,\n            0,\n            0,\n            0.349,\n            0.686,\n            0.168,\n            0,\n            0,\n            0.272,\n            0.534,\n            0.131,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        BlackWhite: [\n            1.5,\n            1.5,\n            1.5,\n            0,\n            -1,\n            1.5,\n            1.5,\n            1.5,\n            0,\n            -1,\n            1.5,\n            1.5,\n            1.5,\n            0,\n            -1,\n            0,\n            0,\n            0,\n            1,\n            0\n        ]\n    };\n    for(var key in matrices){\n        filters[key] = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.Sepia.prototype */ {\n            /**\n       * Filter type\n       * @param {String} type\n       * @default\n       */ type: key,\n            /**\n       * Colormatrix for the effect\n       * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning\n       * outside the -1, 1 range.\n       * @param {Array} matrix array of 20 numbers.\n       * @default\n       */ matrix: matrices[key],\n            /**\n       * Lock the matrix export for this kind of static, parameter less filters.\n       */ mainParameter: false,\n            /**\n       * Lock the colormatrix on the color part, skipping alpha\n       */ colorsOnly: true\n        });\n        fabric.Image.filters[key].fromObject = fabric.Image.filters.BaseFilter.fromObject;\n    }\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Color Blend filter class\n   * @class fabric.Image.filter.BlendColor\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @example\n   * var filter = new fabric.Image.filters.BlendColor({\n   *  color: '#000',\n   *  mode: 'multiply'\n   * });\n   *\n   * var filter = new fabric.Image.filters.BlendImage({\n   *  image: fabricImageObject,\n   *  mode: 'multiply',\n   *  alpha: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.BlendColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {\n        type: \"BlendColor\",\n        /**\n     * Color to make the blend operation with. default to a reddish color since black or white\n     * gives always strong result.\n     * @type String\n     * @default\n     **/ color: \"#F95C63\",\n        /**\n     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,\n     * darken, lighten, overlay, exclusion, tint.\n     * @type String\n     * @default\n     **/ mode: \"multiply\",\n        /**\n     * alpha value. represent the strength of the blend color operation.\n     * @type Number\n     * @default\n     **/ alpha: 1,\n        /**\n     * Fragment source for the Multiply program\n     */ fragmentSource: {\n            multiply: \"gl_FragColor.rgb *= uColor.rgb;\\n\",\n            screen: \"gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\\n\",\n            add: \"gl_FragColor.rgb += uColor.rgb;\\n\",\n            diff: \"gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\\n\",\n            subtract: \"gl_FragColor.rgb -= uColor.rgb;\\n\",\n            lighten: \"gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\\n\",\n            darken: \"gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\\n\",\n            exclusion: \"gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\\n\",\n            overlay: \"if (uColor.r < 0.5) {\\n\" + \"gl_FragColor.r *= 2.0 * uColor.r;\\n\" + \"} else {\\n\" + \"gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\\n\" + \"}\\n\" + \"if (uColor.g < 0.5) {\\n\" + \"gl_FragColor.g *= 2.0 * uColor.g;\\n\" + \"} else {\\n\" + \"gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\\n\" + \"}\\n\" + \"if (uColor.b < 0.5) {\\n\" + \"gl_FragColor.b *= 2.0 * uColor.b;\\n\" + \"} else {\\n\" + \"gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\\n\" + \"}\\n\",\n            tint: \"gl_FragColor.rgb *= (1.0 - uColor.a);\\n\" + \"gl_FragColor.rgb += uColor.rgb;\\n\"\n        },\n        /**\n     * build the fragment source for the filters, joining the common part with\n     * the specific one.\n     * @param {String} mode the mode of the filter, a key of this.fragmentSource\n     * @return {String} the source to be compiled\n     * @private\n     */ buildSource: function(mode) {\n            return \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec4 uColor;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"gl_FragColor = color;\\n\" + \"if (color.a > 0.0) {\\n\" + this.fragmentSource[mode] + \"}\\n\" + \"}\";\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var cacheKey = this.type + \"_\" + this.mode, shaderSource;\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                shaderSource = this.buildSource(this.mode);\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        /**\n     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, iLen = data.length, tr, tg, tb, r, g, b, source, alpha1 = 1 - this.alpha;\n            source = new fabric.Color(this.color).getSource();\n            tr = source[0] * this.alpha;\n            tg = source[1] * this.alpha;\n            tb = source[2] * this.alpha;\n            for(var i = 0; i < iLen; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                switch(this.mode){\n                    case \"multiply\":\n                        data[i] = r * tr / 255;\n                        data[i + 1] = g * tg / 255;\n                        data[i + 2] = b * tb / 255;\n                        break;\n                    case \"screen\":\n                        data[i] = 255 - (255 - r) * (255 - tr) / 255;\n                        data[i + 1] = 255 - (255 - g) * (255 - tg) / 255;\n                        data[i + 2] = 255 - (255 - b) * (255 - tb) / 255;\n                        break;\n                    case \"add\":\n                        data[i] = r + tr;\n                        data[i + 1] = g + tg;\n                        data[i + 2] = b + tb;\n                        break;\n                    case \"diff\":\n                    case \"difference\":\n                        data[i] = Math.abs(r - tr);\n                        data[i + 1] = Math.abs(g - tg);\n                        data[i + 2] = Math.abs(b - tb);\n                        break;\n                    case \"subtract\":\n                        data[i] = r - tr;\n                        data[i + 1] = g - tg;\n                        data[i + 2] = b - tb;\n                        break;\n                    case \"darken\":\n                        data[i] = Math.min(r, tr);\n                        data[i + 1] = Math.min(g, tg);\n                        data[i + 2] = Math.min(b, tb);\n                        break;\n                    case \"lighten\":\n                        data[i] = Math.max(r, tr);\n                        data[i + 1] = Math.max(g, tg);\n                        data[i + 2] = Math.max(b, tb);\n                        break;\n                    case \"overlay\":\n                        data[i] = tr < 128 ? 2 * r * tr / 255 : 255 - 2 * (255 - r) * (255 - tr) / 255;\n                        data[i + 1] = tg < 128 ? 2 * g * tg / 255 : 255 - 2 * (255 - g) * (255 - tg) / 255;\n                        data[i + 2] = tb < 128 ? 2 * b * tb / 255 : 255 - 2 * (255 - b) * (255 - tb) / 255;\n                        break;\n                    case \"exclusion\":\n                        data[i] = tr + r - 2 * tr * r / 255;\n                        data[i + 1] = tg + g - 2 * tg * g / 255;\n                        data[i + 2] = tb + b - 2 * tb * b / 255;\n                        break;\n                    case \"tint\":\n                        data[i] = tr + r * alpha1;\n                        data[i + 1] = tg + g * alpha1;\n                        data[i + 2] = tb + b * alpha1;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uColor: gl.getUniformLocation(program, \"uColor\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var source = new fabric.Color(this.color).getSource();\n            source[0] = this.alpha * source[0] / 255;\n            source[1] = this.alpha * source[1] / 255;\n            source[2] = this.alpha * source[2] / 255;\n            source[3] = this.alpha;\n            gl.uniform4fv(uniformLocations.uColor, source);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return {\n                type: this.type,\n                color: this.color,\n                mode: this.mode,\n                alpha: this.alpha\n            };\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.BlendColor} Instance of fabric.Image.filters.BlendColor\n   */ fabric.Image.filters.BlendColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Image Blend filter class\n   * @class fabric.Image.filter.BlendImage\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @example\n   * var filter = new fabric.Image.filters.BlendColor({\n   *  color: '#000',\n   *  mode: 'multiply'\n   * });\n   *\n   * var filter = new fabric.Image.filters.BlendImage({\n   *  image: fabricImageObject,\n   *  mode: 'multiply',\n   *  alpha: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.BlendImage = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.BlendImage.prototype */ {\n        type: \"BlendImage\",\n        /**\n     * Color to make the blend operation with. default to a reddish color since black or white\n     * gives always strong result.\n     **/ image: null,\n        /**\n     * Blend mode for the filter (one of \"multiply\", \"mask\")\n     * @type String\n     * @default\n     **/ mode: \"multiply\",\n        /**\n     * alpha value. represent the strength of the blend image operation.\n     * not implemented.\n     **/ alpha: 1,\n        vertexSource: \"attribute vec2 aPosition;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"varying vec2 vTexCoord2;\\n\" + \"uniform mat3 uTransformMatrix;\\n\" + \"void main() {\\n\" + \"vTexCoord = aPosition;\\n\" + \"vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\\n\" + \"gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\\n\" + \"}\",\n        /**\n     * Fragment source for the Multiply program\n     */ fragmentSource: {\n            multiply: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform sampler2D uImage;\\n\" + \"uniform vec4 uColor;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"varying vec2 vTexCoord2;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"vec4 color2 = texture2D(uImage, vTexCoord2);\\n\" + \"color.rgba *= color2.rgba;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            mask: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform sampler2D uImage;\\n\" + \"uniform vec4 uColor;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"varying vec2 vTexCoord2;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"vec4 color2 = texture2D(uImage, vTexCoord2);\\n\" + \"color.a = color2.a;\\n\" + \"gl_FragColor = color;\\n\" + \"}\"\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var cacheKey = this.type + \"_\" + this.mode;\n            var shaderSource = this.fragmentSource[this.mode];\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        applyToWebGL: function(options) {\n            // load texture to blend.\n            var gl = options.context, texture = this.createTexture(options.filterBackend, this.image);\n            this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);\n            this.callSuper(\"applyToWebGL\", options);\n            this.unbindAdditionalTexture(gl, gl.TEXTURE1);\n        },\n        createTexture: function(backend, image) {\n            return backend.getCachedTexture(image.cacheKey, image._element);\n        },\n        /**\n     * Calculate a transformMatrix to adapt the image to blend over\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ calculateMatrix: function() {\n            var image = this.image, width = image._element.width, height = image._element.height;\n            return [\n                1 / image.scaleX,\n                0,\n                0,\n                0,\n                1 / image.scaleY,\n                0,\n                -image.left / width,\n                -image.top / height,\n                1\n            ];\n        },\n        /**\n     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, resources = options.filterBackend.resources, data = imageData.data, iLen = data.length, width = imageData.width, height = imageData.height, tr, tg, tb, ta, r, g, b, a, canvas1, context, image = this.image, blendData;\n            if (!resources.blendImage) {\n                resources.blendImage = fabric.util.createCanvasElement();\n            }\n            canvas1 = resources.blendImage;\n            context = canvas1.getContext(\"2d\");\n            if (canvas1.width !== width || canvas1.height !== height) {\n                canvas1.width = width;\n                canvas1.height = height;\n            } else {\n                context.clearRect(0, 0, width, height);\n            }\n            context.setTransform(image.scaleX, 0, 0, image.scaleY, image.left, image.top);\n            context.drawImage(image._element, 0, 0, width, height);\n            blendData = context.getImageData(0, 0, width, height).data;\n            for(var i = 0; i < iLen; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                a = data[i + 3];\n                tr = blendData[i];\n                tg = blendData[i + 1];\n                tb = blendData[i + 2];\n                ta = blendData[i + 3];\n                switch(this.mode){\n                    case \"multiply\":\n                        data[i] = r * tr / 255;\n                        data[i + 1] = g * tg / 255;\n                        data[i + 2] = b * tb / 255;\n                        data[i + 3] = a * ta / 255;\n                        break;\n                    case \"mask\":\n                        data[i + 3] = ta;\n                        break;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uTransformMatrix: gl.getUniformLocation(program, \"uTransformMatrix\"),\n                uImage: gl.getUniformLocation(program, \"uImage\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var matrix = this.calculateMatrix();\n            gl.uniform1i(uniformLocations.uImage, 1); // texture unit 1.\n            gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return {\n                type: this.type,\n                image: this.image && this.image.toObject(),\n                mode: this.mode,\n                alpha: this.alpha\n            };\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} callback to be invoked after filter creation\n   * @return {fabric.Image.filters.BlendImage} Instance of fabric.Image.filters.BlendImage\n   */ fabric.Image.filters.BlendImage.fromObject = function(object, callback) {\n        fabric.Image.fromObject(object.image, function(image) {\n            var options = fabric.util.object.clone(object);\n            options.image = image;\n            callback(new fabric.Image.filters.BlendImage(options));\n        });\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), pow = Math.pow, floor = Math.floor, sqrt = Math.sqrt, abs = Math.abs, round = Math.round, sin = Math.sin, ceil = Math.ceil, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Resize image filter class\n   * @class fabric.Image.filters.Resize\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Resize();\n   * object.filters.push(filter);\n   * object.applyFilters(canvas.renderAll.bind(canvas));\n   */ filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Resize\",\n        /**\n     * Resize type\n     * for webgl resizeType is just lanczos, for canvas2d can be:\n     * bilinear, hermite, sliceHack, lanczos.\n     * @param {String} resizeType\n     * @default\n     */ resizeType: \"hermite\",\n        /**\n     * Scale factor for resizing, x axis\n     * @param {Number} scaleX\n     * @default\n     */ scaleX: 1,\n        /**\n     * Scale factor for resizing, y axis\n     * @param {Number} scaleY\n     * @default\n     */ scaleY: 1,\n        /**\n     * LanczosLobes parameter for lanczos filter, valid for resizeType lanczos\n     * @param {Number} lanczosLobes\n     * @default\n     */ lanczosLobes: 3,\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uDelta: gl.getUniformLocation(program, \"uDelta\"),\n                uTaps: gl.getUniformLocation(program, \"uTaps\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform2fv(uniformLocations.uDelta, this.horizontal ? [\n                1 / this.width,\n                0\n            ] : [\n                0,\n                1 / this.height\n            ]);\n            gl.uniform1fv(uniformLocations.uTaps, this.taps);\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var filterWindow = this.getFilterWindow(), cacheKey = this.type + \"_\" + filterWindow;\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                var fragmentShader = this.generateShader(filterWindow);\n                options.programCache[cacheKey] = this.createProgram(options.context, fragmentShader);\n            }\n            return options.programCache[cacheKey];\n        },\n        getFilterWindow: function() {\n            var scale = this.tempScale;\n            return Math.ceil(this.lanczosLobes / scale);\n        },\n        getTaps: function() {\n            var lobeFunction = this.lanczosCreate(this.lanczosLobes), scale = this.tempScale, filterWindow = this.getFilterWindow(), taps = new Array(filterWindow);\n            for(var i = 1; i <= filterWindow; i++){\n                taps[i - 1] = lobeFunction(i * scale);\n            }\n            return taps;\n        },\n        /**\n     * Generate vertex and shader sources from the necessary steps numbers\n     * @param {Number} filterWindow\n     */ generateShader: function(filterWindow) {\n            var offsets = new Array(filterWindow), fragmentShader = this.fragmentSourceTOP, filterWindow;\n            for(var i = 1; i <= filterWindow; i++){\n                offsets[i - 1] = i + \".0 * uDelta\";\n            }\n            fragmentShader += \"uniform float uTaps[\" + filterWindow + \"];\\n\";\n            fragmentShader += \"void main() {\\n\";\n            fragmentShader += \"  vec4 color = texture2D(uTexture, vTexCoord);\\n\";\n            fragmentShader += \"  float sum = 1.0;\\n\";\n            offsets.forEach(function(offset, i) {\n                fragmentShader += \"  color += texture2D(uTexture, vTexCoord + \" + offset + \") * uTaps[\" + i + \"];\\n\";\n                fragmentShader += \"  color += texture2D(uTexture, vTexCoord - \" + offset + \") * uTaps[\" + i + \"];\\n\";\n                fragmentShader += \"  sum += 2.0 * uTaps[\" + i + \"];\\n\";\n            });\n            fragmentShader += \"  gl_FragColor = color / sum;\\n\";\n            fragmentShader += \"}\";\n            return fragmentShader;\n        },\n        fragmentSourceTOP: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec2 uDelta;\\n\" + \"varying vec2 vTexCoord;\\n\",\n        /**\n     * Apply the resize filter to the image\n     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be executed\n     * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ applyTo: function(options) {\n            if (options.webgl) {\n                options.passes++;\n                this.width = options.sourceWidth;\n                this.horizontal = true;\n                this.dW = Math.round(this.width * this.scaleX);\n                this.dH = options.sourceHeight;\n                this.tempScale = this.dW / this.width;\n                this.taps = this.getTaps();\n                options.destinationWidth = this.dW;\n                this._setupFrameBuffer(options);\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n                options.sourceWidth = options.destinationWidth;\n                this.height = options.sourceHeight;\n                this.horizontal = false;\n                this.dH = Math.round(this.height * this.scaleY);\n                this.tempScale = this.dH / this.height;\n                this.taps = this.getTaps();\n                options.destinationHeight = this.dH;\n                this._setupFrameBuffer(options);\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n                options.sourceHeight = options.destinationHeight;\n            } else {\n                this.applyTo2d(options);\n            }\n        },\n        isNeutralState: function() {\n            return this.scaleX === 1 && this.scaleY === 1;\n        },\n        lanczosCreate: function(lobes) {\n            return function(x) {\n                if (x >= lobes || x <= -lobes) {\n                    return 0.0;\n                }\n                if (x < 1.19209290E-07 && x > -1.19209290E-07) {\n                    return 1.0;\n                }\n                x *= Math.PI;\n                var xx = x / lobes;\n                return sin(x) / x * sin(xx) / xx;\n            };\n        },\n        /**\n     * Applies filter to canvas element\n     * @memberOf fabric.Image.filters.Resize.prototype\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} scaleX\n     * @param {Number} scaleY\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, scaleX = this.scaleX, scaleY = this.scaleY;\n            this.rcpScaleX = 1 / scaleX;\n            this.rcpScaleY = 1 / scaleY;\n            var oW = imageData.width, oH = imageData.height, dW = round(oW * scaleX), dH = round(oH * scaleY), newData;\n            if (this.resizeType === \"sliceHack\") {\n                newData = this.sliceByTwo(options, oW, oH, dW, dH);\n            } else if (this.resizeType === \"hermite\") {\n                newData = this.hermiteFastResize(options, oW, oH, dW, dH);\n            } else if (this.resizeType === \"bilinear\") {\n                newData = this.bilinearFiltering(options, oW, oH, dW, dH);\n            } else if (this.resizeType === \"lanczos\") {\n                newData = this.lanczosResize(options, oW, oH, dW, dH);\n            }\n            options.imageData = newData;\n        },\n        /**\n     * Filter sliceByTwo\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ sliceByTwo: function(options, oW, oH, dW, dH) {\n            var imageData = options.imageData, mult = 0.5, doneW = false, doneH = false, stepW = oW * mult, stepH = oH * mult, resources = fabric.filterBackend.resources, tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;\n            if (!resources.sliceByTwo) {\n                resources.sliceByTwo = document.createElement(\"canvas\");\n            }\n            tmpCanvas = resources.sliceByTwo;\n            if (tmpCanvas.width < oW * 1.5 || tmpCanvas.height < oH) {\n                tmpCanvas.width = oW * 1.5;\n                tmpCanvas.height = oH;\n            }\n            ctx = tmpCanvas.getContext(\"2d\");\n            ctx.clearRect(0, 0, oW * 1.5, oH);\n            ctx.putImageData(imageData, 0, 0);\n            dW = floor(dW);\n            dH = floor(dH);\n            while(!doneW || !doneH){\n                oW = stepW;\n                oH = stepH;\n                if (dW < floor(stepW * mult)) {\n                    stepW = floor(stepW * mult);\n                } else {\n                    stepW = dW;\n                    doneW = true;\n                }\n                if (dH < floor(stepH * mult)) {\n                    stepH = floor(stepH * mult);\n                } else {\n                    stepH = dH;\n                    doneH = true;\n                }\n                ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);\n                sX = dX;\n                sY = dY;\n                dY += stepH;\n            }\n            return ctx.getImageData(sX, sY, dW, dH);\n        },\n        /**\n     * Filter lanczosResize\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ lanczosResize: function(options, oW, oH, dW, dH) {\n            function process(u) {\n                var v, i, weight, idx, a, red, green, blue, alpha, fX, fY;\n                center.x = (u + 0.5) * ratioX;\n                icenter.x = floor(center.x);\n                for(v = 0; v < dH; v++){\n                    center.y = (v + 0.5) * ratioY;\n                    icenter.y = floor(center.y);\n                    a = 0;\n                    red = 0;\n                    green = 0;\n                    blue = 0;\n                    alpha = 0;\n                    for(i = icenter.x - range2X; i <= icenter.x + range2X; i++){\n                        if (i < 0 || i >= oW) {\n                            continue;\n                        }\n                        fX = floor(1000 * abs(i - center.x));\n                        if (!cacheLanc[fX]) {\n                            cacheLanc[fX] = {};\n                        }\n                        for(var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++){\n                            if (j < 0 || j >= oH) {\n                                continue;\n                            }\n                            fY = floor(1000 * abs(j - center.y));\n                            if (!cacheLanc[fX][fY]) {\n                                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);\n                            }\n                            weight = cacheLanc[fX][fY];\n                            if (weight > 0) {\n                                idx = (j * oW + i) * 4;\n                                a += weight;\n                                red += weight * srcData[idx];\n                                green += weight * srcData[idx + 1];\n                                blue += weight * srcData[idx + 2];\n                                alpha += weight * srcData[idx + 3];\n                            }\n                        }\n                    }\n                    idx = (v * dW + u) * 4;\n                    destData[idx] = red / a;\n                    destData[idx + 1] = green / a;\n                    destData[idx + 2] = blue / a;\n                    destData[idx + 3] = alpha / a;\n                }\n                if (++u < dW) {\n                    return process(u);\n                } else {\n                    return destImg;\n                }\n            }\n            var srcData = options.imageData.data, destImg = options.ctx.createImageData(dW, dH), destData = destImg.data, lanczos = this.lanczosCreate(this.lanczosLobes), ratioX = this.rcpScaleX, ratioY = this.rcpScaleY, rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY, range2X = ceil(ratioX * this.lanczosLobes / 2), range2Y = ceil(ratioY * this.lanczosLobes / 2), cacheLanc = {}, center = {}, icenter = {};\n            return process(0);\n        },\n        /**\n     * bilinearFiltering\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ bilinearFiltering: function(options, oW, oH, dW, dH) {\n            var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl, color, offset = 0, origPix, ratioX = this.rcpScaleX, ratioY = this.rcpScaleY, w4 = 4 * (oW - 1), img = options.imageData, pixels = img.data, destImage = options.ctx.createImageData(dW, dH), destPixels = destImage.data;\n            for(i = 0; i < dH; i++){\n                for(j = 0; j < dW; j++){\n                    x = floor(ratioX * j);\n                    y = floor(ratioY * i);\n                    xDiff = ratioX * j - x;\n                    yDiff = ratioY * i - y;\n                    origPix = 4 * (y * oW + x);\n                    for(chnl = 0; chnl < 4; chnl++){\n                        a = pixels[origPix + chnl];\n                        b = pixels[origPix + 4 + chnl];\n                        c = pixels[origPix + w4 + chnl];\n                        d = pixels[origPix + w4 + 4 + chnl];\n                        color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) + c * yDiff * (1 - xDiff) + d * xDiff * yDiff;\n                        destPixels[offset++] = color;\n                    }\n                }\n            }\n            return destImage;\n        },\n        /**\n     * hermiteFastResize\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ hermiteFastResize: function(options, oW, oH, dW, dH) {\n            var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY, ratioWHalf = ceil(ratioW / 2), ratioHHalf = ceil(ratioH / 2), img = options.imageData, data = img.data, img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;\n            for(var j = 0; j < dH; j++){\n                for(var i = 0; i < dW; i++){\n                    var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0, gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;\n                    for(var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++){\n                        var dy = abs(centerY - (yy + 0.5)) / ratioHHalf, centerX = (i + 0.5) * ratioW, w0 = dy * dy;\n                        for(var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++){\n                            var dx = abs(centerX - (xx + 0.5)) / ratioWHalf, w = sqrt(w0 + dx * dx);\n                            /* eslint-disable max-depth */ if (w > 1 && w < -1) {\n                                continue;\n                            }\n                            //hermite filter\n                            weight = 2 * w * w * w - 3 * w * w + 1;\n                            if (weight > 0) {\n                                dx = 4 * (xx + yy * oW);\n                                //alpha\n                                gxA += weight * data[dx + 3];\n                                weightsAlpha += weight;\n                                //colors\n                                if (data[dx + 3] < 255) {\n                                    weight = weight * data[dx + 3] / 250;\n                                }\n                                gxR += weight * data[dx];\n                                gxG += weight * data[dx + 1];\n                                gxB += weight * data[dx + 2];\n                                weights += weight;\n                            }\n                        /* eslint-enable max-depth */ }\n                    }\n                    data2[x2] = gxR / weights;\n                    data2[x2 + 1] = gxG / weights;\n                    data2[x2 + 2] = gxB / weights;\n                    data2[x2 + 3] = gxA / weightsAlpha;\n                }\n            }\n            return img2;\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return {\n                type: this.type,\n                scaleX: this.scaleX,\n                scaleY: this.scaleY,\n                resizeType: this.resizeType,\n                lanczosLobes: this.lanczosLobes\n            };\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize\n   */ fabric.Image.filters.Resize.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Contrast filter class\n   * @class fabric.Image.filters.Contrast\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Contrast({\n   *   contrast: 0.25\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Contrast\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uContrast;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\\n\" + \"color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * contrast value, range from -1 to 1.\n     * @param {Number} contrast\n     * @default 0\n     */ contrast: 0,\n        mainParameter: \"contrast\",\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Contrast.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)\n     */ /**\n      * Apply the Contrast operation to a Uint8Array representing the pixels of an image.\n      *\n      * @param {Object} options\n      * @param {ImageData} options.imageData The Uint8Array to be filtered.\n      */ applyTo2d: function(options) {\n            if (this.contrast === 0) {\n                return;\n            }\n            var imageData = options.imageData, i, len, data = imageData.data, len = data.length, contrast = Math.floor(this.contrast * 255), contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));\n            for(i = 0; i < len; i += 4){\n                data[i] = contrastF * (data[i] - 128) + 128;\n                data[i + 1] = contrastF * (data[i + 1] - 128) + 128;\n                data[i + 2] = contrastF * (data[i + 2] - 128) + 128;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uContrast: gl.getUniformLocation(program, \"uContrast\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uContrast, this.contrast);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast\n   */ fabric.Image.filters.Contrast.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Saturate filter class\n   * @class fabric.Image.filters.Saturation\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Saturation#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Saturation({\n   *   saturation: 1\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Saturation = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturation.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Saturation\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uSaturation;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float rgMax = max(color.r, color.g);\\n\" + \"float rgbMax = max(rgMax, color.b);\\n\" + \"color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\\n\" + \"color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\\n\" + \"color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Saturation value, from -1 to 1.\n     * Increases/decreases the color saturation.\n     * A value of 0 has no effect.\n     * \n     * @param {Number} saturation\n     * @default\n     */ saturation: 0,\n        mainParameter: \"saturation\",\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Saturate.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)\n     */ /**\n     * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            if (this.saturation === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, len = data.length, adjust = -this.saturation, i, max;\n            for(i = 0; i < len; i += 4){\n                max = Math.max(data[i], data[i + 1], data[i + 2]);\n                data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;\n                data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;\n                data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uSaturation: gl.getUniformLocation(program, \"uSaturation\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uSaturation, -this.saturation);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Saturation} Instance of fabric.Image.filters.Saturate\n   */ fabric.Image.filters.Saturation.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Vibrance filter class\n   * @class fabric.Image.filters.Vibrance\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Vibrance#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Vibrance({\n   *   vibrance: 1\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Vibrance = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Vibrance.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Vibrance\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uVibrance;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float max = max(color.r, max(color.g, color.b));\\n\" + \"float avg = (color.r + color.g + color.b) / 3.0;\\n\" + \"float amt = (abs(max - avg) * 2.0) * uVibrance;\\n\" + \"color.r += max != color.r ? (max - color.r) * amt : 0.00;\\n\" + \"color.g += max != color.g ? (max - color.g) * amt : 0.00;\\n\" + \"color.b += max != color.b ? (max - color.b) * amt : 0.00;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Vibrance value, from -1 to 1.\n     * Increases/decreases the saturation of more muted colors with less effect on saturated colors.\n     * A value of 0 has no effect.\n     * \n     * @param {Number} vibrance\n     * @default\n     */ vibrance: 0,\n        mainParameter: \"vibrance\",\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Vibrance.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.vibrance=0] Vibrance value for the image (between -1 and 1)\n     */ /**\n     * Apply the Vibrance operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            if (this.vibrance === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, len = data.length, adjust = -this.vibrance, i, max, avg, amt;\n            for(i = 0; i < len; i += 4){\n                max = Math.max(data[i], data[i + 1], data[i + 2]);\n                avg = (data[i] + data[i + 1] + data[i + 2]) / 3;\n                amt = Math.abs(max - avg) * 2 / 255 * adjust;\n                data[i] += max !== data[i] ? (max - data[i]) * amt : 0;\n                data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * amt : 0;\n                data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * amt : 0;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uVibrance: gl.getUniformLocation(program, \"uVibrance\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uVibrance, -this.vibrance);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Vibrance} Instance of fabric.Image.filters.Vibrance\n   */ fabric.Image.filters.Vibrance.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Blur filter class\n   * @class fabric.Image.filters.Blur\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Blur#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Blur({\n   *   blur: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.Blur = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blur.prototype */ {\n        type: \"Blur\",\n        /*\n'gl_FragColor = vec4(0.0);',\n'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',\n'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',\n'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',\n'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',\n'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',\n'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',\n'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',\n'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',\n'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',\n'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',\n'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',\n'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',\n'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',\n'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',\n'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',\n*/ /* eslint-disable max-len */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec2 uDelta;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"const float nSamples = 15.0;\\n\" + \"vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\\n\" + \"float random(vec3 scale) {\\n\" + /* use the fragment position for a different seed per-pixel */ \"return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\\n\" + \"}\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0.0);\\n\" + \"float total = 0.0;\\n\" + \"float offset = random(v3offset);\\n\" + \"for (float t = -nSamples; t <= nSamples; t++) {\\n\" + \"float percent = (t + offset - 0.5) / nSamples;\\n\" + \"float weight = 1.0 - abs(percent);\\n\" + \"color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\\n\" + \"total += weight;\\n\" + \"}\\n\" + \"gl_FragColor = color / total;\\n\" + \"}\",\n        /* eslint-enable max-len */ /**\n     * blur value, in percentage of image dimensions.\n     * specific to keep the image blur constant at different resolutions\n     * range between 0 and 1.\n     * @type Number\n     * @default\n     */ blur: 0,\n        mainParameter: \"blur\",\n        applyTo: function(options) {\n            if (options.webgl) {\n                // this aspectRatio is used to give the same blur to vertical and horizontal\n                this.aspectRatio = options.sourceWidth / options.sourceHeight;\n                options.passes++;\n                this._setupFrameBuffer(options);\n                this.horizontal = true;\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n                this._setupFrameBuffer(options);\n                this.horizontal = false;\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n            } else {\n                this.applyTo2d(options);\n            }\n        },\n        applyTo2d: function(options) {\n            // paint canvasEl with current image data.\n            //options.ctx.putImageData(options.imageData, 0, 0);\n            options.imageData = this.simpleBlur(options);\n        },\n        simpleBlur: function(options) {\n            var resources = options.filterBackend.resources, canvas1, canvas2, width = options.imageData.width, height = options.imageData.height;\n            if (!resources.blurLayer1) {\n                resources.blurLayer1 = fabric.util.createCanvasElement();\n                resources.blurLayer2 = fabric.util.createCanvasElement();\n            }\n            canvas1 = resources.blurLayer1;\n            canvas2 = resources.blurLayer2;\n            if (canvas1.width !== width || canvas1.height !== height) {\n                canvas2.width = canvas1.width = width;\n                canvas2.height = canvas1.height = height;\n            }\n            var ctx1 = canvas1.getContext(\"2d\"), ctx2 = canvas2.getContext(\"2d\"), nSamples = 15, random, percent, j, i, blur = this.blur * 0.06 * 0.5;\n            // load first canvas\n            ctx1.putImageData(options.imageData, 0, 0);\n            ctx2.clearRect(0, 0, width, height);\n            for(i = -nSamples; i <= nSamples; i++){\n                random = (Math.random() - 0.5) / 4;\n                percent = i / nSamples;\n                j = blur * percent * width + random;\n                ctx2.globalAlpha = 1 - Math.abs(percent);\n                ctx2.drawImage(canvas1, j, random);\n                ctx1.drawImage(canvas2, 0, 0);\n                ctx2.globalAlpha = 1;\n                ctx2.clearRect(0, 0, canvas2.width, canvas2.height);\n            }\n            for(i = -nSamples; i <= nSamples; i++){\n                random = (Math.random() - 0.5) / 4;\n                percent = i / nSamples;\n                j = blur * percent * height + random;\n                ctx2.globalAlpha = 1 - Math.abs(percent);\n                ctx2.drawImage(canvas1, random, j);\n                ctx1.drawImage(canvas2, 0, 0);\n                ctx2.globalAlpha = 1;\n                ctx2.clearRect(0, 0, canvas2.width, canvas2.height);\n            }\n            options.ctx.drawImage(canvas1, 0, 0);\n            var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);\n            ctx1.globalAlpha = 1;\n            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);\n            return newImageData;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                delta: gl.getUniformLocation(program, \"uDelta\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var delta = this.chooseRightDelta();\n            gl.uniform2fv(uniformLocations.delta, delta);\n        },\n        /**\n     * choose right value of image percentage to blur with\n     * @returns {Array} a numeric array with delta values\n     */ chooseRightDelta: function() {\n            var blurScale = 1, delta = [\n                0,\n                0\n            ], blur;\n            if (this.horizontal) {\n                if (this.aspectRatio > 1) {\n                    // image is wide, i want to shrink radius horizontal\n                    blurScale = 1 / this.aspectRatio;\n                }\n            } else {\n                if (this.aspectRatio < 1) {\n                    // image is tall, i want to shrink radius vertical\n                    blurScale = this.aspectRatio;\n                }\n            }\n            blur = blurScale * this.blur * 0.12;\n            if (this.horizontal) {\n                delta[0] = blur;\n            } else {\n                delta[1] = blur;\n            }\n            return delta;\n        }\n    });\n    /**\n   * Deserialize a JSON definition of a BlurFilter into a concrete instance.\n   */ filters.Blur.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Gamma filter class\n   * @class fabric.Image.filters.Gamma\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Gamma#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Gamma({\n   *   gamma: [1, 0.5, 2.1]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Gamma = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Gamma.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Gamma\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec3 uGamma;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"vec3 correction = (1.0 / uGamma);\\n\" + \"color.r = pow(color.r, correction.r);\\n\" + \"color.g = pow(color.g, correction.g);\\n\" + \"color.b = pow(color.b, correction.b);\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.rgb *= color.a;\\n\" + \"}\",\n        /**\n     * Gamma array value, from 0.01 to 2.2.\n     * @param {Array} gamma\n     * @default\n     */ gamma: [\n            1,\n            1,\n            1\n        ],\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"gamma\",\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            this.gamma = [\n                1,\n                1,\n                1\n            ];\n            filters.BaseFilter.prototype.initialize.call(this, options);\n        },\n        /**\n     * Apply the Gamma operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, gamma = this.gamma, len = data.length, rInv = 1 / gamma[0], gInv = 1 / gamma[1], bInv = 1 / gamma[2], i;\n            if (!this.rVals) {\n                // eslint-disable-next-line\n                this.rVals = new Uint8Array(256);\n                // eslint-disable-next-line\n                this.gVals = new Uint8Array(256);\n                // eslint-disable-next-line\n                this.bVals = new Uint8Array(256);\n            }\n            // This is an optimization - pre-compute a look-up table for each color channel\n            // instead of performing these pow calls for each pixel in the image.\n            for(i = 0, len = 256; i < len; i++){\n                this.rVals[i] = Math.pow(i / 255, rInv) * 255;\n                this.gVals[i] = Math.pow(i / 255, gInv) * 255;\n                this.bVals[i] = Math.pow(i / 255, bInv) * 255;\n            }\n            for(i = 0, len = data.length; i < len; i += 4){\n                data[i] = this.rVals[data[i]];\n                data[i + 1] = this.gVals[data[i + 1]];\n                data[i + 2] = this.bVals[data[i + 2]];\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uGamma: gl.getUniformLocation(program, \"uGamma\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform3fv(uniformLocations.uGamma, this.gamma);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Gamma} Instance of fabric.Image.filters.Gamma\n   */ fabric.Image.filters.Gamma.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * A container class that knows how to apply a sequence of filters to an input image.\n   */ filters.Composed = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Composed.prototype */ {\n        type: \"Composed\",\n        /**\n     * A non sparse array of filters to apply\n     */ subFilters: [],\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            // create a new array instead mutating the prototype with push\n            this.subFilters = this.subFilters.slice(0);\n        },\n        /**\n     * Apply this container's filters to the input image provided.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be applied.\n     */ applyTo: function(options) {\n            options.passes += this.subFilters.length - 1;\n            this.subFilters.forEach(function(filter) {\n                filter.applyTo(options);\n            });\n        },\n        /**\n     * Serialize this filter into JSON.\n     *\n     * @returns {Object} A JSON representation of this filter.\n     */ toObject: function() {\n            return fabric.util.object.extend(this.callSuper(\"toObject\"), {\n                subFilters: this.subFilters.map(function(filter) {\n                    return filter.toObject();\n                })\n            });\n        },\n        isNeutralState: function() {\n            return !this.subFilters.some(function(filter) {\n                return !filter.isNeutralState();\n            });\n        }\n    });\n    /**\n   * Deserialize a JSON definition of a ComposedFilter into a concrete instance.\n   */ fabric.Image.filters.Composed.fromObject = function(object, callback) {\n        var filters = object.subFilters || [], subFilters = filters.map(function(filter) {\n            return new fabric.Image.filters[filter.type](filter);\n        }), instance = new fabric.Image.filters.Composed({\n            subFilters: subFilters\n        });\n        callback && callback(instance);\n        return instance;\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * HueRotation filter class\n   * @class fabric.Image.filters.HueRotation\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.HueRotation#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.HueRotation({\n   *   rotation: -0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.HueRotation = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.HueRotation.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"HueRotation\",\n        /**\n     * HueRotation value, from -1 to 1.\n     * the unit is radians\n     * @param {Number} myParameter\n     * @default\n     */ rotation: 0,\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"rotation\",\n        calculateMatrix: function() {\n            var rad = this.rotation * Math.PI, cos = fabric.util.cos(rad), sin = fabric.util.sin(rad), aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;\n            this.matrix = [\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0\n            ];\n            this.matrix[0] = cos + OneMinusCos / 3;\n            this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;\n            this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;\n            this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;\n            this.matrix[6] = cos + aThird * OneMinusCos;\n            this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;\n            this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;\n            this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;\n            this.matrix[12] = cos + aThird * OneMinusCos;\n        },\n        /**\n     * HueRotation isNeutralState implementation\n     * Used only in image applyFilters to discard filters that will not have an effect\n     * on the image\n     * @param {Object} options\n     **/ isNeutralState: function(options) {\n            this.calculateMatrix();\n            return filters.BaseFilter.prototype.isNeutralState.call(this, options);\n        },\n        /**\n     * Apply this filter to the input image data provided.\n     *\n     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be executed\n     * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ applyTo: function(options) {\n            this.calculateMatrix();\n            filters.BaseFilter.prototype.applyTo.call(this, options);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.HueRotation} Instance of fabric.Image.filters.HueRotation\n   */ fabric.Image.filters.HueRotation.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), clone = fabric.util.object.clone;\n    if (fabric.Text) {\n        fabric.warn(\"fabric.Text is already defined\");\n        return;\n    }\n    var additionalProps = (\"fontFamily fontWeight fontSize text underline overline linethrough\" + \" textAlign fontStyle lineHeight textBackgroundColor charSpacing styles\" + \" direction path pathStartOffset pathSide pathAlign\").split(\" \");\n    /**\n   * Text class\n   * @class fabric.Text\n   * @extends fabric.Object\n   * @return {fabric.Text} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}\n   * @see {@link fabric.Text#initialize} for constructor definition\n   */ fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {\n        /**\n     * Properties which when set cause object to change dimensions\n     * @type Array\n     * @private\n     */ _dimensionAffectingProps: [\n            \"fontSize\",\n            \"fontWeight\",\n            \"fontFamily\",\n            \"fontStyle\",\n            \"lineHeight\",\n            \"text\",\n            \"charSpacing\",\n            \"textAlign\",\n            \"styles\",\n            \"path\",\n            \"pathStartOffset\",\n            \"pathSide\",\n            \"pathAlign\"\n        ],\n        /**\n     * @private\n     */ _reNewline: /\\r?\\n/,\n        /**\n     * Use this regular expression to filter for whitespaces that is not a new line.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */ _reSpacesAndTabs: /[ \\t\\r]/g,\n        /**\n     * Use this regular expression to filter for whitespace that is not a new line.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */ _reSpaceAndTab: /[ \\t\\r]/,\n        /**\n     * Use this regular expression to filter consecutive groups of non spaces.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */ _reWords: /\\S+/g,\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"text\",\n        /**\n     * Font size (in pixels)\n     * @type Number\n     * @default\n     */ fontSize: 40,\n        /**\n     * Font weight (e.g. bold, normal, 400, 600, 800)\n     * @type {(Number|String)}\n     * @default\n     */ fontWeight: \"normal\",\n        /**\n     * Font family\n     * @type String\n     * @default\n     */ fontFamily: \"Times New Roman\",\n        /**\n     * Text decoration underline.\n     * @type Boolean\n     * @default\n     */ underline: false,\n        /**\n     * Text decoration overline.\n     * @type Boolean\n     * @default\n     */ overline: false,\n        /**\n     * Text decoration linethrough.\n     * @type Boolean\n     * @default\n     */ linethrough: false,\n        /**\n     * Text alignment. Possible values: \"left\", \"center\", \"right\", \"justify\",\n     * \"justify-left\", \"justify-center\" or \"justify-right\".\n     * @type String\n     * @default\n     */ textAlign: \"left\",\n        /**\n     * Font style . Possible values: \"\", \"normal\", \"italic\" or \"oblique\".\n     * @type String\n     * @default\n     */ fontStyle: \"normal\",\n        /**\n     * Line height\n     * @type Number\n     * @default\n     */ lineHeight: 1.16,\n        /**\n     * Superscript schema object (minimum overlap)\n     * @type {Object}\n     * @default\n     */ superscript: {\n            size: 0.60,\n            baseline: -0.35 // baseline-shift factor (upwards)\n        },\n        /**\n     * Subscript schema object (minimum overlap)\n     * @type {Object}\n     * @default\n     */ subscript: {\n            size: 0.60,\n            baseline: 0.11 // baseline-shift factor (downwards)\n        },\n        /**\n     * Background color of text lines\n     * @type String\n     * @default\n     */ textBackgroundColor: \"\",\n        /**\n     * List of properties to consider when checking if\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: fabric.Object.prototype.stateProperties.concat(additionalProps),\n        /**\n     * List of properties to consider when checking if cache needs refresh\n     * @type Array\n     */ cacheProperties: fabric.Object.prototype.cacheProperties.concat(additionalProps),\n        /**\n     * When defined, an object is rendered via stroke and this property specifies its color.\n     * <b>Backwards incompatibility note:</b> This property was named \"strokeStyle\" until v1.1.6\n     * @type String\n     * @default\n     */ stroke: null,\n        /**\n     * Shadow object representing shadow of this shape.\n     * <b>Backwards incompatibility note:</b> This property was named \"textShadow\" (String) until v1.2.11\n     * @type fabric.Shadow\n     * @default\n     */ shadow: null,\n        /**\n     * fabric.Path that the text should follow.\n     * since 4.6.0 the path will be drawn automatically.\n     * if you want to make the path visible, give it a stroke and strokeWidth or fill value\n     * if you want it to be hidden, assign visible = false to the path.\n     * This feature is in BETA, and SVG import/export is not yet supported.\n     * @type fabric.Path\n     * @example\n     * var textPath = new fabric.Text('Text on a path', {\n     *     top: 150,\n     *     left: 150,\n     *     textAlign: 'center',\n     *     charSpacing: -50,\n     *     path: new fabric.Path('M 0 0 C 50 -100 150 -100 200 0', {\n     *         strokeWidth: 1,\n     *         visible: false\n     *     }),\n     *     pathSide: 'left',\n     *     pathStartOffset: 0\n     * });\n     * @default\n     */ path: null,\n        /**\n     * Offset amount for text path starting position\n     * Only used when text has a path\n     * @type Number\n     * @default\n     */ pathStartOffset: 0,\n        /**\n     * Which side of the path the text should be drawn on.\n     * Only used when text has a path\n     * @type {String} 'left|right'\n     * @default\n     */ pathSide: \"left\",\n        /**\n     * How text is aligned to the path. This property determines\n     * the perpendicular position of each character relative to the path.\n     * (one of \"baseline\", \"center\", \"ascender\", \"descender\")\n     * This feature is in BETA, and its behavior may change\n     * @type String\n     * @default\n     */ pathAlign: \"baseline\",\n        /**\n     * @private\n     */ _fontSizeFraction: 0.222,\n        /**\n     * @private\n     */ offsets: {\n            underline: 0.10,\n            linethrough: -0.315,\n            overline: -0.88\n        },\n        /**\n     * Text Line proportion to font Size (in pixels)\n     * @type Number\n     * @default\n     */ _fontSizeMult: 1.13,\n        /**\n     * additional space between characters\n     * expressed in thousands of em unit\n     * @type Number\n     * @default\n     */ charSpacing: 0,\n        /**\n     * Object containing character styles - top-level properties -> line numbers,\n     * 2nd-level properties - character numbers\n     * @type Object\n     * @default\n     */ styles: null,\n        /**\n     * Reference to a context to measure text char or couple of chars\n     * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas\n     * once created it will be referenced on fabric._measuringContext to avoid creating a canvas for every\n     * text object created.\n     * @type {CanvasRenderingContext2D}\n     * @default\n     */ _measuringContext: null,\n        /**\n     * Baseline shift, styles only, keep at 0 for the main text object\n     * @type {Number}\n     * @default\n     */ deltaY: 0,\n        /**\n     * WARNING: EXPERIMENTAL. NOT SUPPORTED YET\n     * determine the direction of the text.\n     * This has to be set manually together with textAlign and originX for proper\n     * experience.\n     * some interesting link for the future\n     * https://www.w3.org/International/questions/qa-bidi-unicode-controls\n     * @since 4.5.0\n     * @type {String} 'ltr|rtl'\n     * @default\n     */ direction: \"ltr\",\n        /**\n     * Array of properties that define a style unit (of 'styles').\n     * @type {Array}\n     * @default\n     */ _styleProperties: [\n            \"stroke\",\n            \"strokeWidth\",\n            \"fill\",\n            \"fontFamily\",\n            \"fontSize\",\n            \"fontWeight\",\n            \"fontStyle\",\n            \"underline\",\n            \"overline\",\n            \"linethrough\",\n            \"deltaY\",\n            \"textBackgroundColor\"\n        ],\n        /**\n     * contains characters bounding boxes\n     */ __charBounds: [],\n        /**\n     * use this size when measuring text. To avoid IE11 rounding errors\n     * @type {Number}\n     * @default\n     * @readonly\n     * @private\n     */ CACHE_FONT_SIZE: 400,\n        /**\n     * contains the min text width to avoid getting 0\n     * @type {Number}\n     * @default\n     */ MIN_TEXT_WIDTH: 2,\n        /**\n     * Constructor\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.Text} thisArg\n     */ initialize: function(text, options) {\n            this.styles = options ? options.styles || {} : {};\n            this.text = text;\n            this.__skipDimension = true;\n            this.callSuper(\"initialize\", options);\n            if (this.path) {\n                this.setPathInfo();\n            }\n            this.__skipDimension = false;\n            this.initDimensions();\n            this.setCoords();\n            this.setupState({\n                propertySet: \"_dimensionAffectingProps\"\n            });\n        },\n        /**\n     * If text has a path, it will add the extra information needed\n     * for path and text calculations\n     * @return {fabric.Text} thisArg\n     */ setPathInfo: function() {\n            var path = this.path;\n            if (path) {\n                path.segmentsInfo = fabric.util.getPathSegmentsInfo(path.path);\n            }\n        },\n        /**\n     * Return a context for measurement of text string.\n     * if created it gets stored for reuse\n     * this is for internal use, please do not use it\n     * @private\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.Text} thisArg\n     */ getMeasuringContext: function() {\n            // if we did not return we have to measure something.\n            if (!fabric._measuringContext) {\n                fabric._measuringContext = this.canvas && this.canvas.contextCache || fabric.util.createCanvasElement().getContext(\"2d\");\n            }\n            return fabric._measuringContext;\n        },\n        /**\n     * @private\n     * Divides text into lines of text and lines of graphemes.\n     */ _splitText: function() {\n            var newLines = this._splitTextIntoLines(this.text);\n            this.textLines = newLines.lines;\n            this._textLines = newLines.graphemeLines;\n            this._unwrappedTextLines = newLines._unwrappedLines;\n            this._text = newLines.graphemeText;\n            return newLines;\n        },\n        /**\n     * Initialize or update text dimensions.\n     * Updates this.width and this.height with the proper values.\n     * Does not return dimensions.\n     */ initDimensions: function() {\n            if (this.__skipDimension) {\n                return;\n            }\n            this._splitText();\n            this._clearCache();\n            if (this.path) {\n                this.width = this.path.width;\n                this.height = this.path.height;\n            } else {\n                this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;\n                this.height = this.calcTextHeight();\n            }\n            if (this.textAlign.indexOf(\"justify\") !== -1) {\n                // once text is measured we need to make space fatter to make justified text.\n                this.enlargeSpaces();\n            }\n            this.saveState({\n                propertySet: \"_dimensionAffectingProps\"\n            });\n        },\n        /**\n     * Enlarge space boxes and shift the others\n     */ enlargeSpaces: function() {\n            var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                if (this.textAlign !== \"justify\" && (i === len - 1 || this.isEndOfWrapping(i))) {\n                    continue;\n                }\n                accumulatedSpace = 0;\n                line = this._textLines[i];\n                currentLineWidth = this.getLineWidth(i);\n                if (currentLineWidth < this.width && (spaces = this.textLines[i].match(this._reSpacesAndTabs))) {\n                    numberOfSpaces = spaces.length;\n                    diffSpace = (this.width - currentLineWidth) / numberOfSpaces;\n                    for(var j = 0, jlen = line.length; j <= jlen; j++){\n                        charBound = this.__charBounds[i][j];\n                        if (this._reSpaceAndTab.test(line[j])) {\n                            charBound.width += diffSpace;\n                            charBound.kernedWidth += diffSpace;\n                            charBound.left += accumulatedSpace;\n                            accumulatedSpace += diffSpace;\n                        } else {\n                            charBound.left += accumulatedSpace;\n                        }\n                    }\n                }\n            }\n        },\n        /**\n     * Detect if the text line is ended with an hard break\n     * text and itext do not have wrapping, return false\n     * @return {Boolean}\n     */ isEndOfWrapping: function(lineIndex) {\n            return lineIndex === this._textLines.length - 1;\n        },\n        /**\n     * Detect if a line has a linebreak and so we need to account for it when moving\n     * and counting style.\n     * It return always for text and Itext.\n     * @return Number\n     */ missingNewlineOffset: function() {\n            return 1;\n        },\n        /**\n     * Returns string representation of an instance\n     * @return {String} String representation of text object\n     */ toString: function() {\n            return \"#<fabric.Text (\" + this.complexity() + '): { \"text\": \"' + this.text + '\", \"fontFamily\": \"' + this.fontFamily + '\" }>';\n        },\n        /**\n     * Return the dimension and the zoom level needed to create a cache canvas\n     * big enough to host the object to be cached.\n     * @private\n     * @param {Object} dim.x width of object to be cached\n     * @param {Object} dim.y height of object to be cached\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */ _getCacheCanvasDimensions: function() {\n            var dims = this.callSuper(\"_getCacheCanvasDimensions\");\n            var fontSize = this.fontSize;\n            dims.width += fontSize * dims.zoomX;\n            dims.height += fontSize * dims.zoomY;\n            return dims;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            var path = this.path;\n            path && !path.isNotVisible() && path._render(ctx);\n            this._setTextStyles(ctx);\n            this._renderTextLinesBackground(ctx);\n            this._renderTextDecoration(ctx, \"underline\");\n            this._renderText(ctx);\n            this._renderTextDecoration(ctx, \"overline\");\n            this._renderTextDecoration(ctx, \"linethrough\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderText: function(ctx) {\n            if (this.paintFirst === \"stroke\") {\n                this._renderTextStroke(ctx);\n                this._renderTextFill(ctx);\n            } else {\n                this._renderTextFill(ctx);\n                this._renderTextStroke(ctx);\n            }\n        },\n        /**\n     * Set the font parameter of the context with the object properties or with charStyle\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [charStyle] object with font style properties\n     * @param {String} [charStyle.fontFamily] Font Family\n     * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )\n     * @param {String} [charStyle.fontWeight] Font weight\n     * @param {String} [charStyle.fontStyle] Font style (italic|normal)\n     */ _setTextStyles: function(ctx, charStyle, forMeasuring) {\n            ctx.textBaseline = \"alphabetical\";\n            if (this.path) {\n                switch(this.pathAlign){\n                    case \"center\":\n                        ctx.textBaseline = \"middle\";\n                        break;\n                    case \"ascender\":\n                        ctx.textBaseline = \"top\";\n                        break;\n                    case \"descender\":\n                        ctx.textBaseline = \"bottom\";\n                        break;\n                }\n            }\n            ctx.font = this._getFontDeclaration(charStyle, forMeasuring);\n        },\n        /**\n     * calculate and return the text Width measuring each line.\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @return {Number} Maximum width of fabric.Text object\n     */ calcTextWidth: function() {\n            var maxWidth = this.getLineWidth(0);\n            for(var i = 1, len = this._textLines.length; i < len; i++){\n                var currentLineWidth = this.getLineWidth(i);\n                if (currentLineWidth > maxWidth) {\n                    maxWidth = currentLineWidth;\n                }\n            }\n            return maxWidth;\n        },\n        /**\n     * @private\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {String} line Text to render\n     * @param {Number} left Left position of text\n     * @param {Number} top Top position of text\n     * @param {Number} lineIndex Index of a line in a text\n     */ _renderTextLine: function(method, ctx, line, left, top, lineIndex) {\n            this._renderChars(method, ctx, line, left, top, lineIndex);\n        },\n        /**\n     * Renders the text background for lines, taking care of style\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextLinesBackground: function(ctx) {\n            if (!this.textBackgroundColor && !this.styleHas(\"textBackgroundColor\")) {\n                return;\n            }\n            var heightOfLine, lineLeftOffset, originalFill = ctx.fillStyle, line, lastColor, leftOffset = this._getLeftOffset(), lineTopOffset = this._getTopOffset(), boxStart = 0, boxWidth = 0, charBox, currentColor, path = this.path, drawStart;\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                heightOfLine = this.getHeightOfLine(i);\n                if (!this.textBackgroundColor && !this.styleHas(\"textBackgroundColor\", i)) {\n                    lineTopOffset += heightOfLine;\n                    continue;\n                }\n                line = this._textLines[i];\n                lineLeftOffset = this._getLineLeftOffset(i);\n                boxWidth = 0;\n                boxStart = 0;\n                lastColor = this.getValueOfPropertyAt(i, 0, \"textBackgroundColor\");\n                for(var j = 0, jlen = line.length; j < jlen; j++){\n                    charBox = this.__charBounds[i][j];\n                    currentColor = this.getValueOfPropertyAt(i, j, \"textBackgroundColor\");\n                    if (path) {\n                        ctx.save();\n                        ctx.translate(charBox.renderLeft, charBox.renderTop);\n                        ctx.rotate(charBox.angle);\n                        ctx.fillStyle = currentColor;\n                        currentColor && ctx.fillRect(-charBox.width / 2, -heightOfLine / this.lineHeight * (1 - this._fontSizeFraction), charBox.width, heightOfLine / this.lineHeight);\n                        ctx.restore();\n                    } else if (currentColor !== lastColor) {\n                        drawStart = leftOffset + lineLeftOffset + boxStart;\n                        if (this.direction === \"rtl\") {\n                            drawStart = this.width - drawStart - boxWidth;\n                        }\n                        ctx.fillStyle = lastColor;\n                        lastColor && ctx.fillRect(drawStart, lineTopOffset, boxWidth, heightOfLine / this.lineHeight);\n                        boxStart = charBox.left;\n                        boxWidth = charBox.width;\n                        lastColor = currentColor;\n                    } else {\n                        boxWidth += charBox.kernedWidth;\n                    }\n                }\n                if (currentColor && !path) {\n                    drawStart = leftOffset + lineLeftOffset + boxStart;\n                    if (this.direction === \"rtl\") {\n                        drawStart = this.width - drawStart - boxWidth;\n                    }\n                    ctx.fillStyle = currentColor;\n                    ctx.fillRect(drawStart, lineTopOffset, boxWidth, heightOfLine / this.lineHeight);\n                }\n                lineTopOffset += heightOfLine;\n            }\n            ctx.fillStyle = originalFill;\n            // if there is text background color no\n            // other shadows should be casted\n            this._removeShadow(ctx);\n        },\n        /**\n     * @private\n     * @param {Object} decl style declaration for cache\n     * @param {String} decl.fontFamily fontFamily\n     * @param {String} decl.fontStyle fontStyle\n     * @param {String} decl.fontWeight fontWeight\n     * @return {Object} reference to cache\n     */ getFontCache: function(decl) {\n            var fontFamily = decl.fontFamily.toLowerCase();\n            if (!fabric.charWidthsCache[fontFamily]) {\n                fabric.charWidthsCache[fontFamily] = {};\n            }\n            var cache = fabric.charWidthsCache[fontFamily], cacheProp = decl.fontStyle.toLowerCase() + \"_\" + (decl.fontWeight + \"\").toLowerCase();\n            if (!cache[cacheProp]) {\n                cache[cacheProp] = {};\n            }\n            return cache[cacheProp];\n        },\n        /**\n     * measure and return the width of a single character.\n     * possibly overridden to accommodate different measure logic or\n     * to hook some external lib for character measurement\n     * @private\n     * @param {String} _char, char to be measured\n     * @param {Object} charStyle style of char to be measured\n     * @param {String} [previousChar] previous char\n     * @param {Object} [prevCharStyle] style of previous char\n     */ _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {\n            // first i try to return from cache\n            var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle), previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char, stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth, fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE, kernedWidth;\n            if (previousChar && fontCache[previousChar] !== undefined) {\n                previousWidth = fontCache[previousChar];\n            }\n            if (fontCache[_char] !== undefined) {\n                kernedWidth = width = fontCache[_char];\n            }\n            if (stylesAreEqual && fontCache[couple] !== undefined) {\n                coupleWidth = fontCache[couple];\n                kernedWidth = coupleWidth - previousWidth;\n            }\n            if (width === undefined || previousWidth === undefined || coupleWidth === undefined) {\n                var ctx = this.getMeasuringContext();\n                // send a TRUE to specify measuring font size CACHE_FONT_SIZE\n                this._setTextStyles(ctx, charStyle, true);\n            }\n            if (width === undefined) {\n                kernedWidth = width = ctx.measureText(_char).width;\n                fontCache[_char] = width;\n            }\n            if (previousWidth === undefined && stylesAreEqual && previousChar) {\n                previousWidth = ctx.measureText(previousChar).width;\n                fontCache[previousChar] = previousWidth;\n            }\n            if (stylesAreEqual && coupleWidth === undefined) {\n                // we can measure the kerning couple and subtract the width of the previous character\n                coupleWidth = ctx.measureText(couple).width;\n                fontCache[couple] = coupleWidth;\n                kernedWidth = coupleWidth - previousWidth;\n            }\n            return {\n                width: width * fontMultiplier,\n                kernedWidth: kernedWidth * fontMultiplier\n            };\n        },\n        /**\n     * Computes height of character at given position\n     * @param {Number} line the line index number\n     * @param {Number} _char the character index number\n     * @return {Number} fontSize of the character\n     */ getHeightOfChar: function(line, _char) {\n            return this.getValueOfPropertyAt(line, _char, \"fontSize\");\n        },\n        /**\n     * measure a text line measuring all characters.\n     * @param {Number} lineIndex line number\n     * @return {Number} Line width\n     */ measureLine: function(lineIndex) {\n            var lineInfo = this._measureLine(lineIndex);\n            if (this.charSpacing !== 0) {\n                lineInfo.width -= this._getWidthOfCharSpacing();\n            }\n            if (lineInfo.width < 0) {\n                lineInfo.width = 0;\n            }\n            return lineInfo;\n        },\n        /**\n     * measure every grapheme of a line, populating __charBounds\n     * @param {Number} lineIndex\n     * @return {Object} object.width total width of characters\n     * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs\n     */ _measureLine: function(lineIndex) {\n            var width = 0, i, grapheme, line = this._textLines[lineIndex], prevGrapheme, graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length), positionInPath = 0, startingPoint, totalPathLength, path = this.path, reverse = this.pathSide === \"right\";\n            this.__charBounds[lineIndex] = lineBounds;\n            for(i = 0; i < line.length; i++){\n                grapheme = line[i];\n                graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);\n                lineBounds[i] = graphemeInfo;\n                width += graphemeInfo.kernedWidth;\n                prevGrapheme = grapheme;\n            }\n            // this latest bound box represent the last character of the line\n            // to simplify cursor handling in interactive mode.\n            lineBounds[i] = {\n                left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,\n                width: 0,\n                kernedWidth: 0,\n                height: this.fontSize\n            };\n            if (path) {\n                totalPathLength = path.segmentsInfo[path.segmentsInfo.length - 1].length;\n                startingPoint = fabric.util.getPointOnPath(path.path, 0, path.segmentsInfo);\n                startingPoint.x += path.pathOffset.x;\n                startingPoint.y += path.pathOffset.y;\n                switch(this.textAlign){\n                    case \"left\":\n                        positionInPath = reverse ? totalPathLength - width : 0;\n                        break;\n                    case \"center\":\n                        positionInPath = (totalPathLength - width) / 2;\n                        break;\n                    case \"right\":\n                        positionInPath = reverse ? 0 : totalPathLength - width;\n                        break;\n                }\n                positionInPath += this.pathStartOffset * (reverse ? -1 : 1);\n                for(i = reverse ? line.length - 1 : 0; reverse ? i >= 0 : i < line.length; reverse ? i-- : i++){\n                    graphemeInfo = lineBounds[i];\n                    if (positionInPath > totalPathLength) {\n                        positionInPath %= totalPathLength;\n                    } else if (positionInPath < 0) {\n                        positionInPath += totalPathLength;\n                    }\n                    // it would probably much faster to send all the grapheme position for a line\n                    // and calculate path position/angle at once.\n                    this._setGraphemeOnPath(positionInPath, graphemeInfo, startingPoint);\n                    positionInPath += graphemeInfo.kernedWidth;\n                }\n            }\n            return {\n                width: width,\n                numOfSpaces: numOfSpaces\n            };\n        },\n        /**\n     * Calculate the angle  and the left,top position of the char that follow a path.\n     * It appends it to graphemeInfo to be reused later at rendering\n     * @private\n     * @param {Number} positionInPath to be measured\n     * @param {Object} graphemeInfo current grapheme box information\n     * @param {Object} startingPoint position of the point\n     */ _setGraphemeOnPath: function(positionInPath, graphemeInfo, startingPoint) {\n            var centerPosition = positionInPath + graphemeInfo.kernedWidth / 2, path = this.path;\n            // we are at currentPositionOnPath. we want to know what point on the path is.\n            var info = fabric.util.getPointOnPath(path.path, centerPosition, path.segmentsInfo);\n            graphemeInfo.renderLeft = info.x - startingPoint.x;\n            graphemeInfo.renderTop = info.y - startingPoint.y;\n            graphemeInfo.angle = info.angle + (this.pathSide === \"right\" ? Math.PI : 0);\n        },\n        /**\n     * Measure and return the info of a single grapheme.\n     * needs the the info of previous graphemes already filled\n     * @private\n     * @param {String} grapheme to be measured\n     * @param {Number} lineIndex index of the line where the char is\n     * @param {Number} charIndex position in the line\n     * @param {String} [prevGrapheme] character preceding the one to be measured\n     */ _getGraphemeBox: function(grapheme, lineIndex, charIndex, prevGrapheme, skipLeft) {\n            var style = this.getCompleteStyleDeclaration(lineIndex, charIndex), prevStyle = prevGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : {}, info = this._measureChar(grapheme, style, prevGrapheme, prevStyle), kernedWidth = info.kernedWidth, width = info.width, charSpacing;\n            if (this.charSpacing !== 0) {\n                charSpacing = this._getWidthOfCharSpacing();\n                width += charSpacing;\n                kernedWidth += charSpacing;\n            }\n            var box = {\n                width: width,\n                left: 0,\n                height: style.fontSize,\n                kernedWidth: kernedWidth,\n                deltaY: style.deltaY\n            };\n            if (charIndex > 0 && !skipLeft) {\n                var previousBox = this.__charBounds[lineIndex][charIndex - 1];\n                box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;\n            }\n            return box;\n        },\n        /**\n     * Calculate height of line at 'lineIndex'\n     * @param {Number} lineIndex index of line to calculate\n     * @return {Number}\n     */ getHeightOfLine: function(lineIndex) {\n            if (this.__lineHeights[lineIndex]) {\n                return this.__lineHeights[lineIndex];\n            }\n            var line = this._textLines[lineIndex], // char 0 is measured before the line cycle because it nneds to char\n            // emptylines\n            maxHeight = this.getHeightOfChar(lineIndex, 0);\n            for(var i = 1, len = line.length; i < len; i++){\n                maxHeight = Math.max(this.getHeightOfChar(lineIndex, i), maxHeight);\n            }\n            return this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;\n        },\n        /**\n     * Calculate text box height\n     */ calcTextHeight: function() {\n            var lineHeight, height = 0;\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                lineHeight = this.getHeightOfLine(i);\n                height += i === len - 1 ? lineHeight / this.lineHeight : lineHeight;\n            }\n            return height;\n        },\n        /**\n     * @private\n     * @return {Number} Left offset\n     */ _getLeftOffset: function() {\n            return this.direction === \"ltr\" ? -this.width / 2 : this.width / 2;\n        },\n        /**\n     * @private\n     * @return {Number} Top offset\n     */ _getTopOffset: function() {\n            return -this.height / 2;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\n     */ _renderTextCommon: function(ctx, method) {\n            ctx.save();\n            var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset();\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                var heightOfLine = this.getHeightOfLine(i), maxHeight = heightOfLine / this.lineHeight, leftOffset = this._getLineLeftOffset(i);\n                this._renderTextLine(method, ctx, this._textLines[i], left + leftOffset, top + lineHeights + maxHeight, i);\n                lineHeights += heightOfLine;\n            }\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextFill: function(ctx) {\n            if (!this.fill && !this.styleHas(\"fill\")) {\n                return;\n            }\n            this._renderTextCommon(ctx, \"fillText\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextStroke: function(ctx) {\n            if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {\n                return;\n            }\n            if (this.shadow && !this.shadow.affectStroke) {\n                this._removeShadow(ctx);\n            }\n            ctx.save();\n            this._setLineDash(ctx, this.strokeDashArray);\n            ctx.beginPath();\n            this._renderTextCommon(ctx, \"strokeText\");\n            ctx.closePath();\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {String} method fillText or strokeText.\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Array} line Content of the line, splitted in an array by grapheme\n     * @param {Number} left\n     * @param {Number} top\n     * @param {Number} lineIndex\n     */ _renderChars: function(method, ctx, line, left, top, lineIndex) {\n            // set proper line offset\n            var lineHeight = this.getHeightOfLine(lineIndex), isJustify = this.textAlign.indexOf(\"justify\") !== -1, actualStyle, nextStyle, charsToRender = \"\", charBox, boxWidth = 0, timeToRender, path = this.path, shortCut = !isJustify && this.charSpacing === 0 && this.isEmptyStyles(lineIndex) && !path, isLtr = this.direction === \"ltr\", sign = this.direction === \"ltr\" ? 1 : -1, drawingLeft, currentDirection = ctx.canvas.getAttribute(\"dir\");\n            ctx.save();\n            if (currentDirection !== this.direction) {\n                ctx.canvas.setAttribute(\"dir\", isLtr ? \"ltr\" : \"rtl\");\n                ctx.direction = isLtr ? \"ltr\" : \"rtl\";\n                ctx.textAlign = isLtr ? \"left\" : \"right\";\n            }\n            top -= lineHeight * this._fontSizeFraction / this.lineHeight;\n            if (shortCut) {\n                // render all the line in one pass without checking\n                // drawingLeft = isLtr ? left : left - this.getLineWidth(lineIndex);\n                this._renderChar(method, ctx, lineIndex, 0, line.join(\"\"), left, top, lineHeight);\n                ctx.restore();\n                return;\n            }\n            for(var i = 0, len = line.length - 1; i <= len; i++){\n                timeToRender = i === len || this.charSpacing || path;\n                charsToRender += line[i];\n                charBox = this.__charBounds[lineIndex][i];\n                if (boxWidth === 0) {\n                    left += sign * (charBox.kernedWidth - charBox.width);\n                    boxWidth += charBox.width;\n                } else {\n                    boxWidth += charBox.kernedWidth;\n                }\n                if (isJustify && !timeToRender) {\n                    if (this._reSpaceAndTab.test(line[i])) {\n                        timeToRender = true;\n                    }\n                }\n                if (!timeToRender) {\n                    // if we have charSpacing, we render char by char\n                    actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);\n                    nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);\n                    timeToRender = fabric.util.hasStyleChanged(actualStyle, nextStyle, false);\n                }\n                if (timeToRender) {\n                    if (path) {\n                        ctx.save();\n                        ctx.translate(charBox.renderLeft, charBox.renderTop);\n                        ctx.rotate(charBox.angle);\n                        this._renderChar(method, ctx, lineIndex, i, charsToRender, -boxWidth / 2, 0, lineHeight);\n                        ctx.restore();\n                    } else {\n                        drawingLeft = left;\n                        this._renderChar(method, ctx, lineIndex, i, charsToRender, drawingLeft, top, lineHeight);\n                    }\n                    charsToRender = \"\";\n                    actualStyle = nextStyle;\n                    left += sign * boxWidth;\n                    boxWidth = 0;\n                }\n            }\n            ctx.restore();\n        },\n        /**\n     * This function try to patch the missing gradientTransform on canvas gradients.\n     * transforming a context to transform the gradient, is going to transform the stroke too.\n     * we want to transform the gradient but not the stroke operation, so we create\n     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.\n     * this method has drawbacks: is slow, is in low resolution, needs a patch for when the size\n     * is limited.\n     * @private\n     * @param {fabric.Gradient} filler a fabric gradient instance\n     * @return {CanvasPattern} a pattern to use as fill/stroke style\n     */ _applyPatternGradientTransformText: function(filler) {\n            var pCanvas = fabric.util.createCanvasElement(), pCtx, // TODO: verify compatibility with strokeUniform\n            width = this.width + this.strokeWidth, height = this.height + this.strokeWidth;\n            pCanvas.width = width;\n            pCanvas.height = height;\n            pCtx = pCanvas.getContext(\"2d\");\n            pCtx.beginPath();\n            pCtx.moveTo(0, 0);\n            pCtx.lineTo(width, 0);\n            pCtx.lineTo(width, height);\n            pCtx.lineTo(0, height);\n            pCtx.closePath();\n            pCtx.translate(width / 2, height / 2);\n            pCtx.fillStyle = filler.toLive(pCtx);\n            this._applyPatternGradientTransform(pCtx, filler);\n            pCtx.fill();\n            return pCtx.createPattern(pCanvas, \"no-repeat\");\n        },\n        handleFiller: function(ctx, property, filler) {\n            var offsetX, offsetY;\n            if (filler.toLive) {\n                if (filler.gradientUnits === \"percentage\" || filler.gradientTransform || filler.patternTransform) {\n                    // need to transform gradient in a pattern.\n                    // this is a slow process. If you are hitting this codepath, and the object\n                    // is not using caching, you should consider switching it on.\n                    // we need a canvas as big as the current object caching canvas.\n                    offsetX = -this.width / 2;\n                    offsetY = -this.height / 2;\n                    ctx.translate(offsetX, offsetY);\n                    ctx[property] = this._applyPatternGradientTransformText(filler);\n                    return {\n                        offsetX: offsetX,\n                        offsetY: offsetY\n                    };\n                } else {\n                    // is a simple gradient or pattern\n                    ctx[property] = filler.toLive(ctx, this);\n                    return this._applyPatternGradientTransform(ctx, filler);\n                }\n            } else {\n                // is a color\n                ctx[property] = filler;\n            }\n            return {\n                offsetX: 0,\n                offsetY: 0\n            };\n        },\n        _setStrokeStyles: function(ctx, decl) {\n            ctx.lineWidth = decl.strokeWidth;\n            ctx.lineCap = this.strokeLineCap;\n            ctx.lineDashOffset = this.strokeDashOffset;\n            ctx.lineJoin = this.strokeLineJoin;\n            ctx.miterLimit = this.strokeMiterLimit;\n            return this.handleFiller(ctx, \"strokeStyle\", decl.stroke);\n        },\n        _setFillStyles: function(ctx, decl) {\n            return this.handleFiller(ctx, \"fillStyle\", decl.fill);\n        },\n        /**\n     * @private\n     * @param {String} method\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {String} _char\n     * @param {Number} left Left coordinate\n     * @param {Number} top Top coordinate\n     * @param {Number} lineHeight Height of the line\n     */ _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {\n            var decl = this._getStyleDeclaration(lineIndex, charIndex), fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex), shouldFill = method === \"fillText\" && fullDecl.fill, shouldStroke = method === \"strokeText\" && fullDecl.stroke && fullDecl.strokeWidth, fillOffsets, strokeOffsets;\n            if (!shouldStroke && !shouldFill) {\n                return;\n            }\n            ctx.save();\n            shouldFill && (fillOffsets = this._setFillStyles(ctx, fullDecl));\n            shouldStroke && (strokeOffsets = this._setStrokeStyles(ctx, fullDecl));\n            ctx.font = this._getFontDeclaration(fullDecl);\n            if (decl && decl.textBackgroundColor) {\n                this._removeShadow(ctx);\n            }\n            if (decl && decl.deltaY) {\n                top += decl.deltaY;\n            }\n            shouldFill && ctx.fillText(_char, left - fillOffsets.offsetX, top - fillOffsets.offsetY);\n            shouldStroke && ctx.strokeText(_char, left - strokeOffsets.offsetX, top - strokeOffsets.offsetY);\n            ctx.restore();\n        },\n        /**\n     * Turns the character into a 'superior figure' (i.e. 'superscript')\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */ setSuperscript: function(start, end) {\n            return this._setScript(start, end, this.superscript);\n        },\n        /**\n     * Turns the character into an 'inferior figure' (i.e. 'subscript')\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */ setSubscript: function(start, end) {\n            return this._setScript(start, end, this.subscript);\n        },\n        /**\n     * Applies 'schema' at given position\n     * @private\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @param {Number} schema\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */ _setScript: function(start, end, schema) {\n            var loc = this.get2DCursorLocation(start, true), fontSize = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, \"fontSize\"), dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, \"deltaY\"), style = {\n                fontSize: fontSize * schema.size,\n                deltaY: dy + fontSize * schema.baseline\n            };\n            this.setSelectionStyles(style, start, end);\n            return this;\n        },\n        /**\n     * @private\n     * @param {Number} lineIndex index text line\n     * @return {Number} Line left offset\n     */ _getLineLeftOffset: function(lineIndex) {\n            var lineWidth = this.getLineWidth(lineIndex), lineDiff = this.width - lineWidth, textAlign = this.textAlign, direction = this.direction, isEndOfWrapping, leftOffset = 0, isEndOfWrapping = this.isEndOfWrapping(lineIndex);\n            if (textAlign === \"justify\" || textAlign === \"justify-center\" && !isEndOfWrapping || textAlign === \"justify-right\" && !isEndOfWrapping || textAlign === \"justify-left\" && !isEndOfWrapping) {\n                return 0;\n            }\n            if (textAlign === \"center\") {\n                leftOffset = lineDiff / 2;\n            }\n            if (textAlign === \"right\") {\n                leftOffset = lineDiff;\n            }\n            if (textAlign === \"justify-center\") {\n                leftOffset = lineDiff / 2;\n            }\n            if (textAlign === \"justify-right\") {\n                leftOffset = lineDiff;\n            }\n            if (direction === \"rtl\") {\n                leftOffset -= lineDiff;\n            }\n            return leftOffset;\n        },\n        /**\n     * @private\n     */ _clearCache: function() {\n            this.__lineWidths = [];\n            this.__lineHeights = [];\n            this.__charBounds = [];\n        },\n        /**\n     * @private\n     */ _shouldClearDimensionCache: function() {\n            var shouldClear = this._forceClearCache;\n            shouldClear || (shouldClear = this.hasStateChanged(\"_dimensionAffectingProps\"));\n            if (shouldClear) {\n                this.dirty = true;\n                this._forceClearCache = false;\n            }\n            return shouldClear;\n        },\n        /**\n     * Measure a single line given its index. Used to calculate the initial\n     * text bounding box. The values are calculated and stored in __lineWidths cache.\n     * @private\n     * @param {Number} lineIndex line number\n     * @return {Number} Line width\n     */ getLineWidth: function(lineIndex) {\n            if (this.__lineWidths[lineIndex] !== undefined) {\n                return this.__lineWidths[lineIndex];\n            }\n            var lineInfo = this.measureLine(lineIndex);\n            var width = lineInfo.width;\n            this.__lineWidths[lineIndex] = width;\n            return width;\n        },\n        _getWidthOfCharSpacing: function() {\n            if (this.charSpacing !== 0) {\n                return this.fontSize * this.charSpacing / 1000;\n            }\n            return 0;\n        },\n        /**\n     * Retrieves the value of property at given character position\n     * @param {Number} lineIndex the line number\n     * @param {Number} charIndex the character number\n     * @param {String} property the property name\n     * @returns the value of 'property'\n     */ getValueOfPropertyAt: function(lineIndex, charIndex, property) {\n            var charStyle = this._getStyleDeclaration(lineIndex, charIndex);\n            if (charStyle && typeof charStyle[property] !== \"undefined\") {\n                return charStyle[property];\n            }\n            return this[property];\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextDecoration: function(ctx, type) {\n            if (!this[type] && !this.styleHas(type)) {\n                return;\n            }\n            var heightOfLine, size, _size, lineLeftOffset, dy, _dy, line, lastDecoration, leftOffset = this._getLeftOffset(), topOffset = this._getTopOffset(), top, boxStart, boxWidth, charBox, currentDecoration, maxHeight, currentFill, lastFill, path = this.path, charSpacing = this._getWidthOfCharSpacing(), offsetY = this.offsets[type];\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                heightOfLine = this.getHeightOfLine(i);\n                if (!this[type] && !this.styleHas(type, i)) {\n                    topOffset += heightOfLine;\n                    continue;\n                }\n                line = this._textLines[i];\n                maxHeight = heightOfLine / this.lineHeight;\n                lineLeftOffset = this._getLineLeftOffset(i);\n                boxStart = 0;\n                boxWidth = 0;\n                lastDecoration = this.getValueOfPropertyAt(i, 0, type);\n                lastFill = this.getValueOfPropertyAt(i, 0, \"fill\");\n                top = topOffset + maxHeight * (1 - this._fontSizeFraction);\n                size = this.getHeightOfChar(i, 0);\n                dy = this.getValueOfPropertyAt(i, 0, \"deltaY\");\n                for(var j = 0, jlen = line.length; j < jlen; j++){\n                    charBox = this.__charBounds[i][j];\n                    currentDecoration = this.getValueOfPropertyAt(i, j, type);\n                    currentFill = this.getValueOfPropertyAt(i, j, \"fill\");\n                    _size = this.getHeightOfChar(i, j);\n                    _dy = this.getValueOfPropertyAt(i, j, \"deltaY\");\n                    if (path && currentDecoration && currentFill) {\n                        ctx.save();\n                        ctx.fillStyle = lastFill;\n                        ctx.translate(charBox.renderLeft, charBox.renderTop);\n                        ctx.rotate(charBox.angle);\n                        ctx.fillRect(-charBox.kernedWidth / 2, offsetY * _size + _dy, charBox.kernedWidth, this.fontSize / 15);\n                        ctx.restore();\n                    } else if ((currentDecoration !== lastDecoration || currentFill !== lastFill || _size !== size || _dy !== dy) && boxWidth > 0) {\n                        var drawStart = leftOffset + lineLeftOffset + boxStart;\n                        if (this.direction === \"rtl\") {\n                            drawStart = this.width - drawStart - boxWidth;\n                        }\n                        if (lastDecoration && lastFill) {\n                            ctx.fillStyle = lastFill;\n                            ctx.fillRect(drawStart, top + offsetY * size + dy, boxWidth, this.fontSize / 15);\n                        }\n                        boxStart = charBox.left;\n                        boxWidth = charBox.width;\n                        lastDecoration = currentDecoration;\n                        lastFill = currentFill;\n                        size = _size;\n                        dy = _dy;\n                    } else {\n                        boxWidth += charBox.kernedWidth;\n                    }\n                }\n                var drawStart = leftOffset + lineLeftOffset + boxStart;\n                if (this.direction === \"rtl\") {\n                    drawStart = this.width - drawStart - boxWidth;\n                }\n                ctx.fillStyle = currentFill;\n                currentDecoration && currentFill && ctx.fillRect(drawStart, top + offsetY * size + dy, boxWidth - charSpacing, this.fontSize / 15);\n                topOffset += heightOfLine;\n            }\n            // if there is text background color no\n            // other shadows should be casted\n            this._removeShadow(ctx);\n        },\n        /**\n     * return font declaration string for canvas context\n     * @param {Object} [styleObject] object\n     * @returns {String} font declaration formatted for canvas context.\n     */ _getFontDeclaration: function(styleObject, forMeasuring) {\n            var style = styleObject || this, family = this.fontFamily, fontIsGeneric = fabric.Text.genericFonts.indexOf(family.toLowerCase()) > -1;\n            var fontFamily = family === undefined || family.indexOf(\"'\") > -1 || family.indexOf(\",\") > -1 || family.indexOf('\"') > -1 || fontIsGeneric ? style.fontFamily : '\"' + style.fontFamily + '\"';\n            return [\n                // node-canvas needs \"weight style\", while browsers need \"style weight\"\n                // verify if this can be fixed in JSDOM\n                fabric.isLikelyNode ? style.fontWeight : style.fontStyle,\n                fabric.isLikelyNode ? style.fontStyle : style.fontWeight,\n                forMeasuring ? this.CACHE_FONT_SIZE + \"px\" : style.fontSize + \"px\",\n                fontFamily\n            ].join(\" \");\n        },\n        /**\n     * Renders text instance on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ render: function(ctx) {\n            // do not render if object is not visible\n            if (!this.visible) {\n                return;\n            }\n            if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {\n                return;\n            }\n            if (this._shouldClearDimensionCache()) {\n                this.initDimensions();\n            }\n            this.callSuper(\"render\", ctx);\n        },\n        /**\n     * Returns the text as an array of lines.\n     * @param {String} text text to split\n     * @returns {Array} Lines in the text\n     */ _splitTextIntoLines: function(text) {\n            var lines = text.split(this._reNewline), newLines = new Array(lines.length), newLine = [\n                \"\\n\"\n            ], newText = [];\n            for(var i = 0; i < lines.length; i++){\n                newLines[i] = fabric.util.string.graphemeSplit(lines[i]);\n                newText = newText.concat(newLines[i], newLine);\n            }\n            newText.pop();\n            return {\n                _unwrappedLines: newLines,\n                lines: lines,\n                graphemeText: newText,\n                graphemeLines: newLines\n            };\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var allProperties = additionalProps.concat(propertiesToInclude);\n            var obj = this.callSuper(\"toObject\", allProperties);\n            obj.styles = fabric.util.stylesToArray(this.styles, this.text);\n            if (obj.path) {\n                obj.path = this.path.toObject();\n            }\n            return obj;\n        },\n        /**\n     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.\n     * @param {String|Object} key Property name or object (if object, iterate over the object properties)\n     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ set: function(key, value) {\n            this.callSuper(\"set\", key, value);\n            var needsDims = false;\n            var isAddingPath = false;\n            if (typeof key === \"object\") {\n                for(var _key in key){\n                    if (_key === \"path\") {\n                        this.setPathInfo();\n                    }\n                    needsDims = needsDims || this._dimensionAffectingProps.indexOf(_key) !== -1;\n                    isAddingPath = isAddingPath || _key === \"path\";\n                }\n            } else {\n                needsDims = this._dimensionAffectingProps.indexOf(key) !== -1;\n                isAddingPath = key === \"path\";\n            }\n            if (isAddingPath) {\n                this.setPathInfo();\n            }\n            if (needsDims) {\n                this.initDimensions();\n                this.setCoords();\n            }\n            return this;\n        },\n        /**\n     * Returns complexity of an instance\n     * @return {Number} complexity\n     */ complexity: function() {\n            return 1;\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})\n   * @static\n   * @memberOf fabric.Text\n   * @see: http://www.w3.org/TR/SVG/text.html#TextElement\n   */ fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor\".split(\" \"));\n    /**\n   * Default SVG font size\n   * @static\n   * @memberOf fabric.Text\n   */ fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;\n    /**\n   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)\n   * @static\n   * @memberOf fabric.Text\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Text.fromElement = function(element, callback, options) {\n        if (!element) {\n            return callback(null);\n        }\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES), parsedAnchor = parsedAttributes.textAnchor || \"left\";\n        options = fabric.util.object.extend(options ? clone(options) : {}, parsedAttributes);\n        options.top = options.top || 0;\n        options.left = options.left || 0;\n        if (parsedAttributes.textDecoration) {\n            var textDecoration = parsedAttributes.textDecoration;\n            if (textDecoration.indexOf(\"underline\") !== -1) {\n                options.underline = true;\n            }\n            if (textDecoration.indexOf(\"overline\") !== -1) {\n                options.overline = true;\n            }\n            if (textDecoration.indexOf(\"line-through\") !== -1) {\n                options.linethrough = true;\n            }\n            delete options.textDecoration;\n        }\n        if (\"dx\" in parsedAttributes) {\n            options.left += parsedAttributes.dx;\n        }\n        if (\"dy\" in parsedAttributes) {\n            options.top += parsedAttributes.dy;\n        }\n        if (!(\"fontSize\" in options)) {\n            options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\n        }\n        var textContent = \"\";\n        // The XML is not properly parsed in IE9 so a workaround to get\n        // textContent is through firstChild.data. Another workaround would be\n        // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)\n        if (!(\"textContent\" in element)) {\n            if (\"firstChild\" in element && element.firstChild !== null) {\n                if (\"data\" in element.firstChild && element.firstChild.data !== null) {\n                    textContent = element.firstChild.data;\n                }\n            }\n        } else {\n            textContent = element.textContent;\n        }\n        textContent = textContent.replace(/^\\s+|\\s+$|\\n+/g, \"\").replace(/\\s+/g, \" \");\n        var originalStrokeWidth = options.strokeWidth;\n        options.strokeWidth = 0;\n        var text = new fabric.Text(textContent, options), textHeightScaleFactor = text.getScaledHeight() / text.height, lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height, scaledDiff = lineHeightDiff * textHeightScaleFactor, textHeight = text.getScaledHeight() + scaledDiff, offX = 0;\n        /*\n      Adjust positioning:\n        x/y attributes in SVG correspond to the bottom-left corner of text bounding box\n        fabric output by default at top, left.\n    */ if (parsedAnchor === \"center\") {\n            offX = text.getScaledWidth() / 2;\n        }\n        if (parsedAnchor === \"right\") {\n            offX = text.getScaledWidth();\n        }\n        text.set({\n            left: text.left - offX,\n            top: text.top - (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) / text.lineHeight,\n            strokeWidth: typeof originalStrokeWidth !== \"undefined\" ? originalStrokeWidth : 1\n        });\n        callback(text);\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Text instance from an object representation\n   * @static\n   * @memberOf fabric.Text\n   * @param {Object} object plain js Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created\n   */ fabric.Text.fromObject = function(object, callback) {\n        var objectCopy = clone(object), path = object.path;\n        delete objectCopy.path;\n        return fabric.Object._fromObject(\"Text\", objectCopy, function(textInstance) {\n            textInstance.styles = fabric.util.stylesFromArray(object.styles, object.text);\n            if (path) {\n                fabric.Object._fromObject(\"Path\", path, function(pathInstance) {\n                    textInstance.set(\"path\", pathInstance);\n                    callback(textInstance);\n                }, \"path\");\n            } else {\n                callback(textInstance);\n            }\n        }, \"text\");\n    };\n    fabric.Text.genericFonts = [\n        \"sans-serif\",\n        \"serif\",\n        \"cursive\",\n        \"fantasy\",\n        \"monospace\"\n    ];\n    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Text);\n})( true ? exports : 0);\n(function() {\n    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {\n        /**\n     * Returns true if object has no styling or no styling in a line\n     * @param {Number} lineIndex , lineIndex is on wrapped lines.\n     * @return {Boolean}\n     */ isEmptyStyles: function(lineIndex) {\n            if (!this.styles) {\n                return true;\n            }\n            if (typeof lineIndex !== \"undefined\" && !this.styles[lineIndex]) {\n                return true;\n            }\n            var obj = typeof lineIndex === \"undefined\" ? this.styles : {\n                line: this.styles[lineIndex]\n            };\n            for(var p1 in obj){\n                for(var p2 in obj[p1]){\n                    // eslint-disable-next-line no-unused-vars\n                    for(var p3 in obj[p1][p2]){\n                        return false;\n                    }\n                }\n            }\n            return true;\n        },\n        /**\n     * Returns true if object has a style property or has it ina specified line\n     * This function is used to detect if a text will use a particular property or not.\n     * @param {String} property to check for\n     * @param {Number} lineIndex to check the style on\n     * @return {Boolean}\n     */ styleHas: function(property, lineIndex) {\n            if (!this.styles || !property || property === \"\") {\n                return false;\n            }\n            if (typeof lineIndex !== \"undefined\" && !this.styles[lineIndex]) {\n                return false;\n            }\n            var obj = typeof lineIndex === \"undefined\" ? this.styles : {\n                0: this.styles[lineIndex]\n            };\n            // eslint-disable-next-line\n            for(var p1 in obj){\n                // eslint-disable-next-line\n                for(var p2 in obj[p1]){\n                    if (typeof obj[p1][p2][property] !== \"undefined\") {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        /**\n     * Check if characters in a text have a value for a property\n     * whose value matches the textbox's value for that property.  If so,\n     * the character-level property is deleted.  If the character\n     * has no other properties, then it is also deleted.  Finally,\n     * if the line containing that character has no other characters\n     * then it also is deleted.\n     *\n     * @param {string} property The property to compare between characters and text.\n     */ cleanStyle: function(property) {\n            if (!this.styles || !property || property === \"\") {\n                return false;\n            }\n            var obj = this.styles, stylesCount = 0, letterCount, stylePropertyValue, allStyleObjectPropertiesMatch = true, graphemeCount = 0, styleObject;\n            // eslint-disable-next-line\n            for(var p1 in obj){\n                letterCount = 0;\n                // eslint-disable-next-line\n                for(var p2 in obj[p1]){\n                    var styleObject = obj[p1][p2], stylePropertyHasBeenSet = styleObject.hasOwnProperty(property);\n                    stylesCount++;\n                    if (stylePropertyHasBeenSet) {\n                        if (!stylePropertyValue) {\n                            stylePropertyValue = styleObject[property];\n                        } else if (styleObject[property] !== stylePropertyValue) {\n                            allStyleObjectPropertiesMatch = false;\n                        }\n                        if (styleObject[property] === this[property]) {\n                            delete styleObject[property];\n                        }\n                    } else {\n                        allStyleObjectPropertiesMatch = false;\n                    }\n                    if (Object.keys(styleObject).length !== 0) {\n                        letterCount++;\n                    } else {\n                        delete obj[p1][p2];\n                    }\n                }\n                if (letterCount === 0) {\n                    delete obj[p1];\n                }\n            }\n            // if every grapheme has the same style set then\n            // delete those styles and set it on the parent\n            for(var i = 0; i < this._textLines.length; i++){\n                graphemeCount += this._textLines[i].length;\n            }\n            if (allStyleObjectPropertiesMatch && stylesCount === graphemeCount) {\n                this[property] = stylePropertyValue;\n                this.removeStyle(property);\n            }\n        },\n        /**\n     * Remove a style property or properties from all individual character styles\n     * in a text object.  Deletes the character style object if it contains no other style\n     * props.  Deletes a line style object if it contains no other character styles.\n     *\n     * @param {String} props The property to remove from character styles.\n     */ removeStyle: function(property) {\n            if (!this.styles || !property || property === \"\") {\n                return;\n            }\n            var obj = this.styles, line, lineNum, charNum;\n            for(lineNum in obj){\n                line = obj[lineNum];\n                for(charNum in line){\n                    delete line[charNum][property];\n                    if (Object.keys(line[charNum]).length === 0) {\n                        delete line[charNum];\n                    }\n                }\n                if (Object.keys(line).length === 0) {\n                    delete obj[lineNum];\n                }\n            }\n        },\n        /**\n     * @private\n     */ _extendStyles: function(index, styles) {\n            var loc = this.get2DCursorLocation(index);\n            if (!this._getLineStyle(loc.lineIndex)) {\n                this._setLineStyle(loc.lineIndex);\n            }\n            if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {\n                this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});\n            }\n            fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);\n        },\n        /**\n     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)\n     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.\n     * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. useful to manage styles.\n     */ get2DCursorLocation: function(selectionStart, skipWrapping) {\n            if (typeof selectionStart === \"undefined\") {\n                selectionStart = this.selectionStart;\n            }\n            var lines = skipWrapping ? this._unwrappedTextLines : this._textLines, len = lines.length;\n            for(var i = 0; i < len; i++){\n                if (selectionStart <= lines[i].length) {\n                    return {\n                        lineIndex: i,\n                        charIndex: selectionStart\n                    };\n                }\n                selectionStart -= lines[i].length + this.missingNewlineOffset(i);\n            }\n            return {\n                lineIndex: i - 1,\n                charIndex: lines[i - 1].length < selectionStart ? lines[i - 1].length : selectionStart\n            };\n        },\n        /**\n     * Gets style of a current selection/cursor (at the start position)\n     * if startIndex or endIndex are not provided, selectionStart or selectionEnd will be used.\n     * @param {Number} [startIndex] Start index to get styles at\n     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1\n     * @param {Boolean} [complete] get full style or not\n     * @return {Array} styles an array with one, zero or more Style objects\n     */ getSelectionStyles: function(startIndex, endIndex, complete) {\n            if (typeof startIndex === \"undefined\") {\n                startIndex = this.selectionStart || 0;\n            }\n            if (typeof endIndex === \"undefined\") {\n                endIndex = this.selectionEnd || startIndex;\n            }\n            var styles = [];\n            for(var i = startIndex; i < endIndex; i++){\n                styles.push(this.getStyleAtPosition(i, complete));\n            }\n            return styles;\n        },\n        /**\n     * Gets style of a current selection/cursor position\n     * @param {Number} position  to get styles at\n     * @param {Boolean} [complete] full style if true\n     * @return {Object} style Style object at a specified index\n     * @private\n     */ getStyleAtPosition: function(position, complete) {\n            var loc = this.get2DCursorLocation(position), style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) : this._getStyleDeclaration(loc.lineIndex, loc.charIndex);\n            return style || {};\n        },\n        /**\n     * Sets style of a current selection, if no selection exist, do not set anything.\n     * @param {Object} [styles] Styles object\n     * @param {Number} [startIndex] Start index to get styles at\n     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ setSelectionStyles: function(styles, startIndex, endIndex) {\n            if (typeof startIndex === \"undefined\") {\n                startIndex = this.selectionStart || 0;\n            }\n            if (typeof endIndex === \"undefined\") {\n                endIndex = this.selectionEnd || startIndex;\n            }\n            for(var i = startIndex; i < endIndex; i++){\n                this._extendStyles(i, styles);\n            }\n            /* not included in _extendStyles to avoid clearing cache more than once */ this._forceClearCache = true;\n            return this;\n        },\n        /**\n     * get the reference, not a clone, of the style object for a given character\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @return {Object} style object\n     */ _getStyleDeclaration: function(lineIndex, charIndex) {\n            var lineStyle = this.styles && this.styles[lineIndex];\n            if (!lineStyle) {\n                return null;\n            }\n            return lineStyle[charIndex];\n        },\n        /**\n     * return a new object that contains all the style property for a character\n     * the object returned is newly created\n     * @param {Number} lineIndex of the line where the character is\n     * @param {Number} charIndex position of the character on the line\n     * @return {Object} style object\n     */ getCompleteStyleDeclaration: function(lineIndex, charIndex) {\n            var style = this._getStyleDeclaration(lineIndex, charIndex) || {}, styleObject = {}, prop;\n            for(var i = 0; i < this._styleProperties.length; i++){\n                prop = this._styleProperties[i];\n                styleObject[prop] = typeof style[prop] === \"undefined\" ? this[prop] : style[prop];\n            }\n            return styleObject;\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {Object} style\n     * @private\n     */ _setStyleDeclaration: function(lineIndex, charIndex, style) {\n            this.styles[lineIndex][charIndex] = style;\n        },\n        /**\n     *\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */ _deleteStyleDeclaration: function(lineIndex, charIndex) {\n            delete this.styles[lineIndex][charIndex];\n        },\n        /**\n     * @param {Number} lineIndex\n     * @return {Boolean} if the line exists or not\n     * @private\n     */ _getLineStyle: function(lineIndex) {\n            return !!this.styles[lineIndex];\n        },\n        /**\n     * Set the line style to an empty object so that is initialized\n     * @param {Number} lineIndex\n     * @private\n     */ _setLineStyle: function(lineIndex) {\n            this.styles[lineIndex] = {};\n        },\n        /**\n     * @param {Number} lineIndex\n     * @private\n     */ _deleteLineStyle: function(lineIndex) {\n            delete this.styles[lineIndex];\n        }\n    });\n})();\n(function() {\n    function parseDecoration(object) {\n        if (object.textDecoration) {\n            object.textDecoration.indexOf(\"underline\") > -1 && (object.underline = true);\n            object.textDecoration.indexOf(\"line-through\") > -1 && (object.linethrough = true);\n            object.textDecoration.indexOf(\"overline\") > -1 && (object.overline = true);\n            delete object.textDecoration;\n        }\n    }\n    /**\n   * IText class (introduced in <b>v1.4</b>) Events are also fired with \"text:\"\n   * prefix when observing canvas.\n   * @class fabric.IText\n   * @extends fabric.Text\n   * @mixes fabric.Observable\n   *\n   * @fires changed\n   * @fires selection:changed\n   * @fires editing:entered\n   * @fires editing:exited\n   *\n   * @return {fabric.IText} thisArg\n   * @see {@link fabric.IText#initialize} for constructor definition\n   *\n   * <p>Supported key combinations:</p>\n   * <pre>\n   *   Move cursor:                    left, right, up, down\n   *   Select character:               shift + left, shift + right\n   *   Select text vertically:         shift + up, shift + down\n   *   Move cursor by word:            alt + left, alt + right\n   *   Select words:                   shift + alt + left, shift + alt + right\n   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end\n   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end\n   *   Jump to start/end of text:      cmd + up, cmd + down\n   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown\n   *   Delete character:               backspace\n   *   Delete word:                    alt + backspace\n   *   Delete line:                    cmd + backspace\n   *   Forward delete:                 delete\n   *   Copy text:                      ctrl/cmd + c\n   *   Paste text:                     ctrl/cmd + v\n   *   Cut text:                       ctrl/cmd + x\n   *   Select entire text:             ctrl/cmd + a\n   *   Quit editing                    tab or esc\n   * </pre>\n   *\n   * <p>Supported mouse/touch combination</p>\n   * <pre>\n   *   Position cursor:                click/touch\n   *   Create selection:               click/touch & drag\n   *   Create selection:               click & shift + click\n   *   Select word:                    double click\n   *   Select line:                    triple click\n   * </pre>\n   */ fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"i-text\",\n        /**\n     * Index where text selection starts (or where cursor is when there is no selection)\n     * @type Number\n     * @default\n     */ selectionStart: 0,\n        /**\n     * Index where text selection ends\n     * @type Number\n     * @default\n     */ selectionEnd: 0,\n        /**\n     * Color of text selection\n     * @type String\n     * @default\n     */ selectionColor: \"rgba(17,119,255,0.3)\",\n        /**\n     * Indicates whether text is in editing mode\n     * @type Boolean\n     * @default\n     */ isEditing: false,\n        /**\n     * Indicates whether a text can be edited\n     * @type Boolean\n     * @default\n     */ editable: true,\n        /**\n     * Border color of text object while it's in editing mode\n     * @type String\n     * @default\n     */ editingBorderColor: \"rgba(102,153,255,0.25)\",\n        /**\n     * Width of cursor (in px)\n     * @type Number\n     * @default\n     */ cursorWidth: 2,\n        /**\n     * Color of text cursor color in editing mode.\n     * if not set (default) will take color from the text.\n     * if set to a color value that fabric can understand, it will\n     * be used instead of the color of the text at the current position.\n     * @type String\n     * @default\n     */ cursorColor: \"\",\n        /**\n     * Delay between cursor blink (in ms)\n     * @type Number\n     * @default\n     */ cursorDelay: 1000,\n        /**\n     * Duration of cursor fadein (in ms)\n     * @type Number\n     * @default\n     */ cursorDuration: 600,\n        /**\n     * Indicates whether internal text char widths can be cached\n     * @type Boolean\n     * @default\n     */ caching: true,\n        /**\n     * DOM container to append the hiddenTextarea.\n     * An alternative to attaching to the document.body.\n     * Useful to reduce laggish redraw of the full document.body tree and\n     * also with modals event capturing that won't let the textarea take focus.\n     * @type HTMLElement\n     * @default\n     */ hiddenTextareaContainer: null,\n        /**\n     * @private\n     */ _reSpace: /\\s|\\n/,\n        /**\n     * @private\n     */ _currentCursorOpacity: 0,\n        /**\n     * @private\n     */ _selectionDirection: null,\n        /**\n     * @private\n     */ _abortCursorAnimation: false,\n        /**\n     * @private\n     */ __widthOfSpace: [],\n        /**\n     * Helps determining when the text is in composition, so that the cursor\n     * rendering is altered.\n     */ inCompositionMode: false,\n        /**\n     * Constructor\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.IText} thisArg\n     */ initialize: function(text, options) {\n            this.callSuper(\"initialize\", text, options);\n            this.initBehavior();\n        },\n        /**\n     * Sets selection start (left boundary of a selection)\n     * @param {Number} index Index to set selection start to\n     */ setSelectionStart: function(index) {\n            index = Math.max(index, 0);\n            this._updateAndFire(\"selectionStart\", index);\n        },\n        /**\n     * Sets selection end (right boundary of a selection)\n     * @param {Number} index Index to set selection end to\n     */ setSelectionEnd: function(index) {\n            index = Math.min(index, this.text.length);\n            this._updateAndFire(\"selectionEnd\", index);\n        },\n        /**\n     * @private\n     * @param {String} property 'selectionStart' or 'selectionEnd'\n     * @param {Number} index new position of property\n     */ _updateAndFire: function(property, index) {\n            if (this[property] !== index) {\n                this._fireSelectionChanged();\n                this[property] = index;\n            }\n            this._updateTextarea();\n        },\n        /**\n     * Fires the even of selection changed\n     * @private\n     */ _fireSelectionChanged: function() {\n            this.fire(\"selection:changed\");\n            this.canvas && this.canvas.fire(\"text:selection:changed\", {\n                target: this\n            });\n        },\n        /**\n     * Initialize text dimensions. Render all text on given context\n     * or on a offscreen canvas to get the text width with measureText.\n     * Updates this.width and this.height with the proper values.\n     * Does not return dimensions.\n     * @private\n     */ initDimensions: function() {\n            this.isEditing && this.initDelayedCursor();\n            this.clearContextTop();\n            this.callSuper(\"initDimensions\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ render: function(ctx) {\n            this.clearContextTop();\n            this.callSuper(\"render\", ctx);\n            // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor\n            // the correct position but not at every cursor animation.\n            this.cursorOffsetCache = {};\n            this.renderCursorOrSelection();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            this.callSuper(\"_render\", ctx);\n        },\n        /**\n     * Prepare and clean the contextTop\n     */ clearContextTop: function(skipRestore) {\n            if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {\n                return;\n            }\n            var ctx = this.canvas.contextTop, v = this.canvas.viewportTransform;\n            ctx.save();\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            this.transform(ctx);\n            this._clearTextArea(ctx);\n            skipRestore || ctx.restore();\n        },\n        /**\n     * Renders cursor or selection (depending on what exists)\n     * it does on the contextTop. If contextTop is not available, do nothing.\n     */ renderCursorOrSelection: function() {\n            if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {\n                return;\n            }\n            var boundaries = this._getCursorBoundaries(), ctx = this.canvas.contextTop;\n            this.clearContextTop(true);\n            if (this.selectionStart === this.selectionEnd) {\n                this.renderCursor(boundaries, ctx);\n            } else {\n                this.renderSelection(boundaries, ctx);\n            }\n            ctx.restore();\n        },\n        _clearTextArea: function(ctx) {\n            // we add 4 pixel, to be sure to do not leave any pixel out\n            var width = this.width + 4, height = this.height + 4;\n            ctx.clearRect(-width / 2, -height / 2, width, height);\n        },\n        /**\n     * Returns cursor boundaries (left, top, leftOffset, topOffset)\n     * @private\n     * @param {Array} chars Array of characters\n     * @param {String} typeOfBoundaries\n     */ _getCursorBoundaries: function(position) {\n            // left/top are left/top of entire text box\n            // leftOffset/topOffset are offset from that left/top point of a text box\n            if (typeof position === \"undefined\") {\n                position = this.selectionStart;\n            }\n            var left = this._getLeftOffset(), top = this._getTopOffset(), offsets = this._getCursorBoundariesOffsets(position);\n            return {\n                left: left,\n                top: top,\n                leftOffset: offsets.left,\n                topOffset: offsets.top\n            };\n        },\n        /**\n     * @private\n     */ _getCursorBoundariesOffsets: function(position) {\n            if (this.cursorOffsetCache && \"top\" in this.cursorOffsetCache) {\n                return this.cursorOffsetCache;\n            }\n            var lineLeftOffset, lineIndex, charIndex, topOffset = 0, leftOffset = 0, boundaries, cursorPosition = this.get2DCursorLocation(position);\n            charIndex = cursorPosition.charIndex;\n            lineIndex = cursorPosition.lineIndex;\n            for(var i = 0; i < lineIndex; i++){\n                topOffset += this.getHeightOfLine(i);\n            }\n            lineLeftOffset = this._getLineLeftOffset(lineIndex);\n            var bound = this.__charBounds[lineIndex][charIndex];\n            bound && (leftOffset = bound.left);\n            if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {\n                leftOffset -= this._getWidthOfCharSpacing();\n            }\n            boundaries = {\n                top: topOffset,\n                left: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0)\n            };\n            if (this.direction === \"rtl\") {\n                boundaries.left *= -1;\n            }\n            this.cursorOffsetCache = boundaries;\n            return this.cursorOffsetCache;\n        },\n        /**\n     * Renders cursor\n     * @param {Object} boundaries\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\n     */ renderCursor: function(boundaries, ctx) {\n            var cursorLocation = this.get2DCursorLocation(), lineIndex = cursorLocation.lineIndex, charIndex = cursorLocation.charIndex > 0 ? cursorLocation.charIndex - 1 : 0, charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, \"fontSize\"), multiplier = this.scaleX * this.canvas.getZoom(), cursorWidth = this.cursorWidth / multiplier, topOffset = boundaries.topOffset, dy = this.getValueOfPropertyAt(lineIndex, charIndex, \"deltaY\");\n            topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight - charHeight * (1 - this._fontSizeFraction);\n            if (this.inCompositionMode) {\n                this.renderSelection(boundaries, ctx);\n            }\n            ctx.fillStyle = this.cursorColor || this.getValueOfPropertyAt(lineIndex, charIndex, \"fill\");\n            ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;\n            ctx.fillRect(boundaries.left + boundaries.leftOffset - cursorWidth / 2, topOffset + boundaries.top + dy, cursorWidth, charHeight);\n        },\n        /**\n     * Renders text selection\n     * @param {Object} boundaries Object with left/top/leftOffset/topOffset\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\n     */ renderSelection: function(boundaries, ctx) {\n            var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, isJustify = this.textAlign.indexOf(\"justify\") !== -1, start = this.get2DCursorLocation(selectionStart), end = this.get2DCursorLocation(selectionEnd), startLine = start.lineIndex, endLine = end.lineIndex, startChar = start.charIndex < 0 ? 0 : start.charIndex, endChar = end.charIndex < 0 ? 0 : end.charIndex;\n            for(var i = startLine; i <= endLine; i++){\n                var lineOffset = this._getLineLeftOffset(i) || 0, lineHeight = this.getHeightOfLine(i), realLineHeight = 0, boxStart = 0, boxEnd = 0;\n                if (i === startLine) {\n                    boxStart = this.__charBounds[startLine][startChar].left;\n                }\n                if (i >= startLine && i < endLine) {\n                    boxEnd = isJustify && !this.isEndOfWrapping(i) ? this.width : this.getLineWidth(i) || 5; // WTF is this 5?\n                } else if (i === endLine) {\n                    if (endChar === 0) {\n                        boxEnd = this.__charBounds[endLine][endChar].left;\n                    } else {\n                        var charSpacing = this._getWidthOfCharSpacing();\n                        boxEnd = this.__charBounds[endLine][endChar - 1].left + this.__charBounds[endLine][endChar - 1].width - charSpacing;\n                    }\n                }\n                realLineHeight = lineHeight;\n                if (this.lineHeight < 1 || i === endLine && this.lineHeight > 1) {\n                    lineHeight /= this.lineHeight;\n                }\n                var drawStart = boundaries.left + lineOffset + boxStart, drawWidth = boxEnd - boxStart, drawHeight = lineHeight, extraTop = 0;\n                if (this.inCompositionMode) {\n                    ctx.fillStyle = this.compositionColor || \"black\";\n                    drawHeight = 1;\n                    extraTop = lineHeight;\n                } else {\n                    ctx.fillStyle = this.selectionColor;\n                }\n                if (this.direction === \"rtl\") {\n                    drawStart = this.width - drawStart - drawWidth;\n                }\n                ctx.fillRect(drawStart, boundaries.top + boundaries.topOffset + extraTop, drawWidth, drawHeight);\n                boundaries.topOffset += realLineHeight;\n            }\n        },\n        /**\n     * High level function to know the height of the cursor.\n     * the currentChar is the one that precedes the cursor\n     * Returns fontSize of char at the current cursor\n     * Unused from the library, is for the end user\n     * @return {Number} Character font size\n     */ getCurrentCharFontSize: function() {\n            var cp = this._getCurrentCharIndex();\n            return this.getValueOfPropertyAt(cp.l, cp.c, \"fontSize\");\n        },\n        /**\n     * High level function to know the color of the cursor.\n     * the currentChar is the one that precedes the cursor\n     * Returns color (fill) of char at the current cursor\n     * if the text object has a pattern or gradient for filler, it will return that.\n     * Unused by the library, is for the end user\n     * @return {String | fabric.Gradient | fabric.Pattern} Character color (fill)\n     */ getCurrentCharColor: function() {\n            var cp = this._getCurrentCharIndex();\n            return this.getValueOfPropertyAt(cp.l, cp.c, \"fill\");\n        },\n        /**\n     * Returns the cursor position for the getCurrent.. functions\n     * @private\n     */ _getCurrentCharIndex: function() {\n            var cursorPosition = this.get2DCursorLocation(this.selectionStart, true), charIndex = cursorPosition.charIndex > 0 ? cursorPosition.charIndex - 1 : 0;\n            return {\n                l: cursorPosition.lineIndex,\n                c: charIndex\n            };\n        }\n    });\n    /**\n   * Returns fabric.IText instance from an object representation\n   * @static\n   * @memberOf fabric.IText\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as argument\n   */ fabric.IText.fromObject = function(object, callback) {\n        var styles = fabric.util.stylesFromArray(object.styles, object.text);\n        //copy object to prevent mutation\n        var objCopy = Object.assign({}, object, {\n            styles: styles\n        });\n        parseDecoration(objCopy);\n        if (objCopy.styles) {\n            for(var i in objCopy.styles){\n                for(var j in objCopy.styles[i]){\n                    parseDecoration(objCopy.styles[i][j]);\n                }\n            }\n        }\n        fabric.Object._fromObject(\"IText\", objCopy, callback, \"text\");\n    };\n})();\n(function() {\n    var clone = fabric.util.object.clone;\n    fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\n        /**\n     * Initializes all the interactive behavior of IText\n     */ initBehavior: function() {\n            this.initAddedHandler();\n            this.initRemovedHandler();\n            this.initCursorSelectionHandlers();\n            this.initDoubleClickSimulation();\n            this.mouseMoveHandler = this.mouseMoveHandler.bind(this);\n        },\n        onDeselect: function() {\n            this.isEditing && this.exitEditing();\n            this.selected = false;\n        },\n        /**\n     * Initializes \"added\" event handler\n     */ initAddedHandler: function() {\n            var _this = this;\n            this.on(\"added\", function() {\n                var canvas = _this.canvas;\n                if (canvas) {\n                    if (!canvas._hasITextHandlers) {\n                        canvas._hasITextHandlers = true;\n                        _this._initCanvasHandlers(canvas);\n                    }\n                    canvas._iTextInstances = canvas._iTextInstances || [];\n                    canvas._iTextInstances.push(_this);\n                }\n            });\n        },\n        initRemovedHandler: function() {\n            var _this = this;\n            this.on(\"removed\", function() {\n                var canvas = _this.canvas;\n                if (canvas) {\n                    canvas._iTextInstances = canvas._iTextInstances || [];\n                    fabric.util.removeFromArray(canvas._iTextInstances, _this);\n                    if (canvas._iTextInstances.length === 0) {\n                        canvas._hasITextHandlers = false;\n                        _this._removeCanvasHandlers(canvas);\n                    }\n                }\n            });\n        },\n        /**\n     * register canvas event to manage exiting on other instances\n     * @private\n     */ _initCanvasHandlers: function(canvas) {\n            canvas._mouseUpITextHandler = function() {\n                if (canvas._iTextInstances) {\n                    canvas._iTextInstances.forEach(function(obj) {\n                        obj.__isMousedown = false;\n                    });\n                }\n            };\n            canvas.on(\"mouse:up\", canvas._mouseUpITextHandler);\n        },\n        /**\n     * remove canvas event to manage exiting on other instances\n     * @private\n     */ _removeCanvasHandlers: function(canvas) {\n            canvas.off(\"mouse:up\", canvas._mouseUpITextHandler);\n        },\n        /**\n     * @private\n     */ _tick: function() {\n            this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, \"_onTickComplete\");\n        },\n        /**\n     * @private\n     */ _animateCursor: function(obj, targetOpacity, duration, completeMethod) {\n            var tickState;\n            tickState = {\n                isAborted: false,\n                abort: function() {\n                    this.isAborted = true;\n                }\n            };\n            obj.animate(\"_currentCursorOpacity\", targetOpacity, {\n                duration: duration,\n                onComplete: function() {\n                    if (!tickState.isAborted) {\n                        obj[completeMethod]();\n                    }\n                },\n                onChange: function() {\n                    // we do not want to animate a selection, only cursor\n                    if (obj.canvas && obj.selectionStart === obj.selectionEnd) {\n                        obj.renderCursorOrSelection();\n                    }\n                },\n                abort: function() {\n                    return tickState.isAborted;\n                }\n            });\n            return tickState;\n        },\n        /**\n     * @private\n     */ _onTickComplete: function() {\n            var _this = this;\n            if (this._cursorTimeout1) {\n                clearTimeout(this._cursorTimeout1);\n            }\n            this._cursorTimeout1 = setTimeout(function() {\n                _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, \"_tick\");\n            }, 100);\n        },\n        /**\n     * Initializes delayed cursor\n     */ initDelayedCursor: function(restart) {\n            var _this = this, delay = restart ? 0 : this.cursorDelay;\n            this.abortCursorAnimation();\n            this._currentCursorOpacity = 1;\n            this._cursorTimeout2 = setTimeout(function() {\n                _this._tick();\n            }, delay);\n        },\n        /**\n     * Aborts cursor animation and clears all timeouts\n     */ abortCursorAnimation: function() {\n            var shouldClear = this._currentTickState || this._currentTickCompleteState, canvas = this.canvas;\n            this._currentTickState && this._currentTickState.abort();\n            this._currentTickCompleteState && this._currentTickCompleteState.abort();\n            clearTimeout(this._cursorTimeout1);\n            clearTimeout(this._cursorTimeout2);\n            this._currentCursorOpacity = 0;\n            // to clear just itext area we need to transform the context\n            // it may not be worth it\n            if (shouldClear && canvas) {\n                canvas.clearContext(canvas.contextTop || canvas.contextContainer);\n            }\n        },\n        /**\n     * Selects entire text\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ selectAll: function() {\n            this.selectionStart = 0;\n            this.selectionEnd = this._text.length;\n            this._fireSelectionChanged();\n            this._updateTextarea();\n            return this;\n        },\n        /**\n     * Returns selected text\n     * @return {String}\n     */ getSelectedText: function() {\n            return this._text.slice(this.selectionStart, this.selectionEnd).join(\"\");\n        },\n        /**\n     * Find new selection index representing start of current word according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findWordBoundaryLeft: function(startFrom) {\n            var offset = 0, index = startFrom - 1;\n            // remove space before cursor first\n            if (this._reSpace.test(this._text[index])) {\n                while(this._reSpace.test(this._text[index])){\n                    offset++;\n                    index--;\n                }\n            }\n            while(/\\S/.test(this._text[index]) && index > -1){\n                offset++;\n                index--;\n            }\n            return startFrom - offset;\n        },\n        /**\n     * Find new selection index representing end of current word according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findWordBoundaryRight: function(startFrom) {\n            var offset = 0, index = startFrom;\n            // remove space after cursor first\n            if (this._reSpace.test(this._text[index])) {\n                while(this._reSpace.test(this._text[index])){\n                    offset++;\n                    index++;\n                }\n            }\n            while(/\\S/.test(this._text[index]) && index < this._text.length){\n                offset++;\n                index++;\n            }\n            return startFrom + offset;\n        },\n        /**\n     * Find new selection index representing start of current line according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findLineBoundaryLeft: function(startFrom) {\n            var offset = 0, index = startFrom - 1;\n            while(!/\\n/.test(this._text[index]) && index > -1){\n                offset++;\n                index--;\n            }\n            return startFrom - offset;\n        },\n        /**\n     * Find new selection index representing end of current line according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findLineBoundaryRight: function(startFrom) {\n            var offset = 0, index = startFrom;\n            while(!/\\n/.test(this._text[index]) && index < this._text.length){\n                offset++;\n                index++;\n            }\n            return startFrom + offset;\n        },\n        /**\n     * Finds index corresponding to beginning or end of a word\n     * @param {Number} selectionStart Index of a character\n     * @param {Number} direction 1 or -1\n     * @return {Number} Index of the beginning or end of a word\n     */ searchWordBoundary: function(selectionStart, direction) {\n            var text = this._text, index = this._reSpace.test(text[selectionStart]) ? selectionStart - 1 : selectionStart, _char = text[index], // wrong\n            reNonWord = fabric.reNonWord;\n            while(!reNonWord.test(_char) && index > 0 && index < text.length){\n                index += direction;\n                _char = text[index];\n            }\n            if (reNonWord.test(_char)) {\n                index += direction === 1 ? 0 : 1;\n            }\n            return index;\n        },\n        /**\n     * Selects a word based on the index\n     * @param {Number} selectionStart Index of a character\n     */ selectWord: function(selectionStart) {\n            selectionStart = selectionStart || this.selectionStart;\n            var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */ newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */ \n            this.selectionStart = newSelectionStart;\n            this.selectionEnd = newSelectionEnd;\n            this._fireSelectionChanged();\n            this._updateTextarea();\n            this.renderCursorOrSelection();\n        },\n        /**\n     * Selects a line based on the index\n     * @param {Number} selectionStart Index of a character\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ selectLine: function(selectionStart) {\n            selectionStart = selectionStart || this.selectionStart;\n            var newSelectionStart = this.findLineBoundaryLeft(selectionStart), newSelectionEnd = this.findLineBoundaryRight(selectionStart);\n            this.selectionStart = newSelectionStart;\n            this.selectionEnd = newSelectionEnd;\n            this._fireSelectionChanged();\n            this._updateTextarea();\n            return this;\n        },\n        /**\n     * Enters editing state\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ enterEditing: function(e) {\n            if (this.isEditing || !this.editable) {\n                return;\n            }\n            if (this.canvas) {\n                this.canvas.calcOffset();\n                this.exitEditingOnOthers(this.canvas);\n            }\n            this.isEditing = true;\n            this.initHiddenTextarea(e);\n            this.hiddenTextarea.focus();\n            this.hiddenTextarea.value = this.text;\n            this._updateTextarea();\n            this._saveEditingProps();\n            this._setEditingProps();\n            this._textBeforeEdit = this.text;\n            this._tick();\n            this.fire(\"editing:entered\");\n            this._fireSelectionChanged();\n            if (!this.canvas) {\n                return this;\n            }\n            this.canvas.fire(\"text:editing:entered\", {\n                target: this\n            });\n            this.initMouseMoveHandler();\n            this.canvas.requestRenderAll();\n            return this;\n        },\n        exitEditingOnOthers: function(canvas) {\n            if (canvas._iTextInstances) {\n                canvas._iTextInstances.forEach(function(obj) {\n                    obj.selected = false;\n                    if (obj.isEditing) {\n                        obj.exitEditing();\n                    }\n                });\n            }\n        },\n        /**\n     * Initializes \"mousemove\" event handler\n     */ initMouseMoveHandler: function() {\n            this.canvas.on(\"mouse:move\", this.mouseMoveHandler);\n        },\n        /**\n     * @private\n     */ mouseMoveHandler: function(options) {\n            if (!this.__isMousedown || !this.isEditing) {\n                return;\n            }\n            // regain focus\n            document.activeElement !== this.hiddenTextarea && this.hiddenTextarea.focus();\n            var newSelectionStart = this.getSelectionStartFromPointer(options.e), currentStart = this.selectionStart, currentEnd = this.selectionEnd;\n            if ((newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd) && (currentStart === newSelectionStart || currentEnd === newSelectionStart)) {\n                return;\n            }\n            if (newSelectionStart > this.__selectionStartOnMouseDown) {\n                this.selectionStart = this.__selectionStartOnMouseDown;\n                this.selectionEnd = newSelectionStart;\n            } else {\n                this.selectionStart = newSelectionStart;\n                this.selectionEnd = this.__selectionStartOnMouseDown;\n            }\n            if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {\n                this.restartCursorIfNeeded();\n                this._fireSelectionChanged();\n                this._updateTextarea();\n                this.renderCursorOrSelection();\n            }\n        },\n        /**\n     * @private\n     */ _setEditingProps: function() {\n            this.hoverCursor = \"text\";\n            if (this.canvas) {\n                this.canvas.defaultCursor = this.canvas.moveCursor = \"text\";\n            }\n            this.borderColor = this.editingBorderColor;\n            this.hasControls = this.selectable = false;\n            this.lockMovementX = this.lockMovementY = true;\n        },\n        /**\n     * convert from textarea to grapheme indexes\n     */ fromStringToGraphemeSelection: function(start, end, text) {\n            var smallerTextStart = text.slice(0, start), graphemeStart = fabric.util.string.graphemeSplit(smallerTextStart).length;\n            if (start === end) {\n                return {\n                    selectionStart: graphemeStart,\n                    selectionEnd: graphemeStart\n                };\n            }\n            var smallerTextEnd = text.slice(start, end), graphemeEnd = fabric.util.string.graphemeSplit(smallerTextEnd).length;\n            return {\n                selectionStart: graphemeStart,\n                selectionEnd: graphemeStart + graphemeEnd\n            };\n        },\n        /**\n     * convert from fabric to textarea values\n     */ fromGraphemeToStringSelection: function(start, end, _text) {\n            var smallerTextStart = _text.slice(0, start), graphemeStart = smallerTextStart.join(\"\").length;\n            if (start === end) {\n                return {\n                    selectionStart: graphemeStart,\n                    selectionEnd: graphemeStart\n                };\n            }\n            var smallerTextEnd = _text.slice(start, end), graphemeEnd = smallerTextEnd.join(\"\").length;\n            return {\n                selectionStart: graphemeStart,\n                selectionEnd: graphemeStart + graphemeEnd\n            };\n        },\n        /**\n     * @private\n     */ _updateTextarea: function() {\n            this.cursorOffsetCache = {};\n            if (!this.hiddenTextarea) {\n                return;\n            }\n            if (!this.inCompositionMode) {\n                var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);\n                this.hiddenTextarea.selectionStart = newSelection.selectionStart;\n                this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;\n            }\n            this.updateTextareaPosition();\n        },\n        /**\n     * @private\n     */ updateFromTextArea: function() {\n            if (!this.hiddenTextarea) {\n                return;\n            }\n            this.cursorOffsetCache = {};\n            this.text = this.hiddenTextarea.value;\n            if (this._shouldClearDimensionCache()) {\n                this.initDimensions();\n                this.setCoords();\n            }\n            var newSelection = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);\n            this.selectionEnd = this.selectionStart = newSelection.selectionEnd;\n            if (!this.inCompositionMode) {\n                this.selectionStart = newSelection.selectionStart;\n            }\n            this.updateTextareaPosition();\n        },\n        /**\n     * @private\n     */ updateTextareaPosition: function() {\n            if (this.selectionStart === this.selectionEnd) {\n                var style = this._calcTextareaPosition();\n                this.hiddenTextarea.style.left = style.left;\n                this.hiddenTextarea.style.top = style.top;\n            }\n        },\n        /**\n     * @private\n     * @return {Object} style contains style for hiddenTextarea\n     */ _calcTextareaPosition: function() {\n            if (!this.canvas) {\n                return {\n                    x: 1,\n                    y: 1\n                };\n            }\n            var desiredPosition = this.inCompositionMode ? this.compositionStart : this.selectionStart, boundaries = this._getCursorBoundaries(desiredPosition), cursorLocation = this.get2DCursorLocation(desiredPosition), lineIndex = cursorLocation.lineIndex, charIndex = cursorLocation.charIndex, charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, \"fontSize\") * this.lineHeight, leftOffset = boundaries.leftOffset, m = this.calcTransformMatrix(), p = {\n                x: boundaries.left + leftOffset,\n                y: boundaries.top + boundaries.topOffset + charHeight\n            }, retinaScaling = this.canvas.getRetinaScaling(), upperCanvas = this.canvas.upperCanvasEl, upperCanvasWidth = upperCanvas.width / retinaScaling, upperCanvasHeight = upperCanvas.height / retinaScaling, maxWidth = upperCanvasWidth - charHeight, maxHeight = upperCanvasHeight - charHeight, scaleX = upperCanvas.clientWidth / upperCanvasWidth, scaleY = upperCanvas.clientHeight / upperCanvasHeight;\n            p = fabric.util.transformPoint(p, m);\n            p = fabric.util.transformPoint(p, this.canvas.viewportTransform);\n            p.x *= scaleX;\n            p.y *= scaleY;\n            if (p.x < 0) {\n                p.x = 0;\n            }\n            if (p.x > maxWidth) {\n                p.x = maxWidth;\n            }\n            if (p.y < 0) {\n                p.y = 0;\n            }\n            if (p.y > maxHeight) {\n                p.y = maxHeight;\n            }\n            // add canvas offset on document\n            p.x += this.canvas._offset.left;\n            p.y += this.canvas._offset.top;\n            return {\n                left: p.x + \"px\",\n                top: p.y + \"px\",\n                fontSize: charHeight + \"px\",\n                charHeight: charHeight\n            };\n        },\n        /**\n     * @private\n     */ _saveEditingProps: function() {\n            this._savedProps = {\n                hasControls: this.hasControls,\n                borderColor: this.borderColor,\n                lockMovementX: this.lockMovementX,\n                lockMovementY: this.lockMovementY,\n                hoverCursor: this.hoverCursor,\n                selectable: this.selectable,\n                defaultCursor: this.canvas && this.canvas.defaultCursor,\n                moveCursor: this.canvas && this.canvas.moveCursor\n            };\n        },\n        /**\n     * @private\n     */ _restoreEditingProps: function() {\n            if (!this._savedProps) {\n                return;\n            }\n            this.hoverCursor = this._savedProps.hoverCursor;\n            this.hasControls = this._savedProps.hasControls;\n            this.borderColor = this._savedProps.borderColor;\n            this.selectable = this._savedProps.selectable;\n            this.lockMovementX = this._savedProps.lockMovementX;\n            this.lockMovementY = this._savedProps.lockMovementY;\n            if (this.canvas) {\n                this.canvas.defaultCursor = this._savedProps.defaultCursor;\n                this.canvas.moveCursor = this._savedProps.moveCursor;\n            }\n        },\n        /**\n     * Exits from editing state\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ exitEditing: function() {\n            var isTextChanged = this._textBeforeEdit !== this.text;\n            var hiddenTextarea = this.hiddenTextarea;\n            this.selected = false;\n            this.isEditing = false;\n            this.selectionEnd = this.selectionStart;\n            if (hiddenTextarea) {\n                hiddenTextarea.blur && hiddenTextarea.blur();\n                hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);\n            }\n            this.hiddenTextarea = null;\n            this.abortCursorAnimation();\n            this._restoreEditingProps();\n            this._currentCursorOpacity = 0;\n            if (this._shouldClearDimensionCache()) {\n                this.initDimensions();\n                this.setCoords();\n            }\n            this.fire(\"editing:exited\");\n            isTextChanged && this.fire(\"modified\");\n            if (this.canvas) {\n                this.canvas.off(\"mouse:move\", this.mouseMoveHandler);\n                this.canvas.fire(\"text:editing:exited\", {\n                    target: this\n                });\n                isTextChanged && this.canvas.fire(\"object:modified\", {\n                    target: this\n                });\n            }\n            return this;\n        },\n        /**\n     * @private\n     */ _removeExtraneousStyles: function() {\n            for(var prop in this.styles){\n                if (!this._textLines[prop]) {\n                    delete this.styles[prop];\n                }\n            }\n        },\n        /**\n     * remove and reflow a style block from start to end.\n     * @param {Number} start linear start position for removal (included in removal)\n     * @param {Number} end linear end position for removal ( excluded from removal )\n     */ removeStyleFromTo: function(start, end) {\n            var cursorStart = this.get2DCursorLocation(start, true), cursorEnd = this.get2DCursorLocation(end, true), lineStart = cursorStart.lineIndex, charStart = cursorStart.charIndex, lineEnd = cursorEnd.lineIndex, charEnd = cursorEnd.charIndex, i, styleObj;\n            if (lineStart !== lineEnd) {\n                // step1 remove the trailing of lineStart\n                if (this.styles[lineStart]) {\n                    for(i = charStart; i < this._unwrappedTextLines[lineStart].length; i++){\n                        delete this.styles[lineStart][i];\n                    }\n                }\n                // step2 move the trailing of lineEnd to lineStart if needed\n                if (this.styles[lineEnd]) {\n                    for(i = charEnd; i < this._unwrappedTextLines[lineEnd].length; i++){\n                        styleObj = this.styles[lineEnd][i];\n                        if (styleObj) {\n                            this.styles[lineStart] || (this.styles[lineStart] = {});\n                            this.styles[lineStart][charStart + i - charEnd] = styleObj;\n                        }\n                    }\n                }\n                // step3 detects lines will be completely removed.\n                for(i = lineStart + 1; i <= lineEnd; i++){\n                    delete this.styles[i];\n                }\n                // step4 shift remaining lines.\n                this.shiftLineStyles(lineEnd, lineStart - lineEnd);\n            } else {\n                // remove and shift left on the same line\n                if (this.styles[lineStart]) {\n                    styleObj = this.styles[lineStart];\n                    var diff = charEnd - charStart, numericChar, _char;\n                    for(i = charStart; i < charEnd; i++){\n                        delete styleObj[i];\n                    }\n                    for(_char in this.styles[lineStart]){\n                        numericChar = parseInt(_char, 10);\n                        if (numericChar >= charEnd) {\n                            styleObj[numericChar - diff] = styleObj[_char];\n                            delete styleObj[_char];\n                        }\n                    }\n                }\n            }\n        },\n        /**\n     * Shifts line styles up or down\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} offset Can any number?\n     */ shiftLineStyles: function(lineIndex, offset) {\n            // shift all line styles by offset upward or downward\n            // do not clone deep. we need new array, not new style objects\n            var clonedStyles = clone(this.styles);\n            for(var line in this.styles){\n                var numericLine = parseInt(line, 10);\n                if (numericLine > lineIndex) {\n                    this.styles[numericLine + offset] = clonedStyles[numericLine];\n                    if (!clonedStyles[numericLine - offset]) {\n                        delete this.styles[numericLine];\n                    }\n                }\n            }\n        },\n        restartCursorIfNeeded: function() {\n            if (!this._currentTickState || this._currentTickState.isAborted || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted) {\n                this.initDelayedCursor();\n            }\n        },\n        /**\n     * Handle insertion of more consecutive style lines for when one or more\n     * newlines gets added to the text. Since current style needs to be shifted\n     * first we shift the current style of the number lines needed, then we add\n     * new lines from the last to the first.\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} charIndex Index of a char\n     * @param {Number} qty number of lines to add\n     * @param {Array} copiedStyle Array of objects styles\n     */ insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {\n            var currentCharStyle, newLineStyles = {}, somethingAdded = false, isEndOfLine = this._unwrappedTextLines[lineIndex].length === charIndex;\n            qty || (qty = 1);\n            this.shiftLineStyles(lineIndex, qty);\n            if (this.styles[lineIndex]) {\n                currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];\n            }\n            // we clone styles of all chars\n            // after cursor onto the current line\n            for(var index in this.styles[lineIndex]){\n                var numIndex = parseInt(index, 10);\n                if (numIndex >= charIndex) {\n                    somethingAdded = true;\n                    newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index];\n                    // remove lines from the previous line since they're on a new line now\n                    if (!(isEndOfLine && charIndex === 0)) {\n                        delete this.styles[lineIndex][index];\n                    }\n                }\n            }\n            var styleCarriedOver = false;\n            if (somethingAdded && !isEndOfLine) {\n                // if is end of line, the extra style we copied\n                // is probably not something we want\n                this.styles[lineIndex + qty] = newLineStyles;\n                styleCarriedOver = true;\n            }\n            if (styleCarriedOver) {\n                // skip the last line of since we already prepared it.\n                qty--;\n            }\n            // for the all the lines or all the other lines\n            // we clone current char style onto the next (otherwise empty) line\n            while(qty > 0){\n                if (copiedStyle && copiedStyle[qty - 1]) {\n                    this.styles[lineIndex + qty] = {\n                        0: clone(copiedStyle[qty - 1])\n                    };\n                } else if (currentCharStyle) {\n                    this.styles[lineIndex + qty] = {\n                        0: clone(currentCharStyle)\n                    };\n                } else {\n                    delete this.styles[lineIndex + qty];\n                }\n                qty--;\n            }\n            this._forceClearCache = true;\n        },\n        /**\n     * Inserts style object for a given line/char index\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} charIndex Index of a char\n     * @param {Number} quantity number Style object to insert, if given\n     * @param {Array} copiedStyle array of style objects\n     */ insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {\n            if (!this.styles) {\n                this.styles = {};\n            }\n            var currentLineStyles = this.styles[lineIndex], currentLineStylesCloned = currentLineStyles ? clone(currentLineStyles) : {};\n            quantity || (quantity = 1);\n            // shift all char styles by quantity forward\n            // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4\n            for(var index in currentLineStylesCloned){\n                var numericIndex = parseInt(index, 10);\n                if (numericIndex >= charIndex) {\n                    currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];\n                    // only delete the style if there was nothing moved there\n                    if (!currentLineStylesCloned[numericIndex - quantity]) {\n                        delete currentLineStyles[numericIndex];\n                    }\n                }\n            }\n            this._forceClearCache = true;\n            if (copiedStyle) {\n                while(quantity--){\n                    if (!Object.keys(copiedStyle[quantity]).length) {\n                        continue;\n                    }\n                    if (!this.styles[lineIndex]) {\n                        this.styles[lineIndex] = {};\n                    }\n                    this.styles[lineIndex][charIndex + quantity] = clone(copiedStyle[quantity]);\n                }\n                return;\n            }\n            if (!currentLineStyles) {\n                return;\n            }\n            var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];\n            while(newStyle && quantity--){\n                this.styles[lineIndex][charIndex + quantity] = clone(newStyle);\n            }\n        },\n        /**\n     * Inserts style object(s)\n     * @param {Array} insertedText Characters at the location where style is inserted\n     * @param {Number} start cursor index for inserting style\n     * @param {Array} [copiedStyle] array of style objects to insert.\n     */ insertNewStyleBlock: function(insertedText, start, copiedStyle) {\n            var cursorLoc = this.get2DCursorLocation(start, true), addedLines = [\n                0\n            ], linesLength = 0;\n            // get an array of how many char per lines are being added.\n            for(var i = 0; i < insertedText.length; i++){\n                if (insertedText[i] === \"\\n\") {\n                    linesLength++;\n                    addedLines[linesLength] = 0;\n                } else {\n                    addedLines[linesLength]++;\n                }\n            }\n            // for the first line copy the style from the current char position.\n            if (addedLines[0] > 0) {\n                this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);\n                copiedStyle = copiedStyle && copiedStyle.slice(addedLines[0] + 1);\n            }\n            linesLength && this.insertNewlineStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex + addedLines[0], linesLength);\n            for(var i = 1; i < linesLength; i++){\n                if (addedLines[i] > 0) {\n                    this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);\n                } else if (copiedStyle) {\n                    // this test is required in order to close #6841\n                    // when a pasted buffer begins with a newline then\n                    // this.styles[cursorLoc.lineIndex + i] and copiedStyle[0]\n                    // may be undefined for some reason\n                    if (this.styles[cursorLoc.lineIndex + i] && copiedStyle[0]) {\n                        this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];\n                    }\n                }\n                copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i] + 1);\n            }\n            // we use i outside the loop to get it like linesLength\n            if (addedLines[i] > 0) {\n                this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);\n            }\n        },\n        /**\n     * Set the selectionStart and selectionEnd according to the new position of cursor\n     * mimic the key - mouse navigation when shift is pressed.\n     */ setSelectionStartEndWithShift: function(start, end, newSelection) {\n            if (newSelection <= start) {\n                if (end === start) {\n                    this._selectionDirection = \"left\";\n                } else if (this._selectionDirection === \"right\") {\n                    this._selectionDirection = \"left\";\n                    this.selectionEnd = start;\n                }\n                this.selectionStart = newSelection;\n            } else if (newSelection > start && newSelection < end) {\n                if (this._selectionDirection === \"right\") {\n                    this.selectionEnd = newSelection;\n                } else {\n                    this.selectionStart = newSelection;\n                }\n            } else {\n                // newSelection is > selection start and end\n                if (end === start) {\n                    this._selectionDirection = \"right\";\n                } else if (this._selectionDirection === \"left\") {\n                    this._selectionDirection = \"right\";\n                    this.selectionStart = end;\n                }\n                this.selectionEnd = newSelection;\n            }\n        },\n        setSelectionInBoundaries: function() {\n            var length = this.text.length;\n            if (this.selectionStart > length) {\n                this.selectionStart = length;\n            } else if (this.selectionStart < 0) {\n                this.selectionStart = 0;\n            }\n            if (this.selectionEnd > length) {\n                this.selectionEnd = length;\n            } else if (this.selectionEnd < 0) {\n                this.selectionEnd = 0;\n            }\n        }\n    });\n})();\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\n    /**\n   * Initializes \"dbclick\" event handler\n   */ initDoubleClickSimulation: function() {\n        // for double click\n        this.__lastClickTime = +new Date();\n        // for triple click\n        this.__lastLastClickTime = +new Date();\n        this.__lastPointer = {};\n        this.on(\"mousedown\", this.onMouseDown);\n    },\n    /**\n   * Default event handler to simulate triple click\n   * @private\n   */ onMouseDown: function(options) {\n        if (!this.canvas) {\n            return;\n        }\n        this.__newClickTime = +new Date();\n        var newPointer = options.pointer;\n        if (this.isTripleClick(newPointer)) {\n            this.fire(\"tripleclick\", options);\n            this._stopEvent(options.e);\n        }\n        this.__lastLastClickTime = this.__lastClickTime;\n        this.__lastClickTime = this.__newClickTime;\n        this.__lastPointer = newPointer;\n        this.__lastIsEditing = this.isEditing;\n        this.__lastSelected = this.selected;\n    },\n    isTripleClick: function(newPointer) {\n        return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === newPointer.x && this.__lastPointer.y === newPointer.y;\n    },\n    /**\n   * @private\n   */ _stopEvent: function(e) {\n        e.preventDefault && e.preventDefault();\n        e.stopPropagation && e.stopPropagation();\n    },\n    /**\n   * Initializes event handlers related to cursor or selection\n   */ initCursorSelectionHandlers: function() {\n        this.initMousedownHandler();\n        this.initMouseupHandler();\n        this.initClicks();\n    },\n    /**\n   * Default handler for double click, select a word\n   */ doubleClickHandler: function(options) {\n        if (!this.isEditing) {\n            return;\n        }\n        this.selectWord(this.getSelectionStartFromPointer(options.e));\n    },\n    /**\n   * Default handler for triple click, select a line\n   */ tripleClickHandler: function(options) {\n        if (!this.isEditing) {\n            return;\n        }\n        this.selectLine(this.getSelectionStartFromPointer(options.e));\n    },\n    /**\n   * Initializes double and triple click event handlers\n   */ initClicks: function() {\n        this.on(\"mousedblclick\", this.doubleClickHandler);\n        this.on(\"tripleclick\", this.tripleClickHandler);\n    },\n    /**\n   * Default event handler for the basic functionalities needed on _mouseDown\n   * can be overridden to do something different.\n   * Scope of this implementation is: find the click position, set selectionStart\n   * find selectionEnd, initialize the drawing of either cursor or selection area\n   * initializing a mousedDown on a text area will cancel fabricjs knowledge of\n   * current compositionMode. It will be set to false.\n   */ _mouseDownHandler: function(options) {\n        if (!this.canvas || !this.editable || options.e.button && options.e.button !== 1) {\n            return;\n        }\n        this.__isMousedown = true;\n        if (this.selected) {\n            this.inCompositionMode = false;\n            this.setCursorByClick(options.e);\n        }\n        if (this.isEditing) {\n            this.__selectionStartOnMouseDown = this.selectionStart;\n            if (this.selectionStart === this.selectionEnd) {\n                this.abortCursorAnimation();\n            }\n            this.renderCursorOrSelection();\n        }\n    },\n    /**\n   * Default event handler for the basic functionalities needed on mousedown:before\n   * can be overridden to do something different.\n   * Scope of this implementation is: verify the object is already selected when mousing down\n   */ _mouseDownHandlerBefore: function(options) {\n        if (!this.canvas || !this.editable || options.e.button && options.e.button !== 1) {\n            return;\n        }\n        // we want to avoid that an object that was selected and then becomes unselectable,\n        // may trigger editing mode in some way.\n        this.selected = this === this.canvas._activeObject;\n    },\n    /**\n   * Initializes \"mousedown\" event handler\n   */ initMousedownHandler: function() {\n        this.on(\"mousedown\", this._mouseDownHandler);\n        this.on(\"mousedown:before\", this._mouseDownHandlerBefore);\n    },\n    /**\n   * Initializes \"mouseup\" event handler\n   */ initMouseupHandler: function() {\n        this.on(\"mouseup\", this.mouseUpHandler);\n    },\n    /**\n   * standard handler for mouse up, overridable\n   * @private\n   */ mouseUpHandler: function(options) {\n        this.__isMousedown = false;\n        if (!this.editable || this.group || options.transform && options.transform.actionPerformed || options.e.button && options.e.button !== 1) {\n            return;\n        }\n        if (this.canvas) {\n            var currentActive = this.canvas._activeObject;\n            if (currentActive && currentActive !== this) {\n                // avoid running this logic when there is an active object\n                // this because is possible with shift click and fast clicks,\n                // to rapidly deselect and reselect this object and trigger an enterEdit\n                return;\n            }\n        }\n        if (this.__lastSelected && !this.__corner) {\n            this.selected = false;\n            this.__lastSelected = false;\n            this.enterEditing(options.e);\n            if (this.selectionStart === this.selectionEnd) {\n                this.initDelayedCursor(true);\n            } else {\n                this.renderCursorOrSelection();\n            }\n        } else {\n            this.selected = true;\n        }\n    },\n    /**\n   * Changes cursor location in a text depending on passed pointer (x/y) object\n   * @param {Event} e Event object\n   */ setCursorByClick: function(e) {\n        var newSelection = this.getSelectionStartFromPointer(e), start = this.selectionStart, end = this.selectionEnd;\n        if (e.shiftKey) {\n            this.setSelectionStartEndWithShift(start, end, newSelection);\n        } else {\n            this.selectionStart = newSelection;\n            this.selectionEnd = newSelection;\n        }\n        if (this.isEditing) {\n            this._fireSelectionChanged();\n            this._updateTextarea();\n        }\n    },\n    /**\n   * Returns index of a character corresponding to where an object was clicked\n   * @param {Event} e Event object\n   * @return {Number} Index of a character\n   */ getSelectionStartFromPointer: function(e) {\n        var mouseOffset = this.getLocalPointer(e), prevWidth = 0, width = 0, height = 0, charIndex = 0, lineIndex = 0, lineLeftOffset, line;\n        for(var i = 0, len = this._textLines.length; i < len; i++){\n            if (height <= mouseOffset.y) {\n                height += this.getHeightOfLine(i) * this.scaleY;\n                lineIndex = i;\n                if (i > 0) {\n                    charIndex += this._textLines[i - 1].length + this.missingNewlineOffset(i - 1);\n                }\n            } else {\n                break;\n            }\n        }\n        lineLeftOffset = this._getLineLeftOffset(lineIndex);\n        width = lineLeftOffset * this.scaleX;\n        line = this._textLines[lineIndex];\n        // handling of RTL: in order to get things work correctly,\n        // we assume RTL writing is mirrored compared to LTR writing.\n        // so in position detection we mirror the X offset, and when is time\n        // of rendering it, we mirror it again.\n        if (this.direction === \"rtl\") {\n            mouseOffset.x = this.width * this.scaleX - mouseOffset.x + width;\n        }\n        for(var j = 0, jlen = line.length; j < jlen; j++){\n            prevWidth = width;\n            // i removed something about flipX here, check.\n            width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;\n            if (width <= mouseOffset.x) {\n                charIndex++;\n            } else {\n                break;\n            }\n        }\n        return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);\n    },\n    /**\n   * @private\n   */ _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {\n        // we need Math.abs because when width is after the last char, the offset is given as 1, while is 0\n        var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth, distanceBtwNextCharAndCursor = width - mouseOffset.x, offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor || distanceBtwNextCharAndCursor < 0 ? 0 : 1, newSelectionStart = index + offset;\n        // if object is horizontally flipped, mirror cursor location from the end\n        if (this.flipX) {\n            newSelectionStart = jlen - newSelectionStart;\n        }\n        if (newSelectionStart > this._text.length) {\n            newSelectionStart = this._text.length;\n        }\n        return newSelectionStart;\n    }\n});\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\n    /**\n   * Initializes hidden textarea (needed to bring up keyboard in iOS)\n   */ initHiddenTextarea: function() {\n        this.hiddenTextarea = fabric.document.createElement(\"textarea\");\n        this.hiddenTextarea.setAttribute(\"autocapitalize\", \"off\");\n        this.hiddenTextarea.setAttribute(\"autocorrect\", \"off\");\n        this.hiddenTextarea.setAttribute(\"autocomplete\", \"off\");\n        this.hiddenTextarea.setAttribute(\"spellcheck\", \"false\");\n        this.hiddenTextarea.setAttribute(\"data-fabric-hiddentextarea\", \"\");\n        this.hiddenTextarea.setAttribute(\"wrap\", \"off\");\n        var style = this._calcTextareaPosition();\n        // line-height: 1px; was removed from the style to fix this:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=870966\n        this.hiddenTextarea.style.cssText = \"position: absolute; top: \" + style.top + \"; left: \" + style.left + \"; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;\" + \" padding-top: \" + style.fontSize + \";\";\n        if (this.hiddenTextareaContainer) {\n            this.hiddenTextareaContainer.appendChild(this.hiddenTextarea);\n        } else {\n            fabric.document.body.appendChild(this.hiddenTextarea);\n        }\n        fabric.util.addListener(this.hiddenTextarea, \"keydown\", this.onKeyDown.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"keyup\", this.onKeyUp.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"input\", this.onInput.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"copy\", this.copy.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"cut\", this.copy.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"paste\", this.paste.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"compositionstart\", this.onCompositionStart.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"compositionupdate\", this.onCompositionUpdate.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"compositionend\", this.onCompositionEnd.bind(this));\n        if (!this._clickHandlerInitialized && this.canvas) {\n            fabric.util.addListener(this.canvas.upperCanvasEl, \"click\", this.onClick.bind(this));\n            this._clickHandlerInitialized = true;\n        }\n    },\n    /**\n   * For functionalities on keyDown\n   * Map a special key to a function of the instance/prototype\n   * If you need different behaviour for ESC or TAB or arrows, you have to change\n   * this map setting the name of a function that you build on the fabric.Itext or\n   * your prototype.\n   * the map change will affect all Instances unless you need for only some text Instances\n   * in that case you have to clone this object and assign your Instance.\n   * this.keysMap = fabric.util.object.clone(this.keysMap);\n   * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]\n   */ keysMap: {\n        9: \"exitEditing\",\n        27: \"exitEditing\",\n        33: \"moveCursorUp\",\n        34: \"moveCursorDown\",\n        35: \"moveCursorRight\",\n        36: \"moveCursorLeft\",\n        37: \"moveCursorLeft\",\n        38: \"moveCursorUp\",\n        39: \"moveCursorRight\",\n        40: \"moveCursorDown\"\n    },\n    keysMapRtl: {\n        9: \"exitEditing\",\n        27: \"exitEditing\",\n        33: \"moveCursorUp\",\n        34: \"moveCursorDown\",\n        35: \"moveCursorLeft\",\n        36: \"moveCursorRight\",\n        37: \"moveCursorRight\",\n        38: \"moveCursorUp\",\n        39: \"moveCursorLeft\",\n        40: \"moveCursorDown\"\n    },\n    /**\n   * For functionalities on keyUp + ctrl || cmd\n   */ ctrlKeysMapUp: {\n        67: \"copy\",\n        88: \"cut\"\n    },\n    /**\n   * For functionalities on keyDown + ctrl || cmd\n   */ ctrlKeysMapDown: {\n        65: \"selectAll\"\n    },\n    onClick: function() {\n        // No need to trigger click event here, focus is enough to have the keyboard appear on Android\n        this.hiddenTextarea && this.hiddenTextarea.focus();\n    },\n    /**\n   * Handles keydown event\n   * only used for arrows and combination of modifier keys.\n   * @param {Event} e Event object\n   */ onKeyDown: function(e) {\n        if (!this.isEditing) {\n            return;\n        }\n        var keyMap = this.direction === \"rtl\" ? this.keysMapRtl : this.keysMap;\n        if (e.keyCode in keyMap) {\n            this[keyMap[e.keyCode]](e);\n        } else if (e.keyCode in this.ctrlKeysMapDown && (e.ctrlKey || e.metaKey)) {\n            this[this.ctrlKeysMapDown[e.keyCode]](e);\n        } else {\n            return;\n        }\n        e.stopImmediatePropagation();\n        e.preventDefault();\n        if (e.keyCode >= 33 && e.keyCode <= 40) {\n            // if i press an arrow key just update selection\n            this.inCompositionMode = false;\n            this.clearContextTop();\n            this.renderCursorOrSelection();\n        } else {\n            this.canvas && this.canvas.requestRenderAll();\n        }\n    },\n    /**\n   * Handles keyup event\n   * We handle KeyUp because ie11 and edge have difficulties copy/pasting\n   * if a copy/cut event fired, keyup is dismissed\n   * @param {Event} e Event object\n   */ onKeyUp: function(e) {\n        if (!this.isEditing || this._copyDone || this.inCompositionMode) {\n            this._copyDone = false;\n            return;\n        }\n        if (e.keyCode in this.ctrlKeysMapUp && (e.ctrlKey || e.metaKey)) {\n            this[this.ctrlKeysMapUp[e.keyCode]](e);\n        } else {\n            return;\n        }\n        e.stopImmediatePropagation();\n        e.preventDefault();\n        this.canvas && this.canvas.requestRenderAll();\n    },\n    /**\n   * Handles onInput event\n   * @param {Event} e Event object\n   */ onInput: function(e) {\n        var fromPaste = this.fromPaste;\n        this.fromPaste = false;\n        e && e.stopPropagation();\n        if (!this.isEditing) {\n            return;\n        }\n        // decisions about style changes.\n        var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, charCount = this._text.length, nextCharCount = nextText.length, removedText, insertedText, charDiff = nextCharCount - charCount, selectionStart = this.selectionStart, selectionEnd = this.selectionEnd, selection = selectionStart !== selectionEnd, copiedStyle, removeFrom, removeTo;\n        if (this.hiddenTextarea.value === \"\") {\n            this.styles = {};\n            this.updateFromTextArea();\n            this.fire(\"changed\");\n            if (this.canvas) {\n                this.canvas.fire(\"text:changed\", {\n                    target: this\n                });\n                this.canvas.requestRenderAll();\n            }\n            return;\n        }\n        var textareaSelection = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);\n        var backDelete = selectionStart > textareaSelection.selectionStart;\n        if (selection) {\n            removedText = this._text.slice(selectionStart, selectionEnd);\n            charDiff += selectionEnd - selectionStart;\n        } else if (nextCharCount < charCount) {\n            if (backDelete) {\n                removedText = this._text.slice(selectionEnd + charDiff, selectionEnd);\n            } else {\n                removedText = this._text.slice(selectionStart, selectionStart - charDiff);\n            }\n        }\n        insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);\n        if (removedText && removedText.length) {\n            if (insertedText.length) {\n                // let's copy some style before deleting.\n                // we want to copy the style before the cursor OR the style at the cursor if selection\n                // is bigger than 0.\n                copiedStyle = this.getSelectionStyles(selectionStart, selectionStart + 1, false);\n                // now duplicate the style one for each inserted text.\n                copiedStyle = insertedText.map(function() {\n                    // this return an array of references, but that is fine since we are\n                    // copying the style later.\n                    return copiedStyle[0];\n                });\n            }\n            if (selection) {\n                removeFrom = selectionStart;\n                removeTo = selectionEnd;\n            } else if (backDelete) {\n                // detect differences between forwardDelete and backDelete\n                removeFrom = selectionEnd - removedText.length;\n                removeTo = selectionEnd;\n            } else {\n                removeFrom = selectionEnd;\n                removeTo = selectionEnd + removedText.length;\n            }\n            this.removeStyleFromTo(removeFrom, removeTo);\n        }\n        if (insertedText.length) {\n            if (fromPaste && insertedText.join(\"\") === fabric.copiedText && !fabric.disableStyleCopyPaste) {\n                copiedStyle = fabric.copiedTextStyle;\n            }\n            this.insertNewStyleBlock(insertedText, selectionStart, copiedStyle);\n        }\n        this.updateFromTextArea();\n        this.fire(\"changed\");\n        if (this.canvas) {\n            this.canvas.fire(\"text:changed\", {\n                target: this\n            });\n            this.canvas.requestRenderAll();\n        }\n    },\n    /**\n   * Composition start\n   */ onCompositionStart: function() {\n        this.inCompositionMode = true;\n    },\n    /**\n   * Composition end\n   */ onCompositionEnd: function() {\n        this.inCompositionMode = false;\n    },\n    // /**\n    //  * Composition update\n    //  */\n    onCompositionUpdate: function(e) {\n        this.compositionStart = e.target.selectionStart;\n        this.compositionEnd = e.target.selectionEnd;\n        this.updateTextareaPosition();\n    },\n    /**\n   * Copies selected text\n   * @param {Event} e Event object\n   */ copy: function() {\n        if (this.selectionStart === this.selectionEnd) {\n            //do not cut-copy if no selection\n            return;\n        }\n        fabric.copiedText = this.getSelectedText();\n        if (!fabric.disableStyleCopyPaste) {\n            fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);\n        } else {\n            fabric.copiedTextStyle = null;\n        }\n        this._copyDone = true;\n    },\n    /**\n   * Pastes text\n   * @param {Event} e Event object\n   */ paste: function() {\n        this.fromPaste = true;\n    },\n    /**\n   * @private\n   * @param {Event} e Event object\n   * @return {Object} Clipboard data object\n   */ _getClipboardData: function(e) {\n        return e && e.clipboardData || fabric.window.clipboardData;\n    },\n    /**\n   * Finds the width in pixels before the cursor on the same line\n   * @private\n   * @param {Number} lineIndex\n   * @param {Number} charIndex\n   * @return {Number} widthBeforeCursor width before cursor\n   */ _getWidthBeforeCursor: function(lineIndex, charIndex) {\n        var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;\n        if (charIndex > 0) {\n            bound = this.__charBounds[lineIndex][charIndex - 1];\n            widthBeforeCursor += bound.left + bound.width;\n        }\n        return widthBeforeCursor;\n    },\n    /**\n   * Gets start offset of a selection\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */ getDownCursorOffset: function(e, isRight) {\n        var selectionProp = this._getSelectionForOffset(e, isRight), cursorLocation = this.get2DCursorLocation(selectionProp), lineIndex = cursorLocation.lineIndex;\n        // if on last line, down cursor goes to end of line\n        if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {\n            // move to the end of a text\n            return this._text.length - selectionProp;\n        }\n        var charIndex = cursorLocation.charIndex, widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex), indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor), textAfterCursor = this._textLines[lineIndex].slice(charIndex);\n        return textAfterCursor.length + indexOnOtherLine + 1 + this.missingNewlineOffset(lineIndex);\n    },\n    /**\n   * private\n   * Helps finding if the offset should be counted from Start or End\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */ _getSelectionForOffset: function(e, isRight) {\n        if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {\n            return this.selectionEnd;\n        } else {\n            return this.selectionStart;\n        }\n    },\n    /**\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */ getUpCursorOffset: function(e, isRight) {\n        var selectionProp = this._getSelectionForOffset(e, isRight), cursorLocation = this.get2DCursorLocation(selectionProp), lineIndex = cursorLocation.lineIndex;\n        if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {\n            // if on first line, up cursor goes to start of line\n            return -selectionProp;\n        }\n        var charIndex = cursorLocation.charIndex, widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex), indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor), textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex), missingNewlineOffset = this.missingNewlineOffset(lineIndex - 1);\n        // return a negative offset\n        return -this._textLines[lineIndex - 1].length + indexOnOtherLine - textBeforeCursor.length + (1 - missingNewlineOffset);\n    },\n    /**\n   * for a given width it founds the matching character.\n   * @private\n   */ _getIndexOnLine: function(lineIndex, width) {\n        var line = this._textLines[lineIndex], lineLeftOffset = this._getLineLeftOffset(lineIndex), widthOfCharsOnLine = lineLeftOffset, indexOnLine = 0, charWidth, foundMatch;\n        for(var j = 0, jlen = line.length; j < jlen; j++){\n            charWidth = this.__charBounds[lineIndex][j].width;\n            widthOfCharsOnLine += charWidth;\n            if (widthOfCharsOnLine > width) {\n                foundMatch = true;\n                var leftEdge = widthOfCharsOnLine - charWidth, rightEdge = widthOfCharsOnLine, offsetFromLeftEdge = Math.abs(leftEdge - width), offsetFromRightEdge = Math.abs(rightEdge - width);\n                indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : j - 1;\n                break;\n            }\n        }\n        // reached end\n        if (!foundMatch) {\n            indexOnLine = line.length - 1;\n        }\n        return indexOnLine;\n    },\n    /**\n   * Moves cursor down\n   * @param {Event} e Event object\n   */ moveCursorDown: function(e) {\n        if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {\n            return;\n        }\n        this._moveCursorUpOrDown(\"Down\", e);\n    },\n    /**\n   * Moves cursor up\n   * @param {Event} e Event object\n   */ moveCursorUp: function(e) {\n        if (this.selectionStart === 0 && this.selectionEnd === 0) {\n            return;\n        }\n        this._moveCursorUpOrDown(\"Up\", e);\n    },\n    /**\n   * Moves cursor up or down, fires the events\n   * @param {String} direction 'Up' or 'Down'\n   * @param {Event} e Event object\n   */ _moveCursorUpOrDown: function(direction, e) {\n        // getUpCursorOffset\n        // getDownCursorOffset\n        var action = \"get\" + direction + \"CursorOffset\", offset = this[action](e, this._selectionDirection === \"right\");\n        if (e.shiftKey) {\n            this.moveCursorWithShift(offset);\n        } else {\n            this.moveCursorWithoutShift(offset);\n        }\n        if (offset !== 0) {\n            this.setSelectionInBoundaries();\n            this.abortCursorAnimation();\n            this._currentCursorOpacity = 1;\n            this.initDelayedCursor();\n            this._fireSelectionChanged();\n            this._updateTextarea();\n        }\n    },\n    /**\n   * Moves cursor with shift\n   * @param {Number} offset\n   */ moveCursorWithShift: function(offset) {\n        var newSelection = this._selectionDirection === \"left\" ? this.selectionStart + offset : this.selectionEnd + offset;\n        this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);\n        return offset !== 0;\n    },\n    /**\n   * Moves cursor up without shift\n   * @param {Number} offset\n   */ moveCursorWithoutShift: function(offset) {\n        if (offset < 0) {\n            this.selectionStart += offset;\n            this.selectionEnd = this.selectionStart;\n        } else {\n            this.selectionEnd += offset;\n            this.selectionStart = this.selectionEnd;\n        }\n        return offset !== 0;\n    },\n    /**\n   * Moves cursor left\n   * @param {Event} e Event object\n   */ moveCursorLeft: function(e) {\n        if (this.selectionStart === 0 && this.selectionEnd === 0) {\n            return;\n        }\n        this._moveCursorLeftOrRight(\"Left\", e);\n    },\n    /**\n   * @private\n   * @return {Boolean} true if a change happened\n   */ _move: function(e, prop, direction) {\n        var newValue;\n        if (e.altKey) {\n            newValue = this[\"findWordBoundary\" + direction](this[prop]);\n        } else if (e.metaKey || e.keyCode === 35 || e.keyCode === 36) {\n            newValue = this[\"findLineBoundary\" + direction](this[prop]);\n        } else {\n            this[prop] += direction === \"Left\" ? -1 : 1;\n            return true;\n        }\n        if (typeof newValue !== \"undefined\" && this[prop] !== newValue) {\n            this[prop] = newValue;\n            return true;\n        }\n    },\n    /**\n   * @private\n   */ _moveLeft: function(e, prop) {\n        return this._move(e, prop, \"Left\");\n    },\n    /**\n   * @private\n   */ _moveRight: function(e, prop) {\n        return this._move(e, prop, \"Right\");\n    },\n    /**\n   * Moves cursor left without keeping selection\n   * @param {Event} e\n   */ moveCursorLeftWithoutShift: function(e) {\n        var change = true;\n        this._selectionDirection = \"left\";\n        // only move cursor when there is no selection,\n        // otherwise we discard it, and leave cursor on same place\n        if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {\n            change = this._moveLeft(e, \"selectionStart\");\n        }\n        this.selectionEnd = this.selectionStart;\n        return change;\n    },\n    /**\n   * Moves cursor left while keeping selection\n   * @param {Event} e\n   */ moveCursorLeftWithShift: function(e) {\n        if (this._selectionDirection === \"right\" && this.selectionStart !== this.selectionEnd) {\n            return this._moveLeft(e, \"selectionEnd\");\n        } else if (this.selectionStart !== 0) {\n            this._selectionDirection = \"left\";\n            return this._moveLeft(e, \"selectionStart\");\n        }\n    },\n    /**\n   * Moves cursor right\n   * @param {Event} e Event object\n   */ moveCursorRight: function(e) {\n        if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {\n            return;\n        }\n        this._moveCursorLeftOrRight(\"Right\", e);\n    },\n    /**\n   * Moves cursor right or Left, fires event\n   * @param {String} direction 'Left', 'Right'\n   * @param {Event} e Event object\n   */ _moveCursorLeftOrRight: function(direction, e) {\n        var actionName = \"moveCursor\" + direction + \"With\";\n        this._currentCursorOpacity = 1;\n        if (e.shiftKey) {\n            actionName += \"Shift\";\n        } else {\n            actionName += \"outShift\";\n        }\n        if (this[actionName](e)) {\n            this.abortCursorAnimation();\n            this.initDelayedCursor();\n            this._fireSelectionChanged();\n            this._updateTextarea();\n        }\n    },\n    /**\n   * Moves cursor right while keeping selection\n   * @param {Event} e\n   */ moveCursorRightWithShift: function(e) {\n        if (this._selectionDirection === \"left\" && this.selectionStart !== this.selectionEnd) {\n            return this._moveRight(e, \"selectionStart\");\n        } else if (this.selectionEnd !== this._text.length) {\n            this._selectionDirection = \"right\";\n            return this._moveRight(e, \"selectionEnd\");\n        }\n    },\n    /**\n   * Moves cursor right without keeping selection\n   * @param {Event} e Event object\n   */ moveCursorRightWithoutShift: function(e) {\n        var changed = true;\n        this._selectionDirection = \"right\";\n        if (this.selectionStart === this.selectionEnd) {\n            changed = this._moveRight(e, \"selectionStart\");\n            this.selectionEnd = this.selectionStart;\n        } else {\n            this.selectionStart = this.selectionEnd;\n        }\n        return changed;\n    },\n    /**\n   * Removes characters from start/end\n   * start/end ar per grapheme position in _text array.\n   *\n   * @param {Number} start\n   * @param {Number} end default to start + 1\n   */ removeChars: function(start, end) {\n        if (typeof end === \"undefined\") {\n            end = start + 1;\n        }\n        this.removeStyleFromTo(start, end);\n        this._text.splice(start, end - start);\n        this.text = this._text.join(\"\");\n        this.set(\"dirty\", true);\n        if (this._shouldClearDimensionCache()) {\n            this.initDimensions();\n            this.setCoords();\n        }\n        this._removeExtraneousStyles();\n    },\n    /**\n   * insert characters at start position, before start position.\n   * start  equal 1 it means the text get inserted between actual grapheme 0 and 1\n   * if style array is provided, it must be as the same length of text in graphemes\n   * if end is provided and is bigger than start, old text is replaced.\n   * start/end ar per grapheme position in _text array.\n   *\n   * @param {String} text text to insert\n   * @param {Array} style array of style objects\n   * @param {Number} start\n   * @param {Number} end default to start + 1\n   */ insertChars: function(text, style, start, end) {\n        if (typeof end === \"undefined\") {\n            end = start;\n        }\n        if (end > start) {\n            this.removeStyleFromTo(start, end);\n        }\n        var graphemes = fabric.util.string.graphemeSplit(text);\n        this.insertNewStyleBlock(graphemes, start, style);\n        this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));\n        this.text = this._text.join(\"\");\n        this.set(\"dirty\", true);\n        if (this._shouldClearDimensionCache()) {\n            this.initDimensions();\n            this.setCoords();\n        }\n        this._removeExtraneousStyles();\n    }\n});\n/* _TO_SVG_START_ */ (function() {\n    var toFixed = fabric.util.toFixed, multipleSpacesRegex = /  +/g;\n    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {\n        /**\n     * Returns SVG representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ _toSVG: function() {\n            var offsets = this._getSVGLeftTopOffsets(), textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);\n            return this._wrapSVGTextAndBg(textAndBg);\n        },\n        /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toSVG: function(reviver) {\n            return this._createBaseSVGMarkup(this._toSVG(), {\n                reviver: reviver,\n                noStyle: true,\n                withShadow: true\n            });\n        },\n        /**\n     * @private\n     */ _getSVGLeftTopOffsets: function() {\n            return {\n                textLeft: -this.width / 2,\n                textTop: -this.height / 2,\n                lineTop: this.getHeightOfLine(0)\n            };\n        },\n        /**\n     * @private\n     */ _wrapSVGTextAndBg: function(textAndBg) {\n            var noShadow = true, textDecoration = this.getSvgTextDecoration(this);\n            return [\n                textAndBg.textBgRects.join(\"\"),\n                '\t\t<text xml:space=\"preserve\" ',\n                this.fontFamily ? 'font-family=\"' + this.fontFamily.replace(/\"/g, \"'\") + '\" ' : \"\",\n                this.fontSize ? 'font-size=\"' + this.fontSize + '\" ' : \"\",\n                this.fontStyle ? 'font-style=\"' + this.fontStyle + '\" ' : \"\",\n                this.fontWeight ? 'font-weight=\"' + this.fontWeight + '\" ' : \"\",\n                textDecoration ? 'text-decoration=\"' + textDecoration + '\" ' : \"\",\n                'style=\"',\n                this.getSvgStyles(noShadow),\n                '\"',\n                this.addPaintOrder(),\n                \" >\",\n                textAndBg.textSpans.join(\"\"),\n                \"</text>\\n\"\n            ];\n        },\n        /**\n     * @private\n     * @param {Number} textTopOffset Text top offset\n     * @param {Number} textLeftOffset Text left offset\n     * @return {Object}\n     */ _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {\n            var textSpans = [], textBgRects = [], height = textTopOffset, lineOffset;\n            // bounding-box background\n            this._setSVGBg(textBgRects);\n            // text and text-background\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                lineOffset = this._getLineLeftOffset(i);\n                if (this.textBackgroundColor || this.styleHas(\"textBackgroundColor\", i)) {\n                    this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);\n                }\n                this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);\n                height += this.getHeightOfLine(i);\n            }\n            return {\n                textSpans: textSpans,\n                textBgRects: textBgRects\n            };\n        },\n        /**\n     * @private\n     */ _createTextCharSpan: function(_char, styleDecl, left, top) {\n            var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex), styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace), fillStyles = styleProps ? 'style=\"' + styleProps + '\"' : \"\", dy = styleDecl.deltaY, dySpan = \"\", NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            if (dy) {\n                dySpan = ' dy=\"' + toFixed(dy, NUM_FRACTION_DIGITS) + '\" ';\n            }\n            return [\n                '<tspan x=\"',\n                toFixed(left, NUM_FRACTION_DIGITS),\n                '\" y=\"',\n                toFixed(top, NUM_FRACTION_DIGITS),\n                '\" ',\n                dySpan,\n                fillStyles,\n                \">\",\n                fabric.util.string.escapeXml(_char),\n                \"</tspan>\"\n            ].join(\"\");\n        },\n        _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {\n            // set proper line offset\n            var lineHeight = this.getHeightOfLine(lineIndex), isJustify = this.textAlign.indexOf(\"justify\") !== -1, actualStyle, nextStyle, charsToRender = \"\", charBox, style, boxWidth = 0, line = this._textLines[lineIndex], timeToRender;\n            textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;\n            for(var i = 0, len = line.length - 1; i <= len; i++){\n                timeToRender = i === len || this.charSpacing;\n                charsToRender += line[i];\n                charBox = this.__charBounds[lineIndex][i];\n                if (boxWidth === 0) {\n                    textLeftOffset += charBox.kernedWidth - charBox.width;\n                    boxWidth += charBox.width;\n                } else {\n                    boxWidth += charBox.kernedWidth;\n                }\n                if (isJustify && !timeToRender) {\n                    if (this._reSpaceAndTab.test(line[i])) {\n                        timeToRender = true;\n                    }\n                }\n                if (!timeToRender) {\n                    // if we have charSpacing, we render char by char\n                    actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);\n                    nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);\n                    timeToRender = fabric.util.hasStyleChanged(actualStyle, nextStyle, true);\n                }\n                if (timeToRender) {\n                    style = this._getStyleDeclaration(lineIndex, i) || {};\n                    textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));\n                    charsToRender = \"\";\n                    actualStyle = nextStyle;\n                    textLeftOffset += boxWidth;\n                    boxWidth = 0;\n                }\n            }\n        },\n        _pushTextBgRect: function(textBgRects, color, left, top, width, height) {\n            var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            textBgRects.push(\"\t\t<rect \", this._getFillAttributes(color), ' x=\"', toFixed(left, NUM_FRACTION_DIGITS), '\" y=\"', toFixed(top, NUM_FRACTION_DIGITS), '\" width=\"', toFixed(width, NUM_FRACTION_DIGITS), '\" height=\"', toFixed(height, NUM_FRACTION_DIGITS), '\"></rect>\\n');\n        },\n        _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {\n            var line = this._textLines[i], heightOfLine = this.getHeightOfLine(i) / this.lineHeight, boxWidth = 0, boxStart = 0, charBox, currentColor, lastColor = this.getValueOfPropertyAt(i, 0, \"textBackgroundColor\");\n            for(var j = 0, jlen = line.length; j < jlen; j++){\n                charBox = this.__charBounds[i][j];\n                currentColor = this.getValueOfPropertyAt(i, j, \"textBackgroundColor\");\n                if (currentColor !== lastColor) {\n                    lastColor && this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart, textTopOffset, boxWidth, heightOfLine);\n                    boxStart = charBox.left;\n                    boxWidth = charBox.width;\n                    lastColor = currentColor;\n                } else {\n                    boxWidth += charBox.kernedWidth;\n                }\n            }\n            currentColor && this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart, textTopOffset, boxWidth, heightOfLine);\n        },\n        /**\n     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values\n     * we work around it by \"moving\" alpha channel into opacity attribute and setting fill's alpha to 1\n     *\n     * @private\n     * @param {*} value\n     * @return {String}\n     */ _getFillAttributes: function(value) {\n            var fillColor = value && typeof value === \"string\" ? new fabric.Color(value) : \"\";\n            if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {\n                return 'fill=\"' + value + '\"';\n            }\n            return 'opacity=\"' + fillColor.getAlpha() + '\" fill=\"' + fillColor.setAlpha(1).toRgb() + '\"';\n        },\n        /**\n     * @private\n     */ _getSVGLineTopOffset: function(lineIndex) {\n            var lineTopOffset = 0, lastHeight = 0;\n            for(var j = 0; j < lineIndex; j++){\n                lineTopOffset += this.getHeightOfLine(j);\n            }\n            lastHeight = this.getHeightOfLine(j);\n            return {\n                lineTop: lineTopOffset,\n                offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)\n            };\n        },\n        /**\n     * Returns styles-string for svg-export\n     * @param {Boolean} skipShadow a boolean to skip shadow filter output\n     * @return {String}\n     */ getSvgStyles: function(skipShadow) {\n            var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);\n            return svgStyle + \" white-space: pre;\";\n        }\n    });\n})();\n/* _TO_SVG_END_ */ (function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    /**\n   * Textbox class, based on IText, allows the user to resize the text rectangle\n   * and wraps lines automatically. Textboxes have their Y scaling locked, the\n   * user can only change width. Height is adjusted automatically based on the\n   * wrapping of lines.\n   * @class fabric.Textbox\n   * @extends fabric.IText\n   * @mixes fabric.Observable\n   * @return {fabric.Textbox} thisArg\n   * @see {@link fabric.Textbox#initialize} for constructor definition\n   */ fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"textbox\",\n        /**\n     * Minimum width of textbox, in pixels.\n     * @type Number\n     * @default\n     */ minWidth: 20,\n        /**\n     * Minimum calculated width of a textbox, in pixels.\n     * fixed to 2 so that an empty textbox cannot go to 0\n     * and is still selectable without text.\n     * @type Number\n     * @default\n     */ dynamicMinWidth: 2,\n        /**\n     * Cached array of text wrapping.\n     * @type Array\n     */ __cachedLines: null,\n        /**\n     * Override standard Object class values\n     */ lockScalingFlip: true,\n        /**\n     * Override standard Object class values\n     * Textbox needs this on false\n     */ noScaleCache: false,\n        /**\n     * Properties which when set cause object to change dimensions\n     * @type Object\n     * @private\n     */ _dimensionAffectingProps: fabric.Text.prototype._dimensionAffectingProps.concat(\"width\"),\n        /**\n     * Use this regular expression to split strings in breakable lines\n     * @private\n     */ _wordJoiners: /[ \\t\\r]/,\n        /**\n     * Use this boolean property in order to split strings that have no white space concept.\n     * this is a cheap way to help with chinese/japanese\n     * @type Boolean\n     * @since 2.6.0\n     */ splitByGrapheme: false,\n        /**\n     * Unlike superclass's version of this function, Textbox does not update\n     * its width.\n     * @private\n     * @override\n     */ initDimensions: function() {\n            if (this.__skipDimension) {\n                return;\n            }\n            this.isEditing && this.initDelayedCursor();\n            this.clearContextTop();\n            this._clearCache();\n            // clear dynamicMinWidth as it will be different after we re-wrap line\n            this.dynamicMinWidth = 0;\n            // wrap lines\n            this._styleMap = this._generateStyleMap(this._splitText());\n            // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap\n            if (this.dynamicMinWidth > this.width) {\n                this._set(\"width\", this.dynamicMinWidth);\n            }\n            if (this.textAlign.indexOf(\"justify\") !== -1) {\n                // once text is measured we need to make space fatter to make justified text.\n                this.enlargeSpaces();\n            }\n            // clear cache and re-calculate height\n            this.height = this.calcTextHeight();\n            this.saveState({\n                propertySet: \"_dimensionAffectingProps\"\n            });\n        },\n        /**\n     * Generate an object that translates the style object so that it is\n     * broken up by visual lines (new lines and automatic wrapping).\n     * The original text styles object is broken up by actual lines (new lines only),\n     * which is only sufficient for Text / IText\n     * @private\n     */ _generateStyleMap: function(textInfo) {\n            var realLineCount = 0, realLineCharCount = 0, charCount = 0, map = {};\n            for(var i = 0; i < textInfo.graphemeLines.length; i++){\n                if (textInfo.graphemeText[charCount] === \"\\n\" && i > 0) {\n                    realLineCharCount = 0;\n                    charCount++;\n                    realLineCount++;\n                } else if (!this.splitByGrapheme && this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {\n                    // this case deals with space's that are removed from end of lines when wrapping\n                    realLineCharCount++;\n                    charCount++;\n                }\n                map[i] = {\n                    line: realLineCount,\n                    offset: realLineCharCount\n                };\n                charCount += textInfo.graphemeLines[i].length;\n                realLineCharCount += textInfo.graphemeLines[i].length;\n            }\n            return map;\n        },\n        /**\n     * Returns true if object has a style property or has it on a specified line\n     * @param {Number} lineIndex\n     * @return {Boolean}\n     */ styleHas: function(property, lineIndex) {\n            if (this._styleMap && !this.isWrapping) {\n                var map = this._styleMap[lineIndex];\n                if (map) {\n                    lineIndex = map.line;\n                }\n            }\n            return fabric.Text.prototype.styleHas.call(this, property, lineIndex);\n        },\n        /**\n     * Returns true if object has no styling or no styling in a line\n     * @param {Number} lineIndex , lineIndex is on wrapped lines.\n     * @return {Boolean}\n     */ isEmptyStyles: function(lineIndex) {\n            if (!this.styles) {\n                return true;\n            }\n            var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false, map = this._styleMap[lineIndex], mapNextLine = this._styleMap[lineIndex + 1];\n            if (map) {\n                lineIndex = map.line;\n                offset = map.offset;\n            }\n            if (mapNextLine) {\n                nextLineIndex = mapNextLine.line;\n                shouldLimit = nextLineIndex === lineIndex;\n                nextOffset = mapNextLine.offset;\n            }\n            obj = typeof lineIndex === \"undefined\" ? this.styles : {\n                line: this.styles[lineIndex]\n            };\n            for(var p1 in obj){\n                for(var p2 in obj[p1]){\n                    if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {\n                        // eslint-disable-next-line no-unused-vars\n                        for(var p3 in obj[p1][p2]){\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */ _getStyleDeclaration: function(lineIndex, charIndex) {\n            if (this._styleMap && !this.isWrapping) {\n                var map = this._styleMap[lineIndex];\n                if (!map) {\n                    return null;\n                }\n                lineIndex = map.line;\n                charIndex = map.offset + charIndex;\n            }\n            return this.callSuper(\"_getStyleDeclaration\", lineIndex, charIndex);\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {Object} style\n     * @private\n     */ _setStyleDeclaration: function(lineIndex, charIndex, style) {\n            var map = this._styleMap[lineIndex];\n            lineIndex = map.line;\n            charIndex = map.offset + charIndex;\n            this.styles[lineIndex][charIndex] = style;\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */ _deleteStyleDeclaration: function(lineIndex, charIndex) {\n            var map = this._styleMap[lineIndex];\n            lineIndex = map.line;\n            charIndex = map.offset + charIndex;\n            delete this.styles[lineIndex][charIndex];\n        },\n        /**\n     * probably broken need a fix\n     * Returns the real style line that correspond to the wrapped lineIndex line\n     * Used just to verify if the line does exist or not.\n     * @param {Number} lineIndex\n     * @returns {Boolean} if the line exists or not\n     * @private\n     */ _getLineStyle: function(lineIndex) {\n            var map = this._styleMap[lineIndex];\n            return !!this.styles[map.line];\n        },\n        /**\n     * Set the line style to an empty object so that is initialized\n     * @param {Number} lineIndex\n     * @param {Object} style\n     * @private\n     */ _setLineStyle: function(lineIndex) {\n            var map = this._styleMap[lineIndex];\n            this.styles[map.line] = {};\n        },\n        /**\n     * Wraps text using the 'width' property of Textbox. First this function\n     * splits text on newlines, so we preserve newlines entered by the user.\n     * Then it wraps each line using the width of the Textbox by calling\n     * _wrapLine().\n     * @param {Array} lines The string array of text that is split into lines\n     * @param {Number} desiredWidth width you want to wrap to\n     * @returns {Array} Array of lines\n     */ _wrapText: function(lines, desiredWidth) {\n            var wrapped = [], i;\n            this.isWrapping = true;\n            for(i = 0; i < lines.length; i++){\n                wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));\n            }\n            this.isWrapping = false;\n            return wrapped;\n        },\n        /**\n     * Helper function to measure a string of text, given its lineIndex and charIndex offset\n     * it gets called when charBounds are not available yet.\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {String} text\n     * @param {number} lineIndex\n     * @param {number} charOffset\n     * @returns {number}\n     * @private\n     */ _measureWord: function(word, lineIndex, charOffset) {\n            var width = 0, prevGrapheme, skipLeft = true;\n            charOffset = charOffset || 0;\n            for(var i = 0, len = word.length; i < len; i++){\n                var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);\n                width += box.kernedWidth;\n                prevGrapheme = word[i];\n            }\n            return width;\n        },\n        /**\n     * Wraps a line of text using the width of the Textbox and a context.\n     * @param {Array} line The grapheme array that represent the line\n     * @param {Number} lineIndex\n     * @param {Number} desiredWidth width you want to wrap the line to\n     * @param {Number} reservedSpace space to remove from wrapping for custom functionalities\n     * @returns {Array} Array of line(s) into which the given text is wrapped\n     * to.\n     */ _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {\n            var lineWidth = 0, splitByGrapheme = this.splitByGrapheme, graphemeLines = [], line = [], // spaces in different languages?\n            words = splitByGrapheme ? fabric.util.string.graphemeSplit(_line) : _line.split(this._wordJoiners), word = \"\", offset = 0, infix = splitByGrapheme ? \"\" : \" \", wordWidth = 0, infixWidth = 0, largestWordWidth = 0, lineJustStarted = true, additionalSpace = this._getWidthOfCharSpacing(), reservedSpace = reservedSpace || 0;\n            // fix a difference between split and graphemeSplit\n            if (words.length === 0) {\n                words.push([]);\n            }\n            desiredWidth -= reservedSpace;\n            for(var i = 0; i < words.length; i++){\n                // if using splitByGrapheme words are already in graphemes.\n                word = splitByGrapheme ? words[i] : fabric.util.string.graphemeSplit(words[i]);\n                wordWidth = this._measureWord(word, lineIndex, offset);\n                offset += word.length;\n                lineWidth += infixWidth + wordWidth - additionalSpace;\n                if (lineWidth > desiredWidth && !lineJustStarted) {\n                    graphemeLines.push(line);\n                    line = [];\n                    lineWidth = wordWidth;\n                    lineJustStarted = true;\n                } else {\n                    lineWidth += additionalSpace;\n                }\n                if (!lineJustStarted && !splitByGrapheme) {\n                    line.push(infix);\n                }\n                line = line.concat(word);\n                infixWidth = splitByGrapheme ? 0 : this._measureWord([\n                    infix\n                ], lineIndex, offset);\n                offset++;\n                lineJustStarted = false;\n                // keep track of largest word\n                if (wordWidth > largestWordWidth) {\n                    largestWordWidth = wordWidth;\n                }\n            }\n            i && graphemeLines.push(line);\n            if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {\n                this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;\n            }\n            return graphemeLines;\n        },\n        /**\n     * Detect if the text line is ended with an hard break\n     * text and itext do not have wrapping, return false\n     * @param {Number} lineIndex text to split\n     * @return {Boolean}\n     */ isEndOfWrapping: function(lineIndex) {\n            if (!this._styleMap[lineIndex + 1]) {\n                // is last line, return true;\n                return true;\n            }\n            if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {\n                // this is last line before a line break, return true;\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Detect if a line has a linebreak and so we need to account for it when moving\n     * and counting style.\n     * @return Number\n     */ missingNewlineOffset: function(lineIndex) {\n            if (this.splitByGrapheme) {\n                return this.isEndOfWrapping(lineIndex) ? 1 : 0;\n            }\n            return 1;\n        },\n        /**\n    * Gets lines of text to render in the Textbox. This function calculates\n    * text wrapping on the fly every time it is called.\n    * @param {String} text text to split\n    * @returns {Array} Array of lines in the Textbox.\n    * @override\n    */ _splitTextIntoLines: function(text) {\n            var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text), graphemeLines = this._wrapText(newText.lines, this.width), lines = new Array(graphemeLines.length);\n            for(var i = 0; i < graphemeLines.length; i++){\n                lines[i] = graphemeLines[i].join(\"\");\n            }\n            newText.lines = lines;\n            newText.graphemeLines = graphemeLines;\n            return newText;\n        },\n        getMinWidth: function() {\n            return Math.max(this.minWidth, this.dynamicMinWidth);\n        },\n        _removeExtraneousStyles: function() {\n            var linesToKeep = {};\n            for(var prop in this._styleMap){\n                if (this._textLines[prop]) {\n                    linesToKeep[this._styleMap[prop].line] = 1;\n                }\n            }\n            for(var prop in this.styles){\n                if (!linesToKeep[prop]) {\n                    delete this.styles[prop];\n                }\n            }\n        },\n        /**\n     * Returns object representation of an instance\n     * @method toObject\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"minWidth\",\n                \"splitByGrapheme\"\n            ].concat(propertiesToInclude));\n        }\n    });\n    /**\n   * Returns fabric.Textbox instance from an object representation\n   * @static\n   * @memberOf fabric.Textbox\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created\n   */ fabric.Textbox.fromObject = function(object, callback) {\n        var styles = fabric.util.stylesFromArray(object.styles, object.text);\n        //copy object to prevent mutation\n        var objCopy = Object.assign({}, object, {\n            styles: styles\n        });\n        return fabric.Object._fromObject(\"Textbox\", objCopy, callback, \"text\");\n    };\n})( true ? exports : 0);\n(function() {\n    var controlsUtils = fabric.controlsUtils, scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler, scaleStyleHandler = controlsUtils.scaleCursorStyleHandler, scalingEqually = controlsUtils.scalingEqually, scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX, scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY, scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName, objectControls = fabric.Object.prototype.controls;\n    objectControls.ml = new fabric.Control({\n        x: -0.5,\n        y: 0,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingXOrSkewingY,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.mr = new fabric.Control({\n        x: 0.5,\n        y: 0,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingXOrSkewingY,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.mb = new fabric.Control({\n        x: 0,\n        y: 0.5,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingYOrSkewingX,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.mt = new fabric.Control({\n        x: 0,\n        y: -0.5,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingYOrSkewingX,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.tl = new fabric.Control({\n        x: -0.5,\n        y: -0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.tr = new fabric.Control({\n        x: 0.5,\n        y: -0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.bl = new fabric.Control({\n        x: -0.5,\n        y: 0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.br = new fabric.Control({\n        x: 0.5,\n        y: 0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.mtr = new fabric.Control({\n        x: 0,\n        y: -0.5,\n        actionHandler: controlsUtils.rotationWithSnapping,\n        cursorStyleHandler: controlsUtils.rotationStyleHandler,\n        offsetY: -40,\n        withConnection: true,\n        actionName: \"rotate\"\n    });\n    if (fabric.Textbox) {\n        // this is breaking the prototype inheritance, no time / ideas to fix it.\n        // is important to document that if you want to have all objects to have a\n        // specific custom control, you have to add it to Object prototype and to Textbox\n        // prototype. The controls are shared as references. So changes to control `tr`\n        // can still apply to all objects if needed.\n        var textBoxControls = fabric.Textbox.prototype.controls = {};\n        textBoxControls.mtr = objectControls.mtr;\n        textBoxControls.tr = objectControls.tr;\n        textBoxControls.br = objectControls.br;\n        textBoxControls.tl = objectControls.tl;\n        textBoxControls.bl = objectControls.bl;\n        textBoxControls.mt = objectControls.mt;\n        textBoxControls.mb = objectControls.mb;\n        textBoxControls.mr = new fabric.Control({\n            x: 0.5,\n            y: 0,\n            actionHandler: controlsUtils.changeWidth,\n            cursorStyleHandler: scaleSkewStyleHandler,\n            actionName: \"resizing\"\n        });\n        textBoxControls.ml = new fabric.Control({\n            x: -0.5,\n            y: 0,\n            actionHandler: controlsUtils.changeWidth,\n            cursorStyleHandler: scaleSkewStyleHandler,\n            actionName: \"resizing\"\n        });\n    }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2ZhYnJpYy9kaXN0L2ZhYnJpYy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxR0FBcUcsR0FDckcsMkVBQTJFLEdBRTNFLElBQUlBLFNBQVNBLFVBQVU7SUFBRUMsU0FBUztBQUFRO0FBQzFDLElBQUksSUFBbUIsRUFBYTtJQUNsQ0MsY0FBYyxHQUFHRjtBQUNuQixPQUVLLEVBRUo7QUFDRCxhQUFhLEdBQ2IsSUFBSSxPQUFPSyxhQUFhLGVBQWUsZ0JBQWtCLGFBQWEsRUFRckUsTUFDSTtJQUNILDBFQUEwRTtJQUMxRSxJQUFJTSxRQUFRQyxtQkFBT0EsQ0FBQztJQUNwQixJQUFJQyxnQkFBZ0IsSUFBSUYsTUFBTUcsS0FBSyxDQUNqQ0MsbUJBQW1CLCtGQUNuQjtRQUNFQyxVQUFVO1lBQ1JDLHdCQUF3QjtnQkFBQzthQUFNO1FBQ2pDO1FBQ0FDLFdBQVc7SUFDYixHQUFHUixNQUFNO0lBQ1hWLE9BQU9LLFFBQVEsR0FBR1EsY0FBY1IsUUFBUTtJQUN4Q0wsT0FBT21CLG1CQUFtQixHQUFHUCx3SkFBZ0U7SUFDN0ZaLE9BQU9xQixVQUFVLEdBQUdULDhHQUF1QztJQUMzRFosT0FBT1UsTUFBTSxHQUFHRztJQUNoQlUsWUFBWXZCLE9BQU9VLE1BQU0sQ0FBQ2EsU0FBUztBQUNyQztBQUVBOzs7Q0FHQyxHQUNEdkIsT0FBT3dCLGdCQUFnQixHQUFHLGtCQUFrQnhCLE9BQU9VLE1BQU0sSUFBSSxrQkFBa0JWLE9BQU9LLFFBQVEsSUFDM0ZMLE9BQU9VLE1BQU0sSUFBSVYsT0FBT1UsTUFBTSxDQUFDZSxTQUFTLElBQUl6QixPQUFPVSxNQUFNLENBQUNlLFNBQVMsQ0FBQ0MsY0FBYyxHQUFHO0FBRXhGOzs7Q0FHQyxHQUNEMUIsT0FBTzJCLFlBQVksR0FBRyxPQUFPQyxXQUFXLGVBQ2xCLGdCQUFrQjtBQUV4QyxvQkFBb0IsR0FDcEI7OztDQUdDLEdBQ0Q1QixPQUFPNkIsaUJBQWlCLEdBQUc7SUFDekI7SUFDQTtJQUNBO0lBQVE7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Q3RCQyxTQUFzQjtRQUN0QkMsTUFBc0I7UUFDdEJDLFVBQXNCO1FBQ3RCQyxVQUFzQjtRQUN0QkMsZUFBc0I7UUFDdEJDLFVBQXNCO1FBQ3RCQyxVQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxhQUFzQjtRQUN0QkMsZ0JBQXNCO1FBQ3RCQyxZQUFzQjtRQUN0QkMsWUFBc0I7UUFDdEJDLFNBQXNCO1FBQ3RCQyxZQUFzQjtRQUN0QkMsY0FBc0I7UUFDdEJDLGVBQXNCO1FBQ3RCQyxlQUFzQjtRQUN0QkMsZUFBc0I7UUFDdEJDLGVBQXNCO1FBQ3RCQyxZQUFzQjtRQUN0QkMsVUFBc0I7UUFDdEJDLGFBQXNCO1FBQ3RCQyxTQUFzQjtRQUN0QkMsU0FBc0I7UUFDdEJDLFlBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsYUFBc0I7UUFDdEJDLGFBQXNCO1FBQ3RCQyxTQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLFlBQXNCO1FBQ3RCQyxNQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLE1BQXNCO1FBQ3RCQyxNQUFzQjtRQUN0QkMsT0FBc0I7UUFDdEJDLGFBQXNCO1FBQ3RCQyxVQUFzQjtRQUN0QkMsU0FBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxRQUFzQjtRQUN0QkMsT0FBc0I7UUFDdEJDLE9BQXNCO1FBQ3RCQyxVQUFzQjtRQUN0QkMsZUFBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxjQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLFlBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsc0JBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLFlBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsYUFBc0I7UUFDdEJDLGVBQXNCO1FBQ3RCQyxjQUFzQjtRQUN0QkMsZ0JBQXNCO1FBQ3RCQyxnQkFBc0I7UUFDdEJDLGdCQUFzQjtRQUN0QkMsYUFBc0I7UUFDdEJDLE1BQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsT0FBc0I7UUFDdEJDLFNBQXNCO1FBQ3RCQyxRQUFzQjtRQUN0QkMsa0JBQXNC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QzFFLGlGQUFpRjtRQUNqRiwrRUFBK0U7UUFDL0UsNENBQTRDO1FBQzVDLElBQUl5QyxrQkFBa0IvMUcsT0FBT3N6RyxPQUFPLENBQUNwNUYsU0FBUyxDQUFDMDFCLFFBQVEsR0FBRyxDQUFFO1FBRTVEbW1FLGdCQUFnQkQsR0FBRyxHQUFHSixlQUFlSSxHQUFHO1FBQ3hDQyxnQkFBZ0IvNkQsRUFBRSxHQUFHMDZELGVBQWUxNkQsRUFBRTtRQUN0Qys2RCxnQkFBZ0I3NkQsRUFBRSxHQUFHdzZELGVBQWV4NkQsRUFBRTtRQUN0QzY2RCxnQkFBZ0JoN0QsRUFBRSxHQUFHMjZELGVBQWUzNkQsRUFBRTtRQUN0Q2c3RCxnQkFBZ0I5NkQsRUFBRSxHQUFHeTZELGVBQWV6NkQsRUFBRTtRQUN0Qzg2RCxnQkFBZ0JuM0YsRUFBRSxHQUFHODJGLGVBQWU5MkYsRUFBRTtRQUN0Q20zRixnQkFBZ0JGLEVBQUUsR0FBR0gsZUFBZUcsRUFBRTtRQUV0Q0UsZ0JBQWdCSCxFQUFFLEdBQUcsSUFBSTUxRyxPQUFPODRDLE9BQU8sQ0FBQztZQUN0Q3R1QyxHQUFHO1lBQ0hDLEdBQUc7WUFDSGtvQyxlQUFlMkUsY0FBY1gsV0FBVztZQUN4QzZDLG9CQUFvQmc4RDtZQUNwQno4RCxZQUFZO1FBQ2Q7UUFFQWc5RCxnQkFBZ0JKLEVBQUUsR0FBRyxJQUFJMzFHLE9BQU84NEMsT0FBTyxDQUFDO1lBQ3RDdHVDLEdBQUcsQ0FBQztZQUNKQyxHQUFHO1lBQ0hrb0MsZUFBZTJFLGNBQWNYLFdBQVc7WUFDeEM2QyxvQkFBb0JnOEQ7WUFDcEJ6OEQsWUFBWTtRQUNkO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bjb3Zlci1jcmFmdC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL2ZhYnJpYy9kaXN0L2ZhYnJpYy5qcz8zMmU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGJ1aWxkOiBgbm9kZSBidWlsZC5qcyBtb2R1bGVzPUFMTCBleGNsdWRlPWdlc3R1cmVzLGFjY2Vzc29ycyxlcmFzaW5nIHJlcXVpcmVqcyBtaW5pZmllcj11Z2xpZnlqc2AgKi9cbi8qISBGYWJyaWMuanMgQ29weXJpZ2h0IDIwMDgtMjAxNSwgUHJpbnRpbyAoSnVyaXkgWmF5dHNldiwgTWF4aW0gQ2hlcm55YWspICovXG5cbnZhciBmYWJyaWMgPSBmYWJyaWMgfHwgeyB2ZXJzaW9uOiAnNS4zLjAnIH07XG5pZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gIGV4cG9ydHMuZmFicmljID0gZmFicmljO1xufVxuLyogX0FNRF9TVEFSVF8gKi9cbmVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFicmljOyB9KTtcbn1cbi8qIF9BTURfRU5EXyAqL1xuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKGRvY3VtZW50IGluc3RhbmNlb2YgKHR5cGVvZiBIVE1MRG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gSFRNTERvY3VtZW50IDogRG9jdW1lbnQpKSB7XG4gICAgZmFicmljLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gIH1cbiAgZWxzZSB7XG4gICAgZmFicmljLmRvY3VtZW50ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCcnKTtcbiAgfVxuICBmYWJyaWMud2luZG93ID0gd2luZG93O1xufVxuZWxzZSB7XG4gIC8vIGFzc3VtZSB3ZSdyZSBydW5uaW5nIHVuZGVyIG5vZGUuanMgd2hlbiBkb2N1bWVudC93aW5kb3cgYXJlIG5vdCBwcmVzZW50XG4gIHZhciBqc2RvbSA9IHJlcXVpcmUoJ2pzZG9tJyk7XG4gIHZhciB2aXJ0dWFsV2luZG93ID0gbmV3IGpzZG9tLkpTRE9NKFxuICAgIGRlY29kZVVSSUNvbXBvbmVudCgnJTNDIURPQ1RZUEUlMjBodG1sJTNFJTNDaHRtbCUzRSUzQ2hlYWQlM0UlM0MlMkZoZWFkJTNFJTNDYm9keSUzRSUzQyUyRmJvZHklM0UlM0MlMkZodG1sJTNFJyksXG4gICAge1xuICAgICAgZmVhdHVyZXM6IHtcbiAgICAgICAgRmV0Y2hFeHRlcm5hbFJlc291cmNlczogWydpbWcnXVxuICAgICAgfSxcbiAgICAgIHJlc291cmNlczogJ3VzYWJsZSdcbiAgICB9KS53aW5kb3c7XG4gIGZhYnJpYy5kb2N1bWVudCA9IHZpcnR1YWxXaW5kb3cuZG9jdW1lbnQ7XG4gIGZhYnJpYy5qc2RvbUltcGxGb3JXcmFwcGVyID0gcmVxdWlyZSgnanNkb20vbGliL2pzZG9tL2xpdmluZy9nZW5lcmF0ZWQvdXRpbHMnKS5pbXBsRm9yV3JhcHBlcjtcbiAgZmFicmljLm5vZGVDYW52YXMgPSByZXF1aXJlKCdqc2RvbS9saWIvanNkb20vdXRpbHMnKS5DYW52YXM7XG4gIGZhYnJpYy53aW5kb3cgPSB2aXJ0dWFsV2luZG93O1xuICBET01QYXJzZXIgPSBmYWJyaWMud2luZG93LkRPTVBhcnNlcjtcbn1cblxuLyoqXG4gKiBUcnVlIHdoZW4gaW4gZW52aXJvbm1lbnQgdGhhdCBzdXBwb3J0cyB0b3VjaCBldmVudHNcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xuZmFicmljLmlzVG91Y2hTdXBwb3J0ZWQgPSAnb250b3VjaHN0YXJ0JyBpbiBmYWJyaWMud2luZG93IHx8ICdvbnRvdWNoc3RhcnQnIGluIGZhYnJpYy5kb2N1bWVudCB8fFxuICAoZmFicmljLndpbmRvdyAmJiBmYWJyaWMud2luZG93Lm5hdmlnYXRvciAmJiBmYWJyaWMud2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDApO1xuXG4vKipcbiAqIFRydWUgd2hlbiBpbiBlbnZpcm9ubWVudCB0aGF0J3MgcHJvYmFibHkgTm9kZS5qc1xuICogQHR5cGUgYm9vbGVhblxuICovXG5mYWJyaWMuaXNMaWtlbHlOb2RlID0gdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcblxuLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuLyoqXG4gKiBBdHRyaWJ1dGVzIHBhcnNlZCBmcm9tIGFsbCBTVkcgZWxlbWVudHNcbiAqIEB0eXBlIGFycmF5XG4gKi9cbmZhYnJpYy5TSEFSRURfQVRUUklCVVRFUyA9IFtcbiAgJ2Rpc3BsYXknLFxuICAndHJhbnNmb3JtJyxcbiAgJ2ZpbGwnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsXG4gICdvcGFjaXR5JyxcbiAgJ3N0cm9rZScsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1kYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsXG4gICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLFxuICAnaWQnLCAncGFpbnQtb3JkZXInLCAndmVjdG9yLWVmZmVjdCcsXG4gICdpbnN0YW50aWF0ZWRfYnlfdXNlJywgJ2NsaXAtcGF0aCcsXG5dO1xuLyogX0ZST01fU1ZHX0VORF8gKi9cblxuLyoqXG4gKiBQaXhlbCBwZXIgSW5jaCBhcyBhIGRlZmF1bHQgdmFsdWUgc2V0IHRvIDk2LiBDYW4gYmUgY2hhbmdlZCBmb3IgbW9yZSByZWFsaXN0aWMgY29udmVyc2lvbi5cbiAqL1xuZmFicmljLkRQSSA9IDk2O1xuZmFicmljLnJlTnVtID0gJyg/OlstK10/KD86XFxcXGQrfFxcXFxkKlxcXFwuXFxcXGQrKSg/OltlRV1bLStdP1xcXFxkKyk/KSc7XG5mYWJyaWMuY29tbWFXc3AgPSAnKD86XFxcXHMrLD9cXFxccyp8LFxcXFxzKiknO1xuZmFicmljLnJlUGF0aENvbW1hbmQgPSAvKFstK10/KChcXGQrXFwuXFxkKyl8KChcXGQrKXwoXFwuXFxkKykpKSg/OltlRV1bLStdP1xcZCspPykvaWc7XG5mYWJyaWMucmVOb25Xb3JkID0gL1sgXFxuXFwuLDshXFw/XFwtXS87XG5mYWJyaWMuZm9udFBhdGhzID0geyB9O1xuZmFicmljLmlNYXRyaXggPSBbMSwgMCwgMCwgMSwgMCwgMF07XG5mYWJyaWMuc3ZnTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG4vKipcbiAqIFBpeGVsIGxpbWl0IGZvciBjYWNoZSBjYW52YXNlcy4gMU1weCAsIDRNcHggc2hvdWxkIGJlIGZpbmUuXG4gKiBAc2luY2UgMS43LjE0XG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBkZWZhdWx0XG4gKi9cbmZhYnJpYy5wZXJmTGltaXRTaXplVG90YWwgPSAyMDk3MTUyO1xuXG4vKipcbiAqIFBpeGVsIGxpbWl0IGZvciBjYWNoZSBjYW52YXNlcyB3aWR0aCBvciBoZWlnaHQuIElFIGZpeGVzIHRoZSBtYXhpbXVtIGF0IDUwMDBcbiAqIEBzaW5jZSAxLjcuMTRcbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLm1heENhY2hlU2lkZUxpbWl0ID0gNDA5NjtcblxuLyoqXG4gKiBMb3dlc3QgcGl4ZWwgbGltaXQgZm9yIGNhY2hlIGNhbnZhc2VzLCBzZXQgYXQgMjU2UFhcbiAqIEBzaW5jZSAxLjcuMTRcbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLm1pbkNhY2hlU2lkZUxpbWl0ID0gMjU2O1xuXG4vKipcbiAqIENhY2hlIE9iamVjdCBmb3Igd2lkdGhzIG9mIGNoYXJzIGluIHRleHQgcmVuZGVyaW5nLlxuICovXG5mYWJyaWMuY2hhcldpZHRoc0NhY2hlID0geyB9O1xuXG4vKipcbiAqIGlmIHdlYmdsIGlzIGVuYWJsZWQgYW5kIGF2YWlsYWJsZSwgdGV4dHVyZVNpemUgd2lsbCBkZXRlcm1pbmUgdGhlIHNpemVcbiAqIG9mIHRoZSBjYW52YXMgYmFja2VuZFxuICogQHNpbmNlIDIuMC4wXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBkZWZhdWx0XG4gKi9cbmZhYnJpYy50ZXh0dXJlU2l6ZSA9IDIwNDg7XG5cbi8qKlxuICogV2hlbiAndHJ1ZScsIHN0eWxlIGluZm9ybWF0aW9uIGlzIG5vdCByZXRhaW5lZCB3aGVuIGNvcHkvcGFzdGluZyB0ZXh0LCBtYWtpbmdcbiAqIHBhc3RlZCB0ZXh0IHVzZSBkZXN0aW5hdGlvbiBzdHlsZS5cbiAqIERlZmF1bHRzIHRvICdmYWxzZScuXG4gKiBAdHlwZSBCb29sZWFuXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMuZGlzYWJsZVN0eWxlQ29weVBhc3RlID0gZmFsc2U7XG5cbi8qKlxuICogRW5hYmxlIHdlYmdsIGZvciBmaWx0ZXJpbmcgcGljdHVyZSBpcyBhdmFpbGFibGVcbiAqIEEgZmlsdGVyaW5nIGJhY2tlbmQgd2lsbCBiZSBpbml0aWFsaXplZCwgdGhpcyB3aWxsIGJvdGggdGFrZSBtZW1vcnkgYW5kXG4gKiB0aW1lIHNpbmNlIGEgZGVmYXVsdCAyMDQ4eDIwNDggY2FudmFzIHdpbGwgYmUgY3JlYXRlZCBmb3IgdGhlIGdsIGNvbnRleHRcbiAqIEBzaW5jZSAyLjAuMFxuICogQHR5cGUgQm9vbGVhblxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLmVuYWJsZUdMRmlsdGVyaW5nID0gdHJ1ZTtcblxuLyoqXG4gKiBEZXZpY2UgUGl4ZWwgUmF0aW9cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvc2FmYXJpL2RvY3VtZW50YXRpb24vQXVkaW9WaWRlby9Db25jZXB0dWFsL0hUTUwtY2FudmFzLWd1aWRlL1NldHRpbmdVcHRoZUNhbnZhcy9TZXR0aW5nVXB0aGVDYW52YXMuaHRtbFxuICovXG5mYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyA9IGZhYnJpYy53aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93LndlYmtpdERldmljZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy5tb3pEZXZpY2VQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDE7XG4vKipcbiAqIEJyb3dzZXItc3BlY2lmaWMgY29uc3RhbnQgdG8gYWRqdXN0IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5zaGFkb3dCbHVyIHZhbHVlLFxuICogd2hpY2ggaXMgdW5pdGxlc3MgYW5kIG5vdCByZW5kZXJlZCBlcXVhbGx5IGFjcm9zcyBicm93c2Vycy5cbiAqXG4gKiBWYWx1ZXMgdGhhdCB3b3JrIHF1aXRlIHdlbGwgKGFzIG9mIE9jdG9iZXIgMjAxNykgYXJlOlxuICogLSBDaHJvbWU6IDEuNVxuICogLSBFZGdlOiAxLjc1XG4gKiAtIEZpcmVmb3g6IDAuOVxuICogLSBTYWZhcmk6IDAuOTVcbiAqXG4gKiBAc2luY2UgMi4wLjBcbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHQgMVxuICovXG5mYWJyaWMuYnJvd3NlclNoYWRvd0JsdXJDb25zdGFudCA9IDE7XG5cbi8qKlxuICogVGhpcyBvYmplY3QgY29udGFpbnMgdGhlIHJlc3VsdCBvZiBhcmMgdG8gYmV6aWVyIGNvbnZlcnNpb24gZm9yIGZhc3RlciByZXRyaWV2aW5nIGlmIHRoZSBzYW1lIGFyYyBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgYWdhaW4uXG4gKiBJdCB3YXMgYW4gaW50ZXJuYWwgdmFyaWFibGUsIGlzIGFjY2Vzc2libGUgc2luY2UgdmVyc2lvbiAyLjMuNFxuICovXG5mYWJyaWMuYXJjVG9TZWdtZW50c0NhY2hlID0geyB9O1xuXG4vKipcbiAqIFRoaXMgb2JqZWN0IGtlZXBzIHRoZSByZXN1bHRzIG9mIHRoZSBib3VuZHNPZkN1cnZlIGNhbGN1bGF0aW9uIG1hcHBlZCBieSB0aGUgam9pbmVkIGFyZ3VtZW50cyBuZWNlc3NhcnkgdG8gY2FsY3VsYXRlIGl0LlxuICogSXQgZG9lcyBzcGVlZCB1cCBjYWxjdWxhdGlvbiwgaWYgeW91IHBhcnNlIGFuZCBhZGQgYWx3YXlzIHRoZSBzYW1lIHBhdGhzLCBidXQgaW4gY2FzZSBvZiBoZWF2eSB1c2FnZSBvZiBmcmVlZHJhd2luZ1xuICogeW91IGRvIG5vdCBnZXQgYW55IHNwZWVkIGJlbmVmaXQgYW5kIHlvdSBnZXQgYSBiaWcgb2JqZWN0IGluIG1lbW9yeS5cbiAqIFRoZSBvYmplY3Qgd2FzIGEgcHJpdmF0ZSB2YXJpYWJsZSBiZWZvcmUsIHdoaWxlIG5vdyBpcyBhcHBlbmRlZCB0byB0aGUgbGliIHNvIHRoYXQgeW91IGhhdmUgYWNjZXNzIHRvIGl0IGFuZCB5b3VcbiAqIGNhbiBldmVudHVhbGx5IGNsZWFyIGl0LlxuICogSXQgd2FzIGFuIGludGVybmFsIHZhcmlhYmxlLCBpcyBhY2Nlc3NpYmxlIHNpbmNlIHZlcnNpb24gMi4zLjRcbiAqL1xuZmFicmljLmJvdW5kc09mQ3VydmVDYWNoZSA9IHsgfTtcblxuLyoqXG4gKiBJZiBkaXNhYmxlZCBib3VuZHNPZkN1cnZlQ2FjaGUgaXMgbm90IHVzZWQuIEZvciBhcHBzIHRoYXQgbWFrZSBoZWF2eSB1c2FnZSBvZiBwZW5jaWwgZHJhd2luZyBwcm9iYWJseSBkaXNhYmxpbmcgaXQgaXMgYmV0dGVyXG4gKiBAZGVmYXVsdCB0cnVlXG4gKi9cbmZhYnJpYy5jYWNoZXNCb3VuZHNPZkN1cnZlID0gdHJ1ZTtcblxuLyoqXG4gKiBTa2lwIHBlcmZvcm1hbmNlIHRlc3Rpbmcgb2Ygc2V0dXBHTENvbnRleHQgYW5kIGZvcmNlIHRoZSB1c2Ugb2YgcHV0SW1hZ2VEYXRhIHRoYXQgc2VlbXMgdG8gYmUgdGhlIG9uZSB0aGF0IHdvcmtzIGJlc3Qgb25cbiAqIENocm9tZSArIG9sZCBoYXJkd2FyZS4gaWYgeW91ciB1c2VycyBhcmUgZXhwZXJpZW5jaW5nIGVtcHR5IGltYWdlcyBhZnRlciBmaWx0ZXJpbmcgeW91IG1heSB0cnkgdG8gZm9yY2UgdGhpcyB0byB0cnVlXG4gKiB0aGlzIGhhcyB0byBiZSBzZXQgYmVmb3JlIGluc3RhbnRpYXRpbmcgdGhlIGZpbHRlcmluZyBiYWNrZW5kICggYmVmb3JlIGZpbHRlcmluZyB0aGUgZmlyc3QgaW1hZ2UgKVxuICogQHR5cGUgQm9vbGVhblxuICogQGRlZmF1bHQgZmFsc2VcbiAqL1xuZmFicmljLmZvcmNlR0xQdXRJbWFnZURhdGEgPSBmYWxzZTtcblxuZmFicmljLmluaXRGaWx0ZXJCYWNrZW5kID0gZnVuY3Rpb24oKSB7XG4gIGlmIChmYWJyaWMuZW5hYmxlR0xGaWx0ZXJpbmcgJiYgZmFicmljLmlzV2ViZ2xTdXBwb3J0ZWQgJiYgZmFicmljLmlzV2ViZ2xTdXBwb3J0ZWQoZmFicmljLnRleHR1cmVTaXplKSkge1xuICAgIGNvbnNvbGUubG9nKCdtYXggdGV4dHVyZSBzaXplOiAnICsgZmFicmljLm1heFRleHR1cmVTaXplKTtcbiAgICByZXR1cm4gKG5ldyBmYWJyaWMuV2ViZ2xGaWx0ZXJCYWNrZW5kKHsgdGlsZVNpemU6IGZhYnJpYy50ZXh0dXJlU2l6ZSB9KSk7XG4gIH1cbiAgZWxzZSBpZiAoZmFicmljLkNhbnZhczJkRmlsdGVyQmFja2VuZCkge1xuICAgIHJldHVybiAobmV3IGZhYnJpYy5DYW52YXMyZEZpbHRlckJhY2tlbmQoKSk7XG4gIH1cbn07XG5cblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gZW5zdXJlIGdsb2JhbGl0eSBldmVuIGlmIGVudGlyZSBsaWJyYXJ5IHdlcmUgZnVuY3Rpb24gd3JhcHBlZCAoYXMgaW4gTWV0ZW9yLmpzIHBhY2thZ2luZyBzeXN0ZW0pXG4gIHdpbmRvdy5mYWJyaWMgPSBmYWJyaWM7XG59XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIF9yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGV2ZW50TGlzdGVuZXIgPSB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgZXZlbnRMaXN0ZW5lcltldmVudExpc3RlbmVyLmluZGV4T2YoaGFuZGxlcildID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmFicmljLnV0aWwuYXJyYXkuZmlsbChldmVudExpc3RlbmVyLCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmVzIHNwZWNpZmllZCBldmVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLk9ic2VydmFibGVcbiAgICogQGFsaWFzIG9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXZlbnROYW1lIEV2ZW50IG5hbWUgKGVnLiAnYWZ0ZXI6cmVuZGVyJykgb3Igb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIChlZy4geydhZnRlcjpyZW5kZXInOiBoYW5kbGVyLCAnc2VsZWN0aW9uOmNsZWFyZWQnOiBoYW5kbGVyfSlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBGdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vyc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnMgPSB7IH07XG4gICAgfVxuICAgIC8vIG9uZSBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgd2FzIHBhc3NlZFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGV2ZW50TmFtZSkge1xuICAgICAgICB0aGlzLm9uKHByb3AsIGV2ZW50TmFtZVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSkge1xuICAgICAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0ucHVzaChoYW5kbGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBfb25jZShldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICB2YXIgX2hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLm9mZihldmVudE5hbWUsIF9oYW5kbGVyKTtcbiAgICB9LmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbihldmVudE5hbWUsIF9oYW5kbGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgLy8gb25lIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyB3YXMgcGFzc2VkXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIF9vbmNlLmNhbGwodGhpcywgcHJvcCwgZXZlbnROYW1lW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBfb25jZS5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIGV2ZW50IG9ic2VydmluZyBmb3IgYSBwYXJ0aWN1bGFyIGV2ZW50IGhhbmRsZXIuIENhbGxpbmcgdGhpcyBtZXRob2RcbiAgICogd2l0aG91dCBhcmd1bWVudHMgcmVtb3ZlcyBhbGwgaGFuZGxlcnMgZm9yIGFsbCBldmVudHNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBhbGlhcyBvZmZcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBldmVudE5hbWUgRXZlbnQgbmFtZSAoZWcuICdhZnRlcjpyZW5kZXInKSBvciBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgKGVnLiB7J2FmdGVyOnJlbmRlcic6IGhhbmRsZXIsICdzZWxlY3Rpb246Y2xlYXJlZCc6IGhhbmRsZXJ9KVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEZ1bmN0aW9uIHRvIGJlIGRlbGV0ZWQgZnJvbSBFdmVudExpc3RlbmVyc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIG9mZihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGFsbCBrZXkvdmFsdWUgcGFpcnMgKGV2ZW50IG5hbWUgLT4gZXZlbnQgaGFuZGxlcilcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZm9yIChldmVudE5hbWUgaW4gdGhpcy5fX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgIF9yZW1vdmVFdmVudExpc3RlbmVyLmNhbGwodGhpcywgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb25lIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyB3YXMgcGFzc2VkXG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgX3JlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBwcm9wLCBldmVudE5hbWVbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIF9yZW1vdmVFdmVudExpc3RlbmVyLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgZXZlbnQgd2l0aCBhbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLk9ic2VydmFibGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSBFdmVudCBuYW1lIHRvIGZpcmVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZ1bmN0aW9uIGZpcmUoZXZlbnROYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBsaXN0ZW5lcnNGb3JFdmVudCA9IHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgIGlmICghbGlzdGVuZXJzRm9yRXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnNGb3JFdmVudC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGlzdGVuZXJzRm9yRXZlbnRbaV0gJiYgbGlzdGVuZXJzRm9yRXZlbnRbaV0uY2FsbCh0aGlzLCBvcHRpb25zIHx8IHsgfSk7XG4gICAgfVxuICAgIHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdID0gbGlzdGVuZXJzRm9yRXZlbnQuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLk9ic2VydmFibGVcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjZXZlbnRzfVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2V2ZW50c3xFdmVudHMgZGVtb31cbiAgICovXG4gIGZhYnJpYy5PYnNlcnZhYmxlID0ge1xuICAgIGZpcmU6IGZpcmUsXG4gICAgb246IG9uLFxuICAgIG9uY2U6IG9uY2UsXG4gICAgb2ZmOiBvZmYsXG4gIH07XG59KSgpO1xuXG5cbi8qKlxuICogQG5hbWVzcGFjZSBmYWJyaWMuQ29sbGVjdGlvblxuICovXG5mYWJyaWMuQ29sbGVjdGlvbiA9IHtcblxuICBfb2JqZWN0czogW10sXG5cbiAgLyoqXG4gICAqIEFkZHMgb2JqZWN0cyB0byBjb2xsZWN0aW9uLCBDYW52YXMgb3IgR3JvdXAsIHRoZW4gcmVuZGVycyBjYW52YXNcbiAgICogKGlmIGByZW5kZXJPbkFkZFJlbW92ZWAgaXMgbm90IGBmYWxzZWApLlxuICAgKiBpbiBjYXNlIG9mIEdyb3VwIG5vIGNoYW5nZXMgdG8gYm91bmRpbmcgYm94IGFyZSBtYWRlLlxuICAgKiBPYmplY3RzIHNob3VsZCBiZSBpbnN0YW5jZXMgb2YgKG9yIGluaGVyaXQgZnJvbSkgZmFicmljLk9iamVjdFxuICAgKiBVc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyBoaWdobHkgZGlzY291cmFnZWQgZm9yIGdyb3Vwcy5cbiAgICogeW91IGNhbiBhZGQgYSBidW5jaCBvZiBvYmplY3RzIHdpdGggdGhlIGFkZCBtZXRob2QgYnV0IHRoZW4geW91IE5FRURcbiAgICogdG8gcnVuIGEgYWRkV2l0aFVwZGF0ZSBjYWxsIGZvciB0aGUgR3JvdXAgY2xhc3Mgb3IgcG9zaXRpb24vYmJveCB3aWxsIGJlIHdyb25nLlxuICAgKiBAcGFyYW0gey4uLmZhYnJpYy5PYmplY3R9IG9iamVjdCBaZXJvIG9yIG1vcmUgZmFicmljIGluc3RhbmNlc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGFkZDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX29iamVjdHMucHVzaC5hcHBseSh0aGlzLl9vYmplY3RzLCBhcmd1bWVudHMpO1xuICAgIGlmICh0aGlzLl9vbk9iamVjdEFkZGVkKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX29uT2JqZWN0QWRkZWQoYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogSW5zZXJ0cyBhbiBvYmplY3QgaW50byBjb2xsZWN0aW9uIGF0IHNwZWNpZmllZCBpbmRleCwgdGhlbiByZW5kZXJzIGNhbnZhcyAoaWYgYHJlbmRlck9uQWRkUmVtb3ZlYCBpcyBub3QgYGZhbHNlYClcbiAgICogQW4gb2JqZWN0IHNob3VsZCBiZSBhbiBpbnN0YW5jZSBvZiAob3IgaW5oZXJpdCBmcm9tKSBmYWJyaWMuT2JqZWN0XG4gICAqIFVzZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBmb3IgZ3JvdXBzLlxuICAgKiB5b3UgY2FuIGFkZCBhIGJ1bmNoIG9mIG9iamVjdHMgd2l0aCB0aGUgaW5zZXJ0QXQgbWV0aG9kIGJ1dCB0aGVuIHlvdSBORUVEXG4gICAqIHRvIHJ1biBhIGFkZFdpdGhVcGRhdGUgY2FsbCBmb3IgdGhlIEdyb3VwIGNsYXNzIG9yIHBvc2l0aW9uL2Jib3ggd2lsbCBiZSB3cm9uZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCB0byBpbnNlcnQgb2JqZWN0IGF0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9uU3BsaWNpbmcgV2hlbiBgdHJ1ZWAsIG5vIHNwbGljaW5nIChzaGlmdGluZykgb2Ygb2JqZWN0cyBvY2N1cnNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBpbnNlcnRBdDogZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIG5vblNwbGljaW5nKSB7XG4gICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzO1xuICAgIGlmIChub25TcGxpY2luZykge1xuICAgICAgb2JqZWN0c1tpbmRleF0gPSBvYmplY3Q7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb2JqZWN0cy5zcGxpY2UoaW5kZXgsIDAsIG9iamVjdCk7XG4gICAgfVxuICAgIHRoaXMuX29uT2JqZWN0QWRkZWQgJiYgdGhpcy5fb25PYmplY3RBZGRlZChvYmplY3QpO1xuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgb2JqZWN0cyBmcm9tIGEgY29sbGVjdGlvbiwgdGhlbiByZW5kZXJzIGNhbnZhcyAoaWYgYHJlbmRlck9uQWRkUmVtb3ZlYCBpcyBub3QgYGZhbHNlYClcbiAgICogQHBhcmFtIHsuLi5mYWJyaWMuT2JqZWN0fSBvYmplY3QgWmVybyBvciBtb3JlIGZhYnJpYyBpbnN0YW5jZXNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcbiAgICAgICAgaW5kZXgsIHNvbWV0aGluZ1JlbW92ZWQgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGluZGV4ID0gb2JqZWN0cy5pbmRleE9mKGFyZ3VtZW50c1tpXSk7XG5cbiAgICAgIC8vIG9ubHkgY2FsbCBvbk9iamVjdFJlbW92ZWQgaWYgYW4gb2JqZWN0IHdhcyBhY3R1YWxseSByZW1vdmVkXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHNvbWV0aGluZ1JlbW92ZWQgPSB0cnVlO1xuICAgICAgICBvYmplY3RzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMuX29uT2JqZWN0UmVtb3ZlZCAmJiB0aGlzLl9vbk9iamVjdFJlbW92ZWQoYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHNvbWV0aGluZ1JlbW92ZWQgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIG9iamVjdCBpbiB0aGlzIGdyb3VwXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqICAgICAgICAgICAgICAgICAgIENhbGxiYWNrIGludm9rZWQgd2l0aCBjdXJyZW50IG9iamVjdCBhcyBmaXJzdCBhcmd1bWVudCxcbiAgICogICAgICAgICAgICAgICAgICAgaW5kZXggLSBhcyBzZWNvbmQgYW5kIGFuIGFycmF5IG9mIGFsbCBvYmplY3RzIC0gYXMgdGhpcmQuXG4gICAqICAgICAgICAgICAgICAgICAgIENhbGxiYWNrIGlzIGludm9rZWQgaW4gYSBjb250ZXh0IG9mIEdsb2JhbCBPYmplY3QgKGUuZy4gYHdpbmRvd2ApXG4gICAqICAgICAgICAgICAgICAgICAgIHdoZW4gbm8gYGNvbnRleHRgIGFyZ3VtZW50IGlzIGdpdmVuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IENvbnRleHQgKGFrYSB0aGlzT2JqZWN0KVxuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGZvckVhY2hPYmplY3Q6IGZ1bmN0aW9uKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdmFyIG9iamVjdHMgPSB0aGlzLmdldE9iamVjdHMoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBvYmplY3RzW2ldLCBpLCBvYmplY3RzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgY2hpbGRyZW4gb2JqZWN0cyBvZiB0aGlzIGluc3RhbmNlXG4gICAqIFR5cGUgcGFyYW1ldGVyIGludHJvZHVjZWQgaW4gMS4zLjEwXG4gICAqIHNpbmNlIDIuMy41IHRoaXMgbWV0aG9kIHJldHVybiBhbHdheXMgYSBDT1BZIG9mIHRoZSBhcnJheTtcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBXaGVuIHNwZWNpZmllZCwgb25seSBvYmplY3RzIG9mIHRoaXMgdHlwZSBhcmUgcmV0dXJuZWRcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBnZXRPYmplY3RzOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdHMuY29uY2F0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmZpbHRlcihmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gby50eXBlID09PSB0eXBlO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9iamVjdCBhdCBzcGVjaWZpZWQgaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICovXG4gIGl0ZW06IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3RzW2luZGV4XTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGNvbGxlY3Rpb24gY29udGFpbnMgbm8gb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGNvbGxlY3Rpb24gaXMgZW1wdHlcbiAgICovXG4gIGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5sZW5ndGggPT09IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzaXplIG9mIGEgY29sbGVjdGlvbiAoaS5lOiBsZW5ndGggb2YgYW4gYXJyYXkgY29udGFpbmluZyBpdHMgb2JqZWN0cylcbiAgICogQHJldHVybiB7TnVtYmVyfSBDb2xsZWN0aW9uIHNpemVcbiAgICovXG4gIHNpemU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGNvbGxlY3Rpb24gY29udGFpbnMgYW4gb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNoZWNrIGFnYWluc3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZGVlcD1mYWxzZV0gYHRydWVgIHRvIGNoZWNrIGFsbCBkZXNjZW5kYW50cywgYGZhbHNlYCB0byBjaGVjayBvbmx5IGBfb2JqZWN0c2BcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGNvbGxlY3Rpb24gY29udGFpbnMgYW4gb2JqZWN0XG4gICAqL1xuICBjb250YWluczogZnVuY3Rpb24gKG9iamVjdCwgZGVlcCkge1xuICAgIGlmICh0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqZWN0KSA+IC0xKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVlcCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdHMuc29tZShmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqLmNvbnRhaW5zID09PSAnZnVuY3Rpb24nICYmIG9iai5jb250YWlucyhvYmplY3QsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBudW1iZXIgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xsZWN0aW9uIGNvbXBsZXhpdHlcbiAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5XG4gICAqL1xuICBjb21wbGV4aXR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBjdXJyZW50KSB7XG4gICAgICBtZW1vICs9IGN1cnJlbnQuY29tcGxleGl0eSA/IGN1cnJlbnQuY29tcGxleGl0eSgpIDogMDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIDApO1xuICB9XG59O1xuXG5cbi8qKlxuICogQG5hbWVzcGFjZSBmYWJyaWMuQ29tbW9uTWV0aG9kc1xuICovXG5mYWJyaWMuQ29tbW9uTWV0aG9kcyA9IHtcblxuICAvKipcbiAgICogU2V0cyBvYmplY3QncyBwcm9wZXJ0aWVzIGZyb20gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBfc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5zZXQocHJvcCwgb3B0aW9uc1twcm9wXSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2ZpbGxlcl0gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gcHJvcGVydHkgdG8gc2V0IHRoZSBHcmFkaWVudCB0b1xuICAgKi9cbiAgX2luaXRHcmFkaWVudDogZnVuY3Rpb24oZmlsbGVyLCBwcm9wZXJ0eSkge1xuICAgIGlmIChmaWxsZXIgJiYgZmlsbGVyLmNvbG9yU3RvcHMgJiYgIShmaWxsZXIgaW5zdGFuY2VvZiBmYWJyaWMuR3JhZGllbnQpKSB7XG4gICAgICB0aGlzLnNldChwcm9wZXJ0eSwgbmV3IGZhYnJpYy5HcmFkaWVudChmaWxsZXIpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsbGVyXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSBwcm9wZXJ0eSB0byBzZXQgdGhlIFBhdHRlcm4gdG9cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayB0byBpbnZva2UgYWZ0ZXIgcGF0dGVybiBsb2FkXG4gICAqL1xuICBfaW5pdFBhdHRlcm46IGZ1bmN0aW9uKGZpbGxlciwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgaWYgKGZpbGxlciAmJiBmaWxsZXIuc291cmNlICYmICEoZmlsbGVyIGluc3RhbmNlb2YgZmFicmljLlBhdHRlcm4pKSB7XG4gICAgICB0aGlzLnNldChwcm9wZXJ0eSwgbmV3IGZhYnJpYy5QYXR0ZXJuKGZpbGxlciwgY2FsbGJhY2spKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICB0aGlzLl9zZXQocHJvcCwgb2JqW3Byb3BdKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgcHJvcGVydHkgdG8gYSBnaXZlbiB2YWx1ZS4gV2hlbiBjaGFuZ2luZyBwb3NpdGlvbi9kaW1lbnNpb24gLXJlbGF0ZWQgcHJvcGVydGllcyAobGVmdCwgdG9wLCBzY2FsZSwgYW5nbGUsIGV0Yy4pIGBzZXRgIGRvZXMgbm90IHVwZGF0ZSBwb3NpdGlvbiBvZiBvYmplY3QncyBib3JkZXJzL2NvbnRyb2xzLiBJZiB5b3UgbmVlZCB0byB1cGRhdGUgdGhvc2UsIGNhbGwgYHNldENvb3JkcygpYC5cbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBrZXkgUHJvcGVydHkgbmFtZSBvciBvYmplY3QgKGlmIG9iamVjdCwgaXRlcmF0ZSBvdmVyIHRoZSBvYmplY3QgcHJvcGVydGllcylcbiAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHZhbHVlIFByb3BlcnR5IHZhbHVlIChpZiBmdW5jdGlvbiwgdGhlIHZhbHVlIGlzIHBhc3NlZCBpbnRvIGl0IGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgYXMgYSBuZXcgb25lKVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy5fc2V0T2JqZWN0KGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdGhpc1trZXldID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgc3BlY2lmaWVkIHByb3BlcnR5IGZyb20gYHRydWVgIHRvIGBmYWxzZWAgb3IgZnJvbSBgZmFsc2VgIHRvIGB0cnVlYFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gdG9nZ2xlXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgdG9nZ2xlOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KHByb3BlcnR5KTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMuc2V0KHByb3BlcnR5LCAhdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQmFzaWMgZ2V0dGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAqIEByZXR1cm4geyp9IHZhbHVlIG9mIGEgcHJvcGVydHlcbiAgICovXG4gIGdldDogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICByZXR1cm4gdGhpc1twcm9wZXJ0eV07XG4gIH1cbn07XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gIHZhciBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgICAgYXRhbjIgPSBNYXRoLmF0YW4yLFxuICAgICAgcG93ID0gTWF0aC5wb3csXG4gICAgICBQaUJ5MTgwID0gTWF0aC5QSSAvIDE4MCxcbiAgICAgIFBpQnkyID0gTWF0aC5QSSAvIDI7XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWxcbiAgICovXG4gIGZhYnJpYy51dGlsID0ge1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjb3Mgb2YgYW4gYW5nbGUsIGF2b2lkaW5nIHJldHVybmluZyBmbG9hdHMgZm9yIGtub3duIHJlc3VsdHNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIHRoZSBhbmdsZSBpbiByYWRpYW5zIG9yIGluIGRlZ3JlZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBjb3M6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHsgcmV0dXJuIDE7IH1cbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgLy8gY29zKGEpID0gY29zKC1hKVxuICAgICAgICBhbmdsZSA9IC1hbmdsZTtcbiAgICAgIH1cbiAgICAgIHZhciBhbmdsZVNsaWNlID0gYW5nbGUgLyBQaUJ5MjtcbiAgICAgIHN3aXRjaCAoYW5nbGVTbGljZSkge1xuICAgICAgICBjYXNlIDE6IGNhc2UgMzogcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguY29zKGFuZ2xlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzaW4gb2YgYW4gYW5nbGUsIGF2b2lkaW5nIHJldHVybmluZyBmbG9hdHMgZm9yIGtub3duIHJlc3VsdHNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIHRoZSBhbmdsZSBpbiByYWRpYW5zIG9yIGluIGRlZ3JlZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBzaW46IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHsgcmV0dXJuIDA7IH1cbiAgICAgIHZhciBhbmdsZVNsaWNlID0gYW5nbGUgLyBQaUJ5Miwgc2lnbiA9IDE7XG4gICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgIC8vIHNpbigtYSkgPSAtc2luKGEpXG4gICAgICAgIHNpZ24gPSAtMTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoYW5nbGVTbGljZSkge1xuICAgICAgICBjYXNlIDE6IHJldHVybiBzaWduO1xuICAgICAgICBjYXNlIDI6IHJldHVybiAwO1xuICAgICAgICBjYXNlIDM6IHJldHVybiAtc2lnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnNpbihhbmdsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdmFsdWUgZnJvbSBhbiBhcnJheS5cbiAgICAgKiBQcmVzZW5jZSBvZiB2YWx1ZSAoYW5kIGl0cyBwb3NpdGlvbiBpbiBhbiBhcnJheSkgaXMgZGV0ZXJtaW5lZCB2aWEgYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb3JpZ2luYWwgYXJyYXlcbiAgICAgKi9cbiAgICByZW1vdmVGcm9tQXJyYXk6IGZ1bmN0aW9uKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGlkeCA9IGFycmF5LmluZGV4T2YodmFsdWUpO1xuICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgYXJyYXkuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcmFuZG9tIG51bWJlciBiZXR3ZWVuIDIgc3BlY2lmaWVkIG9uZXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW4gbG93ZXIgbGltaXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4IHVwcGVyIGxpbWl0XG4gICAgICogQHJldHVybiB7TnVtYmVyfSByYW5kb20gdmFsdWUgKGJldHdlZW4gbWluIGFuZCBtYXgpXG4gICAgICovXG4gICAgZ2V0UmFuZG9tSW50OiBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgZGVncmVlcyB0byByYWRpYW5zLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVncmVlcyB2YWx1ZSBpbiBkZWdyZWVzXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB2YWx1ZSBpbiByYWRpYW5zXG4gICAgICovXG4gICAgZGVncmVlc1RvUmFkaWFuczogZnVuY3Rpb24oZGVncmVlcykge1xuICAgICAgcmV0dXJuIGRlZ3JlZXMgKiBQaUJ5MTgwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHJhZGlhbnMgdG8gZGVncmVlcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGlhbnMgdmFsdWUgaW4gcmFkaWFuc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gdmFsdWUgaW4gZGVncmVlc1xuICAgICAqL1xuICAgIHJhZGlhbnNUb0RlZ3JlZXM6IGZ1bmN0aW9uKHJhZGlhbnMpIHtcbiAgICAgIHJldHVybiByYWRpYW5zIC8gUGlCeTE4MDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBgcG9pbnRgIGFyb3VuZCBgb3JpZ2luYCB3aXRoIGByYWRpYW5zYFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHRvIHJvdGF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBvcmlnaW4gVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBUaGUgcmFkaWFucyBvZiB0aGUgYW5nbGUgZm9yIHRoZSByb3RhdGlvblxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gVGhlIG5ldyByb3RhdGVkIHBvaW50XG4gICAgICovXG4gICAgcm90YXRlUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcmlnaW4sIHJhZGlhbnMpIHtcbiAgICAgIHZhciBuZXdQb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnQueCAtIG9yaWdpbi54LCBwb2ludC55IC0gb3JpZ2luLnkpLFxuICAgICAgICAgIHYgPSBmYWJyaWMudXRpbC5yb3RhdGVWZWN0b3IobmV3UG9pbnQsIHJhZGlhbnMpO1xuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQodi54LCB2LnkpLmFkZEVxdWFscyhvcmlnaW4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIGB2ZWN0b3JgIHdpdGggYHJhZGlhbnNgXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2ZWN0b3IgVGhlIHZlY3RvciB0byByb3RhdGUgKHggYW5kIHkpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGlhbnMgVGhlIHJhZGlhbnMgb2YgdGhlIGFuZ2xlIGZvciB0aGUgcm90YXRpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgcm90YXRlZCBwb2ludFxuICAgICAqL1xuICAgIHJvdGF0ZVZlY3RvcjogZnVuY3Rpb24odmVjdG9yLCByYWRpYW5zKSB7XG4gICAgICB2YXIgc2luID0gZmFicmljLnV0aWwuc2luKHJhZGlhbnMpLFxuICAgICAgICAgIGNvcyA9IGZhYnJpYy51dGlsLmNvcyhyYWRpYW5zKSxcbiAgICAgICAgICByeCA9IHZlY3Rvci54ICogY29zIC0gdmVjdG9yLnkgKiBzaW4sXG4gICAgICAgICAgcnkgPSB2ZWN0b3IueCAqIHNpbiArIHZlY3Rvci55ICogY29zO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcngsXG4gICAgICAgIHk6IHJ5XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdmV0b3IgZnJvbSBwb2ludHMgcmVwcmVzZW50ZWQgYXMgYSBwb2ludFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFBvaW50XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHhcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQb2ludH0gZnJvbVxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHRvXG4gICAgICogQHJldHVybnMge1BvaW50fSB2ZWN0b3JcbiAgICAgKi9cbiAgICBjcmVhdGVWZWN0b3I6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQodG8ueCAtIGZyb20ueCwgdG8ueSAtIGZyb20ueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgYW5nbGUgYmV0d2VlbiAyIHZlY3RvcnMgdXNpbmcgZG90IHByb2R1Y3RcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtQb2ludH0gYVxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGJcbiAgICAgKiBAcmV0dXJucyB0aGUgYW5nbGUgaW4gcmFkaWFuIGJldHdlZW4gdGhlIHZlY3RvcnNcbiAgICAgKi9cbiAgICBjYWxjQW5nbGVCZXR3ZWVuVmVjdG9yczogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBNYXRoLmFjb3MoKGEueCAqIGIueCArIGEueSAqIGIueSkgLyAoTWF0aC5oeXBvdChhLngsIGEueSkgKiBNYXRoLmh5cG90KGIueCwgYi55KSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtQb2ludH0gdlxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgdW5pdCB2ZWN0b3Igb2YgcG9pbnRpbmcgdG8gdGhlIGRpcmVjdGlvbiBvZiBgdmBcbiAgICAgKi9cbiAgICBnZXRIYXRWZWN0b3I6IGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludCh2LngsIHYueSkubXVsdGlwbHkoMSAvIE1hdGguaHlwb3Qodi54LCB2LnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7UG9pbnR9IEFcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBCXG4gICAgICogQHBhcmFtIHtQb2ludH0gQ1xuICAgICAqIEByZXR1cm5zIHt7IHZlY3RvcjogUG9pbnQsIGFuZ2xlOiBudW1iZXIgfX0gdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgYmlzZWN0b3Igb2YgQSBhbmQgQSdzIGFuZ2xlXG4gICAgICovXG4gICAgZ2V0QmlzZWN0b3I6IGZ1bmN0aW9uIChBLCBCLCBDKSB7XG4gICAgICB2YXIgQUIgPSBmYWJyaWMudXRpbC5jcmVhdGVWZWN0b3IoQSwgQiksIEFDID0gZmFicmljLnV0aWwuY3JlYXRlVmVjdG9yKEEsIEMpO1xuICAgICAgdmFyIGFscGhhID0gZmFicmljLnV0aWwuY2FsY0FuZ2xlQmV0d2VlblZlY3RvcnMoQUIsIEFDKTtcbiAgICAgIC8vICBjaGVjayBpZiBhbHBoYSBpcyByZWxhdGl2ZSB0byBBQi0+QkNcbiAgICAgIHZhciBybyA9IGZhYnJpYy51dGlsLmNhbGNBbmdsZUJldHdlZW5WZWN0b3JzKGZhYnJpYy51dGlsLnJvdGF0ZVZlY3RvcihBQiwgYWxwaGEpLCBBQyk7XG4gICAgICB2YXIgcGhpID0gYWxwaGEgKiAocm8gPT09IDAgPyAxIDogLTEpIC8gMjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZlY3RvcjogZmFicmljLnV0aWwuZ2V0SGF0VmVjdG9yKGZhYnJpYy51dGlsLnJvdGF0ZVZlY3RvcihBQiwgcGhpKSksXG4gICAgICAgIGFuZ2xlOiBhbHBoYVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvamVjdCBzdHJva2Ugd2lkdGggb24gcG9pbnRzIHJldHVybmluZyAyIHByb2plY3Rpb25zIGZvciBlYWNoIHBvaW50IGFzIGZvbGxvd3M6XG4gICAgICogLSBgbWl0ZXJgOiAyIHBvaW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSBvdXRlciBib3VuZGFyeSBhbmQgdGhlIGlubmVyIGJvdW5kYXJ5IG9mIHN0cm9rZS5cbiAgICAgKiAtIGBiZXZlbGA6IDIgcG9pbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGJldmVsIGJvdW5kYXJpZXMsIHRhbmdlbnQgdG8gdGhlIGJpc2VjdG9yLlxuICAgICAqIC0gYHJvdW5kYDogc2FtZSBhcyBgYmV2ZWxgXG4gICAgICogVXNlZCB0byBjYWxjdWxhdGUgb2JqZWN0J3MgYm91bmRpbmcgYm94XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7UG9pbnRbXX0gcG9pbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zdHJva2VXaWR0aFxuICAgICAqIEBwYXJhbSB7J21pdGVyJ3wnYmV2ZWwnfCdyb3VuZCd9IG9wdGlvbnMuc3Ryb2tlTGluZUpvaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zdHJva2VNaXRlckxpbWl0IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLW1pdGVybGltaXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuc3Ryb2tlVW5pZm9ybVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnNjYWxlWFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnNjYWxlWVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wZW5QYXRoXSB3aGV0aGVyIHRoZSBzaGFwZSBpcyBvcGVuIG9yIG5vdCwgYWZmZWN0cyB0aGUgY2FsY3VsYXRpb25zIG9mIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHNcbiAgICAgKiBAcmV0dXJucyB7ZmFicmljLlBvaW50W119IGFycmF5IG9mIHNpemUgMm4vNG4gb2YgYWxsIHN1c3BlY3RlZCBwb2ludHNcbiAgICAgKi9cbiAgICBwcm9qZWN0U3Ryb2tlT25Qb2ludHM6IGZ1bmN0aW9uIChwb2ludHMsIG9wdGlvbnMsIG9wZW5QYXRoKSB7XG4gICAgICB2YXIgY29vcmRzID0gW10sIHMgPSBvcHRpb25zLnN0cm9rZVdpZHRoIC8gMixcbiAgICAgICAgICBzdHJva2VVbmlmb3JtU2NhbGFyID0gb3B0aW9ucy5zdHJva2VVbmlmb3JtID9cbiAgICAgICAgICAgIG5ldyBmYWJyaWMuUG9pbnQoMSAvIG9wdGlvbnMuc2NhbGVYLCAxIC8gb3B0aW9ucy5zY2FsZVkpIDogbmV3IGZhYnJpYy5Qb2ludCgxLCAxKSxcbiAgICAgICAgICBnZXRTdHJva2VIYXRWZWN0b3IgPSBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIHNjYWxhciA9IHMgLyAoTWF0aC5oeXBvdCh2LngsIHYueSkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQodi54ICogc2NhbGFyICogc3Ryb2tlVW5pZm9ybVNjYWxhci54LCB2LnkgKiBzY2FsYXIgKiBzdHJva2VVbmlmb3JtU2NhbGFyLnkpO1xuICAgICAgICAgIH07XG4gICAgICBpZiAocG9pbnRzLmxlbmd0aCA8PSAxKSB7cmV0dXJuIGNvb3Jkczt9XG4gICAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIEEgPSBuZXcgZmFicmljLlBvaW50KHAueCwgcC55KSwgQiwgQztcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgQyA9IHBvaW50c1tpbmRleCArIDFdO1xuICAgICAgICAgIEIgPSBvcGVuUGF0aCA/IGdldFN0cm9rZUhhdFZlY3RvcihmYWJyaWMudXRpbC5jcmVhdGVWZWN0b3IoQywgQSkpLmFkZEVxdWFscyhBKSA6IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09IHBvaW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgQiA9IHBvaW50c1tpbmRleCAtIDFdO1xuICAgICAgICAgIEMgPSBvcGVuUGF0aCA/IGdldFN0cm9rZUhhdFZlY3RvcihmYWJyaWMudXRpbC5jcmVhdGVWZWN0b3IoQiwgQSkpLmFkZEVxdWFscyhBKSA6IHBvaW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBCID0gcG9pbnRzW2luZGV4IC0gMV07XG4gICAgICAgICAgQyA9IHBvaW50c1tpbmRleCArIDFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiaXNlY3RvciA9IGZhYnJpYy51dGlsLmdldEJpc2VjdG9yKEEsIEIsIEMpLFxuICAgICAgICAgICAgYmlzZWN0b3JWZWN0b3IgPSBiaXNlY3Rvci52ZWN0b3IsXG4gICAgICAgICAgICBhbHBoYSA9IGJpc2VjdG9yLmFuZ2xlLFxuICAgICAgICAgICAgc2NhbGFyLFxuICAgICAgICAgICAgbWl0ZXJWZWN0b3I7XG4gICAgICAgIGlmIChvcHRpb25zLnN0cm9rZUxpbmVKb2luID09PSAnbWl0ZXInKSB7XG4gICAgICAgICAgc2NhbGFyID0gLXMgLyBNYXRoLnNpbihhbHBoYSAvIDIpO1xuICAgICAgICAgIG1pdGVyVmVjdG9yID0gbmV3IGZhYnJpYy5Qb2ludChcbiAgICAgICAgICAgIGJpc2VjdG9yVmVjdG9yLnggKiBzY2FsYXIgKiBzdHJva2VVbmlmb3JtU2NhbGFyLngsXG4gICAgICAgICAgICBiaXNlY3RvclZlY3Rvci55ICogc2NhbGFyICogc3Ryb2tlVW5pZm9ybVNjYWxhci55XG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoTWF0aC5oeXBvdChtaXRlclZlY3Rvci54LCBtaXRlclZlY3Rvci55KSAvIHMgPD0gb3B0aW9ucy5zdHJva2VNaXRlckxpbWl0KSB7XG4gICAgICAgICAgICBjb29yZHMucHVzaChBLmFkZChtaXRlclZlY3RvcikpO1xuICAgICAgICAgICAgY29vcmRzLnB1c2goQS5zdWJ0cmFjdChtaXRlclZlY3RvcikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY2FsYXIgPSAtcyAqIE1hdGguU1FSVDI7XG4gICAgICAgIG1pdGVyVmVjdG9yID0gbmV3IGZhYnJpYy5Qb2ludChcbiAgICAgICAgICBiaXNlY3RvclZlY3Rvci54ICogc2NhbGFyICogc3Ryb2tlVW5pZm9ybVNjYWxhci54LFxuICAgICAgICAgIGJpc2VjdG9yVmVjdG9yLnkgKiBzY2FsYXIgKiBzdHJva2VVbmlmb3JtU2NhbGFyLnlcbiAgICAgICAgKTtcbiAgICAgICAgY29vcmRzLnB1c2goQS5hZGQobWl0ZXJWZWN0b3IpKTtcbiAgICAgICAgY29vcmRzLnB1c2goQS5zdWJ0cmFjdChtaXRlclZlY3RvcikpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29vcmRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0cmFuc2Zvcm0gdCB0byBwb2ludCBwXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge2ZhYnJpYy5Qb2ludH0gcCBUaGUgcG9pbnQgdG8gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHQgVGhlIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtpZ25vcmVPZmZzZXRdIEluZGljYXRlcyB0aGF0IHRoZSBvZmZzZXQgc2hvdWxkIG5vdCBiZSBhcHBsaWVkXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBUaGUgdHJhbnNmb3JtZWQgcG9pbnRcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1Qb2ludDogZnVuY3Rpb24ocCwgdCwgaWdub3JlT2Zmc2V0KSB7XG4gICAgICBpZiAoaWdub3JlT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KFxuICAgICAgICAgIHRbMF0gKiBwLnggKyB0WzJdICogcC55LFxuICAgICAgICAgIHRbMV0gKiBwLnggKyB0WzNdICogcC55XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludChcbiAgICAgICAgdFswXSAqIHAueCArIHRbMl0gKiBwLnkgKyB0WzRdLFxuICAgICAgICB0WzFdICogcC54ICsgdFszXSAqIHAueSArIHRbNV1cbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2YgcG9pbnRzJ3MgYm91bmRpbmcgcmVjdGFuZ2xlIChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIDQgcG9pbnRzIGFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3RyYW5zZm9ybV0gYW4gYXJyYXkgb2YgNiBudW1iZXJzIHJlcHJlc2VudGluZyBhIDJ4MyB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIG1ha2VCb3VuZGluZ0JveEZyb21Qb2ludHM6IGZ1bmN0aW9uKHBvaW50cywgdHJhbnNmb3JtKSB7XG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcG9pbnRzW2ldID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocG9pbnRzW2ldLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgeFBvaW50cyA9IFtwb2ludHNbMF0ueCwgcG9pbnRzWzFdLngsIHBvaW50c1syXS54LCBwb2ludHNbM10ueF0sXG4gICAgICAgICAgbWluWCA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbih4UG9pbnRzKSxcbiAgICAgICAgICBtYXhYID0gZmFicmljLnV0aWwuYXJyYXkubWF4KHhQb2ludHMpLFxuICAgICAgICAgIHdpZHRoID0gbWF4WCAtIG1pblgsXG4gICAgICAgICAgeVBvaW50cyA9IFtwb2ludHNbMF0ueSwgcG9pbnRzWzFdLnksIHBvaW50c1syXS55LCBwb2ludHNbM10ueV0sXG4gICAgICAgICAgbWluWSA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbih5UG9pbnRzKSxcbiAgICAgICAgICBtYXhZID0gZmFicmljLnV0aWwuYXJyYXkubWF4KHlQb2ludHMpLFxuICAgICAgICAgIGhlaWdodCA9IG1heFkgLSBtaW5ZO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBtaW5YLFxuICAgICAgICB0b3A6IG1pblksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludmVydCB0cmFuc2Zvcm1hdGlvbiB0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHQgVGhlIHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgaW52ZXJ0ZWQgdHJhbnNmb3JtXG4gICAgICovXG4gICAgaW52ZXJ0VHJhbnNmb3JtOiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgYSA9IDEgLyAodFswXSAqIHRbM10gLSB0WzFdICogdFsyXSksXG4gICAgICAgICAgciA9IFthICogdFszXSwgLWEgKiB0WzFdLCAtYSAqIHRbMl0sIGEgKiB0WzBdXSxcbiAgICAgICAgICBvID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoeyB4OiB0WzRdLCB5OiB0WzVdIH0sIHIsIHRydWUpO1xuICAgICAgcls0XSA9IC1vLng7XG4gICAgICByWzVdID0gLW8ueTtcbiAgICAgIHJldHVybiByO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHdyYXBwZXIgYXJvdW5kIE51bWJlciN0b0ZpeGVkLCB3aGljaCBjb250cmFyeSB0byBuYXRpdmUgbWV0aG9kIHJldHVybnMgbnVtYmVyLCBub3Qgc3RyaW5nLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG51bWJlciBudW1iZXIgdG8gb3BlcmF0ZSBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFjdGlvbkRpZ2l0cyBudW1iZXIgb2YgZnJhY3Rpb24gZGlnaXRzIHRvIFwibGVhdmVcIlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICB0b0ZpeGVkOiBmdW5jdGlvbihudW1iZXIsIGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChOdW1iZXIobnVtYmVyKS50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGZyb20gYXR0cmlidXRlIHZhbHVlIHRvIHBpeGVsIHZhbHVlIGlmIGFwcGxpY2FibGUuXG4gICAgICogUmV0dXJucyBjb252ZXJ0ZWQgcGl4ZWxzIG9yIG9yaWdpbmFsIHZhbHVlIG5vdCBjb252ZXJ0ZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSBudW1iZXIgdG8gb3BlcmF0ZSBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmb250U2l6ZVxuICAgICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9XG4gICAgICovXG4gICAgcGFyc2VVbml0OiBmdW5jdGlvbih2YWx1ZSwgZm9udFNpemUpIHtcbiAgICAgIHZhciB1bml0ID0gL1xcRHswLDJ9JC8uZXhlYyh2YWx1ZSksXG4gICAgICAgICAgbnVtYmVyID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBpZiAoIWZvbnRTaXplKSB7XG4gICAgICAgIGZvbnRTaXplID0gZmFicmljLlRleHQuREVGQVVMVF9TVkdfRk9OVF9TSVpFO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh1bml0WzBdKSB7XG4gICAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDI1LjQ7XG5cbiAgICAgICAgY2FzZSAnY20nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gMi41NDtcblxuICAgICAgICBjYXNlICdpbic6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEk7XG5cbiAgICAgICAgY2FzZSAncHQnOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gNzI7IC8vIG9yICogNCAvIDNcblxuICAgICAgICBjYXNlICdwYyc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEkgLyA3MiAqIDEyOyAvLyBvciAqIDE2XG5cbiAgICAgICAgY2FzZSAnZW0nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmb250U2l6ZTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHdoaWNoIGFsd2F5cyByZXR1cm5zIGBmYWxzZWAuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZmFsc2VGdW5jdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMga2xhc3MgXCJDbGFzc1wiIG9iamVjdCBvZiBnaXZlbiBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIG9iamVjdCAoZWcuICdjaXJjbGUnKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgTmFtZXNwYWNlIHRvIGdldCBrbGFzcyBcIkNsYXNzXCIgb2JqZWN0IGZyb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGtsYXNzIFwiQ2xhc3NcIlxuICAgICAqL1xuICAgIGdldEtsYXNzOiBmdW5jdGlvbih0eXBlLCBuYW1lc3BhY2UpIHtcbiAgICAgIC8vIGNhcGl0YWxpemUgZmlyc3QgbGV0dGVyIG9ubHlcbiAgICAgIHR5cGUgPSBmYWJyaWMudXRpbC5zdHJpbmcuY2FtZWxpemUodHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc2xpY2UoMSkpO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnJlc29sdmVOYW1lc3BhY2UobmFtZXNwYWNlKVt0eXBlXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhcnJheSBvZiBhdHRyaWJ1dGVzIGZvciBnaXZlbiBzdmcgdGhhdCBmYWJyaWMgcGFyc2VzXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvZiBzdmcgZWxlbWVudCAoZWcuICdjaXJjbGUnKVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBzdHJpbmcgbmFtZXMgb2Ygc3VwcG9ydGVkIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBnZXRTdmdBdHRyaWJ1dGVzOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IFtcbiAgICAgICAgJ2luc3RhbnRpYXRlZF9ieV91c2UnLFxuICAgICAgICAnc3R5bGUnLFxuICAgICAgICAnaWQnLFxuICAgICAgICAnY2xhc3MnXG4gICAgICBdO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2xpbmVhckdyYWRpZW50JzpcbiAgICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQoWyd4MScsICd5MScsICd4MicsICd5MicsICdncmFkaWVudFVuaXRzJywgJ2dyYWRpZW50VHJhbnNmb3JtJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyYWRpYWxHcmFkaWVudCc6XG4gICAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuY29uY2F0KFsnZ3JhZGllbnRVbml0cycsICdncmFkaWVudFRyYW5zZm9ybScsICdjeCcsICdjeScsICdyJywgJ2Z4JywgJ2Z5JywgJ2ZyJ10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdG9wJzpcbiAgICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQoWydvZmZzZXQnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3Qgb2YgZ2l2ZW4gbmFtZXNwYWNlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBOYW1lc3BhY2Ugc3RyaW5nIGUuZy4gJ2ZhYnJpYy5JbWFnZS5maWx0ZXInIG9yICdmYWJyaWMnXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgZm9yIGdpdmVuIG5hbWVzcGFjZSAoZGVmYXVsdCBmYWJyaWMpXG4gICAgICovXG4gICAgcmVzb2x2ZU5hbWVzcGFjZTogZnVuY3Rpb24obmFtZXNwYWNlKSB7XG4gICAgICBpZiAoIW5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm4gZmFicmljO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFydHMgPSBuYW1lc3BhY2Uuc3BsaXQoJy4nKSxcbiAgICAgICAgICBsZW4gPSBwYXJ0cy5sZW5ndGgsIGksXG4gICAgICAgICAgb2JqID0gZ2xvYmFsIHx8IGZhYnJpYy53aW5kb3c7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBvYmogPSBvYmpbcGFydHNbaV1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyBpbWFnZSBlbGVtZW50IGZyb20gZ2l2ZW4gdXJsIGFuZCBwYXNzZXMgaXQgdG8gYSBjYWxsYmFja1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHJlcHJlc2VudGluZyBhbiBpbWFnZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrOyBpbnZva2VkIHdpdGggbG9hZGVkIGltYWdlXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF0gQ29udGV4dCB0byBpbnZva2UgY2FsbGJhY2sgaW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2Nyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiB2YWx1ZSB0byBzZXQgaW1hZ2UgZWxlbWVudCB0b1xuICAgICAqL1xuICAgIGxvYWRJbWFnZTogZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgY29udGV4dCwgY3Jvc3NPcmlnaW4pIHtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgdXJsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1nID0gZmFicmljLnV0aWwuY3JlYXRlSW1hZ2UoKTtcblxuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIHZhciBvbkxvYWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChjb250ZXh0LCBpbWcsIGZhbHNlKTtcbiAgICAgICAgaW1nID0gaW1nLm9ubG9hZCA9IGltZy5vbmVycm9yID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGltZy5vbmxvYWQgPSBvbkxvYWRDYWxsYmFjaztcbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmYWJyaWMubG9nKCdFcnJvciBsb2FkaW5nICcgKyBpbWcuc3JjKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChjb250ZXh0LCBudWxsLCB0cnVlKTtcbiAgICAgICAgaW1nID0gaW1nLm9ubG9hZCA9IGltZy5vbmVycm9yID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIC8vIGRhdGEtdXJscyBhcHBlYXIgdG8gYmUgYnVnZ3kgd2l0aCBjcm9zc09yaWdpblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2thbmdheC9mYWJyaWMuanMvY29tbWl0L2QwYWJiOTBmMWNkNWM1ZWY5ZDJhOTRkM2ZiMjFhMjIzMzBkYTNlMGEjY29tbWl0Y29tbWVudC00NTEzNzY3XG4gICAgICAvLyBzZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTMxNTE1MlxuICAgICAgLy8gICAgIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTkzNTA2OVxuICAgICAgLy8gY3Jvc3NPcmlnaW4gbnVsbCBpcyB0aGUgc2FtZSBhcyBub3Qgc2V0LlxuICAgICAgaWYgKHVybC5pbmRleE9mKCdkYXRhJykgIT09IDAgJiZcbiAgICAgICAgY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBjcm9zc09yaWdpbiAhPT0gbnVsbCkge1xuICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICAgIH1cblxuICAgICAgLy8gSUUxMCAvIElFMTEtRml4OiBTVkcgY29udGVudHMgZnJvbSBkYXRhOiBVUklcbiAgICAgIC8vIHdpbGwgb25seSBiZSBhdmFpbGFibGUgaWYgdGhlIElNRyBpcyBwcmVzZW50XG4gICAgICAvLyBpbiB0aGUgRE9NIChhbmQgdmlzaWJsZSlcbiAgICAgIGlmICh1cmwuc3Vic3RyaW5nKDAsMTQpID09PSAnZGF0YTppbWFnZS9zdmcnKSB7XG4gICAgICAgIGltZy5vbmxvYWQgPSBudWxsO1xuICAgICAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2VJbkRvbShpbWcsIG9uTG9hZENhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgU1ZHIGltYWdlIHdpdGggZGF0YTogVVJMIHRvIHRoZSBkb21cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1nIEltYWdlIG9iamVjdCB3aXRoIGRhdGE6aW1hZ2Uvc3ZnIHNyY1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrOyBpbnZva2VkIHdpdGggbG9hZGVkIGltYWdlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBET00gZWxlbWVudCAoZGl2IGNvbnRhaW5pbmcgdGhlIFNWRyBpbWFnZSlcbiAgICAgKi9cbiAgICBsb2FkSW1hZ2VJbkRvbTogZnVuY3Rpb24oaW1nLCBvbkxvYWRDYWxsYmFjaykge1xuICAgICAgdmFyIGRpdiA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5zdHlsZS53aWR0aCA9IGRpdi5zdHlsZS5oZWlnaHQgPSAnMXB4JztcbiAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gZGl2LnN0eWxlLnRvcCA9ICctMTAwJSc7XG4gICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgZGl2LmFwcGVuZENoaWxkKGltZyk7XG4gICAgICBmYWJyaWMuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAvKipcbiAgICAgICAqIFdyYXAgaW4gZnVuY3Rpb24gdG86XG4gICAgICAgKiAgIDEuIENhbGwgZXhpc3RpbmcgY2FsbGJhY2tcbiAgICAgICAqICAgMi4gQ2xlYW51cCBET01cbiAgICAgICAqL1xuICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25Mb2FkQ2FsbGJhY2soKTtcbiAgICAgICAgZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgZGl2ID0gbnVsbDtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY29ycmVzcG9uZGluZyBmYWJyaWMgaW5zdGFuY2VzIGZyb20gdGhlaXIgb2JqZWN0IHJlcHJlc2VudGF0aW9uc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIE9iamVjdHMgdG8gZW5saXZlblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFsbCBvYmplY3RzIGFyZSBjcmVhdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBOYW1lc3BhY2UgdG8gZ2V0IGtsYXNzIFwiQ2xhc3NcIiBvYmplY3QgZnJvbVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJldml2ZXIgTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygb2JqZWN0IGVsZW1lbnRzLFxuICAgICAqIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBlbmxpdmVuT2JqZWN0czogZnVuY3Rpb24ob2JqZWN0cywgY2FsbGJhY2ssIG5hbWVzcGFjZSwgcmV2aXZlcikge1xuICAgICAgb2JqZWN0cyA9IG9iamVjdHMgfHwgW107XG5cbiAgICAgIHZhciBlbmxpdmVuZWRPYmplY3RzID0gW10sXG4gICAgICAgICAgbnVtTG9hZGVkT2JqZWN0cyA9IDAsXG4gICAgICAgICAgbnVtVG90YWxPYmplY3RzID0gb2JqZWN0cy5sZW5ndGg7XG5cbiAgICAgIGZ1bmN0aW9uIG9uTG9hZGVkKCkge1xuICAgICAgICBpZiAoKytudW1Mb2FkZWRPYmplY3RzID09PSBudW1Ub3RhbE9iamVjdHMpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzLmZpbHRlcihmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgdW5kZWZpbmVkIG9iamVjdHMgKG9iamVjdHMgdGhhdCBnYXZlIGVycm9yKVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFudW1Ub3RhbE9iamVjdHMpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkT2JqZWN0cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChvLCBpbmRleCkge1xuICAgICAgICAvLyBpZiBzcGFyc2UgYXJyYXlcbiAgICAgICAgaWYgKCFvIHx8ICFvLnR5cGUpIHtcbiAgICAgICAgICBvbkxvYWRlZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2xhc3MgPSBmYWJyaWMudXRpbC5nZXRLbGFzcyhvLnR5cGUsIG5hbWVzcGFjZSk7XG4gICAgICAgIGtsYXNzLmZyb21PYmplY3QobywgZnVuY3Rpb24gKG9iaiwgZXJyb3IpIHtcbiAgICAgICAgICBlcnJvciB8fCAoZW5saXZlbmVkT2JqZWN0c1tpbmRleF0gPSBvYmopO1xuICAgICAgICAgIHJldml2ZXIgJiYgcmV2aXZlcihvLCBvYmosIGVycm9yKTtcbiAgICAgICAgICBvbkxvYWRlZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGNvcnJlc3BvbmRpbmcgZmFicmljIGluc3RhbmNlcyByZXNpZGluZyBpbiBhbiBvYmplY3QsIGUuZy4gYGNsaXBQYXRoYFxuICAgICAqIEBzZWUge0BsaW5rIGZhYnJpYy5PYmplY3QuRU5MSVZFTl9QUk9QU31cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBhc3NpZ24gZW5saXZlZCBwcm9wcyB0byB0aGlzIG9iamVjdCAocGFzcyBudWxsIHRvIHNraXAgdGhpcylcbiAgICAgKiBAcGFyYW0geyhvYmplY3RzOmZhYnJpYy5PYmplY3RbXSkgPT4gdm9pZH0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBlbmxpdmVuT2JqZWN0RW5saXZhYmxlczogZnVuY3Rpb24gKG9iamVjdCwgY29udGV4dCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBlbmxpdmVuUHJvcHMgPSBmYWJyaWMuT2JqZWN0LkVOTElWRU5fUFJPUFMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICEhb2JqZWN0W2tleV07IH0pO1xuICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMoZW5saXZlblByb3BzLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBvYmplY3Rba2V5XTsgfSksIGZ1bmN0aW9uIChlbmxpdmVkUHJvcHMpIHtcbiAgICAgICAgdmFyIG9iamVjdHMgPSB7fTtcbiAgICAgICAgZW5saXZlblByb3BzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcbiAgICAgICAgICBvYmplY3RzW2tleV0gPSBlbmxpdmVkUHJvcHNbaW5kZXhdO1xuICAgICAgICAgIGNvbnRleHQgJiYgKGNvbnRleHRba2V5XSA9IGVubGl2ZWRQcm9wc1tpbmRleF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sob2JqZWN0cyk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCB3YWl0IGZvciBsb2FkaW5nIG9mIHBhdHRlcm5zXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdHRlcm5zIE9iamVjdHMgdG8gZW5saXZlblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFsbCBvYmplY3RzIGFyZSBjcmVhdGVkXG4gICAgICogY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqL1xuICAgIGVubGl2ZW5QYXR0ZXJuczogZnVuY3Rpb24ocGF0dGVybnMsIGNhbGxiYWNrKSB7XG4gICAgICBwYXR0ZXJucyA9IHBhdHRlcm5zIHx8IFtdO1xuXG4gICAgICBmdW5jdGlvbiBvbkxvYWRlZCgpIHtcbiAgICAgICAgaWYgKCsrbnVtTG9hZGVkUGF0dGVybnMgPT09IG51bVBhdHRlcm5zKSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkUGF0dGVybnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlbmxpdmVuZWRQYXR0ZXJucyA9IFtdLFxuICAgICAgICAgIG51bUxvYWRlZFBhdHRlcm5zID0gMCxcbiAgICAgICAgICBudW1QYXR0ZXJucyA9IHBhdHRlcm5zLmxlbmd0aDtcblxuICAgICAgaWYgKCFudW1QYXR0ZXJucykge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRQYXR0ZXJucyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGF0dGVybnMuZm9yRWFjaChmdW5jdGlvbiAocCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHAgJiYgcC5zb3VyY2UpIHtcbiAgICAgICAgICBuZXcgZmFicmljLlBhdHRlcm4ocCwgZnVuY3Rpb24ocGF0dGVybikge1xuICAgICAgICAgICAgZW5saXZlbmVkUGF0dGVybnNbaW5kZXhdID0gcGF0dGVybjtcbiAgICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZW5saXZlbmVkUGF0dGVybnNbaW5kZXhdID0gcDtcbiAgICAgICAgICBvbkxvYWRlZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR3JvdXBzIFNWRyBlbGVtZW50cyAodXN1YWxseSB0aG9zZSByZXRyaWV2ZWQgZnJvbSBTVkcgZG9jdW1lbnQpXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnRzIFNWRyBlbGVtZW50cyB0byBncm91cFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBWYWx1ZSB0byBzZXQgc291cmNlUGF0aCB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R8ZmFicmljLkdyb3VwfVxuICAgICAqL1xuICAgIGdyb3VwU1ZHRWxlbWVudHM6IGZ1bmN0aW9uKGVsZW1lbnRzLCBvcHRpb25zLCBwYXRoKSB7XG4gICAgICB2YXIgb2JqZWN0O1xuICAgICAgaWYgKGVsZW1lbnRzICYmIGVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZWxlbWVudHNbMF0uc291cmNlUGF0aCA9IHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzWzBdO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgICAgICBvcHRpb25zLmNlbnRlclBvaW50ID0ge1xuICAgICAgICAgICAgeDogb3B0aW9ucy53aWR0aCAvIDIsXG4gICAgICAgICAgICB5OiBvcHRpb25zLmhlaWdodCAvIDJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLndpZHRoO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb2JqZWN0ID0gbmV3IGZhYnJpYy5Hcm91cChlbGVtZW50cywgb3B0aW9ucyk7XG4gICAgICBpZiAodHlwZW9mIHBhdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9iamVjdC5zb3VyY2VQYXRoID0gcGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlcyBhbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgU291cmNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gcHJvcGVydGllcyBQcm9wZXJ0aWVzIG5hbWVzIHRvIGluY2x1ZGVcbiAgICAgKi9cbiAgICBwb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzOiBmdW5jdGlvbihzb3VyY2UsIGRlc3RpbmF0aW9uLCBwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAocHJvcGVydGllcyAmJiBBcnJheS5pc0FycmF5KHByb3BlcnRpZXMpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXNbaV0gaW4gc291cmNlKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0aWVzW2ldXSA9IHNvdXJjZVtwcm9wZXJ0aWVzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjYW52YXMgZWxlbWVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtDYW52YXNFbGVtZW50fSBpbml0aWFsaXplZCBjYW52YXMgZWxlbWVudFxuICAgICAqL1xuICAgIGNyZWF0ZUNhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNhbnZhcyBlbGVtZW50IHRoYXQgaXMgYSBjb3B5IG9mIGFub3RoZXIgYW5kIGlzIGFsc28gcGFpbnRlZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzRWxlbWVudH0gY2FudmFzIHRvIGNvcHkgc2l6ZSBhbmQgY29udGVudCBvZlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtDYW52YXNFbGVtZW50fSBpbml0aWFsaXplZCBjYW52YXMgZWxlbWVudFxuICAgICAqL1xuICAgIGNvcHlDYW52YXNFbGVtZW50OiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIHZhciBuZXdDYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICBuZXdDYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICBuZXdDYW52YXMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgIG5ld0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xuICAgICAgcmV0dXJuIG5ld0NhbnZhcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2luY2UgMi42LjAgbW92ZWQgZnJvbSBjYW52YXMgaW5zdGFuY2UgdG8gdXRpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc0VsZW1lbnR9IGNhbnZhc0VsIHRvIGNvcHkgc2l6ZSBhbmQgY29udGVudCBvZlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXQgJ2pwZWcnIG9yICdwbmcnLCBpbiBzb21lIGJyb3dzZXJzICd3ZWJwJyBpcyBvayB0b29cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcXVhbGl0eSA8PSAxIGFuZCA+IDBcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBkYXRhIHVybFxuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24oY2FudmFzRWwsIGZvcm1hdCwgcXVhbGl0eSkge1xuICAgICAgcmV0dXJuIGNhbnZhc0VsLnRvRGF0YVVSTCgnaW1hZ2UvJyArIGZvcm1hdCwgcXVhbGl0eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgaW1hZ2UgZWxlbWVudCAod29ya3Mgb24gY2xpZW50IGFuZCBub2RlKVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBIVE1MIGltYWdlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjcmVhdGVJbWFnZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSBtYXRyaXggQSBieSBtYXRyaXggQiB0byBuZXN0IHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYSBGaXJzdCB0cmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYiBTZWNvbmQgdHJhbnNmb3JtTWF0cml4XG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaXMyeDIgZmxhZyB0byBtdWx0aXBseSBtYXRyaWNlcyBhcyAyeDIgbWF0cmljZXNcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIHByb2R1Y3Qgb2YgdGhlIHR3byB0cmFuc2Zvcm0gbWF0cmljZXNcbiAgICAgKi9cbiAgICBtdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzOiBmdW5jdGlvbihhLCBiLCBpczJ4Mikge1xuICAgICAgLy8gTWF0cml4IG11bHRpcGx5IGEgKiBiXG4gICAgICByZXR1cm4gW1xuICAgICAgICBhWzBdICogYlswXSArIGFbMl0gKiBiWzFdLFxuICAgICAgICBhWzFdICogYlswXSArIGFbM10gKiBiWzFdLFxuICAgICAgICBhWzBdICogYlsyXSArIGFbMl0gKiBiWzNdLFxuICAgICAgICBhWzFdICogYlsyXSArIGFbM10gKiBiWzNdLFxuICAgICAgICBpczJ4MiA/IDAgOiBhWzBdICogYls0XSArIGFbMl0gKiBiWzVdICsgYVs0XSxcbiAgICAgICAgaXMyeDIgPyAwIDogYVsxXSAqIGJbNF0gKyBhWzNdICogYls1XSArIGFbNV1cbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY29tcG9zZXMgc3RhbmRhcmQgMngzIG1hdHJpeCBpbnRvIHRyYW5zZm9ybSBjb21wb25lbnRzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhIHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ29tcG9uZW50cyBvZiB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICBxckRlY29tcG9zZTogZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIGFuZ2xlID0gYXRhbjIoYVsxXSwgYVswXSksXG4gICAgICAgICAgZGVub20gPSBwb3coYVswXSwgMikgKyBwb3coYVsxXSwgMiksXG4gICAgICAgICAgc2NhbGVYID0gc3FydChkZW5vbSksXG4gICAgICAgICAgc2NhbGVZID0gKGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV0pIC8gc2NhbGVYLFxuICAgICAgICAgIHNrZXdYID0gYXRhbjIoYVswXSAqIGFbMl0gKyBhWzFdICogYSBbM10sIGRlbm9tKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFuZ2xlOiBhbmdsZSAvIFBpQnkxODAsXG4gICAgICAgIHNjYWxlWDogc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHNjYWxlWSxcbiAgICAgICAgc2tld1g6IHNrZXdYIC8gUGlCeTE4MCxcbiAgICAgICAgc2tld1k6IDAsXG4gICAgICAgIHRyYW5zbGF0ZVg6IGFbNF0sXG4gICAgICAgIHRyYW5zbGF0ZVk6IGFbNV1cbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0cmFuc2Zvcm0gbWF0cml4IHN0YXJ0aW5nIGZyb20gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIGtpbmQgb2ZcbiAgICAgKiB0aGUgb25lIHJldHVybmVkIGZyb20gcXJEZWNvbXBvc2UsIHVzZWZ1bCBhbHNvIGlmIHlvdSB3YW50IHRvIGNhbGN1bGF0ZSBzb21lXG4gICAgICogdHJhbnNmb3JtYXRpb25zIGZyb20gYW4gb2JqZWN0IHRoYXQgaXMgbm90IGVubGl2ZWQgeWV0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuYW5nbGVdIGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0gdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqL1xuICAgIGNhbGNSb3RhdGVNYXRyaXg6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucy5hbmdsZSkge1xuICAgICAgICByZXR1cm4gZmFicmljLmlNYXRyaXguY29uY2F0KCk7XG4gICAgICB9XG4gICAgICB2YXIgdGhldGEgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKG9wdGlvbnMuYW5nbGUpLFxuICAgICAgICAgIGNvcyA9IGZhYnJpYy51dGlsLmNvcyh0aGV0YSksXG4gICAgICAgICAgc2luID0gZmFicmljLnV0aWwuc2luKHRoZXRhKTtcbiAgICAgIHJldHVybiBbY29zLCBzaW4sIC1zaW4sIGNvcywgMCwgMF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0cmFuc2Zvcm0gbWF0cml4IHN0YXJ0aW5nIGZyb20gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIGtpbmQgb2ZcbiAgICAgKiB0aGUgb25lIHJldHVybmVkIGZyb20gcXJEZWNvbXBvc2UsIHVzZWZ1bCBhbHNvIGlmIHlvdSB3YW50IHRvIGNhbGN1bGF0ZSBzb21lXG4gICAgICogdHJhbnNmb3JtYXRpb25zIGZyb20gYW4gb2JqZWN0IHRoYXQgaXMgbm90IGVubGl2ZWQgeWV0LlxuICAgICAqIGlzIGNhbGxlZCBEaW1lbnNpb25zVHJhbnNmb3JtTWF0cml4IGJlY2F1c2UgdGhvc2UgcHJvcGVydGllcyBhcmUgdGhlIG9uZSB0aGF0IGluZmx1ZW5jZVxuICAgICAqIHRoZSBzaXplIG9mIHRoZSByZXN1bHRpbmcgYm94IG9mIHRoZSBvYmplY3QuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2NhbGVYXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2NhbGVZXVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmZsaXBYXVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmZsaXBZXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2tld1hdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5za2V3WV1cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0gdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqL1xuICAgIGNhbGNEaW1lbnNpb25zTWF0cml4OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgc2NhbGVYID0gdHlwZW9mIG9wdGlvbnMuc2NhbGVYID09PSAndW5kZWZpbmVkJyA/IDEgOiBvcHRpb25zLnNjYWxlWCxcbiAgICAgICAgICBzY2FsZVkgPSB0eXBlb2Ygb3B0aW9ucy5zY2FsZVkgPT09ICd1bmRlZmluZWQnID8gMSA6IG9wdGlvbnMuc2NhbGVZLFxuICAgICAgICAgIHNjYWxlTWF0cml4ID0gW1xuICAgICAgICAgICAgb3B0aW9ucy5mbGlwWCA/IC1zY2FsZVggOiBzY2FsZVgsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIG9wdGlvbnMuZmxpcFkgPyAtc2NhbGVZIDogc2NhbGVZLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDBdLFxuICAgICAgICAgIG11bHRpcGx5ID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyxcbiAgICAgICAgICBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucztcbiAgICAgIGlmIChvcHRpb25zLnNrZXdYKSB7XG4gICAgICAgIHNjYWxlTWF0cml4ID0gbXVsdGlwbHkoXG4gICAgICAgICAgc2NhbGVNYXRyaXgsXG4gICAgICAgICAgWzEsIDAsIE1hdGgudGFuKGRlZ3JlZXNUb1JhZGlhbnMob3B0aW9ucy5za2V3WCkpLCAxXSxcbiAgICAgICAgICB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNrZXdZKSB7XG4gICAgICAgIHNjYWxlTWF0cml4ID0gbXVsdGlwbHkoXG4gICAgICAgICAgc2NhbGVNYXRyaXgsXG4gICAgICAgICAgWzEsIE1hdGgudGFuKGRlZ3JlZXNUb1JhZGlhbnMob3B0aW9ucy5za2V3WSkpLCAwLCAxXSxcbiAgICAgICAgICB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2FsZU1hdHJpeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRyYW5zZm9ybSBtYXRyaXggc3RhcnRpbmcgZnJvbSBhbiBvYmplY3Qgb2YgdGhlIHNhbWUga2luZCBvZlxuICAgICAqIHRoZSBvbmUgcmV0dXJuZWQgZnJvbSBxckRlY29tcG9zZSwgdXNlZnVsIGFsc28gaWYgeW91IHdhbnQgdG8gY2FsY3VsYXRlIHNvbWVcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbnMgZnJvbSBhbiBvYmplY3QgdGhhdCBpcyBub3QgZW5saXZlZCB5ZXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5hbmdsZV1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNjYWxlWF1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNjYWxlWV1cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5mbGlwWF1cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5mbGlwWV1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNrZXdYXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2tld1hdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy50cmFuc2xhdGVYXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMudHJhbnNsYXRlWV1cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJbXX0gdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqL1xuICAgIGNvbXBvc2VNYXRyaXg6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBtYXRyaXggPSBbMSwgMCwgMCwgMSwgb3B0aW9ucy50cmFuc2xhdGVYIHx8IDAsIG9wdGlvbnMudHJhbnNsYXRlWSB8fCAwXSxcbiAgICAgICAgICBtdWx0aXBseSA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXM7XG4gICAgICBpZiAob3B0aW9ucy5hbmdsZSkge1xuICAgICAgICBtYXRyaXggPSBtdWx0aXBseShtYXRyaXgsIGZhYnJpYy51dGlsLmNhbGNSb3RhdGVNYXRyaXgob3B0aW9ucykpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2NhbGVYICE9PSAxIHx8IG9wdGlvbnMuc2NhbGVZICE9PSAxIHx8XG4gICAgICAgICAgb3B0aW9ucy5za2V3WCB8fCBvcHRpb25zLnNrZXdZIHx8IG9wdGlvbnMuZmxpcFggfHwgb3B0aW9ucy5mbGlwWSkge1xuICAgICAgICBtYXRyaXggPSBtdWx0aXBseShtYXRyaXgsIGZhYnJpYy51dGlsLmNhbGNEaW1lbnNpb25zTWF0cml4KG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlc2V0IGFuIG9iamVjdCB0cmFuc2Zvcm0gc3RhdGUgdG8gbmV1dHJhbC4gVG9wIGFuZCBsZWZ0IGFyZSBub3QgYWNjb3VudGVkIGZvclxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXQgb2JqZWN0IHRvIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIHJlc2V0T2JqZWN0VHJhbnNmb3JtOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICB0YXJnZXQuc2NhbGVYID0gMTtcbiAgICAgIHRhcmdldC5zY2FsZVkgPSAxO1xuICAgICAgdGFyZ2V0LnNrZXdYID0gMDtcbiAgICAgIHRhcmdldC5za2V3WSA9IDA7XG4gICAgICB0YXJnZXQuZmxpcFggPSBmYWxzZTtcbiAgICAgIHRhcmdldC5mbGlwWSA9IGZhbHNlO1xuICAgICAgdGFyZ2V0LnJvdGF0ZSgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBPYmplY3QgdHJhbnNmb3JtIHZhbHVlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXQgb2JqZWN0IHRvIHJlYWQgZnJvbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ29tcG9uZW50cyBvZiB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICBzYXZlT2JqZWN0VHJhbnNmb3JtOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZVg6IHRhcmdldC5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGFyZ2V0LnNjYWxlWSxcbiAgICAgICAgc2tld1g6IHRhcmdldC5za2V3WCxcbiAgICAgICAgc2tld1k6IHRhcmdldC5za2V3WSxcbiAgICAgICAgYW5nbGU6IHRhcmdldC5hbmdsZSxcbiAgICAgICAgbGVmdDogdGFyZ2V0LmxlZnQsXG4gICAgICAgIGZsaXBYOiB0YXJnZXQuZmxpcFgsXG4gICAgICAgIGZsaXBZOiB0YXJnZXQuZmxpcFksXG4gICAgICAgIHRvcDogdGFyZ2V0LnRvcFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGNvbnRleHQgaGFzIHRyYW5zcGFyZW50IHBpeGVsXG4gICAgICogYXQgc3BlY2lmaWVkIGxvY2F0aW9uICh0YWtpbmcgdG9sZXJhbmNlIGludG8gYWNjb3VudClcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZVxuICAgICAqL1xuICAgIGlzVHJhbnNwYXJlbnQ6IGZ1bmN0aW9uKGN0eCwgeCwgeSwgdG9sZXJhbmNlKSB7XG5cbiAgICAgIC8vIElmIHRvbGVyYW5jZSBpcyA+IDAgYWRqdXN0IHN0YXJ0IGNvb3JkcyB0byB0YWtlIGludG8gYWNjb3VudC5cbiAgICAgIC8vIElmIG1vdmVzIG9mZiBDYW52YXMgZml4IHRvIDBcbiAgICAgIGlmICh0b2xlcmFuY2UgPiAwKSB7XG4gICAgICAgIGlmICh4ID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgeCAtPSB0b2xlcmFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgeCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICB5IC09IHRvbGVyYW5jZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX2lzVHJhbnNwYXJlbnQgPSB0cnVlLCBpLCB0ZW1wLFxuICAgICAgICAgIGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoeCwgeSwgKHRvbGVyYW5jZSAqIDIpIHx8IDEsICh0b2xlcmFuY2UgKiAyKSB8fCAxKSxcbiAgICAgICAgICBsID0gaW1hZ2VEYXRhLmRhdGEubGVuZ3RoO1xuXG4gICAgICAvLyBTcGxpdCBpbWFnZSBkYXRhIC0gZm9yIHRvbGVyYW5jZSA+IDEsIHBpeGVsRGF0YVNpemUgPSA0O1xuICAgICAgZm9yIChpID0gMzsgaSA8IGw7IGkgKz0gNCkge1xuICAgICAgICB0ZW1wID0gaW1hZ2VEYXRhLmRhdGFbaV07XG4gICAgICAgIF9pc1RyYW5zcGFyZW50ID0gdGVtcCA8PSAwO1xuICAgICAgICBpZiAoX2lzVHJhbnNwYXJlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7IC8vIFN0b3AgaWYgY29sb3VyIGZvdW5kXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW1hZ2VEYXRhID0gbnVsbDtcblxuICAgICAgcmV0dXJuIF9pc1RyYW5zcGFyZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBwcmVzZXJ2ZUFzcGVjdFJhdGlvIGF0dHJpYnV0ZSBmcm9tIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIHRvIGJlIHBhcnNlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxpZ24gYW5kIG1lZXRPclNsaWNlIGF0dHJpYnV0ZVxuICAgICAqL1xuICAgIHBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZTogZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gICAgICB2YXIgbWVldE9yU2xpY2UgPSAnbWVldCcsIGFsaWduWCA9ICdNaWQnLCBhbGlnblkgPSAnTWlkJyxcbiAgICAgICAgICBhc3BlY3RSYXRpb0F0dHJzID0gYXR0cmlidXRlLnNwbGl0KCcgJyksIGFsaWduO1xuXG4gICAgICBpZiAoYXNwZWN0UmF0aW9BdHRycyAmJiBhc3BlY3RSYXRpb0F0dHJzLmxlbmd0aCkge1xuICAgICAgICBtZWV0T3JTbGljZSA9IGFzcGVjdFJhdGlvQXR0cnMucG9wKCk7XG4gICAgICAgIGlmIChtZWV0T3JTbGljZSAhPT0gJ21lZXQnICYmIG1lZXRPclNsaWNlICE9PSAnc2xpY2UnKSB7XG4gICAgICAgICAgYWxpZ24gPSBtZWV0T3JTbGljZTtcbiAgICAgICAgICBtZWV0T3JTbGljZSA9ICdtZWV0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3BlY3RSYXRpb0F0dHJzLmxlbmd0aCkge1xuICAgICAgICAgIGFsaWduID0gYXNwZWN0UmF0aW9BdHRycy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9kaXZpZGUgYWxpZ24gaW4gYWxpZ25YIGFuZCBhbGlnbllcbiAgICAgIGFsaWduWCA9IGFsaWduICE9PSAnbm9uZScgPyBhbGlnbi5zbGljZSgxLCA0KSA6ICdub25lJztcbiAgICAgIGFsaWduWSA9IGFsaWduICE9PSAnbm9uZScgPyBhbGlnbi5zbGljZSg1LCA4KSA6ICdub25lJztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lZXRPclNsaWNlOiBtZWV0T3JTbGljZSxcbiAgICAgICAgYWxpZ25YOiBhbGlnblgsXG4gICAgICAgIGFsaWduWTogYWxpZ25ZXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBjaGFyIHdpZHRocyBjYWNoZSBmb3IgdGhlIGdpdmVuIGZvbnQgZmFtaWx5IG9yIGFsbCB0aGUgY2FjaGUgaWYgbm9cbiAgICAgKiBmb250RmFtaWx5IGlzIHNwZWNpZmllZC5cbiAgICAgKiBVc2UgaXQgaWYgeW91IGtub3cgeW91IGFyZSBsb2FkaW5nIGZvbnRzIGluIGEgbGF6eSB3YXkgYW5kIHlvdSBhcmUgbm90IHdhaXRpbmdcbiAgICAgKiBmb3IgY3VzdG9tIGZvbnRzIHRvIGxvYWQgcHJvcGVybHkgd2hlbiBhZGRpbmcgdGV4dCBvYmplY3RzIHRvIHRoZSBjYW52YXMuXG4gICAgICogSWYgYSB0ZXh0IG9iamVjdCBpcyBhZGRlZCB3aGVuIGl0cyBvd24gZm9udCBpcyBub3QgbG9hZGVkIHlldCwgeW91IHdpbGwgZ2V0IHdyb25nXG4gICAgICogbWVhc3VyZW1lbnQgYW5kIHNvIHdyb25nIGJvdW5kaW5nIGJveGVzLlxuICAgICAqIEFmdGVyIHRoZSBmb250IGNhY2hlIGlzIGNsZWFyZWQsIGVpdGhlciBjaGFuZ2UgdGhlIHRleHRPYmplY3QgdGV4dCBjb250ZW50IG9yIGNhbGxcbiAgICAgKiBpbml0RGltZW5zaW9ucygpIHRvIHRyaWdnZXIgYSByZWNhbGN1bGF0aW9uXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtmb250RmFtaWx5XSBmb250IGZhbWlseSB0byBjbGVhclxuICAgICAqL1xuICAgIGNsZWFyRmFicmljRm9udENhY2hlOiBmdW5jdGlvbihmb250RmFtaWx5KSB7XG4gICAgICBmb250RmFtaWx5ID0gKGZvbnRGYW1pbHkgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoIWZvbnRGYW1pbHkpIHtcbiAgICAgICAgZmFicmljLmNoYXJXaWR0aHNDYWNoZSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0pIHtcbiAgICAgICAgZGVsZXRlIGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGN1cnJlbnQgYXNwZWN0IHJhdGlvLCBkZXRlcm1pbmVzIHRoZSBtYXggd2lkdGggYW5kIGhlaWdodCB0aGF0IGNhblxuICAgICAqIHJlc3BlY3QgdGhlIHRvdGFsIGFsbG93ZWQgYXJlYSBmb3IgdGhlIGNhY2hlLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhciBhc3BlY3QgcmF0aW9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4aW11bUFyZWEgTWF4aW11bSBhcmVhIHlvdSB3YW50IHRvIGFjaGlldmVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3QueH0gTGltaXRlZCBkaW1lbnNpb25zIGJ5IFhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3QueX0gTGltaXRlZCBkaW1lbnNpb25zIGJ5IFlcbiAgICAgKi9cbiAgICBsaW1pdERpbXNCeUFyZWE6IGZ1bmN0aW9uKGFyLCBtYXhpbXVtQXJlYSkge1xuICAgICAgdmFyIHJvdWdoV2lkdGggPSBNYXRoLnNxcnQobWF4aW11bUFyZWEgKiBhciksXG4gICAgICAgICAgcGVyZkxpbWl0U2l6ZVkgPSBNYXRoLmZsb29yKG1heGltdW1BcmVhIC8gcm91Z2hXaWR0aCk7XG4gICAgICByZXR1cm4geyB4OiBNYXRoLmZsb29yKHJvdWdoV2lkdGgpLCB5OiBwZXJmTGltaXRTaXplWSB9O1xuICAgIH0sXG5cbiAgICBjYXBWYWx1ZTogZnVuY3Rpb24obWluLCB2YWx1ZSwgbWF4KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBzY2FsZSBmb3IgdGhlIG9iamVjdCBzb3VyY2UgdG8gZml0IGluc2lkZSB0aGUgb2JqZWN0IGRlc3RpbmF0aW9uLFxuICAgICAqIGtlZXBpbmcgYXNwZWN0IHJhdGlvIGludGFjdC5cbiAgICAgKiByZXNwZWN0IHRoZSB0b3RhbCBhbGxvd2VkIGFyZWEgZm9yIHRoZSBjYWNoZS5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdCB8IGZhYnJpYy5PYmplY3R9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2UuaGVpZ2h0IG5hdHVyYWwgdW5zY2FsZWQgaGVpZ2h0IG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlLndpZHRoIG5hdHVyYWwgdW5zY2FsZWQgd2lkdGggb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0IHwgZmFicmljLk9iamVjdH0gZGVzdGluYXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzdGluYXRpb24uaGVpZ2h0IG5hdHVyYWwgdW5zY2FsZWQgaGVpZ2h0IG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzdGluYXRpb24ud2lkdGggbmF0dXJhbCB1bnNjYWxlZCB3aWR0aCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBzY2FsZSBmYWN0b3IgdG8gYXBwbHkgdG8gc291cmNlIHRvIGZpdCBpbnRvIGRlc3RpbmF0aW9uXG4gICAgICovXG4gICAgZmluZFNjYWxlVG9GaXQ6IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihkZXN0aW5hdGlvbi53aWR0aCAvIHNvdXJjZS53aWR0aCwgZGVzdGluYXRpb24uaGVpZ2h0IC8gc291cmNlLmhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBzY2FsZSBmb3IgdGhlIG9iamVjdCBzb3VyY2UgdG8gY292ZXIgZW50aXJlbHkgdGhlIG9iamVjdCBkZXN0aW5hdGlvbixcbiAgICAgKiBrZWVwaW5nIGFzcGVjdCByYXRpbyBpbnRhY3QuXG4gICAgICogcmVzcGVjdCB0aGUgdG90YWwgYWxsb3dlZCBhcmVhIGZvciB0aGUgY2FjaGUuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3QgfCBmYWJyaWMuT2JqZWN0fSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlLmhlaWdodCBuYXR1cmFsIHVuc2NhbGVkIGhlaWdodCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZS53aWR0aCBuYXR1cmFsIHVuc2NhbGVkIHdpZHRoIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdCB8IGZhYnJpYy5PYmplY3R9IGRlc3RpbmF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc3RpbmF0aW9uLmhlaWdodCBuYXR1cmFsIHVuc2NhbGVkIGhlaWdodCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc3RpbmF0aW9uLndpZHRoIG5hdHVyYWwgdW5zY2FsZWQgd2lkdGggb2YgdGhlIG9iamVjdFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gc2NhbGUgZmFjdG9yIHRvIGFwcGx5IHRvIHNvdXJjZSB0byBjb3ZlciBkZXN0aW5hdGlvblxuICAgICAqL1xuICAgIGZpbmRTY2FsZVRvQ292ZXI6IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdGluYXRpb24pIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChkZXN0aW5hdGlvbi53aWR0aCAvIHNvdXJjZS53aWR0aCwgZGVzdGluYXRpb24uaGVpZ2h0IC8gc291cmNlLmhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdpdmVuIGFuIGFycmF5IG9mIDYgbnVtYmVyIHJldHVybnMgc29tZXRoaW5nIGxpa2UgYFwibWF0cml4KC4uLm51bWJlcnMpXCJgXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtIGFuIGFycmF5IHdpdGggNiBudW1iZXJzXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0cmFuc2Zvcm0gbWF0cml4IGZvciBzdmdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3QueX0gTGltaXRlZCBkaW1lbnNpb25zIGJ5IFlcbiAgICAgKi9cbiAgICBtYXRyaXhUb1NWRzogZnVuY3Rpb24odHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4gJ21hdHJpeCgnICsgdHJhbnNmb3JtLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFicmljLnV0aWwudG9GaXhlZCh2YWx1ZSwgZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTKTtcbiAgICAgIH0pLmpvaW4oJyAnKSArICcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2l2ZW4gYW4gb2JqZWN0IGFuZCBhIHRyYW5zZm9ybSwgYXBwbHkgdGhlIGludmVyc2UgdHJhbnNmb3JtIHRvIHRoZSBvYmplY3QsXG4gICAgICogdGhpcyBpcyBlcXVpdmFsZW50IHRvIHJlbW92ZSBmcm9tIHRoYXQgb2JqZWN0IHRoYXQgdHJhbnNmb3JtYXRpb24sIHNvIHRoYXRcbiAgICAgKiBhZGRlZCBpbiBhIHNwYWNlIHdpdGggdGhlIHJlbW92ZWQgdHJhbnNmb3JtLCB0aGUgb2JqZWN0IHdpbGwgYmUgdGhlIHNhbWUgYXMgYmVmb3JlLlxuICAgICAqIFJlbW92aW5nIGZyb20gYW4gb2JqZWN0IGEgdHJhbnNmb3JtIHRoYXQgc2NhbGUgYnkgMiBpcyBsaWtlIHNjYWxpbmcgaXQgYnkgMS8yLlxuICAgICAqIFJlbW92aW5nIGZyb20gYW4gb2JqZWN0IGEgdHJhbnNmcm9tIHRoYXQgcm90YXRlIGJ5IDMwZGVnIGlzIGxpa2Ugcm90YXRpbmcgYnkgMzBkZWdcbiAgICAgKiBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLlxuICAgICAqIFRoaXMgdXRpbCBpcyB1c2VkIHRvIGFkZCBvYmplY3RzIGluc2lkZSB0cmFuc2Zvcm1lZCBncm91cHMgb3IgbmVzdGVkIGdyb3Vwcy5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCB0aGUgb2JqZWN0IHlvdSB3YW50IHRvIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybSB0aGUgZGVzdGluYXRpb24gdHJhbnNmb3JtXG4gICAgICovXG4gICAgcmVtb3ZlVHJhbnNmb3JtRnJvbU9iamVjdDogZnVuY3Rpb24ob2JqZWN0LCB0cmFuc2Zvcm0pIHtcbiAgICAgIHZhciBpbnZlcnRlZCA9IGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybSh0cmFuc2Zvcm0pLFxuICAgICAgICAgIGZpbmFsVHJhbnNmb3JtID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhpbnZlcnRlZCwgb2JqZWN0LmNhbGNPd25NYXRyaXgoKSk7XG4gICAgICBmYWJyaWMudXRpbC5hcHBseVRyYW5zZm9ybVRvT2JqZWN0KG9iamVjdCwgZmluYWxUcmFuc2Zvcm0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnaXZlbiBhbiBvYmplY3QgYW5kIGEgdHJhbnNmb3JtLCBhcHBseSB0aGUgdHJhbnNmb3JtIHRvIHRoZSBvYmplY3QuXG4gICAgICogdGhpcyBpcyBlcXVpdmFsZW50IHRvIGNoYW5nZSB0aGUgc3BhY2Ugd2hlcmUgdGhlIG9iamVjdCBpcyBkcmF3bi5cbiAgICAgKiBBZGRpbmcgdG8gYW4gb2JqZWN0IGEgdHJhbnNmb3JtIHRoYXQgc2NhbGUgYnkgMiBpcyBsaWtlIHNjYWxpbmcgaXQgYnkgMi5cbiAgICAgKiBUaGlzIGlzIHVzZWQgd2hlbiByZW1vdmluZyBhbiBvYmplY3QgZnJvbSBhbiBhY3RpdmUgc2VsZWN0aW9uIGZvciBleGFtcGxlLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IHRoZSBvYmplY3QgeW91IHdhbnQgdG8gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtIHRoZSBkZXN0aW5hdGlvbiB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICBhZGRUcmFuc2Zvcm1Ub09iamVjdDogZnVuY3Rpb24ob2JqZWN0LCB0cmFuc2Zvcm0pIHtcbiAgICAgIGZhYnJpYy51dGlsLmFwcGx5VHJhbnNmb3JtVG9PYmplY3QoXG4gICAgICAgIG9iamVjdCxcbiAgICAgICAgZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyh0cmFuc2Zvcm0sIG9iamVjdC5jYWxjT3duTWF0cml4KCkpXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkaXNjYXJkIGFuIG9iamVjdCB0cmFuc2Zvcm0gc3RhdGUgYW5kIGFwcGx5IHRoZSBvbmUgZnJvbSB0aGUgbWF0cml4LlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IHRoZSBvYmplY3QgeW91IHdhbnQgdG8gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtIHRoZSBkZXN0aW5hdGlvbiB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICBhcHBseVRyYW5zZm9ybVRvT2JqZWN0OiBmdW5jdGlvbihvYmplY3QsIHRyYW5zZm9ybSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5xckRlY29tcG9zZSh0cmFuc2Zvcm0pLFxuICAgICAgICAgIGNlbnRlciA9IG5ldyBmYWJyaWMuUG9pbnQob3B0aW9ucy50cmFuc2xhdGVYLCBvcHRpb25zLnRyYW5zbGF0ZVkpO1xuICAgICAgb2JqZWN0LmZsaXBYID0gZmFsc2U7XG4gICAgICBvYmplY3QuZmxpcFkgPSBmYWxzZTtcbiAgICAgIG9iamVjdC5zZXQoJ3NjYWxlWCcsIG9wdGlvbnMuc2NhbGVYKTtcbiAgICAgIG9iamVjdC5zZXQoJ3NjYWxlWScsIG9wdGlvbnMuc2NhbGVZKTtcbiAgICAgIG9iamVjdC5za2V3WCA9IG9wdGlvbnMuc2tld1g7XG4gICAgICBvYmplY3Quc2tld1kgPSBvcHRpb25zLnNrZXdZO1xuICAgICAgb2JqZWN0LmFuZ2xlID0gb3B0aW9ucy5hbmdsZTtcbiAgICAgIG9iamVjdC5zZXRQb3NpdGlvbkJ5T3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2l2ZW4gYSB3aWR0aCBhbmQgaGVpZ2h0LCByZXR1cm4gdGhlIHNpemUgb2YgdGhlIGJvdW5kaW5nIGJveFxuICAgICAqIHRoYXQgY2FuIGNvbnRhaW5zIHRoZSBib3ggd2l0aCB3aWR0aC9oZWlnaHQgd2l0aCBhcHBsaWVkIHRyYW5zZm9ybVxuICAgICAqIGRlc2NyaWJlZCBpbiBvcHRpb25zLlxuICAgICAqIFVzZSB0byBjYWxjdWxhdGUgdGhlIGJveGVzIGFyb3VuZCBvYmplY3RzIGZvciBjb250cm9scy5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zY2FsZVhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5zY2FsZVlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5za2V3WFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNrZXdZXG4gICAgICogQHJldHVybiB7T2JqZWN0Lnh9IHdpZHRoIG9mIGNvbnRhaW5pbmdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3QueX0gaGVpZ2h0IG9mIGNvbnRhaW5pbmdcbiAgICAgKi9cbiAgICBzaXplQWZ0ZXJUcmFuc2Zvcm06IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBkaW1YID0gd2lkdGggLyAyLCBkaW1ZID0gaGVpZ2h0IC8gMixcbiAgICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IC1kaW1YLFxuICAgICAgICAgICAgICB5OiAtZGltWVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogZGltWCxcbiAgICAgICAgICAgICAgeTogLWRpbVlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IC1kaW1YLFxuICAgICAgICAgICAgICB5OiBkaW1ZXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBkaW1YLFxuICAgICAgICAgICAgICB5OiBkaW1ZXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICB0cmFuc2Zvcm1NYXRyaXggPSBmYWJyaWMudXRpbC5jYWxjRGltZW5zaW9uc01hdHJpeChvcHRpb25zKSxcbiAgICAgICAgICBiYm94ID0gZmFicmljLnV0aWwubWFrZUJvdW5kaW5nQm94RnJvbVBvaW50cyhwb2ludHMsIHRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYm94LndpZHRoLFxuICAgICAgICB5OiBiYm94LmhlaWdodCxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyAyIGNsaXAgcGF0aHMgaW50byBvbmUgdmlzdWFsbHkgZXF1YWwgY2xpcCBwYXRoXG4gICAgICpcbiAgICAgKiAqKklNUE9SVEFOVCoqOlxcXG4gICAgICogRG9lcyAqKk5PVCoqIGNsb25lIHRoZSBhcmd1bWVudHMsIGNsb25lIHRoZW0gcHJvaXIgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIHdyYXBwZXIgKGdyb3VwKSB0aGF0IGNvbnRhaW5zIG9uZSBjbGlwIHBhdGggYW5kIGlzIGNsaXBwZWQgYnkgdGhlIG90aGVyIHNvIGNvbnRlbnQgaXMga2VwdCB3aGVyZSBib3RoIG92ZXJsYXAuXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIGlmIGJvdGggdGhlIGNsaXAgcGF0aHMgbWF5IGhhdmUgbmVzdGVkIGNsaXAgcGF0aHMgb2YgdGhlaXIgb3duLCBzbyBhc3NpZ25pbmcgb25lIHRvIHRoZSBvdGhlcidzIGNsaXAgcGF0aCBwcm9wZXJ0eSBpcyBub3QgcG9zc2libGUuXG4gICAgICpcbiAgICAgKiBJbiBvcmRlciB0byBoYW5kbGUgdGhlIGBpbnZlcnRlZGAgcHJvcGVydHkgd2UgZm9sbG93IGxvZ2ljIGRlc2NyaWJlZCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxcXG4gICAgICogKiooMSkqKiBib3RoIGNsaXAgcGF0aHMgYXJlIGludmVydGVkIC0gdGhlIGNsaXAgcGF0aHMgcGFzcyB0aGUgaW52ZXJ0ZWQgcHJvcCB0byB0aGUgd3JhcHBlciBhbmQgbG9vc2UgaXQgdGhlbXNlbHZlcy5cXFxuICAgICAqICoqKDIpKiogb25lIGlzIGludmVydGVkIGFuZCB0aGUgb3RoZXIgaXNuJ3QgLSB0aGUgd3JhcHBlciBzaG91bGRuJ3QgYmVjb21lIGludmVydGVkIGFuZCB0aGUgaW52ZXJ0ZWQgY2xpcCBwYXRoIG11c3QgY2xpcCB0aGUgbm9uIGludmVydGVkIG9uZSB0byBwcm9kdWNlIGFuIGlkZW50aWNhbCB2aXN1YWwgZWZmZWN0LlxcXG4gICAgICogKiooMykqKiBib3RoIGNsaXAgcGF0aHMgYXJlIG5vdCBpbnZlcnRlZCAtIHdyYXBwZXIgYW5kIGNsaXAgcGF0aHMgcmVtYWluIHVuY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gYzFcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGMyXG4gICAgICogQHJldHVybnMge2ZhYnJpYy5PYmplY3R9IG1lcmdlZCBjbGlwIHBhdGhcbiAgICAgKi9cbiAgICBtZXJnZUNsaXBQYXRoczogZnVuY3Rpb24gKGMxLCBjMikge1xuICAgICAgdmFyIGEgPSBjMSwgYiA9IGMyO1xuICAgICAgaWYgKGEuaW52ZXJ0ZWQgJiYgIWIuaW52ZXJ0ZWQpIHtcbiAgICAgICAgLy8gIGNhc2UgKDIpXG4gICAgICAgIGEgPSBjMjtcbiAgICAgICAgYiA9IGMxO1xuICAgICAgfVxuICAgICAgLy8gIGBiYCBiZWNvbWVzIGBhYCdzIGNsaXAgcGF0aCBzbyB3ZSB0cmFuc2Zvcm0gYGJgIHRvIGBhYCBjb29yZGluYXRlIHBsYW5lXG4gICAgICBmYWJyaWMudXRpbC5hcHBseVRyYW5zZm9ybVRvT2JqZWN0KFxuICAgICAgICBiLFxuICAgICAgICBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKFxuICAgICAgICAgIGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybShhLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSksXG4gICAgICAgICAgYi5jYWxjVHJhbnNmb3JtTWF0cml4KClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIC8vICBhc3NpZ24gdGhlIGBpbnZlcnRlZGAgcHJvcCB0byB0aGUgd3JhcHBpbmcgZ3JvdXBcbiAgICAgIHZhciBpbnZlcnRlZCA9IGEuaW52ZXJ0ZWQgJiYgYi5pbnZlcnRlZDtcbiAgICAgIGlmIChpbnZlcnRlZCkge1xuICAgICAgICAvLyAgY2FzZSAoMSlcbiAgICAgICAgYS5pbnZlcnRlZCA9IGIuaW52ZXJ0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZmFicmljLkdyb3VwKFthXSwgeyBjbGlwUGF0aDogYiwgaW52ZXJ0ZWQ6IGludmVydGVkIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJldlN0eWxlIGZpcnN0IHN0eWxlIHRvIGNvbXBhcmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhpc1N0eWxlIHNlY29uZCBzdHlsZSB0byBjb21wYXJlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JUZXh0U3BhbnMgd2hldGhlciB0byBjaGVjayBvdmVybGluZSwgdW5kZXJsaW5lLCBhbmQgbGluZS10aHJvdWdoIHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBzdHlsZSBjaGFuZ2VkXG4gICAgICovXG4gICAgaGFzU3R5bGVDaGFuZ2VkOiBmdW5jdGlvbihwcmV2U3R5bGUsIHRoaXNTdHlsZSwgZm9yVGV4dFNwYW5zKSB7XG4gICAgICBmb3JUZXh0U3BhbnMgPSBmb3JUZXh0U3BhbnMgfHwgZmFsc2U7XG4gICAgICByZXR1cm4gKHByZXZTdHlsZS5maWxsICE9PSB0aGlzU3R5bGUuZmlsbCB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuc3Ryb2tlICE9PSB0aGlzU3R5bGUuc3Ryb2tlIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5zdHJva2VXaWR0aCAhPT0gdGhpc1N0eWxlLnN0cm9rZVdpZHRoIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250U2l6ZSAhPT0gdGhpc1N0eWxlLmZvbnRTaXplIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250RmFtaWx5ICE9PSB0aGlzU3R5bGUuZm9udEZhbWlseSB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZm9udFdlaWdodCAhPT0gdGhpc1N0eWxlLmZvbnRXZWlnaHQgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRTdHlsZSAhPT0gdGhpc1N0eWxlLmZvbnRTdHlsZSB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUudGV4dEJhY2tncm91bmRDb2xvciAhPT0gdGhpc1N0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmRlbHRhWSAhPT0gdGhpc1N0eWxlLmRlbHRhWSkgfHxcbiAgICAgICAgICAgICAgKGZvclRleHRTcGFucyAmJlxuICAgICAgICAgICAgICAgIChwcmV2U3R5bGUub3ZlcmxpbmUgIT09IHRoaXNTdHlsZS5vdmVybGluZSB8fFxuICAgICAgICAgICAgICAgIHByZXZTdHlsZS51bmRlcmxpbmUgIT09IHRoaXNTdHlsZS51bmRlcmxpbmUgfHxcbiAgICAgICAgICAgICAgICBwcmV2U3R5bGUubGluZXRocm91Z2ggIT09IHRoaXNTdHlsZS5saW5ldGhyb3VnaCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcnJheSBmb3JtIG9mIGEgdGV4dCBvYmplY3QncyBpbmxpbmUgc3R5bGVzIHByb3BlcnR5IHdpdGggc3R5bGVzIGdyb3VwZWQgaW4gcmFuZ2VzXG4gICAgICogcmF0aGVyIHRoYW4gcGVyIGNoYXJhY3Rlci4gVGhpcyBmb3JtYXQgaXMgbGVzcyB2ZXJib3NlLCBhbmQgaXMgYmV0dGVyIHN1aXRlZCBmb3Igc3RvcmFnZVxuICAgICAqIHNvIGl0IGlzIHVzZWQgaW4gc2VyaWFsaXphdGlvbiAobm90IGR1cmluZyBydW50aW1lKS5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzIHBlciBjaGFyYWN0ZXIgc3R5bGVzIGZvciBhIHRleHQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGhlIHRleHQgc3RyaW5nIHRoYXQgdGhlIHN0eWxlcyBhcmUgYXBwbGllZCB0b1xuICAgICAqIEByZXR1cm4ge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgc3R5bGU6IG9iamVjdH1bXX1cbiAgICAgKi9cbiAgICBzdHlsZXNUb0FycmF5OiBmdW5jdGlvbihzdHlsZXMsIHRleHQpIHtcbiAgICAgIC8vIGNsb25lIHN0eWxlIHN0cnVjdHVyZSB0byBwcmV2ZW50IG11dGF0aW9uXG4gICAgICB2YXIgc3R5bGVzID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKHN0eWxlcywgdHJ1ZSksXG4gICAgICAgICAgdGV4dExpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyksXG4gICAgICAgICAgY2hhckluZGV4ID0gLTEsIHByZXZTdHlsZSA9IHt9LCBzdHlsZXNBcnJheSA9IFtdO1xuICAgICAgLy9sb29wIHRocm91Z2ggZWFjaCB0ZXh0TGluZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFzdHlsZXNbaV0pIHtcbiAgICAgICAgICAvL25vIHN0eWxlcyBleGlzdCBmb3IgdGhpcyBsaW5lLCBzbyBhZGQgdGhlIGxpbmUncyBsZW5ndGggdG8gdGhlIGNoYXJJbmRleCB0b3RhbFxuICAgICAgICAgIGNoYXJJbmRleCArPSB0ZXh0TGluZXNbaV0ubGVuZ3RoO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vbG9vcCB0aHJvdWdoIGVhY2ggY2hhcmFjdGVyIG9mIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB0ZXh0TGluZXNbaV0ubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICBjaGFySW5kZXgrKztcbiAgICAgICAgICB2YXIgdGhpc1N0eWxlID0gc3R5bGVzW2ldW2NdO1xuICAgICAgICAgIC8vY2hlY2sgaWYgc3R5bGUgZXhpc3RzIGZvciB0aGlzIGNoYXJhY3RlclxuICAgICAgICAgIGlmICh0aGlzU3R5bGUgJiYgT2JqZWN0LmtleXModGhpc1N0eWxlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVDaGFuZ2VkID0gZmFicmljLnV0aWwuaGFzU3R5bGVDaGFuZ2VkKHByZXZTdHlsZSwgdGhpc1N0eWxlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChzdHlsZUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgc3R5bGVzQXJyYXkucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGNoYXJJbmRleCxcbiAgICAgICAgICAgICAgICBlbmQ6IGNoYXJJbmRleCArIDEsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHRoaXNTdHlsZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvL2lmIHN0eWxlIGlzIHRoZSBzYW1lIGFzIHByZXZpb3VzIGNoYXJhY3RlciwgaW5jcmVhc2UgZW5kIGluZGV4XG4gICAgICAgICAgICAgIHN0eWxlc0FycmF5W3N0eWxlc0FycmF5Lmxlbmd0aCAtIDFdLmVuZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2U3R5bGUgPSB0aGlzU3R5bGUgfHwge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZXNBcnJheTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb2JqZWN0IGZvcm0gb2YgdGhlIHN0eWxlcyBwcm9wZXJ0eSB3aXRoIHN0eWxlcyB0aGF0IGFyZSBhc3NpZ25lZCBwZXJcbiAgICAgKiBjaGFyYWN0ZXIgcmF0aGVyIHRoYW4gZ3JvdXBlZCBieSByYW5nZS4gVGhpcyBmb3JtYXQgaXMgbW9yZSB2ZXJib3NlLCBhbmQgaXNcbiAgICAgKiBvbmx5IHVzZWQgZHVyaW5nIHJ1bnRpbWUgKG5vdCBmb3Igc2VyaWFsaXphdGlvbi9zdG9yYWdlKVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHN0eWxlcyB0aGUgc2VyaWFsaXplZCBmb3JtIG9mIGEgdGV4dCBvYmplY3QncyBzdHlsZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0aGUgdGV4dCBzdHJpbmcgdGhhdCB0aGUgc3R5bGVzIGFyZSBhcHBsaWVkIHRvXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHN0eWxlc0Zyb21BcnJheTogZnVuY3Rpb24oc3R5bGVzLCB0ZXh0KSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3R5bGVzKSkge1xuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgfVxuICAgICAgdmFyIHRleHRMaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpLFxuICAgICAgICAgIGNoYXJJbmRleCA9IC0xLCBzdHlsZUluZGV4ID0gMCwgc3R5bGVzT2JqZWN0ID0ge307XG4gICAgICAvL2xvb3AgdGhyb3VnaCBlYWNoIHRleHRMaW5lXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvL2xvb3AgdGhyb3VnaCBlYWNoIGNoYXJhY3RlciBvZiB0aGUgY3VycmVudCBsaW5lXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgdGV4dExpbmVzW2ldLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgY2hhckluZGV4Kys7XG4gICAgICAgICAgLy9jaGVjayBpZiB0aGVyZSdzIGEgc3R5bGUgY29sbGVjdGlvbiB0aGF0IGluY2x1ZGVzIHRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgICAgICAgIGlmIChzdHlsZXNbc3R5bGVJbmRleF1cbiAgICAgICAgICAgICYmIHN0eWxlc1tzdHlsZUluZGV4XS5zdGFydCA8PSBjaGFySW5kZXhcbiAgICAgICAgICAgICYmIGNoYXJJbmRleCA8IHN0eWxlc1tzdHlsZUluZGV4XS5lbmQpIHtcbiAgICAgICAgICAgIC8vY3JlYXRlIG9iamVjdCBmb3IgbGluZSBpbmRleCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICBzdHlsZXNPYmplY3RbaV0gPSBzdHlsZXNPYmplY3RbaV0gfHwge307XG4gICAgICAgICAgICAvL2Fzc2lnbiBhIHN0eWxlIGF0IHRoaXMgY2hhcmFjdGVyJ3MgaW5kZXhcbiAgICAgICAgICAgIHN0eWxlc09iamVjdFtpXVtjXSA9IE9iamVjdC5hc3NpZ24oe30sIHN0eWxlc1tzdHlsZUluZGV4XS5zdHlsZSk7XG4gICAgICAgICAgICAvL2lmIGNoYXJhY3RlciBpcyBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHN0eWxlIGNvbGxlY3Rpb24sIG1vdmUgdG8gdGhlIG5leHRcbiAgICAgICAgICAgIGlmIChjaGFySW5kZXggPT09IHN0eWxlc1tzdHlsZUluZGV4XS5lbmQgLSAxKSB7XG4gICAgICAgICAgICAgIHN0eWxlSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZXNPYmplY3Q7XG4gICAgfVxuICB9O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIF9qb2luID0gQXJyYXkucHJvdG90eXBlLmpvaW4sXG4gICAgICBjb21tYW5kTGVuZ3RocyA9IHtcbiAgICAgICAgbTogMixcbiAgICAgICAgbDogMixcbiAgICAgICAgaDogMSxcbiAgICAgICAgdjogMSxcbiAgICAgICAgYzogNixcbiAgICAgICAgczogNCxcbiAgICAgICAgcTogNCxcbiAgICAgICAgdDogMixcbiAgICAgICAgYTogN1xuICAgICAgfSxcbiAgICAgIHJlcGVhdGVkQ29tbWFuZHMgPSB7XG4gICAgICAgIG06ICdsJyxcbiAgICAgICAgTTogJ0wnXG4gICAgICB9O1xuICBmdW5jdGlvbiBzZWdtZW50VG9CZXppZXIodGgyLCB0aDMsIGNvc1RoLCBzaW5UaCwgcngsIHJ5LCBjeDEsIGN5MSwgbVQsIGZyb21YLCBmcm9tWSkge1xuICAgIHZhciBjb3N0aDIgPSBmYWJyaWMudXRpbC5jb3ModGgyKSxcbiAgICAgICAgc2ludGgyID0gZmFicmljLnV0aWwuc2luKHRoMiksXG4gICAgICAgIGNvc3RoMyA9IGZhYnJpYy51dGlsLmNvcyh0aDMpLFxuICAgICAgICBzaW50aDMgPSBmYWJyaWMudXRpbC5zaW4odGgzKSxcbiAgICAgICAgdG9YID0gY29zVGggKiByeCAqIGNvc3RoMyAtIHNpblRoICogcnkgKiBzaW50aDMgKyBjeDEsXG4gICAgICAgIHRvWSA9IHNpblRoICogcnggKiBjb3N0aDMgKyBjb3NUaCAqIHJ5ICogc2ludGgzICsgY3kxLFxuICAgICAgICBjcDFYID0gZnJvbVggKyBtVCAqICggLWNvc1RoICogcnggKiBzaW50aDIgLSBzaW5UaCAqIHJ5ICogY29zdGgyKSxcbiAgICAgICAgY3AxWSA9IGZyb21ZICsgbVQgKiAoIC1zaW5UaCAqIHJ4ICogc2ludGgyICsgY29zVGggKiByeSAqIGNvc3RoMiksXG4gICAgICAgIGNwMlggPSB0b1ggKyBtVCAqICggY29zVGggKiByeCAqIHNpbnRoMyArIHNpblRoICogcnkgKiBjb3N0aDMpLFxuICAgICAgICBjcDJZID0gdG9ZICsgbVQgKiAoIHNpblRoICogcnggKiBzaW50aDMgLSBjb3NUaCAqIHJ5ICogY29zdGgzKTtcblxuICAgIHJldHVybiBbJ0MnLFxuICAgICAgY3AxWCwgY3AxWSxcbiAgICAgIGNwMlgsIGNwMlksXG4gICAgICB0b1gsIHRvWVxuICAgIF07XG4gIH1cblxuICAvKiBBZGFwdGVkIGZyb20gaHR0cDovL2R4ci5tb3ppbGxhLm9yZy9tb3ppbGxhLWNlbnRyYWwvc291cmNlL2NvbnRlbnQvc3ZnL2NvbnRlbnQvc3JjL25zU1ZHUGF0aERhdGFQYXJzZXIuY3BwXG4gICAqIGJ5IEFuZHJlYSBCb2dhenppIGNvZGUgaXMgdW5kZXIgTVBMLiBpZiB5b3UgZG9uJ3QgaGF2ZSBhIGNvcHkgb2YgdGhlIGxpY2Vuc2UgeW91IGNhbiB0YWtlIGl0IGhlcmVcbiAgICogaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvXG4gICAqL1xuICBmdW5jdGlvbiBhcmNUb1NlZ21lbnRzKHRvWCwgdG9ZLCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90YXRlWCkge1xuICAgIHZhciBQSSA9IE1hdGguUEksIHRoID0gcm90YXRlWCAqIFBJIC8gMTgwLFxuICAgICAgICBzaW5UaCA9IGZhYnJpYy51dGlsLnNpbih0aCksXG4gICAgICAgIGNvc1RoID0gZmFicmljLnV0aWwuY29zKHRoKSxcbiAgICAgICAgZnJvbVggPSAwLCBmcm9tWSA9IDA7XG5cbiAgICByeCA9IE1hdGguYWJzKHJ4KTtcbiAgICByeSA9IE1hdGguYWJzKHJ5KTtcblxuICAgIHZhciBweCA9IC1jb3NUaCAqIHRvWCAqIDAuNSAtIHNpblRoICogdG9ZICogMC41LFxuICAgICAgICBweSA9IC1jb3NUaCAqIHRvWSAqIDAuNSArIHNpblRoICogdG9YICogMC41LFxuICAgICAgICByeDIgPSByeCAqIHJ4LCByeTIgPSByeSAqIHJ5LCBweTIgPSBweSAqIHB5LCBweDIgPSBweCAqIHB4LFxuICAgICAgICBwbCA9IHJ4MiAqIHJ5MiAtIHJ4MiAqIHB5MiAtIHJ5MiAqIHB4MixcbiAgICAgICAgcm9vdCA9IDA7XG5cbiAgICBpZiAocGwgPCAwKSB7XG4gICAgICB2YXIgcyA9IE1hdGguc3FydCgxIC0gcGwgLyAocngyICogcnkyKSk7XG4gICAgICByeCAqPSBzO1xuICAgICAgcnkgKj0gcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByb290ID0gKGxhcmdlID09PSBzd2VlcCA/IC0xLjAgOiAxLjApICpcbiAgICAgICAgICAgICAgTWF0aC5zcXJ0KCBwbCAvIChyeDIgKiBweTIgKyByeTIgKiBweDIpKTtcbiAgICB9XG5cbiAgICB2YXIgY3ggPSByb290ICogcnggKiBweSAvIHJ5LFxuICAgICAgICBjeSA9IC1yb290ICogcnkgKiBweCAvIHJ4LFxuICAgICAgICBjeDEgPSBjb3NUaCAqIGN4IC0gc2luVGggKiBjeSArIHRvWCAqIDAuNSxcbiAgICAgICAgY3kxID0gc2luVGggKiBjeCArIGNvc1RoICogY3kgKyB0b1kgKiAwLjUsXG4gICAgICAgIG1UaGV0YSA9IGNhbGNWZWN0b3JBbmdsZSgxLCAwLCAocHggLSBjeCkgLyByeCwgKHB5IC0gY3kpIC8gcnkpLFxuICAgICAgICBkdGhldGEgPSBjYWxjVmVjdG9yQW5nbGUoKHB4IC0gY3gpIC8gcngsIChweSAtIGN5KSAvIHJ5LCAoLXB4IC0gY3gpIC8gcngsICgtcHkgLSBjeSkgLyByeSk7XG5cbiAgICBpZiAoc3dlZXAgPT09IDAgJiYgZHRoZXRhID4gMCkge1xuICAgICAgZHRoZXRhIC09IDIgKiBQSTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3dlZXAgPT09IDEgJiYgZHRoZXRhIDwgMCkge1xuICAgICAgZHRoZXRhICs9IDIgKiBQSTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGludG8gY3ViaWMgYmV6aWVyIHNlZ21lbnRzIDw9IDkwZGVnXG4gICAgdmFyIHNlZ21lbnRzID0gTWF0aC5jZWlsKE1hdGguYWJzKGR0aGV0YSAvIFBJICogMikpLFxuICAgICAgICByZXN1bHQgPSBbXSwgbURlbHRhID0gZHRoZXRhIC8gc2VnbWVudHMsXG4gICAgICAgIG1UID0gOCAvIDMgKiBNYXRoLnNpbihtRGVsdGEgLyA0KSAqIE1hdGguc2luKG1EZWx0YSAvIDQpIC8gTWF0aC5zaW4obURlbHRhIC8gMiksXG4gICAgICAgIHRoMyA9IG1UaGV0YSArIG1EZWx0YTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHM7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gc2VnbWVudFRvQmV6aWVyKG1UaGV0YSwgdGgzLCBjb3NUaCwgc2luVGgsIHJ4LCByeSwgY3gxLCBjeTEsIG1ULCBmcm9tWCwgZnJvbVkpO1xuICAgICAgZnJvbVggPSByZXN1bHRbaV1bNV07XG4gICAgICBmcm9tWSA9IHJlc3VsdFtpXVs2XTtcbiAgICAgIG1UaGV0YSA9IHRoMztcbiAgICAgIHRoMyArPSBtRGVsdGE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKlxuICAgKiBQcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjYWxjVmVjdG9yQW5nbGUodXgsIHV5LCB2eCwgdnkpIHtcbiAgICB2YXIgdGEgPSBNYXRoLmF0YW4yKHV5LCB1eCksXG4gICAgICAgIHRiID0gTWF0aC5hdGFuMih2eSwgdngpO1xuICAgIGlmICh0YiA+PSB0YSkge1xuICAgICAgcmV0dXJuIHRiIC0gdGE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIDIgKiBNYXRoLlBJIC0gKHRhIC0gdGIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYm91bmRpbmcgYm94IG9mIGEgYmV6aWVyY3VydmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgwIHN0YXJ0aW5nIHBvaW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuICAgKiBAcGFyYW0ge051bWJlcn0geDEgZmlyc3QgY29udHJvbCBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIHNlY29uZG8gY29udHJvbCBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0geTJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgzIGVuZCBvZiBiZXppZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkzXG4gICAqL1xuICAvLyB0YWtlbiBmcm9tIGh0dHA6Ly9qc2Jpbi5jb20vaXZvbWlxLzU2L2VkaXQgIG5vIGNyZWRpdHMgYXZhaWxhYmxlIGZvciB0aGF0LlxuICAvLyBUT0RPOiBjYW4gd2Ugbm9ybWFsaXplIHRoaXMgd2l0aCB0aGUgc3RhcnRpbmcgcG9pbnRzIHNldCBhdCAwIGFuZCB0aGVuIHRyYW5zbGF0ZWQgdGhlIGJib3g/XG4gIGZ1bmN0aW9uIGdldEJvdW5kc09mQ3VydmUoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgdmFyIGFyZ3NTdHJpbmc7XG4gICAgaWYgKGZhYnJpYy5jYWNoZXNCb3VuZHNPZkN1cnZlKSB7XG4gICAgICBhcmdzU3RyaW5nID0gX2pvaW4uY2FsbChhcmd1bWVudHMpO1xuICAgICAgaWYgKGZhYnJpYy5ib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ10pIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy5ib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ107XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgICAgIG1pbiA9IE1hdGgubWluLCBtYXggPSBNYXRoLm1heCxcbiAgICAgICAgYWJzID0gTWF0aC5hYnMsIHR2YWx1ZXMgPSBbXSxcbiAgICAgICAgYm91bmRzID0gW1tdLCBbXV0sXG4gICAgICAgIGEsIGIsIGMsIHQsIHQxLCB0MiwgYjJhYywgc3FydGIyYWM7XG5cbiAgICBiID0gNiAqIHgwIC0gMTIgKiB4MSArIDYgKiB4MjtcbiAgICBhID0gLTMgKiB4MCArIDkgKiB4MSAtIDkgKiB4MiArIDMgKiB4MztcbiAgICBjID0gMyAqIHgxIC0gMyAqIHgwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBiID0gNiAqIHkwIC0gMTIgKiB5MSArIDYgKiB5MjtcbiAgICAgICAgYSA9IC0zICogeTAgKyA5ICogeTEgLSA5ICogeTIgKyAzICogeTM7XG4gICAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhYnMoYSkgPCAxZS0xMikge1xuICAgICAgICBpZiAoYWJzKGIpIDwgMWUtMTIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0ID0gLWMgLyBiO1xuICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICB0dmFsdWVzLnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgICBpZiAoYjJhYyA8IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzcXJ0YjJhYyA9IHNxcnQoYjJhYyk7XG4gICAgICB0MSA9ICgtYiArIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgICAgfVxuICAgICAgdDIgPSAoLWIgLSBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgdHZhbHVlcy5wdXNoKHQyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgeCwgeSwgaiA9IHR2YWx1ZXMubGVuZ3RoLCBqbGVuID0gaiwgbXQ7XG4gICAgd2hpbGUgKGotLSkge1xuICAgICAgdCA9IHR2YWx1ZXNbal07XG4gICAgICBtdCA9IDEgLSB0O1xuICAgICAgeCA9IChtdCAqIG10ICogbXQgKiB4MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeDEpICsgKDMgKiBtdCAqIHQgKiB0ICogeDIpICsgKHQgKiB0ICogdCAqIHgzKTtcbiAgICAgIGJvdW5kc1swXVtqXSA9IHg7XG5cbiAgICAgIHkgPSAobXQgKiBtdCAqIG10ICogeTApICsgKDMgKiBtdCAqIG10ICogdCAqIHkxKSArICgzICogbXQgKiB0ICogdCAqIHkyKSArICh0ICogdCAqIHQgKiB5Myk7XG4gICAgICBib3VuZHNbMV1bal0gPSB5O1xuICAgIH1cblxuICAgIGJvdW5kc1swXVtqbGVuXSA9IHgwO1xuICAgIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuICAgIGJvdW5kc1swXVtqbGVuICsgMV0gPSB4MztcbiAgICBib3VuZHNbMV1bamxlbiArIDFdID0geTM7XG4gICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgIHtcbiAgICAgICAgeDogbWluLmFwcGx5KG51bGwsIGJvdW5kc1swXSksXG4gICAgICAgIHk6IG1pbi5hcHBseShudWxsLCBib3VuZHNbMV0pXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB4OiBtYXguYXBwbHkobnVsbCwgYm91bmRzWzBdKSxcbiAgICAgICAgeTogbWF4LmFwcGx5KG51bGwsIGJvdW5kc1sxXSlcbiAgICAgIH1cbiAgICBdO1xuICAgIGlmIChmYWJyaWMuY2FjaGVzQm91bmRzT2ZDdXJ2ZSkge1xuICAgICAgZmFicmljLmJvdW5kc09mQ3VydmVDYWNoZVthcmdzU3RyaW5nXSA9IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhcmMgdG8gYSBidW5jaCBvZiBiZXppZXIgY3VydmVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmeCBzdGFydGluZyBwb2ludCB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmeSBzdGFydGluZyBwb2ludCB5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkcyBBcmMgY29tbWFuZFxuICAgKi9cbiAgZnVuY3Rpb24gZnJvbUFyY1RvQmV6aWVycyhmeCwgZnksIGNvb3Jkcykge1xuICAgIHZhciByeCA9IGNvb3Jkc1sxXSxcbiAgICAgICAgcnkgPSBjb29yZHNbMl0sXG4gICAgICAgIHJvdCA9IGNvb3Jkc1szXSxcbiAgICAgICAgbGFyZ2UgPSBjb29yZHNbNF0sXG4gICAgICAgIHN3ZWVwID0gY29vcmRzWzVdLFxuICAgICAgICB0eCA9IGNvb3Jkc1s2XSxcbiAgICAgICAgdHkgPSBjb29yZHNbN10sXG4gICAgICAgIHNlZ3NOb3JtID0gYXJjVG9TZWdtZW50cyh0eCAtIGZ4LCB0eSAtIGZ5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWdzTm9ybS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2Vnc05vcm1baV1bMV0gKz0gZng7XG4gICAgICBzZWdzTm9ybVtpXVsyXSArPSBmeTtcbiAgICAgIHNlZ3NOb3JtW2ldWzNdICs9IGZ4O1xuICAgICAgc2Vnc05vcm1baV1bNF0gKz0gZnk7XG4gICAgICBzZWdzTm9ybVtpXVs1XSArPSBmeDtcbiAgICAgIHNlZ3NOb3JtW2ldWzZdICs9IGZ5O1xuICAgIH1cbiAgICByZXR1cm4gc2Vnc05vcm07XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gdGFrZSBhIHBhcnNlZCBTVkcgcGF0aCBhbmQgbWFrZSBpdCBzaW1wbGVyIGZvciBmYWJyaWNKUyBsb2dpYy5cbiAgICogc2ltcGxpZmljYXRpb24gY29uc2lzdCBvZjogb25seSBVUFBFUkNBU0UgYWJzb2x1dGUgY29tbWFuZHMgKCByZWxhdGl2ZSBjb252ZXJ0ZWQgdG8gYWJzb2x1dGUgKVxuICAgKiBTIGNvbnZlcnRlZCBpbiBDLCBUIGNvbnZlcnRlZCBpbiBRLCBBIGNvbnZlcnRlZCBpbiBDLlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIHRoZSBhcnJheSBvZiBjb21tYW5kcyBvZiBhIHBhcnNlZCBzdmcgcGF0aCBmb3IgZmFicmljLlBhdGhcbiAgICogQHJldHVybiB7QXJyYXl9IHRoZSBzaW1wbGlmaWVkIGFycmF5IG9mIGNvbW1hbmRzIG9mIGEgcGFyc2VkIHN2ZyBwYXRoIGZvciBmYWJyaWMuUGF0aFxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZVBhdGhTaW1wbGVyKHBhdGgpIHtcbiAgICAvLyB4IGFuZCB5IHJlcHJlc2VudCB0aGUgbGFzdCBwb2ludCBvZiB0aGUgcGF0aC4gdGhlIHByZXZpb3VzIGNvbW1hbmQgcG9pbnQuXG4gICAgLy8gd2UgYWRkIHRoZW0gdG8gZWFjaCByZWxhdGl2ZSBjb21tYW5kIHRvIG1ha2UgaXQgYW4gYWJzb2x1dGUgY29tbWVudC5cbiAgICAvLyB3ZSBhbHNvIHN3YXAgdGhlIHYgViBoIEggd2l0aCBMLCBiZWNhdXNlIGFyZSBlYXNpZXIgdG8gdHJhbnNmb3JtLlxuICAgIHZhciB4ID0gMCwgeSA9IDAsIGxlbiA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAvLyB4MSBhbmQgeTEgcmVwcmVzZW50IHRoZSBsYXN0IHBvaW50IG9mIHRoZSBzdWJwYXRoLiB0aGUgc3VicGF0aCBpcyBzdGFydGVkIHdpdGhcbiAgICAgICAgLy8gbSBvciBNIGNvbW1hbmQuIFdoZW4gYSB6IG9yIFogY29tbWFuZCBpcyBkcmF3biwgeCBhbmQgeSBuZWVkIHRvIGJlIHJlc2V0dGVkIHRvXG4gICAgICAgIC8vIHRoZSBsYXN0IHgxIGFuZCB5MS5cbiAgICAgICAgeDEgPSAwLCB5MSA9IDAsIGN1cnJlbnQsIGksIGNvbnZlcnRlZCxcbiAgICAgICAgLy8gcHJldmlvdXMgd2lsbCBob3N0IHRoZSBsZXR0ZXIgb2YgdGhlIHByZXZpb3VzIGNvbW1hbmQsIHRvIGhhbmRsZSBTIGFuZCBULlxuICAgICAgICAvLyBjb250cm9sWCBhbmQgY29udHJvbFkgd2lsbCBob3N0IHRoZSBwcmV2aW91cyByZWZsZWN0ZWQgY29udHJvbCBwb2ludFxuICAgICAgICBkZXN0aW5hdGlvblBhdGggPSBbXSwgcHJldmlvdXMsIGNvbnRyb2xYLCBjb250cm9sWTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnZlcnRlZCA9IGZhbHNlO1xuICAgICAgY3VycmVudCA9IHBhdGhbaV0uc2xpY2UoMCk7XG4gICAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy8gZmlyc3QgbGV0dGVyXG4gICAgICAgIGNhc2UgJ2wnOiAvLyBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFswXSA9ICdMJztcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHg7XG4gICAgICAgICAgY3VycmVudFsyXSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHg7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ0wnO1xuICAgICAgICAgIGN1cnJlbnRbMl0gPSB5O1xuICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd2JzogLy8gdmVydGljYWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnTCc7XG4gICAgICAgICAgeSA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgY3VycmVudFsxXSA9IHg7XG4gICAgICAgICAgY3VycmVudFsyXSA9IHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ20nOiAvLyBtb3ZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFswXSA9ICdNJztcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHg7XG4gICAgICAgICAgY3VycmVudFsyXSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgeDEgPSBjdXJyZW50WzFdO1xuICAgICAgICAgIHkxID0gY3VycmVudFsyXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYyc6IC8vIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFswXSA9ICdDJztcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHg7XG4gICAgICAgICAgY3VycmVudFsyXSArPSB5O1xuICAgICAgICAgIGN1cnJlbnRbM10gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzRdICs9IHk7XG4gICAgICAgICAgY3VycmVudFs1XSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbNl0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgICAgeSA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ1MnO1xuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzJdICs9IHk7XG4gICAgICAgICAgY3VycmVudFszXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbNF0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgIC8vIHdvdWxkIGJlIHNTY0MgYnV0IHNpbmNlIHdlIGFyZSBzd2FwcGluZyBzU2MgZm9yIEMsIHdlIGNoZWNrIGp1c3QgdGhhdC5cbiAgICAgICAgICBpZiAocHJldmlvdXMgPT09ICdDJykge1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBDLCBjLCBTLCBvciBzLFxuICAgICAgICAgICAgLy8gdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHggPSBjdXJyZW50WzNdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnQyc7XG4gICAgICAgICAgY3VycmVudFs1XSA9IGN1cnJlbnRbM107XG4gICAgICAgICAgY3VycmVudFs2XSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgY3VycmVudFszXSA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgY3VycmVudFs0XSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgY3VycmVudFsxXSA9IGNvbnRyb2xYO1xuICAgICAgICAgIGN1cnJlbnRbMl0gPSBjb250cm9sWTtcbiAgICAgICAgICAvLyBjdXJyZW50WzNdIGFuZCBjdXJyZW50WzRdIGFyZSBOT1cgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICAgICAgICAgIC8vIHdlIGtlZXAgaXQgZm9yIHRoZSBuZXh0IHJlZmxlY3Rpb24uXG4gICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFswXSA9ICdRJztcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHg7XG4gICAgICAgICAgY3VycmVudFsyXSArPSB5O1xuICAgICAgICAgIGN1cnJlbnRbM10gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzRdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIHggPSBjdXJyZW50WzNdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0JzogLy8gc2hvcnRoYW5kIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFswXSA9ICdUJztcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHg7XG4gICAgICAgICAgY3VycmVudFsyXSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgaWYgKHByZXZpb3VzID09PSAnUScpIHtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBRLCBxLCBUIG9yIHQsXG4gICAgICAgICAgICAvLyBhc3N1bWUgdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnUSc7XG4gICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgY3VycmVudFsxXSA9IGNvbnRyb2xYO1xuICAgICAgICAgIGN1cnJlbnRbMl0gPSBjb250cm9sWTtcbiAgICAgICAgICBjdXJyZW50WzNdID0geDtcbiAgICAgICAgICBjdXJyZW50WzRdID0geTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgY3VycmVudFswXSA9ICdBJztcbiAgICAgICAgICBjdXJyZW50WzZdICs9IHg7XG4gICAgICAgICAgY3VycmVudFs3XSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgY29udmVydGVkID0gdHJ1ZTtcbiAgICAgICAgICBkZXN0aW5hdGlvblBhdGggPSBkZXN0aW5hdGlvblBhdGguY29uY2F0KGZyb21BcmNUb0JlemllcnMoeCwgeSwgY3VycmVudCkpO1xuICAgICAgICAgIHggPSBjdXJyZW50WzZdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzddO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgeCA9IHgxO1xuICAgICAgICAgIHkgPSB5MTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICAgIGlmICghY29udmVydGVkKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uUGF0aC5wdXNoKGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMgPSBjdXJyZW50WzBdO1xuICAgIH1cbiAgICByZXR1cm4gZGVzdGluYXRpb25QYXRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxjIGxlbmd0aCBmcm9tIHBvaW50IHgxLHkxIHRvIHgyLHkyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MSBzdGFydGluZyBwb2ludCB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MSBzdGFydGluZyBwb2ludCB5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MiBzdGFydGluZyBwb2ludCB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MiBzdGFydGluZyBwb2ludCB5XG4gICAqIEByZXR1cm4ge051bWJlcn0gbGVuZ3RoIG9mIHNlZ21lbnRcbiAgICovXG4gIGZ1bmN0aW9uIGNhbGNMaW5lTGVuZ3RoKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICB9XG5cbiAgLy8gZnVuY3Rpb25zIGZvciB0aGUgQ3ViaWMgYmVpemVyXG4gIC8vIHRha2VuIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9rb252YWpzL2tvbnZhL2Jsb2IvNy4wLjUvc3JjL3NoYXBlcy9QYXRoLnRzI0wzNTBcbiAgZnVuY3Rpb24gQ0IxKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0O1xuICB9XG4gIGZ1bmN0aW9uIENCMih0KSB7XG4gICAgcmV0dXJuIDMgKiB0ICogdCAqICgxIC0gdCk7XG4gIH1cbiAgZnVuY3Rpb24gQ0IzKHQpIHtcbiAgICByZXR1cm4gMyAqIHQgKiAoMSAtIHQpICogKDEgLSB0KTtcbiAgfVxuICBmdW5jdGlvbiBDQjQodCkge1xuICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQb2ludE9uQ3ViaWNCZXppZXJJdGVyYXRvcihwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5LCBwNHgsIHA0eSkge1xuICAgIHJldHVybiBmdW5jdGlvbihwY3QpIHtcbiAgICAgIHZhciBjMSA9IENCMShwY3QpLCBjMiA9IENCMihwY3QpLCBjMyA9IENCMyhwY3QpLCBjNCA9IENCNChwY3QpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcDR4ICogYzEgKyBwM3ggKiBjMiArIHAyeCAqIGMzICsgcDF4ICogYzQsXG4gICAgICAgIHk6IHA0eSAqIGMxICsgcDN5ICogYzIgKyBwMnkgKiBjMyArIHAxeSAqIGM0XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUYW5nZW50Q3ViaWNJdGVyYXRvcihwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5LCBwNHgsIHA0eSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocGN0KSB7XG4gICAgICB2YXIgaW52VCA9IDEgLSBwY3QsXG4gICAgICAgICAgdGFuZ2VudFggPSAoMyAqIGludlQgKiBpbnZUICogKHAyeCAtIHAxeCkpICsgKDYgKiBpbnZUICogcGN0ICogKHAzeCAtIHAyeCkpICtcbiAgICAgICAgICAoMyAqIHBjdCAqIHBjdCAqIChwNHggLSBwM3gpKSxcbiAgICAgICAgICB0YW5nZW50WSA9ICgzICogaW52VCAqIGludlQgKiAocDJ5IC0gcDF5KSkgKyAoNiAqIGludlQgKiBwY3QgKiAocDN5IC0gcDJ5KSkgK1xuICAgICAgICAgICgzICogcGN0ICogcGN0ICogKHA0eSAtIHAzeSkpO1xuICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGFuZ2VudFksIHRhbmdlbnRYKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gUUIxKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG4gIH1cblxuICBmdW5jdGlvbiBRQjIodCkge1xuICAgIHJldHVybiAyICogdCAqICgxIC0gdCk7XG4gIH1cblxuICBmdW5jdGlvbiBRQjModCkge1xuICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBvaW50T25RdWFkcmF0aWNCZXppZXJJdGVyYXRvcihwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBjdCkge1xuICAgICAgdmFyIGMxID0gUUIxKHBjdCksIGMyID0gUUIyKHBjdCksIGMzID0gUUIzKHBjdCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwM3ggKiBjMSArIHAyeCAqIGMyICsgcDF4ICogYzMsXG4gICAgICAgIHk6IHAzeSAqIGMxICsgcDJ5ICogYzIgKyBwMXkgKiBjM1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGFuZ2VudFF1YWRyYXRpY0l0ZXJhdG9yKHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBjdCkge1xuICAgICAgdmFyIGludlQgPSAxIC0gcGN0LFxuICAgICAgICAgIHRhbmdlbnRYID0gKDIgKiBpbnZUICogKHAyeCAtIHAxeCkpICsgKDIgKiBwY3QgKiAocDN4IC0gcDJ4KSksXG4gICAgICAgICAgdGFuZ2VudFkgPSAoMiAqIGludlQgKiAocDJ5IC0gcDF5KSkgKyAoMiAqIHBjdCAqIChwM3kgLSBwMnkpKTtcbiAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRhbmdlbnRZLCB0YW5nZW50WCk7XG4gICAgfTtcbiAgfVxuXG5cbiAgLy8gdGhpcyB3aWxsIHJ1biBvdmVyIGEgcGF0aCBzZWdtZW50ICggYSBjdWJpYyBvciBxdWFkcmF0aWMgc2VnbWVudCkgYW5kIGFwcHJveGltYXRlIGl0XG4gIC8vIHdpdGggMTAwIHNlZ2VtbnRzLiBUaGlzIHdpbGwgZ29vZCBlbm91Z2ggdG8gY2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgdGhlIGN1cnZlXG4gIGZ1bmN0aW9uIHBhdGhJdGVyYXRvcihpdGVyYXRvciwgeDEsIHkxKSB7XG4gICAgdmFyIHRlbXBQID0geyB4OiB4MSwgeTogeTEgfSwgcCwgdG1wTGVuID0gMCwgcGVyYztcbiAgICBmb3IgKHBlcmMgPSAxOyBwZXJjIDw9IDEwMDsgcGVyYyArPSAxKSB7XG4gICAgICBwID0gaXRlcmF0b3IocGVyYyAvIDEwMCk7XG4gICAgICB0bXBMZW4gKz0gY2FsY0xpbmVMZW5ndGgodGVtcFAueCwgdGVtcFAueSwgcC54LCBwLnkpO1xuICAgICAgdGVtcFAgPSBwO1xuICAgIH1cbiAgICByZXR1cm4gdG1wTGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgcGF0aEluZm8sIGFuZCBhIGRpc3RhbmNlIGluIHBpeGVscywgZmluZCB0aGUgcGVyY2VudGFnZSBmcm9tIDAgdG8gMVxuICAgKiB0aGF0IGNvcnJlc3BvbmQgdG8gdGhhdCBwaXhlbHMgcnVuIG92ZXIgdGhlIHBhdGguXG4gICAqIFRoZSBwZXJjZW50YWdlIHdpbGwgYmUgdGhlbiB1c2VkIHRvIGZpbmQgdGhlIGNvcnJlY3QgcG9pbnQgb24gdGhlIGNhbnZhcyBmb3IgdGhlIHBhdGguXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNlZ0luZm8gZmFicmljSlMgY29sbGVjdGlvbiBvZiBpbmZvcm1hdGlvbiBvbiBhIHBhcnNlZCBwYXRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZSBmcm9tIHN0YXJ0aW5nIHBvaW50LCBpbiBwaXhlbHMuXG4gICAqIEByZXR1cm4ge09iamVjdH0gaW5mbyBvYmplY3Qgd2l0aCB4IGFuZCB5ICggdGhlIHBvaW50IG9uIGNhbnZhcyApIGFuZCBhbmdsZSwgdGhlIHRhbmdlbnQgb24gdGhhdCBwb2ludDtcbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRQZXJjZW50YWdlRm9yRGlzdGFuY2Uoc2VnSW5mbywgZGlzdGFuY2UpIHtcbiAgICB2YXIgcGVyYyA9IDAsIHRtcExlbiA9IDAsIGl0ZXJhdG9yID0gc2VnSW5mby5pdGVyYXRvciwgdGVtcFAgPSB7IHg6IHNlZ0luZm8ueCwgeTogc2VnSW5mby55IH0sXG4gICAgICAgIHAsIG5leHRMZW4sIG5leHRTdGVwID0gMC4wMSwgYW5nbGVGaW5kZXIgPSBzZWdJbmZvLmFuZ2xlRmluZGVyLCBsYXN0UGVyYztcbiAgICAvLyBuZXh0U3RlcCA+IDAuMDAwMSBjb3ZlcnMgMC4wMDAxNTYyNSB0aGF0IDEvNjR0aCBvZiAxLzEwMFxuICAgIC8vIHRoZSBwYXRoXG4gICAgd2hpbGUgKHRtcExlbiA8IGRpc3RhbmNlICYmIG5leHRTdGVwID4gMC4wMDAxKSB7XG4gICAgICBwID0gaXRlcmF0b3IocGVyYyk7XG4gICAgICBsYXN0UGVyYyA9IHBlcmM7XG4gICAgICBuZXh0TGVuID0gY2FsY0xpbmVMZW5ndGgodGVtcFAueCwgdGVtcFAueSwgcC54LCBwLnkpO1xuICAgICAgLy8gY29tcGFyZSB0bXBMZW4gZWFjaCBjeWNsZSB3aXRoIGRpc3RhbmNlLCBkZWNpZGUgbmV4dCBwZXJjIHRvIHRlc3QuXG4gICAgICBpZiAoKG5leHRMZW4gKyB0bXBMZW4pID4gZGlzdGFuY2UpIHtcbiAgICAgICAgLy8gd2UgZGlzY2FyZCB0aGlzIHN0ZXAgYW5kIHdlIG1ha2Ugc21hbGxlciBzdGVwcy5cbiAgICAgICAgcGVyYyAtPSBuZXh0U3RlcDtcbiAgICAgICAgbmV4dFN0ZXAgLz0gMjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0ZW1wUCA9IHA7XG4gICAgICAgIHBlcmMgKz0gbmV4dFN0ZXA7XG4gICAgICAgIHRtcExlbiArPSBuZXh0TGVuO1xuICAgICAgfVxuICAgIH1cbiAgICBwLmFuZ2xlID0gYW5nbGVGaW5kZXIobGFzdFBlcmMpO1xuICAgIHJldHVybiBwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBvdmVyIGEgcGFyc2VkIGFuZCBzaW1wbGlmZWQgcGF0aCBhbmQgZXh0cmFjIHNvbWUgaW5mb3JtYXRpb25zLlxuICAgKiBpbmZvcm1hdGlvbnMgYXJlIGxlbmd0aCBvZiBlYWNoIGNvbW1hbmQgYW5kIHN0YXJ0aW5nIHBvaW50XG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggZmFicmljSlMgcGFyc2VkIHBhdGggY29tbWFuZHNcbiAgICogQHJldHVybiB7QXJyYXl9IHBhdGggY29tbWFuZHMgaW5mb3JtYXRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBnZXRQYXRoU2VnbWVudHNJbmZvKHBhdGgpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSAwLCBsZW4gPSBwYXRoLmxlbmd0aCwgY3VycmVudCxcbiAgICAgICAgLy94MiBhbmQgeTIgYXJlIHRoZSBjb29yZHMgb2Ygc2VnbWVudCBzdGFydFxuICAgICAgICAvL3gxIGFuZCB5MSBhcmUgdGhlIGNvb3JkcyBvZiB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICB4MSA9IDAsIHkxID0gMCwgeDIgPSAwLCB5MiA9IDAsIGluZm8gPSBbXSwgaXRlcmF0b3IsIHRlbXBJbmZvLCBhbmdsZUZpbmRlcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjdXJyZW50ID0gcGF0aFtpXTtcbiAgICAgIHRlbXBJbmZvID0ge1xuICAgICAgICB4OiB4MSxcbiAgICAgICAgeTogeTEsXG4gICAgICAgIGNvbW1hbmQ6IGN1cnJlbnRbMF0sXG4gICAgICB9O1xuICAgICAgc3dpdGNoIChjdXJyZW50WzBdKSB7IC8vZmlyc3QgbGV0dGVyXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIHRlbXBJbmZvLmxlbmd0aCA9IDA7XG4gICAgICAgICAgeDIgPSB4MSA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgeTIgPSB5MSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgIHRlbXBJbmZvLmxlbmd0aCA9IGNhbGNMaW5lTGVuZ3RoKHgxLCB5MSwgY3VycmVudFsxXSwgY3VycmVudFsyXSk7XG4gICAgICAgICAgeDEgPSBjdXJyZW50WzFdO1xuICAgICAgICAgIHkxID0gY3VycmVudFsyXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgaXRlcmF0b3IgPSBnZXRQb2ludE9uQ3ViaWNCZXppZXJJdGVyYXRvcihcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICAgIGN1cnJlbnRbNl1cbiAgICAgICAgICApO1xuICAgICAgICAgIGFuZ2xlRmluZGVyID0gZ2V0VGFuZ2VudEN1YmljSXRlcmF0b3IoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICBjdXJyZW50WzZdXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0ZW1wSW5mby5pdGVyYXRvciA9IGl0ZXJhdG9yO1xuICAgICAgICAgIHRlbXBJbmZvLmFuZ2xlRmluZGVyID0gYW5nbGVGaW5kZXI7XG4gICAgICAgICAgdGVtcEluZm8ubGVuZ3RoID0gcGF0aEl0ZXJhdG9yKGl0ZXJhdG9yLCB4MSwgeTEpO1xuICAgICAgICAgIHgxID0gY3VycmVudFs1XTtcbiAgICAgICAgICB5MSA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgIGl0ZXJhdG9yID0gZ2V0UG9pbnRPblF1YWRyYXRpY0Jlemllckl0ZXJhdG9yKFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgIGN1cnJlbnRbNF1cbiAgICAgICAgICApO1xuICAgICAgICAgIGFuZ2xlRmluZGVyID0gZ2V0VGFuZ2VudFF1YWRyYXRpY0l0ZXJhdG9yKFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgIGN1cnJlbnRbNF1cbiAgICAgICAgICApO1xuICAgICAgICAgIHRlbXBJbmZvLml0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICAgICAgdGVtcEluZm8uYW5nbGVGaW5kZXIgPSBhbmdsZUZpbmRlcjtcbiAgICAgICAgICB0ZW1wSW5mby5sZW5ndGggPSBwYXRoSXRlcmF0b3IoaXRlcmF0b3IsIHgxLCB5MSk7XG4gICAgICAgICAgeDEgPSBjdXJyZW50WzNdO1xuICAgICAgICAgIHkxID0gY3VycmVudFs0XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnWic6XG4gICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgIC8vIHdlIGFkZCB0aG9zZSBpbiBvcmRlciB0byBlYXNlIGNhbGN1bGF0aW9ucyBsYXRlclxuICAgICAgICAgIHRlbXBJbmZvLmRlc3RYID0geDI7XG4gICAgICAgICAgdGVtcEluZm8uZGVzdFkgPSB5MjtcbiAgICAgICAgICB0ZW1wSW5mby5sZW5ndGggPSBjYWxjTGluZUxlbmd0aCh4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgICAgeDEgPSB4MjtcbiAgICAgICAgICB5MSA9IHkyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdG90YWxMZW5ndGggKz0gdGVtcEluZm8ubGVuZ3RoO1xuICAgICAgaW5mby5wdXNoKHRlbXBJbmZvKTtcbiAgICB9XG4gICAgaW5mby5wdXNoKHsgbGVuZ3RoOiB0b3RhbExlbmd0aCwgeDogeDEsIHk6IHkxIH0pO1xuICAgIHJldHVybiBpbmZvO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UG9pbnRPblBhdGgocGF0aCwgZGlzdGFuY2UsIGluZm9zKSB7XG4gICAgaWYgKCFpbmZvcykge1xuICAgICAgaW5mb3MgPSBnZXRQYXRoU2VnbWVudHNJbmZvKHBhdGgpO1xuICAgIH1cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKChkaXN0YW5jZSAtIGluZm9zW2ldLmxlbmd0aCA+IDApICYmIGkgPCAoaW5mb3MubGVuZ3RoIC0gMikpIHtcbiAgICAgIGRpc3RhbmNlIC09IGluZm9zW2ldLmxlbmd0aDtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgLy8gdmFyIGRpc3RhbmNlID0gaW5mb3NbaW5mb3MubGVuZ3RoIC0gMV0gKiBwZXJjO1xuICAgIHZhciBzZWdJbmZvID0gaW5mb3NbaV0sIHNlZ1BlcmNlbnQgPSBkaXN0YW5jZSAvIHNlZ0luZm8ubGVuZ3RoLFxuICAgICAgICBjb21tYW5kID0gc2VnSW5mby5jb21tYW5kLCBzZWdtZW50ID0gcGF0aFtpXSwgaW5mbztcblxuICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgY2FzZSAnTSc6XG4gICAgICAgIHJldHVybiB7IHg6IHNlZ0luZm8ueCwgeTogc2VnSW5mby55LCBhbmdsZTogMCB9O1xuICAgICAgY2FzZSAnWic6XG4gICAgICBjYXNlICd6JzpcbiAgICAgICAgaW5mbyA9IG5ldyBmYWJyaWMuUG9pbnQoc2VnSW5mby54LCBzZWdJbmZvLnkpLmxlcnAoXG4gICAgICAgICAgbmV3IGZhYnJpYy5Qb2ludChzZWdJbmZvLmRlc3RYLCBzZWdJbmZvLmRlc3RZKSxcbiAgICAgICAgICBzZWdQZXJjZW50XG4gICAgICAgICk7XG4gICAgICAgIGluZm8uYW5nbGUgPSBNYXRoLmF0YW4yKHNlZ0luZm8uZGVzdFkgLSBzZWdJbmZvLnksIHNlZ0luZm8uZGVzdFggLSBzZWdJbmZvLngpO1xuICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgIGNhc2UgJ0wnOlxuICAgICAgICBpbmZvID0gbmV3IGZhYnJpYy5Qb2ludChzZWdJbmZvLngsIHNlZ0luZm8ueSkubGVycChcbiAgICAgICAgICBuZXcgZmFicmljLlBvaW50KHNlZ21lbnRbMV0sIHNlZ21lbnRbMl0pLFxuICAgICAgICAgIHNlZ1BlcmNlbnRcbiAgICAgICAgKTtcbiAgICAgICAgaW5mby5hbmdsZSA9IE1hdGguYXRhbjIoc2VnbWVudFsyXSAtIHNlZ0luZm8ueSwgc2VnbWVudFsxXSAtIHNlZ0luZm8ueCk7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgY2FzZSAnQyc6XG4gICAgICAgIHJldHVybiBmaW5kUGVyY2VudGFnZUZvckRpc3RhbmNlKHNlZ0luZm8sIGRpc3RhbmNlKTtcbiAgICAgIGNhc2UgJ1EnOlxuICAgICAgICByZXR1cm4gZmluZFBlcmNlbnRhZ2VGb3JEaXN0YW5jZShzZWdJbmZvLCBkaXN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nXG4gICAqIEByZXR1cm4geyhzdHJpbmd8bnVtYmVyKVtdW119IEFuIGFycmF5IG9mIFNWRyBwYXRoIGNvbW1hbmRzXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlVzYWdlPC9jYXB0aW9uPlxuICAgKiBwYXJzZVBhdGgoJ00gMyA0IFEgMyA1IDIgMSA0IDAgUSA5IDEyIDIgMSA0IDAnKSA9PT0gW1xuICAgKiAgIFsnTScsIDMsIDRdLFxuICAgKiAgIFsnUScsIDMsIDUsIDIsIDEsIDQsIDBdLFxuICAgKiAgIFsnUScsIDksIDEyLCAyLCAxLCA0LCAwXSxcbiAgICogXTtcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoU3RyaW5nKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICBjb29yZHMgPSBbXSxcbiAgICAgICAgY3VycmVudFBhdGgsXG4gICAgICAgIHBhcnNlZCxcbiAgICAgICAgcmUgPSBmYWJyaWMucmVQYXRoQ29tbWFuZCxcbiAgICAgICAgck51bWJlciA9ICdbLStdPyg/OlxcXFxkKlxcXFwuXFxcXGQrfFxcXFxkK1xcXFwuPykoPzpbZUVdWy0rXT9cXFxcZCspP1xcXFxzKicsXG4gICAgICAgIHJOdW1iZXJDb21tYVdzcCA9ICcoJyArIHJOdW1iZXIgKyAnKScgKyBmYWJyaWMuY29tbWFXc3AsXG4gICAgICAgIHJGbGFnQ29tbWFXc3AgPSAnKFswMV0pJyArIGZhYnJpYy5jb21tYVdzcCArICc/JyxcbiAgICAgICAgckFyY1NlcSA9IHJOdW1iZXJDb21tYVdzcCArICc/JyArIHJOdW1iZXJDb21tYVdzcCArICc/JyArIHJOdW1iZXJDb21tYVdzcCArIHJGbGFnQ29tbWFXc3AgKyByRmxhZ0NvbW1hV3NwICtcbiAgICAgICAgICByTnVtYmVyQ29tbWFXc3AgKyAnPygnICsgck51bWJlciArICcpJyxcbiAgICAgICAgcmVnQXJjQXJndW1lbnRTZXF1ZW5jZSA9IG5ldyBSZWdFeHAockFyY1NlcSwgJ2cnKSxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGNvb3Jkc1N0cixcbiAgICAgICAgLy8gb25lIG9mIGNvbW1hbmRzIChtLE0sbCxMLHEsUSxjLEMsZXRjLikgZm9sbG93ZWQgYnkgbm9uLWNvbW1hbmQgY2hhcmFjdGVycyAoaS5lLiBjb21tYW5kIHZhbHVlcylcbiAgICAgICAgcGF0aDtcbiAgICBpZiAoIXBhdGhTdHJpbmcgfHwgIXBhdGhTdHJpbmcubWF0Y2gpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHBhdGggPSBwYXRoU3RyaW5nLm1hdGNoKC9bbXpsaHZjc3F0YV1bXm16bGh2Y3NxdGFdKi9naSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgY29vcmRzUGFyc2VkLCBsZW4gPSBwYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjdXJyZW50UGF0aCA9IHBhdGhbaV07XG5cbiAgICAgIGNvb3Jkc1N0ciA9IGN1cnJlbnRQYXRoLnNsaWNlKDEpLnRyaW0oKTtcbiAgICAgIGNvb3Jkcy5sZW5ndGggPSAwO1xuXG4gICAgICB2YXIgY29tbWFuZCA9IGN1cnJlbnRQYXRoLmNoYXJBdCgwKTtcbiAgICAgIGNvb3Jkc1BhcnNlZCA9IFtjb21tYW5kXTtcblxuICAgICAgaWYgKGNvbW1hbmQudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICAgIC8vIGFyY3MgaGF2ZSBzcGVjaWFsIGZsYWdzIHRoYXQgYXBwYXJlbnRseSBkb24ndCByZXF1aXJlIHNwYWNlcyBzbyBoYW5kbGUgc3BlY2lhbFxuICAgICAgICBmb3IgKHZhciBhcmdzOyAoYXJncyA9IHJlZ0FyY0FyZ3VtZW50U2VxdWVuY2UuZXhlYyhjb29yZHNTdHIpKTspIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKGFyZ3Nbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGNvb3Jkc1N0cikpKSB7XG4gICAgICAgICAgY29vcmRzLnB1c2gobWF0Y2hbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gY29vcmRzLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICBwYXJzZWQgPSBwYXJzZUZsb2F0KGNvb3Jkc1tqXSk7XG4gICAgICAgIGlmICghaXNOYU4ocGFyc2VkKSkge1xuICAgICAgICAgIGNvb3Jkc1BhcnNlZC5wdXNoKHBhcnNlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvbW1hbmRMZW5ndGggPSBjb21tYW5kTGVuZ3Roc1tjb21tYW5kLnRvTG93ZXJDYXNlKCldLFxuICAgICAgICAgIHJlcGVhdGVkQ29tbWFuZCA9IHJlcGVhdGVkQ29tbWFuZHNbY29tbWFuZF0gfHwgY29tbWFuZDtcblxuICAgICAgaWYgKGNvb3Jkc1BhcnNlZC5sZW5ndGggLSAxID4gY29tbWFuZExlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBrID0gMSwga2xlbiA9IGNvb3Jkc1BhcnNlZC5sZW5ndGg7IGsgPCBrbGVuOyBrICs9IGNvbW1hbmRMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChbY29tbWFuZF0uY29uY2F0KGNvb3Jkc1BhcnNlZC5zbGljZShrLCBrICsgY29tbWFuZExlbmd0aCkpKTtcbiAgICAgICAgICBjb21tYW5kID0gcmVwZWF0ZWRDb21tYW5kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY29vcmRzUGFyc2VkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKlxuICAgKiBDb252ZXJ0cyBwb2ludHMgdG8gYSBzbW9vdGggU1ZHIHBhdGhcbiAgICogQHBhcmFtIHt7IHg6IG51bWJlcix5OiBudW1iZXIgfVtdfSBwb2ludHMgQXJyYXkgb2YgcG9pbnRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29ycmVjdGlvbl0gQXBwbHkgYSBjb3JyZWN0aW9uIHRvIHRoZSBwYXRoICh1c3VhbGx5IHdlIHVzZSBgd2lkdGggLyAxMDAwYCkuIElmIHZhbHVlIGlzIHVuZGVmaW5lZCAwIGlzIHVzZWQgYXMgdGhlIGNvcnJlY3Rpb24gdmFsdWUuXG4gICAqIEByZXR1cm4geyhzdHJpbmd8bnVtYmVyKVtdW119IEFuIGFycmF5IG9mIFNWRyBwYXRoIGNvbW1hbmRzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTbW9vdGhQYXRoRnJvbVBvaW50cyhwb2ludHMsIGNvcnJlY3Rpb24pIHtcbiAgICB2YXIgcGF0aCA9IFtdLCBpLFxuICAgICAgICBwMSA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzWzBdLngsIHBvaW50c1swXS55KSxcbiAgICAgICAgcDIgPSBuZXcgZmFicmljLlBvaW50KHBvaW50c1sxXS54LCBwb2ludHNbMV0ueSksXG4gICAgICAgIGxlbiA9IHBvaW50cy5sZW5ndGgsIG11bHRTaWduWCA9IDEsIG11bHRTaWduWSA9IDAsIG1hbnlQb2ludHMgPSBsZW4gPiAyO1xuICAgIGNvcnJlY3Rpb24gPSBjb3JyZWN0aW9uIHx8IDA7XG5cbiAgICBpZiAobWFueVBvaW50cykge1xuICAgICAgbXVsdFNpZ25YID0gcG9pbnRzWzJdLnggPCBwMi54ID8gLTEgOiBwb2ludHNbMl0ueCA9PT0gcDIueCA/IDAgOiAxO1xuICAgICAgbXVsdFNpZ25ZID0gcG9pbnRzWzJdLnkgPCBwMi55ID8gLTEgOiBwb2ludHNbMl0ueSA9PT0gcDIueSA/IDAgOiAxO1xuICAgIH1cbiAgICBwYXRoLnB1c2goWydNJywgcDEueCAtIG11bHRTaWduWCAqIGNvcnJlY3Rpb24sIHAxLnkgLSBtdWx0U2lnblkgKiBjb3JyZWN0aW9uXSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIXAxLmVxKHAyKSkge1xuICAgICAgICB2YXIgbWlkUG9pbnQgPSBwMS5taWRQb2ludEZyb20ocDIpO1xuICAgICAgICAvLyBwMSBpcyBvdXIgYmV6aWVyIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgLy8gbWlkcG9pbnQgaXMgb3VyIGVuZHBvaW50XG4gICAgICAgIC8vIHN0YXJ0IHBvaW50IGlzIHAoaS0xKSB2YWx1ZS5cbiAgICAgICAgcGF0aC5wdXNoKFsnUScsIHAxLngsIHAxLnksIG1pZFBvaW50LngsIG1pZFBvaW50LnldKTtcbiAgICAgIH1cbiAgICAgIHAxID0gcG9pbnRzW2ldO1xuICAgICAgaWYgKChpICsgMSkgPCBwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgIHAyID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hbnlQb2ludHMpIHtcbiAgICAgIG11bHRTaWduWCA9IHAxLnggPiBwb2ludHNbaSAtIDJdLnggPyAxIDogcDEueCA9PT0gcG9pbnRzW2kgLSAyXS54ID8gMCA6IC0xO1xuICAgICAgbXVsdFNpZ25ZID0gcDEueSA+IHBvaW50c1tpIC0gMl0ueSA/IDEgOiBwMS55ID09PSBwb2ludHNbaSAtIDJdLnkgPyAwIDogLTE7XG4gICAgfVxuICAgIHBhdGgucHVzaChbJ0wnLCBwMS54ICsgbXVsdFNpZ25YICogY29ycmVjdGlvbiwgcDEueSArIG11bHRTaWduWSAqIGNvcnJlY3Rpb25dKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICAvKipcbiAgICogVHJhbnNmb3JtIGEgcGF0aCBieSB0cmFuc2Zvcm1pbmcgZWFjaCBzZWdtZW50LlxuICAgKiBpdCBoYXMgdG8gYmUgYSBzaW1wbGlmaWVkIHBhdGggb3IgaXQgd29uJ3Qgd29yay5cbiAgICogV0FSTklORzogdGhpcyBkZXBlbmRzIGZyb20gcGF0aE9mZnNldCBmb3IgY29ycmVjdCBvcGVyYXRpb25cbiAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBmYWJyaWNKUyBwYXJzZWQgYW5kIHNpbXBsaWZpZWQgcGF0aCBjb21tYW5kc1xuICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm0gbWF0cml4IHRoYXQgcmVwcmVzZW50IHRoZSB0cmFuc2Zvcm1hdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhdGhPZmZzZXRdIHRoZSBmYWJyaWMuUGF0aCBwYXRoT2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXRoT2Zmc2V0LnhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhdGhPZmZzZXQueVxuICAgKiBAcmV0dXJucyB7QXJyYXl9IHRoZSB0cmFuc2Zvcm1lZCBwYXRoXG4gICAqL1xuICBmdW5jdGlvbiB0cmFuc2Zvcm1QYXRoKHBhdGgsIHRyYW5zZm9ybSwgcGF0aE9mZnNldCkge1xuICAgIGlmIChwYXRoT2Zmc2V0KSB7XG4gICAgICB0cmFuc2Zvcm0gPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKFxuICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgIFsxLCAwLCAwLCAxLCAtcGF0aE9mZnNldC54LCAtcGF0aE9mZnNldC55XVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGgubWFwKGZ1bmN0aW9uKHBhdGhTZWdtZW50KSB7XG4gICAgICB2YXIgbmV3U2VnbWVudCA9IHBhdGhTZWdtZW50LnNsaWNlKDApLCBwb2ludCA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwYXRoU2VnbWVudC5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgICAgcG9pbnQueCA9IHBhdGhTZWdtZW50W2ldO1xuICAgICAgICBwb2ludC55ID0gcGF0aFNlZ21lbnRbaSArIDFdO1xuICAgICAgICBwb2ludCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHBvaW50LCB0cmFuc2Zvcm0pO1xuICAgICAgICBuZXdTZWdtZW50W2ldID0gcG9pbnQueDtcbiAgICAgICAgbmV3U2VnbWVudFtpICsgMV0gPSBwb2ludC55O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1NlZ21lbnQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSm9pbiBwYXRoIGNvbW1hbmRzIHRvIGdvIGJhY2sgdG8gc3ZnIGZvcm1hdFxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoRGF0YSBmYWJyaWNKUyBwYXJzZWQgcGF0aCBjb21tYW5kc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGpvaW5lZCBwYXRoICdNIDAgMCBMIDIwIDMwJ1xuICAgKi9cbiAgZmFicmljLnV0aWwuam9pblBhdGggPSBmdW5jdGlvbihwYXRoRGF0YSkge1xuICAgIHJldHVybiBwYXRoRGF0YS5tYXAoZnVuY3Rpb24gKHNlZ21lbnQpIHsgcmV0dXJuIHNlZ21lbnQuam9pbignICcpOyB9KS5qb2luKCcgJyk7XG4gIH07XG4gIGZhYnJpYy51dGlsLnBhcnNlUGF0aCA9IHBhcnNlUGF0aDtcbiAgZmFicmljLnV0aWwubWFrZVBhdGhTaW1wbGVyID0gbWFrZVBhdGhTaW1wbGVyO1xuICBmYWJyaWMudXRpbC5nZXRTbW9vdGhQYXRoRnJvbVBvaW50cyA9IGdldFNtb290aFBhdGhGcm9tUG9pbnRzO1xuICBmYWJyaWMudXRpbC5nZXRQYXRoU2VnbWVudHNJbmZvID0gZ2V0UGF0aFNlZ21lbnRzSW5mbztcbiAgZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSA9IGdldEJvdW5kc09mQ3VydmU7XG4gIGZhYnJpYy51dGlsLmdldFBvaW50T25QYXRoID0gZ2V0UG9pbnRPblBhdGg7XG4gIGZhYnJpYy51dGlsLnRyYW5zZm9ybVBhdGggPSB0cmFuc2Zvcm1QYXRoO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBJbnZva2VzIG1ldGhvZCBvbiBhbGwgaXRlbXMgaW4gYSBnaXZlbiBhcnJheVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gaXRlcmF0ZSBvdmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTmFtZSBvZiBhIG1ldGhvZCB0byBpbnZva2VcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBmdW5jdGlvbiBpbnZva2UoYXJyYXksIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IGFyZ3MubGVuZ3RoID8gYXJyYXlbaV1bbWV0aG9kXS5hcHBseShhcnJheVtpXSwgYXJncykgOiBhcnJheVtpXVttZXRob2RdLmNhbGwoYXJyYXlbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIG1heGltdW0gdmFsdWUgaW4gYXJyYXkgKG5vdCBuZWNlc3NhcmlseSBcImZpcnN0XCIgb25lKVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gaXRlcmF0ZSBvdmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBieVByb3BlcnR5XG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBmdW5jdGlvbiBtYXgoYXJyYXksIGJ5UHJvcGVydHkpIHtcbiAgICByZXR1cm4gZmluZChhcnJheSwgYnlQcm9wZXJ0eSwgZnVuY3Rpb24odmFsdWUxLCB2YWx1ZTIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTEgPj0gdmFsdWUyO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIG1pbmltdW0gdmFsdWUgaW4gYXJyYXkgKG5vdCBuZWNlc3NhcmlseSBcImZpcnN0XCIgb25lKVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuYXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gaXRlcmF0ZSBvdmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBieVByb3BlcnR5XG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBmdW5jdGlvbiBtaW4oYXJyYXksIGJ5UHJvcGVydHkpIHtcbiAgICByZXR1cm4gZmluZChhcnJheSwgYnlQcm9wZXJ0eSwgZnVuY3Rpb24odmFsdWUxLCB2YWx1ZTIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTEgPCB2YWx1ZTI7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGZpbGwoYXJyYXksIHZhbHVlKSB7XG4gICAgdmFyIGsgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGstLSkge1xuICAgICAgYXJyYXlba10gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5kKGFycmF5LCBieVByb3BlcnR5LCBjb25kaXRpb24pIHtcbiAgICBpZiAoIWFycmF5IHx8IGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpID0gYXJyYXkubGVuZ3RoIC0gMSxcbiAgICAgICAgcmVzdWx0ID0gYnlQcm9wZXJ0eSA/IGFycmF5W2ldW2J5UHJvcGVydHldIDogYXJyYXlbaV07XG4gICAgaWYgKGJ5UHJvcGVydHkpIHtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihhcnJheVtpXVtieVByb3BlcnR5XSwgcmVzdWx0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGFycmF5W2ldW2J5UHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoY29uZGl0aW9uKGFycmF5W2ldLCByZXN1bHQpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLmFycmF5XG4gICAqL1xuICBmYWJyaWMudXRpbC5hcnJheSA9IHtcbiAgICBmaWxsOiBmaWxsLFxuICAgIGludm9rZTogaW52b2tlLFxuICAgIG1pbjogbWluLFxuICAgIG1heDogbWF4XG4gIH07XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogQ29waWVzIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygb25lIGpzIG9iamVjdCB0byBhbm90aGVyXG4gICAqIHRoaXMgZG9lcyBub3QgYW5kIGNhbm5vdCBjb21wZXRlIHdpdGggZ2VuZXJpYyB1dGlscy5cbiAgICogRG9lcyBub3QgY2xvbmUgb3IgZXh0ZW5kIGZhYnJpYy5PYmplY3Qgc3ViY2xhc3Nlcy5cbiAgICogVGhpcyBpcyBtb3N0bHkgZm9yIGludGVybmFsIHVzZSBhbmQgaGFzIGV4dHJhIGhhbmRsaW5nIGZvciBmYWJyaWNKUyBvYmplY3RzXG4gICAqIGl0IHNraXBzIHRoZSBjYW52YXMgYW5kIGdyb3VwIHByb3BlcnRpZXMgaW4gZGVlcCBjbG9uaW5nLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwub2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvbiBXaGVyZSB0byBjb3B5IHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgV2hlcmUgdG8gY29weSBmcm9tXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlZXBdIFdoZXRoZXIgdG8gZXh0ZW5kIG5lc3RlZCBvYmplY3RzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cbiAgZnVuY3Rpb24gZXh0ZW5kKGRlc3RpbmF0aW9uLCBzb3VyY2UsIGRlZXApIHtcbiAgICAvLyBKU2NyaXB0IERvbnRFbnVtIGJ1ZyBpcyBub3QgdGFrZW4gY2FyZSBvZlxuICAgIC8vIHRoZSBkZWVwIGNsb25lIGlzIGZvciBpbnRlcm5hbCB1c2UsIGlzIG5vdCBtZWFudCB0byBhdm9pZFxuICAgIC8vIGphdmFzY3JpcHQgdHJhcHMgb3IgY2xvbmluZyBodG1sIGVsZW1lbnQgb3Igc2VsZiByZWZlcmVuY2VkIG9iamVjdHMuXG4gICAgaWYgKGRlZXApIHtcbiAgICAgIGlmICghZmFicmljLmlzTGlrZWx5Tm9kZSAmJiBzb3VyY2UgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIC8vIGF2b2lkIGNsb25pbmcgZGVlcCBpbWFnZXMsIGNhbnZhc2VzLFxuICAgICAgICBkZXN0aW5hdGlvbiA9IHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGRlc3RpbmF0aW9uID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBkZXN0aW5hdGlvbltpXSA9IGV4dGVuZCh7IH0sIHNvdXJjZVtpXSwgZGVlcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNvdXJjZSAmJiB0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAocHJvcGVydHkgPT09ICdjYW52YXMnIHx8IHByb3BlcnR5ID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBjbG9uZSB0aGlzIHByb3BzIGF0IGFsbC5cbiAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8ga2VlcCB0aGUga2V5cyBpbiB0aGUgY29weVxuICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gZXh0ZW5kKHsgfSwgc291cmNlW3Byb3BlcnR5XSwgZGVlcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBzb3VuZHMgb2RkIGZvciBhbiBleHRlbmQgYnV0IGlzIG9rIGZvciByZWN1cnNpdmUgdXNlXG4gICAgICAgIGRlc3RpbmF0aW9uID0gc291cmNlO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdGluYXRpb247XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBlbXB0eSBvYmplY3QgYW5kIGNvcGllcyBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGFub3RoZXIgb2JqZWN0IHRvIGl0XG4gICAqIFRoaXMgbWV0aG9kIGlzIG1vc3RseSBmb3IgaW50ZXJuYWwgdXNlLCBhbmQgbm90IGludGVuZGVkIGZvciBkdXBsaWNhdGluZyBzaGFwZXMgaW4gY2FudmFzLiBcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLm9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjbG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZWVwXSBXaGV0aGVyIHRvIGNsb25lIG5lc3RlZCBvYmplY3RzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cbiAgLy9UT0RPOiB0aGlzIGZ1bmN0aW9uIHJldHVybiBhbiBlbXB0eSBvYmplY3QgaWYgeW91IHRyeSB0byBjbG9uZSBudWxsXG4gIGZ1bmN0aW9uIGNsb25lKG9iamVjdCwgZGVlcCkge1xuICAgIHJldHVybiBleHRlbmQoeyB9LCBvYmplY3QsIGRlZXApO1xuICB9XG5cbiAgLyoqIEBuYW1lc3BhY2UgZmFicmljLnV0aWwub2JqZWN0ICovXG4gIGZhYnJpYy51dGlsLm9iamVjdCA9IHtcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBjbG9uZTogY2xvbmVcbiAgfTtcbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMudXRpbCwgZmFicmljLk9ic2VydmFibGUpO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIENhbWVsaXplcyBhIHN0cmluZ1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGNhbWVsaXplXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQ2FtZWxpemVkIHZlcnNpb24gb2YgYSBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIGNhbWVsaXplKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvLSsoLik/L2csIGZ1bmN0aW9uKG1hdGNoLCBjaGFyYWN0ZXIpIHtcbiAgICAgIHJldHVybiBjaGFyYWN0ZXIgPyBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKSA6ICcnO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhcGl0YWxpemVzIGEgc3RyaW5nXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5zdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gY2FwaXRhbGl6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmaXJzdExldHRlck9ubHldIElmIHRydWUgb25seSBmaXJzdCBsZXR0ZXIgaXMgY2FwaXRhbGl6ZWRcbiAgICogYW5kIG90aGVyIGxldHRlcnMgc3RheSB1bnRvdWNoZWQsIGlmIGZhbHNlIGZpcnN0IGxldHRlciBpcyBjYXBpdGFsaXplZFxuICAgKiBhbmQgb3RoZXIgbGV0dGVycyBhcmUgY29udmVydGVkIHRvIGxvd2VyY2FzZS5cbiAgICogQHJldHVybiB7U3RyaW5nfSBDYXBpdGFsaXplZCB2ZXJzaW9uIG9mIGEgc3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZywgZmlyc3RMZXR0ZXJPbmx5KSB7XG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArXG4gICAgICAoZmlyc3RMZXR0ZXJPbmx5ID8gc3RyaW5nLnNsaWNlKDEpIDogc3RyaW5nLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzY2FwZXMgWE1MIGluIGEgc3RyaW5nXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5zdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gZXNjYXBlXG4gICAqIEByZXR1cm4ge1N0cmluZ30gRXNjYXBlZCB2ZXJzaW9uIG9mIGEgc3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiBlc2NhcGVYbWwoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgICAucmVwbGFjZSgvJy9nLCAnJmFwb3M7JylcbiAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG4gIH1cblxuICAvKipcbiAgICogRGl2aWRlIGEgc3RyaW5nIGluIHRoZSB1c2VyIHBlcmNlaXZlZCBzaW5nbGUgdW5pdHNcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dHN0cmluZyBTdHJpbmcgdG8gZXNjYXBlXG4gICAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBjb250YWluaW5nIHRoZSBncmFwaGVtZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdyYXBoZW1lU3BsaXQodGV4dHN0cmluZykge1xuICAgIHZhciBpID0gMCwgY2hyLCBncmFwaGVtZXMgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBjaHI7IGkgPCB0ZXh0c3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoKGNociA9IGdldFdob2xlQ2hhcih0ZXh0c3RyaW5nLCBpKSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZ3JhcGhlbWVzLnB1c2goY2hyKTtcbiAgICB9XG4gICAgcmV0dXJuIGdyYXBoZW1lcztcbiAgfVxuXG4gIC8vIHRha2VuIGZyb20gbWRuIGluIHRoZSBjaGFyQXQgZG9jIHBhZ2UuXG4gIGZ1bmN0aW9uIGdldFdob2xlQ2hhcihzdHIsIGkpIHtcbiAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGlzTmFOKGNvZGUpKSB7XG4gICAgICByZXR1cm4gJyc7IC8vIFBvc2l0aW9uIG5vdCBmb3VuZFxuICAgIH1cbiAgICBpZiAoY29kZSA8IDB4RDgwMCB8fCBjb2RlID4gMHhERkZGKSB7XG4gICAgICByZXR1cm4gc3RyLmNoYXJBdChpKTtcbiAgICB9XG5cbiAgICAvLyBIaWdoIHN1cnJvZ2F0ZSAoY291bGQgY2hhbmdlIGxhc3QgaGV4IHRvIDB4REI3RiB0byB0cmVhdCBoaWdoIHByaXZhdGVcbiAgICAvLyBzdXJyb2dhdGVzIGFzIHNpbmdsZSBjaGFyYWN0ZXJzKVxuICAgIGlmICgweEQ4MDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4REJGRikge1xuICAgICAgaWYgKHN0ci5sZW5ndGggPD0gKGkgKyAxKSkge1xuICAgICAgICB0aHJvdyAnSGlnaCBzdXJyb2dhdGUgd2l0aG91dCBmb2xsb3dpbmcgbG93IHN1cnJvZ2F0ZSc7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dCA9IHN0ci5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgIGlmICgweERDMDAgPiBuZXh0IHx8IG5leHQgPiAweERGRkYpIHtcbiAgICAgICAgdGhyb3cgJ0hpZ2ggc3Vycm9nYXRlIHdpdGhvdXQgZm9sbG93aW5nIGxvdyBzdXJyb2dhdGUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoaSkgKyBzdHIuY2hhckF0KGkgKyAxKTtcbiAgICB9XG4gICAgLy8gTG93IHN1cnJvZ2F0ZSAoMHhEQzAwIDw9IGNvZGUgJiYgY29kZSA8PSAweERGRkYpXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHRocm93ICdMb3cgc3Vycm9nYXRlIHdpdGhvdXQgcHJlY2VkaW5nIGhpZ2ggc3Vycm9nYXRlJztcbiAgICB9XG4gICAgdmFyIHByZXYgPSBzdHIuY2hhckNvZGVBdChpIC0gMSk7XG5cbiAgICAvLyAoY291bGQgY2hhbmdlIGxhc3QgaGV4IHRvIDB4REI3RiB0byB0cmVhdCBoaWdoIHByaXZhdGVcbiAgICAvLyBzdXJyb2dhdGVzIGFzIHNpbmdsZSBjaGFyYWN0ZXJzKVxuICAgIGlmICgweEQ4MDAgPiBwcmV2IHx8IHByZXYgPiAweERCRkYpIHtcbiAgICAgIHRocm93ICdMb3cgc3Vycm9nYXRlIHdpdGhvdXQgcHJlY2VkaW5nIGhpZ2ggc3Vycm9nYXRlJztcbiAgICB9XG4gICAgLy8gV2UgY2FuIHBhc3Mgb3ZlciBsb3cgc3Vycm9nYXRlcyBub3cgYXMgdGhlIHNlY29uZCBjb21wb25lbnRcbiAgICAvLyBpbiBhIHBhaXIgd2hpY2ggd2UgaGF2ZSBhbHJlYWR5IHByb2Nlc3NlZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFN0cmluZyB1dGlsaXRpZXNcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMudXRpbC5zdHJpbmdcbiAgICovXG4gIGZhYnJpYy51dGlsLnN0cmluZyA9IHtcbiAgICBjYW1lbGl6ZTogY2FtZWxpemUsXG4gICAgY2FwaXRhbGl6ZTogY2FwaXRhbGl6ZSxcbiAgICBlc2NhcGVYbWw6IGVzY2FwZVhtbCxcbiAgICBncmFwaGVtZVNwbGl0OiBncmFwaGVtZVNwbGl0XG4gIH07XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbigpIHsgfSxcblxuICAgICAgSVNfRE9OVEVOVU1fQlVHR1kgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4geyB0b1N0cmluZzogMSB9KSB7XG4gICAgICAgICAgaWYgKHAgPT09ICd0b1N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KSgpLFxuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgYWRkTWV0aG9kcyA9IGZ1bmN0aW9uKGtsYXNzLCBzb3VyY2UsIHBhcmVudCkge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcblxuICAgICAgICAgIGlmIChwcm9wZXJ0eSBpbiBrbGFzcy5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGtsYXNzLnByb3RvdHlwZVtwcm9wZXJ0eV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgKHNvdXJjZVtwcm9wZXJ0eV0gKyAnJykuaW5kZXhPZignY2FsbFN1cGVyJykgPiAtMSkge1xuXG4gICAgICAgICAgICBrbGFzcy5wcm90b3R5cGVbcHJvcGVydHldID0gKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHZhciBzdXBlcmNsYXNzID0gdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcyA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzID0gc3VwZXJjbGFzcztcblxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eSAhPT0gJ2luaXRpYWxpemUnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkocHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZVtwcm9wZXJ0eV0gPSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChJU19ET05URU5VTV9CVUdHWSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuICAgICAgICAgICAgICBrbGFzcy5wcm90b3R5cGUudG9TdHJpbmcgPSBzb3VyY2UudG9TdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc291cmNlLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikge1xuICAgICAgICAgICAgICBrbGFzcy5wcm90b3R5cGUudmFsdWVPZiA9IHNvdXJjZS52YWx1ZU9mO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICBmdW5jdGlvbiBTdWJjbGFzcygpIHsgfVxuXG4gIGZ1bmN0aW9uIGNhbGxTdXBlcihtZXRob2ROYW1lKSB7XG4gICAgdmFyIHBhcmVudE1ldGhvZCA9IG51bGwsXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIC8vIGNsaW1iIHByb3RvdHlwZSBjaGFpbiB0byBmaW5kIG1ldGhvZCBub3QgZXF1YWwgdG8gY2FsbGVlJ3MgbWV0aG9kXG4gICAgd2hpbGUgKF90aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MpIHtcbiAgICAgIHZhciBzdXBlckNsYXNzTWV0aG9kID0gX3RoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV07XG4gICAgICBpZiAoX3RoaXNbbWV0aG9kTmFtZV0gIT09IHN1cGVyQ2xhc3NNZXRob2QpIHtcbiAgICAgICAgcGFyZW50TWV0aG9kID0gc3VwZXJDbGFzc01ldGhvZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIF90aGlzID0gX3RoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcy5wcm90b3R5cGU7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJlbnRNZXRob2QpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmxvZygndHJpZWQgdG8gY2FsbFN1cGVyICcgKyBtZXRob2ROYW1lICsgJywgbWV0aG9kIG5vdCBmb3VuZCBpbiBwcm90b3R5cGUgY2hhaW4nLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgPyBwYXJlbnRNZXRob2QuYXBwbHkodGhpcywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKVxuICAgICAgOiBwYXJlbnRNZXRob2QuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZm9yIGNyZWF0aW9uIG9mIFwiY2xhc3Nlc1wiLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcmVudF0gb3B0aW9uYWwgXCJDbGFzc1wiIHRvIGluaGVyaXQgZnJvbVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgc2hhcmVkIGJ5IGFsbCBpbnN0YW5jZXMgb2YgdGhpcyBjbGFzc1xuICAgKiAgICAgICAgICAgICAgICAgIChiZSBjYXJlZnVsIG1vZGlmeWluZyBvYmplY3RzIGRlZmluZWQgaGVyZSBhcyB0aGlzIHdvdWxkIGFmZmVjdCBhbGwgaW5zdGFuY2VzKVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQ2xhc3MoKSB7XG4gICAgdmFyIHBhcmVudCA9IG51bGwsXG4gICAgICAgIHByb3BlcnRpZXMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICBpZiAodHlwZW9mIHByb3BlcnRpZXNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBhcmVudCA9IHByb3BlcnRpZXMuc2hpZnQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24ga2xhc3MoKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBrbGFzcy5zdXBlcmNsYXNzID0gcGFyZW50O1xuICAgIGtsYXNzLnN1YmNsYXNzZXMgPSBbXTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIFN1YmNsYXNzLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICBrbGFzcy5wcm90b3R5cGUgPSBuZXcgU3ViY2xhc3MoKTtcbiAgICAgIHBhcmVudC5zdWJjbGFzc2VzLnB1c2goa2xhc3MpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYWRkTWV0aG9kcyhrbGFzcywgcHJvcGVydGllc1tpXSwgcGFyZW50KTtcbiAgICB9XG4gICAgaWYgKCFrbGFzcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSkge1xuICAgICAga2xhc3MucHJvdG90eXBlLmluaXRpYWxpemUgPSBlbXB0eUZ1bmN0aW9uO1xuICAgIH1cbiAgICBrbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBrbGFzcztcbiAgICBrbGFzcy5wcm90b3R5cGUuY2FsbFN1cGVyID0gY2FsbFN1cGVyO1xuICAgIHJldHVybiBrbGFzcztcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzID0gY3JlYXRlQ2xhc3M7XG59KSgpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG4gIC8vIHNpbmNlIGllMTEgY2FuIHVzZSBhZGRFdmVudExpc3RlbmVyIGJ1dCB0aGV5IGRvIG5vdCBzdXBwb3J0IG9wdGlvbnMsIGkgbmVlZCB0byBjaGVja1xuICB2YXIgY291bGRVc2VBdHRhY2hFdmVudCA9ICEhZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLmF0dGFjaEV2ZW50LFxuICAgICAgdG91Y2hFdmVudHMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJ107XG4gIC8qKlxuICAgKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBlbGVtZW50ICYmIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGNvdWxkVXNlQXR0YWNoRXZlbnQgPyBmYWxzZSA6IG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYW4gZWxlbWVudFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBmYWJyaWMudXRpbC5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGVsZW1lbnQgJiYgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgY291bGRVc2VBdHRhY2hFdmVudCA/IGZhbHNlIDogb3B0aW9ucyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0VG91Y2hJbmZvKGV2ZW50KSB7XG4gICAgdmFyIHRvdWNoUHJvcCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuICAgIGlmICh0b3VjaFByb3AgJiYgdG91Y2hQcm9wWzBdKSB7XG4gICAgICByZXR1cm4gdG91Y2hQcm9wWzBdO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cblxuICBmYWJyaWMudXRpbC5nZXRQb2ludGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGV2ZW50LnRhcmdldCxcbiAgICAgICAgc2Nyb2xsID0gZmFicmljLnV0aWwuZ2V0U2Nyb2xsTGVmdFRvcChlbGVtZW50KSxcbiAgICAgICAgX2V2dCA9IGdldFRvdWNoSW5mbyhldmVudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IF9ldnQuY2xpZW50WCArIHNjcm9sbC5sZWZ0LFxuICAgICAgeTogX2V2dC5jbGllbnRZICsgc2Nyb2xsLnRvcFxuICAgIH07XG4gIH07XG5cbiAgZmFicmljLnV0aWwuaXNUb3VjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gdG91Y2hFdmVudHMuaW5kZXhPZihldmVudC50eXBlKSA+IC0xIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xuICB9O1xufSkoKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBDcm9zcy1icm93c2VyIHdyYXBwZXIgZm9yIHNldHRpbmcgZWxlbWVudCdzIHN0eWxlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXNcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IEVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIGFzIGEgZmlyc3QgYXJndW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIHNldFN0eWxlKGVsZW1lbnQsIHN0eWxlcykge1xuICAgIHZhciBlbGVtZW50U3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgIGlmICghZWxlbWVudFN0eWxlKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmNzc1RleHQgKz0gJzsnICsgc3R5bGVzO1xuICAgICAgcmV0dXJuIHN0eWxlcy5pbmRleE9mKCdvcGFjaXR5JykgPiAtMVxuICAgICAgICA/IHNldE9wYWNpdHkoZWxlbWVudCwgc3R5bGVzLm1hdGNoKC9vcGFjaXR5OlxccyooXFxkP1xcLj9cXGQqKS8pWzFdKVxuICAgICAgICA6IGVsZW1lbnQ7XG4gICAgfVxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHN0eWxlcykge1xuICAgICAgaWYgKHByb3BlcnR5ID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgc2V0T3BhY2l0eShlbGVtZW50LCBzdHlsZXNbcHJvcGVydHldKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgbm9ybWFsaXplZFByb3BlcnR5ID0gKHByb3BlcnR5ID09PSAnZmxvYXQnIHx8IHByb3BlcnR5ID09PSAnY3NzRmxvYXQnKVxuICAgICAgICAgID8gKHR5cGVvZiBlbGVtZW50U3R5bGUuc3R5bGVGbG9hdCA9PT0gJ3VuZGVmaW5lZCcgPyAnY3NzRmxvYXQnIDogJ3N0eWxlRmxvYXQnKVxuICAgICAgICAgIDogcHJvcGVydHk7XG4gICAgICAgIGVsZW1lbnRTdHlsZS5zZXRQcm9wZXJ0eShub3JtYWxpemVkUHJvcGVydHksIHN0eWxlc1twcm9wZXJ0eV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHZhciBwYXJzZUVsID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgc3VwcG9ydHNPcGFjaXR5ID0gdHlwZW9mIHBhcnNlRWwuc3R5bGUub3BhY2l0eSA9PT0gJ3N0cmluZycsXG4gICAgICBzdXBwb3J0c0ZpbHRlcnMgPSB0eXBlb2YgcGFyc2VFbC5zdHlsZS5maWx0ZXIgPT09ICdzdHJpbmcnLFxuICAgICAgcmVPcGFjaXR5ID0gL2FscGhhXFxzKlxcKFxccypvcGFjaXR5XFxzKj1cXHMqKFteXFwpXSspXFwpLyxcblxuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIHNldE9wYWNpdHkgPSBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gZWxlbWVudDsgfTtcblxuICBpZiAoc3VwcG9ydHNPcGFjaXR5KSB7XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBzZXRPcGFjaXR5ID0gZnVuY3Rpb24oZWxlbWVudCwgdmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcbiAgfVxuICBlbHNlIGlmIChzdXBwb3J0c0ZpbHRlcnMpIHtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHNldE9wYWNpdHkgPSBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZSkge1xuICAgICAgdmFyIGVzID0gZWxlbWVudC5zdHlsZTtcbiAgICAgIGlmIChlbGVtZW50LmN1cnJlbnRTdHlsZSAmJiAhZWxlbWVudC5jdXJyZW50U3R5bGUuaGFzTGF5b3V0KSB7XG4gICAgICAgIGVzLnpvb20gPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHJlT3BhY2l0eS50ZXN0KGVzLmZpbHRlcikpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PSAwLjk5OTkgPyAnJyA6ICgnYWxwaGEob3BhY2l0eT0nICsgKHZhbHVlICogMTAwKSArICcpJyk7XG4gICAgICAgIGVzLmZpbHRlciA9IGVzLmZpbHRlci5yZXBsYWNlKHJlT3BhY2l0eSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVzLmZpbHRlciArPSAnIGFscGhhKG9wYWNpdHk9JyArICh2YWx1ZSAqIDEwMCkgKyAnKSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuICB9XG5cbiAgZmFicmljLnV0aWwuc2V0U3R5bGUgPSBzZXRTdHlsZTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIF9zbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogVGFrZXMgaWQgYW5kIHJldHVybnMgYW4gZWxlbWVudCB3aXRoIHRoYXQgaWQgKGlmIG9uZSBleGlzdHMgaW4gYSBkb2N1bWVudClcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fSBpZFxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnID8gZmFicmljLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkO1xuICB9XG5cbiAgdmFyIHNsaWNlQ2FuQ29udmVydE5vZGVsaXN0cyxcbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgYW4gYXJyYXktbGlrZSBvYmplY3QgKGUuZy4gYXJndW1lbnRzIG9yIE5vZGVMaXN0KSB0byBhbiBhcnJheVxuICAgICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJyYXlMaWtlXG4gICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAqL1xuICAgICAgdG9BcnJheSA9IGZ1bmN0aW9uKGFycmF5TGlrZSkge1xuICAgICAgICByZXR1cm4gX3NsaWNlLmNhbGwoYXJyYXlMaWtlLCAwKTtcbiAgICAgIH07XG5cbiAgdHJ5IHtcbiAgICBzbGljZUNhbkNvbnZlcnROb2RlbGlzdHMgPSB0b0FycmF5KGZhYnJpYy5kb2N1bWVudC5jaGlsZE5vZGVzKSBpbnN0YW5jZW9mIEFycmF5O1xuICB9XG4gIGNhdGNoIChlcnIpIHsgfVxuXG4gIGlmICghc2xpY2VDYW5Db252ZXJ0Tm9kZWxpc3RzKSB7XG4gICAgdG9BcnJheSA9IGZ1bmN0aW9uKGFycmF5TGlrZSkge1xuICAgICAgdmFyIGFyciA9IG5ldyBBcnJheShhcnJheUxpa2UubGVuZ3RoKSwgaSA9IGFycmF5TGlrZS5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGFycltpXSA9IGFycmF5TGlrZVtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHNwZWNpZmllZCBlbGVtZW50IHdpdGggc3BlY2lmaWVkIGF0dHJpYnV0ZXNcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0YWdOYW1lIFR5cGUgb2YgYW4gZWxlbWVudCB0byBjcmVhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBBdHRyaWJ1dGVzIHRvIHNldCBvbiBhbiBlbGVtZW50XG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBOZXdseSBjcmVhdGVkIGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VFbGVtZW50KHRhZ05hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgZWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBmb3IgKHZhciBwcm9wIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChwcm9wID09PSAnY2xhc3MnKSB7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwcm9wID09PSAnZm9yJykge1xuICAgICAgICBlbC5odG1sRm9yID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGNsYXNzIHRvIGFuIGVsZW1lbnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBhZGQgY2xhc3MgdG9cbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSBDbGFzcyB0byBhZGQgdG8gYW4gZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGVsZW1lbnQgJiYgKCcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJykgPT09IC0xKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSAoZWxlbWVudC5jbGFzc05hbWUgPyAnICcgOiAnJykgKyBjbGFzc05hbWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBzIGVsZW1lbnQgd2l0aCBhbm90aGVyIGVsZW1lbnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byB3cmFwXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfSB3cmFwcGVyIEVsZW1lbnQgdG8gd3JhcCB3aXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gQXR0cmlidXRlcyB0byBzZXQgb24gYSB3cmFwcGVyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSB3cmFwcGVyXG4gICAqL1xuICBmdW5jdGlvbiB3cmFwRWxlbWVudChlbGVtZW50LCB3cmFwcGVyLCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKHR5cGVvZiB3cmFwcGVyID09PSAnc3RyaW5nJykge1xuICAgICAgd3JhcHBlciA9IG1ha2VFbGVtZW50KHdyYXBwZXIsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHdyYXBwZXIsIGVsZW1lbnQpO1xuICAgIH1cbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZWxlbWVudCBzY3JvbGwgb2Zmc2V0c1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIG9wZXJhdGUgb25cbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBsZWZ0L3RvcCB2YWx1ZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdldFNjcm9sbExlZnRUb3AoZWxlbWVudCkge1xuXG4gICAgdmFyIGxlZnQgPSAwLFxuICAgICAgICB0b3AgPSAwLFxuICAgICAgICBkb2NFbGVtZW50ID0gZmFicmljLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgYm9keSA9IGZhYnJpYy5kb2N1bWVudC5ib2R5IHx8IHtcbiAgICAgICAgICBzY3JvbGxMZWZ0OiAwLCBzY3JvbGxUb3A6IDBcbiAgICAgICAgfTtcblxuICAgIC8vIFdoaWxlIGxvb3AgY2hlY2tzIChhbmQgdGhlbiBzZXRzIGVsZW1lbnQgdG8pIC5wYXJlbnROb2RlIE9SIC5ob3N0XG4gICAgLy8gIHRvIGFjY291bnQgZm9yIFNoYWRvd0RPTS4gV2Ugc3RpbGwgd2FudCB0byB0cmF2ZXJzZSB1cCBvdXQgb2YgU2hhZG93RE9NLFxuICAgIC8vICBidXQgdGhlIC5wYXJlbnROb2RlIG9mIGEgcm9vdCBTaGFkb3dET00gbm9kZSB3aWxsIGFsd2F5cyBiZSBudWxsLCBpbnN0ZWFkXG4gICAgLy8gIGl0IHNob3VsZCBiZSBhY2Nlc3NlZCB0aHJvdWdoIC5ob3N0LiBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjQ3NjU1MjgvNDM4MzkzOFxuICAgIHdoaWxlIChlbGVtZW50ICYmIChlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0KSkge1xuXG4gICAgICAvLyBTZXQgZWxlbWVudCB0byBlbGVtZW50IHBhcmVudCwgb3IgJ2hvc3QnIGluIGNhc2Ugb2YgU2hhZG93RE9NXG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcblxuICAgICAgaWYgKGVsZW1lbnQgPT09IGZhYnJpYy5kb2N1bWVudCkge1xuICAgICAgICBsZWZ0ID0gYm9keS5zY3JvbGxMZWZ0IHx8IGRvY0VsZW1lbnQuc2Nyb2xsTGVmdCB8fCAwO1xuICAgICAgICB0b3AgPSBib2R5LnNjcm9sbFRvcCB8fCAgZG9jRWxlbWVudC5zY3JvbGxUb3AgfHwgMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsZWZ0ICs9IGVsZW1lbnQuc2Nyb2xsTGVmdCB8fCAwO1xuICAgICAgICB0b3AgKz0gZWxlbWVudC5zY3JvbGxUb3AgfHwgMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IDEgJiYgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgb2Zmc2V0IGZvciBhIGdpdmVuIGVsZW1lbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gZ2V0IG9mZnNldCBmb3JcbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBcImxlZnRcIiBhbmQgXCJ0b3BcIiBwcm9wZXJ0aWVzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRFbGVtZW50T2Zmc2V0KGVsZW1lbnQpIHtcbiAgICB2YXIgZG9jRWxlbSxcbiAgICAgICAgZG9jID0gZWxlbWVudCAmJiBlbGVtZW50Lm93bmVyRG9jdW1lbnQsXG4gICAgICAgIGJveCA9IHsgbGVmdDogMCwgdG9wOiAwIH0sXG4gICAgICAgIG9mZnNldCA9IHsgbGVmdDogMCwgdG9wOiAwIH0sXG4gICAgICAgIHNjcm9sbExlZnRUb3AsXG4gICAgICAgIG9mZnNldEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgYm9yZGVyTGVmdFdpZHRoOiAnbGVmdCcsXG4gICAgICAgICAgYm9yZGVyVG9wV2lkdGg6ICAndG9wJyxcbiAgICAgICAgICBwYWRkaW5nTGVmdDogICAgICdsZWZ0JyxcbiAgICAgICAgICBwYWRkaW5nVG9wOiAgICAgICd0b3AnXG4gICAgICAgIH07XG5cbiAgICBpZiAoIWRvYykge1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBhdHRyIGluIG9mZnNldEF0dHJpYnV0ZXMpIHtcbiAgICAgIG9mZnNldFtvZmZzZXRBdHRyaWJ1dGVzW2F0dHJdXSArPSBwYXJzZUludChnZXRFbGVtZW50U3R5bGUoZWxlbWVudCwgYXR0ciksIDEwKSB8fCAwO1xuICAgIH1cblxuICAgIGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIGlmICggdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgIGJveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuXG4gICAgc2Nyb2xsTGVmdFRvcCA9IGdldFNjcm9sbExlZnRUb3AoZWxlbWVudCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogYm94LmxlZnQgKyBzY3JvbGxMZWZ0VG9wLmxlZnQgLSAoZG9jRWxlbS5jbGllbnRMZWZ0IHx8IDApICsgb2Zmc2V0LmxlZnQsXG4gICAgICB0b3A6IGJveC50b3AgKyBzY3JvbGxMZWZ0VG9wLnRvcCAtIChkb2NFbGVtLmNsaWVudFRvcCB8fCAwKSAgKyBvZmZzZXQudG9wXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHN0eWxlIGF0dHJpYnV0ZSB2YWx1ZSBvZiBhIGdpdmVuIGVsZW1lbnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBnZXQgc3R5bGUgYXR0cmlidXRlIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBTdHlsZSBhdHRyaWJ1dGUgdG8gZ2V0IGZvciBlbGVtZW50XG4gICAqIEByZXR1cm4ge1N0cmluZ30gU3R5bGUgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKi9cbiAgdmFyIGdldEVsZW1lbnRTdHlsZTtcbiAgaWYgKGZhYnJpYy5kb2N1bWVudC5kZWZhdWx0VmlldyAmJiBmYWJyaWMuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgIGdldEVsZW1lbnRTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIpIHtcbiAgICAgIHZhciBzdHlsZSA9IGZhYnJpYy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICAgICAgcmV0dXJuIHN0eWxlID8gc3R5bGVbYXR0cl0gOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgfVxuICBlbHNlIHtcbiAgICBnZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XG4gICAgICB2YXIgdmFsdWUgPSBlbGVtZW50LnN0eWxlW2F0dHJdO1xuICAgICAgaWYgKCF2YWx1ZSAmJiBlbGVtZW50LmN1cnJlbnRTdHlsZSkge1xuICAgICAgICB2YWx1ZSA9IGVsZW1lbnQuY3VycmVudFN0eWxlW2F0dHJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH1cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IGZhYnJpYy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUsXG4gICAgICAgIHNlbGVjdFByb3AgPSAndXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICA/ICd1c2VyU2VsZWN0J1xuICAgICAgICAgIDogJ01velVzZXJTZWxlY3QnIGluIHN0eWxlXG4gICAgICAgICAgICA/ICdNb3pVc2VyU2VsZWN0J1xuICAgICAgICAgICAgOiAnV2Via2l0VXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICAgICAgPyAnV2Via2l0VXNlclNlbGVjdCdcbiAgICAgICAgICAgICAgOiAnS2h0bWxVc2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgICAgICAgID8gJ0todG1sVXNlclNlbGVjdCdcbiAgICAgICAgICAgICAgICA6ICcnO1xuXG4gICAgLyoqXG4gICAgICogTWFrZXMgZWxlbWVudCB1bnNlbGVjdGFibGVcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gbWFrZSB1bnNlbGVjdGFibGVcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gRWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgaW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlRWxlbWVudFVuc2VsZWN0YWJsZShlbGVtZW50KSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQub25zZWxlY3RzdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ID0gZmFicmljLnV0aWwuZmFsc2VGdW5jdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RQcm9wKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc2VsZWN0UHJvcF0gPSAnbm9uZSc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC51bnNlbGVjdGFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsZW1lbnQudW5zZWxlY3RhYmxlID0gJ29uJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGVsZW1lbnQgc2VsZWN0YWJsZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBtYWtlIHNlbGVjdGFibGVcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gRWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgaW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlRWxlbWVudFNlbGVjdGFibGUoZWxlbWVudCkge1xuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVsZW1lbnQub25zZWxlY3RzdGFydCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0UHJvcCkge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3NlbGVjdFByb3BdID0gJyc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC51bnNlbGVjdGFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsZW1lbnQudW5zZWxlY3RhYmxlID0gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFVuc2VsZWN0YWJsZSA9IG1ha2VFbGVtZW50VW5zZWxlY3RhYmxlO1xuICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50U2VsZWN0YWJsZSA9IG1ha2VFbGVtZW50U2VsZWN0YWJsZTtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBnZXROb2RlQ2FudmFzKGVsZW1lbnQpIHtcbiAgICB2YXIgaW1wbCA9IGZhYnJpYy5qc2RvbUltcGxGb3JXcmFwcGVyKGVsZW1lbnQpO1xuICAgIHJldHVybiBpbXBsLl9jYW52YXMgfHwgaW1wbC5faW1hZ2U7XG4gIH07XG5cbiAgZnVuY3Rpb24gY2xlYW5VcEpzZG9tTm9kZShlbGVtZW50KSB7XG4gICAgaWYgKCFmYWJyaWMuaXNMaWtlbHlOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbXBsID0gZmFicmljLmpzZG9tSW1wbEZvcldyYXBwZXIoZWxlbWVudCk7XG4gICAgaWYgKGltcGwpIHtcbiAgICAgIGltcGwuX2ltYWdlID0gbnVsbDtcbiAgICAgIGltcGwuX2NhbnZhcyA9IG51bGw7XG4gICAgICAvLyB1bnN1cmUgaWYgbmVjZXNzYXJ5XG4gICAgICBpbXBsLl9jdXJyZW50U3JjID0gbnVsbDtcbiAgICAgIGltcGwuX2F0dHJpYnV0ZXMgPSBudWxsO1xuICAgICAgaW1wbC5fY2xhc3NMaXN0ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRJbWFnZVNtb290aGluZyhjdHgsIHZhbHVlKSB7XG4gICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY3R4LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZFxuICAgICAgfHwgY3R4Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjdHgubXNJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY3R4Lm9JbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldEltYWdlU21vb3RoaW5nIHNldHMgdGhlIGNvbnRleHQgaW1hZ2VTbW9vdGhpbmdFbmFibGVkIHByb3BlcnR5LlxuICAgKiBVc2VkIGJ5IGNhbnZhcyBhbmQgYnkgSW1hZ2VPYmplY3QuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQHBhcmFtIHtIVE1MUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdG8gc2V0IG9uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgdHJ1ZSBvciBmYWxzZVxuICAgKi9cbiAgZmFicmljLnV0aWwuc2V0SW1hZ2VTbW9vdGhpbmcgPSBzZXRJbWFnZVNtb290aGluZztcbiAgZmFicmljLnV0aWwuZ2V0QnlJZCA9IGdldEJ5SWQ7XG4gIGZhYnJpYy51dGlsLnRvQXJyYXkgPSB0b0FycmF5O1xuICBmYWJyaWMudXRpbC5hZGRDbGFzcyA9IGFkZENsYXNzO1xuICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudCA9IG1ha2VFbGVtZW50O1xuICBmYWJyaWMudXRpbC53cmFwRWxlbWVudCA9IHdyYXBFbGVtZW50O1xuICBmYWJyaWMudXRpbC5nZXRTY3JvbGxMZWZ0VG9wID0gZ2V0U2Nyb2xsTGVmdFRvcDtcbiAgZmFicmljLnV0aWwuZ2V0RWxlbWVudE9mZnNldCA9IGdldEVsZW1lbnRPZmZzZXQ7XG4gIGZhYnJpYy51dGlsLmdldE5vZGVDYW52YXMgPSBnZXROb2RlQ2FudmFzO1xuICBmYWJyaWMudXRpbC5jbGVhblVwSnNkb21Ob2RlID0gY2xlYW5VcEpzZG9tTm9kZTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gYWRkUGFyYW1Ub1VybCh1cmwsIHBhcmFtKSB7XG4gICAgcmV0dXJuIHVybCArICgvXFw/Ly50ZXN0KHVybCkgPyAnJicgOiAnPycpICsgcGFyYW07XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eUZuKCkgeyB9XG5cbiAgLyoqXG4gICAqIENyb3NzLWJyb3dzZXIgYWJzdHJhY3Rpb24gZm9yIHNlbmRpbmcgWE1MSHR0cFJlcXVlc3RcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIHNlbmQgWE1MSHR0cFJlcXVlc3QgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWV0aG9kPVwiR0VUXCJdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXJhbWV0ZXJzXSBwYXJhbWV0ZXJzIHRvIGFwcGVuZCB0byB1cmwgaW4gR0VUIG9yIGluIGJvZHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJvZHldIGJvZHkgdG8gc2VuZCB3aXRoIFBPU1Qgb3IgUFVUIHJlcXVlc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vbkNvbXBsZXRlIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIHJlcXVlc3QgaXMgY29tcGxldGVkXG4gICAqIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fSByZXF1ZXN0XG4gICAqL1xuICBmdW5jdGlvbiByZXF1ZXN0KHVybCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kID8gb3B0aW9ucy5tZXRob2QudG9VcHBlckNhc2UoKSA6ICdHRVQnLFxuICAgICAgICBvbkNvbXBsZXRlID0gb3B0aW9ucy5vbkNvbXBsZXRlIHx8IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICB4aHIgPSBuZXcgZmFicmljLndpbmRvdy5YTUxIdHRwUmVxdWVzdCgpLFxuICAgICAgICBib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG9wdGlvbnMucGFyYW1ldGVycztcblxuICAgIC8qKiBAaWdub3JlICovXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIG9uQ29tcGxldGUoeGhyKTtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5Rm47XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICBib2R5ID0gbnVsbDtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wYXJhbWV0ZXJzID09PSAnc3RyaW5nJykge1xuICAgICAgICB1cmwgPSBhZGRQYXJhbVRvVXJsKHVybCwgb3B0aW9ucy5wYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG5cbiAgICBpZiAobWV0aG9kID09PSAnUE9TVCcgfHwgbWV0aG9kID09PSAnUFVUJykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICB9XG5cbiAgICB4aHIuc2VuZChib2R5KTtcbiAgICByZXR1cm4geGhyO1xuICB9XG5cbiAgZmFicmljLnV0aWwucmVxdWVzdCA9IHJlcXVlc3Q7XG59KSgpO1xuXG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgYGNvbnNvbGUubG9nYCAod2hlbiBhdmFpbGFibGUpXG4gKiBAcGFyYW0geyp9IFt2YWx1ZXNdIFZhbHVlcyB0byBsb2dcbiAqL1xuZmFicmljLmxvZyA9IGNvbnNvbGUubG9nO1xuXG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIGBjb25zb2xlLndhcm5gICh3aGVuIGF2YWlsYWJsZSlcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlc10gVmFsdWVzIHRvIGxvZyBhcyBhIHdhcm5pbmdcbiAqL1xuZmFicmljLndhcm4gPSBjb25zb2xlLndhcm47XG5cblxuKGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBBbmltYXRpb25PcHRpb25zXG4gICAqIEFuaW1hdGlvbiBvZiBhIHZhbHVlIG9yIGxpc3Qgb2YgdmFsdWVzLlxuICAgKiBXaGVuIHVzaW5nIGxpc3RzLCB0aGluayBvZiBzb21ldGhpbmcgbGlrZSB0aGlzOlxuICAgKiBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICogICBzdGFydFZhbHVlOiBbMSwgMiwgM10sXG4gICAqICAgZW5kVmFsdWU6IFsyLCA0LCA2XSxcbiAgICogICBvbkNoYW5nZTogZnVuY3Rpb24oW2EsIGIsIGNdKSB7XG4gICAqICAgICBjYW52YXMuem9vbVRvUG9pbnQoe3g6IGIsIHk6IGN9LCBhKVxuICAgKiAgICAgY2FudmFzLnJlbmRlckFsbCgpXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogQGV4YW1wbGVcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW29uQ2hhbmdlXSBDYWxsYmFjazsgaW52b2tlZCBvbiBldmVyeSB2YWx1ZSBjaGFuZ2VcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW29uQ29tcGxldGVdIENhbGxiYWNrOyBpbnZva2VkIHdoZW4gdmFsdWUgY2hhbmdlIGlzIGNvbXBsZXRlZFxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBOb3RlOiBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgYW5kIGJ5VmFsdWUgbXVzdCBtYXRjaCB0aGUgdHlwZVxuICAgKiB2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IHsgc3RhcnRWYWx1ZTogMCwgZW5kVmFsdWU6IDEsIGJ5VmFsdWU6IDAuMjUgfVxuICAgKiB2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IHsgc3RhcnRWYWx1ZTogWzAsIDFdLCBlbmRWYWx1ZTogWzEsIDJdLCBieVZhbHVlOiBbMC4yNSwgMC4yNV0gfVxuICAgKiBAcHJvcGVydHkge251bWJlciB8IG51bWJlcltdfSBbc3RhcnRWYWx1ZT0wXSBTdGFydGluZyB2YWx1ZVxuICAgKiBAcHJvcGVydHkge251bWJlciB8IG51bWJlcltdfSBbZW5kVmFsdWU9MTAwXSBFbmRpbmcgdmFsdWVcbiAgICogQHByb3BlcnR5IHtudW1iZXIgfCBudW1iZXJbXX0gW2J5VmFsdWU9MTAwXSBWYWx1ZSB0byBtb2RpZnkgdGhlIHByb3BlcnR5IGJ5XG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtlYXNpbmddIEVhc2luZyBmdW5jdGlvblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2R1cmF0aW9uPTUwMF0gRHVyYXRpb24gb2YgY2hhbmdlIChpbiBtcylcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2Fib3J0XSBBZGRpdGlvbmFsIGZ1bmN0aW9uIHdpdGggbG9naWMuIElmIHJldHVybnMgdHJ1ZSwgYW5pbWF0aW9uIGFib3J0cy5cbiAgICpcbiAgICogQHR5cGVkZWYgeygpID0+IHZvaWR9IENhbmNlbEZ1bmN0aW9uXG4gICAqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbkN1cnJlbnRTdGF0ZVxuICAgKiBAcHJvcGVydHkge251bWJlciB8IG51bWJlcltdfSBjdXJyZW50VmFsdWUgdmFsdWUgaW4gcmFuZ2UgW2BzdGFydFZhbHVlYCwgYGVuZFZhbHVlYF1cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbXBsZXRpb25SYXRlIHZhbHVlIGluIHJhbmdlIFswLCAxXVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gZHVyYXRpb25SYXRlIHZhbHVlIGluIHJhbmdlIFswLCAxXVxuICAgKlxuICAgKiBAdHlwZWRlZiB7KEFuaW1hdGlvbk9wdGlvbnMgJiBBbmltYXRpb25DdXJyZW50U3RhdGUgJiB7IGNhbmNlbDogQ2FuY2VsRnVuY3Rpb24gfX0gQW5pbWF0aW9uQ29udGV4dFxuICAgKi9cblxuICAvKipcbiAgICogQXJyYXkgaG9sZGluZyBhbGwgcnVubmluZyBhbmltYXRpb25zXG4gICAqIEBtZW1iZXJvZiBmYWJyaWNcbiAgICogQHR5cGUge0FuaW1hdGlvbkNvbnRleHRbXX1cbiAgICovXG4gIHZhciBSVU5OSU5HX0FOSU1BVElPTlMgPSBbXTtcbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChSVU5OSU5HX0FOSU1BVElPTlMsIHtcblxuICAgIC8qKlxuICAgICAqIGNhbmNlbCBhbGwgcnVubmluZyBhbmltYXRpb25zIGF0IHRoZSBuZXh0IHJlcXVlc3RBbmltRnJhbWVcbiAgICAgKiBAcmV0dXJucyB7QW5pbWF0aW9uQ29udGV4dFtdfVxuICAgICAqL1xuICAgIGNhbmNlbEFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLnNwbGljZSgwKTtcbiAgICAgIGFuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbmNlbCBhbGwgcnVubmluZyBhbmltYXRpb25zIGF0dGFjaGVkIHRvIGNhbnZhcyBhdCB0aGUgbmV4dCByZXF1ZXN0QW5pbUZyYW1lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuQ2FudmFzfSBjYW52YXNcbiAgICAgKiBAcmV0dXJucyB7QW5pbWF0aW9uQ29udGV4dFtdfVxuICAgICAqL1xuICAgIGNhbmNlbEJ5Q2FudmFzOiBmdW5jdGlvbiAoY2FudmFzKSB7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgY2FuY2VsbGVkID0gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGFuaW1hdGlvbi50YXJnZXQgPT09ICdvYmplY3QnICYmIGFuaW1hdGlvbi50YXJnZXQuY2FudmFzID09PSBjYW52YXM7XG4gICAgICB9KTtcbiAgICAgIGNhbmNlbGxlZC5mb3JFYWNoKGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2FuY2VsbGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYW5jZWwgYWxsIHJ1bm5pbmcgYW5pbWF0aW9ucyBmb3IgdGFyZ2V0IGF0IHRoZSBuZXh0IHJlcXVlc3RBbmltRnJhbWVcbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldFxuICAgICAqIEByZXR1cm5zIHtBbmltYXRpb25Db250ZXh0W119XG4gICAgICovXG4gICAgY2FuY2VsQnlUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHZhciBjYW5jZWxsZWQgPSB0aGlzLmZpbmRBbmltYXRpb25zQnlUYXJnZXQodGFyZ2V0KTtcbiAgICAgIGNhbmNlbGxlZC5mb3JFYWNoKGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2FuY2VsbGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FuY2VsRnVuY3Rpb259IGNhbmNlbEZ1bmMgdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IGFuaW1hdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZpbmRBbmltYXRpb25JbmRleDogZnVuY3Rpb24gKGNhbmNlbEZ1bmMpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4T2YodGhpcy5maW5kQW5pbWF0aW9uKGNhbmNlbEZ1bmMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbmNlbEZ1bmN0aW9ufSBjYW5jZWxGdW5jIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBhbmltYXRlXG4gICAgICogQHJldHVybnMge0FuaW1hdGlvbkNvbnRleHQgfCB1bmRlZmluZWR9IGFuaW1hdGlvbidzIG9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgZmluZEFuaW1hdGlvbjogZnVuY3Rpb24gKGNhbmNlbEZ1bmMpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmQoZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uLmNhbmNlbCA9PT0gY2FuY2VsRnVuYztcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IHRoZSBvYmplY3QgdGhhdCBpcyBhc3NpZ25lZCB0byB0aGUgdGFyZ2V0IHByb3BlcnR5IG9mIHRoZSBhbmltYXRpb24gY29udGV4dFxuICAgICAqIEByZXR1cm5zIHtBbmltYXRpb25Db250ZXh0W119IGFycmF5IG9mIGFuaW1hdGlvbiBvcHRpb25zIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGFyZ2V0XG4gICAgICovXG4gICAgZmluZEFuaW1hdGlvbnNCeVRhcmdldDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbi50YXJnZXQgPT09IHRhcmdldDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0RWFzaW5nKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgKiBNYXRoLmNvcyh0IC8gZCAqIChNYXRoLlBJIC8gMikpICsgYyArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyB2YWx1ZSBmcm9tIG9uZSB0byBhbm90aGVyIHdpdGhpbiBjZXJ0YWluIHBlcmlvZCBvZiB0aW1lLCBpbnZva2luZyBjYWxsYmFja3MgYXMgdmFsdWUgaXMgYmVpbmcgY2hhbmdlZC5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7QW5pbWF0aW9uT3B0aW9uc30gW29wdGlvbnNdIEFuaW1hdGlvbiBvcHRpb25zXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIE5vdGU6IHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBhbmQgYnlWYWx1ZSBtdXN0IG1hdGNoIHRoZSB0eXBlXG4gICAqIGZhYnJpYy51dGlsLmFuaW1hdGUoeyBzdGFydFZhbHVlOiAwLCBlbmRWYWx1ZTogMSwgYnlWYWx1ZTogMC4yNSB9KVxuICAgKiBmYWJyaWMudXRpbC5hbmltYXRlKHsgc3RhcnRWYWx1ZTogWzAsIDFdLCBlbmRWYWx1ZTogWzEsIDJdLCBieVZhbHVlOiBbMC4yNSwgMC4yNV0gfSlcbiAgICogQHJldHVybnMge0NhbmNlbEZ1bmN0aW9ufSBjYW5jZWwgZnVuY3Rpb25cbiAgICovXG4gIGZ1bmN0aW9uIGFuaW1hdGUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgdmFyIGNhbmNlbCA9IGZhbHNlLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICByZW1vdmVGcm9tUmVnaXN0cnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gZmFicmljLnJ1bm5pbmdBbmltYXRpb25zLmluZGV4T2YoY29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgJiYgZmFicmljLnJ1bm5pbmdBbmltYXRpb25zLnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgICAgIH07XG5cbiAgICBjb250ZXh0ID0gZXh0ZW5kKGNsb25lKG9wdGlvbnMpLCB7XG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUZyb21SZWdpc3RyeSgpO1xuICAgICAgfSxcbiAgICAgIGN1cnJlbnRWYWx1ZTogJ3N0YXJ0VmFsdWUnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXJ0VmFsdWUgOiAwLFxuICAgICAgY29tcGxldGlvblJhdGU6IDAsXG4gICAgICBkdXJhdGlvblJhdGU6IDBcbiAgICB9KTtcbiAgICBmYWJyaWMucnVubmluZ0FuaW1hdGlvbnMucHVzaChjb250ZXh0KTtcblxuICAgIHJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24odGltZXN0YW1wKSB7XG4gICAgICB2YXIgc3RhcnQgPSB0aW1lc3RhbXAgfHwgK25ldyBEYXRlKCksXG4gICAgICAgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8IDUwMCxcbiAgICAgICAgICBmaW5pc2ggPSBzdGFydCArIGR1cmF0aW9uLCB0aW1lLFxuICAgICAgICAgIG9uQ2hhbmdlID0gb3B0aW9ucy5vbkNoYW5nZSB8fCBub29wLFxuICAgICAgICAgIGFib3J0ID0gb3B0aW9ucy5hYm9ydCB8fCBub29wLFxuICAgICAgICAgIG9uQ29tcGxldGUgPSBvcHRpb25zLm9uQ29tcGxldGUgfHwgbm9vcCxcbiAgICAgICAgICBlYXNpbmcgPSBvcHRpb25zLmVhc2luZyB8fCBkZWZhdWx0RWFzaW5nLFxuICAgICAgICAgIGlzTWFueSA9ICdzdGFydFZhbHVlJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGFydFZhbHVlLmxlbmd0aCA+IDAgOiBmYWxzZSxcbiAgICAgICAgICBzdGFydFZhbHVlID0gJ3N0YXJ0VmFsdWUnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXJ0VmFsdWUgOiAwLFxuICAgICAgICAgIGVuZFZhbHVlID0gJ2VuZFZhbHVlJyBpbiBvcHRpb25zID8gb3B0aW9ucy5lbmRWYWx1ZSA6IDEwMCxcbiAgICAgICAgICBieVZhbHVlID0gb3B0aW9ucy5ieVZhbHVlIHx8IChpc01hbnkgPyBzdGFydFZhbHVlLm1hcChmdW5jdGlvbih2YWx1ZSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGVuZFZhbHVlW2ldIC0gc3RhcnRWYWx1ZVtpXTtcbiAgICAgICAgICB9KSA6IGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSk7XG5cbiAgICAgIG9wdGlvbnMub25TdGFydCAmJiBvcHRpb25zLm9uU3RhcnQoKTtcblxuICAgICAgKGZ1bmN0aW9uIHRpY2sodGlja3RpbWUpIHtcbiAgICAgICAgdGltZSA9IHRpY2t0aW1lIHx8ICtuZXcgRGF0ZSgpO1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSB0aW1lID4gZmluaXNoID8gZHVyYXRpb24gOiAodGltZSAtIHN0YXJ0KSxcbiAgICAgICAgICAgIHRpbWVQZXJjID0gY3VycmVudFRpbWUgLyBkdXJhdGlvbixcbiAgICAgICAgICAgIGN1cnJlbnQgPSBpc01hbnkgPyBzdGFydFZhbHVlLm1hcChmdW5jdGlvbihfdmFsdWUsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVhc2luZyhjdXJyZW50VGltZSwgc3RhcnRWYWx1ZVtpXSwgYnlWYWx1ZVtpXSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgfSkgOiBlYXNpbmcoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGJ5VmFsdWUsIGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHZhbHVlUGVyYyA9IGlzTWFueSA/IE1hdGguYWJzKChjdXJyZW50WzBdIC0gc3RhcnRWYWx1ZVswXSkgLyBieVZhbHVlWzBdKVxuICAgICAgICAgICAgICA6IE1hdGguYWJzKChjdXJyZW50IC0gc3RhcnRWYWx1ZSkgLyBieVZhbHVlKTtcbiAgICAgICAgLy8gIHVwZGF0ZSBjb250ZXh0XG4gICAgICAgIGNvbnRleHQuY3VycmVudFZhbHVlID0gaXNNYW55ID8gY3VycmVudC5zbGljZSgpIDogY3VycmVudDtcbiAgICAgICAgY29udGV4dC5jb21wbGV0aW9uUmF0ZSA9IHZhbHVlUGVyYztcbiAgICAgICAgY29udGV4dC5kdXJhdGlvblJhdGUgPSB0aW1lUGVyYztcbiAgICAgICAgaWYgKGNhbmNlbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWJvcnQoY3VycmVudCwgdmFsdWVQZXJjLCB0aW1lUGVyYykpIHtcbiAgICAgICAgICByZW1vdmVGcm9tUmVnaXN0cnkoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWUgPiBmaW5pc2gpIHtcbiAgICAgICAgICAvLyAgdXBkYXRlIGNvbnRleHRcbiAgICAgICAgICBjb250ZXh0LmN1cnJlbnRWYWx1ZSA9IGlzTWFueSA/IGVuZFZhbHVlLnNsaWNlKCkgOiBlbmRWYWx1ZTtcbiAgICAgICAgICBjb250ZXh0LmNvbXBsZXRpb25SYXRlID0gMTtcbiAgICAgICAgICBjb250ZXh0LmR1cmF0aW9uUmF0ZSA9IDE7XG4gICAgICAgICAgLy8gIGV4ZWN1dGUgY2FsbGJhY2tzXG4gICAgICAgICAgb25DaGFuZ2UoaXNNYW55ID8gZW5kVmFsdWUuc2xpY2UoKSA6IGVuZFZhbHVlLCAxLCAxKTtcbiAgICAgICAgICBvbkNvbXBsZXRlKGVuZFZhbHVlLCAxLCAxKTtcbiAgICAgICAgICByZW1vdmVGcm9tUmVnaXN0cnkoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgb25DaGFuZ2UoY3VycmVudCwgdmFsdWVQZXJjLCB0aW1lUGVyYyk7XG4gICAgICAgICAgcmVxdWVzdEFuaW1GcmFtZSh0aWNrKTtcbiAgICAgICAgfVxuICAgICAgfSkoc3RhcnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbnRleHQuY2FuY2VsO1xuICB9XG5cbiAgdmFyIF9yZXF1ZXN0QW5pbUZyYW1lID0gZmFicmljLndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFicmljLndpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gIHZhciBfY2FuY2VsQW5pbUZyYW1lID0gZmFicmljLndpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBmYWJyaWMud2luZG93LmNsZWFyVGltZW91dDtcblxuICAvKipcbiAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsIGJhc2VkIG9uIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4gICAqIEluIG9yZGVyIHRvIGdldCBhIHByZWNpc2Ugc3RhcnQgdGltZSwgYHJlcXVlc3RBbmltRnJhbWVgIHNob3VsZCBiZSBjYWxsZWQgYXMgYW4gZW50cnkgaW50byB0aGUgbWV0aG9kXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2VcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IG9wdGlvbmFsIEVsZW1lbnQgdG8gYXNzb2NpYXRlIHdpdGggYW5pbWF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKCkge1xuICAgIHJldHVybiBfcmVxdWVzdEFuaW1GcmFtZS5hcHBseShmYWJyaWMud2luZG93LCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsQW5pbUZyYW1lKCkge1xuICAgIHJldHVybiBfY2FuY2VsQW5pbUZyYW1lLmFwcGx5KGZhYnJpYy53aW5kb3csIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmYWJyaWMudXRpbC5hbmltYXRlID0gYW5pbWF0ZTtcbiAgZmFicmljLnV0aWwucmVxdWVzdEFuaW1GcmFtZSA9IHJlcXVlc3RBbmltRnJhbWU7XG4gIGZhYnJpYy51dGlsLmNhbmNlbEFuaW1GcmFtZSA9IGNhbmNlbEFuaW1GcmFtZTtcbiAgZmFicmljLnJ1bm5pbmdBbmltYXRpb25zID0gUlVOTklOR19BTklNQVRJT05TO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gIC8vIENhbGN1bGF0ZSBhbiBpbi1iZXR3ZWVuIGNvbG9yLiBSZXR1cm5zIGEgXCJyZ2JhKClcIiBzdHJpbmcuXG4gIC8vIENyZWRpdDogRWR3aW4gTWFydGluIDxlZHdpbkBiaXRzdG9ybS5vcmc+XG4gIC8vICAgICAgICAgaHR0cDovL3d3dy5iaXRzdG9ybS5vcmcvanF1ZXJ5L2NvbG9yLWFuaW1hdGlvbi9qcXVlcnkuYW5pbWF0ZS1jb2xvcnMuanNcbiAgZnVuY3Rpb24gY2FsY3VsYXRlQ29sb3IoYmVnaW4sIGVuZCwgcG9zKSB7XG4gICAgdmFyIGNvbG9yID0gJ3JnYmEoJ1xuICAgICAgICArIHBhcnNlSW50KChiZWdpblswXSArIHBvcyAqIChlbmRbMF0gLSBiZWdpblswXSkpLCAxMCkgKyAnLCdcbiAgICAgICAgKyBwYXJzZUludCgoYmVnaW5bMV0gKyBwb3MgKiAoZW5kWzFdIC0gYmVnaW5bMV0pKSwgMTApICsgJywnXG4gICAgICAgICsgcGFyc2VJbnQoKGJlZ2luWzJdICsgcG9zICogKGVuZFsyXSAtIGJlZ2luWzJdKSksIDEwKTtcblxuICAgIGNvbG9yICs9ICcsJyArIChiZWdpbiAmJiBlbmQgPyBwYXJzZUZsb2F0KGJlZ2luWzNdICsgcG9zICogKGVuZFszXSAtIGJlZ2luWzNdKSkgOiAxKTtcbiAgICBjb2xvciArPSAnKSc7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIGNvbG9yIGZyb20gb25lIHRvIGFub3RoZXIgd2l0aGluIGNlcnRhaW4gcGVyaW9kIG9mIHRpbWUsIGludm9raW5nIGNhbGxiYWNrcyBhcyB2YWx1ZSBpcyBiZWluZyBjaGFuZ2VkLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZyb21Db2xvciBUaGUgc3RhcnRpbmcgY29sb3IgaW4gaGV4IG9yIHJnYihhKSBmb3JtYXQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0b0NvbG9yIFRoZSBzdGFydGluZyBjb2xvciBpbiBoZXggb3IgcmdiKGEpIGZvcm1hdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbl0gRHVyYXRpb24gb2YgY2hhbmdlIChpbiBtcykuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQW5pbWF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25DaGFuZ2VdIENhbGxiYWNrOyBpbnZva2VkIG9uIGV2ZXJ5IHZhbHVlIGNoYW5nZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkNvbXBsZXRlXSBDYWxsYmFjazsgaW52b2tlZCB3aGVuIHZhbHVlIGNoYW5nZSBpcyBjb21wbGV0ZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY29sb3JFYXNpbmddIEVhc2luZyBmdW5jdGlvbi4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gb25seSB0YWtlIHR3byBhcmd1bWVudHMgKGN1cnJlbnRUaW1lLCBkdXJhdGlvbikuIFRodXMgdGhlIHJlZ3VsYXIgYW5pbWF0aW9uIGVhc2luZyBmdW5jdGlvbnMgY2Fubm90IGJlIHVzZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmFib3J0XSBBZGRpdGlvbmFsIGZ1bmN0aW9uIHdpdGggbG9naWMuIElmIHJldHVybnMgdHJ1ZSwgb25Db21wbGV0ZSBpcyBjYWxsZWQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYWJvcnQgZnVuY3Rpb25cbiAgICovXG4gIGZ1bmN0aW9uIGFuaW1hdGVDb2xvcihmcm9tQ29sb3IsIHRvQ29sb3IsIGR1cmF0aW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIHN0YXJ0Q29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGZyb21Db2xvcikuZ2V0U291cmNlKCksXG4gICAgICAgIGVuZENvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih0b0NvbG9yKS5nZXRTb3VyY2UoKSxcbiAgICAgICAgb3JpZ2luYWxPbkNvbXBsZXRlID0gb3B0aW9ucy5vbkNvbXBsZXRlLFxuICAgICAgICBvcmlnaW5hbE9uQ2hhbmdlID0gb3B0aW9ucy5vbkNoYW5nZTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHJldHVybiBmYWJyaWMudXRpbC5hbmltYXRlKGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQob3B0aW9ucywge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uIHx8IDUwMCxcbiAgICAgIHN0YXJ0VmFsdWU6IHN0YXJ0Q29sb3IsXG4gICAgICBlbmRWYWx1ZTogZW5kQ29sb3IsXG4gICAgICBieVZhbHVlOiBlbmRDb2xvcixcbiAgICAgIGVhc2luZzogZnVuY3Rpb24gKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBieVZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICB2YXIgcG9zVmFsdWUgPSBvcHRpb25zLmNvbG9yRWFzaW5nXG4gICAgICAgICAgPyBvcHRpb25zLmNvbG9yRWFzaW5nKGN1cnJlbnRUaW1lLCBkdXJhdGlvbilcbiAgICAgICAgICA6IDEgLSBNYXRoLmNvcyhjdXJyZW50VGltZSAvIGR1cmF0aW9uICogKE1hdGguUEkgLyAyKSk7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVDb2xvcihzdGFydFZhbHVlLCBieVZhbHVlLCBwb3NWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgLy8gaGFzIHRvIHRha2UgaW4gYWNjb3VudCBmb3IgY29sb3IgcmVzdG9yaW5nO1xuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oY3VycmVudCwgdmFsdWVQZXJjLCB0aW1lUGVyYykge1xuICAgICAgICBpZiAob3JpZ2luYWxPbkNvbXBsZXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsT25Db21wbGV0ZShcbiAgICAgICAgICAgIGNhbGN1bGF0ZUNvbG9yKGVuZENvbG9yLCBlbmRDb2xvciwgMCksXG4gICAgICAgICAgICB2YWx1ZVBlcmMsXG4gICAgICAgICAgICB0aW1lUGVyY1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24oY3VycmVudCwgdmFsdWVQZXJjLCB0aW1lUGVyYykge1xuICAgICAgICBpZiAob3JpZ2luYWxPbkNoYW5nZSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxPbkNoYW5nZShcbiAgICAgICAgICAgICAgY2FsY3VsYXRlQ29sb3IoY3VycmVudCwgY3VycmVudCwgMCksXG4gICAgICAgICAgICAgIHZhbHVlUGVyYyxcbiAgICAgICAgICAgICAgdGltZVBlcmNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9yaWdpbmFsT25DaGFuZ2UoY3VycmVudCwgdmFsdWVQZXJjLCB0aW1lUGVyYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICBmYWJyaWMudXRpbC5hbmltYXRlQ29sb3IgPSBhbmltYXRlQ29sb3I7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZShhLCBjLCBwLCBzKSB7XG4gICAgaWYgKGEgPCBNYXRoLmFicyhjKSkge1xuICAgICAgYSA9IGM7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy9oYW5kbGUgdGhlIDAvMCBjYXNlOlxuICAgICAgaWYgKGMgPT09IDAgJiYgYSA9PT0gMCkge1xuICAgICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKGMgLyBhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYTogYSwgYzogYywgcDogcCwgczogcyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZWxhc3RpYyhvcHRzLCB0LCBkKSB7XG4gICAgcmV0dXJuIG9wdHMuYSAqXG4gICAgICBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqXG4gICAgICBNYXRoLnNpbiggKHQgKiBkIC0gb3B0cy5zKSAqICgyICogTWF0aC5QSSkgLyBvcHRzLnAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdWJpYyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0Q3ViaWModCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1YmljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRDdWJpYyh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICogdCArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiB0ICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1YXJ0aWMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5RdWFydCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICogdCArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVhcnRpYyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0UXVhcnQodCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCAqIHQgLSAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVhcnRpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0UXVhcnQodCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCAqIHQgKiB0ICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIC1jIC8gMiAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAtIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWludGljIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluUXVpbnQodCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCAqIHQgKiB0ICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWludGljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRRdWludCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKiB0ICogdCArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWludGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRRdWludCh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKiB0ICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW51c29pZGFsIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluU2luZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jICogTWF0aC5jb3ModCAvIGQgKiAoTWF0aC5QSSAvIDIpKSArIGMgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbnVzb2lkYWwgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dFNpbmUodCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogTWF0aC5zaW4odCAvIGQgKiAoTWF0aC5QSSAvIDIpKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogU2ludXNvaWRhbCBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0U2luZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jIC8gMiAqIChNYXRoLmNvcyhNYXRoLlBJICogdCAvIGQpIC0gMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9uZW50aWFsIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluRXhwbyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuICh0ID09PSAwKSA/IGIgOiBjICogTWF0aC5wb3coMiwgMTAgKiAodCAvIGQgLSAxKSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9uZW50aWFsIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRFeHBvKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gKHQgPT09IGQpID8gYiArIGMgOiBjICogKC1NYXRoLnBvdygyLCAtMTAgKiB0IC8gZCkgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRXhwb25lbnRpYWwgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEV4cG8odCwgYiwgYywgZCkge1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgaWYgKHQgPT09IGQpIHtcbiAgICAgIHJldHVybiBiICsgYztcbiAgICB9XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoLU1hdGgucG93KDIsIC0xMCAqIC0tdCkgKyAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ2lyY3VsYXIgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5DaXJjKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgKiAoTWF0aC5zcXJ0KDEgLSAodCAvPSBkKSAqIHQpIC0gMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIENpcmN1bGFyIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRDaXJjKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqIE1hdGguc3FydCgxIC0gKHQgPSB0IC8gZCAtIDEpICogdCkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIENpcmN1bGFyIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRDaXJjKHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIC1jIC8gMiAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbGFzdGljIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluRWxhc3RpYyh0LCBiLCBjLCBkKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4LCBwID0gMCwgYSA9IGM7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICB0IC89IGQ7XG4gICAgaWYgKHQgPT09IDEpIHtcbiAgICAgIHJldHVybiBiICsgYztcbiAgICB9XG4gICAgaWYgKCFwKSB7XG4gICAgICBwID0gZCAqIDAuMztcbiAgICB9XG4gICAgdmFyIG9wdHMgPSBub3JtYWxpemUoYSwgYywgcCwgcyk7XG4gICAgcmV0dXJuIC1lbGFzdGljKG9wdHMsIHQsIGQpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbGFzdGljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRFbGFzdGljKHQsIGIsIGMsIGQpIHtcbiAgICB2YXIgcyA9IDEuNzAxNTgsIHAgPSAwLCBhID0gYztcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHQgLz0gZDtcbiAgICBpZiAodCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogMC4zO1xuICAgIH1cbiAgICB2YXIgb3B0cyA9IG5vcm1hbGl6ZShhLCBjLCBwLCBzKTtcbiAgICByZXR1cm4gb3B0cy5hICogTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAqIGQgLSBvcHRzLnMpICogKDIgKiBNYXRoLlBJKSAvIG9wdHMucCApICsgb3B0cy5jICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbGFzdGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRFbGFzdGljKHQsIGIsIGMsIGQpIHtcbiAgICB2YXIgcyA9IDEuNzAxNTgsIHAgPSAwLCBhID0gYztcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPT09IDIpIHtcbiAgICAgIHJldHVybiBiICsgYztcbiAgICB9XG4gICAgaWYgKCFwKSB7XG4gICAgICBwID0gZCAqICgwLjMgKiAxLjUpO1xuICAgIH1cbiAgICB2YXIgb3B0cyA9IG5vcm1hbGl6ZShhLCBjLCBwLCBzKTtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiAtMC41ICogZWxhc3RpYyhvcHRzLCB0LCBkKSArIGI7XG4gICAgfVxuICAgIHJldHVybiBvcHRzLmEgKiBNYXRoLnBvdygyLCAtMTAgKiAodCAtPSAxKSkgKlxuICAgICAgTWF0aC5zaW4oKHQgKiBkIC0gb3B0cy5zKSAqICgyICogTWF0aC5QSSkgLyBvcHRzLnAgKSAqIDAuNSArIG9wdHMuYyArIGI7XG4gIH1cblxuICAvKipcbiAgICogQmFja3dhcmRzIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluQmFjayh0LCBiLCBjLCBkLCBzKSB7XG4gICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcyA9IDEuNzAxNTg7XG4gICAgfVxuICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogKChzICsgMSkgKiB0IC0gcykgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0QmFjayh0LCBiLCBjLCBkLCBzKSB7XG4gICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcyA9IDEuNzAxNTg7XG4gICAgfVxuICAgIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYWNrd2FyZHMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEJhY2sodCwgYiwgYywgZCwgcykge1xuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHMgPSAxLjcwMTU4O1xuICAgIH1cbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogKHQgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCAtIHMpKSArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0ICsgcykgKyAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQm91bmNpbmcgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5Cb3VuY2UodCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjIC0gZWFzZU91dEJvdW5jZSAoZCAtIHQsIDAsIGMsIGQpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCb3VuY2luZyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0Qm91bmNlKHQsIGIsIGMsIGQpIHtcbiAgICBpZiAoKHQgLz0gZCkgPCAoMSAvIDIuNzUpKSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiB0ICogdCkgKyBiO1xuICAgIH1cbiAgICBlbHNlIGlmICh0IDwgKDIgLyAyLjc1KSkge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDEuNSAvIDIuNzUpKSAqIHQgKyAwLjc1KSArIGI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHQgPCAoMi41IC8gMi43NSkpIHtcbiAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09ICgyLjI1IC8gMi43NSkpICogdCArIDAuOTM3NSkgKyBiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09ICgyLjYyNSAvIDIuNzUpKSAqIHQgKyAwLjk4NDM3NSkgKyBiO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCb3VuY2luZyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0Qm91bmNlKHQsIGIsIGMsIGQpIHtcbiAgICBpZiAodCA8IGQgLyAyKSB7XG4gICAgICByZXR1cm4gZWFzZUluQm91bmNlICh0ICogMiwgMCwgYywgZCkgKiAwLjUgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gZWFzZU91dEJvdW5jZSh0ICogMiAtIGQsIDAsIGMsIGQpICogMC41ICsgYyAqIDAuNSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRWFzaW5nIGZ1bmN0aW9uc1xuICAgKiBTZWUgPGEgaHJlZj1cImh0dHA6Ly9naXptYS5jb20vZWFzaW5nL1wiPkVhc2luZyBFcXVhdGlvbnMgYnkgUm9iZXJ0IFBlbm5lcjwvYT5cbiAgICogQG5hbWVzcGFjZSBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmYWJyaWMudXRpbC5lYXNlID0ge1xuXG4gICAgLyoqXG4gICAgICogUXVhZHJhdGljIGVhc2luZyBpblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAgICovXG4gICAgZWFzZUluUXVhZDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBRdWFkcmF0aWMgZWFzaW5nIG91dFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAgICovXG4gICAgZWFzZU91dFF1YWQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiAtYyAqICh0IC89IGQpICogKHQgLSAyKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1YWRyYXRpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAgICovXG4gICAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgdCAvPSAoZCAvIDIpO1xuICAgICAgaWYgKHQgPCAxKSB7XG4gICAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICsgYjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtYyAvIDIgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSkgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDdWJpYyBlYXNpbmcgaW5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgICAqL1xuICAgIGVhc2VJbkN1YmljOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKyBiO1xuICAgIH0sXG5cbiAgICBlYXNlT3V0Q3ViaWM6IGVhc2VPdXRDdWJpYyxcbiAgICBlYXNlSW5PdXRDdWJpYzogZWFzZUluT3V0Q3ViaWMsXG4gICAgZWFzZUluUXVhcnQ6IGVhc2VJblF1YXJ0LFxuICAgIGVhc2VPdXRRdWFydDogZWFzZU91dFF1YXJ0LFxuICAgIGVhc2VJbk91dFF1YXJ0OiBlYXNlSW5PdXRRdWFydCxcbiAgICBlYXNlSW5RdWludDogZWFzZUluUXVpbnQsXG4gICAgZWFzZU91dFF1aW50OiBlYXNlT3V0UXVpbnQsXG4gICAgZWFzZUluT3V0UXVpbnQ6IGVhc2VJbk91dFF1aW50LFxuICAgIGVhc2VJblNpbmU6IGVhc2VJblNpbmUsXG4gICAgZWFzZU91dFNpbmU6IGVhc2VPdXRTaW5lLFxuICAgIGVhc2VJbk91dFNpbmU6IGVhc2VJbk91dFNpbmUsXG4gICAgZWFzZUluRXhwbzogZWFzZUluRXhwbyxcbiAgICBlYXNlT3V0RXhwbzogZWFzZU91dEV4cG8sXG4gICAgZWFzZUluT3V0RXhwbzogZWFzZUluT3V0RXhwbyxcbiAgICBlYXNlSW5DaXJjOiBlYXNlSW5DaXJjLFxuICAgIGVhc2VPdXRDaXJjOiBlYXNlT3V0Q2lyYyxcbiAgICBlYXNlSW5PdXRDaXJjOiBlYXNlSW5PdXRDaXJjLFxuICAgIGVhc2VJbkVsYXN0aWM6IGVhc2VJbkVsYXN0aWMsXG4gICAgZWFzZU91dEVsYXN0aWM6IGVhc2VPdXRFbGFzdGljLFxuICAgIGVhc2VJbk91dEVsYXN0aWM6IGVhc2VJbk91dEVsYXN0aWMsXG4gICAgZWFzZUluQmFjazogZWFzZUluQmFjayxcbiAgICBlYXNlT3V0QmFjazogZWFzZU91dEJhY2ssXG4gICAgZWFzZUluT3V0QmFjazogZWFzZUluT3V0QmFjayxcbiAgICBlYXNlSW5Cb3VuY2U6IGVhc2VJbkJvdW5jZSxcbiAgICBlYXNlT3V0Qm91bmNlOiBlYXNlT3V0Qm91bmNlLFxuICAgIGVhc2VJbk91dEJvdW5jZTogZWFzZUluT3V0Qm91bmNlXG4gIH07XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogQG5hbWUgZmFicmljXG4gICAqIEBuYW1lc3BhY2VcbiAgICovXG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lLFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICBwYXJzZVVuaXQgPSBmYWJyaWMudXRpbC5wYXJzZVVuaXQsXG4gICAgICBtdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyxcblxuICAgICAgc3ZnVmFsaWRUYWdOYW1lcyA9IFsncGF0aCcsICdjaXJjbGUnLCAncG9seWdvbicsICdwb2x5bGluZScsICdlbGxpcHNlJywgJ3JlY3QnLCAnbGluZScsXG4gICAgICAgICdpbWFnZScsICd0ZXh0J10sXG4gICAgICBzdmdWaWV3Qm94RWxlbWVudHMgPSBbJ3N5bWJvbCcsICdpbWFnZScsICdtYXJrZXInLCAncGF0dGVybicsICd2aWV3JywgJ3N2ZyddLFxuICAgICAgc3ZnSW52YWxpZEFuY2VzdG9ycyA9IFsncGF0dGVybicsICdkZWZzJywgJ3N5bWJvbCcsICdtZXRhZGF0YScsICdjbGlwUGF0aCcsICdtYXNrJywgJ2Rlc2MnXSxcbiAgICAgIHN2Z1ZhbGlkUGFyZW50cyA9IFsnc3ltYm9sJywgJ2cnLCAnYScsICdzdmcnLCAnY2xpcFBhdGgnLCAnZGVmcyddLFxuXG4gICAgICBhdHRyaWJ1dGVzTWFwID0ge1xuICAgICAgICBjeDogICAgICAgICAgICAgICAgICAgJ2xlZnQnLFxuICAgICAgICB4OiAgICAgICAgICAgICAgICAgICAgJ2xlZnQnLFxuICAgICAgICByOiAgICAgICAgICAgICAgICAgICAgJ3JhZGl1cycsXG4gICAgICAgIGN5OiAgICAgICAgICAgICAgICAgICAndG9wJyxcbiAgICAgICAgeTogICAgICAgICAgICAgICAgICAgICd0b3AnLFxuICAgICAgICBkaXNwbGF5OiAgICAgICAgICAgICAgJ3Zpc2libGUnLFxuICAgICAgICB2aXNpYmlsaXR5OiAgICAgICAgICAgJ3Zpc2libGUnLFxuICAgICAgICB0cmFuc2Zvcm06ICAgICAgICAgICAgJ3RyYW5zZm9ybU1hdHJpeCcsXG4gICAgICAgICdmaWxsLW9wYWNpdHknOiAgICAgICAnZmlsbE9wYWNpdHknLFxuICAgICAgICAnZmlsbC1ydWxlJzogICAgICAgICAgJ2ZpbGxSdWxlJyxcbiAgICAgICAgJ2ZvbnQtZmFtaWx5JzogICAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICAgJ2ZvbnQtc2l6ZSc6ICAgICAgICAgICdmb250U2l6ZScsXG4gICAgICAgICdmb250LXN0eWxlJzogICAgICAgICAnZm9udFN0eWxlJyxcbiAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogICAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICAgJ2xldHRlci1zcGFjaW5nJzogICAgICdjaGFyU3BhY2luZycsXG4gICAgICAgICdwYWludC1vcmRlcic6ICAgICAgICAncGFpbnRGaXJzdCcsXG4gICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogICAnc3Ryb2tlRGFzaEFycmF5JyxcbiAgICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogICdzdHJva2VEYXNoT2Zmc2V0JyxcbiAgICAgICAgJ3N0cm9rZS1saW5lY2FwJzogICAgICdzdHJva2VMaW5lQ2FwJyxcbiAgICAgICAgJ3N0cm9rZS1saW5lam9pbic6ICAgICdzdHJva2VMaW5lSm9pbicsXG4gICAgICAgICdzdHJva2UtbWl0ZXJsaW1pdCc6ICAnc3Ryb2tlTWl0ZXJMaW1pdCcsXG4gICAgICAgICdzdHJva2Utb3BhY2l0eSc6ICAgICAnc3Ryb2tlT3BhY2l0eScsXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiAgICAgICAnc3Ryb2tlV2lkdGgnLFxuICAgICAgICAndGV4dC1kZWNvcmF0aW9uJzogICAgJ3RleHREZWNvcmF0aW9uJyxcbiAgICAgICAgJ3RleHQtYW5jaG9yJzogICAgICAgICd0ZXh0QW5jaG9yJyxcbiAgICAgICAgb3BhY2l0eTogICAgICAgICAgICAgICdvcGFjaXR5JyxcbiAgICAgICAgJ2NsaXAtcGF0aCc6ICAgICAgICAgICdjbGlwUGF0aCcsXG4gICAgICAgICdjbGlwLXJ1bGUnOiAgICAgICAgICAnY2xpcFJ1bGUnLFxuICAgICAgICAndmVjdG9yLWVmZmVjdCc6ICAgICAgJ3N0cm9rZVVuaWZvcm0nLFxuICAgICAgICAnaW1hZ2UtcmVuZGVyaW5nJzogICAgJ2ltYWdlU21vb3RoaW5nJyxcbiAgICAgIH0sXG5cbiAgICAgIGNvbG9yQXR0cmlidXRlcyA9IHtcbiAgICAgICAgc3Ryb2tlOiAnc3Ryb2tlT3BhY2l0eScsXG4gICAgICAgIGZpbGw6ICAgJ2ZpbGxPcGFjaXR5J1xuICAgICAgfSxcblxuICAgICAgZlNpemUgPSAnZm9udC1zaXplJywgY1BhdGggPSAnY2xpcC1wYXRoJztcblxuICBmYWJyaWMuc3ZnVmFsaWRUYWdOYW1lc1JlZ0V4ID0gZ2V0U3ZnUmVnZXgoc3ZnVmFsaWRUYWdOYW1lcyk7XG4gIGZhYnJpYy5zdmdWaWV3Qm94RWxlbWVudHNSZWdFeCA9IGdldFN2Z1JlZ2V4KHN2Z1ZpZXdCb3hFbGVtZW50cyk7XG4gIGZhYnJpYy5zdmdJbnZhbGlkQW5jZXN0b3JzUmVnRXggPSBnZXRTdmdSZWdleChzdmdJbnZhbGlkQW5jZXN0b3JzKTtcbiAgZmFicmljLnN2Z1ZhbGlkUGFyZW50c1JlZ0V4ID0gZ2V0U3ZnUmVnZXgoc3ZnVmFsaWRQYXJlbnRzKTtcblxuICBmYWJyaWMuY3NzUnVsZXMgPSB7IH07XG4gIGZhYnJpYy5ncmFkaWVudERlZnMgPSB7IH07XG4gIGZhYnJpYy5jbGlwUGF0aHMgPSB7IH07XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplQXR0cihhdHRyKSB7XG4gICAgLy8gdHJhbnNmb3JtIGF0dHJpYnV0ZSBuYW1lc1xuICAgIGlmIChhdHRyIGluIGF0dHJpYnV0ZXNNYXApIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzTWFwW2F0dHJdO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKGF0dHIsIHZhbHVlLCBwYXJlbnRBdHRyaWJ1dGVzLCBmb250U2l6ZSkge1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSksIHBhcnNlZDtcblxuICAgIGlmICgoYXR0ciA9PT0gJ2ZpbGwnIHx8IGF0dHIgPT09ICdzdHJva2UnKSAmJiB2YWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnc3Ryb2tlVW5pZm9ybScpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT09ICdub24tc2NhbGluZy1zdHJva2UnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3N0cm9rZURhc2hBcnJheScpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLywvZywgJyAnKS5zcGxpdCgvXFxzKy8pLm1hcChwYXJzZUZsb2F0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3RyYW5zZm9ybU1hdHJpeCcpIHtcbiAgICAgIGlmIChwYXJlbnRBdHRyaWJ1dGVzICYmIHBhcmVudEF0dHJpYnV0ZXMudHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICAgIHZhbHVlID0gbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhcbiAgICAgICAgICBwYXJlbnRBdHRyaWJ1dGVzLnRyYW5zZm9ybU1hdHJpeCwgZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAndmlzaWJsZScpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgIT09ICdub25lJyAmJiB2YWx1ZSAhPT0gJ2hpZGRlbic7XG4gICAgICAvLyBkaXNwbGF5PW5vbmUgb24gcGFyZW50IGVsZW1lbnQgYWx3YXlzIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBjaGlsZCBlbGVtZW50XG4gICAgICBpZiAocGFyZW50QXR0cmlidXRlcyAmJiBwYXJlbnRBdHRyaWJ1dGVzLnZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdvcGFjaXR5Jykge1xuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIGlmIChwYXJlbnRBdHRyaWJ1dGVzICYmIHR5cGVvZiBwYXJlbnRBdHRyaWJ1dGVzLm9wYWNpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhbHVlICo9IHBhcmVudEF0dHJpYnV0ZXMub3BhY2l0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3RleHRBbmNob3InIC8qIHRleHQtYW5jaG9yICovKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlID09PSAnc3RhcnQnID8gJ2xlZnQnIDogdmFsdWUgPT09ICdlbmQnID8gJ3JpZ2h0JyA6ICdjZW50ZXInO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnY2hhclNwYWNpbmcnKSB7XG4gICAgICAvLyBwYXJzZVVuaXQgcmV0dXJucyBweCBhbmQgd2UgY29udmVydCBpdCB0byBlbVxuICAgICAgcGFyc2VkID0gcGFyc2VVbml0KHZhbHVlLCBmb250U2l6ZSkgLyBmb250U2l6ZSAqIDEwMDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdwYWludEZpcnN0Jykge1xuICAgICAgdmFyIGZpbGxJbmRleCA9IHZhbHVlLmluZGV4T2YoJ2ZpbGwnKTtcbiAgICAgIHZhciBzdHJva2VJbmRleCA9IHZhbHVlLmluZGV4T2YoJ3N0cm9rZScpO1xuICAgICAgdmFyIHZhbHVlID0gJ2ZpbGwnO1xuICAgICAgaWYgKGZpbGxJbmRleCA+IC0xICYmIHN0cm9rZUluZGV4ID4gLTEgJiYgc3Ryb2tlSW5kZXggPCBmaWxsSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSAnc3Ryb2tlJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZpbGxJbmRleCA9PT0gLTEgJiYgc3Ryb2tlSW5kZXggPiAtMSkge1xuICAgICAgICB2YWx1ZSA9ICdzdHJva2UnO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnaHJlZicgfHwgYXR0ciA9PT0gJ3hsaW5rOmhyZWYnIHx8IGF0dHIgPT09ICdmb250Jykge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnaW1hZ2VTbW9vdGhpbmcnKSB7XG4gICAgICByZXR1cm4gKHZhbHVlID09PSAnb3B0aW1pemVRdWFsaXR5Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcGFyc2VkID0gaXNBcnJheSA/IHZhbHVlLm1hcChwYXJzZVVuaXQpIDogcGFyc2VVbml0KHZhbHVlLCBmb250U2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICghaXNBcnJheSAmJiBpc05hTihwYXJzZWQpID8gdmFsdWUgOiBwYXJzZWQpO1xuICB9XG5cbiAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gIGZ1bmN0aW9uIGdldFN2Z1JlZ2V4KGFycikge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKCdeKCcgKyBhcnIuam9pbignfCcpICsgJylcXFxcYicsICdpJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgQXJyYXkgb2YgYXR0cmlidXRlcyB0byBwYXJzZVxuICAgKi9cbiAgZnVuY3Rpb24gX3NldFN0cm9rZUZpbGxPcGFjaXR5KGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKHZhciBhdHRyIGluIGNvbG9yQXR0cmlidXRlcykge1xuXG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXNbY29sb3JBdHRyaWJ1dGVzW2F0dHJdXSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXR0cmlidXRlc1thdHRyXSA9PT0gJycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlc1thdHRyXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKCFmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVthdHRyXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0cl0gPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVthdHRyXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJpYnV0ZXNbYXR0cl0uaW5kZXhPZigndXJsKCcpID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgYXR0cmlidXRlc1thdHRyXSA9IGNvbG9yLnNldEFscGhhKHRvRml4ZWQoY29sb3IuZ2V0QWxwaGEoKSAqIGF0dHJpYnV0ZXNbY29sb3JBdHRyaWJ1dGVzW2F0dHJdXSwgMikpLnRvUmdiYSgpO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2dldE11bHRpcGxlTm9kZXMoZG9jLCBub2RlTmFtZXMpIHtcbiAgICB2YXIgbm9kZU5hbWUsIG5vZGVBcnJheSA9IFtdLCBub2RlTGlzdCwgaSwgbGVuO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGVOYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbm9kZU5hbWUgPSBub2RlTmFtZXNbaV07XG4gICAgICBub2RlTGlzdCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShub2RlTmFtZSk7XG4gICAgICBub2RlQXJyYXkgPSBub2RlQXJyYXkuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5vZGVMaXN0KSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlQXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdmFsdWVzXG4gICAqIEBzdGF0aWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZVZhbHVlIFN0cmluZyBjb250YWluaW5nIGF0dHJpYnV0ZSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgNiBlbGVtZW50cyByZXByZXNlbnRpbmcgdHJhbnNmb3JtYXRpb24gbWF0cml4XG4gICAqL1xuICBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gcm90YXRlTWF0cml4KG1hdHJpeCwgYXJncykge1xuICAgICAgdmFyIGNvcyA9IGZhYnJpYy51dGlsLmNvcyhhcmdzWzBdKSwgc2luID0gZmFicmljLnV0aWwuc2luKGFyZ3NbMF0pLFxuICAgICAgICAgIHggPSAwLCB5ID0gMDtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICB4ID0gYXJnc1sxXTtcbiAgICAgICAgeSA9IGFyZ3NbMl07XG4gICAgICB9XG5cbiAgICAgIG1hdHJpeFswXSA9IGNvcztcbiAgICAgIG1hdHJpeFsxXSA9IHNpbjtcbiAgICAgIG1hdHJpeFsyXSA9IC1zaW47XG4gICAgICBtYXRyaXhbM10gPSBjb3M7XG4gICAgICBtYXRyaXhbNF0gPSB4IC0gKGNvcyAqIHggLSBzaW4gKiB5KTtcbiAgICAgIG1hdHJpeFs1XSA9IHkgLSAoc2luICogeCArIGNvcyAqIHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYWxlTWF0cml4KG1hdHJpeCwgYXJncykge1xuICAgICAgdmFyIG11bHRpcGxpZXJYID0gYXJnc1swXSxcbiAgICAgICAgICBtdWx0aXBsaWVyWSA9IChhcmdzLmxlbmd0aCA9PT0gMikgPyBhcmdzWzFdIDogYXJnc1swXTtcblxuICAgICAgbWF0cml4WzBdID0gbXVsdGlwbGllclg7XG4gICAgICBtYXRyaXhbM10gPSBtdWx0aXBsaWVyWTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2V3TWF0cml4KG1hdHJpeCwgYXJncywgcG9zKSB7XG4gICAgICBtYXRyaXhbcG9zXSA9IE1hdGgudGFuKGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMoYXJnc1swXSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIG1hdHJpeFs0XSA9IGFyZ3NbMF07XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgbWF0cml4WzVdID0gYXJnc1sxXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZGVudGl0eSBtYXRyaXhcbiAgICB2YXIgaU1hdHJpeCA9IGZhYnJpYy5pTWF0cml4LFxuXG4gICAgICAgIC8vID09IGJlZ2luIHRyYW5zZm9ybSByZWdleHBcbiAgICAgICAgbnVtYmVyID0gZmFicmljLnJlTnVtLFxuXG4gICAgICAgIGNvbW1hV3NwID0gZmFicmljLmNvbW1hV3NwLFxuXG4gICAgICAgIHNrZXdYID0gJyg/Oihza2V3WClcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcKSknLFxuXG4gICAgICAgIHNrZXdZID0gJyg/Oihza2V3WSlcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcKSknLFxuXG4gICAgICAgIHJvdGF0ZSA9ICcoPzoocm90YXRlKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKSg/OicgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpJyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJykpP1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgc2NhbGUgPSAnKD86KHNjYWxlKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKSg/OicgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpKT9cXFxccypcXFxcKSknLFxuXG4gICAgICAgIHRyYW5zbGF0ZSA9ICcoPzoodHJhbnNsYXRlKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKSg/OicgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpKT9cXFxccypcXFxcKSknLFxuXG4gICAgICAgIG1hdHJpeCA9ICcoPzoobWF0cml4KVxcXFxzKlxcXFwoXFxcXHMqJyArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgKyBjb21tYVdzcCArXG4gICAgICAgICAgICAgICAgICAnKCcgKyBudW1iZXIgKyAnKScgK1xuICAgICAgICAgICAgICAgICAgJ1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgdHJhbnNmb3JtID0gJyg/OicgK1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXggKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGUgKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICBzY2FsZSArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZSArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHNrZXdYICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgc2tld1kgK1xuICAgICAgICAgICAgICAgICAgICAnKScsXG5cbiAgICAgICAgdHJhbnNmb3JtcyA9ICcoPzonICsgdHJhbnNmb3JtICsgJyg/OicgKyBjb21tYVdzcCArICcqJyArIHRyYW5zZm9ybSArICcpKicgKyAnKScsXG5cbiAgICAgICAgdHJhbnNmb3JtTGlzdCA9ICdeXFxcXHMqKD86JyArIHRyYW5zZm9ybXMgKyAnPylcXFxccyokJyxcblxuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjVHJhbnNmb3JtQXR0cmlidXRlXG4gICAgICAgIHJlVHJhbnNmb3JtTGlzdCA9IG5ldyBSZWdFeHAodHJhbnNmb3JtTGlzdCksXG4gICAgICAgIC8vID09IGVuZCB0cmFuc2Zvcm0gcmVnZXhwXG5cbiAgICAgICAgcmVUcmFuc2Zvcm0gPSBuZXcgUmVnRXhwKHRyYW5zZm9ybSwgJ2cnKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhdHRyaWJ1dGVWYWx1ZSkge1xuXG4gICAgICAvLyBzdGFydCB3aXRoIGlkZW50aXR5IG1hdHJpeFxuICAgICAgdmFyIG1hdHJpeCA9IGlNYXRyaXguY29uY2F0KCksXG4gICAgICAgICAgbWF0cmljZXMgPSBbXTtcblxuICAgICAgLy8gcmV0dXJuIGlmIG5vIGFyZ3VtZW50IHdhcyBnaXZlbiBvclxuICAgICAgLy8gYW4gYXJndW1lbnQgZG9lcyBub3QgbWF0Y2ggdHJhbnNmb3JtIGF0dHJpYnV0ZSByZWdleHBcbiAgICAgIGlmICghYXR0cmlidXRlVmFsdWUgfHwgKGF0dHJpYnV0ZVZhbHVlICYmICFyZVRyYW5zZm9ybUxpc3QudGVzdChhdHRyaWJ1dGVWYWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICB9XG5cbiAgICAgIGF0dHJpYnV0ZVZhbHVlLnJlcGxhY2UocmVUcmFuc2Zvcm0sIGZ1bmN0aW9uKG1hdGNoKSB7XG5cbiAgICAgICAgdmFyIG0gPSBuZXcgUmVnRXhwKHRyYW5zZm9ybSkuZXhlYyhtYXRjaCkuZmlsdGVyKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgICAvLyBtYXRjaCAhPT0gJycgJiYgbWF0Y2ggIT0gbnVsbFxuICAgICAgICAgICAgICByZXR1cm4gKCEhbWF0Y2gpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvcGVyYXRpb24gPSBtWzFdLFxuICAgICAgICAgICAgYXJncyA9IG0uc2xpY2UoMikubWFwKHBhcnNlRmxvYXQpO1xuXG4gICAgICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XG4gICAgICAgICAgY2FzZSAndHJhbnNsYXRlJzpcbiAgICAgICAgICAgIHRyYW5zbGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICAgIGFyZ3NbMF0gPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKGFyZ3NbMF0pO1xuICAgICAgICAgICAgcm90YXRlTWF0cml4KG1hdHJpeCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzY2FsZSc6XG4gICAgICAgICAgICBzY2FsZU1hdHJpeChtYXRyaXgsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2tld1gnOlxuICAgICAgICAgICAgc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2tld1knOlxuICAgICAgICAgICAgc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWF0cml4JzpcbiAgICAgICAgICAgIG1hdHJpeCA9IGFyZ3M7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNuYXBzaG90IGN1cnJlbnQgbWF0cml4IGludG8gbWF0cmljZXMgYXJyYXlcbiAgICAgICAgbWF0cmljZXMucHVzaChtYXRyaXguY29uY2F0KCkpO1xuICAgICAgICAvLyByZXNldFxuICAgICAgICBtYXRyaXggPSBpTWF0cml4LmNvbmNhdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjb21iaW5lZE1hdHJpeCA9IG1hdHJpY2VzWzBdO1xuICAgICAgd2hpbGUgKG1hdHJpY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbWF0cmljZXMuc2hpZnQoKTtcbiAgICAgICAgY29tYmluZWRNYXRyaXggPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKGNvbWJpbmVkTWF0cml4LCBtYXRyaWNlc1swXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWRNYXRyaXg7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU3R5bGVTdHJpbmcoc3R5bGUsIG9TdHlsZSkge1xuICAgIHZhciBhdHRyLCB2YWx1ZTtcbiAgICBzdHlsZS5yZXBsYWNlKC87XFxzKiQvLCAnJykuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgdmFyIHBhaXIgPSBjaHVuay5zcGxpdCgnOicpO1xuXG4gICAgICBhdHRyID0gcGFpclswXS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhbHVlID0gIHBhaXJbMV0udHJpbSgpO1xuXG4gICAgICBvU3R5bGVbYXR0cl0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTdHlsZU9iamVjdChzdHlsZSwgb1N0eWxlKSB7XG4gICAgdmFyIGF0dHIsIHZhbHVlO1xuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3R5bGVbcHJvcF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBhdHRyID0gcHJvcC50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFsdWUgPSBzdHlsZVtwcm9wXTtcblxuICAgICAgb1N0eWxlW2F0dHJdID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBnZXRHbG9iYWxTdHlsZXNGb3JFbGVtZW50KGVsZW1lbnQsIHN2Z1VpZCkge1xuICAgIHZhciBzdHlsZXMgPSB7IH07XG4gICAgZm9yICh2YXIgcnVsZSBpbiBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXSkge1xuICAgICAgaWYgKGVsZW1lbnRNYXRjaGVzUnVsZShlbGVtZW50LCBydWxlLnNwbGl0KCcgJykpKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdW3J1bGVdKSB7XG4gICAgICAgICAgc3R5bGVzW3Byb3BlcnR5XSA9IGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdW3J1bGVdW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlc1J1bGUoZWxlbWVudCwgc2VsZWN0b3JzKSB7XG4gICAgdmFyIGZpcnN0TWF0Y2hpbmcsIHBhcmVudE1hdGNoaW5nID0gdHJ1ZTtcbiAgICAvL3N0YXJ0IGZyb20gcmlnaHRtb3N0IHNlbGVjdG9yLlxuICAgIGZpcnN0TWF0Y2hpbmcgPSBzZWxlY3Rvck1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3JzLnBvcCgpKTtcbiAgICBpZiAoZmlyc3RNYXRjaGluZyAmJiBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICBwYXJlbnRNYXRjaGluZyA9IGRvZXNTb21lUGFyZW50TWF0Y2goZWxlbWVudCwgc2VsZWN0b3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0TWF0Y2hpbmcgJiYgcGFyZW50TWF0Y2hpbmcgJiYgKHNlbGVjdG9ycy5sZW5ndGggPT09IDApO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9lc1NvbWVQYXJlbnRNYXRjaChlbGVtZW50LCBzZWxlY3RvcnMpIHtcbiAgICB2YXIgc2VsZWN0b3IsIHBhcmVudE1hdGNoaW5nID0gdHJ1ZTtcbiAgICB3aGlsZSAoZWxlbWVudC5wYXJlbnROb2RlICYmIGVsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICBpZiAocGFyZW50TWF0Y2hpbmcpIHtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvcnMucG9wKCk7XG4gICAgICB9XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgcGFyZW50TWF0Y2hpbmcgPSBzZWxlY3Rvck1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3JzLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2VsZWN0b3JNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZSxcbiAgICAgICAgY2xhc3NOYW1lcyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpLFxuICAgICAgICBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpLCBtYXRjaGVyLCBpO1xuICAgIC8vIGkgY2hlY2sgaWYgYSBzZWxlY3RvciBtYXRjaGVzIHNsaWNpbmcgYXdheSBwYXJ0IGZyb20gaXQuXG4gICAgLy8gaWYgaSBnZXQgZW1wdHkgc3RyaW5nIGkgc2hvdWxkIG1hdGNoXG4gICAgbWF0Y2hlciA9IG5ldyBSZWdFeHAoJ14nICsgbm9kZU5hbWUsICdpJyk7XG4gICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKG1hdGNoZXIsICcnKTtcbiAgICBpZiAoaWQgJiYgc2VsZWN0b3IubGVuZ3RoKSB7XG4gICAgICBtYXRjaGVyID0gbmV3IFJlZ0V4cCgnIycgKyBpZCArICcoPyFbYS16QS1aXFxcXC1dKyknLCAnaScpO1xuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKG1hdGNoZXIsICcnKTtcbiAgICB9XG4gICAgaWYgKGNsYXNzTmFtZXMgJiYgc2VsZWN0b3IubGVuZ3RoKSB7XG4gICAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lcy5zcGxpdCgnICcpO1xuICAgICAgZm9yIChpID0gY2xhc3NOYW1lcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgbWF0Y2hlciA9IG5ldyBSZWdFeHAoJ1xcXFwuJyArIGNsYXNzTmFtZXNbaV0gKyAnKD8hW2EtekEtWlxcXFwtXSspJywgJ2knKTtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKG1hdGNoZXIsICcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9yLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiB0byBzdXBwb3J0IElFOCBtaXNzaW5nIGdldEVsZW1lbnRCeUlkIG9uIFNWR2RvY3VtZW50IGFuZCBvbiBub2RlIHhtbERPTVxuICAgKi9cbiAgZnVuY3Rpb24gZWxlbWVudEJ5SWQoZG9jLCBpZCkge1xuICAgIHZhciBlbDtcbiAgICBkb2MuZ2V0RWxlbWVudEJ5SWQgJiYgKGVsID0gZG9jLmdldEVsZW1lbnRCeUlkKGlkKSk7XG4gICAgaWYgKGVsKSB7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICAgIHZhciBub2RlLCBpLCBsZW4sIG5vZGVsaXN0ID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJyk7XG4gICAgZm9yIChpID0gMCwgbGVuID0gbm9kZWxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5vZGUgPSBub2RlbGlzdFtpXTtcbiAgICAgIGlmIChpZCA9PT0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJykpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVVzZURpcmVjdGl2ZXMoZG9jKSB7XG4gICAgdmFyIG5vZGVsaXN0ID0gX2dldE11bHRpcGxlTm9kZXMoZG9jLCBbJ3VzZScsICdzdmc6dXNlJ10pLCBpID0gMDtcbiAgICB3aGlsZSAobm9kZWxpc3QubGVuZ3RoICYmIGkgPCBub2RlbGlzdC5sZW5ndGgpIHtcbiAgICAgIHZhciBlbCA9IG5vZGVsaXN0W2ldLFxuICAgICAgICAgIHhsaW5rQXR0cmlidXRlID0gZWwuZ2V0QXR0cmlidXRlKCd4bGluazpocmVmJykgfHwgZWwuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG5cbiAgICAgIGlmICh4bGlua0F0dHJpYnV0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB4bGluayA9IHhsaW5rQXR0cmlidXRlLnNsaWNlKDEpLFxuICAgICAgICAgIHggPSBlbC5nZXRBdHRyaWJ1dGUoJ3gnKSB8fCAwLFxuICAgICAgICAgIHkgPSBlbC5nZXRBdHRyaWJ1dGUoJ3knKSB8fCAwLFxuICAgICAgICAgIGVsMiA9IGVsZW1lbnRCeUlkKGRvYywgeGxpbmspLmNsb25lTm9kZSh0cnVlKSxcbiAgICAgICAgICBjdXJyZW50VHJhbnMgPSAoZWwyLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykgfHwgJycpICsgJyB0cmFuc2xhdGUoJyArIHggKyAnLCAnICsgeSArICcpJyxcbiAgICAgICAgICBwYXJlbnROb2RlLFxuICAgICAgICAgIG9sZExlbmd0aCA9IG5vZGVsaXN0Lmxlbmd0aCwgYXR0cixcbiAgICAgICAgICBqLFxuICAgICAgICAgIGF0dHJzLFxuICAgICAgICAgIGxlbixcbiAgICAgICAgICBuYW1lc3BhY2UgPSBmYWJyaWMuc3ZnTlM7XG5cbiAgICAgIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbDIpO1xuICAgICAgaWYgKC9ec3ZnJC9pLnRlc3QoZWwyLm5vZGVOYW1lKSkge1xuICAgICAgICB2YXIgZWwzID0gZWwyLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgJ2cnKTtcbiAgICAgICAgZm9yIChqID0gMCwgYXR0cnMgPSBlbDIuYXR0cmlidXRlcywgbGVuID0gYXR0cnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBhdHRyID0gYXR0cnMuaXRlbShqKTtcbiAgICAgICAgICBlbDMuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyLm5vZGVOYW1lLCBhdHRyLm5vZGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZWwyLmZpcnN0Q2hpbGQgIT0gbnVsbFxuICAgICAgICB3aGlsZSAoZWwyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBlbDMuYXBwZW5kQ2hpbGQoZWwyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsMiA9IGVsMztcbiAgICAgIH1cblxuICAgICAgZm9yIChqID0gMCwgYXR0cnMgPSBlbC5hdHRyaWJ1dGVzLCBsZW4gPSBhdHRycy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICBhdHRyID0gYXR0cnMuaXRlbShqKTtcbiAgICAgICAgaWYgKGF0dHIubm9kZU5hbWUgPT09ICd4JyB8fCBhdHRyLm5vZGVOYW1lID09PSAneScgfHxcbiAgICAgICAgICBhdHRyLm5vZGVOYW1lID09PSAneGxpbms6aHJlZicgfHwgYXR0ci5ub2RlTmFtZSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXR0ci5ub2RlTmFtZSA9PT0gJ3RyYW5zZm9ybScpIHtcbiAgICAgICAgICBjdXJyZW50VHJhbnMgPSBhdHRyLm5vZGVWYWx1ZSArICcgJyArIGN1cnJlbnRUcmFucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBlbDIuc2V0QXR0cmlidXRlKGF0dHIubm9kZU5hbWUsIGF0dHIubm9kZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbDIuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBjdXJyZW50VHJhbnMpO1xuICAgICAgZWwyLnNldEF0dHJpYnV0ZSgnaW5zdGFudGlhdGVkX2J5X3VzZScsICcxJyk7XG4gICAgICBlbDIucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgcGFyZW50Tm9kZSA9IGVsLnBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlLnJlcGxhY2VDaGlsZChlbDIsIGVsKTtcbiAgICAgIC8vIHNvbWUgYnJvd3NlcnMgZG8gbm90IHNob3J0ZW4gbm9kZWxpc3QgYWZ0ZXIgcmVwbGFjZUNoaWxkIChJRTgpXG4gICAgICBpZiAobm9kZWxpc3QubGVuZ3RoID09PSBvbGRMZW5ndGgpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9jb29yZHMuaHRtbCNWaWV3Qm94QXR0cmlidXRlXG4gIC8vIG1hdGNoZXMsIGUuZy46ICsxNC41NmUtMTIsIGV0Yy5cbiAgdmFyIHJlVmlld0JveEF0dHJWYWx1ZSA9IG5ldyBSZWdFeHAoXG4gICAgJ14nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyosPycgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKiw/JyArXG4gICAgJ1xcXFxzKignICsgZmFicmljLnJlTnVtICsgJyspXFxcXHMqLD8nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyonICtcbiAgICAnJCdcbiAgKTtcblxuICAvKipcbiAgICogQWRkIGEgPGc+IGVsZW1lbnQgdGhhdCBlbnZlbG9wIGFsbCBjaGlsZCBlbGVtZW50cyBhbmQgbWFrZXMgdGhlIHZpZXdib3ggdHJhbnNmb3JtTWF0cml4IGRlc2NlbmQgb24gYWxsIGVsZW1lbnRzXG4gICAqL1xuICBmdW5jdGlvbiBhcHBseVZpZXdib3hUcmFuc2Zvcm0oZWxlbWVudCkge1xuICAgIGlmICghZmFicmljLnN2Z1ZpZXdCb3hFbGVtZW50c1JlZ0V4LnRlc3QoZWxlbWVudC5ub2RlTmFtZSkpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgdmFyIHZpZXdCb3hBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKSxcbiAgICAgICAgc2NhbGVYID0gMSxcbiAgICAgICAgc2NhbGVZID0gMSxcbiAgICAgICAgbWluWCA9IDAsXG4gICAgICAgIG1pblkgPSAwLFxuICAgICAgICB2aWV3Qm94V2lkdGgsIHZpZXdCb3hIZWlnaHQsIG1hdHJpeCwgZWwsXG4gICAgICAgIHdpZHRoQXR0ciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLFxuICAgICAgICBoZWlnaHRBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpLFxuICAgICAgICB4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3gnKSB8fCAwLFxuICAgICAgICB5ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3knKSB8fCAwLFxuICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKSB8fCAnJyxcbiAgICAgICAgbWlzc2luZ1ZpZXdCb3ggPSAoIXZpZXdCb3hBdHRyIHx8ICEodmlld0JveEF0dHIgPSB2aWV3Qm94QXR0ci5tYXRjaChyZVZpZXdCb3hBdHRyVmFsdWUpKSksXG4gICAgICAgIG1pc3NpbmdEaW1BdHRyID0gKCF3aWR0aEF0dHIgfHwgIWhlaWdodEF0dHIgfHwgd2lkdGhBdHRyID09PSAnMTAwJScgfHwgaGVpZ2h0QXR0ciA9PT0gJzEwMCUnKSxcbiAgICAgICAgdG9CZVBhcnNlZCA9IG1pc3NpbmdWaWV3Qm94ICYmIG1pc3NpbmdEaW1BdHRyLFxuICAgICAgICBwYXJzZWREaW0gPSB7IH0sIHRyYW5zbGF0ZU1hdHJpeCA9ICcnLCB3aWR0aERpZmYgPSAwLCBoZWlnaHREaWZmID0gMDtcblxuICAgIHBhcnNlZERpbS53aWR0aCA9IDA7XG4gICAgcGFyc2VkRGltLmhlaWdodCA9IDA7XG4gICAgcGFyc2VkRGltLnRvQmVQYXJzZWQgPSB0b0JlUGFyc2VkO1xuXG4gICAgaWYgKG1pc3NpbmdWaWV3Qm94KSB7XG4gICAgICBpZiAoKCh4IHx8IHkpICYmIGVsZW1lbnQucGFyZW50Tm9kZSAmJiBlbGVtZW50LnBhcmVudE5vZGUubm9kZU5hbWUgIT09ICcjZG9jdW1lbnQnKSkge1xuICAgICAgICB0cmFuc2xhdGVNYXRyaXggPSAnIHRyYW5zbGF0ZSgnICsgcGFyc2VVbml0KHgpICsgJyAnICsgcGFyc2VVbml0KHkpICsgJykgJztcbiAgICAgICAgbWF0cml4ID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSB8fCAnJykgKyB0cmFuc2xhdGVNYXRyaXg7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBtYXRyaXgpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgneCcpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgneScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b0JlUGFyc2VkKSB7XG4gICAgICByZXR1cm4gcGFyc2VkRGltO1xuICAgIH1cblxuICAgIGlmIChtaXNzaW5nVmlld0JveCkge1xuICAgICAgcGFyc2VkRGltLndpZHRoID0gcGFyc2VVbml0KHdpZHRoQXR0cik7XG4gICAgICBwYXJzZWREaW0uaGVpZ2h0ID0gcGFyc2VVbml0KGhlaWdodEF0dHIpO1xuICAgICAgLy8gc2V0IGEgdHJhbnNmb3JtIGZvciBlbGVtZW50cyB0aGF0IGhhdmUgeCB5IGFuZCBhcmUgaW5uZXIob25seSkgU1ZHc1xuICAgICAgcmV0dXJuIHBhcnNlZERpbTtcbiAgICB9XG4gICAgbWluWCA9IC1wYXJzZUZsb2F0KHZpZXdCb3hBdHRyWzFdKTtcbiAgICBtaW5ZID0gLXBhcnNlRmxvYXQodmlld0JveEF0dHJbMl0pO1xuICAgIHZpZXdCb3hXaWR0aCA9IHBhcnNlRmxvYXQodmlld0JveEF0dHJbM10pO1xuICAgIHZpZXdCb3hIZWlnaHQgPSBwYXJzZUZsb2F0KHZpZXdCb3hBdHRyWzRdKTtcbiAgICBwYXJzZWREaW0ubWluWCA9IG1pblg7XG4gICAgcGFyc2VkRGltLm1pblkgPSBtaW5ZO1xuICAgIHBhcnNlZERpbS52aWV3Qm94V2lkdGggPSB2aWV3Qm94V2lkdGg7XG4gICAgcGFyc2VkRGltLnZpZXdCb3hIZWlnaHQgPSB2aWV3Qm94SGVpZ2h0O1xuICAgIGlmICghbWlzc2luZ0RpbUF0dHIpIHtcbiAgICAgIHBhcnNlZERpbS53aWR0aCA9IHBhcnNlVW5pdCh3aWR0aEF0dHIpO1xuICAgICAgcGFyc2VkRGltLmhlaWdodCA9IHBhcnNlVW5pdChoZWlnaHRBdHRyKTtcbiAgICAgIHNjYWxlWCA9IHBhcnNlZERpbS53aWR0aCAvIHZpZXdCb3hXaWR0aDtcbiAgICAgIHNjYWxlWSA9IHBhcnNlZERpbS5oZWlnaHQgLyB2aWV3Qm94SGVpZ2h0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHBhcnNlZERpbS53aWR0aCA9IHZpZXdCb3hXaWR0aDtcbiAgICAgIHBhcnNlZERpbS5oZWlnaHQgPSB2aWV3Qm94SGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIGRlZmF1bHQgaXMgdG8gcHJlc2VydmUgYXNwZWN0IHJhdGlvXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbyA9IGZhYnJpYy51dGlsLnBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZShwcmVzZXJ2ZUFzcGVjdFJhdGlvKTtcbiAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblggIT09ICdub25lJykge1xuICAgICAgLy90cmFuc2xhdGUgYWxsIGNvbnRhaW5lciBmb3IgdGhlIGVmZmVjdCBvZiBNaWQsIE1pbiwgTWF4XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5tZWV0T3JTbGljZSA9PT0gJ21lZXQnKSB7XG4gICAgICAgIHNjYWxlWSA9IHNjYWxlWCA9IChzY2FsZVggPiBzY2FsZVkgPyBzY2FsZVkgOiBzY2FsZVgpO1xuICAgICAgICAvLyBjYWxjdWxhdGUgYWRkaXRpb25hbCB0cmFuc2xhdGlvbiB0byBtb3ZlIHRoZSB2aWV3Ym94XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5tZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgICBzY2FsZVkgPSBzY2FsZVggPSAoc2NhbGVYID4gc2NhbGVZID8gc2NhbGVYIDogc2NhbGVZKTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIGFkZGl0aW9uYWwgdHJhbnNsYXRpb24gdG8gbW92ZSB0aGUgdmlld2JveFxuICAgICAgfVxuICAgICAgd2lkdGhEaWZmID0gcGFyc2VkRGltLndpZHRoIC0gdmlld0JveFdpZHRoICogc2NhbGVYO1xuICAgICAgaGVpZ2h0RGlmZiA9IHBhcnNlZERpbS5oZWlnaHQgLSB2aWV3Qm94SGVpZ2h0ICogc2NhbGVYO1xuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ25YID09PSAnTWlkJykge1xuICAgICAgICB3aWR0aERpZmYgLz0gMjtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduWSA9PT0gJ01pZCcpIHtcbiAgICAgICAgaGVpZ2h0RGlmZiAvPSAyO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ25YID09PSAnTWluJykge1xuICAgICAgICB3aWR0aERpZmYgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ25ZID09PSAnTWluJykge1xuICAgICAgICBoZWlnaHREaWZmID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2NhbGVYID09PSAxICYmIHNjYWxlWSA9PT0gMSAmJiBtaW5YID09PSAwICYmIG1pblkgPT09IDAgJiYgeCA9PT0gMCAmJiB5ID09PSAwKSB7XG4gICAgICByZXR1cm4gcGFyc2VkRGltO1xuICAgIH1cbiAgICBpZiAoKHggfHwgeSkgJiYgZWxlbWVudC5wYXJlbnROb2RlLm5vZGVOYW1lICE9PSAnI2RvY3VtZW50Jykge1xuICAgICAgdHJhbnNsYXRlTWF0cml4ID0gJyB0cmFuc2xhdGUoJyArIHBhcnNlVW5pdCh4KSArICcgJyArIHBhcnNlVW5pdCh5KSArICcpICc7XG4gICAgfVxuXG4gICAgbWF0cml4ID0gdHJhbnNsYXRlTWF0cml4ICsgJyBtYXRyaXgoJyArIHNjYWxlWCArXG4gICAgICAgICAgICAgICAgICAnIDAnICtcbiAgICAgICAgICAgICAgICAgICcgMCAnICtcbiAgICAgICAgICAgICAgICAgIHNjYWxlWSArICcgJyArXG4gICAgICAgICAgICAgICAgICAobWluWCAqIHNjYWxlWCArIHdpZHRoRGlmZikgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgKG1pblkgKiBzY2FsZVkgKyBoZWlnaHREaWZmKSArICcpICc7XG4gICAgLy8gc2VlbXMgdW51c2VkLlxuICAgIC8vIHBhcnNlZERpbS52aWV3Ym94VHJhbnNmb3JtID0gZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlKG1hdHJpeCk7XG4gICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdzdmcnKSB7XG4gICAgICBlbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZmFicmljLnN2Z05TLCAnZycpO1xuICAgICAgLy8gZWxlbWVudC5maXJzdENoaWxkICE9IG51bGxcbiAgICAgIHdoaWxlIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGVsID0gZWxlbWVudDtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgneCcpO1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd5Jyk7XG4gICAgICBtYXRyaXggPSBlbC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpICsgbWF0cml4O1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIG1hdHJpeCk7XG4gICAgcmV0dXJuIHBhcnNlZERpbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0FuY2VzdG9yV2l0aE5vZGVOYW1lKGVsZW1lbnQsIG5vZGVOYW1lKSB7XG4gICAgd2hpbGUgKGVsZW1lbnQgJiYgKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUpKSB7XG4gICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSAmJiBub2RlTmFtZS50ZXN0KGVsZW1lbnQubm9kZU5hbWUucmVwbGFjZSgnc3ZnOicsICcnKSlcbiAgICAgICAgJiYgIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpbnN0YW50aWF0ZWRfYnlfdXNlJykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gU1ZHIGRvY3VtZW50LCBjb252ZXJ0cyBpdCB0byBhbiBhcnJheSBvZiBjb3JyZXNwb25kaW5nIGZhYnJpYy4qIGluc3RhbmNlcyBhbmQgcGFzc2VzIHRoZW0gdG8gYSBjYWxsYmFja1xuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAqIEBwYXJhbSB7U1ZHRG9jdW1lbnR9IGRvYyBTVkcgZG9jdW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gY2FsbCB3aGVuIHBhcnNpbmcgaXMgZmluaXNoZWQ7XG4gICAqIEl0J3MgYmVpbmcgcGFzc2VkIGFuIGFycmF5IG9mIGVsZW1lbnRzIChwYXJzZWQgZnJvbSBhIGRvY3VtZW50KS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIFNWRyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcnNpbmdPcHRpb25zXSBvcHRpb25zIGZvciBwYXJzaW5nIGRvY3VtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFyc2luZ09wdGlvbnMuY3Jvc3NPcmlnaW5dIGNyb3NzT3JpZ2luIHNldHRpbmdzXG4gICAqL1xuICBmYWJyaWMucGFyc2VTVkdEb2N1bWVudCA9IGZ1bmN0aW9uKGRvYywgY2FsbGJhY2ssIHJldml2ZXIsIHBhcnNpbmdPcHRpb25zKSB7XG4gICAgaWYgKCFkb2MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwYXJzZVVzZURpcmVjdGl2ZXMoZG9jKTtcblxuICAgIHZhciBzdmdVaWQgPSAgZmFicmljLk9iamVjdC5fX3VpZCsrLCBpLCBsZW4sXG4gICAgICAgIG9wdGlvbnMgPSBhcHBseVZpZXdib3hUcmFuc2Zvcm0oZG9jKSxcbiAgICAgICAgZGVzY2VuZGFudHMgPSBmYWJyaWMudXRpbC50b0FycmF5KGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpKTtcbiAgICBvcHRpb25zLmNyb3NzT3JpZ2luID0gcGFyc2luZ09wdGlvbnMgJiYgcGFyc2luZ09wdGlvbnMuY3Jvc3NPcmlnaW47XG4gICAgb3B0aW9ucy5zdmdVaWQgPSBzdmdVaWQ7XG5cbiAgICBpZiAoZGVzY2VuZGFudHMubGVuZ3RoID09PSAwICYmIGZhYnJpYy5pc0xpa2VseU5vZGUpIHtcbiAgICAgIC8vIHdlJ3JlIGxpa2VseSBpbiBub2RlLCB3aGVyZSBcIm8zLXhtbFwiIGxpYnJhcnkgZmFpbHMgdG8gZ0VCVE4oXCIqXCIpXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYWpheG9yZy9ub2RlLW8zLXhtbC9pc3N1ZXMvMjFcbiAgICAgIGRlc2NlbmRhbnRzID0gZG9jLnNlbGVjdE5vZGVzKCcvLypbbmFtZSguKSE9XCJzdmdcIl0nKTtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRlc2NlbmRhbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGRlc2NlbmRhbnRzW2ldO1xuICAgICAgfVxuICAgICAgZGVzY2VuZGFudHMgPSBhcnI7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gZGVzY2VuZGFudHMuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7XG4gICAgICBhcHBseVZpZXdib3hUcmFuc2Zvcm0oZWwpO1xuICAgICAgcmV0dXJuIGZhYnJpYy5zdmdWYWxpZFRhZ05hbWVzUmVnRXgudGVzdChlbC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpKSAmJlxuICAgICAgICAgICAgIWhhc0FuY2VzdG9yV2l0aE5vZGVOYW1lKGVsLCBmYWJyaWMuc3ZnSW52YWxpZEFuY2VzdG9yc1JlZ0V4KTsgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3N0cnVjdC5odG1sI0RlZnNFbGVtZW50XG4gICAgfSk7XG4gICAgaWYgKCFlbGVtZW50cyB8fCAoZWxlbWVudHMgJiYgIWVsZW1lbnRzLmxlbmd0aCkpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKFtdLCB7fSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjbGlwUGF0aHMgPSB7IH07XG4gICAgZGVzY2VuZGFudHMuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7XG4gICAgICByZXR1cm4gZWwubm9kZU5hbWUucmVwbGFjZSgnc3ZnOicsICcnKSA9PT0gJ2NsaXBQYXRoJztcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICB2YXIgaWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICBjbGlwUGF0aHNbaWRdID0gZmFicmljLnV0aWwudG9BcnJheShlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpKS5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy5zdmdWYWxpZFRhZ05hbWVzUmVnRXgudGVzdChlbC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGZhYnJpYy5ncmFkaWVudERlZnNbc3ZnVWlkXSA9IGZhYnJpYy5nZXRHcmFkaWVudERlZnMoZG9jKTtcbiAgICBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXSA9IGZhYnJpYy5nZXRDU1NSdWxlcyhkb2MpO1xuICAgIGZhYnJpYy5jbGlwUGF0aHNbc3ZnVWlkXSA9IGNsaXBQYXRocztcbiAgICAvLyBQcmVjZWRlbmNlIG9mIHJ1bGVzOiAgIHN0eWxlID4gY2xhc3MgPiBhdHRyaWJ1dGVcbiAgICBmYWJyaWMucGFyc2VFbGVtZW50cyhlbGVtZW50cywgZnVuY3Rpb24oaW5zdGFuY2VzLCBlbGVtZW50cykge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGluc3RhbmNlcywgb3B0aW9ucywgZWxlbWVudHMsIGRlc2NlbmRhbnRzKTtcbiAgICAgICAgZGVsZXRlIGZhYnJpYy5ncmFkaWVudERlZnNbc3ZnVWlkXTtcbiAgICAgICAgZGVsZXRlIGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdO1xuICAgICAgICBkZWxldGUgZmFicmljLmNsaXBQYXRoc1tzdmdVaWRdO1xuICAgICAgfVxuICAgIH0sIGNsb25lKG9wdGlvbnMpLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVjdXJzaXZlbHlQYXJzZUdyYWRpZW50c1hsaW5rKGRvYywgZ3JhZGllbnQpIHtcbiAgICB2YXIgZ3JhZGllbnRzQXR0cnMgPSBbJ2dyYWRpZW50VHJhbnNmb3JtJywgJ3gxJywgJ3gyJywgJ3kxJywgJ3kyJywgJ2dyYWRpZW50VW5pdHMnLCAnY3gnLCAnY3knLCAncicsICdmeCcsICdmeSddLFxuICAgICAgICB4bGlua0F0dHIgPSAneGxpbms6aHJlZicsXG4gICAgICAgIHhMaW5rID0gZ3JhZGllbnQuZ2V0QXR0cmlidXRlKHhsaW5rQXR0cikuc2xpY2UoMSksXG4gICAgICAgIHJlZmVyZW5jZWRHcmFkaWVudCA9IGVsZW1lbnRCeUlkKGRvYywgeExpbmspO1xuICAgIGlmIChyZWZlcmVuY2VkR3JhZGllbnQgJiYgcmVmZXJlbmNlZEdyYWRpZW50LmdldEF0dHJpYnV0ZSh4bGlua0F0dHIpKSB7XG4gICAgICByZWN1cnNpdmVseVBhcnNlR3JhZGllbnRzWGxpbmsoZG9jLCByZWZlcmVuY2VkR3JhZGllbnQpO1xuICAgIH1cbiAgICBncmFkaWVudHNBdHRycy5mb3JFYWNoKGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIGlmIChyZWZlcmVuY2VkR3JhZGllbnQgJiYgIWdyYWRpZW50Lmhhc0F0dHJpYnV0ZShhdHRyKSAmJiByZWZlcmVuY2VkR3JhZGllbnQuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZShhdHRyLCByZWZlcmVuY2VkR3JhZGllbnQuZ2V0QXR0cmlidXRlKGF0dHIpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWdyYWRpZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIHJlZmVyZW5jZUNsb25lID0gcmVmZXJlbmNlZEdyYWRpZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIHdoaWxlIChyZWZlcmVuY2VDbG9uZS5maXJzdENoaWxkKSB7XG4gICAgICAgIGdyYWRpZW50LmFwcGVuZENoaWxkKHJlZmVyZW5jZUNsb25lLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICBncmFkaWVudC5yZW1vdmVBdHRyaWJ1dGUoeGxpbmtBdHRyKTtcbiAgfVxuXG4gIHZhciByZUZvbnREZWNsYXJhdGlvbiA9IG5ldyBSZWdFeHAoXG4gICAgJyhub3JtYWx8aXRhbGljKT9cXFxccyoobm9ybWFsfHNtYWxsLWNhcHMpP1xcXFxzKicgK1xuICAgICcobm9ybWFsfGJvbGR8Ym9sZGVyfGxpZ2h0ZXJ8MTAwfDIwMHwzMDB8NDAwfDUwMHw2MDB8NzAwfDgwMHw5MDApP1xcXFxzKignICtcbiAgICAgIGZhYnJpYy5yZU51bSArXG4gICAgJyg/OnB4fGNtfG1tfGVtfHB0fHBjfGluKSopKD86XFxcXC8obm9ybWFsfCcgKyBmYWJyaWMucmVOdW0gKyAnKSk/XFxcXHMrKC4qKScpO1xuXG4gIGV4dGVuZChmYWJyaWMsIHtcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzaG9ydCBmb250IGRlY2xhcmF0aW9uLCBidWlsZGluZyBhZGRpbmcgaXRzIHByb3BlcnRpZXMgdG8gYSBzdHlsZSBvYmplY3RcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBmb250IGRlY2xhcmF0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9TdHlsZSBkZWZpbml0aW9uXG4gICAgICovXG4gICAgcGFyc2VGb250RGVjbGFyYXRpb246IGZ1bmN0aW9uKHZhbHVlLCBvU3R5bGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKHJlRm9udERlY2xhcmF0aW9uKTtcblxuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZm9udFN0eWxlID0gbWF0Y2hbMV0sXG4gICAgICAgICAgLy8gZm9udCB2YXJpYW50IGlzIG5vdCB1c2VkXG4gICAgICAgICAgLy8gZm9udFZhcmlhbnQgPSBtYXRjaFsyXSxcbiAgICAgICAgICBmb250V2VpZ2h0ID0gbWF0Y2hbM10sXG4gICAgICAgICAgZm9udFNpemUgPSBtYXRjaFs0XSxcbiAgICAgICAgICBsaW5lSGVpZ2h0ID0gbWF0Y2hbNV0sXG4gICAgICAgICAgZm9udEZhbWlseSA9IG1hdGNoWzZdO1xuXG4gICAgICBpZiAoZm9udFN0eWxlKSB7XG4gICAgICAgIG9TdHlsZS5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICB9XG4gICAgICBpZiAoZm9udFdlaWdodCkge1xuICAgICAgICBvU3R5bGUuZm9udFdlaWdodCA9IGlzTmFOKHBhcnNlRmxvYXQoZm9udFdlaWdodCkpID8gZm9udFdlaWdodCA6IHBhcnNlRmxvYXQoZm9udFdlaWdodCk7XG4gICAgICB9XG4gICAgICBpZiAoZm9udFNpemUpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRTaXplID0gcGFyc2VVbml0KGZvbnRTaXplKTtcbiAgICAgIH1cbiAgICAgIGlmIChmb250RmFtaWx5KSB7XG4gICAgICAgIG9TdHlsZS5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lSGVpZ2h0KSB7XG4gICAgICAgIG9TdHlsZS5saW5lSGVpZ2h0ID0gbGluZUhlaWdodCA9PT0gJ25vcm1hbCcgPyAxIDogbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIFNWRyBkb2N1bWVudCwgcmV0dXJuaW5nIGFsbCBvZiB0aGUgZ3JhZGllbnQgZGVjbGFyYXRpb25zIGZvdW5kIGluIGl0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1NWR0RvY3VtZW50fSBkb2MgU1ZHIGRvY3VtZW50IHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBHcmFkaWVudCBkZWZpbml0aW9uczsga2V5IGNvcnJlc3BvbmRzIHRvIGVsZW1lbnQgaWQsIHZhbHVlIC0tIHRvIGdyYWRpZW50IGRlZmluaXRpb24gZWxlbWVudFxuICAgICAqL1xuICAgIGdldEdyYWRpZW50RGVmczogZnVuY3Rpb24oZG9jKSB7XG4gICAgICB2YXIgdGFnQXJyYXkgPSBbXG4gICAgICAgICAgICAnbGluZWFyR3JhZGllbnQnLFxuICAgICAgICAgICAgJ3JhZGlhbEdyYWRpZW50JyxcbiAgICAgICAgICAgICdzdmc6bGluZWFyR3JhZGllbnQnLFxuICAgICAgICAgICAgJ3N2ZzpyYWRpYWxHcmFkaWVudCddLFxuICAgICAgICAgIGVsTGlzdCA9IF9nZXRNdWx0aXBsZU5vZGVzKGRvYywgdGFnQXJyYXkpLFxuICAgICAgICAgIGVsLCBqID0gMCwgZ3JhZGllbnREZWZzID0geyB9O1xuICAgICAgaiA9IGVsTGlzdC5sZW5ndGg7XG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIGVsID0gZWxMaXN0W2pdO1xuICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKCd4bGluazpocmVmJykpIHtcbiAgICAgICAgICByZWN1cnNpdmVseVBhcnNlR3JhZGllbnRzWGxpbmsoZG9jLCBlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhZGllbnREZWZzW2VsLmdldEF0dHJpYnV0ZSgnaWQnKV0gPSBlbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncmFkaWVudERlZnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMnIG5hbWUvdmFsdWUsIGdpdmVuIGVsZW1lbnQgYW5kIGFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcztcbiAgICAgKiBQYXJzZXMgcGFyZW50IFwiZ1wiIG5vZGVzIHJlY3Vyc2l2ZWx5IHVwd2FyZHMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGF0dHJpYnV0ZXMgQXJyYXkgb2YgYXR0cmlidXRlcyB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgcGFyc2VkIGF0dHJpYnV0ZXMnIG5hbWVzL3ZhbHVlc1xuICAgICAqL1xuICAgIHBhcnNlQXR0cmlidXRlczogZnVuY3Rpb24oZWxlbWVudCwgYXR0cmlidXRlcywgc3ZnVWlkKSB7XG5cbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSxcbiAgICAgICAgICBwYXJlbnRBdHRyaWJ1dGVzID0geyB9LFxuICAgICAgICAgIGZvbnRTaXplLCBwYXJlbnRGb250U2l6ZTtcblxuICAgICAgaWYgKHR5cGVvZiBzdmdVaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN2Z1VpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdmdVaWQnKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZXJlJ3MgYSBwYXJlbnQgY29udGFpbmVyIChgZ2Agb3IgYGFgIG9yIGBzeW1ib2xgIG5vZGUpLCBwYXJzZSBpdHMgYXR0cmlidXRlcyByZWN1cnNpdmVseSB1cHdhcmRzXG4gICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmIGZhYnJpYy5zdmdWYWxpZFBhcmVudHNSZWdFeC50ZXN0KGVsZW1lbnQucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgcGFyZW50QXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudC5wYXJlbnROb2RlLCBhdHRyaWJ1dGVzLCBzdmdVaWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3duQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIGF0dHIpIHtcbiAgICAgICAgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICBtZW1vW2F0dHJdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICB9LCB7IH0pO1xuICAgICAgLy8gYWRkIHZhbHVlcyBwYXJzZWQgZnJvbSBzdHlsZSwgd2hpY2ggdGFrZSBwcmVjZWRlbmNlIG92ZXIgYXR0cmlidXRlc1xuICAgICAgLy8gKHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3N0eWxpbmcuaHRtbCNVc2luZ1ByZXNlbnRhdGlvbkF0dHJpYnV0ZXMpXG4gICAgICB2YXIgY3NzQXR0cnMgPSBleHRlbmQoXG4gICAgICAgIGdldEdsb2JhbFN0eWxlc0ZvckVsZW1lbnQoZWxlbWVudCwgc3ZnVWlkKSxcbiAgICAgICAgZmFicmljLnBhcnNlU3R5bGVBdHRyaWJ1dGUoZWxlbWVudClcbiAgICAgICk7XG4gICAgICBvd25BdHRyaWJ1dGVzID0gZXh0ZW5kKFxuICAgICAgICBvd25BdHRyaWJ1dGVzLFxuICAgICAgICBjc3NBdHRyc1xuICAgICAgKTtcbiAgICAgIGlmIChjc3NBdHRyc1tjUGF0aF0pIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoY1BhdGgsIGNzc0F0dHJzW2NQYXRoXSk7XG4gICAgICB9XG4gICAgICBmb250U2l6ZSA9IHBhcmVudEZvbnRTaXplID0gcGFyZW50QXR0cmlidXRlcy5mb250U2l6ZSB8fCBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkU7XG4gICAgICBpZiAob3duQXR0cmlidXRlc1tmU2l6ZV0pIHtcbiAgICAgICAgLy8gbG9va3MgbGlrZSB0aGUgbWluaW11bSBzaG91bGQgYmUgOXB4IHdoZW4gZGVhbGluZyB3aXRoIGVtcy4gdGhpcyBpcyB3aGF0IGxvb2tzIGxpa2UgaW4gYnJvd3NlcnMuXG4gICAgICAgIG93bkF0dHJpYnV0ZXNbZlNpemVdID0gZm9udFNpemUgPSBwYXJzZVVuaXQob3duQXR0cmlidXRlc1tmU2l6ZV0sIHBhcmVudEZvbnRTaXplKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vcm1hbGl6ZWRBdHRyLCBub3JtYWxpemVkVmFsdWUsIG5vcm1hbGl6ZWRTdHlsZSA9IHt9O1xuICAgICAgZm9yICh2YXIgYXR0ciBpbiBvd25BdHRyaWJ1dGVzKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRBdHRyID0gbm9ybWFsaXplQXR0cihhdHRyKTtcbiAgICAgICAgbm9ybWFsaXplZFZhbHVlID0gbm9ybWFsaXplVmFsdWUobm9ybWFsaXplZEF0dHIsIG93bkF0dHJpYnV0ZXNbYXR0cl0sIHBhcmVudEF0dHJpYnV0ZXMsIGZvbnRTaXplKTtcbiAgICAgICAgbm9ybWFsaXplZFN0eWxlW25vcm1hbGl6ZWRBdHRyXSA9IG5vcm1hbGl6ZWRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub3JtYWxpemVkU3R5bGUgJiYgbm9ybWFsaXplZFN0eWxlLmZvbnQpIHtcbiAgICAgICAgZmFicmljLnBhcnNlRm9udERlY2xhcmF0aW9uKG5vcm1hbGl6ZWRTdHlsZS5mb250LCBub3JtYWxpemVkU3R5bGUpO1xuICAgICAgfVxuICAgICAgdmFyIG1lcmdlZEF0dHJzID0gZXh0ZW5kKHBhcmVudEF0dHJpYnV0ZXMsIG5vcm1hbGl6ZWRTdHlsZSk7XG4gICAgICByZXR1cm4gZmFicmljLnN2Z1ZhbGlkUGFyZW50c1JlZ0V4LnRlc3QoZWxlbWVudC5ub2RlTmFtZSkgPyBtZXJnZWRBdHRycyA6IF9zZXRTdHJva2VGaWxsT3BhY2l0eShtZXJnZWRBdHRycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYW4gYXJyYXkgb2Ygc3ZnIGVsZW1lbnRzIHRvIGNvcnJlc3BvbmRpbmcgZmFicmljLiogaW5zdGFuY2VzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50cyBBcnJheSBvZiBlbGVtZW50cyB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEJlaW5nIHBhc3NlZCBhbiBhcnJheSBvZiBmYWJyaWMgaW5zdGFuY2VzICh0cmFuc2Zvcm1lZCBmcm9tIFNWRyBlbGVtZW50cylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIFNWRyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqL1xuICAgIHBhcnNlRWxlbWVudHM6IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjaywgb3B0aW9ucywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMpIHtcbiAgICAgIG5ldyBmYWJyaWMuRWxlbWVudHNQYXJzZXIoZWxlbWVudHMsIGNhbGxiYWNrLCBvcHRpb25zLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucykucGFyc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIFwic3R5bGVcIiBhdHRyaWJ1dGUsIHJldHVuaW5nIGFuIG9iamVjdCB3aXRoIHZhbHVlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdHMgd2l0aCB2YWx1ZXMgcGFyc2VkIGZyb20gc3R5bGUgYXR0cmlidXRlIG9mIGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBwYXJzZVN0eWxlQXR0cmlidXRlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICB2YXIgb1N0eWxlID0geyB9LFxuICAgICAgICAgIHN0eWxlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cbiAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIG9TdHlsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFyc2VTdHlsZVN0cmluZyhzdHlsZSwgb1N0eWxlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwYXJzZVN0eWxlT2JqZWN0KHN0eWxlLCBvU3R5bGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb1N0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgXCJwb2ludHNcIiBhdHRyaWJ1dGUsIHJldHVybmluZyBhbiBhcnJheSBvZiB2YWx1ZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwb2ludHMgcG9pbnRzIGF0dHJpYnV0ZSBzdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgcG9pbnRzXG4gICAgICovXG4gICAgcGFyc2VQb2ludHNBdHRyaWJ1dGU6IGZ1bmN0aW9uKHBvaW50cykge1xuXG4gICAgICAvLyBwb2ludHMgYXR0cmlidXRlIGlzIHJlcXVpcmVkIGFuZCBtdXN0IG5vdCBiZSBlbXB0eVxuICAgICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlcGxhY2UgY29tbWFzIHdpdGggd2hpdGVzcGFjZSBhbmQgcmVtb3ZlIGJvb2tlbmRpbmcgd2hpdGVzcGFjZVxuICAgICAgcG9pbnRzID0gcG9pbnRzLnJlcGxhY2UoLywvZywgJyAnKS50cmltKCk7XG5cbiAgICAgIHBvaW50cyA9IHBvaW50cy5zcGxpdCgvXFxzKy8pO1xuICAgICAgdmFyIHBhcnNlZFBvaW50cyA9IFtdLCBpLCBsZW47XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICBwYXJzZWRQb2ludHMucHVzaCh7XG4gICAgICAgICAgeDogcGFyc2VGbG9hdChwb2ludHNbaV0pLFxuICAgICAgICAgIHk6IHBhcnNlRmxvYXQocG9pbnRzW2kgKyAxXSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9kZCBudW1iZXIgb2YgcG9pbnRzIGlzIGFuIGVycm9yXG4gICAgICAvLyBpZiAocGFyc2VkUG9pbnRzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgIC8vICAgcmV0dXJuIG51bGw7XG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVybiBwYXJzZWRQb2ludHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgQ1NTIHJ1bGVzIGZvciBhIGdpdmVuIFNWRyBkb2N1bWVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ1NTIHJ1bGVzIG9mIHRoaXMgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBnZXRDU1NSdWxlczogZnVuY3Rpb24oZG9jKSB7XG4gICAgICB2YXIgc3R5bGVzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdHlsZScpLCBpLCBsZW4sXG4gICAgICAgICAgYWxsUnVsZXMgPSB7IH0sIHJ1bGVzO1xuXG4gICAgICAvLyB2ZXJ5IGNydWRlIHBhcnNpbmcgb2Ygc3R5bGUgY29udGVudHNcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0eWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgc3R5bGVDb250ZW50cyA9IHN0eWxlc1tpXS50ZXh0Q29udGVudDtcblxuICAgICAgICAvLyByZW1vdmUgY29tbWVudHNcbiAgICAgICAgc3R5bGVDb250ZW50cyA9IHN0eWxlQ29udGVudHMucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy9nLCAnJyk7XG4gICAgICAgIGlmIChzdHlsZUNvbnRlbnRzLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWNvdmVycyBhbGwgdGhlIHJ1bGUgaW4gdGhpcyBmb3JtIGBib2R5IHsgc3R5bGUgY29kZS4uLiB9YFxuICAgICAgICAvLyBydWxlcyA9IHN0eWxlQ29udGVudHMubWF0Y2goL1tee10qXFx7W1xcc1xcU10qP1xcfS9nKTtcbiAgICAgICAgcnVsZXMgPSBzdHlsZUNvbnRlbnRzLnNwbGl0KCd9Jyk7XG4gICAgICAgIC8vIHJlbW92ZSBlbXB0eSBydWxlcy5cbiAgICAgICAgcnVsZXMgPSBydWxlcy5maWx0ZXIoZnVuY3Rpb24ocnVsZSkgeyByZXR1cm4gcnVsZS50cmltKCk7IH0pO1xuICAgICAgICAvLyBhdCB0aGlzIHBvaW50IHdlIGhhdmUgaG9wZWZ1bGx5IGFuIGFycmF5IG9mIHJ1bGVzIGBib2R5IHsgc3R5bGUgY29kZS4uLiBgXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgICAgcnVsZXMuZm9yRWFjaChmdW5jdGlvbihydWxlKSB7XG5cbiAgICAgICAgICB2YXIgbWF0Y2ggPSBydWxlLnNwbGl0KCd7JyksXG4gICAgICAgICAgICAgIHJ1bGVPYmogPSB7IH0sIGRlY2xhcmF0aW9uID0gbWF0Y2hbMV0udHJpbSgpLFxuICAgICAgICAgICAgICBwcm9wZXJ0eVZhbHVlUGFpcnMgPSBkZWNsYXJhdGlvbi5zcGxpdCgnOycpLmZpbHRlcihmdW5jdGlvbihwYWlyKSB7IHJldHVybiBwYWlyLnRyaW0oKTsgfSk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm9wZXJ0eVZhbHVlUGFpcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gcHJvcGVydHlWYWx1ZVBhaXJzW2ldLnNwbGl0KCc6JyksXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYWlyWzBdLnRyaW0oKSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhaXJbMV0udHJpbSgpO1xuICAgICAgICAgICAgcnVsZU9ialtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcnVsZSA9IG1hdGNoWzBdLnRyaW0oKTtcbiAgICAgICAgICBydWxlLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbihfcnVsZSkge1xuICAgICAgICAgICAgX3J1bGUgPSBfcnVsZS5yZXBsYWNlKC9ec3ZnL2ksICcnKS50cmltKCk7XG4gICAgICAgICAgICBpZiAoX3J1bGUgPT09ICcnKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxSdWxlc1tfcnVsZV0pIHtcbiAgICAgICAgICAgICAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChhbGxSdWxlc1tfcnVsZV0sIHJ1bGVPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGFsbFJ1bGVzW19ydWxlXSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShydWxlT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsUnVsZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRha2VzIHVybCBjb3JyZXNwb25kaW5nIHRvIGFuIFNWRyBkb2N1bWVudCwgYW5kIHBhcnNlcyBpdCBpbnRvIGEgc2V0IG9mIGZhYnJpYyBvYmplY3RzLlxuICAgICAqIE5vdGUgdGhhdCBTVkcgaXMgZmV0Y2hlZCB2aWEgWE1MSHR0cFJlcXVlc3QsIHNvIGl0IG5lZWRzIHRvIGNvbmZvcm0gdG8gU09QIChTYW1lIE9yaWdpbiBQb2xpY3kpXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBTVkcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY3Jvc3NPcmlnaW5dIGNyb3NzT3JpZ2luIGNyb3NzT3JpZ2luIHNldHRpbmcgdG8gdXNlIGZvciBleHRlcm5hbCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBsb2FkU1ZHRnJvbVVSTDogZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgcmV2aXZlciwgb3B0aW9ucykge1xuXG4gICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXlxcblxccyovLCAnJykudHJpbSgpO1xuICAgICAgbmV3IGZhYnJpYy51dGlsLnJlcXVlc3QodXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ2dldCcsXG4gICAgICAgIG9uQ29tcGxldGU6IG9uQ29tcGxldGVcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBvbkNvbXBsZXRlKHIpIHtcblxuICAgICAgICB2YXIgeG1sID0gci5yZXNwb25zZVhNTDtcbiAgICAgICAgaWYgKCF4bWwgfHwgIXhtbC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmYWJyaWMucGFyc2VTVkdEb2N1bWVudCh4bWwuZG9jdW1lbnRFbGVtZW50LCBmdW5jdGlvbiAocmVzdWx0cywgX29wdGlvbnMsIGVsZW1lbnRzLCBhbGxFbGVtZW50cykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3VsdHMsIF9vcHRpb25zLCBlbGVtZW50cywgYWxsRWxlbWVudHMpO1xuICAgICAgICB9LCByZXZpdmVyLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gYW4gU1ZHIGRvY3VtZW50LCBhbmQgcGFyc2VzIGl0IGludG8gYSBzZXQgb2YgZmFicmljIG9iamVjdHNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIFNWRyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gY3Jvc3NPcmlnaW4gc2V0dGluZyB0byB1c2UgZm9yIGV4dGVybmFsIHJlc291cmNlc1xuICAgICAqL1xuICAgIGxvYWRTVkdGcm9tU3RyaW5nOiBmdW5jdGlvbihzdHJpbmcsIGNhbGxiYWNrLCByZXZpdmVyLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcGFyc2VyID0gbmV3IGZhYnJpYy53aW5kb3cuRE9NUGFyc2VyKCksXG4gICAgICAgICAgZG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzdHJpbmcudHJpbSgpLCAndGV4dC94bWwnKTtcbiAgICAgIGZhYnJpYy5wYXJzZVNWR0RvY3VtZW50KGRvYy5kb2N1bWVudEVsZW1lbnQsIGZ1bmN0aW9uIChyZXN1bHRzLCBfb3B0aW9ucywgZWxlbWVudHMsIGFsbEVsZW1lbnRzKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdHMsIF9vcHRpb25zLCBlbGVtZW50cywgYWxsRWxlbWVudHMpO1xuICAgICAgfSwgcmV2aXZlciwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbmZhYnJpYy5FbGVtZW50c1BhcnNlciA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjaywgb3B0aW9ucywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMsIGRvYykge1xuICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5yZXZpdmVyID0gcmV2aXZlcjtcbiAgdGhpcy5zdmdVaWQgPSAob3B0aW9ucyAmJiBvcHRpb25zLnN2Z1VpZCkgfHwgMDtcbiAgdGhpcy5wYXJzaW5nT3B0aW9ucyA9IHBhcnNpbmdPcHRpb25zO1xuICB0aGlzLnJlZ2V4VXJsID0gL151cmxcXChbJ1wiXT8jKFteJ1wiXSspWydcIl0/XFwpL2c7XG4gIHRoaXMuZG9jID0gZG9jO1xufTtcblxuKGZ1bmN0aW9uKHByb3RvKSB7XG4gIHByb3RvLnBhcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbnN0YW5jZXMgPSBuZXcgQXJyYXkodGhpcy5lbGVtZW50cy5sZW5ndGgpO1xuICAgIHRoaXMubnVtRWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcbiAgICB0aGlzLmNyZWF0ZU9iamVjdHMoKTtcbiAgfTtcblxuICBwcm90by5jcmVhdGVPYmplY3RzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N2Z1VpZCcsIF90aGlzLnN2Z1VpZCk7XG4gICAgICBfdGhpcy5jcmVhdGVPYmplY3QoZWxlbWVudCwgaSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcHJvdG8uZmluZFRhZyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgcmV0dXJuIGZhYnJpY1tmYWJyaWMudXRpbC5zdHJpbmcuY2FwaXRhbGl6ZShlbC50YWdOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpXTtcbiAgfTtcblxuICBwcm90by5jcmVhdGVPYmplY3QgPSBmdW5jdGlvbihlbCwgaW5kZXgpIHtcbiAgICB2YXIga2xhc3MgPSB0aGlzLmZpbmRUYWcoZWwpO1xuICAgIGlmIChrbGFzcyAmJiBrbGFzcy5mcm9tRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAga2xhc3MuZnJvbUVsZW1lbnQoZWwsIHRoaXMuY3JlYXRlQ2FsbGJhY2soaW5kZXgsIGVsKSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgZmFicmljLmxvZyhlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tJZkRvbmUoKTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdG8uY3JlYXRlQ2FsbGJhY2sgPSBmdW5jdGlvbihpbmRleCwgZWwpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBfb3B0aW9ucztcbiAgICAgIF90aGlzLnJlc29sdmVHcmFkaWVudChvYmosIGVsLCAnZmlsbCcpO1xuICAgICAgX3RoaXMucmVzb2x2ZUdyYWRpZW50KG9iaiwgZWwsICdzdHJva2UnKTtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBmYWJyaWMuSW1hZ2UgJiYgb2JqLl9vcmlnaW5hbEVsZW1lbnQpIHtcbiAgICAgICAgX29wdGlvbnMgPSBvYmoucGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlKGVsKTtcbiAgICAgIH1cbiAgICAgIG9iai5fcmVtb3ZlVHJhbnNmb3JtTWF0cml4KF9vcHRpb25zKTtcbiAgICAgIF90aGlzLnJlc29sdmVDbGlwUGF0aChvYmosIGVsKTtcbiAgICAgIF90aGlzLnJldml2ZXIgJiYgX3RoaXMucmV2aXZlcihlbCwgb2JqKTtcbiAgICAgIF90aGlzLmluc3RhbmNlc1tpbmRleF0gPSBvYmo7XG4gICAgICBfdGhpcy5jaGVja0lmRG9uZSgpO1xuICAgIH07XG4gIH07XG5cbiAgcHJvdG8uZXh0cmFjdFByb3BlcnR5RGVmaW5pdGlvbiA9IGZ1bmN0aW9uKG9iaiwgcHJvcGVydHksIHN0b3JhZ2UpIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcGVydHldLCByZWdleCA9IHRoaXMucmVnZXhVcmw7XG4gICAgaWYgKCFyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdleC5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBpZCA9IHJlZ2V4LmV4ZWModmFsdWUpWzFdO1xuICAgIHJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIGZhYnJpY1tzdG9yYWdlXVt0aGlzLnN2Z1VpZF1baWRdO1xuICB9O1xuXG4gIHByb3RvLnJlc29sdmVHcmFkaWVudCA9IGZ1bmN0aW9uKG9iaiwgZWwsIHByb3BlcnR5KSB7XG4gICAgdmFyIGdyYWRpZW50RGVmID0gdGhpcy5leHRyYWN0UHJvcGVydHlEZWZpbml0aW9uKG9iaiwgcHJvcGVydHksICdncmFkaWVudERlZnMnKTtcbiAgICBpZiAoZ3JhZGllbnREZWYpIHtcbiAgICAgIHZhciBvcGFjaXR5QXR0ciA9IGVsLmdldEF0dHJpYnV0ZShwcm9wZXJ0eSArICctb3BhY2l0eScpO1xuICAgICAgdmFyIGdyYWRpZW50ID0gZmFicmljLkdyYWRpZW50LmZyb21FbGVtZW50KGdyYWRpZW50RGVmLCBvYmosIG9wYWNpdHlBdHRyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgb2JqLnNldChwcm9wZXJ0eSwgZ3JhZGllbnQpO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5jcmVhdGVDbGlwUGF0aENhbGxiYWNrID0gZnVuY3Rpb24ob2JqLCBjb250YWluZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oX25ld09iaikge1xuICAgICAgX25ld09iai5fcmVtb3ZlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICBfbmV3T2JqLmZpbGxSdWxlID0gX25ld09iai5jbGlwUnVsZTtcbiAgICAgIGNvbnRhaW5lci5wdXNoKF9uZXdPYmopO1xuICAgIH07XG4gIH07XG5cbiAgcHJvdG8ucmVzb2x2ZUNsaXBQYXRoID0gZnVuY3Rpb24ob2JqLCB1c2luZ0VsZW1lbnQpIHtcbiAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmV4dHJhY3RQcm9wZXJ0eURlZmluaXRpb24ob2JqLCAnY2xpcFBhdGgnLCAnY2xpcFBhdGhzJyksXG4gICAgICAgIGVsZW1lbnQsIGtsYXNzLCBvYmpUcmFuc2Zvcm1JbnYsIGNvbnRhaW5lciwgZ1RyYW5zZm9ybSwgb3B0aW9ucztcbiAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgIGNvbnRhaW5lciA9IFtdO1xuICAgICAgb2JqVHJhbnNmb3JtSW52ID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKG9iai5jYWxjVHJhbnNmb3JtTWF0cml4KCkpO1xuICAgICAgLy8gbW92ZSB0aGUgY2xpcFBhdGggdGFnIGFzIHNpYmxpbmcgdG8gdGhlIHJlYWwgZWxlbWVudCB0aGF0IGlzIHVzaW5nIGl0XG4gICAgICB2YXIgY2xpcFBhdGhUYWcgPSBjbGlwUGF0aFswXS5wYXJlbnROb2RlO1xuICAgICAgdmFyIGNsaXBQYXRoT3duZXIgPSB1c2luZ0VsZW1lbnQ7XG4gICAgICB3aGlsZSAoY2xpcFBhdGhPd25lci5wYXJlbnROb2RlICYmIGNsaXBQYXRoT3duZXIuZ2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnKSAhPT0gb2JqLmNsaXBQYXRoKSB7XG4gICAgICAgIGNsaXBQYXRoT3duZXIgPSBjbGlwUGF0aE93bmVyLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICBjbGlwUGF0aE93bmVyLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY2xpcFBhdGhUYWcpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50ID0gY2xpcFBhdGhbaV07XG4gICAgICAgIGtsYXNzID0gdGhpcy5maW5kVGFnKGVsZW1lbnQpO1xuICAgICAgICBrbGFzcy5mcm9tRWxlbWVudChcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIHRoaXMuY3JlYXRlQ2xpcFBhdGhDYWxsYmFjayhvYmosIGNvbnRhaW5lciksXG4gICAgICAgICAgdGhpcy5vcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29udGFpbmVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjbGlwUGF0aCA9IGNvbnRhaW5lclswXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjbGlwUGF0aCA9IG5ldyBmYWJyaWMuR3JvdXAoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICAgIGdUcmFuc2Zvcm0gPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKFxuICAgICAgICBvYmpUcmFuc2Zvcm1JbnYsXG4gICAgICAgIGNsaXBQYXRoLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKVxuICAgICAgKTtcbiAgICAgIGlmIChjbGlwUGF0aC5jbGlwUGF0aCkge1xuICAgICAgICB0aGlzLnJlc29sdmVDbGlwUGF0aChjbGlwUGF0aCwgY2xpcFBhdGhPd25lcik7XG4gICAgICB9XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKGdUcmFuc2Zvcm0pO1xuICAgICAgY2xpcFBhdGguZmxpcFggPSBmYWxzZTtcbiAgICAgIGNsaXBQYXRoLmZsaXBZID0gZmFsc2U7XG4gICAgICBjbGlwUGF0aC5zZXQoJ3NjYWxlWCcsIG9wdGlvbnMuc2NhbGVYKTtcbiAgICAgIGNsaXBQYXRoLnNldCgnc2NhbGVZJywgb3B0aW9ucy5zY2FsZVkpO1xuICAgICAgY2xpcFBhdGguYW5nbGUgPSBvcHRpb25zLmFuZ2xlO1xuICAgICAgY2xpcFBhdGguc2tld1ggPSBvcHRpb25zLnNrZXdYO1xuICAgICAgY2xpcFBhdGguc2tld1kgPSAwO1xuICAgICAgY2xpcFBhdGguc2V0UG9zaXRpb25CeU9yaWdpbih7IHg6IG9wdGlvbnMudHJhbnNsYXRlWCwgeTogb3B0aW9ucy50cmFuc2xhdGVZIH0sICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICBvYmouY2xpcFBhdGggPSBjbGlwUGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBpZiBjbGlwLXBhdGggZG9lcyBub3QgcmVzb2x2ZSB0byBhbnkgZWxlbWVudCwgZGVsZXRlIHRoZSBwcm9wZXJ0eS5cbiAgICAgIGRlbGV0ZSBvYmouY2xpcFBhdGg7XG4gICAgfVxuICB9O1xuXG4gIHByb3RvLmNoZWNrSWZEb25lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKC0tdGhpcy5udW1FbGVtZW50cyA9PT0gMCkge1xuICAgICAgdGhpcy5pbnN0YW5jZXMgPSB0aGlzLmluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsIGVxZXFlcVxuICAgICAgICByZXR1cm4gZWwgIT0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLmluc3RhbmNlcywgdGhpcy5lbGVtZW50cyk7XG4gICAgfVxuICB9O1xufSkoZmFicmljLkVsZW1lbnRzUGFyc2VyLnByb3RvdHlwZSk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBBZGFwdGF0aW9uIG9mIHdvcmsgb2YgS2V2aW4gTGluZHNleSAoa2V2aW5Aa2V2bGluZGV2LmNvbSkgKi9cblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5Qb2ludCkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUG9pbnQgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZmFicmljLlBvaW50ID0gUG9pbnQ7XG5cbiAgLyoqXG4gICAqIFBvaW50IGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9pbnRcbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAqL1xuICBmdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgUG9pbnQucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuUG9pbnQucHJvdG90eXBlICovIHtcblxuICAgIHR5cGU6ICdwb2ludCcsXG5cbiAgICBjb25zdHJ1Y3RvcjogUG9pbnQsXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFub3RoZXIgcG9pbnQgdG8gdGhpcyBvbmUgYW5kIHJldHVybnMgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gbmV3IFBvaW50IGluc3RhbmNlIHdpdGggYWRkZWQgdmFsdWVzXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB0aGF0LngsIHRoaXMueSArIHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW5vdGhlciBwb2ludCB0byB0aGlzIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFkZEVxdWFsczogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHRoaXMueCArPSB0aGF0Lng7XG4gICAgICB0aGlzLnkgKz0gdGhhdC55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdmFsdWUgdG8gdGhpcyBwb2ludCBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBuZXcgUG9pbnQgd2l0aCBhZGRlZCB2YWx1ZVxuICAgICAqL1xuICAgIHNjYWxhckFkZDogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBzY2FsYXIsIHRoaXMueSArIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgdmFsdWUgdG8gdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGFyQWRkRXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggKz0gc2NhbGFyO1xuICAgICAgdGhpcy55ICs9IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgYW5vdGhlciBwb2ludCBmcm9tIHRoaXMgcG9pbnQgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IG5ldyBQb2ludCBvYmplY3Qgd2l0aCBzdWJ0cmFjdGVkIHZhbHVlc1xuICAgICAqL1xuICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSB0aGF0LngsIHRoaXMueSAtIHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyBhbm90aGVyIHBvaW50IGZyb20gdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHN1YnRyYWN0RXF1YWxzOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdGhpcy54IC09IHRoYXQueDtcbiAgICAgIHRoaXMueSAtPSB0aGF0Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHZhbHVlIGZyb20gdGhpcyBwb2ludCBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHNjYWxhclN1YnRyYWN0OiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHNjYWxhciwgdGhpcy55IC0gc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIHZhbHVlIGZyb20gdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGFyU3VidHJhY3RFcXVhbHM6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHRoaXMueCAtPSBzY2FsYXI7XG4gICAgICB0aGlzLnkgLT0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIFRPRE86IHJlbmFtZSBpbiBzY2FsYXJNdWx0aXBseSBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG11bHRpcGx5OiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHNjYWxhciwgdGhpcy55ICogc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyTXVsdGlwbHlFcXVhbHMgaW4gMi4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBtdWx0aXBseUVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54ICo9IHNjYWxhcjtcbiAgICAgIHRoaXMueSAqPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhckRpdmlkZSBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGRpdmlkZTogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLyBzY2FsYXIsIHRoaXMueSAvIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhckRpdmlkZUVxdWFscyBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRpdmlkZUVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54IC89IHNjYWxhcjtcbiAgICAgIHRoaXMueSAvPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgZXF1YWwgdG8gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZXE6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA9PT0gdGhhdC54ICYmIHRoaXMueSA9PT0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgbGVzcyB0aGFuIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGx0OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPCB0aGF0LnggJiYgdGhpcy55IDwgdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGx0ZTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54IDw9IHRoYXQueCAmJiB0aGlzLnkgPD0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG5cbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBncmVhdGVyIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGd0OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPiB0aGF0LnggJiYgdGhpcy55ID4gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGd0ZTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54ID49IHRoYXQueCAmJiB0aGlzLnkgPj0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuZXcgcG9pbnQgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aXRoIHRoaXMgb25lIGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHQgLCBwb3NpdGlvbiBvZiBpbnRlcnBvbGF0aW9uLCBiZXR3ZWVuIDAgYW5kIDEgZGVmYXVsdCAwLjVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbGVycDogZnVuY3Rpb24gKHRoYXQsIHQpIHtcbiAgICAgIGlmICh0eXBlb2YgdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdCA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHQgPSBNYXRoLm1heChNYXRoLm1pbigxLCB0KSwgMCk7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArICh0aGF0LnggLSB0aGlzLngpICogdCwgdGhpcy55ICsgKHRoYXQueSAtIHRoaXMueSkgKiB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkaXN0YW5jZSBmcm9tIHRoaXMgcG9pbnQgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZGlzdGFuY2VGcm9tOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdmFyIGR4ID0gdGhpcy54IC0gdGhhdC54LFxuICAgICAgICAgIGR5ID0gdGhpcy55IC0gdGhhdC55O1xuICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGJldHdlZW4gdGhpcyBwb2ludCBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtaWRQb2ludEZyb206IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gdGhpcy5sZXJwKHRoYXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHBvaW50IHdoaWNoIGlzIHRoZSBtaW4gb2YgdGhpcyBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtaW46IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KE1hdGgubWluKHRoaXMueCwgdGhhdC54KSwgTWF0aC5taW4odGhpcy55LCB0aGF0LnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBwb2ludCB3aGljaCBpcyB0aGUgbWF4IG9mIHRoaXMgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbWF4OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChNYXRoLm1heCh0aGlzLngsIHRoYXQueCksIE1hdGgubWF4KHRoaXMueSwgdGhhdC55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKyAnLCcgKyB0aGlzLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeC95IG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFhZOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB4IG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRYOiBmdW5jdGlvbiAoeCkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHkgb2YgdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFk6IGZ1bmN0aW9uICh5KSB7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeC95IG9mIHRoaXMgcG9pbnQgZnJvbSBhbm90aGVyIHBvaW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RnJvbVBvaW50OiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdGhpcy54ID0gdGhhdC54O1xuICAgICAgdGhpcy55ID0gdGhhdC55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN3YXBzIHgveSBvZiB0aGlzIHBvaW50IGFuZCBhbm90aGVyIHBvaW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKi9cbiAgICBzd2FwOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgICAgeSA9IHRoaXMueTtcbiAgICAgIHRoaXMueCA9IHRoYXQueDtcbiAgICAgIHRoaXMueSA9IHRoYXQueTtcbiAgICAgIHRoYXQueCA9IHg7XG4gICAgICB0aGF0LnkgPSB5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBjbG9uZWQgaW5zdGFuY2Ugb2YgdGhlIHBvaW50XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIEFkYXB0YXRpb24gb2Ygd29yayBvZiBLZXZpbiBMaW5kc2V5IChrZXZpbkBrZXZsaW5kZXYuY29tKSAqL1xuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5JbnRlcnNlY3Rpb24pIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkludGVyc2VjdGlvbiBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJzZWN0aW9uIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW50ZXJzZWN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBJbnRlcnNlY3Rpb24oc3RhdHVzKSB7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgfVxuXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24gPSBJbnRlcnNlY3Rpb247XG5cbiAgZmFicmljLkludGVyc2VjdGlvbi5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5JbnRlcnNlY3Rpb24ucHJvdG90eXBlICovIHtcblxuICAgIGNvbnN0cnVjdG9yOiBJbnRlcnNlY3Rpb24sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgcG9pbnQgdG8gaW50ZXJzZWN0aW9uXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50XG4gICAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhcHBlbmRQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHBvaW50cyB0byBpbnRlcnNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFwcGVuZFBvaW50czogZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgdGhpcy5wb2ludHMgPSB0aGlzLnBvaW50cy5jb25jYXQocG9pbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIG9uZSBsaW5lIGludGVyc2VjdHMgYW5vdGhlclxuICAgKiBUT0RPOiByZW5hbWUgaW4gaW50ZXJzZWN0U2VnbWVudFNlZ21lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGEyXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBiMVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYjJcbiAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn1cbiAgICovXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZUxpbmUgPSBmdW5jdGlvbiAoYTEsIGEyLCBiMSwgYjIpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICB1YVQgPSAoYjIueCAtIGIxLngpICogKGExLnkgLSBiMS55KSAtIChiMi55IC0gYjEueSkgKiAoYTEueCAtIGIxLngpLFxuICAgICAgICB1YlQgPSAoYTIueCAtIGExLngpICogKGExLnkgLSBiMS55KSAtIChhMi55IC0gYTEueSkgKiAoYTEueCAtIGIxLngpLFxuICAgICAgICB1QiA9IChiMi55IC0gYjEueSkgKiAoYTIueCAtIGExLngpIC0gKGIyLnggLSBiMS54KSAqIChhMi55IC0gYTEueSk7XG4gICAgaWYgKHVCICE9PSAwKSB7XG4gICAgICB2YXIgdWEgPSB1YVQgLyB1QixcbiAgICAgICAgICB1YiA9IHViVCAvIHVCO1xuICAgICAgaWYgKDAgPD0gdWEgJiYgdWEgPD0gMSAmJiAwIDw9IHViICYmIHViIDw9IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbignSW50ZXJzZWN0aW9uJyk7XG4gICAgICAgIHJlc3VsdC5hcHBlbmRQb2ludChuZXcgZmFicmljLlBvaW50KGExLnggKyB1YSAqIChhMi54IC0gYTEueCksIGExLnkgKyB1YSAqIChhMi55IC0gYTEueSkpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHVhVCA9PT0gMCB8fCB1YlQgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbignQ29pbmNpZGVudCcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oJ1BhcmFsbGVsJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBsaW5lIGludGVyc2VjdHMgcG9seWdvblxuICAgKiBUT0RPOiByZW5hbWUgaW4gaW50ZXJzZWN0U2VnbWVudFBvbHlnb25cbiAgICogZml4IGRldGVjdGlvbiBvZiBjb2luY2lkZW50XG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGExXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBhMlxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn1cbiAgICovXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24gPSBmdW5jdGlvbihhMSwgYTIsIHBvaW50cykge1xuICAgIHZhciByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCksXG4gICAgICAgIGxlbmd0aCA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIGIxLCBiMiwgaW50ZXIsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGIxID0gcG9pbnRzW2ldO1xuICAgICAgYjIgPSBwb2ludHNbKGkgKyAxKSAlIGxlbmd0aF07XG4gICAgICBpbnRlciA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lTGluZShhMSwgYTIsIGIxLCBiMik7XG5cbiAgICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIucG9pbnRzKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnN0YXR1cyA9ICdJbnRlcnNlY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcG9seWdvbiBpbnRlcnNlY3RzIGFub3RoZXIgcG9seWdvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50czFcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzMlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMxLCBwb2ludHMyKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKSxcbiAgICAgICAgbGVuZ3RoID0gcG9pbnRzMS5sZW5ndGgsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhMSA9IHBvaW50czFbaV0sXG4gICAgICAgICAgYTIgPSBwb2ludHMxWyhpICsgMSkgJSBsZW5ndGhdLFxuICAgICAgICAgIGludGVyID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKGExLCBhMiwgcG9pbnRzMik7XG5cbiAgICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIucG9pbnRzKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnN0YXR1cyA9ICdJbnRlcnNlY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgcG9seWdvbiBpbnRlcnNlY3RzIHJlY3RhbmdsZVxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcjFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHIyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25SZWN0YW5nbGUgPSBmdW5jdGlvbiAocG9pbnRzLCByMSwgcjIpIHtcbiAgICB2YXIgbWluID0gcjEubWluKHIyKSxcbiAgICAgICAgbWF4ID0gcjEubWF4KHIyKSxcbiAgICAgICAgdG9wUmlnaHQgPSBuZXcgZmFicmljLlBvaW50KG1heC54LCBtaW4ueSksXG4gICAgICAgIGJvdHRvbUxlZnQgPSBuZXcgZmFicmljLlBvaW50KG1pbi54LCBtYXgueSksXG4gICAgICAgIGludGVyMSA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbihtaW4sIHRvcFJpZ2h0LCBwb2ludHMpLFxuICAgICAgICBpbnRlcjIgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24odG9wUmlnaHQsIG1heCwgcG9pbnRzKSxcbiAgICAgICAgaW50ZXIzID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKG1heCwgYm90dG9tTGVmdCwgcG9pbnRzKSxcbiAgICAgICAgaW50ZXI0ID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKGJvdHRvbUxlZnQsIG1pbiwgcG9pbnRzKSxcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpO1xuXG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjEucG9pbnRzKTtcbiAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyMi5wb2ludHMpO1xuICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIzLnBvaW50cyk7XG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjQucG9pbnRzKTtcblxuICAgIGlmIChyZXN1bHQucG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5zdGF0dXMgPSAnSW50ZXJzZWN0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuQ29sb3IpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkNvbG9yIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQ29sb3IgY2xhc3NcbiAgICogVGhlIHB1cnBvc2Ugb2Yge0BsaW5rIGZhYnJpYy5Db2xvcn0gaXMgdG8gYWJzdHJhY3QgYW5kIGVuY2Fwc3VsYXRlIGNvbW1vbiBjb2xvciBvcGVyYXRpb25zO1xuICAgKiB7QGxpbmsgZmFicmljLkNvbG9yfSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBjcmVhdGVzIGluc3RhbmNlcyBvZiB7QGxpbmsgZmFicmljLkNvbG9yfSBvYmplY3RzLlxuICAgKlxuICAgKiBAY2xhc3MgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBvcHRpb25hbCBpbiBoZXggb3IgcmdiKGEpIG9yIGhzbCBmb3JtYXQgb3IgZnJvbSBrbm93biBjb2xvciBsaXN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMi8jY29sb3JzfVxuICAgKi9cbiAgZnVuY3Rpb24gQ29sb3IoY29sb3IpIHtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICB0aGlzLnNldFNvdXJjZShbMCwgMCwgMCwgMV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3RyeVBhcnNpbmdDb2xvcihjb2xvcik7XG4gICAgfVxuICB9XG5cbiAgZmFicmljLkNvbG9yID0gQ29sb3I7XG5cbiAgZmFicmljLkNvbG9yLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkNvbG9yLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBjb2xvciBDb2xvciB2YWx1ZSB0byBwYXJzZVxuICAgICAqL1xuICAgIF90cnlQYXJzaW5nQ29sb3I6IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICB2YXIgc291cmNlO1xuXG4gICAgICBpZiAoY29sb3IgaW4gQ29sb3IuY29sb3JOYW1lTWFwKSB7XG4gICAgICAgIGNvbG9yID0gQ29sb3IuY29sb3JOYW1lTWFwW2NvbG9yXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgIHNvdXJjZSA9IFsyNTUsIDI1NSwgMjU1LCAwXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgc291cmNlID0gQ29sb3Iuc291cmNlRnJvbUhleChjb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBzb3VyY2UgPSBDb2xvci5zb3VyY2VGcm9tUmdiKGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHNvdXJjZSA9IENvbG9yLnNvdXJjZUZyb21Ic2woY29sb3IpO1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgLy9pZiBjb2xvciBpcyBub3QgcmVjb2duaXplIGxldCdzIG1ha2UgYmxhY2sgYXMgY2FudmFzIGRvZXNcbiAgICAgICAgc291cmNlID0gWzAsIDAsIDAsIDFdO1xuICAgICAgfVxuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHBzOi8vcmF3Z2l0aHViLmNvbS9tamlqYWNrc29uL21qaWphY2tzb24uZ2l0aHViLmNvbS9tYXN0ZXIvMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0Lmh0bWxcIj5odHRwczovL2dpdGh1Yi5jb20vbWppamFja3NvbjwvYT5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByIFJlZCBjb2xvciB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBnIEdyZWVuIGNvbG9yIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgQmx1ZSBjb2xvciB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBIc2wgY29sb3JcbiAgICAgKi9cbiAgICBfcmdiVG9Ic2w6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcbiAgICAgIHIgLz0gMjU1OyBnIC89IDI1NTsgYiAvPSAyNTU7XG5cbiAgICAgIHZhciBoLCBzLCBsLFxuICAgICAgICAgIG1heCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heChbciwgZywgYl0pLFxuICAgICAgICAgIG1pbiA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbihbciwgZywgYl0pO1xuXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgaCA9IHMgPSAwOyAvLyBhY2hyb21hdGljXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBiOlxuICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGggLz0gNjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgTWF0aC5yb3VuZChoICogMzYwKSxcbiAgICAgICAgTWF0aC5yb3VuZChzICogMTAwKSxcbiAgICAgICAgTWF0aC5yb3VuZChsICogMTAwKVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzb3VyY2Ugb2YgdGhpcyBjb2xvciAod2hlcmUgc291cmNlIGlzIGFuIGFycmF5IHJlcHJlc2VudGF0aW9uOyBleDogWzIwMCwgMjAwLCAxMDAsIDFdKVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGdldFNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc291cmNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNvdXJjZSBvZiB0aGlzIGNvbG9yICh3aGVyZSBzb3VyY2UgaXMgYW4gYXJyYXkgcmVwcmVzZW50YXRpb247IGV4OiBbMjAwLCAyMDAsIDEwMCwgMV0pXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlXG4gICAgICovXG4gICAgc2V0U291cmNlOiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBSR0IgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KVxuICAgICAqL1xuICAgIHRvUmdiOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgICAgcmV0dXJuICdyZ2IoJyArIHNvdXJjZVswXSArICcsJyArIHNvdXJjZVsxXSArICcsJyArIHNvdXJjZVsyXSArICcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBSR0JBIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IHJnYmEoMC0yNTUsMC0yNTUsMC0yNTUsMC0xKVxuICAgICAqL1xuICAgIHRvUmdiYTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICAgIHJldHVybiAncmdiYSgnICsgc291cmNlWzBdICsgJywnICsgc291cmNlWzFdICsgJywnICsgc291cmNlWzJdICsgJywnICsgc291cmNlWzNdICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIEhTTCBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBoc2woMC0zNjAsMCUtMTAwJSwwJS0xMDAlKVxuICAgICAqL1xuICAgIHRvSHNsOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGhzbCA9IHRoaXMuX3JnYlRvSHNsKHNvdXJjZVswXSwgc291cmNlWzFdLCBzb3VyY2VbMl0pO1xuXG4gICAgICByZXR1cm4gJ2hzbCgnICsgaHNsWzBdICsgJywnICsgaHNsWzFdICsgJyUsJyArIGhzbFsyXSArICclKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gSFNMQSBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBoc2xhKDAtMzYwLDAlLTEwMCUsMCUtMTAwJSwwLTEpXG4gICAgICovXG4gICAgdG9Ic2xhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGhzbCA9IHRoaXMuX3JnYlRvSHNsKHNvdXJjZVswXSwgc291cmNlWzFdLCBzb3VyY2VbMl0pO1xuXG4gICAgICByZXR1cm4gJ2hzbGEoJyArIGhzbFswXSArICcsJyArIGhzbFsxXSArICclLCcgKyBoc2xbMl0gKyAnJSwnICsgc291cmNlWzNdICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIEhFWCBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBGRjU1NTVcbiAgICAgKi9cbiAgICB0b0hleDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSwgciwgZywgYjtcblxuICAgICAgciA9IHNvdXJjZVswXS50b1N0cmluZygxNik7XG4gICAgICByID0gKHIubGVuZ3RoID09PSAxKSA/ICgnMCcgKyByKSA6IHI7XG5cbiAgICAgIGcgPSBzb3VyY2VbMV0udG9TdHJpbmcoMTYpO1xuICAgICAgZyA9IChnLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgZykgOiBnO1xuXG4gICAgICBiID0gc291cmNlWzJdLnRvU3RyaW5nKDE2KTtcbiAgICAgIGIgPSAoYi5sZW5ndGggPT09IDEpID8gKCcwJyArIGIpIDogYjtcblxuICAgICAgcmV0dXJuIHIudG9VcHBlckNhc2UoKSArIGcudG9VcHBlckNhc2UoKSArIGIudG9VcHBlckNhc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBIRVhBIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IEZGNTU1NUNDXG4gICAgICovXG4gICAgdG9IZXhhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLCBhO1xuXG4gICAgICBhID0gTWF0aC5yb3VuZChzb3VyY2VbM10gKiAyNTUpO1xuICAgICAgYSA9IGEudG9TdHJpbmcoMTYpO1xuICAgICAgYSA9IChhLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgYSkgOiBhO1xuXG4gICAgICByZXR1cm4gdGhpcy50b0hleCgpICsgYS50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHZhbHVlIG9mIGFscGhhIGNoYW5uZWwgZm9yIHRoaXMgY29sb3JcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IDAtMVxuICAgICAqL1xuICAgIGdldEFscGhhOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFNvdXJjZSgpWzNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHZhbHVlIG9mIGFscGhhIGNoYW5uZWwgZm9yIHRoaXMgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYWxwaGEgQWxwaGEgdmFsdWUgMC0xXG4gICAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfSB0aGlzQXJnXG4gICAgICovXG4gICAgc2V0QWxwaGE6IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICAgIHNvdXJjZVszXSA9IGFscGhhO1xuICAgICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGNvbG9yIHRvIGl0cyBncmF5c2NhbGUgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICB0b0dyYXlzY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBhdmVyYWdlID0gcGFyc2VJbnQoKHNvdXJjZVswXSAqIDAuMyArIHNvdXJjZVsxXSAqIDAuNTkgKyBzb3VyY2VbMl0gKiAwLjExKS50b0ZpeGVkKDApLCAxMCksXG4gICAgICAgICAgY3VycmVudEFscGhhID0gc291cmNlWzNdO1xuICAgICAgdGhpcy5zZXRTb3VyY2UoW2F2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGN1cnJlbnRBbHBoYV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgY29sb3IgdG8gaXRzIGJsYWNrIGFuZCB3aGl0ZSByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICB0b0JsYWNrV2hpdGU6IGZ1bmN0aW9uKHRocmVzaG9sZCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgYXZlcmFnZSA9IChzb3VyY2VbMF0gKiAwLjMgKyBzb3VyY2VbMV0gKiAwLjU5ICsgc291cmNlWzJdICogMC4xMSkudG9GaXhlZCgwKSxcbiAgICAgICAgICBjdXJyZW50QWxwaGEgPSBzb3VyY2VbM107XG5cbiAgICAgIHRocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAxMjc7XG5cbiAgICAgIGF2ZXJhZ2UgPSAoTnVtYmVyKGF2ZXJhZ2UpIDwgTnVtYmVyKHRocmVzaG9sZCkpID8gMCA6IDI1NTtcbiAgICAgIHRoaXMuc2V0U291cmNlKFthdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjdXJyZW50QWxwaGFdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPdmVybGF5cyBjb2xvciB3aXRoIGFub3RoZXIgY29sb3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xmYWJyaWMuQ29sb3J9IG90aGVyQ29sb3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBvdmVybGF5V2l0aDogZnVuY3Rpb24ob3RoZXJDb2xvcikge1xuICAgICAgaWYgKCEob3RoZXJDb2xvciBpbnN0YW5jZW9mIENvbG9yKSkge1xuICAgICAgICBvdGhlckNvbG9yID0gbmV3IENvbG9yKG90aGVyQ29sb3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgYWxwaGEgPSB0aGlzLmdldEFscGhhKCksXG4gICAgICAgICAgb3RoZXJBbHBoYSA9IDAuNSxcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIG90aGVyU291cmNlID0gb3RoZXJDb2xvci5nZXRTb3VyY2UoKSwgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChNYXRoLnJvdW5kKChzb3VyY2VbaV0gKiAoMSAtIG90aGVyQWxwaGEpKSArIChvdGhlclNvdXJjZVtpXSAqIG90aGVyQWxwaGEpKSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFszXSA9IGFscGhhO1xuICAgICAgdGhpcy5zZXRTb3VyY2UocmVzdWx0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVnZXggbWF0Y2hpbmcgY29sb3IgaW4gUkdCIG9yIFJHQkEgZm9ybWF0cyAoZXg6IHJnYigwLCAwLCAwKSwgcmdiYSgyNTUsIDEwMCwgMTAsIDAuNSksIHJnYmEoIDI1NSAsIDEwMCAsIDEwICwgMC41ICksIHJnYigxLDEsMSksIHJnYmEoMTAwJSwgNjAlLCAxMCUsIDAuNSkpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIGZhYnJpYy5Db2xvci5yZVJHQmEgPSAvXnJnYmE/XFwoXFxzKihcXGR7MSwzfSg/OlxcLlxcZCspP1xcJT8pXFxzKixcXHMqKFxcZHsxLDN9KD86XFwuXFxkKyk/XFwlPylcXHMqLFxccyooXFxkezEsM30oPzpcXC5cXGQrKT9cXCU/KVxccyooPzpcXHMqLFxccyooKD86XFxkKlxcLj9cXGQrKT8pXFxzKik/XFwpJC9pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBjb2xvciBpbiBIU0wgb3IgSFNMQSBmb3JtYXRzIChleDogaHNsKDIwMCwgODAlLCAxMCUpLCBoc2xhKDMwMCwgNTAlLCA4MCUsIDAuNSksIGhzbGEoIDMwMCAsIDUwJSAsIDgwJSAsIDAuNSApKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3IucmVIU0xhID0gL15oc2xhP1xcKFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9XFwlKVxccyosXFxzKihcXGR7MSwzfVxcJSlcXHMqKD86XFxzKixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFxzKik/XFwpJC9pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBjb2xvciBpbiBIRVggZm9ybWF0IChleDogI0ZGNTU0NENDLCAjRkY1NTU1LCAwMTAxNTUsIGFmZilcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKi9cbiAgZmFicmljLkNvbG9yLnJlSGV4ID0gL14jPyhbMC05YS1mXXs4fXxbMC05YS1mXXs2fXxbMC05YS1mXXs0fXxbMC05YS1mXXszfSkkL2k7XG5cbiAgLyoqXG4gICAqIE1hcCBvZiB0aGUgMTQ4IGNvbG9yIG5hbWVzIHdpdGggSEVYIGNvZGVcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAc2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jc3ZnLWNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3IuY29sb3JOYW1lTWFwID0ge1xuICAgIGFsaWNlYmx1ZTogICAgICAgICAgICAnI0YwRjhGRicsXG4gICAgYW50aXF1ZXdoaXRlOiAgICAgICAgICcjRkFFQkQ3JyxcbiAgICBhcXVhOiAgICAgICAgICAgICAgICAgJyMwMEZGRkYnLFxuICAgIGFxdWFtYXJpbmU6ICAgICAgICAgICAnIzdGRkZENCcsXG4gICAgYXp1cmU6ICAgICAgICAgICAgICAgICcjRjBGRkZGJyxcbiAgICBiZWlnZTogICAgICAgICAgICAgICAgJyNGNUY1REMnLFxuICAgIGJpc3F1ZTogICAgICAgICAgICAgICAnI0ZGRTRDNCcsXG4gICAgYmxhY2s6ICAgICAgICAgICAgICAgICcjMDAwMDAwJyxcbiAgICBibGFuY2hlZGFsbW9uZDogICAgICAgJyNGRkVCQ0QnLFxuICAgIGJsdWU6ICAgICAgICAgICAgICAgICAnIzAwMDBGRicsXG4gICAgYmx1ZXZpb2xldDogICAgICAgICAgICcjOEEyQkUyJyxcbiAgICBicm93bjogICAgICAgICAgICAgICAgJyNBNTJBMkEnLFxuICAgIGJ1cmx5d29vZDogICAgICAgICAgICAnI0RFQjg4NycsXG4gICAgY2FkZXRibHVlOiAgICAgICAgICAgICcjNUY5RUEwJyxcbiAgICBjaGFydHJldXNlOiAgICAgICAgICAgJyM3RkZGMDAnLFxuICAgIGNob2NvbGF0ZTogICAgICAgICAgICAnI0QyNjkxRScsXG4gICAgY29yYWw6ICAgICAgICAgICAgICAgICcjRkY3RjUwJyxcbiAgICBjb3JuZmxvd2VyYmx1ZTogICAgICAgJyM2NDk1RUQnLFxuICAgIGNvcm5zaWxrOiAgICAgICAgICAgICAnI0ZGRjhEQycsXG4gICAgY3JpbXNvbjogICAgICAgICAgICAgICcjREMxNDNDJyxcbiAgICBjeWFuOiAgICAgICAgICAgICAgICAgJyMwMEZGRkYnLFxuICAgIGRhcmtibHVlOiAgICAgICAgICAgICAnIzAwMDA4QicsXG4gICAgZGFya2N5YW46ICAgICAgICAgICAgICcjMDA4QjhCJyxcbiAgICBkYXJrZ29sZGVucm9kOiAgICAgICAgJyNCODg2MEInLFxuICAgIGRhcmtncmF5OiAgICAgICAgICAgICAnI0E5QTlBOScsXG4gICAgZGFya2dyZXk6ICAgICAgICAgICAgICcjQTlBOUE5JyxcbiAgICBkYXJrZ3JlZW46ICAgICAgICAgICAgJyMwMDY0MDAnLFxuICAgIGRhcmtraGFraTogICAgICAgICAgICAnI0JEQjc2QicsXG4gICAgZGFya21hZ2VudGE6ICAgICAgICAgICcjOEIwMDhCJyxcbiAgICBkYXJrb2xpdmVncmVlbjogICAgICAgJyM1NTZCMkYnLFxuICAgIGRhcmtvcmFuZ2U6ICAgICAgICAgICAnI0ZGOEMwMCcsXG4gICAgZGFya29yY2hpZDogICAgICAgICAgICcjOTkzMkNDJyxcbiAgICBkYXJrcmVkOiAgICAgICAgICAgICAgJyM4QjAwMDAnLFxuICAgIGRhcmtzYWxtb246ICAgICAgICAgICAnI0U5OTY3QScsXG4gICAgZGFya3NlYWdyZWVuOiAgICAgICAgICcjOEZCQzhGJyxcbiAgICBkYXJrc2xhdGVibHVlOiAgICAgICAgJyM0ODNEOEInLFxuICAgIGRhcmtzbGF0ZWdyYXk6ICAgICAgICAnIzJGNEY0RicsXG4gICAgZGFya3NsYXRlZ3JleTogICAgICAgICcjMkY0RjRGJyxcbiAgICBkYXJrdHVycXVvaXNlOiAgICAgICAgJyMwMENFRDEnLFxuICAgIGRhcmt2aW9sZXQ6ICAgICAgICAgICAnIzk0MDBEMycsXG4gICAgZGVlcHBpbms6ICAgICAgICAgICAgICcjRkYxNDkzJyxcbiAgICBkZWVwc2t5Ymx1ZTogICAgICAgICAgJyMwMEJGRkYnLFxuICAgIGRpbWdyYXk6ICAgICAgICAgICAgICAnIzY5Njk2OScsXG4gICAgZGltZ3JleTogICAgICAgICAgICAgICcjNjk2OTY5JyxcbiAgICBkb2RnZXJibHVlOiAgICAgICAgICAgJyMxRTkwRkYnLFxuICAgIGZpcmVicmljazogICAgICAgICAgICAnI0IyMjIyMicsXG4gICAgZmxvcmFsd2hpdGU6ICAgICAgICAgICcjRkZGQUYwJyxcbiAgICBmb3Jlc3RncmVlbjogICAgICAgICAgJyMyMjhCMjInLFxuICAgIGZ1Y2hzaWE6ICAgICAgICAgICAgICAnI0ZGMDBGRicsXG4gICAgZ2FpbnNib3JvOiAgICAgICAgICAgICcjRENEQ0RDJyxcbiAgICBnaG9zdHdoaXRlOiAgICAgICAgICAgJyNGOEY4RkYnLFxuICAgIGdvbGQ6ICAgICAgICAgICAgICAgICAnI0ZGRDcwMCcsXG4gICAgZ29sZGVucm9kOiAgICAgICAgICAgICcjREFBNTIwJyxcbiAgICBncmF5OiAgICAgICAgICAgICAgICAgJyM4MDgwODAnLFxuICAgIGdyZXk6ICAgICAgICAgICAgICAgICAnIzgwODA4MCcsXG4gICAgZ3JlZW46ICAgICAgICAgICAgICAgICcjMDA4MDAwJyxcbiAgICBncmVlbnllbGxvdzogICAgICAgICAgJyNBREZGMkYnLFxuICAgIGhvbmV5ZGV3OiAgICAgICAgICAgICAnI0YwRkZGMCcsXG4gICAgaG90cGluazogICAgICAgICAgICAgICcjRkY2OUI0JyxcbiAgICBpbmRpYW5yZWQ6ICAgICAgICAgICAgJyNDRDVDNUMnLFxuICAgIGluZGlnbzogICAgICAgICAgICAgICAnIzRCMDA4MicsXG4gICAgaXZvcnk6ICAgICAgICAgICAgICAgICcjRkZGRkYwJyxcbiAgICBraGFraTogICAgICAgICAgICAgICAgJyNGMEU2OEMnLFxuICAgIGxhdmVuZGVyOiAgICAgICAgICAgICAnI0U2RTZGQScsXG4gICAgbGF2ZW5kZXJibHVzaDogICAgICAgICcjRkZGMEY1JyxcbiAgICBsYXduZ3JlZW46ICAgICAgICAgICAgJyM3Q0ZDMDAnLFxuICAgIGxlbW9uY2hpZmZvbjogICAgICAgICAnI0ZGRkFDRCcsXG4gICAgbGlnaHRibHVlOiAgICAgICAgICAgICcjQUREOEU2JyxcbiAgICBsaWdodGNvcmFsOiAgICAgICAgICAgJyNGMDgwODAnLFxuICAgIGxpZ2h0Y3lhbjogICAgICAgICAgICAnI0UwRkZGRicsXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjRkFGQUQyJyxcbiAgICBsaWdodGdyYXk6ICAgICAgICAgICAgJyNEM0QzRDMnLFxuICAgIGxpZ2h0Z3JleTogICAgICAgICAgICAnI0QzRDNEMycsXG4gICAgbGlnaHRncmVlbjogICAgICAgICAgICcjOTBFRTkwJyxcbiAgICBsaWdodHBpbms6ICAgICAgICAgICAgJyNGRkI2QzEnLFxuICAgIGxpZ2h0c2FsbW9uOiAgICAgICAgICAnI0ZGQTA3QScsXG4gICAgbGlnaHRzZWFncmVlbjogICAgICAgICcjMjBCMkFBJyxcbiAgICBsaWdodHNreWJsdWU6ICAgICAgICAgJyM4N0NFRkEnLFxuICAgIGxpZ2h0c2xhdGVncmF5OiAgICAgICAnIzc3ODg5OScsXG4gICAgbGlnaHRzbGF0ZWdyZXk6ICAgICAgICcjNzc4ODk5JyxcbiAgICBsaWdodHN0ZWVsYmx1ZTogICAgICAgJyNCMEM0REUnLFxuICAgIGxpZ2h0eWVsbG93OiAgICAgICAgICAnI0ZGRkZFMCcsXG4gICAgbGltZTogICAgICAgICAgICAgICAgICcjMDBGRjAwJyxcbiAgICBsaW1lZ3JlZW46ICAgICAgICAgICAgJyMzMkNEMzInLFxuICAgIGxpbmVuOiAgICAgICAgICAgICAgICAnI0ZBRjBFNicsXG4gICAgbWFnZW50YTogICAgICAgICAgICAgICcjRkYwMEZGJyxcbiAgICBtYXJvb246ICAgICAgICAgICAgICAgJyM4MDAwMDAnLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6ICAgICAnIzY2Q0RBQScsXG4gICAgbWVkaXVtYmx1ZTogICAgICAgICAgICcjMDAwMENEJyxcbiAgICBtZWRpdW1vcmNoaWQ6ICAgICAgICAgJyNCQTU1RDMnLFxuICAgIG1lZGl1bXB1cnBsZTogICAgICAgICAnIzkzNzBEQicsXG4gICAgbWVkaXVtc2VhZ3JlZW46ICAgICAgICcjM0NCMzcxJyxcbiAgICBtZWRpdW1zbGF0ZWJsdWU6ICAgICAgJyM3QjY4RUUnLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAgICAnIzAwRkE5QScsXG4gICAgbWVkaXVtdHVycXVvaXNlOiAgICAgICcjNDhEMUNDJyxcbiAgICBtZWRpdW12aW9sZXRyZWQ6ICAgICAgJyNDNzE1ODUnLFxuICAgIG1pZG5pZ2h0Ymx1ZTogICAgICAgICAnIzE5MTk3MCcsXG4gICAgbWludGNyZWFtOiAgICAgICAgICAgICcjRjVGRkZBJyxcbiAgICBtaXN0eXJvc2U6ICAgICAgICAgICAgJyNGRkU0RTEnLFxuICAgIG1vY2Nhc2luOiAgICAgICAgICAgICAnI0ZGRTRCNScsXG4gICAgbmF2YWpvd2hpdGU6ICAgICAgICAgICcjRkZERUFEJyxcbiAgICBuYXZ5OiAgICAgICAgICAgICAgICAgJyMwMDAwODAnLFxuICAgIG9sZGxhY2U6ICAgICAgICAgICAgICAnI0ZERjVFNicsXG4gICAgb2xpdmU6ICAgICAgICAgICAgICAgICcjODA4MDAwJyxcbiAgICBvbGl2ZWRyYWI6ICAgICAgICAgICAgJyM2QjhFMjMnLFxuICAgIG9yYW5nZTogICAgICAgICAgICAgICAnI0ZGQTUwMCcsXG4gICAgb3JhbmdlcmVkOiAgICAgICAgICAgICcjRkY0NTAwJyxcbiAgICBvcmNoaWQ6ICAgICAgICAgICAgICAgJyNEQTcwRDYnLFxuICAgIHBhbGVnb2xkZW5yb2Q6ICAgICAgICAnI0VFRThBQScsXG4gICAgcGFsZWdyZWVuOiAgICAgICAgICAgICcjOThGQjk4JyxcbiAgICBwYWxldHVycXVvaXNlOiAgICAgICAgJyNBRkVFRUUnLFxuICAgIHBhbGV2aW9sZXRyZWQ6ICAgICAgICAnI0RCNzA5MycsXG4gICAgcGFwYXlhd2hpcDogICAgICAgICAgICcjRkZFRkQ1JyxcbiAgICBwZWFjaHB1ZmY6ICAgICAgICAgICAgJyNGRkRBQjknLFxuICAgIHBlcnU6ICAgICAgICAgICAgICAgICAnI0NEODUzRicsXG4gICAgcGluazogICAgICAgICAgICAgICAgICcjRkZDMENCJyxcbiAgICBwbHVtOiAgICAgICAgICAgICAgICAgJyNEREEwREQnLFxuICAgIHBvd2RlcmJsdWU6ICAgICAgICAgICAnI0IwRTBFNicsXG4gICAgcHVycGxlOiAgICAgICAgICAgICAgICcjODAwMDgwJyxcbiAgICByZWJlY2NhcHVycGxlOiAgICAgICAgJyM2NjMzOTknLFxuICAgIHJlZDogICAgICAgICAgICAgICAgICAnI0ZGMDAwMCcsXG4gICAgcm9zeWJyb3duOiAgICAgICAgICAgICcjQkM4RjhGJyxcbiAgICByb3lhbGJsdWU6ICAgICAgICAgICAgJyM0MTY5RTEnLFxuICAgIHNhZGRsZWJyb3duOiAgICAgICAgICAnIzhCNDUxMycsXG4gICAgc2FsbW9uOiAgICAgICAgICAgICAgICcjRkE4MDcyJyxcbiAgICBzYW5keWJyb3duOiAgICAgICAgICAgJyNGNEE0NjAnLFxuICAgIHNlYWdyZWVuOiAgICAgICAgICAgICAnIzJFOEI1NycsXG4gICAgc2Vhc2hlbGw6ICAgICAgICAgICAgICcjRkZGNUVFJyxcbiAgICBzaWVubmE6ICAgICAgICAgICAgICAgJyNBMDUyMkQnLFxuICAgIHNpbHZlcjogICAgICAgICAgICAgICAnI0MwQzBDMCcsXG4gICAgc2t5Ymx1ZTogICAgICAgICAgICAgICcjODdDRUVCJyxcbiAgICBzbGF0ZWJsdWU6ICAgICAgICAgICAgJyM2QTVBQ0QnLFxuICAgIHNsYXRlZ3JheTogICAgICAgICAgICAnIzcwODA5MCcsXG4gICAgc2xhdGVncmV5OiAgICAgICAgICAgICcjNzA4MDkwJyxcbiAgICBzbm93OiAgICAgICAgICAgICAgICAgJyNGRkZBRkEnLFxuICAgIHNwcmluZ2dyZWVuOiAgICAgICAgICAnIzAwRkY3RicsXG4gICAgc3RlZWxibHVlOiAgICAgICAgICAgICcjNDY4MkI0JyxcbiAgICB0YW46ICAgICAgICAgICAgICAgICAgJyNEMkI0OEMnLFxuICAgIHRlYWw6ICAgICAgICAgICAgICAgICAnIzAwODA4MCcsXG4gICAgdGhpc3RsZTogICAgICAgICAgICAgICcjRDhCRkQ4JyxcbiAgICB0b21hdG86ICAgICAgICAgICAgICAgJyNGRjYzNDcnLFxuICAgIHR1cnF1b2lzZTogICAgICAgICAgICAnIzQwRTBEMCcsXG4gICAgdmlvbGV0OiAgICAgICAgICAgICAgICcjRUU4MkVFJyxcbiAgICB3aGVhdDogICAgICAgICAgICAgICAgJyNGNURFQjMnLFxuICAgIHdoaXRlOiAgICAgICAgICAgICAgICAnI0ZGRkZGRicsXG4gICAgd2hpdGVzbW9rZTogICAgICAgICAgICcjRjVGNUY1JyxcbiAgICB5ZWxsb3c6ICAgICAgICAgICAgICAgJyNGRkZGMDAnLFxuICAgIHllbGxvd2dyZWVuOiAgICAgICAgICAnIzlBQ0QzMidcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgaWYgKHQgPCAwKSB7XG4gICAgICB0ICs9IDE7XG4gICAgfVxuICAgIGlmICh0ID4gMSkge1xuICAgICAgdCAtPSAxO1xuICAgIH1cbiAgICBpZiAodCA8IDEgLyA2KSB7XG4gICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAxIC8gMikge1xuICAgICAgcmV0dXJuIHE7XG4gICAgfVxuICAgIGlmICh0IDwgMiAvIDMpIHtcbiAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gUkdCIGZvcm1hdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbVJnYiA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbVJnYihjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBSR0Igb3IgUkdCQSBmb3JtYXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IHJnYigwLTI1NSwwLTI1NSwwLTI1NSksIHJnYigwJS0xMDAlLDAlLTEwMCUsMCUtMTAwJSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKi9cbiAgZmFicmljLkNvbG9yLnNvdXJjZUZyb21SZ2IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHZhciBtYXRjaCA9IGNvbG9yLm1hdGNoKENvbG9yLnJlUkdCYSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCkgLyAoLyUkLy50ZXN0KG1hdGNoWzFdKSA/IDEwMCA6IDEpICogKC8lJC8udGVzdChtYXRjaFsxXSkgPyAyNTUgOiAxKSxcbiAgICAgICAgICBnID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKSAvICgvJSQvLnRlc3QobWF0Y2hbMl0pID8gMTAwIDogMSkgKiAoLyUkLy50ZXN0KG1hdGNoWzJdKSA/IDI1NSA6IDEpLFxuICAgICAgICAgIGIgPSBwYXJzZUludChtYXRjaFszXSwgMTApIC8gKC8lJC8udGVzdChtYXRjaFszXSkgPyAxMDAgOiAxKSAqICgvJSQvLnRlc3QobWF0Y2hbM10pID8gMjU1IDogMSk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHBhcnNlSW50KHIsIDEwKSxcbiAgICAgICAgcGFyc2VJbnQoZywgMTApLFxuICAgICAgICBwYXJzZUludChiLCAxMCksXG4gICAgICAgIG1hdGNoWzRdID8gcGFyc2VGbG9hdChtYXRjaFs0XSkgOiAxXG4gICAgICBdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gUkdCQSBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21SZ2JhID0gQ29sb3IuZnJvbVJnYjtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gSFNMIGZvcm1hdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IGhzbCgwLTI2MCwwJS0xMDAlLDAlLTEwMCUpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21Ic2wgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiBDb2xvci5mcm9tU291cmNlKENvbG9yLnNvdXJjZUZyb21Ic2woY29sb3IpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhcnJheSByZXByZXNlbnRhdGlvbiAoZXg6IFsxMDAsIDEwMCwgMjAwLCAxXSkgb2YgYSBjb2xvciB0aGF0J3MgaW4gSFNMIG9yIEhTTEEgZm9ybWF0LlxuICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHBzOi8vcmF3Z2l0aHViLmNvbS9tamlqYWNrc29uL21qaWphY2tzb24uZ2l0aHViLmNvbS9tYXN0ZXIvMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0Lmh0bWxcIj5odHRwczovL2dpdGh1Yi5jb20vbWppamFja3NvbjwvYT5cbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IGhzbCgwLTM2MCwwJS0xMDAlLDAlLTEwMCUpIG9yIGhzbGEoMC0zNjAsMCUtMTAwJSwwJS0xMDAlLCAwLTEpXG4gICAqIEByZXR1cm4ge0FycmF5fSBzb3VyY2VcbiAgICogQHNlZSBodHRwOi8vaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci8jaHNsLWNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3Iuc291cmNlRnJvbUhzbCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgdmFyIG1hdGNoID0gY29sb3IubWF0Y2goQ29sb3IucmVIU0xhKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KG1hdGNoWzFdKSAlIDM2MCkgKyAzNjApICUgMzYwKSAvIDM2MCxcbiAgICAgICAgcyA9IHBhcnNlRmxvYXQobWF0Y2hbMl0pIC8gKC8lJC8udGVzdChtYXRjaFsyXSkgPyAxMDAgOiAxKSxcbiAgICAgICAgbCA9IHBhcnNlRmxvYXQobWF0Y2hbM10pIC8gKC8lJC8udGVzdChtYXRjaFszXSkgPyAxMDAgOiAxKSxcbiAgICAgICAgciwgZywgYjtcblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICByID0gZyA9IGIgPSBsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBxID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHMsXG4gICAgICAgICAgcCA9IGwgKiAyIC0gcTtcblxuICAgICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcbiAgICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgTWF0aC5yb3VuZChyICogMjU1KSxcbiAgICAgIE1hdGgucm91bmQoZyAqIDI1NSksXG4gICAgICBNYXRoLnJvdW5kKGIgKiAyNTUpLFxuICAgICAgbWF0Y2hbNF0gPyBwYXJzZUZsb2F0KG1hdGNoWzRdKSA6IDFcbiAgICBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIU0xBIGZvcm1hdFxuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhzbGEgPSBDb2xvci5mcm9tSHNsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIRVggZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IEZGNTU1NVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhleCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbUhleChjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBIRVggZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgZXg6IEZGNTU1NSBvciBGRjU1NDRDQyAoUkdCYSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKi9cbiAgZmFicmljLkNvbG9yLnNvdXJjZUZyb21IZXggPSBmdW5jdGlvbihjb2xvcikge1xuICAgIGlmIChjb2xvci5tYXRjaChDb2xvci5yZUhleCkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGNvbG9yLnNsaWNlKGNvbG9yLmluZGV4T2YoJyMnKSArIDEpLFxuICAgICAgICAgIGlzU2hvcnROb3RhdGlvbiA9ICh2YWx1ZS5sZW5ndGggPT09IDMgfHwgdmFsdWUubGVuZ3RoID09PSA0KSxcbiAgICAgICAgICBpc1JHQmEgPSAodmFsdWUubGVuZ3RoID09PSA4IHx8IHZhbHVlLmxlbmd0aCA9PT0gNCksXG4gICAgICAgICAgciA9IGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMCkgKyB2YWx1ZS5jaGFyQXQoMCkpIDogdmFsdWUuc3Vic3RyaW5nKDAsIDIpLFxuICAgICAgICAgIGcgPSBpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDEpICsgdmFsdWUuY2hhckF0KDEpKSA6IHZhbHVlLnN1YnN0cmluZygyLCA0KSxcbiAgICAgICAgICBiID0gaXNTaG9ydE5vdGF0aW9uID8gKHZhbHVlLmNoYXJBdCgyKSArIHZhbHVlLmNoYXJBdCgyKSkgOiB2YWx1ZS5zdWJzdHJpbmcoNCwgNiksXG4gICAgICAgICAgYSA9IGlzUkdCYSA/IChpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDMpICsgdmFsdWUuY2hhckF0KDMpKSA6IHZhbHVlLnN1YnN0cmluZyg2LCA4KSkgOiAnRkYnO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBwYXJzZUludChyLCAxNiksXG4gICAgICAgIHBhcnNlSW50KGcsIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoYiwgMTYpLFxuICAgICAgICBwYXJzZUZsb2F0KChwYXJzZUludChhLCAxNikgLyAyNTUpLnRvRml4ZWQoMikpXG4gICAgICBdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGNvbG9yIGluIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzIwMCwgMTAwLCAxMDAsIDAuNV0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21Tb3VyY2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICB2YXIgb0NvbG9yID0gbmV3IENvbG9yKCk7XG4gICAgb0NvbG9yLnNldFNvdXJjZShzb3VyY2UpO1xuICAgIHJldHVybiBvQ29sb3I7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIHNjYWxlTWFwID0gWydlJywgJ3NlJywgJ3MnLCAnc3cnLCAndycsICdudycsICduJywgJ25lJywgJ2UnXSxcbiAgICAgIHNrZXdNYXAgPSBbJ25zJywgJ25lc3cnLCAnZXcnLCAnbndzZSddLFxuICAgICAgY29udHJvbHMgPSB7fSxcbiAgICAgIExFRlQgPSAnbGVmdCcsIFRPUCA9ICd0b3AnLCBSSUdIVCA9ICdyaWdodCcsIEJPVFRPTSA9ICdib3R0b20nLCBDRU5URVIgPSAnY2VudGVyJyxcbiAgICAgIG9wcG9zaXRlID0ge1xuICAgICAgICB0b3A6IEJPVFRPTSxcbiAgICAgICAgYm90dG9tOiBUT1AsXG4gICAgICAgIGxlZnQ6IFJJR0hULFxuICAgICAgICByaWdodDogTEVGVCxcbiAgICAgICAgY2VudGVyOiBDRU5URVIsXG4gICAgICB9LCByYWRpYW5zVG9EZWdyZWVzID0gZmFicmljLnV0aWwucmFkaWFuc1RvRGVncmVlcyxcbiAgICAgIHNpZ24gPSAoTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICgoeCA+IDApIC0gKHggPCAwKSkgfHwgK3g7IH0pO1xuXG4gIC8qKlxuICAgKiBDb21iaW5lIGNvbnRyb2wgcG9zaXRpb24gYW5kIG9iamVjdCBhbmdsZSB0byBmaW5kIHRoZSBjb250cm9sIGRpcmVjdGlvbiBjb21wYXJlZFxuICAgKiB0byB0aGUgb2JqZWN0IGNlbnRlci5cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgZm9yIHdoaWNoIHdlIGFyZSByZW5kZXJpbmcgY29udHJvbHNcbiAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY29udHJvbCBjbGFzc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IDAgLSA3IGEgcXVhZHJhbnQgbnVtYmVyXG4gICAqL1xuICBmdW5jdGlvbiBmaW5kQ29ybmVyUXVhZHJhbnQoZmFicmljT2JqZWN0LCBjb250cm9sKSB7XG4gICAgdmFyIGNvcm5lckFuZ2xlID0gZmFicmljT2JqZWN0LmFuZ2xlICsgcmFkaWFuc1RvRGVncmVlcyhNYXRoLmF0YW4yKGNvbnRyb2wueSwgY29udHJvbC54KSkgKyAzNjA7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKGNvcm5lckFuZ2xlICUgMzYwKSAvIDQ1KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcmVFdmVudChldmVudE5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICBjYW52YXMgPSB0YXJnZXQuY2FudmFzLFxuICAgICAgICBjYW52YXNPcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9wdGlvbnMpO1xuICAgIGNhbnZhc09wdGlvbnMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIGNhbnZhcyAmJiBjYW52YXMuZmlyZSgnb2JqZWN0OicgKyBldmVudE5hbWUsIGNhbnZhc09wdGlvbnMpO1xuICAgIHRhcmdldC5maXJlKGV2ZW50TmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogSW5zcGVjdCBldmVudCBhbmQgZmFicmljT2JqZWN0IHByb3BlcnRpZXMgdG8gdW5kZXJzdGFuZCBpZiB0aGUgc2NhbGluZyBhY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGZyb20gdGhlIHVzZXIgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IGFib3V0IHRvIHNjYWxlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc2NhbGUgaXMgcHJvcG9ydGlvbmFsXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZUlzUHJvcG9ydGlvbmFsKGV2ZW50RGF0YSwgZmFicmljT2JqZWN0KSB7XG4gICAgdmFyIGNhbnZhcyA9IGZhYnJpY09iamVjdC5jYW52YXMsIHVuaVNjYWxlS2V5ID0gY2FudmFzLnVuaVNjYWxlS2V5LFxuICAgICAgICB1bmlmb3JtSXNUb2dnbGVkID0gZXZlbnREYXRhW3VuaVNjYWxlS2V5XTtcbiAgICByZXR1cm4gKGNhbnZhcy51bmlmb3JtU2NhbGluZyAmJiAhdW5pZm9ybUlzVG9nZ2xlZCkgfHxcbiAgICAoIWNhbnZhcy51bmlmb3JtU2NhbGluZyAmJiB1bmlmb3JtSXNUb2dnbGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdHJhbnNmb3JtIGlzIGNlbnRlcmVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gdHJhbnNmb3JtIGRhdGFcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0cmFuc2Zvcm0gaXMgY2VudGVyZWRcbiAgICovXG4gIGZ1bmN0aW9uIGlzVHJhbnNmb3JtQ2VudGVyZWQodHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybS5vcmlnaW5YID09PSBDRU5URVIgJiYgdHJhbnNmb3JtLm9yaWdpblkgPT09IENFTlRFUjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNwZWN0IGZhYnJpY09iamVjdCB0byB1bmRlcnN0YW5kIGlmIHRoZSBjdXJyZW50IHNjYWxpbmcgYWN0aW9uIGlzIGFsbG93ZWRcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgYWJvdXQgdG8gc2NhbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ5ICd4JyBvciAneScgb3IgJydcbiAgICogQHBhcmFtIHtCb29sZWFufSBzY2FsZVByb3BvcnRpb25hbGx5IHRydWUgaWYgd2UgYXJlIHRyeWluZyB0byBzY2FsZSBwcm9wb3J0aW9uYWxseVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNjYWxpbmcgaXMgbm90IGFsbG93ZWQgYXQgY3VycmVudCBjb25kaXRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsaW5nSXNGb3JiaWRkZW4oZmFicmljT2JqZWN0LCBieSwgc2NhbGVQcm9wb3J0aW9uYWxseSkge1xuICAgIHZhciBsb2NrWCA9IGZhYnJpY09iamVjdC5sb2NrU2NhbGluZ1gsIGxvY2tZID0gZmFicmljT2JqZWN0LmxvY2tTY2FsaW5nWTtcbiAgICBpZiAobG9ja1ggJiYgbG9ja1kpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWJ5ICYmIChsb2NrWCB8fCBsb2NrWSkgJiYgc2NhbGVQcm9wb3J0aW9uYWxseSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChsb2NrWCAmJiBieSA9PT0gJ3gnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGxvY2tZICYmIGJ5ID09PSAneScpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIHRoZSBjb3JyZWN0IGN1cnNvciBzdHlsZSBmb3IgdGhlIHNjYWxlIGFjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBjYXVzaW5nIHRoZSBzY2FsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjb250cm9sIHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYSB2YWxpZCBjc3Mgc3RyaW5nIGZvciB0aGUgY3Vyc29yXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZUN1cnNvclN0eWxlSGFuZGxlcihldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCkge1xuICAgIHZhciBub3RBbGxvd2VkID0gJ25vdC1hbGxvd2VkJyxcbiAgICAgICAgc2NhbGVQcm9wb3J0aW9uYWxseSA9IHNjYWxlSXNQcm9wb3J0aW9uYWwoZXZlbnREYXRhLCBmYWJyaWNPYmplY3QpLFxuICAgICAgICBieSA9ICcnO1xuICAgIGlmIChjb250cm9sLnggIT09IDAgJiYgY29udHJvbC55ID09PSAwKSB7XG4gICAgICBieSA9ICd4JztcbiAgICB9XG4gICAgZWxzZSBpZiAoY29udHJvbC54ID09PSAwICYmIGNvbnRyb2wueSAhPT0gMCkge1xuICAgICAgYnkgPSAneSc7XG4gICAgfVxuICAgIGlmIChzY2FsaW5nSXNGb3JiaWRkZW4oZmFicmljT2JqZWN0LCBieSwgc2NhbGVQcm9wb3J0aW9uYWxseSkpIHtcbiAgICAgIHJldHVybiBub3RBbGxvd2VkO1xuICAgIH1cbiAgICB2YXIgbiA9IGZpbmRDb3JuZXJRdWFkcmFudChmYWJyaWNPYmplY3QsIGNvbnRyb2wpO1xuICAgIHJldHVybiBzY2FsZU1hcFtuXSArICctcmVzaXplJztcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm4gdGhlIGNvcnJlY3QgY3Vyc29yIHN0eWxlIGZvciB0aGUgc2tldyBhY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgY2F1c2luZyB0aGUgc2NhbGVcbiAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY29udHJvbCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGEgdmFsaWQgY3NzIHN0cmluZyBmb3IgdGhlIGN1cnNvclxuICAgKi9cbiAgZnVuY3Rpb24gc2tld0N1cnNvclN0eWxlSGFuZGxlcihldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCkge1xuICAgIHZhciBub3RBbGxvd2VkID0gJ25vdC1hbGxvd2VkJztcbiAgICBpZiAoY29udHJvbC54ICE9PSAwICYmIGZhYnJpY09iamVjdC5sb2NrU2tld2luZ1kpIHtcbiAgICAgIHJldHVybiBub3RBbGxvd2VkO1xuICAgIH1cbiAgICBpZiAoY29udHJvbC55ICE9PSAwICYmIGZhYnJpY09iamVjdC5sb2NrU2tld2luZ1gpIHtcbiAgICAgIHJldHVybiBub3RBbGxvd2VkO1xuICAgIH1cbiAgICB2YXIgbiA9IGZpbmRDb3JuZXJRdWFkcmFudChmYWJyaWNPYmplY3QsIGNvbnRyb2wpICUgNDtcbiAgICByZXR1cm4gc2tld01hcFtuXSArICctcmVzaXplJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lIHNrZXcgYW5kIHNjYWxlIHN0eWxlIGhhbmRsZXJzIHRvIGNvdmVyIGZhYnJpYyBzdGFuZGFyZCB1c2UgY2FzZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBjYXVzaW5nIHRoZSBzY2FsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjb250cm9sIHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYSB2YWxpZCBjc3Mgc3RyaW5nIGZvciB0aGUgY3Vyc29yXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZVNrZXdDdXJzb3JTdHlsZUhhbmRsZXIoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpIHtcbiAgICBpZiAoZXZlbnREYXRhW2ZhYnJpY09iamVjdC5jYW52YXMuYWx0QWN0aW9uS2V5XSkge1xuICAgICAgcmV0dXJuIGNvbnRyb2xzLnNrZXdDdXJzb3JTdHlsZUhhbmRsZXIoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJvbHMuc2NhbGVDdXJzb3JTdHlsZUhhbmRsZXIoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3BlY3QgZXZlbnQsIGNvbnRyb2wgYW5kIGZhYnJpY09iamVjdCB0byByZXR1cm4gdGhlIGNvcnJlY3QgYWN0aW9uIG5hbWVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgY2F1c2luZyB0aGUgc2NhbGVcbiAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY29udHJvbCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGFuIGFjdGlvbiBuYW1lXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZU9yU2tld0FjdGlvbk5hbWUoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpIHtcbiAgICB2YXIgaXNBbHRlcm5hdGl2ZSA9IGV2ZW50RGF0YVtmYWJyaWNPYmplY3QuY2FudmFzLmFsdEFjdGlvbktleV07XG4gICAgaWYgKGNvbnRyb2wueCA9PT0gMCkge1xuICAgICAgLy8gdGhlbiBpcyBzY2FsZVkgb3Igc2tld1hcbiAgICAgIHJldHVybiBpc0FsdGVybmF0aXZlID8gJ3NrZXdYJyA6ICdzY2FsZVknO1xuICAgIH1cbiAgICBpZiAoY29udHJvbC55ID09PSAwKSB7XG4gICAgICAvLyB0aGVuIGlzIHNjYWxlWSBvciBza2V3WFxuICAgICAgcmV0dXJuIGlzQWx0ZXJuYXRpdmUgPyAnc2tld1knIDogJ3NjYWxlWCc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGNvcnJlY3Qgc3R5bGUgZm9yIHRoZSBjb250cm9sIHRoYXQgaXMgdXNlZCBmb3Igcm90YXRpb24uXG4gICAqIHRoaXMgZnVuY3Rpb24gaXMgdmVyeSBzaW1wbGUgYW5kIGl0IGp1c3QgdGFrZSBjYXJlIG9mIG5vdC1hbGxvd2VkIG9yIHN0YW5kYXJkIGN1cnNvclxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBjYXVzaW5nIHRoZSBzY2FsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjb250cm9sIHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYSB2YWxpZCBjc3Mgc3RyaW5nIGZvciB0aGUgY3Vyc29yXG4gICAqL1xuICBmdW5jdGlvbiByb3RhdGlvblN0eWxlSGFuZGxlcihldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCkge1xuICAgIGlmIChmYWJyaWNPYmplY3QubG9ja1JvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gJ25vdC1hbGxvd2VkJztcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2wuY3Vyc29yU3R5bGU7XG4gIH1cblxuICBmdW5jdGlvbiBjb21tb25FdmVudEluZm8oZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZTogZXZlbnREYXRhLFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICBwb2ludGVyOiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwIGFuIGFjdGlvbiBoYW5kbGVyIHdpdGggc2F2aW5nL3Jlc3RvcmluZyBvYmplY3QgcG9zaXRpb24gb24gdGhlIHRyYW5zZm9ybS5cbiAgICogdGhpcyBpcyB0aGUgY29kZSB0aGF0IHBlcm1pdHMgdG8gb2JqZWN0cyB0byBrZWVwIHRoZWlyIHBvc2l0aW9uIHdoaWxlIHRyYW5zZm9ybWluZy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uSGFuZGxlciB0aGUgZnVuY3Rpb24gdG8gd3JhcFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB3aXRoIGFuIGFjdGlvbiBoYW5kbGVyIHNpZ25hdHVyZVxuICAgKi9cbiAgZnVuY3Rpb24gd3JhcFdpdGhGaXhlZEFuY2hvcihhY3Rpb25IYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCwgY2VudGVyUG9pbnQgPSB0YXJnZXQuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgICBjb25zdHJhaW50ID0gdGFyZ2V0LnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoY2VudGVyUG9pbnQsIHRyYW5zZm9ybS5vcmlnaW5YLCB0cmFuc2Zvcm0ub3JpZ2luWSksXG4gICAgICAgICAgYWN0aW9uUGVyZm9ybWVkID0gYWN0aW9uSGFuZGxlcihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gICAgICB0YXJnZXQuc2V0UG9zaXRpb25CeU9yaWdpbihjb25zdHJhaW50LCB0cmFuc2Zvcm0ub3JpZ2luWCwgdHJhbnNmb3JtLm9yaWdpblkpO1xuICAgICAgcmV0dXJuIGFjdGlvblBlcmZvcm1lZDtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXAgYW4gYWN0aW9uIGhhbmRsZXIgd2l0aCBmaXJpbmcgYW4gZXZlbnQgaWYgdGhlIGFjdGlvbiBpcyBwZXJmb3JtZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYWN0aW9uSGFuZGxlciB0aGUgZnVuY3Rpb24gdG8gd3JhcFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB3aXRoIGFuIGFjdGlvbiBoYW5kbGVyIHNpZ25hdHVyZVxuICAgKi9cbiAgZnVuY3Rpb24gd3JhcFdpdGhGaXJlRXZlbnQoZXZlbnROYW1lLCBhY3Rpb25IYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgICB2YXIgYWN0aW9uUGVyZm9ybWVkID0gYWN0aW9uSGFuZGxlcihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gICAgICBpZiAoYWN0aW9uUGVyZm9ybWVkKSB7XG4gICAgICAgIGZpcmVFdmVudChldmVudE5hbWUsIGNvbW1vbkV2ZW50SW5mbyhldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjdGlvblBlcmZvcm1lZDtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgYSBwb2ludCBkZXNjcmliZWQgYnkgeCBhbmQgeSBpbiBhIGRpc3RhbmNlIGZyb20gdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgb2JqZWN0XG4gICAqIGJvdW5kaW5nIGJveC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWVxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtGYWJyaWMuUG9pbnR9IHRoZSBub3JtYWxpemVkIHBvaW50XG4gICAqL1xuICBmdW5jdGlvbiBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgb3JpZ2luWCwgb3JpZ2luWSwgeCwgeSkge1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW3RyYW5zZm9ybS5jb3JuZXJdLFxuICAgICAgICB6b29tID0gdGFyZ2V0LmNhbnZhcy5nZXRab29tKCksXG4gICAgICAgIHBhZGRpbmcgPSB0YXJnZXQucGFkZGluZyAvIHpvb20sXG4gICAgICAgIGxvY2FsUG9pbnQgPSB0YXJnZXQudG9Mb2NhbFBvaW50KG5ldyBmYWJyaWMuUG9pbnQoeCwgeSksIG9yaWdpblgsIG9yaWdpblkpO1xuICAgIGlmIChsb2NhbFBvaW50LnggPj0gcGFkZGluZykge1xuICAgICAgbG9jYWxQb2ludC54IC09IHBhZGRpbmc7XG4gICAgfVxuICAgIGlmIChsb2NhbFBvaW50LnggPD0gLXBhZGRpbmcpIHtcbiAgICAgIGxvY2FsUG9pbnQueCArPSBwYWRkaW5nO1xuICAgIH1cbiAgICBpZiAobG9jYWxQb2ludC55ID49IHBhZGRpbmcpIHtcbiAgICAgIGxvY2FsUG9pbnQueSAtPSBwYWRkaW5nO1xuICAgIH1cbiAgICBpZiAobG9jYWxQb2ludC55IDw9IHBhZGRpbmcpIHtcbiAgICAgIGxvY2FsUG9pbnQueSArPSBwYWRkaW5nO1xuICAgIH1cbiAgICBsb2NhbFBvaW50LnggLT0gY29udHJvbC5vZmZzZXRYO1xuICAgIGxvY2FsUG9pbnQueSAtPSBjb250cm9sLm9mZnNldFk7XG4gICAgcmV0dXJuIGxvY2FsUG9pbnQ7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGlmIHRoZSBmYWJyaWMgb2JqZWN0IGlzIGZsaXBwZWQgb24gb25lIHNpZGUuXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb25lIGZsaXAsIGJ1dCBub3QgdHdvLlxuICAgKi9cbiAgZnVuY3Rpb24gdGFyZ2V0SGFzT25lRmxpcCh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0LmZsaXBYICE9PSB0YXJnZXQuZmxpcFk7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBjb21wZW5zYXRlIHRoZSBzY2FsZSBmYWN0b3Igd2hlbiBza2V3IGlzIGFwcGxpZWQgb24gYm90aCBheGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjb21wZW5zYXRlU2NhbGVGb3JTa2V3KHRhcmdldCwgb3Bwb3NpdGVTa2V3LCBzY2FsZVRvQ29tcGVuc2F0ZSwgYXhpcywgcmVmZXJlbmNlKSB7XG4gICAgaWYgKHRhcmdldFtvcHBvc2l0ZVNrZXddICE9PSAwKSB7XG4gICAgICB2YXIgbmV3RGltID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKVtheGlzXTtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHJlZmVyZW5jZSAvIG5ld0RpbSAqIHRhcmdldFtzY2FsZVRvQ29tcGVuc2F0ZV07XG4gICAgICB0YXJnZXQuc2V0KHNjYWxlVG9Db21wZW5zYXRlLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjdGlvbiBoYW5kbGVyIGZvciBza2V3aW5nIG9uIHRoZSBYIGF4aXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNrZXdPYmplY3RYKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgIC8vIGZpbmQgaG93IGJpZyB0aGUgb2JqZWN0IHdvdWxkIGJlLCBpZiB0aGVyZSB3YXMgbm8gc2tld1guIHRha2VzIGluIGFjY291bnQgc2NhbGluZ1xuICAgICAgICBkaW1Ob1NrZXcgPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygwLCB0YXJnZXQuc2tld1kpLFxuICAgICAgICBsb2NhbFBvaW50ID0gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIHRyYW5zZm9ybS5vcmlnaW5YLCB0cmFuc2Zvcm0ub3JpZ2luWSwgeCwgeSksXG4gICAgICAgIC8vIHRoZSBtb3VzZSBpcyBpbiB0aGUgY2VudGVyIG9mIHRoZSBvYmplY3QsIGFuZCB3ZSB3YW50IGl0IHRvIHN0YXkgdGhlcmUuXG4gICAgICAgIC8vIHNvIHRoZSBvYmplY3Qgd2lsbCBncm93IHR3aWNlIGFzIG11Y2ggYXMgdGhlIG1vdXNlLlxuICAgICAgICAvLyB0aGlzIG1ha2VzIHRoZSBza2V3IGdyb3d0aCB0byBsb2NhbFBvaW50ICogMiAtIGRpbU5vU2tldy5cbiAgICAgICAgdG90YWxTa2V3U2l6ZSA9IE1hdGguYWJzKGxvY2FsUG9pbnQueCAqIDIpIC0gZGltTm9Ta2V3LngsXG4gICAgICAgIGN1cnJlbnRTa2V3ID0gdGFyZ2V0LnNrZXdYLCBuZXdTa2V3O1xuICAgIGlmICh0b3RhbFNrZXdTaXplIDwgMikge1xuICAgICAgLy8gbGV0J3MgbWFrZSBpdCBlYXN5IHRvIGdvIGJhY2sgdG8gcG9zaXRpb24gMC5cbiAgICAgIG5ld1NrZXcgPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG5ld1NrZXcgPSByYWRpYW5zVG9EZWdyZWVzKFxuICAgICAgICBNYXRoLmF0YW4yKCh0b3RhbFNrZXdTaXplIC8gdGFyZ2V0LnNjYWxlWCksIChkaW1Ob1NrZXcueSAvIHRhcmdldC5zY2FsZVkpKVxuICAgICAgKTtcbiAgICAgIC8vIG5vdyB3ZSBoYXZlIHRvIGZpbmQgdGhlIHNpZ24gb2YgdGhlIHNrZXcuXG4gICAgICAvLyBpdCBtb3N0bHkgZGVwZW5kIG9uIHRoZSBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24uXG4gICAgICBpZiAodHJhbnNmb3JtLm9yaWdpblggPT09IExFRlQgJiYgdHJhbnNmb3JtLm9yaWdpblkgPT09IEJPVFRPTSkge1xuICAgICAgICBuZXdTa2V3ID0gLW5ld1NrZXc7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtLm9yaWdpblggPT09IFJJR0hUICYmIHRyYW5zZm9ybS5vcmlnaW5ZID09PSBUT1ApIHtcbiAgICAgICAgbmV3U2tldyA9IC1uZXdTa2V3O1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldEhhc09uZUZsaXAodGFyZ2V0KSkge1xuICAgICAgICBuZXdTa2V3ID0gLW5ld1NrZXc7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBoYXNTa2V3ZWQgPSBjdXJyZW50U2tldyAhPT0gbmV3U2tldztcbiAgICBpZiAoaGFzU2tld2VkKSB7XG4gICAgICB2YXIgZGltQmVmb3JlU2tld2luZyA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCkueTtcbiAgICAgIHRhcmdldC5zZXQoJ3NrZXdYJywgbmV3U2tldyk7XG4gICAgICBjb21wZW5zYXRlU2NhbGVGb3JTa2V3KHRhcmdldCwgJ3NrZXdZJywgJ3NjYWxlWScsICd5JywgZGltQmVmb3JlU2tld2luZyk7XG4gICAgfVxuICAgIHJldHVybiBoYXNTa2V3ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQWN0aW9uIGhhbmRsZXIgZm9yIHNrZXdpbmcgb24gdGhlIFkgYXhpc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2tld09iamVjdFkoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgLy8gZmluZCBob3cgYmlnIHRoZSBvYmplY3Qgd291bGQgYmUsIGlmIHRoZXJlIHdhcyBubyBza2V3WC4gdGFrZXMgaW4gYWNjb3VudCBzY2FsaW5nXG4gICAgICAgIGRpbU5vU2tldyA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKHRhcmdldC5za2V3WCwgMCksXG4gICAgICAgIGxvY2FsUG9pbnQgPSBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgdHJhbnNmb3JtLm9yaWdpblgsIHRyYW5zZm9ybS5vcmlnaW5ZLCB4LCB5KSxcbiAgICAgICAgLy8gdGhlIG1vdXNlIGlzIGluIHRoZSBjZW50ZXIgb2YgdGhlIG9iamVjdCwgYW5kIHdlIHdhbnQgaXQgdG8gc3RheSB0aGVyZS5cbiAgICAgICAgLy8gc28gdGhlIG9iamVjdCB3aWxsIGdyb3cgdHdpY2UgYXMgbXVjaCBhcyB0aGUgbW91c2UuXG4gICAgICAgIC8vIHRoaXMgbWFrZXMgdGhlIHNrZXcgZ3Jvd3RoIHRvIGxvY2FsUG9pbnQgKiAyIC0gZGltTm9Ta2V3LlxuICAgICAgICB0b3RhbFNrZXdTaXplID0gTWF0aC5hYnMobG9jYWxQb2ludC55ICogMikgLSBkaW1Ob1NrZXcueSxcbiAgICAgICAgY3VycmVudFNrZXcgPSB0YXJnZXQuc2tld1ksIG5ld1NrZXc7XG4gICAgaWYgKHRvdGFsU2tld1NpemUgPCAyKSB7XG4gICAgICAvLyBsZXQncyBtYWtlIGl0IGVhc3kgdG8gZ28gYmFjayB0byBwb3NpdGlvbiAwLlxuICAgICAgbmV3U2tldyA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbmV3U2tldyA9IHJhZGlhbnNUb0RlZ3JlZXMoXG4gICAgICAgIE1hdGguYXRhbjIoKHRvdGFsU2tld1NpemUgLyB0YXJnZXQuc2NhbGVZKSwgKGRpbU5vU2tldy54IC8gdGFyZ2V0LnNjYWxlWCkpXG4gICAgICApO1xuICAgICAgLy8gbm93IHdlIGhhdmUgdG8gZmluZCB0aGUgc2lnbiBvZiB0aGUgc2tldy5cbiAgICAgIC8vIGl0IG1vc3RseSBkZXBlbmQgb24gdGhlIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgIGlmICh0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gTEVGVCAmJiB0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gQk9UVE9NKSB7XG4gICAgICAgIG5ld1NrZXcgPSAtbmV3U2tldztcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gUklHSFQgJiYgdHJhbnNmb3JtLm9yaWdpblkgPT09IFRPUCkge1xuICAgICAgICBuZXdTa2V3ID0gLW5ld1NrZXc7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0SGFzT25lRmxpcCh0YXJnZXQpKSB7XG4gICAgICAgIG5ld1NrZXcgPSAtbmV3U2tldztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGhhc1NrZXdlZCA9IGN1cnJlbnRTa2V3ICE9PSBuZXdTa2V3O1xuICAgIGlmIChoYXNTa2V3ZWQpIHtcbiAgICAgIHZhciBkaW1CZWZvcmVTa2V3aW5nID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKS54O1xuICAgICAgdGFyZ2V0LnNldCgnc2tld1knLCBuZXdTa2V3KTtcbiAgICAgIGNvbXBlbnNhdGVTY2FsZUZvclNrZXcodGFyZ2V0LCAnc2tld1gnLCAnc2NhbGVYJywgJ3gnLCBkaW1CZWZvcmVTa2V3aW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc1NrZXdlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVkIEFjdGlvbiBoYW5kbGVyIGZvciBza2V3aW5nIG9uIHRoZSBZIGF4aXMsIHRha2VzIGNhcmUgb2YgdGhlXG4gICAqIHNrZXcgZGlyZWN0aW9uIGFuZCBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIG9yaWdpbiBmb3IgdGhlIGFuY2hvciBwb2ludFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNrZXdIYW5kbGVyWChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIC8vIHN0ZXAxIGZpZ3VyZSBvdXQgYW5kIGNoYW5nZSB0cmFuc2Zvcm0gb3JpZ2luLlxuICAgIC8vIGlmIHNrZXdYID4gMCBhbmQgb3JpZ2luWSBib3R0b20gd2UgYW5jaG9yIG9uIHJpZ2h0XG4gICAgLy8gaWYgc2tld1ggPiAwIGFuZCBvcmlnaW5ZIHRvcCB3ZSBhbmNob3Igb24gbGVmdFxuICAgIC8vIGlmIHNrZXdYIDwgMCBhbmQgb3JpZ2luWSBib3R0b20gd2UgYW5jaG9yIG9uIGxlZnRcbiAgICAvLyBpZiBza2V3WCA8IDAgYW5kIG9yaWdpblkgdG9wIHdlIGFuY2hvciBvbiByaWdodFxuICAgIC8vIGlmIHNrZXdYIGlzIDAsIHdlIGxvb2sgZm9yIG1vdXNlIHBvc2l0aW9uIHRvIHVuZGVyc3RhbmQgd2hlcmUgYXJlIHdlIGdvaW5nLlxuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LCBjdXJyZW50U2tldyA9IHRhcmdldC5za2V3WCwgb3JpZ2luWCwgb3JpZ2luWSA9IHRyYW5zZm9ybS5vcmlnaW5ZO1xuICAgIGlmICh0YXJnZXQubG9ja1NrZXdpbmdYKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjdXJyZW50U2tldyA9PT0gMCkge1xuICAgICAgdmFyIGxvY2FsUG9pbnRGcm9tQ2VudGVyID0gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIENFTlRFUiwgQ0VOVEVSLCB4LCB5KTtcbiAgICAgIGlmIChsb2NhbFBvaW50RnJvbUNlbnRlci54ID4gMCkge1xuICAgICAgICAvLyB3ZSBhcmUgcHVsbGluZyByaWdodCwgYW5jaG9yIGxlZnQ7XG4gICAgICAgIG9yaWdpblggPSBMRUZUO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHdlIGFyZSBwdWxsaW5nIHJpZ2h0LCBhbmNob3IgcmlnaHRcbiAgICAgICAgb3JpZ2luWCA9IFJJR0hUO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50U2tldyA+IDApIHtcbiAgICAgICAgb3JpZ2luWCA9IG9yaWdpblkgPT09IFRPUCA/IExFRlQgOiBSSUdIVDtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50U2tldyA8IDApIHtcbiAgICAgICAgb3JpZ2luWCA9IG9yaWdpblkgPT09IFRPUCA/IFJJR0hUIDogTEVGVDtcbiAgICAgIH1cbiAgICAgIC8vIGlzIHRoZSBvYmplY3QgZmxpcHBlZCBvbiBvbmUgc2lkZSBvbmx5PyBzd2FwIHRoZSBvcmlnaW4uXG4gICAgICBpZiAodGFyZ2V0SGFzT25lRmxpcCh0YXJnZXQpKSB7XG4gICAgICAgIG9yaWdpblggPSBvcmlnaW5YID09PSBMRUZUID8gUklHSFQgOiBMRUZUO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG9uY2Ugd2UgaGF2ZSB0aGUgb3JpZ2luLCB3ZSBmaW5kIHRoZSBhbmNob3IgcG9pbnRcbiAgICB0cmFuc2Zvcm0ub3JpZ2luWCA9IG9yaWdpblg7XG4gICAgdmFyIGZpbmFsSGFuZGxlciA9IHdyYXBXaXRoRmlyZUV2ZW50KCdza2V3aW5nJywgd3JhcFdpdGhGaXhlZEFuY2hvcihza2V3T2JqZWN0WCkpO1xuICAgIHJldHVybiBmaW5hbEhhbmRsZXIoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZWQgQWN0aW9uIGhhbmRsZXIgZm9yIHNrZXdpbmcgb24gdGhlIFkgYXhpcywgdGFrZXMgY2FyZSBvZiB0aGVcbiAgICogc2tldyBkaXJlY3Rpb24gYW5kIGRldGVybWluZSB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gb3JpZ2luIGZvciB0aGUgYW5jaG9yIHBvaW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2tld0hhbmRsZXJZKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgLy8gc3RlcDEgZmlndXJlIG91dCBhbmQgY2hhbmdlIHRyYW5zZm9ybSBvcmlnaW4uXG4gICAgLy8gaWYgc2tld1kgPiAwIGFuZCBvcmlnaW5YIGxlZnQgd2UgYW5jaG9yIG9uIHRvcFxuICAgIC8vIGlmIHNrZXdZID4gMCBhbmQgb3JpZ2luWCByaWdodCB3ZSBhbmNob3Igb24gYm90dG9tXG4gICAgLy8gaWYgc2tld1kgPCAwIGFuZCBvcmlnaW5YIGxlZnQgd2UgYW5jaG9yIG9uIGJvdHRvbVxuICAgIC8vIGlmIHNrZXdZIDwgMCBhbmQgb3JpZ2luWCByaWdodCB3ZSBhbmNob3Igb24gdG9wXG4gICAgLy8gaWYgc2tld1kgaXMgMCwgd2UgbG9vayBmb3IgbW91c2UgcG9zaXRpb24gdG8gdW5kZXJzdGFuZCB3aGVyZSBhcmUgd2UgZ29pbmcuXG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsIGN1cnJlbnRTa2V3ID0gdGFyZ2V0LnNrZXdZLCBvcmlnaW5ZLCBvcmlnaW5YID0gdHJhbnNmb3JtLm9yaWdpblg7XG4gICAgaWYgKHRhcmdldC5sb2NrU2tld2luZ1kpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRTa2V3ID09PSAwKSB7XG4gICAgICB2YXIgbG9jYWxQb2ludEZyb21DZW50ZXIgPSBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgQ0VOVEVSLCBDRU5URVIsIHgsIHkpO1xuICAgICAgaWYgKGxvY2FsUG9pbnRGcm9tQ2VudGVyLnkgPiAwKSB7XG4gICAgICAgIC8vIHdlIGFyZSBwdWxsaW5nIGRvd24sIGFuY2hvciB1cDtcbiAgICAgICAgb3JpZ2luWSA9IFRPUDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB3ZSBhcmUgcHVsbGluZyB1cCwgYW5jaG9yIGRvd25cbiAgICAgICAgb3JpZ2luWSA9IEJPVFRPTTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY3VycmVudFNrZXcgPiAwKSB7XG4gICAgICAgIG9yaWdpblkgPSBvcmlnaW5YID09PSBMRUZUID8gVE9QIDogQk9UVE9NO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRTa2V3IDwgMCkge1xuICAgICAgICBvcmlnaW5ZID0gb3JpZ2luWCA9PT0gTEVGVCA/IEJPVFRPTSA6IFRPUDtcbiAgICAgIH1cbiAgICAgIC8vIGlzIHRoZSBvYmplY3QgZmxpcHBlZCBvbiBvbmUgc2lkZSBvbmx5PyBzd2FwIHRoZSBvcmlnaW4uXG4gICAgICBpZiAodGFyZ2V0SGFzT25lRmxpcCh0YXJnZXQpKSB7XG4gICAgICAgIG9yaWdpblkgPSBvcmlnaW5ZID09PSBUT1AgPyBCT1RUT00gOiBUT1A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gb25jZSB3ZSBoYXZlIHRoZSBvcmlnaW4sIHdlIGZpbmQgdGhlIGFuY2hvciBwb2ludFxuICAgIHRyYW5zZm9ybS5vcmlnaW5ZID0gb3JpZ2luWTtcbiAgICB2YXIgZmluYWxIYW5kbGVyID0gd3JhcFdpdGhGaXJlRXZlbnQoJ3NrZXdpbmcnLCB3cmFwV2l0aEZpeGVkQW5jaG9yKHNrZXdPYmplY3RZKSk7XG4gICAgcmV0dXJuIGZpbmFsSGFuZGxlcihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aW9uIGhhbmRsZXIgZm9yIHJvdGF0aW9uIGFuZCBzbmFwcGluZywgd2l0aG91dCBhbmNob3IgcG9pbnQuXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcm90YXRpb25XaXRoU25hcHBpbmcoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICB2YXIgdCA9IHRyYW5zZm9ybSxcbiAgICAgICAgdGFyZ2V0ID0gdC50YXJnZXQsXG4gICAgICAgIHBpdm90UG9pbnQgPSB0YXJnZXQudHJhbnNsYXRlVG9PcmlnaW5Qb2ludCh0YXJnZXQuZ2V0Q2VudGVyUG9pbnQoKSwgdC5vcmlnaW5YLCB0Lm9yaWdpblkpO1xuXG4gICAgaWYgKHRhcmdldC5sb2NrUm90YXRpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdEFuZ2xlID0gTWF0aC5hdGFuMih0LmV5IC0gcGl2b3RQb2ludC55LCB0LmV4IC0gcGl2b3RQb2ludC54KSxcbiAgICAgICAgY3VyQW5nbGUgPSBNYXRoLmF0YW4yKHkgLSBwaXZvdFBvaW50LnksIHggLSBwaXZvdFBvaW50LngpLFxuICAgICAgICBhbmdsZSA9IHJhZGlhbnNUb0RlZ3JlZXMoY3VyQW5nbGUgLSBsYXN0QW5nbGUgKyB0LnRoZXRhKSxcbiAgICAgICAgaGFzUm90YXRlZCA9IHRydWU7XG5cbiAgICBpZiAodGFyZ2V0LnNuYXBBbmdsZSA+IDApIHtcbiAgICAgIHZhciBzbmFwQW5nbGUgID0gdGFyZ2V0LnNuYXBBbmdsZSxcbiAgICAgICAgICBzbmFwVGhyZXNob2xkICA9IHRhcmdldC5zbmFwVGhyZXNob2xkIHx8IHNuYXBBbmdsZSxcbiAgICAgICAgICByaWdodEFuZ2xlTG9ja2VkID0gTWF0aC5jZWlsKGFuZ2xlIC8gc25hcEFuZ2xlKSAqIHNuYXBBbmdsZSxcbiAgICAgICAgICBsZWZ0QW5nbGVMb2NrZWQgPSBNYXRoLmZsb29yKGFuZ2xlIC8gc25hcEFuZ2xlKSAqIHNuYXBBbmdsZTtcblxuICAgICAgaWYgKE1hdGguYWJzKGFuZ2xlIC0gbGVmdEFuZ2xlTG9ja2VkKSA8IHNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgYW5nbGUgPSBsZWZ0QW5nbGVMb2NrZWQ7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChNYXRoLmFicyhhbmdsZSAtIHJpZ2h0QW5nbGVMb2NrZWQpIDwgc25hcFRocmVzaG9sZCkge1xuICAgICAgICBhbmdsZSA9IHJpZ2h0QW5nbGVMb2NrZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXplIGFuZ2xlIHRvIHBvc2l0aXZlIHZhbHVlXG4gICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgYW5nbGUgPSAzNjAgKyBhbmdsZTtcbiAgICB9XG4gICAgYW5nbGUgJT0gMzYwO1xuXG4gICAgaGFzUm90YXRlZCA9IHRhcmdldC5hbmdsZSAhPT0gYW5nbGU7XG4gICAgdGFyZ2V0LmFuZ2xlID0gYW5nbGU7XG4gICAgcmV0dXJuIGhhc1JvdGF0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQmFzaWMgc2NhbGluZyBsb2dpYywgcmV1c2VkIHdpdGggZGlmZmVyZW50IGNvbnN0cmFpbiBmb3Igc2NhbGluZyBYLFksIGZyZWVseSBvciBlcXVhbGx5LlxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gZm9yIHNjYWxpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYnkgJ3gnLCAneScsICdlcXVhbGx5JyBvciAnJyB0byBpbmRpY2F0ZSB0eXBlIG9mIHNjYWxpbmdcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVPYmplY3QoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgbG9ja1NjYWxpbmdYID0gdGFyZ2V0LmxvY2tTY2FsaW5nWCwgbG9ja1NjYWxpbmdZID0gdGFyZ2V0LmxvY2tTY2FsaW5nWSxcbiAgICAgICAgYnkgPSBvcHRpb25zLmJ5LCBuZXdQb2ludCwgc2NhbGVYLCBzY2FsZVksIGRpbSxcbiAgICAgICAgc2NhbGVQcm9wb3J0aW9uYWxseSA9IHNjYWxlSXNQcm9wb3J0aW9uYWwoZXZlbnREYXRhLCB0YXJnZXQpLFxuICAgICAgICBmb3JiaWRTY2FsaW5nID0gc2NhbGluZ0lzRm9yYmlkZGVuKHRhcmdldCwgYnksIHNjYWxlUHJvcG9ydGlvbmFsbHkpLFxuICAgICAgICBzaWduWCwgc2lnblksIGdlc3R1cmVTY2FsZSA9IHRyYW5zZm9ybS5nZXN0dXJlU2NhbGU7XG5cbiAgICBpZiAoZm9yYmlkU2NhbGluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZ2VzdHVyZVNjYWxlKSB7XG4gICAgICBzY2FsZVggPSB0cmFuc2Zvcm0uc2NhbGVYICogZ2VzdHVyZVNjYWxlO1xuICAgICAgc2NhbGVZID0gdHJhbnNmb3JtLnNjYWxlWSAqIGdlc3R1cmVTY2FsZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBuZXdQb2ludCA9IGdldExvY2FsUG9pbnQodHJhbnNmb3JtLCB0cmFuc2Zvcm0ub3JpZ2luWCwgdHJhbnNmb3JtLm9yaWdpblksIHgsIHkpO1xuICAgICAgLy8gdXNlIG9mIHNpZ246IFdlIHVzZSBzaWduIHRvIGRldGVjdCBjaGFuZ2Ugb2YgZGlyZWN0aW9uIG9mIGFuIGFjdGlvbi4gc2lnbiB1c3VhbGx5IGNoYW5nZSB3aGVuXG4gICAgICAvLyB3ZSBjcm9zcyB0aGUgb3JpZ2luIHBvaW50IHdpdGggdGhlIG1vdXNlLiBTbyBhIHNjYWxlIGZsaXAgZm9yIGV4YW1wbGUuIFRoZXJlIGlzIGFuIGlzc3VlIHdoZW4gc2NhbGluZ1xuICAgICAgLy8gYnkgY2VudGVyIGFuZCBzY2FsaW5nIHVzaW5nIG9uZSBtaWRkbGUgY29udHJvbCAoIGRlZmF1bHQ6IG1yLCBtdCwgbWwsIG1iKSwgdGhlIG1vdXNlIG1vdmVtZW50IGNhbiBlYXNpbHlcbiAgICAgIC8vIGNyb3NzIG1hbnkgdGltZSB0aGUgb3JpZ2luIHBvaW50IGFuZCBmbGlwIHRoZSBvYmplY3QuIHNvIHdlIG5lZWQgYSB3YXkgdG8gZmlsdGVyIG91dCB0aGUgbm9pc2UuXG4gICAgICAvLyBUaGlzIHRlcm5hcnkgaGVyZSBzaG91bGQgYmUgb2sgdG8gZmlsdGVyIG91dCBYIHNjYWxpbmcgd2hlbiB3ZSB3YW50IFkgb25seSBhbmQgdmljZSB2ZXJzYS5cbiAgICAgIHNpZ25YID0gYnkgIT09ICd5JyA/IHNpZ24obmV3UG9pbnQueCkgOiAxO1xuICAgICAgc2lnblkgPSBieSAhPT0gJ3gnID8gc2lnbihuZXdQb2ludC55KSA6IDE7XG4gICAgICBpZiAoIXRyYW5zZm9ybS5zaWduWCkge1xuICAgICAgICB0cmFuc2Zvcm0uc2lnblggPSBzaWduWDtcbiAgICAgIH1cbiAgICAgIGlmICghdHJhbnNmb3JtLnNpZ25ZKSB7XG4gICAgICAgIHRyYW5zZm9ybS5zaWduWSA9IHNpZ25ZO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0LmxvY2tTY2FsaW5nRmxpcCAmJlxuICAgICAgICAodHJhbnNmb3JtLnNpZ25YICE9PSBzaWduWCB8fCB0cmFuc2Zvcm0uc2lnblkgIT09IHNpZ25ZKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZGltID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcbiAgICAgIC8vIG1pc3NpbmcgZGV0ZWN0aW9uIG9mIGZsaXAgYW5kIGxvZ2ljIHRvIHN3aXRjaCB0aGUgb3JpZ2luXG4gICAgICBpZiAoc2NhbGVQcm9wb3J0aW9uYWxseSAmJiAhYnkpIHtcbiAgICAgICAgLy8gdW5pZm9ybSBzY2FsaW5nXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKG5ld1BvaW50LngpICsgTWF0aC5hYnMobmV3UG9pbnQueSksXG4gICAgICAgICAgICBvcmlnaW5hbCA9IHRyYW5zZm9ybS5vcmlnaW5hbCxcbiAgICAgICAgICAgIG9yaWdpbmFsRGlzdGFuY2UgPSBNYXRoLmFicyhkaW0ueCAqIG9yaWdpbmFsLnNjYWxlWCAvIHRhcmdldC5zY2FsZVgpICtcbiAgICAgICAgICAgICAgTWF0aC5hYnMoZGltLnkgKiBvcmlnaW5hbC5zY2FsZVkgLyB0YXJnZXQuc2NhbGVZKSxcbiAgICAgICAgICAgIHNjYWxlID0gZGlzdGFuY2UgLyBvcmlnaW5hbERpc3RhbmNlO1xuICAgICAgICBzY2FsZVggPSBvcmlnaW5hbC5zY2FsZVggKiBzY2FsZTtcbiAgICAgICAgc2NhbGVZID0gb3JpZ2luYWwuc2NhbGVZICogc2NhbGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2NhbGVYID0gTWF0aC5hYnMobmV3UG9pbnQueCAqIHRhcmdldC5zY2FsZVggLyBkaW0ueCk7XG4gICAgICAgIHNjYWxlWSA9IE1hdGguYWJzKG5ld1BvaW50LnkgKiB0YXJnZXQuc2NhbGVZIC8gZGltLnkpO1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgYXJlIHNjYWxpbmcgYnkgY2VudGVyLCB3ZSBuZWVkIHRvIGRvdWJsZSB0aGUgc2NhbGVcbiAgICAgIGlmIChpc1RyYW5zZm9ybUNlbnRlcmVkKHRyYW5zZm9ybSkpIHtcbiAgICAgICAgc2NhbGVYICo9IDI7XG4gICAgICAgIHNjYWxlWSAqPSAyO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybS5zaWduWCAhPT0gc2lnblggJiYgYnkgIT09ICd5Jykge1xuICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWCA9IG9wcG9zaXRlW3RyYW5zZm9ybS5vcmlnaW5YXTtcbiAgICAgICAgc2NhbGVYICo9IC0xO1xuICAgICAgICB0cmFuc2Zvcm0uc2lnblggPSBzaWduWDtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm0uc2lnblkgIT09IHNpZ25ZICYmIGJ5ICE9PSAneCcpIHtcbiAgICAgICAgdHJhbnNmb3JtLm9yaWdpblkgPSBvcHBvc2l0ZVt0cmFuc2Zvcm0ub3JpZ2luWV07XG4gICAgICAgIHNjYWxlWSAqPSAtMTtcbiAgICAgICAgdHJhbnNmb3JtLnNpZ25ZID0gc2lnblk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG1pblNjYWxlIGlzIHRha2VuIGFyZSBpbiB0aGUgc2V0dGVyLlxuICAgIHZhciBvbGRTY2FsZVggPSB0YXJnZXQuc2NhbGVYLCBvbGRTY2FsZVkgPSB0YXJnZXQuc2NhbGVZO1xuICAgIGlmICghYnkpIHtcbiAgICAgICFsb2NrU2NhbGluZ1ggJiYgdGFyZ2V0LnNldCgnc2NhbGVYJywgc2NhbGVYKTtcbiAgICAgICFsb2NrU2NhbGluZ1kgJiYgdGFyZ2V0LnNldCgnc2NhbGVZJywgc2NhbGVZKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBmb3JiaWRkZW4gY2FzZXMgYWxyZWFkeSBoYW5kbGVkIG9uIHRvcCBoZXJlLlxuICAgICAgYnkgPT09ICd4JyAmJiB0YXJnZXQuc2V0KCdzY2FsZVgnLCBzY2FsZVgpO1xuICAgICAgYnkgPT09ICd5JyAmJiB0YXJnZXQuc2V0KCdzY2FsZVknLCBzY2FsZVkpO1xuICAgIH1cbiAgICByZXR1cm4gb2xkU2NhbGVYICE9PSB0YXJnZXQuc2NhbGVYIHx8IG9sZFNjYWxlWSAhPT0gdGFyZ2V0LnNjYWxlWTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmljIHNjYWxpbmcgbG9naWMsIHRvIHNjYWxlIGZyb20gY29ybmVycyBlaXRoZXIgZXF1YWxseSBvciBmcmVlbHkuXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVPYmplY3RGcm9tQ29ybmVyKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgcmV0dXJuIHNjYWxlT2JqZWN0KGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsaW5nIGxvZ2ljIGZvciB0aGUgWCBheGlzLlxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlT2JqZWN0WChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHJldHVybiBzY2FsZU9iamVjdChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSAsIHsgYnk6ICd4JyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsaW5nIGxvZ2ljIGZvciB0aGUgWSBheGlzLlxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlT2JqZWN0WShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHJldHVybiBzY2FsZU9iamVjdChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSAsIHsgYnk6ICd5JyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wb3NlZCBhY3Rpb24gaGFuZGxlciB0byBlaXRoZXIgc2NhbGUgWSBvciBza2V3IFhcbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsaW5nWU9yU2tld2luZ1goZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICAvLyBvayBzb21lIHNhZmV0eSBuZWVkZWQgaGVyZS5cbiAgICBpZiAoZXZlbnREYXRhW3RyYW5zZm9ybS50YXJnZXQuY2FudmFzLmFsdEFjdGlvbktleV0pIHtcbiAgICAgIHJldHVybiBjb250cm9scy5za2V3SGFuZGxlclgoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJvbHMuc2NhbGluZ1koZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBvc2VkIGFjdGlvbiBoYW5kbGVyIHRvIGVpdGhlciBzY2FsZSBYIG9yIHNrZXcgWVxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxpbmdYT3JTa2V3aW5nWShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIC8vIG9rIHNvbWUgc2FmZXR5IG5lZWRlZCBoZXJlLlxuICAgIGlmIChldmVudERhdGFbdHJhbnNmb3JtLnRhcmdldC5jYW52YXMuYWx0QWN0aW9uS2V5XSkge1xuICAgICAgcmV0dXJuIGNvbnRyb2xzLnNrZXdIYW5kbGVyWShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9scy5zY2FsaW5nWChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aW9uIGhhbmRsZXIgdG8gY2hhbmdlIHRleHRib3ggd2lkdGhcbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBjaGFuZ2VXaWR0aChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LCBsb2NhbFBvaW50ID0gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIHRyYW5zZm9ybS5vcmlnaW5YLCB0cmFuc2Zvcm0ub3JpZ2luWSwgeCwgeSksXG4gICAgICAgIHN0cm9rZVBhZGRpbmcgPSB0YXJnZXQuc3Ryb2tlV2lkdGggLyAodGFyZ2V0LnN0cm9rZVVuaWZvcm0gPyB0YXJnZXQuc2NhbGVYIDogMSksXG4gICAgICAgIG11bHRpcGxpZXIgPSBpc1RyYW5zZm9ybUNlbnRlcmVkKHRyYW5zZm9ybSkgPyAyIDogMSxcbiAgICAgICAgb2xkV2lkdGggPSB0YXJnZXQud2lkdGgsXG4gICAgICAgIG5ld1dpZHRoID0gTWF0aC5hYnMobG9jYWxQb2ludC54ICogbXVsdGlwbGllciAvIHRhcmdldC5zY2FsZVgpIC0gc3Ryb2tlUGFkZGluZztcbiAgICB0YXJnZXQuc2V0KCd3aWR0aCcsIE1hdGgubWF4KG5ld1dpZHRoLCAwKSk7XG4gICAgcmV0dXJuIG9sZFdpZHRoICE9PSBuZXdXaWR0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3Rpb24gaGFuZGxlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHRyYW5zbGF0aW9uIG9jY3VycmVkXG4gICAqL1xuICBmdW5jdGlvbiBkcmFnSGFuZGxlcihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICBuZXdMZWZ0ID0geCAtIHRyYW5zZm9ybS5vZmZzZXRYLFxuICAgICAgICBuZXdUb3AgPSB5IC0gdHJhbnNmb3JtLm9mZnNldFksXG4gICAgICAgIG1vdmVYID0gIXRhcmdldC5nZXQoJ2xvY2tNb3ZlbWVudFgnKSAmJiB0YXJnZXQubGVmdCAhPT0gbmV3TGVmdCxcbiAgICAgICAgbW92ZVkgPSAhdGFyZ2V0LmdldCgnbG9ja01vdmVtZW50WScpICYmIHRhcmdldC50b3AgIT09IG5ld1RvcDtcbiAgICBtb3ZlWCAmJiB0YXJnZXQuc2V0KCdsZWZ0JywgbmV3TGVmdCk7XG4gICAgbW92ZVkgJiYgdGFyZ2V0LnNldCgndG9wJywgbmV3VG9wKTtcbiAgICBpZiAobW92ZVggfHwgbW92ZVkpIHtcbiAgICAgIGZpcmVFdmVudCgnbW92aW5nJywgY29tbW9uRXZlbnRJbmZvKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSk7XG4gICAgfVxuICAgIHJldHVybiBtb3ZlWCB8fCBtb3ZlWTtcbiAgfVxuXG4gIGNvbnRyb2xzLnNjYWxlQ3Vyc29yU3R5bGVIYW5kbGVyID0gc2NhbGVDdXJzb3JTdHlsZUhhbmRsZXI7XG4gIGNvbnRyb2xzLnNrZXdDdXJzb3JTdHlsZUhhbmRsZXIgPSBza2V3Q3Vyc29yU3R5bGVIYW5kbGVyO1xuICBjb250cm9scy5zY2FsZVNrZXdDdXJzb3JTdHlsZUhhbmRsZXIgPSBzY2FsZVNrZXdDdXJzb3JTdHlsZUhhbmRsZXI7XG4gIGNvbnRyb2xzLnJvdGF0aW9uV2l0aFNuYXBwaW5nID0gd3JhcFdpdGhGaXJlRXZlbnQoJ3JvdGF0aW5nJywgd3JhcFdpdGhGaXhlZEFuY2hvcihyb3RhdGlvbldpdGhTbmFwcGluZykpO1xuICBjb250cm9scy5zY2FsaW5nRXF1YWxseSA9IHdyYXBXaXRoRmlyZUV2ZW50KCdzY2FsaW5nJywgd3JhcFdpdGhGaXhlZEFuY2hvciggc2NhbGVPYmplY3RGcm9tQ29ybmVyKSk7XG4gIGNvbnRyb2xzLnNjYWxpbmdYID0gd3JhcFdpdGhGaXJlRXZlbnQoJ3NjYWxpbmcnLCB3cmFwV2l0aEZpeGVkQW5jaG9yKHNjYWxlT2JqZWN0WCkpO1xuICBjb250cm9scy5zY2FsaW5nWSA9IHdyYXBXaXRoRmlyZUV2ZW50KCdzY2FsaW5nJywgd3JhcFdpdGhGaXhlZEFuY2hvcihzY2FsZU9iamVjdFkpKTtcbiAgY29udHJvbHMuc2NhbGluZ1lPclNrZXdpbmdYID0gc2NhbGluZ1lPclNrZXdpbmdYO1xuICBjb250cm9scy5zY2FsaW5nWE9yU2tld2luZ1kgPSBzY2FsaW5nWE9yU2tld2luZ1k7XG4gIGNvbnRyb2xzLmNoYW5nZVdpZHRoID0gd3JhcFdpdGhGaXJlRXZlbnQoJ3Jlc2l6aW5nJywgd3JhcFdpdGhGaXhlZEFuY2hvcihjaGFuZ2VXaWR0aCkpO1xuICBjb250cm9scy5za2V3SGFuZGxlclggPSBza2V3SGFuZGxlclg7XG4gIGNvbnRyb2xzLnNrZXdIYW5kbGVyWSA9IHNrZXdIYW5kbGVyWTtcbiAgY29udHJvbHMuZHJhZ0hhbmRsZXIgPSBkcmFnSGFuZGxlcjtcbiAgY29udHJvbHMuc2NhbGVPclNrZXdBY3Rpb25OYW1lID0gc2NhbGVPclNrZXdBY3Rpb25OYW1lO1xuICBjb250cm9scy5yb3RhdGlvblN0eWxlSGFuZGxlciA9IHJvdGF0aW9uU3R5bGVIYW5kbGVyO1xuICBjb250cm9scy5maXJlRXZlbnQgPSBmaXJlRXZlbnQ7XG4gIGNvbnRyb2xzLndyYXBXaXRoRml4ZWRBbmNob3IgPSB3cmFwV2l0aEZpeGVkQW5jaG9yO1xuICBjb250cm9scy53cmFwV2l0aEZpcmVFdmVudCA9IHdyYXBXaXRoRmlyZUV2ZW50O1xuICBjb250cm9scy5nZXRMb2NhbFBvaW50ID0gZ2V0TG9jYWxQb2ludDtcbiAgZmFicmljLmNvbnRyb2xzVXRpbHMgPSBjb250cm9scztcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBjb250cm9scyA9IGZhYnJpYy5jb250cm9sc1V0aWxzO1xuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSByb3VuZCBjb250cm9sLCBhcyBwZXIgZmFicmljIGZlYXR1cmVzLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHdyaXR0ZW4gdG8gcmVzcGVjdCBvYmplY3QgcHJvcGVydGllcyBsaWtlIHRyYW5zcGFyZW50Q29ybmVycywgY29ybmVyU2l6ZVxuICAgKiBjb3JuZXJDb2xvciwgY29ybmVyU3Ryb2tlQ29sb3JcbiAgICogcGx1cyB0aGUgYWRkaXRpb24gb2Ygb2Zmc2V0WSBhbmQgb2Zmc2V0WC5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBvblxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCB4IGNvb3JkaW5hdGUgd2hlcmUgdGhlIGNvbnRyb2wgY2VudGVyIHNob3VsZCBiZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIHkgY29vcmRpbmF0ZSB3aGVyZSB0aGUgY29udHJvbCBjZW50ZXIgc2hvdWxkIGJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlIG92ZXJyaWRlIGZvciBmYWJyaWMuT2JqZWN0IGNvbnRyb2xzIHN0eWxlXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IGZvciB3aGljaCB3ZSBhcmUgcmVuZGVyaW5nIGNvbnRyb2xzXG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXJDaXJjbGVDb250cm9sIChjdHgsIGxlZnQsIHRvcCwgc3R5bGVPdmVycmlkZSwgZmFicmljT2JqZWN0KSB7XG4gICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgdmFyIHhTaXplID0gdGhpcy5zaXplWCB8fCBzdHlsZU92ZXJyaWRlLmNvcm5lclNpemUgfHwgZmFicmljT2JqZWN0LmNvcm5lclNpemUsXG4gICAgICAgIHlTaXplID0gdGhpcy5zaXplWSB8fCBzdHlsZU92ZXJyaWRlLmNvcm5lclNpemUgfHwgZmFicmljT2JqZWN0LmNvcm5lclNpemUsXG4gICAgICAgIHRyYW5zcGFyZW50Q29ybmVycyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLnRyYW5zcGFyZW50Q29ybmVycyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgIHN0eWxlT3ZlcnJpZGUudHJhbnNwYXJlbnRDb3JuZXJzIDogZmFicmljT2JqZWN0LnRyYW5zcGFyZW50Q29ybmVycyxcbiAgICAgICAgbWV0aG9kTmFtZSA9IHRyYW5zcGFyZW50Q29ybmVycyA/ICdzdHJva2UnIDogJ2ZpbGwnLFxuICAgICAgICBzdHJva2UgPSAhdHJhbnNwYXJlbnRDb3JuZXJzICYmIChzdHlsZU92ZXJyaWRlLmNvcm5lclN0cm9rZUNvbG9yIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTdHJva2VDb2xvciksXG4gICAgICAgIG15TGVmdCA9IGxlZnQsXG4gICAgICAgIG15VG9wID0gdG9wLCBzaXplO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyQ29sb3IgfHwgZmFicmljT2JqZWN0LmNvcm5lckNvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyU3Ryb2tlQ29sb3IgfHwgZmFicmljT2JqZWN0LmNvcm5lclN0cm9rZUNvbG9yO1xuICAgIC8vIGFzIHNvb24gYXMgZmFicmljIHJlYWN0IHY1LCByZW1vdmUgaWUxMSwgdXNlIHByb3BlciBlbGxpcHNlIGNvZGUuXG4gICAgaWYgKHhTaXplID4geVNpemUpIHtcbiAgICAgIHNpemUgPSB4U2l6ZTtcbiAgICAgIGN0eC5zY2FsZSgxLjAsIHlTaXplIC8geFNpemUpO1xuICAgICAgbXlUb3AgPSB0b3AgKiB4U2l6ZSAvIHlTaXplO1xuICAgIH1cbiAgICBlbHNlIGlmICh5U2l6ZSA+IHhTaXplKSB7XG4gICAgICBzaXplID0geVNpemU7XG4gICAgICBjdHguc2NhbGUoeFNpemUgLyB5U2l6ZSwgMS4wKTtcbiAgICAgIG15TGVmdCA9IGxlZnQgKiB5U2l6ZSAvIHhTaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNpemUgPSB4U2l6ZTtcbiAgICB9XG4gICAgLy8gdGhpcyBpcyBzdGlsbCB3cm9uZ1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKG15TGVmdCwgbXlUb3AsIHNpemUgLyAyLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgIGN0eFttZXRob2ROYW1lXSgpO1xuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBzcXVhcmUgY29udHJvbCwgYXMgcGVyIGZhYnJpYyBmZWF0dXJlcy5cbiAgICogVGhpcyBmdW5jdGlvbiBpcyB3cml0dGVuIHRvIHJlc3BlY3Qgb2JqZWN0IHByb3BlcnRpZXMgbGlrZSB0cmFuc3BhcmVudENvcm5lcnMsIGNvcm5lclNpemVcbiAgICogY29ybmVyQ29sb3IsIGNvcm5lclN0cm9rZUNvbG9yXG4gICAqIHBsdXMgdGhlIGFkZGl0aW9uIG9mIG9mZnNldFkgYW5kIG9mZnNldFguXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgeCBjb29yZGluYXRlIHdoZXJlIHRoZSBjb250cm9sIGNlbnRlciBzaG91bGQgYmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCB5IGNvb3JkaW5hdGUgd2hlcmUgdGhlIGNvbnRyb2wgY2VudGVyIHNob3VsZCBiZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPdmVycmlkZSBvdmVycmlkZSBmb3IgZmFicmljLk9iamVjdCBjb250cm9scyBzdHlsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCBmb3Igd2hpY2ggd2UgYXJlIHJlbmRlcmluZyBjb250cm9sc1xuICAgKi9cbiAgZnVuY3Rpb24gcmVuZGVyU3F1YXJlQ29udHJvbChjdHgsIGxlZnQsIHRvcCwgc3R5bGVPdmVycmlkZSwgZmFicmljT2JqZWN0KSB7XG4gICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgdmFyIHhTaXplID0gdGhpcy5zaXplWCB8fCBzdHlsZU92ZXJyaWRlLmNvcm5lclNpemUgfHwgZmFicmljT2JqZWN0LmNvcm5lclNpemUsXG4gICAgICAgIHlTaXplID0gdGhpcy5zaXplWSB8fCBzdHlsZU92ZXJyaWRlLmNvcm5lclNpemUgfHwgZmFicmljT2JqZWN0LmNvcm5lclNpemUsXG4gICAgICAgIHRyYW5zcGFyZW50Q29ybmVycyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLnRyYW5zcGFyZW50Q29ybmVycyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgIHN0eWxlT3ZlcnJpZGUudHJhbnNwYXJlbnRDb3JuZXJzIDogZmFicmljT2JqZWN0LnRyYW5zcGFyZW50Q29ybmVycyxcbiAgICAgICAgbWV0aG9kTmFtZSA9IHRyYW5zcGFyZW50Q29ybmVycyA/ICdzdHJva2UnIDogJ2ZpbGwnLFxuICAgICAgICBzdHJva2UgPSAhdHJhbnNwYXJlbnRDb3JuZXJzICYmIChcbiAgICAgICAgICBzdHlsZU92ZXJyaWRlLmNvcm5lclN0cm9rZUNvbG9yIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTdHJva2VDb2xvclxuICAgICAgICApLCB4U2l6ZUJ5MiA9IHhTaXplIC8gMiwgeVNpemVCeTIgPSB5U2l6ZSAvIDI7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJDb2xvciB8fCBmYWJyaWNPYmplY3QuY29ybmVyQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJTdHJva2VDb2xvciB8fCBmYWJyaWNPYmplY3QuY29ybmVyU3Ryb2tlQ29sb3I7XG4gICAgLy8gdGhpcyBpcyBzdGlsbCB3cm9uZ1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGN0eC50cmFuc2xhdGUobGVmdCwgdG9wKTtcbiAgICBjdHgucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnMoZmFicmljT2JqZWN0LmFuZ2xlKSk7XG4gICAgLy8gdGhpcyBkb2VzIG5vdCB3b3JrLCBhbmQgZml4ZWQgd2l0aCAoICYmICkgZG9lcyBub3QgbWFrZSBzZW5zZS5cbiAgICAvLyB0byBoYXZlIHJlYWwgdHJhbnNwYXJlbnQgY29ybmVycyB3ZSBuZWVkIHRoZSBjb250cm9scyBvbiB1cHBlckNhbnZhc1xuICAgIC8vIHRyYW5zcGFyZW50Q29ybmVycyB8fCBjdHguY2xlYXJSZWN0KC14U2l6ZUJ5MiwgLXlTaXplQnkyLCB4U2l6ZSwgeVNpemUpO1xuICAgIGN0eFttZXRob2ROYW1lICsgJ1JlY3QnXSgteFNpemVCeTIsIC15U2l6ZUJ5MiwgeFNpemUsIHlTaXplKTtcbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBjdHguc3Ryb2tlUmVjdCgteFNpemVCeTIsIC15U2l6ZUJ5MiwgeFNpemUsIHlTaXplKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIGNvbnRyb2xzLnJlbmRlckNpcmNsZUNvbnRyb2wgPSByZW5kZXJDaXJjbGVDb250cm9sO1xuICBjb250cm9scy5yZW5kZXJTcXVhcmVDb250cm9sID0gcmVuZGVyU3F1YXJlQ29udHJvbDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGZ1bmN0aW9uIENvbnRyb2wob3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgICAgdGhpc1tpXSA9IG9wdGlvbnNbaV07XG4gICAgfVxuICB9XG5cbiAgZmFicmljLkNvbnRyb2wgPSBDb250cm9sO1xuXG4gIGZhYnJpYy5Db250cm9sLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkNvbnRyb2wucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIGtlZXAgdHJhY2sgb2YgY29udHJvbCB2aXNpYmlsaXR5LlxuICAgICAqIG1haW5seSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgKiBpZiB5b3UgZG8gbm90IHdhbnQgdG8gc2VlIGEgY29udHJvbCwgeW91IGNhbiByZW1vdmUgaXRcbiAgICAgKiBmcm9tIHRoZSBjb250cm9sc2V0LlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB2aXNpYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgYWN0aW9uIHRoYXQgdGhlIGNvbnRyb2wgd2lsbCBsaWtlbHkgZXhlY3V0ZS5cbiAgICAgKiBUaGlzIGlzIG9wdGlvbmFsLiBGYWJyaWNKUyB1c2VzIHRvIGlkZW50aWZ5IHdoYXQgdGhlIHVzZXIgaXMgZG9pbmcgZm9yIHNvbWVcbiAgICAgKiBleHRyYSBvcHRpbWl6YXRpb25zLiBJZiB5b3UgYXJlIHdyaXRpbmcgYSBjdXN0b20gY29udHJvbCBhbmQgeW91IHdhbnQgdG8ga25vd1xuICAgICAqIHNvbWV3aGVyZSBlbHNlIGluIHRoZSBjb2RlIHdoYXQgaXMgZ29pbmcgb24sIHlvdSBjYW4gdXNlIHRoaXMgc3RyaW5nIGhlcmUuXG4gICAgICogeW91IGNhbiBhbHNvIHByb3ZpZGUgYSBjdXN0b20gZ2V0QWN0aW9uTmFtZSBpZiB5b3VyIGNvbnRyb2wgcnVuIG11bHRpcGxlIGFjdGlvbnNcbiAgICAgKiBkZXBlbmRpbmcgb24gc29tZSBleHRlcm5hbCBzdGF0ZS5cbiAgICAgKiBkZWZhdWx0IHRvIHNjYWxlIHNpbmNlIGlzIHRoZSBtb3N0IGNvbW1vbiwgdXNlZCBvbiA0IGNvcm5lcnMgYnkgZGVmYXVsdFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ3NjYWxlJ1xuICAgICAqL1xuICAgIGFjdGlvbk5hbWU6ICdzY2FsZScsXG5cbiAgICAvKipcbiAgICAgKiBEcmF3aW5nIGFuZ2xlIG9mIHRoZSBjb250cm9sLlxuICAgICAqIE5PVCB1c2VkIGZvciBub3csIGJ1dCBuYW1lIG1hcmtlZCBhcyBuZWVkZWQgZm9yIGludGVybmFsIGxvZ2ljXG4gICAgICogZXhhbXBsZTogdG8gcmV1c2UgdGhlIHNhbWUgZHJhd2luZyBmdW5jdGlvbiBmb3IgZGlmZmVyZW50IHJvdGF0ZWQgY29udHJvbHNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBhbmdsZTogMCxcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLiBYXG4gICAgICogMCwwIGlzIHRoZSBjZW50ZXIgb2YgdGhlIE9iamVjdCwgd2hpbGUgLTAuNSAobGVmdCkgb3IgMC41IChyaWdodCkgYXJlIHRoZSBleHRyZW1pdGllc1xuICAgICAqIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgeDogMCxcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBjb250cm9sLiBZXG4gICAgICogMCwwIGlzIHRoZSBjZW50ZXIgb2YgdGhlIE9iamVjdCwgd2hpbGUgLTAuNSAodG9wKSBvciAwLjUgKGJvdHRvbSkgYXJlIHRoZSBleHRyZW1pdGllc1xuICAgICAqIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgeTogMCxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb2Zmc2V0IG9mIHRoZSBjb250cm9sIGZyb20gdGhlIGRlZmluZWQgcG9zaXRpb24uIEluIHBpeGVsc1xuICAgICAqIFBvc2l0aXZlIG9mZnNldCBtb3ZlcyB0aGUgY29udHJvbCB0byB0aGUgcmlnaHQsIG5lZ2F0aXZlIHRvIHRoZSBsZWZ0LlxuICAgICAqIEl0IHVzZWQgd2hlbiB5b3Ugd2FudCB0byBoYXZlIHBvc2l0aW9uIG9mIGNvbnRyb2wgdGhhdCBkb2VzIG5vdCBzY2FsZSB3aXRoXG4gICAgICogdGhlIGJvdW5kaW5nIGJveC4gRXhhbXBsZTogcm90YXRpb24gY29udHJvbCBpcyBwbGFjZWQgYXQgeDowLCB5OiAwLjUgb25cbiAgICAgKiB0aGUgYm91bmRpbmRib3gsIHdpdGggYW4gb2Zmc2V0IG9mIDMwIHBpeGVscyB2ZXJ0aWNhbGx5LiBUaG9zZSAzMCBwaXhlbHMgd2lsbFxuICAgICAqIHN0YXkgMzAgcGl4ZWxzIG5vIG1hdHRlciBob3cgdGhlIG9iamVjdCBpcyBiaWcuIEFub3RoZXIgZXhhbXBsZSBpcyBoYXZpbmcgMlxuICAgICAqIGNvbnRyb2xzIGluIHRoZSBjb3JuZXIsIHRoYXQgc3RheSBpbiB0aGUgc2FtZSBwb3NpdGlvbiB3aGVuIHRoZSBvYmplY3Qgc2NhbGUuXG4gICAgICogb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBvZmZzZXRYOiAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgb2Zmc2V0IG9mIHRoZSBjb250cm9sIGZyb20gdGhlIGRlZmluZWQgcG9zaXRpb24uIEluIHBpeGVsc1xuICAgICAqIFBvc2l0aXZlIG9mZnNldCBtb3ZlcyB0aGUgY29udHJvbCB0byB0aGUgYm90dG9tLCBuZWdhdGl2ZSB0byB0aGUgdG9wLlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG9mZnNldFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsZW5ndGggb2YgdGhlIGNvbnRyb2wuIElmIG51bGwsIGRlZmF1bHRzIHRvIG9iamVjdCdzIGNvcm5lclNpemUuXG4gICAgICogRXhwZWN0cyBib3RoIHNpemVYIGFuZCBzaXplWSB0byBiZSBzZXQgd2hlbiBzZXQuXG4gICAgICogQHR5cGUgez9OdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHNpemVYOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBjb250cm9sLiBJZiBudWxsLCBkZWZhdWx0cyB0byBvYmplY3QncyBjb3JuZXJTaXplLlxuICAgICAqIEV4cGVjdHMgYm90aCBzaXplWCBhbmQgc2l6ZVkgdG8gYmUgc2V0IHdoZW4gc2V0LlxuICAgICAqIEB0eXBlIHs/TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBzaXplWTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxlbmd0aCBvZiB0aGUgdG91Y2ggYXJlYSBvZiB0aGUgY29udHJvbC4gSWYgbnVsbCwgZGVmYXVsdHMgdG8gb2JqZWN0J3MgdG91Y2hDb3JuZXJTaXplLlxuICAgICAqIEV4cGVjdHMgYm90aCB0b3VjaFNpemVYIGFuZCB0b3VjaFNpemVZIHRvIGJlIHNldCB3aGVuIHNldC5cbiAgICAgKiBAdHlwZSB7P051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgdG91Y2hTaXplWDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgdG91Y2ggYXJlYSBvZiB0aGUgY29udHJvbC4gSWYgbnVsbCwgZGVmYXVsdHMgdG8gb2JqZWN0J3MgdG91Y2hDb3JuZXJTaXplLlxuICAgICAqIEV4cGVjdHMgYm90aCB0b3VjaFNpemVYIGFuZCB0b3VjaFNpemVZIHRvIGJlIHNldCB3aGVuIHNldC5cbiAgICAgKiBAdHlwZSB7P051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgdG91Y2hTaXplWTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENzcyBjdXJzb3Igc3R5bGUgdG8gZGlzcGxheSB3aGVuIHRoZSBjb250cm9sIGlzIGhvdmVyZWQuXG4gICAgICogaWYgdGhlIG1ldGhvZCBgY3Vyc29yU3R5bGVIYW5kbGVyYCBpcyBwcm92aWRlZCwgdGhpcyBwcm9wZXJ0eSBpcyBpZ25vcmVkLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ2Nyb3NzaGFpcidcbiAgICAgKi9cbiAgICBjdXJzb3JTdHlsZTogJ2Nyb3NzaGFpcicsXG5cbiAgICAvKipcbiAgICAgKiBJZiBjb250cm9scyBoYXMgYW4gb2Zmc2V0WSBvciBvZmZzZXRYLCBkcmF3IGEgbGluZSB0aGF0IGNvbm5lY3RzXG4gICAgICogdGhlIGNvbnRyb2wgdG8gdGhlIGJvdW5kaW5nIGJveFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgd2l0aENvbm5lY3Rpb246IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRyb2wgYWN0aW9uSGFuZGxlciwgcHJvdmlkZSBvbmUgdG8gaGFuZGxlIGFjdGlvbiAoIGNvbnRyb2wgYmVpbmcgbW92ZWQgKVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybURhdGEgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCB4IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB5IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBhY3Rpb24vZXZlbnQgbW9kaWZpZWQgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGFjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgdHJhbnNmb3JtRGF0YSwgeCwgeSAqLykgeyB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRyb2wgaGFuZGxlciBmb3IgbW91c2UgZG93biwgcHJvdmlkZSBvbmUgdG8gaGFuZGxlIG1vdXNlIGRvd24gb24gY29udHJvbFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybURhdGEgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCB4IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB5IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBhY3Rpb24vZXZlbnQgbW9kaWZpZWQgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIG1vdXNlRG93bkhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgdHJhbnNmb3JtRGF0YSwgeCwgeSAqLykgeyB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRyb2wgbW91c2VVcEhhbmRsZXIsIHByb3ZpZGUgb25lIHRvIGhhbmRsZSBhbiBlZmZlY3Qgb24gbW91c2UgdXAuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtRGF0YSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHggcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGFjdGlvbi9ldmVudCBtb2RpZmllZCB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgbW91c2VVcEhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgdHJhbnNmb3JtRGF0YSwgeCwgeSAqLykgeyB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250cm9sIGFjdGlvbkhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IG9uIHdoaWNoIHRoZSBjb250cm9sIGlzIGRpc3BsYXllZFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgY29udHJvbCBmb3Igd2hpY2ggdGhlIGFjdGlvbiBoYW5kbGVyIGlzIGJlaW5nIGFza2VkXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBhY3Rpb24gaGFuZGxlclxuICAgICAqL1xuICAgIGdldEFjdGlvbkhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgZmFicmljT2JqZWN0LCBjb250cm9sICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3Rpb25IYW5kbGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyb2wgbW91c2VEb3duIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IG9uIHdoaWNoIHRoZSBjb250cm9sIGlzIGRpc3BsYXllZFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgY29udHJvbCBmb3Igd2hpY2ggdGhlIGFjdGlvbiBoYW5kbGVyIGlzIGJlaW5nIGFza2VkXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBhY3Rpb24gaGFuZGxlclxuICAgICAqL1xuICAgIGdldE1vdXNlRG93bkhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgZmFicmljT2JqZWN0LCBjb250cm9sICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb3VzZURvd25IYW5kbGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyb2wgbW91c2VVcCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCBvbiB3aGljaCB0aGUgY29udHJvbCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIGNvbnRyb2wgZm9yIHdoaWNoIHRoZSBhY3Rpb24gaGFuZGxlciBpcyBiZWluZyBhc2tlZFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgYWN0aW9uIGhhbmRsZXJcbiAgICAgKi9cbiAgICBnZXRNb3VzZVVwSGFuZGxlcjogZnVuY3Rpb24oLyogZXZlbnREYXRhLCBmYWJyaWNPYmplY3QsIGNvbnRyb2wgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLm1vdXNlVXBIYW5kbGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyb2wgY3Vyc29yU3R5bGUgZm9yIGNzcyB1c2luZyBjdXJzb3JTdHlsZS4gSWYgeW91IG5lZWQgYSBtb3JlIGVsYWJvcmF0ZVxuICAgICAqIGZ1bmN0aW9uIHlvdSBjYW4gcGFzcyBvbmUgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICogdGhlIGN1cnNvclN0eWxlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjdXJyZW50IGNvbnRyb2wgKCBsaWtlbHkgdGhpcylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBvbiB3aGljaCB0aGUgY29udHJvbCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBmdW5jdGlvbihldmVudERhdGEsIGNvbnRyb2wgLyogZmFicmljT2JqZWN0ICovKSB7XG4gICAgICByZXR1cm4gY29udHJvbC5jdXJzb3JTdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWN0aW9uIG5hbWUuIFRoZSBiYXNpYyBpbXBsZW1lbnRhdGlvbiBqdXN0IHJldHVybiB0aGUgYWN0aW9uTmFtZSBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGN1cnJlbnQgY29udHJvbCAoIGxpa2VseSB0aGlzKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IG9uIHdoaWNoIHRoZSBjb250cm9sIGlzIGRpc3BsYXllZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRBY3Rpb25OYW1lOiBmdW5jdGlvbihldmVudERhdGEsIGNvbnRyb2wgLyogZmFicmljT2JqZWN0ICovKSB7XG4gICAgICByZXR1cm4gY29udHJvbC5hY3Rpb25OYW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyb2xzIHZpc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBvbiB3aGljaCB0aGUgY29udHJvbCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udHJvbEtleSBrZXkgd2hlcmUgdGhlIGNvbnRyb2wgaXMgbWVtb3JpemVkIG9uIHRoZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0VmlzaWJpbGl0eTogZnVuY3Rpb24oZmFicmljT2JqZWN0LCBjb250cm9sS2V5KSB7XG4gICAgICB2YXIgb2JqZWN0VmlzaWJpbGl0eSA9IGZhYnJpY09iamVjdC5fY29udHJvbHNWaXNpYmlsaXR5O1xuICAgICAgaWYgKG9iamVjdFZpc2liaWxpdHkgJiYgdHlwZW9mIG9iamVjdFZpc2liaWxpdHlbY29udHJvbEtleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RWaXNpYmlsaXR5W2NvbnRyb2xLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjb250cm9scyB2aXNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmlsaXR5IGZvciB0aGUgb2JqZWN0XG4gICAgICogQHJldHVybiB7Vm9pZH1cbiAgICAgKi9cbiAgICBzZXRWaXNpYmlsaXR5OiBmdW5jdGlvbih2aXNpYmlsaXR5IC8qIG5hbWUsIGZhYnJpY09iamVjdCAqLykge1xuICAgICAgdGhpcy52aXNpYmxlID0gdmlzaWJpbGl0eTtcbiAgICB9LFxuXG5cbiAgICBwb3NpdGlvbkhhbmRsZXI6IGZ1bmN0aW9uKGRpbSwgZmluYWxNYXRyaXggLyosIGZhYnJpY09iamVjdCwgY3VycmVudENvbnRyb2wgKi8pIHtcbiAgICAgIHZhciBwb2ludCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHtcbiAgICAgICAgeDogdGhpcy54ICogZGltLnggKyB0aGlzLm9mZnNldFgsXG4gICAgICAgIHk6IHRoaXMueSAqIGRpbS55ICsgdGhpcy5vZmZzZXRZIH0sIGZpbmFsTWF0cml4KTtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29vcmRzIGZvciB0aGlzIGNvbnRyb2wgYmFzZWQgb24gb2JqZWN0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2JqZWN0QW5nbGUgYW5nbGUgZnJvbSB0aGUgZmFicmljIG9iamVjdCBob2xkaW5nIHRoZSBjb250cm9sXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9iamVjdENvcm5lclNpemUgY29ybmVyU2l6ZSBmcm9tIHRoZSBmYWJyaWMgb2JqZWN0IGhvbGRpbmcgdGhlIGNvbnRyb2wgKG9yIHRvdWNoQ29ybmVyU2l6ZSBpZlxuICAgICAqICAgaXNUb3VjaCBpcyB0cnVlKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjZW50ZXJYIHggY29vcmRpbmF0ZSB3aGVyZSB0aGUgY29udHJvbCBjZW50ZXIgc2hvdWxkIGJlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNlbnRlclkgeSBjb29yZGluYXRlIHdoZXJlIHRoZSBjb250cm9sIGNlbnRlciBzaG91bGQgYmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVG91Y2ggdHJ1ZSBpZiB0b3VjaCBjb3JuZXIsIGZhbHNlIGlmIG5vcm1hbCBjb3JuZXJcbiAgICAgKi9cbiAgICBjYWxjQ29ybmVyQ29vcmRzOiBmdW5jdGlvbihvYmplY3RBbmdsZSwgb2JqZWN0Q29ybmVyU2l6ZSwgY2VudGVyWCwgY2VudGVyWSwgaXNUb3VjaCkge1xuICAgICAgdmFyIGNvc0hhbGZPZmZzZXQsXG4gICAgICAgICAgc2luSGFsZk9mZnNldCxcbiAgICAgICAgICBjb3NIYWxmT2Zmc2V0Q29tcCxcbiAgICAgICAgICBzaW5IYWxmT2Zmc2V0Q29tcCxcbiAgICAgICAgICB4U2l6ZSA9IChpc1RvdWNoKSA/IHRoaXMudG91Y2hTaXplWCA6IHRoaXMuc2l6ZVgsXG4gICAgICAgICAgeVNpemUgPSAoaXNUb3VjaCkgPyB0aGlzLnRvdWNoU2l6ZVkgOiB0aGlzLnNpemVZO1xuICAgICAgaWYgKHhTaXplICYmIHlTaXplICYmIHhTaXplICE9PSB5U2l6ZSkge1xuICAgICAgICAvLyBoYW5kbGUgcmVjdGFuZ3VsYXIgY29ybmVyc1xuICAgICAgICB2YXIgY29udHJvbFRyaWFuZ2xlQW5nbGUgPSBNYXRoLmF0YW4yKHlTaXplLCB4U2l6ZSk7XG4gICAgICAgIHZhciBjb3JuZXJIeXBvdGVudXNlID0gTWF0aC5zcXJ0KHhTaXplICogeFNpemUgKyB5U2l6ZSAqIHlTaXplKSAvIDI7XG4gICAgICAgIHZhciBuZXdUaGV0YSA9IGNvbnRyb2xUcmlhbmdsZUFuZ2xlIC0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyhvYmplY3RBbmdsZSk7XG4gICAgICAgIHZhciBuZXdUaGV0YUNvbXAgPSBNYXRoLlBJIC8gMiAtIGNvbnRyb2xUcmlhbmdsZUFuZ2xlIC0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyhvYmplY3RBbmdsZSk7XG4gICAgICAgIGNvc0hhbGZPZmZzZXQgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuY29zKG5ld1RoZXRhKTtcbiAgICAgICAgc2luSGFsZk9mZnNldCA9IGNvcm5lckh5cG90ZW51c2UgKiBmYWJyaWMudXRpbC5zaW4obmV3VGhldGEpO1xuICAgICAgICAvLyB1c2UgY29tcGxlbWVudGFyeSBhbmdsZSBmb3IgdHdvIGNvcm5lcnNcbiAgICAgICAgY29zSGFsZk9mZnNldENvbXAgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuY29zKG5ld1RoZXRhQ29tcCk7XG4gICAgICAgIHNpbkhhbGZPZmZzZXRDb21wID0gY29ybmVySHlwb3RlbnVzZSAqIGZhYnJpYy51dGlsLnNpbihuZXdUaGV0YUNvbXApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGhhbmRsZSBzcXVhcmUgY29ybmVyc1xuICAgICAgICAvLyB1c2UgZGVmYXVsdCBvYmplY3QgY29ybmVyIHNpemUgdW5sZXNzIHNpemUgaXMgZGVmaW5lZFxuICAgICAgICB2YXIgY29ybmVyU2l6ZSA9ICh4U2l6ZSAmJiB5U2l6ZSkgPyB4U2l6ZSA6IG9iamVjdENvcm5lclNpemU7XG4gICAgICAgIC8qIDAuNzA3MTA2NzgxMiBzdGFuZHMgZm9yIHNxcnQoMikvMiAqL1xuICAgICAgICBjb3JuZXJIeXBvdGVudXNlID0gY29ybmVyU2l6ZSAqIDAuNzA3MTA2NzgxMjtcbiAgICAgICAgLy8gY29tcGxlbWVudGFyeSBhbmdsZXMgYXJlIGVxdWFsIHNpbmNlIHRoZXkncmUgYm90aCA0NSBkZWdyZWVzXG4gICAgICAgIHZhciBuZXdUaGV0YSA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMoNDUgLSBvYmplY3RBbmdsZSk7XG4gICAgICAgIGNvc0hhbGZPZmZzZXQgPSBjb3NIYWxmT2Zmc2V0Q29tcCA9IGNvcm5lckh5cG90ZW51c2UgKiBmYWJyaWMudXRpbC5jb3MobmV3VGhldGEpO1xuICAgICAgICBzaW5IYWxmT2Zmc2V0ID0gc2luSGFsZk9mZnNldENvbXAgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuc2luKG5ld1RoZXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGw6IHtcbiAgICAgICAgICB4OiBjZW50ZXJYIC0gc2luSGFsZk9mZnNldENvbXAsXG4gICAgICAgICAgeTogY2VudGVyWSAtIGNvc0hhbGZPZmZzZXRDb21wLFxuICAgICAgICB9LFxuICAgICAgICB0cjoge1xuICAgICAgICAgIHg6IGNlbnRlclggKyBjb3NIYWxmT2Zmc2V0LFxuICAgICAgICAgIHk6IGNlbnRlclkgLSBzaW5IYWxmT2Zmc2V0LFxuICAgICAgICB9LFxuICAgICAgICBibDoge1xuICAgICAgICAgIHg6IGNlbnRlclggLSBjb3NIYWxmT2Zmc2V0LFxuICAgICAgICAgIHk6IGNlbnRlclkgKyBzaW5IYWxmT2Zmc2V0LFxuICAgICAgICB9LFxuICAgICAgICBicjoge1xuICAgICAgICAgIHg6IGNlbnRlclggKyBzaW5IYWxmT2Zmc2V0Q29tcCxcbiAgICAgICAgICB5OiBjZW50ZXJZICsgY29zSGFsZk9mZnNldENvbXAsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIFJlbmRlciBmdW5jdGlvbiBmb3IgdGhlIGNvbnRyb2wuXG4gICAgKiBXaGVuIHRoaXMgZnVuY3Rpb24gcnVucyB0aGUgY29udGV4dCBpcyB1bnNjYWxlZC4gdW5yb3RhdGUuIEp1c3QgcmV0aW5hIHNjYWxlZC5cbiAgICAqIGFsbCB0aGUgZnVuY3Rpb25zIHdpbGwgaGF2ZSB0byB0cmFuc2xhdGUgdG8gdGhlIHBvaW50IGxlZnQsdG9wIGJlZm9yZSBzdGFydGluZyBEcmF3aW5nXG4gICAgKiBpZiB0aGV5IHdhbnQgdG8gZHJhdyBhIGNvbnRyb2wgd2hlcmUgdGhlIHBvc2l0aW9uIGlzIGRldGVjdGVkLlxuICAgICogbGVmdCBhbmQgdG9wIGFyZSB0aGUgcmVzdWx0IG9mIHRoZSBwb3NpdGlvbkhhbmRsZXIgZnVuY3Rpb25cbiAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdGhlIGNvbnRleHQgd2hlcmUgdGhlIGNvbnRyb2wgd2lsbCBiZSBkcmF3blxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgcG9zaXRpb24gb2YgdGhlIGNhbnZhcyB3aGVyZSB3ZSBhcmUgYWJvdXQgdG8gcmVuZGVyIHRoZSBjb250cm9sLlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBwb3NpdGlvbiBvZiB0aGUgY2FudmFzIHdoZXJlIHdlIGFyZSBhYm91dCB0byByZW5kZXIgdGhlIGNvbnRyb2wuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPdmVycmlkZVxuICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIG9iamVjdCB3aGVyZSB0aGUgY29udHJvbCBpcyBhYm91dCB0byBiZSByZW5kZXJlZFxuICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgsIGxlZnQsIHRvcCwgc3R5bGVPdmVycmlkZSwgZmFicmljT2JqZWN0KSB7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICAgIHN3aXRjaCAoc3R5bGVPdmVycmlkZS5jb3JuZXJTdHlsZSB8fCBmYWJyaWNPYmplY3QuY29ybmVyU3R5bGUpIHtcbiAgICAgICAgY2FzZSAnY2lyY2xlJzpcbiAgICAgICAgICBmYWJyaWMuY29udHJvbHNVdGlscy5yZW5kZXJDaXJjbGVDb250cm9sLmNhbGwodGhpcywgY3R4LCBsZWZ0LCB0b3AsIHN0eWxlT3ZlcnJpZGUsIGZhYnJpY09iamVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZmFicmljLmNvbnRyb2xzVXRpbHMucmVuZGVyU3F1YXJlQ29udHJvbC5jYWxsKHRoaXMsIGN0eCwgbGVmdCwgdG9wLCBzdHlsZU92ZXJyaWRlLCBmYWJyaWNPYmplY3QpO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICBmdW5jdGlvbiBnZXRDb2xvclN0b3AoZWwsIG11bHRpcGxpZXIpIHtcbiAgICB2YXIgc3R5bGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyksXG4gICAgICAgIG9mZnNldCA9IGVsLmdldEF0dHJpYnV0ZSgnb2Zmc2V0JykgfHwgMCxcbiAgICAgICAgY29sb3IsIGNvbG9yQWxwaGEsIG9wYWNpdHksIGk7XG5cbiAgICAvLyBjb252ZXJ0IHBlcmNlbnRzIHRvIGFic29sdXRlIHZhbHVlc1xuICAgIG9mZnNldCA9IHBhcnNlRmxvYXQob2Zmc2V0KSAvICgvJSQvLnRlc3Qob2Zmc2V0KSA/IDEwMCA6IDEpO1xuICAgIG9mZnNldCA9IG9mZnNldCA8IDAgPyAwIDogb2Zmc2V0ID4gMSA/IDEgOiBvZmZzZXQ7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICB2YXIga2V5VmFsdWVQYWlycyA9IHN0eWxlLnNwbGl0KC9cXHMqO1xccyovKTtcblxuICAgICAgaWYgKGtleVZhbHVlUGFpcnNba2V5VmFsdWVQYWlycy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAga2V5VmFsdWVQYWlycy5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0ga2V5VmFsdWVQYWlycy5sZW5ndGg7IGktLTsgKSB7XG5cbiAgICAgICAgdmFyIHNwbGl0ID0ga2V5VmFsdWVQYWlyc1tpXS5zcGxpdCgvXFxzKjpcXHMqLyksXG4gICAgICAgICAgICBrZXkgPSBzcGxpdFswXS50cmltKCksXG4gICAgICAgICAgICB2YWx1ZSA9IHNwbGl0WzFdLnRyaW0oKTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnc3RvcC1jb2xvcicpIHtcbiAgICAgICAgICBjb2xvciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0b3Atb3BhY2l0eScpIHtcbiAgICAgICAgICBvcGFjaXR5ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICBjb2xvciA9IGVsLmdldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicpIHx8ICdyZ2IoMCwwLDApJztcbiAgICB9XG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICBvcGFjaXR5ID0gZWwuZ2V0QXR0cmlidXRlKCdzdG9wLW9wYWNpdHknKTtcbiAgICB9XG5cbiAgICBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoY29sb3IpO1xuICAgIGNvbG9yQWxwaGEgPSBjb2xvci5nZXRBbHBoYSgpO1xuICAgIG9wYWNpdHkgPSBpc05hTihwYXJzZUZsb2F0KG9wYWNpdHkpKSA/IDEgOiBwYXJzZUZsb2F0KG9wYWNpdHkpO1xuICAgIG9wYWNpdHkgKj0gY29sb3JBbHBoYSAqIG11bHRpcGxpZXI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBjb2xvcjogY29sb3IudG9SZ2IoKSxcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHlcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGluZWFyQ29vcmRzKGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiBlbC5nZXRBdHRyaWJ1dGUoJ3gxJykgfHwgMCxcbiAgICAgIHkxOiBlbC5nZXRBdHRyaWJ1dGUoJ3kxJykgfHwgMCxcbiAgICAgIHgyOiBlbC5nZXRBdHRyaWJ1dGUoJ3gyJykgfHwgJzEwMCUnLFxuICAgICAgeTI6IGVsLmdldEF0dHJpYnV0ZSgneTInKSB8fCAwXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhZGlhbENvb3JkcyhlbCkge1xuICAgIHJldHVybiB7XG4gICAgICB4MTogZWwuZ2V0QXR0cmlidXRlKCdmeCcpIHx8IGVsLmdldEF0dHJpYnV0ZSgnY3gnKSB8fCAnNTAlJyxcbiAgICAgIHkxOiBlbC5nZXRBdHRyaWJ1dGUoJ2Z5JykgfHwgZWwuZ2V0QXR0cmlidXRlKCdjeScpIHx8ICc1MCUnLFxuICAgICAgcjE6IDAsXG4gICAgICB4MjogZWwuZ2V0QXR0cmlidXRlKCdjeCcpIHx8ICc1MCUnLFxuICAgICAgeTI6IGVsLmdldEF0dHJpYnV0ZSgnY3knKSB8fCAnNTAlJyxcbiAgICAgIHIyOiBlbC5nZXRBdHRyaWJ1dGUoJ3InKSB8fCAnNTAlJ1xuICAgIH07XG4gIH1cbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICB2YXIgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgLyoqXG4gICAqIEdyYWRpZW50IGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuR3JhZGllbnRcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjZ3JhZGllbnRzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuR3JhZGllbnQjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5HcmFkaWVudCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLkdyYWRpZW50LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIG9mZnNldCBmb3IgYWxpZ25pbmcgZ3JhZGllbnRzIGNvbWluZyBmcm9tIFNWRyB3aGVuIG91dHNpZGUgcGF0aGdyb3Vwc1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBvZmZzZXRYOiAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgb2Zmc2V0IGZvciBhbGlnbmluZyBncmFkaWVudHMgY29taW5nIGZyb20gU1ZHIHdoZW4gb3V0c2lkZSBwYXRoZ3JvdXBzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG9mZnNldFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYW5zZm9ybSBtYXRyaXggdG8gYXBwbHkgdG8gdGhlIGdyYWRpZW50IGJlZm9yZSBwYWludGluZy5cbiAgICAgKiBJbXBvcnRlZCBmcm9tIHN2ZyBncmFkaWVudHMsIGlzIG5vdCBhcHBsaWVkIHdpdGggdGhlIGN1cnJlbnQgdHJhbnNmb3JtIGluIHRoZSBjZW50ZXIuXG4gICAgICogQmVmb3JlIHRoaXMgdHJhbnNmb3JtIGlzIGFwcGxpZWQsIHRoZSBvcmlnaW4gcG9pbnQgaXMgYXQgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgb2JqZWN0XG4gICAgICogcGx1cyB0aGUgYWRkaXRpb24gb2Ygb2Zmc2V0WSBhbmQgb2Zmc2V0WC5cbiAgICAgKiBAdHlwZSBOdW1iZXJbXVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBncmFkaWVudFRyYW5zZm9ybTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGNvb3JkaW5hdGVzIHVuaXRzIGZvciBjb29yZHMuXG4gICAgICogSWYgYHBpeGVsc2AsIHRoZSBudW1iZXIgb2YgY29vcmRzIGFyZSBpbiB0aGUgc2FtZSB1bml0IG9mIHdpZHRoIC8gaGVpZ2h0LlxuICAgICAqIElmIHNldCBhcyBgcGVyY2VudGFnZWAgdGhlIGNvb3JkcyBhcmUgc3RpbGwgYSBudW1iZXIsIGJ1dCAxIG1lYW5zIDEwMCUgb2Ygd2lkdGhcbiAgICAgKiBmb3IgdGhlIFggYW5kIDEwMCUgb2YgdGhlIGhlaWdodCBmb3IgdGhlIHkuIEl0IGNhbiBiZSBiaWdnZXIgdGhhbiAxIGFuZCBuZWdhdGl2ZS5cbiAgICAgKiBhbGxvd2VkIHZhbHVlcyBwaXhlbHMgb3IgcGVyY2VudGFnZS5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdCAncGl4ZWxzJ1xuICAgICAqL1xuICAgIGdyYWRpZW50VW5pdHM6ICdwaXhlbHMnLFxuXG4gICAgLyoqXG4gICAgICogR3JhZGllbnQgdHlwZSBsaW5lYXIgb3IgcmFkaWFsXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHQgJ3BpeGVscydcbiAgICAgKi9cbiAgICB0eXBlOiAnbGluZWFyJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3Qgd2l0aCB0eXBlLCBjb29yZHMsIGdyYWRpZW50VW5pdHMgYW5kIGNvbG9yU3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudHlwZV0gZ3JhZGllbnQgdHlwZSBsaW5lYXIgb3IgcmFkaWFsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmdyYWRpZW50VW5pdHNdIGdyYWRpZW50IHVuaXRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm9mZnNldFhdIFNWRyBpbXBvcnQgY29tcGF0aWJpbGl0eVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5vZmZzZXRZXSBTVkcgaW1wb3J0IGNvbXBhdGliaWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBvcHRpb25zLmNvbG9yU3RvcHMgY29udGFpbnMgdGhlIGNvbG9yc3RvcHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuY29vcmRzIGNvbnRhaW5zIHRoZSBjb29yZHMgb2YgdGhlIGdyYWRpZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb3Jkcy54MV0gWCBjb29yZGlhbnRlIG9mIHRoZSBmaXJzdCBwb2ludCBmb3IgbGluZWFyIG9yIG9mIHRoZSBmb2NhbCBwb2ludCBmb3IgcmFkaWFsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb3Jkcy55MV0gWSBjb29yZGlhbnRlIG9mIHRoZSBmaXJzdCBwb2ludCBmb3IgbGluZWFyIG9yIG9mIHRoZSBmb2NhbCBwb2ludCBmb3IgcmFkaWFsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb3Jkcy54Ml0gWCBjb29yZGlhbnRlIG9mIHRoZSBzZWNvbmQgcG9pbnQgZm9yIGxpbmVhciBvciBvZiB0aGUgY2VudGVyIHBvaW50IGZvciByYWRpYWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29vcmRzLnkyXSBZIGNvb3JkaWFudGUgb2YgdGhlIHNlY29uZCBwb2ludCBmb3IgbGluZWFyIG9yIG9mIHRoZSBjZW50ZXIgcG9pbnQgZm9yIHJhZGlhbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29yZHMucjFdIG9ubHkgZm9yIHJhZGlhbCBncmFkaWVudCwgcmFkaXVzIG9mIHRoZSBpbm5lciBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29vcmRzLnIyXSBvbmx5IGZvciByYWRpYWwgZ3JhZGllbnQsIHJhZGl1cyBvZiB0aGUgZXh0ZXJuYWwgY2lyY2xlXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyYWRpZW50fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICBvcHRpb25zLmNvb3JkcyB8fCAob3B0aW9ucy5jb29yZHMgPSB7IH0pO1xuXG4gICAgICB2YXIgY29vcmRzLCBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIHNldHMgZXZlcnl0aGluZywgdGhlbiBjb29yZHMgYW5kIGNvbG9yc3RvcHMgZ2V0IHNldHMgYWdhaW5cbiAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgIF90aGlzW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuaWQpIHtcbiAgICAgICAgdGhpcy5pZCArPSAnXycgKyBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5pZCA9IGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgIH1cblxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4MTogb3B0aW9ucy5jb29yZHMueDEgfHwgMCxcbiAgICAgICAgeTE6IG9wdGlvbnMuY29vcmRzLnkxIHx8IDAsXG4gICAgICAgIHgyOiBvcHRpb25zLmNvb3Jkcy54MiB8fCAwLFxuICAgICAgICB5Mjogb3B0aW9ucy5jb29yZHMueTIgfHwgMFxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgY29vcmRzLnIxID0gb3B0aW9ucy5jb29yZHMucjEgfHwgMDtcbiAgICAgICAgY29vcmRzLnIyID0gb3B0aW9ucy5jb29yZHMucjIgfHwgMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb29yZHMgPSBjb29yZHM7XG4gICAgICB0aGlzLmNvbG9yU3RvcHMgPSBvcHRpb25zLmNvbG9yU3RvcHMuc2xpY2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbm90aGVyIGNvbG9yU3RvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvclN0b3AgT2JqZWN0IHdpdGggb2Zmc2V0IGFuZCBjb2xvclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGFkZENvbG9yU3RvcDogZnVuY3Rpb24oY29sb3JTdG9wcykge1xuICAgICAgZm9yICh2YXIgcG9zaXRpb24gaW4gY29sb3JTdG9wcykge1xuICAgICAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGNvbG9yU3RvcHNbcG9zaXRpb25dKTtcbiAgICAgICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuICAgICAgICAgIG9mZnNldDogcGFyc2VGbG9hdChwb3NpdGlvbiksXG4gICAgICAgICAgY29sb3I6IGNvbG9yLnRvUmdiKCksXG4gICAgICAgICAgb3BhY2l0eTogY29sb3IuZ2V0QWxwaGEoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIGdyYWRpZW50XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9iamVjdCA9IHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBjb29yZHM6IHRoaXMuY29vcmRzLFxuICAgICAgICBjb2xvclN0b3BzOiB0aGlzLmNvbG9yU3RvcHMsXG4gICAgICAgIG9mZnNldFg6IHRoaXMub2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WTogdGhpcy5vZmZzZXRZLFxuICAgICAgICBncmFkaWVudFVuaXRzOiB0aGlzLmdyYWRpZW50VW5pdHMsXG4gICAgICAgIGdyYWRpZW50VHJhbnNmb3JtOiB0aGlzLmdyYWRpZW50VHJhbnNmb3JtID8gdGhpcy5ncmFkaWVudFRyYW5zZm9ybS5jb25jYXQoKSA6IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm1cbiAgICAgIH07XG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIG9iamVjdCwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgYW4gZ3JhZGllbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYSBncmFkaWVudCBmb3JcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBncmFkaWVudCAobGluZWFyL3JhZGlhbClcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob2JqZWN0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgY29vcmRzID0gY2xvbmUodGhpcy5jb29yZHMsIHRydWUpLCBpLCBsZW4sIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgICAgIG1hcmt1cCwgY29tbW9uQXR0cmlidXRlcywgY29sb3JTdG9wcyA9IGNsb25lKHRoaXMuY29sb3JTdG9wcywgdHJ1ZSksXG4gICAgICAgICAgbmVlZHNTd2FwID0gY29vcmRzLnIxID4gY29vcmRzLnIyLFxuICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0gPyB0aGlzLmdyYWRpZW50VHJhbnNmb3JtLmNvbmNhdCgpIDogZmFicmljLmlNYXRyaXguY29uY2F0KCksXG4gICAgICAgICAgb2Zmc2V0WCA9IC10aGlzLm9mZnNldFgsIG9mZnNldFkgPSAtdGhpcy5vZmZzZXRZLFxuICAgICAgICAgIHdpdGhWaWV3cG9ydCA9ICEhb3B0aW9ucy5hZGRpdGlvbmFsVHJhbnNmb3JtLFxuICAgICAgICAgIGdyYWRpZW50VW5pdHMgPSB0aGlzLmdyYWRpZW50VW5pdHMgPT09ICdwaXhlbHMnID8gJ3VzZXJTcGFjZU9uVXNlJyA6ICdvYmplY3RCb3VuZGluZ0JveCc7XG4gICAgICAvLyBjb2xvclN0b3BzIG11c3QgYmUgc29ydGVkIGFzY2VuZGluZ1xuICAgICAgY29sb3JTdG9wcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEub2Zmc2V0IC0gYi5vZmZzZXQ7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGdyYWRpZW50VW5pdHMgPT09ICdvYmplY3RCb3VuZGluZ0JveCcpIHtcbiAgICAgICAgb2Zmc2V0WCAvPSBvYmplY3Qud2lkdGg7XG4gICAgICAgIG9mZnNldFkgLz0gb2JqZWN0LmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvZmZzZXRYICs9IG9iamVjdC53aWR0aCAvIDI7XG4gICAgICAgIG9mZnNldFkgKz0gb2JqZWN0LmhlaWdodCAvIDI7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LnR5cGUgPT09ICdwYXRoJyAmJiB0aGlzLmdyYWRpZW50VW5pdHMgIT09ICdwZXJjZW50YWdlJykge1xuICAgICAgICBvZmZzZXRYIC09IG9iamVjdC5wYXRoT2Zmc2V0Lng7XG4gICAgICAgIG9mZnNldFkgLT0gb2JqZWN0LnBhdGhPZmZzZXQueTtcbiAgICAgIH1cblxuXG4gICAgICB0cmFuc2Zvcm1bNF0gLT0gb2Zmc2V0WDtcbiAgICAgIHRyYW5zZm9ybVs1XSAtPSBvZmZzZXRZO1xuXG4gICAgICBjb21tb25BdHRyaWJ1dGVzID0gJ2lkPVwiU1ZHSURfJyArIHRoaXMuaWQgK1xuICAgICAgICAgICAgICAgICAgICAgJ1wiIGdyYWRpZW50VW5pdHM9XCInICsgZ3JhZGllbnRVbml0cyArICdcIic7XG4gICAgICBjb21tb25BdHRyaWJ1dGVzICs9ICcgZ3JhZGllbnRUcmFuc2Zvcm09XCInICsgKHdpdGhWaWV3cG9ydCA/XG4gICAgICAgIG9wdGlvbnMuYWRkaXRpb25hbFRyYW5zZm9ybSArICcgJyA6ICcnKSArIGZhYnJpYy51dGlsLm1hdHJpeFRvU1ZHKHRyYW5zZm9ybSkgKyAnXCIgJztcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgbWFya3VwID0gW1xuICAgICAgICAgICc8bGluZWFyR3JhZGllbnQgJyxcbiAgICAgICAgICBjb21tb25BdHRyaWJ1dGVzLFxuICAgICAgICAgICcgeDE9XCInLCBjb29yZHMueDEsXG4gICAgICAgICAgJ1wiIHkxPVwiJywgY29vcmRzLnkxLFxuICAgICAgICAgICdcIiB4Mj1cIicsIGNvb3Jkcy54MixcbiAgICAgICAgICAnXCIgeTI9XCInLCBjb29yZHMueTIsXG4gICAgICAgICAgJ1wiPlxcbidcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgLy8gc3ZnIHJhZGlhbCBncmFkaWVudCBoYXMganVzdCAxIHJhZGl1cy4gdGhlIGJpZ2dlc3QuXG4gICAgICAgIG1hcmt1cCA9IFtcbiAgICAgICAgICAnPHJhZGlhbEdyYWRpZW50ICcsXG4gICAgICAgICAgY29tbW9uQXR0cmlidXRlcyxcbiAgICAgICAgICAnIGN4PVwiJywgbmVlZHNTd2FwID8gY29vcmRzLngxIDogY29vcmRzLngyLFxuICAgICAgICAgICdcIiBjeT1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy55MSA6IGNvb3Jkcy55MixcbiAgICAgICAgICAnXCIgcj1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy5yMSA6IGNvb3Jkcy5yMixcbiAgICAgICAgICAnXCIgZng9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMueDIgOiBjb29yZHMueDEsXG4gICAgICAgICAgJ1wiIGZ5PVwiJywgbmVlZHNTd2FwID8gY29vcmRzLnkyIDogY29vcmRzLnkxLFxuICAgICAgICAgICdcIj5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIGlmIChuZWVkc1N3YXApIHtcbiAgICAgICAgICAvLyBzdmcgZ29lcyBmcm9tIGludGVybmFsIHRvIGV4dGVybmFsIHJhZGl1cy4gaWYgcmFkaXVzIGFyZSBpbnZlcnRlZCwgc3dhcCBjb2xvciBzdG9wcy5cbiAgICAgICAgICBjb2xvclN0b3BzID0gY29sb3JTdG9wcy5jb25jYXQoKTtcbiAgICAgICAgICBjb2xvclN0b3BzLnJldmVyc2UoKTtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2xvclN0b3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb2xvclN0b3BzW2ldLm9mZnNldCA9IDEgLSBjb2xvclN0b3BzW2ldLm9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pblJhZGl1cyA9IE1hdGgubWluKGNvb3Jkcy5yMSwgY29vcmRzLnIyKTtcbiAgICAgICAgaWYgKG1pblJhZGl1cyA+IDApIHtcbiAgICAgICAgICAvLyBpIGhhdmUgdG8gc2hpZnQgYWxsIGNvbG9yU3RvcHMgYW5kIGFkZCBuZXcgb25lIGluIDAuXG4gICAgICAgICAgdmFyIG1heFJhZGl1cyA9IE1hdGgubWF4KGNvb3Jkcy5yMSwgY29vcmRzLnIyKSxcbiAgICAgICAgICAgICAgcGVyY2VudGFnZVNoaWZ0ID0gbWluUmFkaXVzIC8gbWF4UmFkaXVzO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbG9yU3RvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbG9yU3RvcHNbaV0ub2Zmc2V0ICs9IHBlcmNlbnRhZ2VTaGlmdCAqICgxIC0gY29sb3JTdG9wc1tpXS5vZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2xvclN0b3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjb2xvclN0b3AgPSBjb2xvclN0b3BzW2ldO1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPHN0b3AgJyxcbiAgICAgICAgICAnb2Zmc2V0PVwiJywgKGNvbG9yU3RvcC5vZmZzZXQgKiAxMDApICsgJyUnLFxuICAgICAgICAgICdcIiBzdHlsZT1cInN0b3AtY29sb3I6JywgY29sb3JTdG9wLmNvbG9yLFxuICAgICAgICAgICh0eXBlb2YgY29sb3JTdG9wLm9wYWNpdHkgIT09ICd1bmRlZmluZWQnID8gJztzdG9wLW9wYWNpdHk6ICcgKyBjb2xvclN0b3Aub3BhY2l0eSA6ICc7JyksXG4gICAgICAgICAgJ1wiLz5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG1hcmt1cC5wdXNoKCh0aGlzLnR5cGUgPT09ICdsaW5lYXInID8gJzwvbGluZWFyR3JhZGllbnQ+XFxuJyA6ICc8L3JhZGlhbEdyYWRpZW50PlxcbicpKTtcblxuICAgICAgcmV0dXJuIG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBDYW52YXNHcmFkaWVudFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNHcmFkaWVudH1cbiAgICAgKi9cbiAgICB0b0xpdmU6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIGdyYWRpZW50LCBjb29yZHMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUodGhpcy5jb29yZHMpLCBpLCBsZW47XG5cbiAgICAgIGlmICghdGhpcy50eXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoXG4gICAgICAgICAgY29vcmRzLngxLCBjb29yZHMueTEsIGNvb3Jkcy54MiwgY29vcmRzLnkyKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgZ3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoXG4gICAgICAgICAgY29vcmRzLngxLCBjb29yZHMueTEsIGNvb3Jkcy5yMSwgY29vcmRzLngyLCBjb29yZHMueTIsIGNvb3Jkcy5yMik7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuY29sb3JTdG9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmNvbG9yU3RvcHNbaV0uY29sb3IsXG4gICAgICAgICAgICBvcGFjaXR5ID0gdGhpcy5jb2xvclN0b3BzW2ldLm9wYWNpdHksXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmNvbG9yU3RvcHNbaV0ub2Zmc2V0O1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoY29sb3IpLnNldEFscGhhKG9wYWNpdHkpLnRvUmdiYSgpO1xuICAgICAgICB9XG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChvZmZzZXQsIGNvbG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH1cbiAgfSk7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuR3JhZGllbnQsIHtcblxuICAgIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuR3JhZGllbnR9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5HcmFkaWVudFxuICAgICAqIEBwYXJhbSB7U1ZHR3JhZGllbnRFbGVtZW50fSBlbCBTVkcgZ3JhZGllbnQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3BhY2l0eUF0dHIgQSBmaWxsLW9wYWNpdHkgb3Igc3Ryb2tlLW9wYWNpdHkgYXR0cmlidXRlIHRvIG11bHRpcGx5IHRvIGVhY2ggc3RvcCdzIG9wYWNpdHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN2Z09wdGlvbnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNpemUgb2YgdGhlIFNWRyBpbiBvcmRlciB0byBwYXJzZSBjb3JyZWN0bHkgZ3JhZGllbnRzXG4gICAgICogdGhhdCB1c2VzIGdyYWRpZW50VW5pdHMgYXMgJ3VzZXJTcGFjZU9uVXNlJyBhbmQgcGVyY2VudGFnZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3QubnVtYmVyfSB2aWV3Qm94V2lkdGggd2lkdGggcGFydCBvZiB0aGUgdmlld0JveCBhdHRyaWJ1dGUgb24gc3ZnXG4gICAgICogQHBhcmFtIHtPYmplY3QubnVtYmVyfSB2aWV3Qm94SGVpZ2h0IGhlaWdodCBwYXJ0IG9mIHRoZSB2aWV3Qm94IGF0dHJpYnV0ZSBvbiBzdmdcbiAgICAgKiBAcGFyYW0ge09iamVjdC5udW1iZXJ9IHdpZHRoIHdpZHRoIHBhcnQgb2YgdGhlIHN2ZyB0YWcgaWYgdmlld0JveCBpcyBub3Qgc3BlY2lmaWVkXG4gICAgICogQHBhcmFtIHtPYmplY3QubnVtYmVyfSBoZWlnaHQgaGVpZ2h0IHBhcnQgb2YgdGhlIHN2ZyB0YWcgaWYgdmlld0JveCBpcyBub3Qgc3BlY2lmaWVkXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyYWRpZW50fSBHcmFkaWVudCBpbnN0YW5jZVxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BzZXJ2ZXJzLmh0bWwjTGluZWFyR3JhZGllbnRFbGVtZW50XG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcHNlcnZlcnMuaHRtbCNSYWRpYWxHcmFkaWVudEVsZW1lbnRcbiAgICAgKi9cbiAgICBmcm9tRWxlbWVudDogZnVuY3Rpb24oZWwsIGluc3RhbmNlLCBvcGFjaXR5QXR0ciwgc3ZnT3B0aW9ucykge1xuICAgICAgLyoqXG4gICAgICAgKiAgQGV4YW1wbGU6XG4gICAgICAgKlxuICAgICAgICogIDxsaW5lYXJHcmFkaWVudCBpZD1cImxpbmVhckdyYWQxXCI+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwJVwiIHN0b3AtY29sb3I9XCJ3aGl0ZVwiLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjEwMCVcIiBzdG9wLWNvbG9yPVwiYmxhY2tcIi8+XG4gICAgICAgKiAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKiAgT1JcbiAgICAgICAqXG4gICAgICAgKiAgPGxpbmVhckdyYWRpZW50IGlkPVwibGluZWFyR3JhZDJcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjBcIiBzdHlsZT1cInN0b3AtY29sb3I6cmdiKDI1NSwyNTUsMjU1KVwiLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjFcIiBzdHlsZT1cInN0b3AtY29sb3I6cmdiKDAsMCwwKVwiLz5cbiAgICAgICAqICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqICBPUlxuICAgICAgICpcbiAgICAgICAqICA8cmFkaWFsR3JhZGllbnQgaWQ9XCJyYWRpYWxHcmFkMVwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMCVcIiBzdG9wLWNvbG9yPVwid2hpdGVcIiBzdG9wLW9wYWNpdHk9XCIxXCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjUwJVwiIHN0b3AtY29sb3I9XCJibGFja1wiIHN0b3Atb3BhY2l0eT1cIjAuNVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIxMDAlXCIgc3RvcC1jb2xvcj1cIndoaXRlXCIgc3RvcC1vcGFjaXR5PVwiMVwiIC8+XG4gICAgICAgKiAgPC9yYWRpYWxHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKiAgT1JcbiAgICAgICAqXG4gICAgICAgKiAgPHJhZGlhbEdyYWRpZW50IGlkPVwicmFkaWFsR3JhZDJcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjBcIiBzdG9wLWNvbG9yPVwicmdiKDI1NSwyNTUsMjU1KVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwLjVcIiBzdG9wLWNvbG9yPVwicmdiKDAsMCwwKVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIxXCIgc3RvcC1jb2xvcj1cInJnYigyNTUsMjU1LDI1NSlcIiAvPlxuICAgICAgICogIDwvcmFkaWFsR3JhZGllbnQ+XG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHZhciBtdWx0aXBsaWVyID0gcGFyc2VGbG9hdChvcGFjaXR5QXR0cikgLyAoLyUkLy50ZXN0KG9wYWNpdHlBdHRyKSA/IDEwMCA6IDEpO1xuICAgICAgbXVsdGlwbGllciA9IG11bHRpcGxpZXIgPCAwID8gMCA6IG11bHRpcGxpZXIgPiAxID8gMSA6IG11bHRpcGxpZXI7XG4gICAgICBpZiAoaXNOYU4obXVsdGlwbGllcikpIHtcbiAgICAgICAgbXVsdGlwbGllciA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvclN0b3BFbHMgPSBlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3RvcCcpLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZ3JhZGllbnRVbml0cyA9IGVsLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRVbml0cycpID09PSAndXNlclNwYWNlT25Vc2UnID9cbiAgICAgICAgICAgICdwaXhlbHMnIDogJ3BlcmNlbnRhZ2UnLFxuICAgICAgICAgIGdyYWRpZW50VHJhbnNmb3JtID0gZWwuZ2V0QXR0cmlidXRlKCdncmFkaWVudFRyYW5zZm9ybScpIHx8ICcnLFxuICAgICAgICAgIGNvbG9yU3RvcHMgPSBbXSxcbiAgICAgICAgICBjb29yZHMsIGksIG9mZnNldFggPSAwLCBvZmZzZXRZID0gMCxcbiAgICAgICAgICB0cmFuc2Zvcm1NYXRyaXg7XG4gICAgICBpZiAoZWwubm9kZU5hbWUgPT09ICdsaW5lYXJHcmFkaWVudCcgfHwgZWwubm9kZU5hbWUgPT09ICdMSU5FQVJHUkFESUVOVCcpIHtcbiAgICAgICAgdHlwZSA9ICdsaW5lYXInO1xuICAgICAgICBjb29yZHMgPSBnZXRMaW5lYXJDb29yZHMoZWwpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHR5cGUgPSAncmFkaWFsJztcbiAgICAgICAgY29vcmRzID0gZ2V0UmFkaWFsQ29vcmRzKGVsKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gY29sb3JTdG9wRWxzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgY29sb3JTdG9wcy5wdXNoKGdldENvbG9yU3RvcChjb2xvclN0b3BFbHNbaV0sIG11bHRpcGxpZXIpKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNmb3JtTWF0cml4ID0gZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlKGdyYWRpZW50VHJhbnNmb3JtKTtcblxuICAgICAgX19jb252ZXJ0UGVyY2VudFVuaXRzVG9WYWx1ZXMoaW5zdGFuY2UsIGNvb3Jkcywgc3ZnT3B0aW9ucywgZ3JhZGllbnRVbml0cyk7XG5cbiAgICAgIGlmIChncmFkaWVudFVuaXRzID09PSAncGl4ZWxzJykge1xuICAgICAgICBvZmZzZXRYID0gLWluc3RhbmNlLmxlZnQ7XG4gICAgICAgIG9mZnNldFkgPSAtaW5zdGFuY2UudG9wO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ3JhZGllbnQgPSBuZXcgZmFicmljLkdyYWRpZW50KHtcbiAgICAgICAgaWQ6IGVsLmdldEF0dHJpYnV0ZSgnaWQnKSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgY29vcmRzOiBjb29yZHMsXG4gICAgICAgIGNvbG9yU3RvcHM6IGNvbG9yU3RvcHMsXG4gICAgICAgIGdyYWRpZW50VW5pdHM6IGdyYWRpZW50VW5pdHMsXG4gICAgICAgIGdyYWRpZW50VHJhbnNmb3JtOiB0cmFuc2Zvcm1NYXRyaXgsXG4gICAgICAgIG9mZnNldFg6IG9mZnNldFgsXG4gICAgICAgIG9mZnNldFk6IG9mZnNldFksXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH1cbiAgICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9fY29udmVydFBlcmNlbnRVbml0c1RvVmFsdWVzKGluc3RhbmNlLCBvcHRpb25zLCBzdmdPcHRpb25zLCBncmFkaWVudFVuaXRzKSB7XG4gICAgdmFyIHByb3BWYWx1ZSwgZmluYWxWYWx1ZTtcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIHByb3BWYWx1ZSA9IG9wdGlvbnNbcHJvcF07XG4gICAgICBpZiAocHJvcFZhbHVlID09PSAnSW5maW5pdHknKSB7XG4gICAgICAgIGZpbmFsVmFsdWUgPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocHJvcFZhbHVlID09PSAnLUluZmluaXR5Jykge1xuICAgICAgICBmaW5hbFZhbHVlID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmaW5hbFZhbHVlID0gcGFyc2VGbG9hdChvcHRpb25zW3Byb3BdLCAxMCk7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAnc3RyaW5nJyAmJiAvXihcXGQrXFwuXFxkKyklfChcXGQrKSUkLy50ZXN0KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICBmaW5hbFZhbHVlICo9IDAuMDE7XG4gICAgICAgICAgaWYgKGdyYWRpZW50VW5pdHMgPT09ICdwaXhlbHMnKSB7XG4gICAgICAgICAgICAvLyB0aGVuIHdlIG5lZWQgdG8gZml4IHRob3NlIHBlcmNlbnRhZ2VzIGhlcmUgaW4gc3ZnIHBhcnNpbmdcbiAgICAgICAgICAgIGlmIChwcm9wID09PSAneDEnIHx8IHByb3AgPT09ICd4MicgfHwgcHJvcCA9PT0gJ3IyJykge1xuICAgICAgICAgICAgICBmaW5hbFZhbHVlICo9IHN2Z09wdGlvbnMudmlld0JveFdpZHRoIHx8IHN2Z09wdGlvbnMud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ3kxJyB8fCBwcm9wID09PSAneTInKSB7XG4gICAgICAgICAgICAgIGZpbmFsVmFsdWUgKj0gc3ZnT3B0aW9ucy52aWV3Qm94SGVpZ2h0IHx8IHN2Z09wdGlvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3B0aW9uc1twcm9wXSA9IGZpbmFsVmFsdWU7XG4gICAgfSk7XG4gIH1cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgLyoqXG4gICAqIFBhdHRlcm4gY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QYXR0ZXJuXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vcGF0dGVybnN8UGF0dGVybiBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2R5bmFtaWMtcGF0dGVybnN8RHluYW1pY1BhdHRlcm4gZGVtb31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlBhdHRlcm4jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG5cblxuICBmYWJyaWMuUGF0dGVybiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLlBhdHRlcm4ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFJlcGVhdCBwcm9wZXJ0eSBvZiBhIHBhdHRlcm4gKG9uZSBvZiByZXBlYXQsIHJlcGVhdC14LCByZXBlYXQteSBvciBuby1yZXBlYXQpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByZXBlYXQ6ICdyZXBlYXQnLFxuXG4gICAgLyoqXG4gICAgICogUGF0dGVybiBob3Jpem9udGFsIG9mZnNldCBmcm9tIG9iamVjdCdzIGxlZnQvdG9wIGNvcm5lclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFBhdHRlcm4gdmVydGljYWwgb2Zmc2V0IGZyb20gb2JqZWN0J3MgbGVmdC90b3AgY29ybmVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogY3Jvc3NPcmlnaW4gdmFsdWUgKG9uZSBvZiBcIlwiLCBcImFub255bW91c1wiLCBcInVzZS1jcmVkZW50aWFsc1wiKVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Jvc3NPcmlnaW46ICcnLFxuXG4gICAgLyoqXG4gICAgICogdHJhbnNmb3JtIG1hdHJpeCB0byBjaGFuZ2UgdGhlIHBhdHRlcm4sIGltcG9ydGVkIGZyb20gc3Zncy5cbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGF0dGVyblRyYW5zZm9ybTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gZnVuY3Rpb24gdG8gaW52b2tlIGFmdGVyIGNhbGxiYWNrIGluaXQuXG4gICAgICogQHJldHVybiB7ZmFicmljLlBhdHRlcm59IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHRoaXMuaWQgPSBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBpZiAoIW9wdGlvbnMuc291cmNlIHx8IChvcHRpb25zLnNvdXJjZSAmJiB0eXBlb2Ygb3B0aW9ucy5zb3VyY2UgIT09ICdzdHJpbmcnKSkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh0aGlzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGltZyBzcmMgc3RyaW5nXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc291cmNlID0gZmFicmljLnV0aWwuY3JlYXRlSW1hZ2UoKTtcbiAgICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKG9wdGlvbnMuc291cmNlLCBmdW5jdGlvbihpbWcsIGlzRXJyb3IpIHtcbiAgICAgICAgICBfdGhpcy5zb3VyY2UgPSBpbWc7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soX3RoaXMsIGlzRXJyb3IpO1xuICAgICAgICB9LCBudWxsLCB0aGlzLmNyb3NzT3JpZ2luKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVybiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcbiAgICAgICAgICBzb3VyY2UsIG9iamVjdDtcblxuICAgICAgLy8gPGltZz4gZWxlbWVudFxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZS5zcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuc291cmNlLnNyYztcbiAgICAgIH1cbiAgICAgIC8vIDxjYW52YXM+IGVsZW1lbnRcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ29iamVjdCcgJiYgdGhpcy5zb3VyY2UudG9EYXRhVVJMKSB7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuc291cmNlLnRvRGF0YVVSTCgpO1xuICAgICAgfVxuXG4gICAgICBvYmplY3QgPSB7XG4gICAgICAgIHR5cGU6ICdwYXR0ZXJuJyxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHJlcGVhdDogdGhpcy5yZXBlYXQsXG4gICAgICAgIGNyb3NzT3JpZ2luOiB0aGlzLmNyb3NzT3JpZ2luLFxuICAgICAgICBvZmZzZXRYOiB0b0ZpeGVkKHRoaXMub2Zmc2V0WCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgIG9mZnNldFk6IHRvRml4ZWQodGhpcy5vZmZzZXRZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgcGF0dGVyblRyYW5zZm9ybTogdGhpcy5wYXR0ZXJuVHJhbnNmb3JtID8gdGhpcy5wYXR0ZXJuVHJhbnNmb3JtLmNvbmNhdCgpIDogbnVsbFxuICAgICAgfTtcbiAgICAgIGZhYnJpYy51dGlsLnBvcHVsYXRlV2l0aFByb3BlcnRpZXModGhpcywgb2JqZWN0LCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHBhdHRlcm5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVyblxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBwYXR0ZXJuU291cmNlID0gdHlwZW9mIHRoaXMuc291cmNlID09PSAnZnVuY3Rpb24nID8gdGhpcy5zb3VyY2UoKSA6IHRoaXMuc291cmNlLFxuICAgICAgICAgIHBhdHRlcm5XaWR0aCA9IHBhdHRlcm5Tb3VyY2Uud2lkdGggLyBvYmplY3Qud2lkdGgsXG4gICAgICAgICAgcGF0dGVybkhlaWdodCA9IHBhdHRlcm5Tb3VyY2UuaGVpZ2h0IC8gb2JqZWN0LmhlaWdodCxcbiAgICAgICAgICBwYXR0ZXJuT2Zmc2V0WCA9IHRoaXMub2Zmc2V0WCAvIG9iamVjdC53aWR0aCxcbiAgICAgICAgICBwYXR0ZXJuT2Zmc2V0WSA9IHRoaXMub2Zmc2V0WSAvIG9iamVjdC5oZWlnaHQsXG4gICAgICAgICAgcGF0dGVybkltZ1NyYyA9ICcnO1xuICAgICAgaWYgKHRoaXMucmVwZWF0ID09PSAncmVwZWF0LXgnIHx8IHRoaXMucmVwZWF0ID09PSAnbm8tcmVwZWF0Jykge1xuICAgICAgICBwYXR0ZXJuSGVpZ2h0ID0gMTtcbiAgICAgICAgaWYgKHBhdHRlcm5PZmZzZXRZKSB7XG4gICAgICAgICAgcGF0dGVybkhlaWdodCArPSBNYXRoLmFicyhwYXR0ZXJuT2Zmc2V0WSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlcGVhdCA9PT0gJ3JlcGVhdC15JyB8fCB0aGlzLnJlcGVhdCA9PT0gJ25vLXJlcGVhdCcpIHtcbiAgICAgICAgcGF0dGVybldpZHRoID0gMTtcbiAgICAgICAgaWYgKHBhdHRlcm5PZmZzZXRYKSB7XG4gICAgICAgICAgcGF0dGVybldpZHRoICs9IE1hdGguYWJzKHBhdHRlcm5PZmZzZXRYKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICBpZiAocGF0dGVyblNvdXJjZS5zcmMpIHtcbiAgICAgICAgcGF0dGVybkltZ1NyYyA9IHBhdHRlcm5Tb3VyY2Uuc3JjO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocGF0dGVyblNvdXJjZS50b0RhdGFVUkwpIHtcbiAgICAgICAgcGF0dGVybkltZ1NyYyA9IHBhdHRlcm5Tb3VyY2UudG9EYXRhVVJMKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnPHBhdHRlcm4gaWQ9XCJTVkdJRF8nICsgdGhpcy5pZCArXG4gICAgICAgICAgICAgICAgICAgICdcIiB4PVwiJyArIHBhdHRlcm5PZmZzZXRYICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIHk9XCInICsgcGF0dGVybk9mZnNldFkgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgd2lkdGg9XCInICsgcGF0dGVybldpZHRoICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIGhlaWdodD1cIicgKyBwYXR0ZXJuSGVpZ2h0ICsgJ1wiPlxcbicgK1xuICAgICAgICAgICAgICAgJzxpbWFnZSB4PVwiMFwiIHk9XCIwXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAnIHdpZHRoPVwiJyArIHBhdHRlcm5Tb3VyY2Uud2lkdGggK1xuICAgICAgICAgICAgICAgICAgICAgICdcIiBoZWlnaHQ9XCInICsgcGF0dGVyblNvdXJjZS5oZWlnaHQgK1xuICAgICAgICAgICAgICAgICAgICAgICdcIiB4bGluazpocmVmPVwiJyArIHBhdHRlcm5JbWdTcmMgK1xuICAgICAgICAgICAgICAgJ1wiPjwvaW1hZ2U+XFxuJyArXG4gICAgICAgICAgICAgJzwvcGF0dGVybj5cXG4nO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpc1twcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgQ2FudmFzUGF0dGVyblxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBjcmVhdGUgcGF0dGVyblxuICAgICAqIEByZXR1cm4ge0NhbnZhc1BhdHRlcm59XG4gICAgICovXG4gICAgdG9MaXZlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgIC8vIGlmIHRoZSBpbWFnZSBmYWlsZWQgdG8gbG9hZCwgcmV0dXJuLCBhbmQgYWxsb3cgcmVzdCB0byBjb250aW51ZSBsb2FkaW5nXG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGFuIGltYWdlXG4gICAgICBpZiAodHlwZW9mIHNvdXJjZS5zcmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICghc291cmNlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UubmF0dXJhbFdpZHRoID09PSAwIHx8IHNvdXJjZS5uYXR1cmFsSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4LmNyZWF0ZVBhdHRlcm4oc291cmNlLCB0aGlzLnJlcGVhdCk7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZDtcblxuICBpZiAoZmFicmljLlNoYWRvdykge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuU2hhZG93IGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogU2hhZG93IGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuU2hhZG93XG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vc2hhZG93c3xTaGFkb3cgZGVtb31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlNoYWRvdyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlNoYWRvdyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLlNoYWRvdy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogU2hhZG93IGNvbG9yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb2xvcjogJ3JnYigwLDAsMCknLFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IGJsdXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBibHVyOiAwLFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IGhvcml6b250YWwgb2Zmc2V0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvZmZzZXRYOiAwLFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IHZlcnRpY2FsIG9mZnNldFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WTogMCxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHNoYWRvdyBzaG91bGQgYWZmZWN0IHN0cm9rZSBvcGVyYXRpb25zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWZmZWN0U3Ryb2tlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRvT2JqZWN0IHNob3VsZCBpbmNsdWRlIGRlZmF1bHQgdmFsdWVzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW5jbHVkZURlZmF1bHRWYWx1ZXM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGBmYWxzZWAsIHRoZSBzaGFkb3cgd2lsbCBzY2FsZSB3aXRoIHRoZSBvYmplY3QuXG4gICAgICogV2hlbiBgdHJ1ZWAsIHRoZSBzaGFkb3cncyBvZmZzZXRYLCBvZmZzZXRZLCBhbmQgYmx1ciB3aWxsIG5vdCBiZSBhZmZlY3RlZCBieSB0aGUgb2JqZWN0J3Mgc2NhbGUuXG4gICAgICogZGVmYXVsdCB0byBmYWxzZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG5vblNjYWxpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCB3aXRoIGFueSBvZiBjb2xvciwgYmx1ciwgb2Zmc2V0WCwgb2Zmc2V0WSBwcm9wZXJ0aWVzIG9yIHN0cmluZyAoZS5nLiBcInJnYmEoMCwwLDAsMC4yKSAycHggMnB4IDEwcHhcIilcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuU2hhZG93fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJzZVNoYWRvdyhvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaGFkb3cgU2hhZG93IHZhbHVlIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBTaGFkb3cgb2JqZWN0IHdpdGggY29sb3IsIG9mZnNldFgsIG9mZnNldFkgYW5kIGJsdXJcbiAgICAgKi9cbiAgICBfcGFyc2VTaGFkb3c6IGZ1bmN0aW9uKHNoYWRvdykge1xuICAgICAgdmFyIHNoYWRvd1N0ciA9IHNoYWRvdy50cmltKCksXG4gICAgICAgICAgb2Zmc2V0c0FuZEJsdXIgPSBmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIuZXhlYyhzaGFkb3dTdHIpIHx8IFtdLFxuICAgICAgICAgIGNvbG9yID0gc2hhZG93U3RyLnJlcGxhY2UoZmFicmljLlNoYWRvdy5yZU9mZnNldHNBbmRCbHVyLCAnJykgfHwgJ3JnYigwLDAsMCknO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xvcjogY29sb3IudHJpbSgpLFxuICAgICAgICBvZmZzZXRYOiBwYXJzZUZsb2F0KG9mZnNldHNBbmRCbHVyWzFdLCAxMCkgfHwgMCxcbiAgICAgICAgb2Zmc2V0WTogcGFyc2VGbG9hdChvZmZzZXRzQW5kQmx1clsyXSwgMTApIHx8IDAsXG4gICAgICAgIGJsdXI6IHBhcnNlRmxvYXQob2Zmc2V0c0FuZEJsdXJbM10sIDEwKSB8fCAwXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MtdGV4dC1kZWNvci0zLyN0ZXh0LXNoYWRvd1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBDU1MzIHRleHQtc2hhZG93IGRlY2xhcmF0aW9uXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLm9mZnNldFgsIHRoaXMub2Zmc2V0WSwgdGhpcy5ibHVyLCB0aGlzLmNvbG9yXS5qb2luKCdweCAnKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3dcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgZkJveFggPSA0MCwgZkJveFkgPSA0MCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcbiAgICAgICAgICBvZmZzZXQgPSBmYWJyaWMudXRpbC5yb3RhdGVWZWN0b3IoXG4gICAgICAgICAgICB7IHg6IHRoaXMub2Zmc2V0WCwgeTogdGhpcy5vZmZzZXRZIH0sXG4gICAgICAgICAgICBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKC1vYmplY3QuYW5nbGUpKSxcbiAgICAgICAgICBCTFVSX0JPWCA9IDIwLCBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcik7XG5cbiAgICAgIGlmIChvYmplY3Qud2lkdGggJiYgb2JqZWN0LmhlaWdodCkge1xuICAgICAgICAvL2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9maWx0ZXJzLmh0bWwjRmlsdGVyRWZmZWN0c1JlZ2lvblxuICAgICAgICAvLyB3ZSBhZGQgc29tZSBleHRyYSBzcGFjZSB0byBmaWx0ZXIgYm94IHRvIGNvbnRhaW4gdGhlIGJsdXIgKCAyMCApXG4gICAgICAgIGZCb3hYID0gdG9GaXhlZCgoTWF0aC5hYnMob2Zmc2V0LngpICsgdGhpcy5ibHVyKSAvIG9iamVjdC53aWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKiAxMDAgKyBCTFVSX0JPWDtcbiAgICAgICAgZkJveFkgPSB0b0ZpeGVkKChNYXRoLmFicyhvZmZzZXQueSkgKyB0aGlzLmJsdXIpIC8gb2JqZWN0LmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKiAxMDAgKyBCTFVSX0JPWDtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZmxpcFgpIHtcbiAgICAgICAgb2Zmc2V0LnggKj0gLTE7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmZsaXBZKSB7XG4gICAgICAgIG9mZnNldC55ICo9IC0xO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAnPGZpbHRlciBpZD1cIlNWR0lEXycgKyB0aGlzLmlkICsgJ1wiIHk9XCItJyArIGZCb3hZICsgJyVcIiBoZWlnaHQ9XCInICsgKDEwMCArIDIgKiBmQm94WSkgKyAnJVwiICcgK1xuICAgICAgICAgICd4PVwiLScgKyBmQm94WCArICclXCIgd2lkdGg9XCInICsgKDEwMCArIDIgKiBmQm94WCkgKyAnJVwiICcgKyAnPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVHYXVzc2lhbkJsdXIgaW49XCJTb3VyY2VBbHBoYVwiIHN0ZERldmlhdGlvbj1cIicgK1xuICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmJsdXIgPyB0aGlzLmJsdXIgLyAyIDogMCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCI+PC9mZUdhdXNzaWFuQmx1cj5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlT2Zmc2V0IGR4PVwiJyArIHRvRml4ZWQob2Zmc2V0LngsIE5VTV9GUkFDVElPTl9ESUdJVFMpICtcbiAgICAgICAgICAnXCIgZHk9XCInICsgdG9GaXhlZChvZmZzZXQueSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCIgcmVzdWx0PVwib0JsdXJcIiA+PC9mZU9mZnNldD5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlRmxvb2QgZmxvb2QtY29sb3I9XCInICsgY29sb3IudG9SZ2IoKSArICdcIiBmbG9vZC1vcGFjaXR5PVwiJyArIGNvbG9yLmdldEFscGhhKCkgKyAnXCIvPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVDb21wb3NpdGUgaW4yPVwib0JsdXJcIiBvcGVyYXRvcj1cImluXCIgLz5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlTWVyZ2U+XFxuJyArXG4gICAgICAgICAgICAnXFx0XFx0PGZlTWVyZ2VOb2RlPjwvZmVNZXJnZU5vZGU+XFxuJyArXG4gICAgICAgICAgICAnXFx0XFx0PGZlTWVyZ2VOb2RlIGluPVwiU291cmNlR3JhcGhpY1wiPjwvZmVNZXJnZU5vZGU+XFxuJyArXG4gICAgICAgICAgJ1xcdDwvZmVNZXJnZT5cXG4nICtcbiAgICAgICAgJzwvZmlsdGVyPlxcbicpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgc2hhZG93IGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICBibHVyOiB0aGlzLmJsdXIsXG4gICAgICAgICAgb2Zmc2V0WDogdGhpcy5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFk6IHRoaXMub2Zmc2V0WSxcbiAgICAgICAgICBhZmZlY3RTdHJva2U6IHRoaXMuYWZmZWN0U3Ryb2tlLFxuICAgICAgICAgIG5vblNjYWxpbmc6IHRoaXMubm9uU2NhbGluZ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHsgfSwgcHJvdG8gPSBmYWJyaWMuU2hhZG93LnByb3RvdHlwZTtcblxuICAgICAgWydjb2xvcicsICdibHVyJywgJ29mZnNldFgnLCAnb2Zmc2V0WScsICdhZmZlY3RTdHJva2UnLCAnbm9uU2NhbGluZyddLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICBpZiAodGhpc1twcm9wXSAhPT0gcHJvdG9bcHJvcF0pIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSB0aGlzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBzaGFkb3cgb2Zmc2V0WCwgb2Zmc2V0WSBhbmQgYmx1ciAoZXg6IFwiMnB4IDJweCAxMHB4IHJnYmEoMCwwLDAsMC4yKVwiLCBcInJnYigwLDI1NSwwKSAycHggMnB4XCIpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuU2hhZG93XG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIgPSAvKD86XFxzfF4pKC0/XFxkKyg/OlxcLlxcZCopPyg/OnB4KT8oPzpcXHM/fCQpKT8oLT9cXGQrKD86XFwuXFxkKik/KD86cHgpPyg/Olxccz98JCkpPyhcXGQrKD86XFwuXFxkKik/KD86cHgpPyk/KD86XFxzP3wkKSg/OiR8XFxzKS87XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAoZmFicmljLlN0YXRpY0NhbnZhcykge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuU3RhdGljQ2FudmFzIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhbGlhc2VzIGZvciBmYXN0ZXIgcmVzb2x1dGlvblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGdldEVsZW1lbnRPZmZzZXQgPSBmYWJyaWMudXRpbC5nZXRFbGVtZW50T2Zmc2V0LFxuICAgICAgcmVtb3ZlRnJvbUFycmF5ID0gZmFicmljLnV0aWwucmVtb3ZlRnJvbUFycmF5LFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICB0cmFuc2Zvcm1Qb2ludCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50LFxuICAgICAgaW52ZXJ0VHJhbnNmb3JtID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtLFxuICAgICAgZ2V0Tm9kZUNhbnZhcyA9IGZhYnJpYy51dGlsLmdldE5vZGVDYW52YXMsXG4gICAgICBjcmVhdGVDYW52YXNFbGVtZW50ID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCxcblxuICAgICAgQ0FOVkFTX0lOSVRfRVJST1IgPSBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBpbml0aWFsaXplIGBjYW52YXNgIGVsZW1lbnQnKTtcblxuICAvKipcbiAgICogU3RhdGljIGNhbnZhcyBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlN0YXRpY0NhbnZhc1xuICAgKiBAbWl4ZXMgZmFicmljLkNvbGxlY3Rpb25cbiAgICogQG1peGVzIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vc3RhdGljX2NhbnZhc3xTdGF0aWNDYW52YXMgZGVtb31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAZmlyZXMgYmVmb3JlOnJlbmRlclxuICAgKiBAZmlyZXMgYWZ0ZXI6cmVuZGVyXG4gICAqIEBmaXJlcyBjYW52YXM6Y2xlYXJlZFxuICAgKiBAZmlyZXMgb2JqZWN0OmFkZGVkXG4gICAqIEBmaXJlcyBvYmplY3Q6cmVtb3ZlZFxuICAgKi9cbiAgZmFicmljLlN0YXRpY0NhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5Db21tb25NZXRob2RzLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFN0cmluZ30gZWwgJmx0O2NhbnZhcz4gZWxlbWVudCB0byBpbml0aWFsaXplIGluc3RhbmNlIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMucmVuZGVyQW5kUmVzZXRCb3VuZCA9IHRoaXMucmVuZGVyQW5kUmVzZXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbEJvdW5kID0gdGhpcy5yZXF1ZXN0UmVuZGVyQWxsLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9pbml0U3RhdGljKGVsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogU2hvdWxkIGJlIHNldCB2aWEge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjc2V0QmFja2dyb3VuZENvbG9yfS5cbiAgICAgKiBAdHlwZSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICcnLFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBpbWFnZSBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogc2luY2UgMi40LjAgaW1hZ2UgY2FjaGluZyBpcyBhY3RpdmUsIHBsZWFzZSB3aGVuIHB1dHRpbmcgYW4gaW1hZ2UgYXMgYmFja2dyb3VuZCwgYWRkIHRvIHRoZVxuICAgICAqIGNhbnZhcyBwcm9wZXJ0eSBhIHJlZmVyZW5jZSB0byB0aGUgY2FudmFzIGl0IGlzIG9uLiBPdGhlcndpc2UgdGhlIGltYWdlIGNhbm5vdCBkZXRlY3QgdGhlIHpvb21cbiAgICAgKiB2YWxlLiBBcyBhbiBhbHRlcm5hdGl2ZSB5b3UgY2FuIGRpc2FibGUgaW1hZ2Ugb2JqZWN0Q2FjaGluZ1xuICAgICAqIEB0eXBlIGZhYnJpYy5JbWFnZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYmFja2dyb3VuZEltYWdlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcmxheSBjb2xvciBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogU2hvdWxkIGJlIHNldCB2aWEge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjc2V0T3ZlcmxheUNvbG9yfVxuICAgICAqIEBzaW5jZSAxLjMuOVxuICAgICAqIEB0eXBlIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsYXlDb2xvcjogJycsXG5cbiAgICAvKipcbiAgICAgKiBPdmVybGF5IGltYWdlIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBzaW5jZSAyLjQuMCBpbWFnZSBjYWNoaW5nIGlzIGFjdGl2ZSwgcGxlYXNlIHdoZW4gcHV0dGluZyBhbiBpbWFnZSBhcyBvdmVybGF5LCBhZGQgdG8gdGhlXG4gICAgICogY2FudmFzIHByb3BlcnR5IGEgcmVmZXJlbmNlIHRvIHRoZSBjYW52YXMgaXQgaXMgb24uIE90aGVyd2lzZSB0aGUgaW1hZ2UgY2Fubm90IGRldGVjdCB0aGUgem9vbVxuICAgICAqIHZhbGUuIEFzIGFuIGFsdGVybmF0aXZlIHlvdSBjYW4gZGlzYWJsZSBpbWFnZSBvYmplY3RDYWNoaW5nXG4gICAgICogQHR5cGUgZmFicmljLkltYWdlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvdmVybGF5SW1hZ2U6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0b09iamVjdC90b0RhdGFsZXNzT2JqZWN0IHNob3VsZCBpbmNsdWRlIGRlZmF1bHQgdmFsdWVzXG4gICAgICogaWYgc2V0IHRvIGZhbHNlLCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhlIG9iamVjdCB2YWx1ZS5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9iamVjdHMnIHN0YXRlIHNob3VsZCBiZSBzYXZlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0YXRlZnVsOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHtAbGluayBmYWJyaWMuQ29sbGVjdGlvbi5hZGR9LCB7QGxpbmsgZmFicmljLkNvbGxlY3Rpb24uaW5zZXJ0QXR9IGFuZCB7QGxpbmsgZmFicmljLkNvbGxlY3Rpb24ucmVtb3ZlfSxcbiAgICAgKiB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcy5tb3ZlVG99LCB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcy5jbGVhcn0gYW5kIG1hbnkgbW9yZSwgc2hvdWxkIGFsc28gcmUtcmVuZGVyIGNhbnZhcy5cbiAgICAgKiBEaXNhYmxpbmcgdGhpcyBvcHRpb24gd2lsbCBub3QgZ2l2ZSBhIHBlcmZvcm1hbmNlIGJvb3N0IHdoZW4gYWRkaW5nL3JlbW92aW5nIGEgbG90IG9mIG9iamVjdHMgdG8vZnJvbSBjYW52YXMgYXQgb25jZVxuICAgICAqIHNpbmNlIHRoZSByZW5kZXJzIGFyZSBxdWVxdWVkIGFuZCBleGVjdXRlZCBvbmUgcGVyIGZyYW1lLlxuICAgICAqIERpc2FibGluZyBpcyBzdWdnZXN0ZWQgYW55d2F5IGFuZCBtYW5hZ2luZyB0aGUgcmVuZGVycyBvZiB0aGUgYXBwIG1hbnVhbGx5IGlzIG5vdCBhIGJpZyBlZmZvcnQgKCBjYW52YXMucmVxdWVzdFJlbmRlckFsbCgpIClcbiAgICAgKiBMZWZ0IGRlZmF1bHQgdG8gdHJ1ZSB0byBkbyBub3QgYnJlYWsgZG9jdW1lbnRhdGlvbiBhbmQgb2xkIGFwcCwgZmlkZGxlcy5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByZW5kZXJPbkFkZFJlbW92ZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9iamVjdCBjb250cm9scyAoYm9yZGVycy9jb250cm9scykgYXJlIHJlbmRlcmVkIGFib3ZlIG92ZXJsYXkgaW1hZ2VcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb250cm9sc0Fib3ZlT3ZlcmxheTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYnJvd3NlciBjYW4gYmUgc2Nyb2xsZWQgd2hlbiB1c2luZyBhIHRvdWNoc2NyZWVuIGFuZCBkcmFnZ2luZyBvbiB0aGUgY2FudmFzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWxsb3dUb3VjaFNjcm9sbGluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGNhbnZhcyB3aWxsIHVzZSBpbWFnZSBzbW9vdGhpbmcsIHRoaXMgaXMgb24gYnkgZGVmYXVsdCBpbiBicm93c2Vyc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGltYWdlU21vb3RoaW5nRW5hYmxlZDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2Zvcm1hdGlvbiAoYSBDYW52YXMgMkQgQVBJIHRyYW5zZm9ybSBtYXRyaXgpIHdoaWNoIGZvY3VzZXMgdGhlIHZpZXdwb3J0XG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWZhdWx0IHRyYW5zZm9ybTwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMudmlld3BvcnRUcmFuc2Zvcm0gPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U2NhbGUgYnkgNzAlIGFuZCB0cmFuc2xhdGUgdG93YXJkIGJvdHRvbS1yaWdodCBieSA1MCwgd2l0aG91dCBza2V3aW5nPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSA9IFswLjcsIDAsIDAsIDAuNywgNTAsIDUwXTtcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHZpZXdwb3J0VHJhbnNmb3JtOiBmYWJyaWMuaU1hdHJpeC5jb25jYXQoKSxcblxuICAgIC8qKlxuICAgICAqIGlmIHNldCB0byBmYWxzZSBiYWNrZ3JvdW5kIGltYWdlIGlzIG5vdCBhZmZlY3RlZCBieSB2aWV3cG9ydCB0cmFuc2Zvcm1cbiAgICAgKiBAc2luY2UgMS42LjNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kVnB0OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogaWYgc2V0IHRvIGZhbHNlIG92ZXJseWEgaW1hZ2UgaXMgbm90IGFmZmVjdGVkIGJ5IHZpZXdwb3J0IHRyYW5zZm9ybVxuICAgICAqIEBzaW5jZSAxLjYuM1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsYXlWcHQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGNhbnZhcyBpcyBzY2FsZWQgYnkgZGV2aWNlUGl4ZWxSYXRpbyBmb3IgYmV0dGVyIHJlbmRlcmluZyBvbiByZXRpbmEgc2NyZWVuc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGVuYWJsZVJldGluYVNjYWxpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBjYW52YXMgZWxlbWVudCBleHRlbnNpb24gb3ZlciBkZXNpZ25cbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSB0bCx0cixibCxici5cbiAgICAgKiBpZiBjYW52YXMgaXMgbm90IHpvb21lZC9wYW5uZWQgdGhvc2UgcG9pbnRzIGFyZSB0aGUgZm91ciBjb3JuZXIgb2YgY2FudmFzXG4gICAgICogaWYgY2FudmFzIGlzIHZpZXdwb3J0VHJhbnNmb3JtZWQgeW91IHRob3NlIHBvaW50cyBpbmRpY2F0ZSB0aGUgZXh0ZW5zaW9uXG4gICAgICogb2YgY2FudmFzIGVsZW1lbnQgaW4gcGxhaW4gdW50cmFzZm9ybWVkIGNvb3JkaW5hdGVzXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGdldCB1cGRhdGVkIHdpdGggQG1ldGhvZCBjYWxjVmlld3BvcnRCb3VuZGFyaWVzLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHZwdENvb3JkczogeyB9LFxuXG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gdnB0Q29vcmRzIGFuZCBvYmplY3QuYUNvb3Jkcywgc2tpcCByZW5kZXJpbmcgb2Ygb2JqZWN0cyB0aGF0XG4gICAgICogYXJlIG5vdCBpbmNsdWRlZCBpbiBjdXJyZW50IHZpZXdwb3J0LlxuICAgICAqIE1heSBncmVhdGx5IGhlbHAgaW4gYXBwbGljYXRpb25zIHdpdGggY3Jvd2RlZCBjYW52YXMgYW5kIHVzZSBvZiB6b29tL3BhblxuICAgICAqIElmIE9uZSBvZiB0aGUgY29ybmVyIG9mIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIG9iamVjdCBpcyBvbiB0aGUgY2FudmFzXG4gICAgICogdGhlIG9iamVjdHMgZ2V0IHJlbmRlcmVkLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNraXBPZmZzY3JlZW46IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBhIGZhYnJpY09iamVjdCB0aGF0LCB3aXRob3V0IHN0cm9rZSBkZWZpbmUgYSBjbGlwcGluZyBhcmVhIHdpdGggdGhlaXIgc2hhcGUuIGZpbGxlZCBpbiBibGFja1xuICAgICAqIHRoZSBjbGlwUGF0aCBvYmplY3QgZ2V0cyB1c2VkIHdoZW4gdGhlIGNhbnZhcyBoYXMgcmVuZGVyZWQsIGFuZCB0aGUgY29udGV4dCBpcyBwbGFjZWQgaW4gdGhlXG4gICAgICogdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXMuXG4gICAgICogY2xpcFBhdGggd2lsbCBjbGlwIGF3YXkgY29udHJvbHMsIGlmIHlvdSBkbyBub3Qgd2FudCB0aGlzIHRvIGhhcHBlbiB1c2UgY29udHJvbHNBYm92ZU92ZXJsYXkgPSB0cnVlXG4gICAgICogQHR5cGUgZmFicmljLk9iamVjdFxuICAgICAqL1xuICAgIGNsaXBQYXRoOiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTdHJpbmd9IGVsICZsdDtjYW52YXM+IGVsZW1lbnQgdG8gaW5pdGlhbGl6ZSBpbnN0YW5jZSBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdFN0YXRpYzogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYiA9IHRoaXMucmVxdWVzdFJlbmRlckFsbEJvdW5kO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgdGhpcy5fY3JlYXRlTG93ZXJDYW52YXMoZWwpO1xuICAgICAgdGhpcy5faW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAvLyBvbmx5IGluaXRpYWxpemUgcmV0aW5hIHNjYWxpbmcgb25jZVxuICAgICAgaWYgKCF0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2luaXRSZXRpbmFTY2FsaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm92ZXJsYXlJbWFnZSkge1xuICAgICAgICB0aGlzLnNldE92ZXJsYXlJbWFnZShvcHRpb25zLm92ZXJsYXlJbWFnZSwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZEltYWdlKSB7XG4gICAgICAgIHRoaXMuc2V0QmFja2dyb3VuZEltYWdlKG9wdGlvbnMuYmFja2dyb3VuZEltYWdlLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm92ZXJsYXlDb2xvcikge1xuICAgICAgICB0aGlzLnNldE92ZXJsYXlDb2xvcihvcHRpb25zLm92ZXJsYXlDb2xvciwgY2IpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzUmV0aW5hU2NhbGluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvID4gMSAmJiB0aGlzLmVuYWJsZVJldGluYVNjYWxpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gcmV0aW5hU2NhbGluZyBpZiBhcHBsaWVkLCBvdGhlcndpc2UgMTtcbiAgICAgKi9cbiAgICBnZXRSZXRpbmFTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1JldGluYVNjYWxpbmcoKSA/IE1hdGgubWF4KDEsIGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvKSA6IDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRSZXRpbmFTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5faXNSZXRpbmFTY2FsaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNjYWxlUmF0aW8gPSBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIHRoaXMuX19pbml0UmV0aW5hU2NhbGluZyhzY2FsZVJhdGlvLCB0aGlzLmxvd2VyQ2FudmFzRWwsIHRoaXMuY29udGV4dENvbnRhaW5lcik7XG4gICAgICBpZiAodGhpcy51cHBlckNhbnZhc0VsKSB7XG4gICAgICAgIHRoaXMuX19pbml0UmV0aW5hU2NhbGluZyhzY2FsZVJhdGlvLCB0aGlzLnVwcGVyQ2FudmFzRWwsIHRoaXMuY29udGV4dFRvcCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9faW5pdFJldGluYVNjYWxpbmc6IGZ1bmN0aW9uKHNjYWxlUmF0aW8sIGNhbnZhcywgY29udGV4dCkge1xuICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLndpZHRoICogc2NhbGVSYXRpbyk7XG4gICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmhlaWdodCAqIHNjYWxlUmF0aW8pO1xuICAgICAgY29udGV4dC5zY2FsZShzY2FsZVJhdGlvLCBzY2FsZVJhdGlvKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGNhbnZhcyBlbGVtZW50IG9mZnNldCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnRcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhbHNvIGF0dGFjaGVkIGFzIFwicmVzaXplXCIgZXZlbnQgaGFuZGxlciBvZiB3aW5kb3dcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjYWxjT2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9vZmZzZXQgPSBnZXRFbGVtZW50T2Zmc2V0KHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5SW1hZ2V8b3ZlcmxheSBpbWFnZX0gZm9yIHRoaXMgY2FudmFzXG4gICAgICogQHBhcmFtIHsoZmFicmljLkltYWdlfFN0cmluZyl9IGltYWdlIGZhYnJpYy5JbWFnZSBpbnN0YW5jZSBvciBVUkwgb2YgYW4gaW1hZ2UgdG8gc2V0IG92ZXJsYXkgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayB0byBpbnZva2Ugd2hlbiBpbWFnZSBpcyBsb2FkZWQgYW5kIHNldCBhcyBhbiBvdmVybGF5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBvcHRpb25zIHRvIHNldCBmb3IgdGhlIHtAbGluayBmYWJyaWMuSW1hZ2V8b3ZlcmxheSBpbWFnZX0uXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL01uekhUL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBvdmVybGF5SW1hZ2Ugd2l0aCBsZWZ0L3RvcCA9IDA8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBvdmVybGF5SW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPm92ZXJsYXlJbWFnZSB3aXRoIGRpZmZlcmVudCBwcm9wZXJ0aWVzPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5SW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2phaWxfY2VsbF9iYXJzLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3RyZXRjaGVkIG92ZXJsYXlJbWFnZSAjMSAtIHdpZHRoL2hlaWdodCBjb3JyZXNwb25kIHRvIGNhbnZhcyB3aWR0aC9oZWlnaHQ8L2NhcHRpb24+XG4gICAgICogZmFicmljLkltYWdlLmZyb21VUkwoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2phaWxfY2VsbF9iYXJzLnBuZycsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAqICAgIGltZy5zZXQoe3dpZHRoOiBjYW52YXMud2lkdGgsIGhlaWdodDogY2FudmFzLmhlaWdodCwgb3JpZ2luWDogJ2xlZnQnLCBvcmlnaW5ZOiAndG9wJ30pO1xuICAgICAqICAgIGNhbnZhcy5zZXRPdmVybGF5SW1hZ2UoaW1nLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3RyZXRjaGVkIG92ZXJsYXlJbWFnZSAjMiAtIHdpZHRoL2hlaWdodCBjb3JyZXNwb25kIHRvIGNhbnZhcyB3aWR0aC9oZWlnaHQ8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICogICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICogICAvLyBOZWVkZWQgdG8gcG9zaXRpb24gb3ZlcmxheUltYWdlIGF0IDAvMFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5vdmVybGF5SW1hZ2UgbG9hZGVkIGZyb20gY3Jvc3Mtb3JpZ2luPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5SW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2phaWxfY2VsbF9iYXJzLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnLFxuICAgICAqICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgc2V0T3ZlcmxheUltYWdlOiBmdW5jdGlvbiAoaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NldEJnT3ZlcmxheUltYWdlKCdvdmVybGF5SW1hZ2UnLCBpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2JhY2tncm91bmRJbWFnZXxiYWNrZ3JvdW5kIGltYWdlfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nKX0gaW1hZ2UgZmFicmljLkltYWdlIGluc3RhbmNlIG9yIFVSTCBvZiBhbiBpbWFnZSB0byBzZXQgYmFja2dyb3VuZCB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGxvYWRlZCBhbmQgc2V0IGFzIGJhY2tncm91bmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxiYWNrZ3JvdW5kIGltYWdlfS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZGpucjhvN2EvMjgvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIGJhY2tncm91bmRJbWFnZSB3aXRoIGxlZnQvdG9wID0gMDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9ob25leV9pbV9zdWJ0bGUucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBiYWNrZ3JvdW5kSW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmJhY2tncm91bmRJbWFnZSB3aXRoIGRpZmZlcmVudCBwcm9wZXJ0aWVzPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgb3BhY2l0eTogMC41LFxuICAgICAqICAgYW5nbGU6IDQ1LFxuICAgICAqICAgbGVmdDogNDAwLFxuICAgICAqICAgdG9wOiA0MDAsXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN0cmV0Y2hlZCBiYWNrZ3JvdW5kSW1hZ2UgIzEgLSB3aWR0aC9oZWlnaHQgY29ycmVzcG9uZCB0byBjYW52YXMgd2lkdGgvaGVpZ2h0PC9jYXB0aW9uPlxuICAgICAqIGZhYnJpYy5JbWFnZS5mcm9tVVJMKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9ob25leV9pbV9zdWJ0bGUucG5nJywgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICogICAgaW1nLnNldCh7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LCBvcmlnaW5YOiAnbGVmdCcsIG9yaWdpblk6ICd0b3AnfSk7XG4gICAgICogICAgY2FudmFzLnNldEJhY2tncm91bmRJbWFnZShpbWcsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgYmFja2dyb3VuZEltYWdlICMyIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9ob25leV9pbV9zdWJ0bGUucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICogICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICogICAvLyBOZWVkZWQgdG8gcG9zaXRpb24gYmFja2dyb3VuZEltYWdlIGF0IDAvMFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5iYWNrZ3JvdW5kSW1hZ2UgbG9hZGVkIGZyb20gY3Jvc3Mtb3JpZ2luPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgb3BhY2l0eTogMC41LFxuICAgICAqICAgYW5nbGU6IDQ1LFxuICAgICAqICAgbGVmdDogNDAwLFxuICAgICAqICAgdG9wOiA0MDAsXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJyxcbiAgICAgKiAgIGNyb3NzT3JpZ2luOiAnYW5vbnltb3VzJ1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIC8vIFRPRE86IGZpeCBzdHJldGNoZWQgZXhhbXBsZXNcbiAgICBzZXRCYWNrZ3JvdW5kSW1hZ2U6IGZ1bmN0aW9uIChpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5SW1hZ2UoJ2JhY2tncm91bmRJbWFnZScsIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjb3ZlcmxheUNvbG9yfGZvcmVncm91bmQgY29sb3J9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9IG92ZXJsYXlDb2xvciBDb2xvciBvciBwYXR0ZXJuIHRvIHNldCBmb3JlZ3JvdW5kIGNvbG9yIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gZm9yZWdyb3VuZCBjb2xvciBpcyBzZXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvcEI1NWgvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIG92ZXJsYXlDb2xvciAtIGNvbG9yIHZhbHVlPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5Q29sb3IoJ3JnYmEoMjU1LCA3MywgNjQsIDAuNiknLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBvdmVybGF5Q29sb3I8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJ1xuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIG92ZXJsYXlDb2xvciB3aXRoIHJlcGVhdCBhbmQgb2Zmc2V0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5Q29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZycsXG4gICAgICogICByZXBlYXQ6ICdyZXBlYXQnLFxuICAgICAqICAgb2Zmc2V0WDogMjAwLFxuICAgICAqICAgb2Zmc2V0WTogMTAwXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqL1xuICAgIHNldE92ZXJsYXlDb2xvcjogZnVuY3Rpb24ob3ZlcmxheUNvbG9yLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZXRCZ092ZXJsYXlDb2xvcignb3ZlcmxheUNvbG9yJywgb3ZlcmxheUNvbG9yLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZENvbG9yfGJhY2tncm91bmQgY29sb3J9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9IGJhY2tncm91bmRDb2xvciBDb2xvciBvciBwYXR0ZXJuIHRvIHNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYmFja2dyb3VuZCBjb2xvciBpcyBzZXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvaFh6dmsvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIGJhY2tncm91bmRDb2xvciAtIGNvbG9yIHZhbHVlPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kQ29sb3IoJ3JnYmEoMjU1LCA3MywgNjQsIDAuNiknLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBiYWNrZ3JvdW5kQ29sb3I8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJ1xuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIGJhY2tncm91bmRDb2xvciB3aXRoIHJlcGVhdCBhbmQgb2Zmc2V0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kQ29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZycsXG4gICAgICogICByZXBlYXQ6ICdyZXBlYXQnLFxuICAgICAqICAgb2Zmc2V0WDogMjAwLFxuICAgICAqICAgb2Zmc2V0WTogMTAwXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqL1xuICAgIHNldEJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24oYmFja2dyb3VuZENvbG9yLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZXRCZ092ZXJsYXlDb2xvcignYmFja2dyb3VuZENvbG9yJywgYmFja2dyb3VuZENvbG9yLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHNldCAoe0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZEltYWdlfGJhY2tncm91bmRJbWFnZX1cbiAgICAgKiBvciB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5SW1hZ2V8b3ZlcmxheUltYWdlfSlcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nfG51bGwpfSBpbWFnZSBmYWJyaWMuSW1hZ2UgaW5zdGFuY2UsIFVSTCBvZiBhbiBpbWFnZSBvciBudWxsIHRvIHNldCBiYWNrZ3JvdW5kIG9yIG92ZXJsYXkgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBpbWFnZSBpcyBsb2FkZWQgYW5kIHNldCBhcyBiYWNrZ3JvdW5kIG9yIG92ZXJsYXkuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgY3JlYXRlZCBpbWFnZSwgdGhlIHNlY29uZCBhcmd1bWVudCBpcyBhIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIGFuIGVycm9yIG9jY3VycmVkIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxpbWFnZX0uXG4gICAgICovXG4gICAgX19zZXRCZ092ZXJsYXlJbWFnZTogZnVuY3Rpb24ocHJvcGVydHksIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKGltYWdlLCBmdW5jdGlvbihpbWcsIGlzRXJyb3IpIHtcbiAgICAgICAgICBpZiAoaW1nKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgZmFicmljLkltYWdlKGltZywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgaW5zdGFuY2UuY2FudmFzID0gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW1nLCBpc0Vycm9yKTtcbiAgICAgICAgfSwgdGhpcywgb3B0aW9ucyAmJiBvcHRpb25zLmNyb3NzT3JpZ2luKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvcHRpb25zICYmIGltYWdlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gaW1hZ2U7XG4gICAgICAgIGltYWdlICYmIChpbWFnZS5jYW52YXMgPSB0aGlzKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW1hZ2UsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHNldCAoe0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZENvbG9yfGJhY2tncm91bmRDb2xvcn1cbiAgICAgKiBvciB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5Q29sb3J8b3ZlcmxheUNvbG9yfSlcbiAgICAgKiBAcGFyYW0geyhPYmplY3R8U3RyaW5nfG51bGwpfSBjb2xvciBPYmplY3Qgd2l0aCBwYXR0ZXJuIGluZm9ybWF0aW9uLCBjb2xvciB2YWx1ZSBvciBudWxsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayBpcyBpbnZva2VkIHdoZW4gY29sb3IgaXMgc2V0XG4gICAgICovXG4gICAgX19zZXRCZ092ZXJsYXlDb2xvcjogZnVuY3Rpb24ocHJvcGVydHksIGNvbG9yLCBjYWxsYmFjaykge1xuICAgICAgdGhpc1twcm9wZXJ0eV0gPSBjb2xvcjtcbiAgICAgIHRoaXMuX2luaXRHcmFkaWVudChjb2xvciwgcHJvcGVydHkpO1xuICAgICAgdGhpcy5faW5pdFBhdHRlcm4oY29sb3IsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQ2FudmFzRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICB0aHJvdyBDQU5WQVNfSU5JVF9FUlJPUjtcbiAgICAgIH1cbiAgICAgIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlID0geyB9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50LmdldENvbnRleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IENBTlZBU19JTklUX0VSUk9SO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9pbml0T3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBsb3dlckNhbnZhc0VsID0gdGhpcy5sb3dlckNhbnZhc0VsO1xuICAgICAgdGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMud2lkdGggfHwgcGFyc2VJbnQobG93ZXJDYW52YXNFbC53aWR0aCwgMTApIHx8IDA7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuaGVpZ2h0IHx8IHBhcnNlSW50KGxvd2VyQ2FudmFzRWwuaGVpZ2h0LCAxMCkgfHwgMDtcblxuICAgICAgaWYgKCF0aGlzLmxvd2VyQ2FudmFzRWwuc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsb3dlckNhbnZhc0VsLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgIGxvd2VyQ2FudmFzRWwuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgIGxvd2VyQ2FudmFzRWwuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgJ3B4JztcbiAgICAgIGxvd2VyQ2FudmFzRWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyAncHgnO1xuXG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYm90dG9tIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2NhbnZhc0VsXVxuICAgICAqL1xuICAgIF9jcmVhdGVMb3dlckNhbnZhczogZnVuY3Rpb24gKGNhbnZhc0VsKSB7XG4gICAgICAvLyBjYW52YXNFbCA9PT0gJ0hUTUxDYW52YXNFbGVtZW50JyBkb2VzIG5vdCB3b3JrIG9uIGpzZG9tL25vZGVcbiAgICAgIGlmIChjYW52YXNFbCAmJiBjYW52YXNFbC5nZXRDb250ZXh0KSB7XG4gICAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IGNhbnZhc0VsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMubG93ZXJDYW52YXNFbCA9IGZhYnJpYy51dGlsLmdldEJ5SWQoY2FudmFzRWwpIHx8IHRoaXMuX2NyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIH1cblxuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy5sb3dlckNhbnZhc0VsLCAnbG93ZXItY2FudmFzJyk7XG4gICAgICB0aGlzLl9vcmlnaW5hbENhbnZhc1N0eWxlID0gdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlO1xuICAgICAgaWYgKHRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlDYW52YXNTdHlsZSh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHRDb250YWluZXIgPSB0aGlzLmxvd2VyQ2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjYW52YXMgd2lkdGggKGluIHB4KVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2FudmFzIGhlaWdodCAoaW4gcHgpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdpZHRoIG9mIHRoaXMgY2FudmFzIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZSB0byBzZXQgd2lkdGggdG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5iYWNrc3RvcmVPbmx5PWZhbHNlXSBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjYW52YXMgYmFja3N0b3JlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmNzc09ubHk9ZmFsc2VdICAgICAgIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNzcyBkaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRXaWR0aDogZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXREaW1lbnNpb25zKHsgd2lkdGg6IHZhbHVlIH0sIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGhlaWdodCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUgICAgICAgICAgICAgICAgICAgICAgICAgVmFsdWUgdG8gc2V0IGhlaWdodCB0b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgW29wdGlvbnNdICAgICAgICAgICAgICAgICAgICAgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmJhY2tzdG9yZU9ubHk9ZmFsc2VdIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNhbnZhcyBiYWNrc3RvcmUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuY3NzT25seT1mYWxzZV0gICAgICAgU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY3NzIGRpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHNldEhlaWdodDogZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXREaW1lbnNpb25zKHsgaGVpZ2h0OiB2YWx1ZSB9LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBkaW1lbnNpb25zICh3aWR0aCwgaGVpZ2h0KSBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZS4gd2hlbiBvcHRpb25zLmNzc09ubHkgZmxhZyBhY3RpdmUgeW91IHNob3VsZCBhbHNvIHN1cHBseSB0aGUgdW5pdCBvZiBtZWFzdXJlIChweC8lL2VtKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgZGltZW5zaW9ucyAgICAgICAgICAgICAgICAgICAgT2JqZWN0IHdpdGggd2lkdGgvaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtkaW1lbnNpb25zLndpZHRoXSAgICAgICAgICAgIFdpZHRoIG9mIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbZGltZW5zaW9ucy5oZWlnaHRdICAgICAgICAgICBIZWlnaHQgb2YgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5iYWNrc3RvcmVPbmx5PWZhbHNlXSBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjYW52YXMgYmFja3N0b3JlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmNzc09ubHk9ZmFsc2VdICAgICAgIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNzcyBkaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXREaW1lbnNpb25zOiBmdW5jdGlvbiAoZGltZW5zaW9ucywgb3B0aW9ucykge1xuICAgICAgdmFyIGNzc1ZhbHVlO1xuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBkaW1lbnNpb25zKSB7XG4gICAgICAgIGNzc1ZhbHVlID0gZGltZW5zaW9uc1twcm9wXTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuY3NzT25seSkge1xuICAgICAgICAgIHRoaXMuX3NldEJhY2tzdG9yZURpbWVuc2lvbihwcm9wLCBkaW1lbnNpb25zW3Byb3BdKTtcbiAgICAgICAgICBjc3NWYWx1ZSArPSAncHgnO1xuICAgICAgICAgIHRoaXMuaGFzTG9zdENvbnRleHQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmJhY2tzdG9yZU9ubHkpIHtcbiAgICAgICAgICB0aGlzLl9zZXRDc3NEaW1lbnNpb24ocHJvcCwgY3NzVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaCAmJiB0aGlzLmZyZWVEcmF3aW5nQnJ1c2guX3NldEJydXNoU3R5bGVzKHRoaXMuY29udGV4dFRvcCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbml0UmV0aW5hU2NhbGluZygpO1xuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG5cbiAgICAgIGlmICghb3B0aW9ucy5jc3NPbmx5KSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZvciBzZXR0aW5nIHdpZHRoL2hlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgcHJvcGVydHkgKHdpZHRofGhlaWdodClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdmFsdWUgdG8gc2V0IHByb3BlcnR5IHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBfc2V0QmFja3N0b3JlRGltZW5zaW9uOiBmdW5jdGlvbiAocHJvcCwgdmFsdWUpIHtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbFtwcm9wXSA9IHZhbHVlO1xuXG4gICAgICBpZiAodGhpcy51cHBlckNhbnZhc0VsKSB7XG4gICAgICAgIHRoaXMudXBwZXJDYW52YXNFbFtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jYWNoZUNhbnZhc0VsKSB7XG4gICAgICAgIHRoaXMuY2FjaGVDYW52YXNFbFtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzW3Byb3BdID0gdmFsdWU7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZm9yIHNldHRpbmcgY3NzIHdpZHRoL2hlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgcHJvcGVydHkgKHdpZHRofGhlaWdodClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgdmFsdWUgdG8gc2V0IHByb3BlcnR5IHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBfc2V0Q3NzRGltZW5zaW9uOiBmdW5jdGlvbiAocHJvcCwgdmFsdWUpIHtcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuXG4gICAgICBpZiAodGhpcy51cHBlckNhbnZhc0VsKSB7XG4gICAgICAgIHRoaXMudXBwZXJDYW52YXNFbC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy53cmFwcGVyRWwpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyRWwuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2FudmFzIHpvb20gbGV2ZWxcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Wm9vbTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnRUcmFuc2Zvcm1bMF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdmlld3BvcnQgdHJhbnNmb3JtYXRpb24gb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2cHQgYSBDYW52YXMgMkQgQVBJIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHNldFZpZXdwb3J0VHJhbnNmb3JtOiBmdW5jdGlvbiAodnB0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGJhY2tncm91bmRPYmplY3QgPSB0aGlzLmJhY2tncm91bmRJbWFnZSxcbiAgICAgICAgICBvdmVybGF5T2JqZWN0ID0gdGhpcy5vdmVybGF5SW1hZ2UsXG4gICAgICAgICAgb2JqZWN0LCBpLCBsZW47XG4gICAgICB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtID0gdnB0O1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuICAgICAgICBvYmplY3QuZ3JvdXAgfHwgb2JqZWN0LnNldENvb3Jkcyh0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChhY3RpdmVPYmplY3QpIHtcbiAgICAgICAgYWN0aXZlT2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgaWYgKGJhY2tncm91bmRPYmplY3QpIHtcbiAgICAgICAgYmFja2dyb3VuZE9iamVjdC5zZXRDb29yZHModHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcmxheU9iamVjdCkge1xuICAgICAgICBvdmVybGF5T2JqZWN0LnNldENvb3Jkcyh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsY1ZpZXdwb3J0Qm91bmRhcmllcygpO1xuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHpvb20gbGV2ZWwgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2UsIHRoZSB6b29tIGNlbnRlcmVkIGFyb3VuZCBwb2ludFxuICAgICAqIG1lYW5pbmcgdGhhdCBmb2xsb3dpbmcgem9vbSB0byBwb2ludCB3aXRoIHRoZSBzYW1lIHBvaW50IHdpbGwgaGF2ZSB0aGUgdmlzdWFsXG4gICAgICogZWZmZWN0IG9mIHRoZSB6b29tIG9yaWdpbmF0aW5nIGZyb20gdGhhdCBwb2ludC4gVGhlIHBvaW50IHdvbid0IG1vdmUuXG4gICAgICogSXQgaGFzIG5vdGhpbmcgdG8gZG8gd2l0aCBjYW52YXMgY2VudGVyIG9yIHZpc3VhbCBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0LlxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCB0byB6b29tIHdpdGggcmVzcGVjdCB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB0byBzZXQgem9vbSB0bywgbGVzcyB0aGFuIDEgem9vbXMgb3V0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICB6b29tVG9Qb2ludDogZnVuY3Rpb24gKHBvaW50LCB2YWx1ZSkge1xuICAgICAgLy8gVE9ETzoganVzdCBjaGFuZ2UgdGhlIHNjYWxlLCBwcmVzZXJ2ZSBvdGhlciB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgIHZhciBiZWZvcmUgPSBwb2ludCwgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgwKTtcbiAgICAgIHBvaW50ID0gdHJhbnNmb3JtUG9pbnQocG9pbnQsIGludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKSk7XG4gICAgICB2cHRbMF0gPSB2YWx1ZTtcbiAgICAgIHZwdFszXSA9IHZhbHVlO1xuICAgICAgdmFyIGFmdGVyID0gdHJhbnNmb3JtUG9pbnQocG9pbnQsIHZwdCk7XG4gICAgICB2cHRbNF0gKz0gYmVmb3JlLnggLSBhZnRlci54O1xuICAgICAgdnB0WzVdICs9IGJlZm9yZS55IC0gYWZ0ZXIueTtcbiAgICAgIHJldHVybiB0aGlzLnNldFZpZXdwb3J0VHJhbnNmb3JtKHZwdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgem9vbSBsZXZlbCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB0byBzZXQgem9vbSB0bywgbGVzcyB0aGFuIDEgem9vbXMgb3V0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRab29tOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXMuem9vbVRvUG9pbnQobmV3IGZhYnJpYy5Qb2ludCgwLCAwKSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhbiB2aWV3cG9ydCBzbyBhcyB0byBwbGFjZSBwb2ludCBhdCB0b3AgbGVmdCBjb3JuZXIgb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IHRvIG1vdmUgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIGFic29sdXRlUGFuOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHZhciB2cHQgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLnNsaWNlKDApO1xuICAgICAgdnB0WzRdID0gLXBvaW50Lng7XG4gICAgICB2cHRbNV0gPSAtcG9pbnQueTtcbiAgICAgIHJldHVybiB0aGlzLnNldFZpZXdwb3J0VHJhbnNmb3JtKHZwdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhbnMgdmlld3BvaW50IHJlbGF0aXZlbHlcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgKHBvc2l0aW9uIHZlY3RvcikgdG8gbW92ZSBieVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgcmVsYXRpdmVQYW46IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzb2x1dGVQYW4obmV3IGZhYnJpYy5Qb2ludChcbiAgICAgICAgLXBvaW50LnggLSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtWzRdLFxuICAgICAgICAtcG9pbnQueSAtIHRoaXMudmlld3BvcnRUcmFuc2Zvcm1bNV1cbiAgICAgICkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zICZsdDtjYW52YXM+IGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byB0aGlzIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0RWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubG93ZXJDYW52YXNFbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBPYmplY3QgdGhhdCB3YXMgYWRkZWRcbiAgICAgKi9cbiAgICBfb25PYmplY3RBZGRlZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICB0aGlzLnN0YXRlZnVsICYmIG9iai5zZXR1cFN0YXRlKCk7XG4gICAgICBvYmouX3NldCgnY2FudmFzJywgdGhpcyk7XG4gICAgICBvYmouc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLmZpcmUoJ29iamVjdDphZGRlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICBvYmouZmlyZSgnYWRkZWQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBPYmplY3QgdGhhdCB3YXMgcmVtb3ZlZFxuICAgICAqL1xuICAgIF9vbk9iamVjdFJlbW92ZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdGhpcy5maXJlKCdvYmplY3Q6cmVtb3ZlZCcsIHsgdGFyZ2V0OiBvYmogfSk7XG4gICAgICBvYmouZmlyZSgncmVtb3ZlZCcpO1xuICAgICAgZGVsZXRlIG9iai5jYW52YXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBzcGVjaWZpZWQgY29udGV4dCBvZiBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBjbGVhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2xlYXJDb250ZXh0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udGV4dCBvZiBjYW52YXMgd2hlcmUgb2JqZWN0cyBhcmUgZHJhd25cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgZ2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dENvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjb250ZXh0cyAoYmFja2dyb3VuZCwgbWFpbiwgdG9wKSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucmVtb3ZlLmFwcGx5KHRoaXMsIHRoaXMuZ2V0T2JqZWN0cygpKTtcbiAgICAgIHRoaXMuYmFja2dyb3VuZEltYWdlID0gbnVsbDtcbiAgICAgIHRoaXMub3ZlcmxheUltYWdlID0gbnVsbDtcbiAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gJyc7XG4gICAgICB0aGlzLm92ZXJsYXlDb2xvciA9ICcnO1xuICAgICAgaWYgKHRoaXMuX2hhc0lUZXh0SGFuZGxlcnMpIHtcbiAgICAgICAgdGhpcy5vZmYoJ21vdXNlOnVwJywgdGhpcy5fbW91c2VVcElUZXh0SGFuZGxlcik7XG4gICAgICAgIHRoaXMuX2lUZXh0SW5zdGFuY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5faGFzSVRleHRIYW5kbGVycyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVhckNvbnRleHQodGhpcy5jb250ZXh0Q29udGFpbmVyKTtcbiAgICAgIHRoaXMuZmlyZSgnY2FudmFzOmNsZWFyZWQnKTtcbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY2FudmFzXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2FudmFzVG9EcmF3T24gPSB0aGlzLmNvbnRleHRDb250YWluZXI7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyhjYW52YXNUb0RyYXdPbiwgdGhpcy5fb2JqZWN0cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gY3JlYXRlZCB0byBiZSBpbnN0YW5jZSBib3VuZCBhdCBpbml0aWFsaXphdGlvblxuICAgICAqIHVzZWQgaW4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHJlbmRlcmluZ1xuICAgICAqIExldCB0aGUgZmFicmljSlMgY2FsbCBpdC4gSWYgeW91IGNhbGwgaXQgbWFudWFsbHkgeW91IGNvdWxkIGhhdmUgbW9yZVxuICAgICAqIGFuaW1hdGlvbkZyYW1lIHN0YWNraW5nIG9uIHRvIG9mIGVhY2ggb3RoZXJcbiAgICAgKiBmb3IgYW4gaW1wZXJhdGl2ZSByZW5kZXJpbmcsIHVzZSBjYW52YXMucmVuZGVyQWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJBbmRSZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzUmVuZGVyaW5nID0gMDtcbiAgICAgIHRoaXMucmVuZGVyQWxsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBhIHJlbmRlckFsbCByZXF1ZXN0IHRvIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxuICAgICAqIHVubGVzcyBvbmUgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgaW4gdGhhdCBjYXNlIG5vdGhpbmcgaXMgZG9uZVxuICAgICAqIGEgYm9vbGVhbiBmbGFnIHdpbGwgYXZvaWQgYXBwZW5kaW5nIG1vcmUuXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVxdWVzdFJlbmRlckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSBmYWJyaWMudXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMucmVuZGVyQW5kUmVzZXRCb3VuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgNCBjb3JuZXIgb2YgY2FudmFzIHdpdGggY3VycmVudCB2aWV3cG9ydFRyYW5zZm9ybS5cbiAgICAgKiBoZWxwcyB0byBkZXRlcm1pbmF0ZSB3aGVuIGFuIG9iamVjdCBpcyBpbiB0aGUgY3VycmVudCByZW5kZXJpbmcgdmlld3BvcnQgdXNpbmdcbiAgICAgKiBvYmplY3QgYWJzb2x1dGUgY29vcmRpbmF0ZXMgKCBhQ29vcmRzIClcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHBvaW50cy50bFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjYWxjVmlld3BvcnRCb3VuZGFyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb2ludHMgPSB7IH0sIHdpZHRoID0gdGhpcy53aWR0aCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQsXG4gICAgICAgICAgaVZwdCA9IGludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKTtcbiAgICAgIHBvaW50cy50bCA9IHRyYW5zZm9ybVBvaW50KHsgeDogMCwgeTogMCB9LCBpVnB0KTtcbiAgICAgIHBvaW50cy5iciA9IHRyYW5zZm9ybVBvaW50KHsgeDogd2lkdGgsIHk6IGhlaWdodCB9LCBpVnB0KTtcbiAgICAgIHBvaW50cy50ciA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzLmJyLngsIHBvaW50cy50bC55KTtcbiAgICAgIHBvaW50cy5ibCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzLnRsLngsIHBvaW50cy5ici55KTtcbiAgICAgIHRoaXMudnB0Q29vcmRzID0gcG9pbnRzO1xuICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9LFxuXG4gICAgY2FuY2VsUmVxdWVzdGVkUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLmlzUmVuZGVyaW5nKTtcbiAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYmFja2dyb3VuZCwgb2JqZWN0cywgb3ZlcmxheSBhbmQgY29udHJvbHMuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgdG8gcmVuZGVyXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyQ2FudmFzOiBmdW5jdGlvbihjdHgsIG9iamVjdHMpIHtcbiAgICAgIHZhciB2ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSwgcGF0aCA9IHRoaXMuY2xpcFBhdGg7XG4gICAgICB0aGlzLmNhbmNlbFJlcXVlc3RlZFJlbmRlcigpO1xuICAgICAgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dChjdHgpO1xuICAgICAgZmFicmljLnV0aWwuc2V0SW1hZ2VTbW9vdGhpbmcoY3R4LCB0aGlzLmltYWdlU21vb3RoaW5nRW5hYmxlZCk7XG4gICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpyZW5kZXInLCB7IGN0eDogY3R4LCB9KTtcbiAgICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQoY3R4KTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIC8vYXBwbHkgdmlld3BvcnQgdHJhbnNmb3JtIG9uY2UgZm9yIGFsbCByZW5kZXJpbmcgcHJvY2Vzc1xuICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgIHRoaXMuX3JlbmRlck9iamVjdHMoY3R4LCBvYmplY3RzKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBpZiAoIXRoaXMuY29udHJvbHNBYm92ZU92ZXJsYXkgJiYgdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmRyYXdDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgcGF0aC5jYW52YXMgPSB0aGlzO1xuICAgICAgICAvLyBuZWVkZWQgdG8gc2V0dXAgYSBjb3VwbGUgb2YgdmFyaWFibGVzXG4gICAgICAgIHBhdGguc2hvdWxkQ2FjaGUoKTtcbiAgICAgICAgcGF0aC5fdHJhbnNmb3JtRG9uZSA9IHRydWU7XG4gICAgICAgIHBhdGgucmVuZGVyQ2FjaGUoeyBmb3JDbGlwcGluZzogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5kcmF3Q2xpcFBhdGhPbkNhbnZhcyhjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyT3ZlcmxheShjdHgpO1xuICAgICAgaWYgKHRoaXMuY29udHJvbHNBYm92ZU92ZXJsYXkgJiYgdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLmRyYXdDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJlKCdhZnRlcjpyZW5kZXInLCB7IGN0eDogY3R4LCB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFpbnQgdGhlIGNhY2hlZCBjbGlwUGF0aCBvbiB0aGUgbG93ZXJDYW52YXNFbFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3Q2xpcFBhdGhPbkNhbnZhczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgdiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sIHBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICAvLyBERUJVRzogdW5jb21tZW50IHRoaXMgbGluZSwgY29tbWVudCB0aGUgZm9sbG93aW5nXG4gICAgICAvLyBjdHguZ2xvYmFsQWxwaGEgPSAwLjQ7XG4gICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICAgIHBhdGgudHJhbnNmb3JtKGN0eCk7XG4gICAgICBjdHguc2NhbGUoMSAvIHBhdGguem9vbVgsIDEgLyBwYXRoLnpvb21ZKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UocGF0aC5fY2FjaGVDYW52YXMsIC1wYXRoLmNhY2hlVHJhbnNsYXRpb25YLCAtcGF0aC5jYWNoZVRyYW5zbGF0aW9uWSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIHRvIHJlbmRlclxuICAgICAqL1xuICAgIF9yZW5kZXJPYmplY3RzOiBmdW5jdGlvbihjdHgsIG9iamVjdHMpIHtcbiAgICAgIHZhciBpLCBsZW47XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIG9iamVjdHNbaV0gJiYgb2JqZWN0c1tpXS5yZW5kZXIoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5ICdiYWNrZ3JvdW5kJyBvciAnb3ZlcmxheSdcbiAgICAgKi9cbiAgICBfcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheTogZnVuY3Rpb24oY3R4LCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIGZpbGwgPSB0aGlzW3Byb3BlcnR5ICsgJ0NvbG9yJ10sIG9iamVjdCA9IHRoaXNbcHJvcGVydHkgKyAnSW1hZ2UnXSxcbiAgICAgICAgICB2ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSwgbmVlZHNWcHQgPSB0aGlzW3Byb3BlcnR5ICsgJ1ZwdCddO1xuICAgICAgaWYgKCFmaWxsICYmICFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICBjdHgubGluZVRvKHRoaXMud2lkdGgsIDApO1xuICAgICAgICBjdHgubGluZVRvKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbygwLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGwudG9MaXZlXG4gICAgICAgICAgPyBmaWxsLnRvTGl2ZShjdHgsIHRoaXMpXG4gICAgICAgICAgOiBmaWxsO1xuICAgICAgICBpZiAobmVlZHNWcHQpIHtcbiAgICAgICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgZmlsbC5vZmZzZXRYIHx8IDAsIGZpbGwub2Zmc2V0WSB8fCAwKTtcbiAgICAgICAgdmFyIG0gPSBmaWxsLmdyYWRpZW50VHJhbnNmb3JtIHx8IGZpbGwucGF0dGVyblRyYW5zZm9ybTtcbiAgICAgICAgbSAmJiBjdHgudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZiAobmVlZHNWcHQpIHtcbiAgICAgICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdC5yZW5kZXIoY3R4KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheShjdHgsICdiYWNrZ3JvdW5kJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJPdmVybGF5OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXkoY3R4LCAnb3ZlcmxheScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIGEgY2VudGVyIG9mIGNhbnZhcy5cbiAgICAgKiBSZXR1cm5lZCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCB0b3AgYW5kIGxlZnQgcHJvcGVydGllc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ0b3BcIiBhbmQgXCJsZWZ0XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqIEBkZXByZWNhdGVkIG1pZ3JhdGUgdG8gYGdldENlbnRlclBvaW50YFxuICAgICAqL1xuICAgIGdldENlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0aGlzLmhlaWdodCAvIDIsXG4gICAgICAgIGxlZnQ6IHRoaXMud2lkdGggLyAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIGEgY2VudGVyIG9mIGNhbnZhcy5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IFxuICAgICAqL1xuICAgIGdldENlbnRlclBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludCh0aGlzLndpZHRoIC8gMiwgdGhpcy5oZWlnaHQgLyAyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IGluIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBjZW50ZXJPYmplY3RIOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgbmV3IGZhYnJpYy5Qb2ludCh0aGlzLmdldENlbnRlclBvaW50KCkueCwgb2JqZWN0LmdldENlbnRlclBvaW50KCkueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGluIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlck9iamVjdFY6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLngsIHRoaXMuZ2V0Q2VudGVyUG9pbnQoKS55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSBpbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIGNlbnRlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSBpbiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHZwQ2VudGVyID0gdGhpcy5nZXRWcENlbnRlcigpO1xuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIHZwQ2VudGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IGluIHRoZSB2aWV3cG9ydCwgb2JqZWN0LnRvcCBpcyB1bmNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJPYmplY3RIOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciB2cENlbnRlciA9IHRoaXMuZ2V0VnBDZW50ZXIoKTtcbiAgICAgIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQodnBDZW50ZXIueCwgb2JqZWN0LmdldENlbnRlclBvaW50KCkueSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IFZlcnRpY2FsbHkgaW4gdGhlIHZpZXdwb3J0LCBvYmplY3QudG9wIGlzIHVuY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlck9iamVjdFY6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHZwQ2VudGVyID0gdGhpcy5nZXRWcENlbnRlcigpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgbmV3IGZhYnJpYy5Qb2ludChvYmplY3QuZ2V0Q2VudGVyUG9pbnQoKS54LCB2cENlbnRlci55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG9pbnQgaW4gY2FudmFzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgY2VudGVyIG9mIGFjdHVhbCB2aWV3cG9ydC5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHZwQ2VudGVyLCB2aWV3cG9ydCBjZW50ZXJcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZ2V0VnBDZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgICBpVnB0ID0gaW52ZXJ0VHJhbnNmb3JtKHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pO1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybVBvaW50KGNlbnRlciwgaVZwdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlclxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBjZW50ZXIgQ2VudGVyIHBvaW50XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfY2VudGVyT2JqZWN0OiBmdW5jdGlvbihvYmplY3QsIGNlbnRlcikge1xuICAgICAgb2JqZWN0LnNldFBvc2l0aW9uQnlPcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgICAgb2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRhdGFsZXNzIEpTT04gcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30ganNvbiBzdHJpbmdcbiAgICAgKi9cbiAgICB0b0RhdGFsZXNzSlNPTjogZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvRGF0YWxlc3NPYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbiAocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvT2JqZWN0TWV0aG9kKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRhdGFsZXNzIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0RhdGFsZXNzT2JqZWN0OiBmdW5jdGlvbiAocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvT2JqZWN0TWV0aG9kKCd0b0RhdGFsZXNzT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvT2JqZWN0TWV0aG9kOiBmdW5jdGlvbiAobWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuXG4gICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoLCBkYXRhID0ge1xuICAgICAgICB2ZXJzaW9uOiBmYWJyaWMudmVyc2lvbixcbiAgICAgICAgb2JqZWN0czogdGhpcy5fdG9PYmplY3RzKG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpLFxuICAgICAgfTtcbiAgICAgIGlmIChjbGlwUGF0aCAmJiAhY2xpcFBhdGguZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgZGF0YS5jbGlwUGF0aCA9IHRoaXMuX3RvT2JqZWN0KHRoaXMuY2xpcFBhdGgsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfVxuICAgICAgZXh0ZW5kKGRhdGEsIHRoaXMuX19zZXJpYWxpemVCZ092ZXJsYXkobWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkpO1xuXG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIGRhdGEsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG9PYmplY3RzOiBmdW5jdGlvbihtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5maWx0ZXIoZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiAhb2JqZWN0LmV4Y2x1ZGVGcm9tRXhwb3J0O1xuICAgICAgfSkubWFwKGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b09iamVjdChpbnN0YW5jZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG9PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgb3JpZ2luYWxWYWx1ZTtcblxuICAgICAgaWYgKCF0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIG9yaWdpbmFsVmFsdWUgPSBpbnN0YW5jZS5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgaW5zdGFuY2UuaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9iamVjdCA9IGluc3RhbmNlW21ldGhvZE5hbWVdKHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgaWYgKCF0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIGluc3RhbmNlLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gb3JpZ2luYWxWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX19zZXJpYWxpemVCZ092ZXJsYXk6IGZ1bmN0aW9uKG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBkYXRhID0ge30sIGJnSW1hZ2UgPSB0aGlzLmJhY2tncm91bmRJbWFnZSwgb3ZlcmxheUltYWdlID0gdGhpcy5vdmVybGF5SW1hZ2UsXG4gICAgICAgICAgYmdDb2xvciA9IHRoaXMuYmFja2dyb3VuZENvbG9yLCBvdmVybGF5Q29sb3IgPSB0aGlzLm92ZXJsYXlDb2xvcjtcblxuICAgICAgaWYgKGJnQ29sb3IgJiYgYmdDb2xvci50b09iamVjdCkge1xuICAgICAgICBpZiAoIWJnQ29sb3IuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgICBkYXRhLmJhY2tncm91bmQgPSBiZ0NvbG9yLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChiZ0NvbG9yKSB7XG4gICAgICAgIGRhdGEuYmFja2dyb3VuZCA9IGJnQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdmVybGF5Q29sb3IgJiYgb3ZlcmxheUNvbG9yLnRvT2JqZWN0KSB7XG4gICAgICAgIGlmICghb3ZlcmxheUNvbG9yLmV4Y2x1ZGVGcm9tRXhwb3J0KSB7XG4gICAgICAgICAgZGF0YS5vdmVybGF5ID0gb3ZlcmxheUNvbG9yLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvdmVybGF5Q29sb3IpIHtcbiAgICAgICAgZGF0YS5vdmVybGF5ID0gb3ZlcmxheUNvbG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmdJbWFnZSAmJiAhYmdJbWFnZS5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICBkYXRhLmJhY2tncm91bmRJbWFnZSA9IHRoaXMuX3RvT2JqZWN0KGJnSW1hZ2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJsYXlJbWFnZSAmJiAhb3ZlcmxheUltYWdlLmV4Y2x1ZGVGcm9tRXhwb3J0KSB7XG4gICAgICAgIGRhdGEub3ZlcmxheUltYWdlID0gdGhpcy5fdG9PYmplY3Qob3ZlcmxheUltYWdlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBnZXRTdmdUcmFuc2Zvcm0oKSB3aWxsIGFwcGx5IHRoZSBTdGF0aWNDYW52YXMudmlld3BvcnRUcmFuc2Zvcm0gdG8gdGhlIFNWRyB0cmFuc2Zvcm1hdGlvbi4gV2hlbiB0cnVlLFxuICAgICAqIGEgem9vbWVkIGNhbnZhcyB3aWxsIHRoZW4gcHJvZHVjZSB6b29tZWQgU1ZHIG91dHB1dC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdmdWaWV3cG9ydFRyYW5zZm9ybWF0aW9uOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdCBmb3IgU1ZHIG91dHB1dFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3VwcHJlc3NQcmVhbWJsZT1mYWxzZV0gSWYgdHJ1ZSB4bWwgdGFnIGlzIG5vdCBpbmNsdWRlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy52aWV3Qm94XSBTVkcgdmlld2JveCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC54XSB4LWNvb3JkaW5hdGUgb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LnldIHktY29vcmRpbmF0ZSBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3gud2lkdGhdIFdpZHRoIG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC5oZWlnaHRdIEhlaWdodCBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPVVURi04XSBFbmNvZGluZyBvZiBTVkcgb3V0cHV0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLndpZHRoXSBkZXNpcmVkIHdpZHRoIG9mIHN2ZyB3aXRoIG9yIHdpdGhvdXQgdW5pdHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaGVpZ2h0XSBkZXNpcmVkIGhlaWdodCBvZiBzdmcgd2l0aCBvciB3aXRob3V0IHVuaXRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjb252ZXJ0ZWQgaW50byBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgc3RyaW5nXG4gICAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjc2VyaWFsaXphdGlvbn1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL2pRM1paL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBTVkcgb3V0cHV0PC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TVkcgb3V0cHV0IHdpdGhvdXQgcHJlYW1ibGUgKHdpdGhvdXQgJmx0Oz94bWwgLi4vPik8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyh7c3VwcHJlc3NQcmVhbWJsZTogdHJ1ZX0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNWRyBvdXRwdXQgd2l0aCB2aWV3Qm94IGF0dHJpYnV0ZTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKHtcbiAgICAgKiAgIHZpZXdCb3g6IHtcbiAgICAgKiAgICAgeDogMTAwLFxuICAgICAqICAgICB5OiAxMDAsXG4gICAgICogICAgIHdpZHRoOiAyMDAsXG4gICAgICogICAgIGhlaWdodDogMzAwXG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U1ZHIG91dHB1dCB3aXRoIGRpZmZlcmVudCBlbmNvZGluZyAoZGVmYXVsdDogVVRGLTgpPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoe2VuY29kaW5nOiAnSVNPLTg4NTktMSd9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Nb2RpZnkgU1ZHIG91dHB1dCB3aXRoIHJldml2ZXIgZnVuY3Rpb248L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyhudWxsLCBmdW5jdGlvbihzdmcpIHtcbiAgICAgKiAgIHJldHVybiBzdmcucmVwbGFjZSgnc3Ryb2tlLWRhc2hhcnJheTogOyBzdHJva2UtbGluZWNhcDogYnV0dDsgc3Ryb2tlLWxpbmVqb2luOiBtaXRlcjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyAnLCAnJyk7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKG9wdGlvbnMsIHJldml2ZXIpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgb3B0aW9ucy5yZXZpdmVyID0gcmV2aXZlcjtcbiAgICAgIHZhciBtYXJrdXAgPSBbXTtcblxuICAgICAgdGhpcy5fc2V0U1ZHUHJlYW1ibGUobWFya3VwLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX3NldFNWR0hlYWRlcihtYXJrdXAsIG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgbWFya3VwLnB1c2goJzxnIGNsaXAtcGF0aD1cInVybCgjJyArIHRoaXMuY2xpcFBhdGguY2xpcFBhdGhJZCArICcpXCIgPlxcbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0U1ZHQmdPdmVybGF5Q29sb3IobWFya3VwLCAnYmFja2dyb3VuZCcpO1xuICAgICAgdGhpcy5fc2V0U1ZHQmdPdmVybGF5SW1hZ2UobWFya3VwLCAnYmFja2dyb3VuZEltYWdlJywgcmV2aXZlcik7XG4gICAgICB0aGlzLl9zZXRTVkdPYmplY3RzKG1hcmt1cCwgcmV2aXZlcik7XG4gICAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgICBtYXJrdXAucHVzaCgnPC9nPlxcbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0U1ZHQmdPdmVybGF5Q29sb3IobWFya3VwLCAnb3ZlcmxheScpO1xuICAgICAgdGhpcy5fc2V0U1ZHQmdPdmVybGF5SW1hZ2UobWFya3VwLCAnb3ZlcmxheUltYWdlJywgcmV2aXZlcik7XG5cbiAgICAgIG1hcmt1cC5wdXNoKCc8L3N2Zz4nKTtcblxuICAgICAgcmV0dXJuIG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHUHJlYW1ibGU6IGZ1bmN0aW9uKG1hcmt1cCwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMuc3VwcHJlc3NQcmVhbWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIicsIChvcHRpb25zLmVuY29kaW5nIHx8ICdVVEYtOCcpLCAnXCIgc3RhbmRhbG9uZT1cIm5vXCIgPz5cXG4nLFxuICAgICAgICAnPCFET0NUWVBFIHN2ZyBQVUJMSUMgXCItLy9XM0MvL0RURCBTVkcgMS4xLy9FTlwiICcsXG4gICAgICAgICdcImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZFwiPlxcbidcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR0hlYWRlcjogZnVuY3Rpb24obWFya3VwLCBvcHRpb25zKSB7XG4gICAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoIHx8IHRoaXMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgdnB0LCB2aWV3Qm94ID0gJ3ZpZXdCb3g9XCIwIDAgJyArIHRoaXMud2lkdGggKyAnICcgKyB0aGlzLmhlaWdodCArICdcIiAnLFxuICAgICAgICAgIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG5cbiAgICAgIGlmIChvcHRpb25zLnZpZXdCb3gpIHtcbiAgICAgICAgdmlld0JveCA9ICd2aWV3Qm94PVwiJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LnggKyAnICcgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlld0JveC55ICsgJyAnICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3gud2lkdGggKyAnICcgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlld0JveC5oZWlnaHQgKyAnXCIgJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zdmdWaWV3cG9ydFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAgICAgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICAgICAgICB2aWV3Qm94ID0gJ3ZpZXdCb3g9XCInICtcbiAgICAgICAgICAgICAgICAgIHRvRml4ZWQoLXZwdFs0XSAvIHZwdFswXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCgtdnB0WzVdIC8gdnB0WzNdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcgJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMud2lkdGggLyB2cHRbMF0sIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5oZWlnaHQgLyB2cHRbM10sIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJ1wiICc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8c3ZnICcsXG4gICAgICAgICd4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyxcbiAgICAgICAgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiICcsXG4gICAgICAgICd2ZXJzaW9uPVwiMS4xXCIgJyxcbiAgICAgICAgJ3dpZHRoPVwiJywgd2lkdGgsICdcIiAnLFxuICAgICAgICAnaGVpZ2h0PVwiJywgaGVpZ2h0LCAnXCIgJyxcbiAgICAgICAgdmlld0JveCxcbiAgICAgICAgJ3htbDpzcGFjZT1cInByZXNlcnZlXCI+XFxuJyxcbiAgICAgICAgJzxkZXNjPkNyZWF0ZWQgd2l0aCBGYWJyaWMuanMgJywgZmFicmljLnZlcnNpb24sICc8L2Rlc2M+XFxuJyxcbiAgICAgICAgJzxkZWZzPlxcbicsXG4gICAgICAgIHRoaXMuY3JlYXRlU1ZHRm9udEZhY2VzTWFya3VwKCksXG4gICAgICAgIHRoaXMuY3JlYXRlU1ZHUmVmRWxlbWVudHNNYXJrdXAoKSxcbiAgICAgICAgdGhpcy5jcmVhdGVTVkdDbGlwUGF0aE1hcmt1cChvcHRpb25zKSxcbiAgICAgICAgJzwvZGVmcz5cXG4nXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBjcmVhdGVTVkdDbGlwUGF0aE1hcmt1cDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aDtcbiAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICBjbGlwUGF0aC5jbGlwUGF0aElkID0gJ0NMSVBQQVRIXycgKyBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICAgIHJldHVybiAgJzxjbGlwUGF0aCBpZD1cIicgKyBjbGlwUGF0aC5jbGlwUGF0aElkICsgJ1wiID5cXG4nICtcbiAgICAgICAgICB0aGlzLmNsaXBQYXRoLnRvQ2xpcFBhdGhTVkcob3B0aW9ucy5yZXZpdmVyKSArXG4gICAgICAgICAgJzwvY2xpcFBhdGg+XFxuJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBtYXJrdXAgY29udGFpbmluZyBTVkcgcmVmZXJlbmNlZCBlbGVtZW50cyBsaWtlIHBhdHRlcm5zLCBncmFkaWVudHMgZXRjLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjcmVhdGVTVkdSZWZFbGVtZW50c01hcmt1cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIG1hcmt1cCA9IFsnYmFja2dyb3VuZCcsICdvdmVybGF5J10ubWFwKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICAgIHZhciBmaWxsID0gX3RoaXNbcHJvcCArICdDb2xvciddO1xuICAgICAgICAgICAgaWYgKGZpbGwgJiYgZmlsbC50b0xpdmUpIHtcbiAgICAgICAgICAgICAgdmFyIHNob3VsZFRyYW5zZm9ybSA9IF90aGlzW3Byb3AgKyAnVnB0J10sIHZwdCA9IF90aGlzLnZpZXdwb3J0VHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgICAgb2JqZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogX3RoaXMud2lkdGggLyAoc2hvdWxkVHJhbnNmb3JtID8gdnB0WzBdIDogMSksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogX3RoaXMuaGVpZ2h0IC8gKHNob3VsZFRyYW5zZm9ybSA/IHZwdFszXSA6IDEpXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gZmlsbC50b1NWRyhcbiAgICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgICAgeyBhZGRpdGlvbmFsVHJhbnNmb3JtOiBzaG91bGRUcmFuc2Zvcm0gPyBmYWJyaWMudXRpbC5tYXRyaXhUb1NWRyh2cHQpIDogJycgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBtYXJrdXAgY29udGFpbmluZyBTVkcgZm9udCBmYWNlcyxcbiAgICAgKiBmb250IFVSTHMgZm9yIGZvbnQgZmFjZXMgbXVzdCBiZSBjb2xsZWN0ZWQgYnkgZGV2ZWxvcGVyc1xuICAgICAqIGFuZCBhcmUgbm90IGV4dHJhY3RlZCBmcm9tIHRoZSBET00gYnkgZmFicmljanNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIEFycmF5IG9mIGZhYnJpYyBvYmplY3RzXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGNyZWF0ZVNWR0ZvbnRGYWNlc01hcmt1cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFya3VwID0gJycsIGZvbnRMaXN0ID0geyB9LCBvYmosIGZvbnRGYW1pbHksXG4gICAgICAgICAgc3R5bGUsIHJvdywgcm93SW5kZXgsIF9jaGFyLCBjaGFySW5kZXgsIGksIGxlbixcbiAgICAgICAgICBmb250UGF0aHMgPSBmYWJyaWMuZm9udFBhdGhzLCBvYmplY3RzID0gW107XG5cbiAgICAgIHRoaXMuX29iamVjdHMuZm9yRWFjaChmdW5jdGlvbiBhZGQob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0Ll9vYmplY3RzKSB7XG4gICAgICAgICAgb2JqZWN0Ll9vYmplY3RzLmZvckVhY2goYWRkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb2JqID0gb2JqZWN0c1tpXTtcbiAgICAgICAgZm9udEZhbWlseSA9IG9iai5mb250RmFtaWx5O1xuICAgICAgICBpZiAob2JqLnR5cGUuaW5kZXhPZigndGV4dCcpID09PSAtMSB8fCBmb250TGlzdFtmb250RmFtaWx5XSB8fCAhZm9udFBhdGhzW2ZvbnRGYW1pbHldKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9udExpc3RbZm9udEZhbWlseV0gPSB0cnVlO1xuICAgICAgICBpZiAoIW9iai5zdHlsZXMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZSA9IG9iai5zdHlsZXM7XG4gICAgICAgIGZvciAocm93SW5kZXggaW4gc3R5bGUpIHtcbiAgICAgICAgICByb3cgPSBzdHlsZVtyb3dJbmRleF07XG4gICAgICAgICAgZm9yIChjaGFySW5kZXggaW4gcm93KSB7XG4gICAgICAgICAgICBfY2hhciA9IHJvd1tjaGFySW5kZXhdO1xuICAgICAgICAgICAgZm9udEZhbWlseSA9IF9jaGFyLmZvbnRGYW1pbHk7XG4gICAgICAgICAgICBpZiAoIWZvbnRMaXN0W2ZvbnRGYW1pbHldICYmIGZvbnRQYXRoc1tmb250RmFtaWx5XSkge1xuICAgICAgICAgICAgICBmb250TGlzdFtmb250RmFtaWx5XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogaW4gZm9udExpc3QpIHtcbiAgICAgICAgbWFya3VwICs9IFtcbiAgICAgICAgICAnXFx0XFx0QGZvbnQtZmFjZSB7XFxuJyxcbiAgICAgICAgICAnXFx0XFx0XFx0Zm9udC1mYW1pbHk6IFxcJycsIGosICdcXCc7XFxuJyxcbiAgICAgICAgICAnXFx0XFx0XFx0c3JjOiB1cmwoXFwnJywgZm9udFBhdGhzW2pdLCAnXFwnKTtcXG4nLFxuICAgICAgICAgICdcXHRcXHR9XFxuJ1xuICAgICAgICBdLmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWFya3VwKSB7XG4gICAgICAgIG1hcmt1cCA9IFtcbiAgICAgICAgICAnXFx0PHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPicsXG4gICAgICAgICAgJzwhW0NEQVRBW1xcbicsXG4gICAgICAgICAgbWFya3VwLFxuICAgICAgICAgICddXT4nLFxuICAgICAgICAgICc8L3N0eWxlPlxcbidcbiAgICAgICAgXS5qb2luKCcnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHT2JqZWN0czogZnVuY3Rpb24obWFya3VwLCByZXZpdmVyKSB7XG4gICAgICB2YXIgaW5zdGFuY2UsIGksIGxlbiwgb2JqZWN0cyA9IHRoaXMuX29iamVjdHM7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGluc3RhbmNlID0gb2JqZWN0c1tpXTtcbiAgICAgICAgaWYgKGluc3RhbmNlLmV4Y2x1ZGVGcm9tRXhwb3J0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0U1ZHT2JqZWN0KG1hcmt1cCwgaW5zdGFuY2UsIHJldml2ZXIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdPYmplY3Q6IGZ1bmN0aW9uKG1hcmt1cCwgaW5zdGFuY2UsIHJldml2ZXIpIHtcbiAgICAgIG1hcmt1cC5wdXNoKGluc3RhbmNlLnRvU1ZHKHJldml2ZXIpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHQmdPdmVybGF5SW1hZ2U6IGZ1bmN0aW9uKG1hcmt1cCwgcHJvcGVydHksIHJldml2ZXIpIHtcbiAgICAgIGlmICh0aGlzW3Byb3BlcnR5XSAmJiAhdGhpc1twcm9wZXJ0eV0uZXhjbHVkZUZyb21FeHBvcnQgJiYgdGhpc1twcm9wZXJ0eV0udG9TVkcpIHtcbiAgICAgICAgbWFya3VwLnB1c2godGhpc1twcm9wZXJ0eV0udG9TVkcocmV2aXZlcikpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdCZ092ZXJsYXlDb2xvcjogZnVuY3Rpb24obWFya3VwLCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIGZpbGxlciA9IHRoaXNbcHJvcGVydHkgKyAnQ29sb3InXSwgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSwgZmluYWxXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgZmluYWxIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgIGlmICghZmlsbGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsZXIudG9MaXZlKSB7XG4gICAgICAgIHZhciByZXBlYXQgPSBmaWxsZXIucmVwZWF0LCBpVnB0ID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKHZwdCksIHNob3VsZEludmVydCA9IHRoaXNbcHJvcGVydHkgKyAnVnB0J10sXG4gICAgICAgICAgICBhZGRpdGlvbmFsVHJhbnNmb3JtID0gc2hvdWxkSW52ZXJ0ID8gZmFicmljLnV0aWwubWF0cml4VG9TVkcoaVZwdCkgOiAnJztcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxyZWN0IHRyYW5zZm9ybT1cIicgKyBhZGRpdGlvbmFsVHJhbnNmb3JtICsgJyB0cmFuc2xhdGUoJywgZmluYWxXaWR0aCAvIDIsICcsJywgZmluYWxIZWlnaHQgLyAyLCAnKVwiJyxcbiAgICAgICAgICAnIHg9XCInLCBmaWxsZXIub2Zmc2V0WCAtIGZpbmFsV2lkdGggLyAyLFxuICAgICAgICAgICdcIiB5PVwiJywgZmlsbGVyLm9mZnNldFkgLSBmaW5hbEhlaWdodCAvIDIsICdcIiAnLFxuICAgICAgICAgICd3aWR0aD1cIicsXG4gICAgICAgICAgKHJlcGVhdCA9PT0gJ3JlcGVhdC15JyB8fCByZXBlYXQgPT09ICduby1yZXBlYXQnXG4gICAgICAgICAgICA/IGZpbGxlci5zb3VyY2Uud2lkdGhcbiAgICAgICAgICAgIDogZmluYWxXaWR0aCApLFxuICAgICAgICAgICdcIiBoZWlnaHQ9XCInLFxuICAgICAgICAgIChyZXBlYXQgPT09ICdyZXBlYXQteCcgfHwgcmVwZWF0ID09PSAnbm8tcmVwZWF0J1xuICAgICAgICAgICAgPyBmaWxsZXIuc291cmNlLmhlaWdodFxuICAgICAgICAgICAgOiBmaW5hbEhlaWdodCksXG4gICAgICAgICAgJ1wiIGZpbGw9XCJ1cmwoI1NWR0lEXycgKyBmaWxsZXIuaWQgKyAnKVwiJyxcbiAgICAgICAgICAnPjwvcmVjdD5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxyZWN0IHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgJyxcbiAgICAgICAgICAnZmlsbD1cIicsIGZpbGxlciwgJ1wiJyxcbiAgICAgICAgICAnPjwvcmVjdD5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCBvciB0aGUgb2JqZWN0cyBvZiBhIG11bHRpcGxlIHNlbGVjdGlvblxuICAgICAqIHRvIHRoZSBib3R0b20gb2YgdGhlIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2VuZCB0byBiYWNrXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZW5kVG9CYWNrOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgaSwgb2JqLCBvYmpzO1xuICAgICAgaWYgKG9iamVjdCA9PT0gYWN0aXZlU2VsZWN0aW9uICYmIG9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICBvYmpzID0gYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzO1xuICAgICAgICBmb3IgKGkgPSBvYmpzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIG9iaiA9IG9ianNbaV07XG4gICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iaik7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0cy51bnNoaWZ0KG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgICAgdGhpcy5fb2JqZWN0cy51bnNoaWZ0KG9iamVjdCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCBvciB0aGUgb2JqZWN0cyBvZiBhIG11bHRpcGxlIHNlbGVjdGlvblxuICAgICAqIHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2VuZFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgaSwgb2JqLCBvYmpzO1xuICAgICAgaWYgKG9iamVjdCA9PT0gYWN0aXZlU2VsZWN0aW9uICYmIG9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICBvYmpzID0gYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2Jqcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9iaiA9IG9ianNbaV07XG4gICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iaik7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0cy5wdXNoKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgICAgdGhpcy5fb2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCBvciBhIHNlbGVjdGlvbiBkb3duIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICAgKiBBbiBvcHRpb25hbCBwYXJhbWV0ZXIsIGludGVyc2VjdGluZyBhbGxvd3MgdG8gbW92ZSB0aGUgb2JqZWN0IGluIGJlaGluZFxuICAgICAqIHRoZSBmaXJzdCBpbnRlcnNlY3Rpbmcgb2JqZWN0LiBXaGVyZSBpbnRlcnNlY3Rpb24gaXMgY2FsY3VsYXRlZCB3aXRoXG4gICAgICogYm91bmRpbmcgYm94LiBJZiBubyBpbnRlcnNlY3Rpb24gaXMgZm91bmQsIHRoZXJlIHdpbGwgbm90IGJlIGNoYW5nZSBpbiB0aGVcbiAgICAgKiBzdGFjay5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc2VuZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVyc2VjdGluZ10gSWYgYHRydWVgLCBzZW5kIG9iamVjdCBiZWhpbmQgbmV4dCBsb3dlciBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZW5kQmFja3dhcmRzOiBmdW5jdGlvbiAob2JqZWN0LCBpbnRlcnNlY3RpbmcpIHtcbiAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBpLCBvYmosIGlkeCwgbmV3SWR4LCBvYmpzLCBvYmpzTW92ZWQgPSAwO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVTZWxlY3Rpb24gJiYgb2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqKTtcbiAgICAgICAgICBpZiAoaWR4ID4gMCArIG9ianNNb3ZlZCkge1xuICAgICAgICAgICAgbmV3SWR4ID0gaWR4IC0gMTtcbiAgICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmopO1xuICAgICAgICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UobmV3SWR4LCAwLCBvYmopO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpzTW92ZWQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlkeCA9IHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmplY3QpO1xuICAgICAgICBpZiAoaWR4ICE9PSAwKSB7XG4gICAgICAgICAgLy8gaWYgb2JqZWN0IGlzIG5vdCBvbiB0aGUgYm90dG9tIG9mIHN0YWNrXG4gICAgICAgICAgbmV3SWR4ID0gdGhpcy5fZmluZE5ld0xvd2VySW5kZXgob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZyk7XG4gICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UobmV3SWR4LCAwLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmROZXdMb3dlckluZGV4OiBmdW5jdGlvbihvYmplY3QsIGlkeCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICB2YXIgbmV3SWR4LCBpO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0aW5nKSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeDtcblxuICAgICAgICAvLyB0cmF2ZXJzZSBkb3duIHRoZSBzdGFjayBsb29raW5nIGZvciB0aGUgbmVhcmVzdCBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAgICAgIGZvciAoaSA9IGlkeCAtIDE7IGkgPj0gMDsgLS1pKSB7XG5cbiAgICAgICAgICB2YXIgaXNJbnRlcnNlY3RpbmcgPSBvYmplY3QuaW50ZXJzZWN0c1dpdGhPYmplY3QodGhpcy5fb2JqZWN0c1tpXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuaXNDb250YWluZWRXaXRoaW5PYmplY3QodGhpcy5fb2JqZWN0c1tpXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgICAgICBpZiAoaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdJZHggPSBpZHggLSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3SWR4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgYSBzZWxlY3Rpb24gdXAgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEFuIG9wdGlvbmFsIHBhcmFtZXRlciwgaW50ZXJzZWN0aW5nIGFsbG93cyB0byBtb3ZlIHRoZSBvYmplY3QgaW4gZnJvbnRcbiAgICAgKiBvZiB0aGUgZmlyc3QgaW50ZXJzZWN0aW5nIG9iamVjdC4gV2hlcmUgaW50ZXJzZWN0aW9uIGlzIGNhbGN1bGF0ZWQgd2l0aFxuICAgICAqIGJvdW5kaW5nIGJveC4gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIGZvdW5kLCB0aGVyZSB3aWxsIG5vdCBiZSBjaGFuZ2UgaW4gdGhlXG4gICAgICogc3RhY2suXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgaW4gZnJvbnQgb2YgbmV4dCB1cHBlciBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBicmluZ0ZvcndhcmQ6IGZ1bmN0aW9uIChvYmplY3QsIGludGVyc2VjdGluZykge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGksIG9iaiwgaWR4LCBuZXdJZHgsIG9ianMsIG9ianNNb3ZlZCA9IDA7XG5cbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZVNlbGVjdGlvbiAmJiBvYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgb2JqcyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gb2Jqcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIGlkeCA9IHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmopO1xuICAgICAgICAgIGlmIChpZHggPCB0aGlzLl9vYmplY3RzLmxlbmd0aCAtIDEgLSBvYmpzTW92ZWQpIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGlkeCArIDE7XG4gICAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Jqc01vdmVkKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKGlkeCAhPT0gdGhpcy5fb2JqZWN0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy8gaWYgb2JqZWN0IGlzIG5vdCBvbiB0b3Agb2Ygc3RhY2sgKGxhc3QgaXRlbSBpbiBhbiBhcnJheSlcbiAgICAgICAgICBuZXdJZHggPSB0aGlzLl9maW5kTmV3VXBwZXJJbmRleChvYmplY3QsIGlkeCwgaW50ZXJzZWN0aW5nKTtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqZWN0KTtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmluZE5ld1VwcGVySW5kZXg6IGZ1bmN0aW9uKG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpIHtcbiAgICAgIHZhciBuZXdJZHgsIGksIGxlbjtcblxuICAgICAgaWYgKGludGVyc2VjdGluZykge1xuICAgICAgICBuZXdJZHggPSBpZHg7XG5cbiAgICAgICAgLy8gdHJhdmVyc2UgdXAgdGhlIHN0YWNrIGxvb2tpbmcgZm9yIHRoZSBuZWFyZXN0IGludGVyc2VjdGluZyBvYmplY3RcbiAgICAgICAgZm9yIChpID0gaWR4ICsgMSwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXG4gICAgICAgICAgdmFyIGlzSW50ZXJzZWN0aW5nID0gb2JqZWN0LmludGVyc2VjdHNXaXRoT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdChvYmplY3QpO1xuXG4gICAgICAgICAgaWYgKGlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4ICsgMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0lkeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IHRvIHNwZWNpZmllZCBsZXZlbCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggUG9zaXRpb24gdG8gbW92ZSB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgbW92ZVRvOiBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCkge1xuICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShpbmRleCwgMCwgb2JqZWN0KTtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYSBjYW52YXMgZWxlbWVudCBhbmQgZGlzcG9zZSBvYmplY3RzXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBjYW5jZWwgZXZlbnR1YWxseSBvbmdvaW5nIHJlbmRlcnNcbiAgICAgIGlmICh0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLmlzUmVuZGVyaW5nKTtcbiAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLmZvckVhY2hPYmplY3QoZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5kaXNwb3NlICYmIG9iamVjdC5kaXNwb3NlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBbXTtcbiAgICAgIGlmICh0aGlzLmJhY2tncm91bmRJbWFnZSAmJiB0aGlzLmJhY2tncm91bmRJbWFnZS5kaXNwb3NlKSB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZEltYWdlLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYmFja2dyb3VuZEltYWdlID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLm92ZXJsYXlJbWFnZSAmJiB0aGlzLm92ZXJsYXlJbWFnZS5kaXNwb3NlKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheUltYWdlLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3ZlcmxheUltYWdlID0gbnVsbDtcbiAgICAgIHRoaXMuX2lUZXh0SW5zdGFuY2VzID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGV4dENvbnRhaW5lciA9IG51bGw7XG4gICAgICAvLyByZXN0b3JlIGNhbnZhcyBzdHlsZVxuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLmNsYXNzTGlzdC5yZW1vdmUoJ2xvd2VyLWNhbnZhcycpO1xuICAgICAgZmFicmljLnV0aWwuc2V0U3R5bGUodGhpcy5sb3dlckNhbnZhc0VsLCB0aGlzLl9vcmlnaW5hbENhbnZhc1N0eWxlKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9vcmlnaW5hbENhbnZhc1N0eWxlO1xuICAgICAgLy8gcmVzdG9yZSBjYW52YXMgc2l6ZSB0byBvcmlnaW5hbCBzaXplIGluIGNhc2UgcmV0aW5hIHNjYWxpbmcgd2FzIGFwcGxpZWRcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy53aWR0aCk7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmhlaWdodCk7XG4gICAgICBmYWJyaWMudXRpbC5jbGVhblVwSnNkb21Ob2RlKHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuQ2FudmFzICgnICsgdGhpcy5jb21wbGV4aXR5KCkgKyAnKTogJyArXG4gICAgICAgICAgICAgICAneyBvYmplY3RzOiAnICsgdGhpcy5fb2JqZWN0cy5sZW5ndGggKyAnIH0+JztcbiAgICB9XG4gIH0pO1xuXG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgZmFicmljLk9ic2VydmFibGUpO1xuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIGZhYnJpYy5Db2xsZWN0aW9uKTtcbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCBmYWJyaWMuRGF0YVVSTEV4cG9ydGVyKTtcblxuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcywgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzICovIHtcblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIEVNUFRZX0pTT046ICd7XCJvYmplY3RzXCI6IFtdLCBcImJhY2tncm91bmRcIjogXCJ3aGl0ZVwifScsXG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIHdheSB0byBjaGVjayBzdXBwb3J0IG9mIHNvbWUgb2YgdGhlIGNhbnZhcyBtZXRob2RzXG4gICAgICogKGVpdGhlciB0aG9zZSBvZiBIVE1MQ2FudmFzRWxlbWVudCBpdHNlbGYsIG9yIHJlbmRlcmluZyBjb250ZXh0KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWUgTWV0aG9kIHRvIGNoZWNrIHN1cHBvcnQgZm9yO1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvdWxkIGJlIG9uZSBvZiBcInNldExpbmVEYXNoXCJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFuIHwgbnVsbH0gYHRydWVgIGlmIG1ldGhvZCBpcyBzdXBwb3J0ZWQgKG9yIGF0IGxlYXN0IGV4aXN0cyksXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGBudWxsYCBpZiBjYW52YXMgZWxlbWVudCBvciBjb250ZXh0IGNhbiBub3QgYmUgaW5pdGlhbGl6ZWRcbiAgICAgKi9cbiAgICBzdXBwb3J0czogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBlbCA9IGNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcblxuICAgICAgaWYgKCFlbCB8fCAhZWwuZ2V0Q29udGV4dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eCA9IGVsLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpZiAoIWN0eCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChtZXRob2ROYW1lKSB7XG5cbiAgICAgICAgY2FzZSAnc2V0TGluZURhc2gnOlxuICAgICAgICAgIHJldHVybiB0eXBlb2YgY3R4LnNldExpbmVEYXNoICE9PSAndW5kZWZpbmVkJztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgKiB0aGlzIGFsaWFzIGlzIHByb3ZpZGVkIGJlY2F1c2UgaWYgeW91IGNhbGwgSlNPTi5zdHJpbmdpZnkgb24gYW4gaW5zdGFuY2UsXG4gICAqIHRoZSB0b0pTT04gb2JqZWN0IHdpbGwgYmUgaW52b2tlZCBpZiBpdCBleGlzdHMuXG4gICAqIEhhdmluZyBhIHRvSlNPTiBtZXRob2QgbWVhbnMgeW91IGNhbiBkbyBKU09OLnN0cmluZ2lmeShteUNhbnZhcylcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICogQHJldHVybiB7T2JqZWN0fSBKU09OIGNvbXBhdGlibGUgb2JqZWN0XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI3NlcmlhbGl6YXRpb259XG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvcGVjODYvfGpzRmlkZGxlIGRlbW99XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkpTT04gd2l0aG91dCBhZGRpdGlvbmFsIHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAqIHZhciBqc29uID0gY2FudmFzLnRvSlNPTigpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5KU09OIHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGluY2x1ZGVkPC9jYXB0aW9uPlxuICAgKiB2YXIganNvbiA9IGNhbnZhcy50b0pTT04oWydsb2NrTW92ZW1lbnRYJywgJ2xvY2tNb3ZlbWVudFknLCAnbG9ja1JvdGF0aW9uJywgJ2xvY2tTY2FsaW5nWCcsICdsb2NrU2NhbGluZ1knXSk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkpTT04gd2l0aG91dCBkZWZhdWx0IHZhbHVlczwvY2FwdGlvbj5cbiAgICogY2FudmFzLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gZmFsc2U7XG4gICAqIHZhciBqc29uID0gY2FudmFzLnRvSlNPTigpO1xuICAgKi9cbiAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUudG9KU09OID0gZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUudG9PYmplY3Q7XG5cbiAgaWYgKGZhYnJpYy5pc0xpa2VseU5vZGUpIHtcbiAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5jcmVhdGVQTkdTdHJlYW0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbXBsID0gZ2V0Tm9kZUNhbnZhcyh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgcmV0dXJuIGltcGwgJiYgaW1wbC5jcmVhdGVQTkdTdHJlYW0oKTtcbiAgICB9O1xuICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLmNyZWF0ZUpQRUdTdHJlYW0gPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgICB2YXIgaW1wbCA9IGdldE5vZGVDYW52YXModGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHJldHVybiBpbXBsICYmIGltcGwuY3JlYXRlSlBFR1N0cmVhbShvcHRzKTtcbiAgICB9O1xuICB9XG59KSgpO1xuXG5cbi8qKlxuICogQmFzZUJydXNoIGNsYXNzXG4gKiBAY2xhc3MgZmFicmljLkJhc2VCcnVzaFxuICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mcmVlZHJhd2luZ3xGcmVlZHJhd2luZyBkZW1vfVxuICovXG5mYWJyaWMuQmFzZUJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuQmFzZUJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIENvbG9yIG9mIGEgYnJ1c2hcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBjb2xvcjogJ3JnYigwLCAwLCAwKScsXG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIGEgYnJ1c2gsIGhhcyB0byBiZSBhIE51bWJlciwgbm8gc3RyaW5nIGxpdGVyYWxzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgd2lkdGg6IDEsXG5cbiAgLyoqXG4gICAqIFNoYWRvdyBvYmplY3QgcmVwcmVzZW50aW5nIHNoYWRvdyBvZiB0aGlzIHNoYXBlLlxuICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwic2hhZG93Q29sb3JcIiAoU3RyaW5nKSwgXCJzaGFkb3dPZmZzZXRYXCIgKE51bWJlciksXG4gICAqIFwic2hhZG93T2Zmc2V0WVwiIChOdW1iZXIpIGFuZCBcInNoYWRvd0JsdXJcIiAoTnVtYmVyKSBzaW5jZSB2MS4yLjEyXG4gICAqIEB0eXBlIGZhYnJpYy5TaGFkb3dcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHNoYWRvdzogbnVsbCxcblxuICAvKipcbiAgICogTGluZSBlbmRpbmdzIHN0eWxlIG9mIGEgYnJ1c2ggKG9uZSBvZiBcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiKVxuICAgKiBAdHlwZSBTdHJpbmdcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHN0cm9rZUxpbmVDYXA6ICdyb3VuZCcsXG5cbiAgLyoqXG4gICAqIENvcm5lciBzdHlsZSBvZiBhIGJydXNoIChvbmUgb2YgXCJiZXZlbFwiLCBcInJvdW5kXCIsIFwibWl0ZXJcIilcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VMaW5lSm9pbjogJ3JvdW5kJyxcblxuICAvKipcbiAgICogTWF4aW11bSBtaXRlciBsZW5ndGggKHVzZWQgZm9yIHN0cm9rZUxpbmVKb2luID0gXCJtaXRlclwiKSBvZiBhIGJydXNoJ3NcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VNaXRlckxpbWl0OiAgICAgICAgIDEwLFxuXG4gIC8qKlxuICAgKiBTdHJva2UgRGFzaCBBcnJheS5cbiAgICogQHR5cGUgQXJyYXlcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHN0cm9rZURhc2hBcnJheTogbnVsbCxcblxuICAvKipcbiAgICogV2hlbiBgdHJ1ZWAsIHRoZSBmcmVlIGRyYXdpbmcgaXMgbGltaXRlZCB0byB0aGUgd2hpdGVib2FyZCBzaXplLiBEZWZhdWx0IHRvIGZhbHNlLlxuICAgKiBAdHlwZSBCb29sZWFuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICovXG5cbiAgbGltaXRlZFRvQ2FudmFzU2l6ZTogZmFsc2UsXG5cblxuICAvKipcbiAgICogU2V0cyBicnVzaCBzdHlsZXNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgX3NldEJydXNoU3R5bGVzOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gdGhpcy53aWR0aDtcbiAgICBjdHgubGluZUNhcCA9IHRoaXMuc3Ryb2tlTGluZUNhcDtcbiAgICBjdHgubWl0ZXJMaW1pdCA9IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdDtcbiAgICBjdHgubGluZUpvaW4gPSB0aGlzLnN0cm9rZUxpbmVKb2luO1xuICAgIGN0eC5zZXRMaW5lRGFzaCh0aGlzLnN0cm9rZURhc2hBcnJheSB8fCBbXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRyYW5zZm9ybWF0aW9uIG9uIGdpdmVuIGNvbnRleHRcbiAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0MmR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NhdmVBbmRUcmFuc2Zvcm06IGZ1bmN0aW9uKGN0eCkge1xuICAgIHZhciB2ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGJydXNoIHNoYWRvdyBzdHlsZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5zaGFkb3cpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXMsXG4gICAgICAgIHNoYWRvdyA9IHRoaXMuc2hhZG93LFxuICAgICAgICBjdHggPSBjYW52YXMuY29udGV4dFRvcCxcbiAgICAgICAgem9vbSA9IGNhbnZhcy5nZXRab29tKCk7XG4gICAgaWYgKGNhbnZhcyAmJiBjYW52YXMuX2lzUmV0aW5hU2NhbGluZygpKSB7XG4gICAgICB6b29tICo9IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cblxuICAgIGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvdy5jb2xvcjtcbiAgICBjdHguc2hhZG93Qmx1ciA9IHNoYWRvdy5ibHVyICogem9vbTtcbiAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHNoYWRvdy5vZmZzZXRYICogem9vbTtcbiAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHNoYWRvdy5vZmZzZXRZICogem9vbTtcbiAgfSxcblxuICBuZWVkc0Z1bGxSZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcik7XG4gICAgcmV0dXJuIGNvbG9yLmdldEFscGhhKCkgPCAxIHx8ICEhdGhpcy5zaGFkb3c7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYnJ1c2ggc2hhZG93IHN0eWxlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0U2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcblxuICAgIGN0eC5zaGFkb3dDb2xvciA9ICcnO1xuICAgIGN0eC5zaGFkb3dCbHVyID0gY3R4LnNoYWRvd09mZnNldFggPSBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlzIHBvaW50ZXIgaXMgb3V0c2lkZSBjYW52YXMgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKiBAcHJpdmF0ZVxuICAqL1xuICBfaXNPdXRTaWRlQ2FudmFzOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgcmV0dXJuIHBvaW50ZXIueCA8IDAgfHwgcG9pbnRlci54ID4gdGhpcy5jYW52YXMuZ2V0V2lkdGgoKSB8fCBwb2ludGVyLnkgPCAwIHx8IHBvaW50ZXIueSA+IHRoaXMuY2FudmFzLmdldEhlaWdodCgpO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBQZW5jaWxCcnVzaCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBlbmNpbEJydXNoXG4gICAqIEBleHRlbmRzIGZhYnJpYy5CYXNlQnJ1c2hcbiAgICovXG4gIGZhYnJpYy5QZW5jaWxCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5CYXNlQnJ1c2gsIC8qKiBAbGVuZHMgZmFicmljLlBlbmNpbEJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBEaXNjYXJkIHBvaW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gYGRlY2ltYXRlYCBwaXhlbCBkaXN0YW50IGZyb20gZWFjaCBvdGhlclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDAuNFxuICAgICAqL1xuICAgIGRlY2ltYXRlOiAwLjQsXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIHN0cmFpZ2h0IGxpbmUgYmV0d2VlbiBsYXN0IHJlY29yZGVkIHBvaW50IHRvIGN1cnJlbnQgcG9pbnRlclxuICAgICAqIFVzZWQgZm9yIGBzaGlmdGAgZnVuY3Rpb25hbGl0eVxuICAgICAqXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZHJhd1N0cmFpZ2h0TGluZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgbW9kaWZpZXIga2V5IHRoYXQgbWFrZXMgdGhlIGJydXNoIGRyYXcgYSBzdHJhaWdodCBsaW5lLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleSB0aGUgZmVhdHVyZSBpcyBkaXNhYmxlZC5cbiAgICAgKiBAdHlwZSB7J2FsdEtleScgfCAnc2hpZnRLZXknIHwgJ2N0cmxLZXknIHwgJ25vbmUnIHwgdW5kZWZpbmVkIHwgbnVsbH1cbiAgICAgKi9cbiAgICBzdHJhaWdodExpbmVLZXk6ICdzaGlmdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNhbnZhc30gY2FudmFzXG4gICAgICogQHJldHVybiB7ZmFicmljLlBlbmNpbEJydXNofSBJbnN0YW5jZSBvZiBhIHBlbmNpbCBicnVzaFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLl9wb2ludHMgPSBbXTtcbiAgICB9LFxuXG4gICAgbmVlZHNGdWxsUmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ25lZWRzRnVsbFJlbmRlcicpIHx8IHRoaXMuX2hhc1N0cmFpZ2h0TGluZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBpbnNpZGUgb24gbW91c2UgZG93biBhbmQgbW91c2UgbW92ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAgICovXG4gICAgX2RyYXdTZWdtZW50OiBmdW5jdGlvbiAoY3R4LCBwMSwgcDIpIHtcbiAgICAgIHZhciBtaWRQb2ludCA9IHAxLm1pZFBvaW50RnJvbShwMik7XG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhwMS54LCBwMS55LCBtaWRQb2ludC54LCBtaWRQb2ludC55KTtcbiAgICAgIHJldHVybiBtaWRQb2ludDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbiBtb3VzZSBkb3duXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICAgKi9cbiAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlciwgb3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcy5faXNNYWluRXZlbnQob3B0aW9ucy5lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdTdHJhaWdodExpbmUgPSBvcHRpb25zLmVbdGhpcy5zdHJhaWdodExpbmVLZXldO1xuICAgICAgdGhpcy5fcHJlcGFyZUZvckRyYXdpbmcocG9pbnRlcik7XG4gICAgICAvLyBjYXB0dXJlIGNvb3JkaW5hdGVzIGltbWVkaWF0ZWx5XG4gICAgICAvLyB0aGlzIGFsbG93cyB0byBkcmF3IGRvdHMgKHdoZW4gbW92ZW1lbnQgbmV2ZXIgb2NjdXJzKVxuICAgICAgdGhpcy5fY2FwdHVyZURyYXdpbmdQYXRoKHBvaW50ZXIpO1xuICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgb24gbW91c2UgbW92ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAgICovXG4gICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMuX2lzTWFpbkV2ZW50KG9wdGlvbnMuZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmF3U3RyYWlnaHRMaW5lID0gb3B0aW9ucy5lW3RoaXMuc3RyYWlnaHRMaW5lS2V5XTtcbiAgICAgIGlmICh0aGlzLmxpbWl0ZWRUb0NhbnZhc1NpemUgPT09IHRydWUgJiYgdGhpcy5faXNPdXRTaWRlQ2FudmFzKHBvaW50ZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jYXB0dXJlRHJhd2luZ1BhdGgocG9pbnRlcikgJiYgdGhpcy5fcG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKHRoaXMubmVlZHNGdWxsUmVuZGVyKCkpIHtcbiAgICAgICAgICAvLyByZWRyYXcgY3VydmVcbiAgICAgICAgICAvLyBjbGVhciB0b3AgY2FudmFzXG4gICAgICAgICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgICAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLl9wb2ludHMsIGxlbmd0aCA9IHBvaW50cy5sZW5ndGgsIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICAgICAgLy8gZHJhdyB0aGUgY3VydmUgdXBkYXRlXG4gICAgICAgICAgdGhpcy5fc2F2ZUFuZFRyYW5zZm9ybShjdHgpO1xuICAgICAgICAgIGlmICh0aGlzLm9sZEVuZCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLm9sZEVuZC54LCB0aGlzLm9sZEVuZC55KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vbGRFbmQgPSB0aGlzLl9kcmF3U2VnbWVudChjdHgsIHBvaW50c1tsZW5ndGggLSAyXSwgcG9pbnRzW2xlbmd0aCAtIDFdLCB0cnVlKTtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIG9uIG1vdXNlIHVwXG4gICAgICovXG4gICAgb25Nb3VzZVVwOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzLl9pc01haW5FdmVudChvcHRpb25zLmUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmF3U3RyYWlnaHRMaW5lID0gZmFsc2U7XG4gICAgICB0aGlzLm9sZEVuZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2ZpbmFsaXplQW5kQWRkUGF0aCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyIEFjdHVhbCBtb3VzZSBwb3NpdGlvbiByZWxhdGVkIHRvIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgX3ByZXBhcmVGb3JEcmF3aW5nOiBmdW5jdGlvbihwb2ludGVyKSB7XG5cbiAgICAgIHZhciBwID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSk7XG5cbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICB0aGlzLl9hZGRQb2ludChwKTtcbiAgICAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AubW92ZVRvKHAueCwgcC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgUG9pbnQgdG8gYmUgYWRkZWQgdG8gcG9pbnRzIGFycmF5XG4gICAgICovXG4gICAgX2FkZFBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgaWYgKHRoaXMuX3BvaW50cy5sZW5ndGggPiAxICYmIHBvaW50LmVxKHRoaXMuX3BvaW50c1t0aGlzLl9wb2ludHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRyYXdTdHJhaWdodExpbmUgJiYgdGhpcy5fcG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5faGFzU3RyYWlnaHRMaW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcG9pbnRzLnBvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHBvaW50cyBhcnJheSBhbmQgc2V0IGNvbnRleHRUb3AgY2FudmFzIHN0eWxlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3BvaW50cyA9IFtdO1xuICAgICAgdGhpcy5fc2V0QnJ1c2hTdHlsZXModGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgICB0aGlzLl9zZXRTaGFkb3coKTtcbiAgICAgIHRoaXMuX2hhc1N0cmFpZ2h0TGluZSA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyIEFjdHVhbCBtb3VzZSBwb3NpdGlvbiByZWxhdGVkIHRvIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgX2NhcHR1cmVEcmF3aW5nUGF0aDogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgICAgdmFyIHBvaW50ZXJQb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54LCBwb2ludGVyLnkpO1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZFBvaW50KHBvaW50ZXJQb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBzbW9vdGggcGF0aCBvbiB0aGUgdG9wQ2FudmFzIHVzaW5nIHF1YWRyYXRpY0N1cnZlVG9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBbY3R4XVxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIGksIGxlbixcbiAgICAgICAgICBwMSA9IHRoaXMuX3BvaW50c1swXSxcbiAgICAgICAgICBwMiA9IHRoaXMuX3BvaW50c1sxXTtcbiAgICAgIGN0eCA9IGN0eCB8fCB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgICAgdGhpcy5fc2F2ZUFuZFRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgLy9pZiB3ZSBvbmx5IGhhdmUgMiBwb2ludHMgaW4gdGhlIHBhdGggYW5kIHRoZXkgYXJlIHRoZSBzYW1lXG4gICAgICAvL2l0IG1lYW5zIHRoYXQgdGhlIHVzZXIgb25seSBjbGlja2VkIHRoZSBjYW52YXMgd2l0aG91dCBtb3ZpbmcgdGhlIG1vdXNlXG4gICAgICAvL3RoZW4gd2Ugc2hvdWxkIGJlIGRyYXdpbmcgYSBkb3QuIEEgcGF0aCBpc24ndCBkcmF3biBiZXR3ZWVuIHR3byBpZGVudGljYWwgZG90c1xuICAgICAgLy90aGF0J3Mgd2h5IHdlIHNldCB0aGVtIGFwYXJ0IGEgYml0XG4gICAgICBpZiAodGhpcy5fcG9pbnRzLmxlbmd0aCA9PT0gMiAmJiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnkpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCAvIDEwMDA7XG4gICAgICAgIHAxID0gbmV3IGZhYnJpYy5Qb2ludChwMS54LCBwMS55KTtcbiAgICAgICAgcDIgPSBuZXcgZmFicmljLlBvaW50KHAyLngsIHAyLnkpO1xuICAgICAgICBwMS54IC09IHdpZHRoO1xuICAgICAgICBwMi54ICs9IHdpZHRoO1xuICAgICAgfVxuICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55KTtcblxuICAgICAgZm9yIChpID0gMSwgbGVuID0gdGhpcy5fcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIHdlIHBpY2sgdGhlIHBvaW50IGJldHdlZW4gcGkgKyAxICYgcGkgKyAyIGFzIHRoZVxuICAgICAgICAvLyBlbmQgcG9pbnQgYW5kIHAxIGFzIG91ciBjb250cm9sIHBvaW50LlxuICAgICAgICB0aGlzLl9kcmF3U2VnbWVudChjdHgsIHAxLCBwMik7XG4gICAgICAgIHAxID0gdGhpcy5fcG9pbnRzW2ldO1xuICAgICAgICBwMiA9IHRoaXMuX3BvaW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBEcmF3IGxhc3QgbGluZSBhcyBhIHN0cmFpZ2h0IGxpbmUgd2hpbGVcbiAgICAgIC8vIHdlIHdhaXQgZm9yIHRoZSBuZXh0IHBvaW50IHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlXG4gICAgICAvLyB0aGUgYmV6aWVyIGNvbnRyb2wgcG9pbnRcbiAgICAgIGN0eC5saW5lVG8ocDEueCwgcDEueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBwb2ludHMgdG8gU1ZHIHBhdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgQXJyYXkgb2YgcG9pbnRzXG4gICAgICogQHJldHVybiB7KHN0cmluZ3xudW1iZXIpW11bXX0gU1ZHIHBhdGggY29tbWFuZHNcbiAgICAgKi9cbiAgICBjb252ZXJ0UG9pbnRzVG9TVkdQYXRoOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICB2YXIgY29ycmVjdGlvbiA9IHRoaXMud2lkdGggLyAxMDAwO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLmdldFNtb290aFBhdGhGcm9tUG9pbnRzKHBvaW50cywgY29ycmVjdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcilbXVtdfSBwYXRoRGF0YSBTVkcgcGF0aCBjb21tYW5kc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIF9pc0VtcHR5U1ZHUGF0aDogZnVuY3Rpb24gKHBhdGhEYXRhKSB7XG4gICAgICB2YXIgcGF0aFN0cmluZyA9IGZhYnJpYy51dGlsLmpvaW5QYXRoKHBhdGhEYXRhKTtcbiAgICAgIHJldHVybiBwYXRoU3RyaW5nID09PSAnTSAwIDAgUSAwIDAgMCAwIEwgMCAwJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBmYWJyaWMuUGF0aCBvYmplY3QgdG8gYWRkIG9uIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpW11bXX0gcGF0aERhdGEgUGF0aCBkYXRhXG4gICAgICogQHJldHVybiB7ZmFicmljLlBhdGh9IFBhdGggdG8gYWRkIG9uIGNhbnZhc1xuICAgICAqL1xuICAgIGNyZWF0ZVBhdGg6IGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG4gICAgICB2YXIgcGF0aCA9IG5ldyBmYWJyaWMuUGF0aChwYXRoRGF0YSwge1xuICAgICAgICBmaWxsOiBudWxsLFxuICAgICAgICBzdHJva2U6IHRoaXMuY29sb3IsXG4gICAgICAgIHN0cm9rZVdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBzdHJva2VMaW5lQ2FwOiB0aGlzLnN0cm9rZUxpbmVDYXAsXG4gICAgICAgIHN0cm9rZU1pdGVyTGltaXQ6IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCxcbiAgICAgICAgc3Ryb2tlTGluZUpvaW46IHRoaXMuc3Ryb2tlTGluZUpvaW4sXG4gICAgICAgIHN0cm9rZURhc2hBcnJheTogdGhpcy5zdHJva2VEYXNoQXJyYXksXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnNoYWRvdykge1xuICAgICAgICB0aGlzLnNoYWRvdy5hZmZlY3RTdHJva2UgPSB0cnVlO1xuICAgICAgICBwYXRoLnNoYWRvdyA9IG5ldyBmYWJyaWMuU2hhZG93KHRoaXMuc2hhZG93KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2ltYXRlIHBvaW50cyBhcnJheSB3aXRoIHRoZSBkZWNpbWF0ZSB2YWx1ZVxuICAgICAqL1xuICAgIGRlY2ltYXRlUG9pbnRzOiBmdW5jdGlvbihwb2ludHMsIGRpc3RhbmNlKSB7XG4gICAgICBpZiAocG9pbnRzLmxlbmd0aCA8PSAyKSB7XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICB9XG4gICAgICB2YXIgem9vbSA9IHRoaXMuY2FudmFzLmdldFpvb20oKSwgYWRqdXN0ZWREaXN0YW5jZSA9IE1hdGgucG93KGRpc3RhbmNlIC8gem9vbSwgMiksXG4gICAgICAgICAgaSwgbCA9IHBvaW50cy5sZW5ndGggLSAxLCBsYXN0UG9pbnQgPSBwb2ludHNbMF0sIG5ld1BvaW50cyA9IFtsYXN0UG9pbnRdLFxuICAgICAgICAgIGNEaXN0YW5jZTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsIC0gMTsgaSsrKSB7XG4gICAgICAgIGNEaXN0YW5jZSA9IE1hdGgucG93KGxhc3RQb2ludC54IC0gcG9pbnRzW2ldLngsIDIpICsgTWF0aC5wb3cobGFzdFBvaW50LnkgLSBwb2ludHNbaV0ueSwgMik7XG4gICAgICAgIGlmIChjRGlzdGFuY2UgPj0gYWRqdXN0ZWREaXN0YW5jZSkge1xuICAgICAgICAgIGxhc3RQb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBuZXdQb2ludHMucHVzaChsYXN0UG9pbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEFkZCB0aGUgbGFzdCBwb2ludCBmcm9tIHRoZSBvcmlnaW5hbCBsaW5lIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgICogVGhpcyBlbnN1cmVzIGRlY2ltYXRlIGRvZXNuJ3QgZGVsZXRlIHRoZSBsYXN0IHBvaW50IG9uIHRoZSBsaW5lLCBhbmQgZW5zdXJlcyB0aGUgbGluZSBpcyA+IDEgcG9pbnQuXG4gICAgICAgKi9cbiAgICAgIG5ld1BvaW50cy5wdXNoKHBvaW50c1tsXSk7XG4gICAgICByZXR1cm4gbmV3UG9pbnRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbiBtb3VzZXVwIGFmdGVyIGRyYXdpbmcgdGhlIHBhdGggb24gY29udGV4dFRvcCBjYW52YXNcbiAgICAgKiB3ZSB1c2UgdGhlIHBvaW50cyBjYXB0dXJlZCB0byBjcmVhdGUgYW4gbmV3IGZhYnJpYyBwYXRoIG9iamVjdFxuICAgICAqIGFuZCBhZGQgaXQgdG8gdGhlIGZhYnJpYyBjYW52YXMuXG4gICAgICovXG4gICAgX2ZpbmFsaXplQW5kQWRkUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGlmICh0aGlzLmRlY2ltYXRlKSB7XG4gICAgICAgIHRoaXMuX3BvaW50cyA9IHRoaXMuZGVjaW1hdGVQb2ludHModGhpcy5fcG9pbnRzLCB0aGlzLmRlY2ltYXRlKTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMuY29udmVydFBvaW50c1RvU1ZHUGF0aCh0aGlzLl9wb2ludHMpO1xuICAgICAgaWYgKHRoaXMuX2lzRW1wdHlTVkdQYXRoKHBhdGhEYXRhKSkge1xuICAgICAgICAvLyBkbyBub3QgY3JlYXRlIDAgd2lkdGgvaGVpZ2h0IHBhdGhzLCBhcyB0aGV5IGFyZVxuICAgICAgICAvLyByZW5kZXJlZCBpbmNvbnNpc3RlbnRseSBhY3Jvc3MgYnJvd3NlcnNcbiAgICAgICAgLy8gRmlyZWZveCA0LCBmb3IgZXhhbXBsZSwgcmVuZGVycyBhIGRvdCxcbiAgICAgICAgLy8gd2hlcmVhcyBDaHJvbWUgMTAgcmVuZGVycyBub3RoaW5nXG4gICAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGF0aCA9IHRoaXMuY3JlYXRlUGF0aChwYXRoRGF0YSk7XG4gICAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCdiZWZvcmU6cGF0aDpjcmVhdGVkJywgeyBwYXRoOiBwYXRoIH0pO1xuICAgICAgdGhpcy5jYW52YXMuYWRkKHBhdGgpO1xuICAgICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcGF0aC5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMuX3Jlc2V0U2hhZG93KCk7XG5cblxuICAgICAgLy8gZmlyZSBldmVudCAncGF0aCcgY3JlYXRlZFxuICAgICAgdGhpcy5jYW52YXMuZmlyZSgncGF0aDpjcmVhdGVkJywgeyBwYXRoOiBwYXRoIH0pO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbi8qKlxuICogQ2lyY2xlQnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuQ2lyY2xlQnJ1c2hcbiAqL1xuZmFicmljLkNpcmNsZUJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkJhc2VCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuQ2lyY2xlQnJ1c2gucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogV2lkdGggb2YgYSBicnVzaFxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHdpZHRoOiAxMCxcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtmYWJyaWMuQ2FudmFzfSBjYW52YXNcbiAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZUJydXNofSBJbnN0YW5jZSBvZiBhIGNpcmNsZSBicnVzaFxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBpbnNpZGUgb24gbW91c2UgZG93biBhbmQgbW91c2UgbW92ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgZHJhd0RvdDogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHZhciBwb2ludCA9IHRoaXMuYWRkUG9pbnQocG9pbnRlciksXG4gICAgICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgdGhpcy5fc2F2ZUFuZFRyYW5zZm9ybShjdHgpO1xuICAgIHRoaXMuZG90KGN0eCwgcG9pbnQpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH0sXG5cbiAgZG90OiBmdW5jdGlvbihjdHgsIHBvaW50KSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHBvaW50LmZpbGw7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMocG9pbnQueCwgcG9pbnQueSwgcG9pbnQucmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIGRvd25cbiAgICovXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5wb2ludHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgdGhpcy5fc2V0U2hhZG93KCk7XG4gICAgdGhpcy5kcmF3RG90KHBvaW50ZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGZ1bGwgc3RhdGUgb2YgdGhlIGJydXNoXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3R4ICA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsIGksIGxlbixcbiAgICAgICAgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgdGhpcy5fc2F2ZUFuZFRyYW5zZm9ybShjdHgpO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5kb3QoY3R4LCBwb2ludHNbaV0pO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIG1vdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgaWYgKHRoaXMubGltaXRlZFRvQ2FudmFzU2l6ZSA9PT0gdHJ1ZSAmJiB0aGlzLl9pc091dFNpZGVDYW52YXMocG9pbnRlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVlZHNGdWxsUmVuZGVyKCkpIHtcbiAgICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgIHRoaXMuYWRkUG9pbnQocG9pbnRlcik7XG4gICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmRyYXdEb3QocG9pbnRlcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIHVwXG4gICAqL1xuICBvbk1vdXNlVXA6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlID0gdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUsIGksIGxlbjtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgdmFyIGNpcmNsZXMgPSBbXTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLnBvaW50c1tpXSxcbiAgICAgICAgICBjaXJjbGUgPSBuZXcgZmFicmljLkNpcmNsZSh7XG4gICAgICAgICAgICByYWRpdXM6IHBvaW50LnJhZGl1cyxcbiAgICAgICAgICAgIGxlZnQ6IHBvaW50LngsXG4gICAgICAgICAgICB0b3A6IHBvaW50LnksXG4gICAgICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgICAgICAgICAgZmlsbDogcG9pbnQuZmlsbFxuICAgICAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNoYWRvdyAmJiAoY2lyY2xlLnNoYWRvdyA9IG5ldyBmYWJyaWMuU2hhZG93KHRoaXMuc2hhZG93KSk7XG5cbiAgICAgIGNpcmNsZXMucHVzaChjaXJjbGUpO1xuICAgIH1cbiAgICB2YXIgZ3JvdXAgPSBuZXcgZmFicmljLkdyb3VwKGNpcmNsZXMpO1xuICAgIGdyb3VwLmNhbnZhcyA9IHRoaXMuY2FudmFzO1xuXG4gICAgdGhpcy5jYW52YXMuZmlyZSgnYmVmb3JlOnBhdGg6Y3JlYXRlZCcsIHsgcGF0aDogZ3JvdXAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkKGdyb3VwKTtcbiAgICB0aGlzLmNhbnZhcy5maXJlKCdwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IGdyb3VwIH0pO1xuXG4gICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMuX3Jlc2V0U2hhZG93KCk7XG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlO1xuICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBKdXN0IGFkZGVkIHBvaW50ZXIgcG9pbnRcbiAgICovXG4gIGFkZFBvaW50OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdmFyIHBvaW50ZXJQb2ludCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54LCBwb2ludGVyLnkpLFxuXG4gICAgICAgIGNpcmNsZVJhZGl1cyA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludChcbiAgICAgICAgICBNYXRoLm1heCgwLCB0aGlzLndpZHRoIC0gMjApLCB0aGlzLndpZHRoICsgMjApIC8gMixcblxuICAgICAgICBjaXJjbGVDb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcilcbiAgICAgICAgICAuc2V0QWxwaGEoZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KDAsIDEwMCkgLyAxMDApXG4gICAgICAgICAgLnRvUmdiYSgpO1xuXG4gICAgcG9pbnRlclBvaW50LnJhZGl1cyA9IGNpcmNsZVJhZGl1cztcbiAgICBwb2ludGVyUG9pbnQuZmlsbCA9IGNpcmNsZUNvbG9yO1xuXG4gICAgdGhpcy5wb2ludHMucHVzaChwb2ludGVyUG9pbnQpO1xuXG4gICAgcmV0dXJuIHBvaW50ZXJQb2ludDtcbiAgfVxufSk7XG5cblxuLyoqXG4gKiBTcHJheUJydXNoIGNsYXNzXG4gKiBAY2xhc3MgZmFicmljLlNwcmF5QnJ1c2hcbiAqL1xuZmFicmljLlNwcmF5QnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyggZmFicmljLkJhc2VCcnVzaCwgLyoqIEBsZW5kcyBmYWJyaWMuU3ByYXlCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBhIHNwcmF5XG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgd2lkdGg6ICAgICAgICAgICAgICAxMCxcblxuICAvKipcbiAgICogRGVuc2l0eSBvZiBhIHNwcmF5IChudW1iZXIgb2YgZG90cyBwZXIgY2h1bmspXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZGVuc2l0eTogICAgICAgICAgICAyMCxcblxuICAvKipcbiAgICogV2lkdGggb2Ygc3ByYXkgZG90c1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGRvdFdpZHRoOiAgICAgICAgICAgMSxcblxuICAvKipcbiAgICogV2lkdGggdmFyaWFuY2Ugb2Ygc3ByYXkgZG90c1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGRvdFdpZHRoVmFyaWFuY2U6ICAgMSxcblxuICAvKipcbiAgICogV2hldGhlciBvcGFjaXR5IG9mIGEgZG90IHNob3VsZCBiZSByYW5kb21cbiAgICogQHR5cGUgQm9vbGVhblxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgcmFuZG9tT3BhY2l0eTogICAgICAgIGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG92ZXJsYXBwaW5nIGRvdHMgKHJlY3RhbmdsZXMpIHNob3VsZCBiZSByZW1vdmVkIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucylcbiAgICogQHR5cGUgQm9vbGVhblxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgb3B0aW1pemVPdmVybGFwcGluZzogIHRydWUsXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7ZmFicmljLkNhbnZhc30gY2FudmFzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5TcHJheUJydXNofSBJbnN0YW5jZSBvZiBhIHNwcmF5IGJydXNoXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLnNwcmF5Q2h1bmtzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgZG93blxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLnNwcmF5Q2h1bmtzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMuX3NldFNoYWRvdygpO1xuXG4gICAgdGhpcy5hZGRTcHJheUNodW5rKHBvaW50ZXIpO1xuICAgIHRoaXMucmVuZGVyKHRoaXMuc3ByYXlDaHVua1BvaW50cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgbW92ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICBpZiAodGhpcy5saW1pdGVkVG9DYW52YXNTaXplID09PSB0cnVlICYmIHRoaXMuX2lzT3V0U2lkZUNhbnZhcyhwb2ludGVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFkZFNwcmF5Q2h1bmsocG9pbnRlcik7XG4gICAgdGhpcy5yZW5kZXIodGhpcy5zcHJheUNodW5rUG9pbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSB1cFxuICAgKi9cbiAgb25Nb3VzZVVwOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZSA9IHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlO1xuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gZmFsc2U7XG5cbiAgICB2YXIgcmVjdHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpbGVuID0gdGhpcy5zcHJheUNodW5rcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHZhciBzcHJheUNodW5rID0gdGhpcy5zcHJheUNodW5rc1tpXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBzcHJheUNodW5rLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuXG4gICAgICAgIHZhciByZWN0ID0gbmV3IGZhYnJpYy5SZWN0KHtcbiAgICAgICAgICB3aWR0aDogc3ByYXlDaHVua1tqXS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHNwcmF5Q2h1bmtbal0ud2lkdGgsXG4gICAgICAgICAgbGVmdDogc3ByYXlDaHVua1tqXS54ICsgMSxcbiAgICAgICAgICB0b3A6IHNwcmF5Q2h1bmtbal0ueSArIDEsXG4gICAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXG4gICAgICAgICAgZmlsbDogdGhpcy5jb2xvclxuICAgICAgICB9KTtcbiAgICAgICAgcmVjdHMucHVzaChyZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpbWl6ZU92ZXJsYXBwaW5nKSB7XG4gICAgICByZWN0cyA9IHRoaXMuX2dldE9wdGltaXplZFJlY3RzKHJlY3RzKTtcbiAgICB9XG5cbiAgICB2YXIgZ3JvdXAgPSBuZXcgZmFicmljLkdyb3VwKHJlY3RzKTtcbiAgICB0aGlzLnNoYWRvdyAmJiBncm91cC5zZXQoJ3NoYWRvdycsIG5ldyBmYWJyaWMuU2hhZG93KHRoaXMuc2hhZG93KSk7XG4gICAgdGhpcy5jYW52YXMuZmlyZSgnYmVmb3JlOnBhdGg6Y3JlYXRlZCcsIHsgcGF0aDogZ3JvdXAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkKGdyb3VwKTtcbiAgICB0aGlzLmNhbnZhcy5maXJlKCdwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IGdyb3VwIH0pO1xuXG4gICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMuX3Jlc2V0U2hhZG93KCk7XG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlO1xuICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gcmVjdHNcbiAgICovXG4gIF9nZXRPcHRpbWl6ZWRSZWN0czogZnVuY3Rpb24ocmVjdHMpIHtcblxuICAgIC8vIGF2b2lkIGNyZWF0aW5nIGR1cGxpY2F0ZSByZWN0cyBhdCB0aGUgc2FtZSBjb29yZGluYXRlc1xuICAgIHZhciB1bmlxdWVSZWN0cyA9IHsgfSwga2V5LCBpLCBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAga2V5ID0gcmVjdHNbaV0ubGVmdCArICcnICsgcmVjdHNbaV0udG9wO1xuICAgICAgaWYgKCF1bmlxdWVSZWN0c1trZXldKSB7XG4gICAgICAgIHVuaXF1ZVJlY3RzW2tleV0gPSByZWN0c1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVuaXF1ZVJlY3RzQXJyYXkgPSBbXTtcbiAgICBmb3IgKGtleSBpbiB1bmlxdWVSZWN0cykge1xuICAgICAgdW5pcXVlUmVjdHNBcnJheS5wdXNoKHVuaXF1ZVJlY3RzW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiB1bmlxdWVSZWN0c0FycmF5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgbmV3IGNodW5rIG9mIHNwcmF5IGJydXNoXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uKHNwcmF5Q2h1bmspIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCwgaSwgbGVuO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuXG4gICAgdGhpcy5fc2F2ZUFuZFRyYW5zZm9ybShjdHgpO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gc3ByYXlDaHVuay5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHBvaW50ID0gc3ByYXlDaHVua1tpXTtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnQub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gcG9pbnQub3BhY2l0eTtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsUmVjdChwb2ludC54LCBwb2ludC55LCBwb2ludC53aWR0aCwgcG9pbnQud2lkdGgpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYWxsIHNwcmF5IGNodW5rc1xuICAgKi9cbiAgX3JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsIGksIGlsZW47XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG5cbiAgICB0aGlzLl9zYXZlQW5kVHJhbnNmb3JtKGN0eCk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGhpcy5zcHJheUNodW5rcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHRoaXMucmVuZGVyKHRoaXMuc3ByYXlDaHVua3NbaV0pO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgKi9cbiAgYWRkU3ByYXlDaHVuazogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMuc3ByYXlDaHVua1BvaW50cyA9IFtdO1xuXG4gICAgdmFyIHgsIHksIHdpZHRoLCByYWRpdXMgPSB0aGlzLndpZHRoIC8gMiwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRlbnNpdHk7IGkrKykge1xuXG4gICAgICB4ID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KHBvaW50ZXIueCAtIHJhZGl1cywgcG9pbnRlci54ICsgcmFkaXVzKTtcbiAgICAgIHkgPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQocG9pbnRlci55IC0gcmFkaXVzLCBwb2ludGVyLnkgKyByYWRpdXMpO1xuXG4gICAgICBpZiAodGhpcy5kb3RXaWR0aFZhcmlhbmNlKSB7XG4gICAgICAgIHdpZHRoID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KFxuICAgICAgICAgIC8vIGJvdHRvbSBjbGFtcCB3aWR0aCB0byAxXG4gICAgICAgICAgTWF0aC5tYXgoMSwgdGhpcy5kb3RXaWR0aCAtIHRoaXMuZG90V2lkdGhWYXJpYW5jZSksXG4gICAgICAgICAgdGhpcy5kb3RXaWR0aCArIHRoaXMuZG90V2lkdGhWYXJpYW5jZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgd2lkdGggPSB0aGlzLmRvdFdpZHRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHgsIHkpO1xuICAgICAgcG9pbnQud2lkdGggPSB3aWR0aDtcblxuICAgICAgaWYgKHRoaXMucmFuZG9tT3BhY2l0eSkge1xuICAgICAgICBwb2ludC5vcGFjaXR5ID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KDAsIDEwMCkgLyAxMDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3ByYXlDaHVua1BvaW50cy5wdXNoKHBvaW50KTtcbiAgICB9XG5cbiAgICB0aGlzLnNwcmF5Q2h1bmtzLnB1c2godGhpcy5zcHJheUNodW5rUG9pbnRzKTtcbiAgfVxufSk7XG5cblxuLyoqXG4gKiBQYXR0ZXJuQnJ1c2ggY2xhc3NcbiAqIEBjbGFzcyBmYWJyaWMuUGF0dGVybkJydXNoXG4gKiBAZXh0ZW5kcyBmYWJyaWMuQmFzZUJydXNoXG4gKi9cbmZhYnJpYy5QYXR0ZXJuQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuUGVuY2lsQnJ1c2gsIC8qKiBAbGVuZHMgZmFicmljLlBhdHRlcm5CcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIGdldFBhdHRlcm5TcmM6IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGRvdFdpZHRoID0gMjAsXG4gICAgICAgIGRvdERpc3RhbmNlID0gNSxcbiAgICAgICAgcGF0dGVybkNhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcbiAgICAgICAgcGF0dGVybkN0eCA9IHBhdHRlcm5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIHBhdHRlcm5DYW52YXMud2lkdGggPSBwYXR0ZXJuQ2FudmFzLmhlaWdodCA9IGRvdFdpZHRoICsgZG90RGlzdGFuY2U7XG5cbiAgICBwYXR0ZXJuQ3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgcGF0dGVybkN0eC5iZWdpblBhdGgoKTtcbiAgICBwYXR0ZXJuQ3R4LmFyYyhkb3RXaWR0aCAvIDIsIGRvdFdpZHRoIC8gMiwgZG90V2lkdGggLyAyLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgIHBhdHRlcm5DdHguY2xvc2VQYXRoKCk7XG4gICAgcGF0dGVybkN0eC5maWxsKCk7XG5cbiAgICByZXR1cm4gcGF0dGVybkNhbnZhcztcbiAgfSxcblxuICBnZXRQYXR0ZXJuU3JjRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5nZXRQYXR0ZXJuU3JjKS5yZXBsYWNlKCd0aGlzLmNvbG9yJywgJ1wiJyArIHRoaXMuY29sb3IgKyAnXCInKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBcInBhdHRlcm5cIiBpbnN0YW5jZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICBnZXRQYXR0ZXJuOiBmdW5jdGlvbihjdHgpIHtcbiAgICByZXR1cm4gY3R4LmNyZWF0ZVBhdHRlcm4odGhpcy5zb3VyY2UgfHwgdGhpcy5nZXRQYXR0ZXJuU3JjKCksICdyZXBlYXQnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBicnVzaCBzdHlsZXNcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgX3NldEJydXNoU3R5bGVzOiBmdW5jdGlvbihjdHgpIHtcbiAgICB0aGlzLmNhbGxTdXBlcignX3NldEJydXNoU3R5bGVzJywgY3R4KTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmdldFBhdHRlcm4oY3R4KTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBwYXRoXG4gICAqL1xuICBjcmVhdGVQYXRoOiBmdW5jdGlvbihwYXRoRGF0YSkge1xuICAgIHZhciBwYXRoID0gdGhpcy5jYWxsU3VwZXIoJ2NyZWF0ZVBhdGgnLCBwYXRoRGF0YSksXG4gICAgICAgIHRvcExlZnQgPSBwYXRoLl9nZXRMZWZ0VG9wQ29vcmRzKCkuc2NhbGFyQWRkKHBhdGguc3Ryb2tlV2lkdGggLyAyKTtcblxuICAgIHBhdGguc3Ryb2tlID0gbmV3IGZhYnJpYy5QYXR0ZXJuKHtcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UgfHwgdGhpcy5nZXRQYXR0ZXJuU3JjRnVuY3Rpb24oKSxcbiAgICAgIG9mZnNldFg6IC10b3BMZWZ0LngsXG4gICAgICBvZmZzZXRZOiAtdG9wTGVmdC55XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZ2V0UG9pbnRlciA9IGZhYnJpYy51dGlsLmdldFBvaW50ZXIsXG4gICAgICBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyxcbiAgICAgIGlzVG91Y2hFdmVudCA9IGZhYnJpYy51dGlsLmlzVG91Y2hFdmVudDtcblxuICAvKipcbiAgICogQ2FudmFzIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuQ2FudmFzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXNcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjY2FudmFzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuQ2FudmFzI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqXG4gICAqIEBmaXJlcyBvYmplY3Q6bW9kaWZpZWQgYXQgdGhlIGVuZCBvZiBhIHRyYW5zZm9ybSBvciBhbnkgY2hhbmdlIHdoZW4gc3RhdGVmdWxsIGlzIHRydWVcbiAgICogQGZpcmVzIG9iamVjdDpyb3RhdGluZyB3aGlsZSBhbiBvYmplY3QgaXMgYmVpbmcgcm90YXRlZCBmcm9tIHRoZSBjb250cm9sXG4gICAqIEBmaXJlcyBvYmplY3Q6c2NhbGluZyB3aGlsZSBhbiBvYmplY3QgaXMgYmVpbmcgc2NhbGVkIGJ5IGNvbnRyb2xzXG4gICAqIEBmaXJlcyBvYmplY3Q6bW92aW5nIHdoaWxlIGFuIG9iamVjdCBpcyBiZWluZyBkcmFnZ2VkXG4gICAqIEBmaXJlcyBvYmplY3Q6c2tld2luZyB3aGlsZSBhbiBvYmplY3QgaXMgYmVpbmcgc2tld2VkIGZyb20gdGhlIGNvbnRyb2xzXG4gICAqXG4gICAqIEBmaXJlcyBiZWZvcmU6dHJhbnNmb3JtIGJlZm9yZSBhIHRyYW5zZm9ybSBpcyBpcyBzdGFydGVkXG4gICAqIEBmaXJlcyBiZWZvcmU6c2VsZWN0aW9uOmNsZWFyZWRcbiAgICogQGZpcmVzIHNlbGVjdGlvbjpjbGVhcmVkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246dXBkYXRlZFxuICAgKiBAZmlyZXMgc2VsZWN0aW9uOmNyZWF0ZWRcbiAgICpcbiAgICogQGZpcmVzIHBhdGg6Y3JlYXRlZCBhZnRlciBhIGRyYXdpbmcgb3BlcmF0aW9uIGVuZHMgYW5kIHRoZSBwYXRoIGlzIGFkZGVkXG4gICAqIEBmaXJlcyBtb3VzZTpkb3duXG4gICAqIEBmaXJlcyBtb3VzZTptb3ZlXG4gICAqIEBmaXJlcyBtb3VzZTp1cFxuICAgKiBAZmlyZXMgbW91c2U6ZG93bjpiZWZvcmUgIG9uIG1vdXNlIGRvd24sIGJlZm9yZSB0aGUgaW5uZXIgZmFicmljIGxvZ2ljIHJ1bnNcbiAgICogQGZpcmVzIG1vdXNlOm1vdmU6YmVmb3JlIG9uIG1vdXNlIG1vdmUsIGJlZm9yZSB0aGUgaW5uZXIgZmFicmljIGxvZ2ljIHJ1bnNcbiAgICogQGZpcmVzIG1vdXNlOnVwOmJlZm9yZSBvbiBtb3VzZSB1cCwgYmVmb3JlIHRoZSBpbm5lciBmYWJyaWMgbG9naWMgcnVuc1xuICAgKiBAZmlyZXMgbW91c2U6b3ZlclxuICAgKiBAZmlyZXMgbW91c2U6b3V0XG4gICAqIEBmaXJlcyBtb3VzZTpkYmxjbGljayB3aGVuZXZlciBhIG5hdGl2ZSBkYmwgY2xpY2sgZXZlbnQgZmlyZXMgb24gdGhlIGNhbnZhcy5cbiAgICpcbiAgICogQGZpcmVzIGRyYWdvdmVyXG4gICAqIEBmaXJlcyBkcmFnZW50ZXJcbiAgICogQGZpcmVzIGRyYWdsZWF2ZVxuICAgKiBAZmlyZXMgZHJvcDpiZWZvcmUgYmVmb3JlIGRyb3AgZXZlbnQuIHNhbWUgbmF0aXZlIGV2ZW50LiBUaGlzIGlzIGFkZGVkIHRvIGhhbmRsZSBlZGdlIGNhc2VzXG4gICAqIEBmaXJlcyBkcm9wXG4gICAqIEBmaXJlcyBhZnRlcjpyZW5kZXIgYXQgdGhlIGVuZCBvZiB0aGUgcmVuZGVyIHByb2Nlc3MsIHJlY2VpdmVzIHRoZSBjb250ZXh0IGluIHRoZSBjYWxsYmFja1xuICAgKiBAZmlyZXMgYmVmb3JlOnJlbmRlciBhdCBzdGFydCB0aGUgcmVuZGVyIHByb2Nlc3MsIHJlY2VpdmVzIHRoZSBjb250ZXh0IGluIHRoZSBjYWxsYmFja1xuICAgKlxuICAgKi9cbiAgZmFicmljLkNhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5TdGF0aWNDYW52YXMsIC8qKiBAbGVuZHMgZmFicmljLkNhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU3RyaW5nfSBlbCAmbHQ7Y2FudmFzPiBlbGVtZW50IHRvIGluaXRpYWxpemUgaW5zdGFuY2Ugb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdGhpcy5yZW5kZXJBbmRSZXNldEJvdW5kID0gdGhpcy5yZW5kZXJBbmRSZXNldC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsQm91bmQgPSB0aGlzLnJlcXVlc3RSZW5kZXJBbGwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2luaXRTdGF0aWMoZWwsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdEludGVyYWN0aXZlKCk7XG4gICAgICB0aGlzLl9jcmVhdGVDYWNoZUNhbnZhcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdHMgY2FuIGJlIHRyYW5zZm9ybWVkIGJ5IG9uZSBzaWRlICh1bnByb3BvcnRpb25hbGx5KVxuICAgICAqIHdoZW4gZHJhZ2dlZCBvbiB0aGUgY29ybmVycyB0aGF0IG5vcm1hbGx5IHdvdWxkIG5vdCBkbyB0aGF0LlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBzaW5jZSBmYWJyaWMgNC4wIC8vIGNoYW5nZWQgbmFtZSBhbmQgZGVmYXVsdCB2YWx1ZVxuICAgICAqL1xuICAgIHVuaWZvcm1TY2FsaW5nOiAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2gga2V5IHN3aXRjaGVzIHVuaWZvcm0gc2NhbGluZy5cbiAgICAgKiB2YWx1ZXM6ICdhbHRLZXknLCAnc2hpZnRLZXknLCAnY3RybEtleScuXG4gICAgICogSWYgYG51bGxgIG9yICdub25lJyBvciBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5XG4gICAgICogZmVhdHVyZSBpcyBkaXNhYmxlZC5cbiAgICAgKiB0b3RhbGx5IHdyb25nIG5hbWVkLiB0aGlzIHNvdW5kcyBsaWtlIGB1bmlmb3JtIHNjYWxpbmdgXG4gICAgICogaWYgQ2FudmFzLnVuaWZvcm1TY2FsaW5nIGlzIHRydWUsIHByZXNzaW5nIHRoaXMgd2lsbCBzZXQgaXQgdG8gZmFsc2VcbiAgICAgKiBhbmQgdmljZXZlcnNhLlxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdW5pU2NhbGVLZXk6ICAgICAgICAgICAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBvYmplY3RzIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiBzY2FsZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkU2NhbGluZzogICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBvYmplY3RzIHVzZSBjZW50ZXIgcG9pbnQgYXMgdGhlIG9yaWdpbiBvZiByb3RhdGUgdHJhbnNmb3JtYXRpb24uXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcImNlbnRlclRyYW5zZm9ybVwiIChCb29sZWFuKS5cbiAgICAgKiBAc2luY2UgMS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZFJvdGF0aW9uOiAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgZW5hYmxlIGNlbnRlcmVkIFRyYW5zZm9ybVxuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkIGZlYXR1cmUgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZEtleTogICAgICAgICAgICdhbHRLZXknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgYWx0ZXJuYXRlIGFjdGlvbiBvbiBjb3JuZXJcbiAgICAgKiB2YWx1ZXM6ICdhbHRLZXknLCAnc2hpZnRLZXknLCAnY3RybEtleScuXG4gICAgICogSWYgYG51bGxgIG9yICdub25lJyBvciBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5XG4gICAgICogZmVhdHVyZSBpcyBkaXNhYmxlZCBmZWF0dXJlIGRpc2FibGVkLlxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYWx0QWN0aW9uS2V5OiAgICAgICAgICAgJ3NoaWZ0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGNhbnZhcyBpcyBpbnRlcmFjdGl2ZS4gVGhpcyBwcm9wZXJ0eSBzaG91bGQgbm90IGJlIGNoYW5nZWQuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW50ZXJhY3RpdmU6ICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGdyb3VwIHNlbGVjdGlvbiBzaG91bGQgYmUgZW5hYmxlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbjogICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2gga2V5IG9yIGtleXMgZW5hYmxlIG11bHRpcGxlIGNsaWNrIHNlbGVjdGlvblxuICAgICAqIFBhc3MgdmFsdWUgYXMgYSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAqIHZhbHVlczogJ2FsdEtleScsICdzaGlmdEtleScsICdjdHJsS2V5Jy5cbiAgICAgKiBJZiBgbnVsbGAgb3IgZW1wdHkgb3IgY29udGFpbmluZyBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5XG4gICAgICogZmVhdHVyZSBpcyBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmd8QXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbktleTogICAgICAgICAgICdzaGlmdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2gga2V5IGVuYWJsZSBhbHRlcm5hdGl2ZSBzZWxlY3Rpb25cbiAgICAgKiBpbiBjYXNlIG9mIHRhcmdldCBvdmVybGFwcGluZyB3aXRoIGFjdGl2ZSBvYmplY3RcbiAgICAgKiB2YWx1ZXM6ICdhbHRLZXknLCAnc2hpZnRLZXknLCAnY3RybEtleScuXG4gICAgICogRm9yIGEgc2VyaWVzIG9mIHJlYXNvbiB0aGF0IGNvbWUgZnJvbSB0aGUgZ2VuZXJhbCBleHBlY3RhdGlvbnMgb24gaG93XG4gICAgICogdGhpbmdzIHNob3VsZCB3b3JrLCB0aGlzIGZlYXR1cmUgd29ya3Mgb25seSBmb3IgcHJlc2VydmVPYmplY3RTdGFja2luZyB0cnVlLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi41XG4gICAgICogQHR5cGUgbnVsbHxTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFsdFNlbGVjdGlvbktleTogICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBzZWxlY3Rpb25cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkNvbG9yOiAgICAgICAgICdyZ2JhKDEwMCwgMTAwLCAyNTUsIDAuMyknLCAvLyBibHVlXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGRhc2ggYXJyYXkgcGF0dGVyblxuICAgICAqIElmIG5vdCBlbXB0eSB0aGUgc2VsZWN0aW9uIGJvcmRlciBpcyBkYXNoZWRcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHNlbGVjdGlvbkRhc2hBcnJheTogICAgIFtdLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgdGhlIGJvcmRlciBvZiBzZWxlY3Rpb24gKHVzdWFsbHkgc2xpZ2h0bHkgZGFya2VyIHRoYW4gY29sb3Igb2Ygc2VsZWN0aW9uIGl0c2VsZilcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkJvcmRlckNvbG9yOiAgICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyknLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgYSBsaW5lIHVzZWQgaW4gb2JqZWN0L2dyb3VwIHNlbGVjdGlvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uTGluZVdpZHRoOiAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBvbmx5IHNoYXBlcyB0aGF0IGFyZSBmdWxseSBjb250YWluZWQgaW4gdGhlIGRyYWdnZWQgc2VsZWN0aW9uIHJlY3RhbmdsZS5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25GdWxseUNvbnRhaW5lZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIHdoZW4gaG92ZXJpbmcgb3ZlciBhbiBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBob3ZlckN1cnNvcjogICAgICAgICAgICAnbW92ZScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIHdoZW4gbW92aW5nIGFuIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1vdmVDdXJzb3I6ICAgICAgICAgICAgICdtb3ZlJyxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgZm9yIHRoZSBlbnRpcmUgY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBkZWZhdWx0Q3Vyc29yOiAgICAgICAgICAnZGVmYXVsdCcsXG5cbiAgICAvKipcbiAgICAgKiBDdXJzb3IgdmFsdWUgdXNlZCBkdXJpbmcgZnJlZSBkcmF3aW5nXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmcmVlRHJhd2luZ0N1cnNvcjogICAgICAnY3Jvc3NoYWlyJyxcblxuICAgIC8qKlxuICAgICAqIEN1cnNvciB2YWx1ZSB1c2VkIGZvciBkaXNhYmxlZCBlbGVtZW50cyAoIGNvcm5lcnMgd2l0aCBkaXNhYmxlZCBhY3Rpb24gKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbm90QWxsb3dlZEN1cnNvcjogICAgICAgICAnbm90LWFsbG93ZWQnLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBlbGVtZW50IGNsYXNzIHRoYXQncyBnaXZlbiB0byB3cmFwcGVyIChkaXYpIGVsZW1lbnQgb2YgY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb250YWluZXJDbGFzczogICAgICAgICAnY2FudmFzLWNvbnRhaW5lcicsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdCBkZXRlY3Rpb24gaGFwcGVucyBvbiBwZXItcGl4ZWwgYmFzaXMgcmF0aGVyIHRoYW4gb24gcGVyLWJvdW5kaW5nLWJveFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBlclBpeGVsVGFyZ2V0RmluZDogICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHBpeGVscyBhcm91bmQgdGFyZ2V0IHBpeGVsIHRvIHRvbGVyYXRlIChjb25zaWRlciBhY3RpdmUpIGR1cmluZyBvYmplY3QgZGV0ZWN0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0YXJnZXRGaW5kVG9sZXJhbmNlOiAgICAwLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCB0YXJnZXQgZGV0ZWN0aW9uIGlzIHNraXBwZWQuIFRhcmdldCBkZXRlY3Rpb24gd2lsbCByZXR1cm4gYWx3YXlzIHVuZGVmaW5lZC5cbiAgICAgKiBjbGljayBzZWxlY3Rpb24gd29uJ3Qgd29yayBhbnltb3JlLCBldmVudHMgd2lsbCBmaXJlIHdpdGggbm8gdGFyZ2V0cy5cbiAgICAgKiBpZiBzb21ldGhpbmcgaXMgc2VsZWN0ZWQgYmVmb3JlIHNldHRpbmcgaXQgdG8gdHJ1ZSwgaXQgd2lsbCBiZSBkZXNlbGVjdGVkIGF0IHRoZSBmaXJzdCBjbGljay5cbiAgICAgKiBhcmVhIHNlbGVjdGlvbiB3aWxsIHN0aWxsIHdvcmsuIGNoZWNrIHRoZSBgc2VsZWN0aW9uYCBwcm9wZXJ0eSB0b28uXG4gICAgICogaWYgeW91IGRlYWN0aXZhdGUgYm90aCwgeW91IHNob3VsZCBsb29rIGludG8gc3RhdGljQ2FudmFzLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNraXBUYXJnZXRGaW5kOiAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBtb3VzZSBldmVudHMgb24gY2FudmFzIChtb3VzZWRvd24vbW91c2Vtb3ZlL21vdXNldXApIHJlc3VsdCBpbiBmcmVlIGRyYXdpbmcuXG4gICAgICogQWZ0ZXIgbW91c2Vkb3duLCBtb3VzZW1vdmUgY3JlYXRlcyBhIHNoYXBlLFxuICAgICAqIGFuZCB0aGVuIG1vdXNldXAgZmluYWxpemVzIGl0IGFuZCBhZGRzIGFuIGluc3RhbmNlIG9mIGBmYWJyaWMuUGF0aGAgb250byBjYW52YXMuXG4gICAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTQjZnJlZV9kcmF3aW5nfVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGlzRHJhd2luZ01vZGU6ICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgb2JqZWN0cyBzaG91bGQgcmVtYWluIGluIGN1cnJlbnQgc3RhY2sgcG9zaXRpb24gd2hlbiBzZWxlY3RlZC5cbiAgICAgKiBXaGVuIGZhbHNlIG9iamVjdHMgYXJlIGJyb3VnaHQgdG8gdG9wIGFuZCByZW5kZXJlZCBhcyBwYXJ0IG9mIHRoZSBzZWxlY3Rpb24gZ3JvdXBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwcmVzZXJ2ZU9iamVjdFN0YWNraW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgYW5nbGUgdGhhdCBhbiBvYmplY3Qgd2lsbCBsb2NrIHRvIHdoaWxlIHJvdGF0aW5nLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBzaW5jZSAxLjYuN1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc25hcEFuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBzbmFwQW5nbGUgdGhlIHJvdGF0aW9uIHdpbGwgbG9jayB0byB0aGUgc25hcEFuZ2xlLlxuICAgICAqIFdoZW4gYG51bGxgLCB0aGUgc25hcFRocmVzaG9sZCB3aWxsIGRlZmF1bHQgdG8gdGhlIHNuYXBBbmdsZS5cbiAgICAgKiBAdHlwZSBudWxsfE51bWJlclxuICAgICAqIEBzaW5jZSAxLjYuN1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc25hcFRocmVzaG9sZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgcmlnaHQgY2xpY2sgb24gY2FudmFzIGNhbiBvdXRwdXQgdGhlIGNvbnRleHQgbWVudSBvciBub3RcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDEuNi41XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdG9wQ29udGV4dE1lbnU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBjYW52YXMgY2FuIGZpcmUgcmlnaHQgY2xpY2sgZXZlbnRzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAxLjYuNVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlyZVJpZ2h0Q2xpY2s6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBjYW52YXMgY2FuIGZpcmUgbWlkZGxlIGNsaWNrIGV2ZW50c1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMS43LjhcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZpcmVNaWRkbGVDbGljazogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBLZWVwIHRyYWNrIG9mIHRoZSBzdWJUYXJnZXRzIGZvciBNb3VzZSBFdmVudHNcbiAgICAgKiBAdHlwZSBmYWJyaWMuT2JqZWN0W11cbiAgICAgKi9cbiAgICB0YXJnZXRzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIG9wdGlvbiBpcyBlbmFibGVkLCBQb2ludGVyRXZlbnQgaXMgdXNlZCBpbnN0ZWFkIG9mIE1vdXNlRXZlbnQuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZW5hYmxlUG9pbnRlckV2ZW50czogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBLZWVwIHRyYWNrIG9mIHRoZSBob3ZlcmVkIHRhcmdldFxuICAgICAqIEB0eXBlIGZhYnJpYy5PYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9ob3ZlcmVkVGFyZ2V0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogaG9sZCB0aGUgbGlzdCBvZiBuZXN0ZWQgdGFyZ2V0cyBob3ZlcmVkXG4gICAgICogQHR5cGUgZmFicmljLk9iamVjdFtdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaG92ZXJlZFRhcmdldHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEludGVyYWN0aXZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSBudWxsO1xuICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IG51bGw7XG4gICAgICB0aGlzLl9pbml0V3JhcHBlckVsZW1lbnQoKTtcbiAgICAgIHRoaXMuX2NyZWF0ZVVwcGVyQ2FudmFzKCk7XG4gICAgICB0aGlzLl9pbml0RXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgICAgdGhpcy5faW5pdFJldGluYVNjYWxpbmcoKTtcblxuICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoID0gZmFicmljLlBlbmNpbEJydXNoICYmIG5ldyBmYWJyaWMuUGVuY2lsQnJ1c2godGhpcyk7XG5cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIG9iamVjdHMgaW4gdHdvIGdyb3Vwcywgb25lIHRvIHJlbmRlciBpbW1lZGlhdGVseVxuICAgICAqIGFuZCBvbmUgdG8gcmVuZGVyIGFzIGFjdGl2ZUdyb3VwLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvYmplY3RzIHRvIHJlbmRlciBpbW1lZGlhdGVseSBhbmQgcHVzaGVzIHRoZSBvdGhlciBpbiB0aGUgYWN0aXZlR3JvdXAuXG4gICAgICovXG4gICAgX2Nob29zZU9iamVjdHNUb1JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0cyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLFxuICAgICAgICAgIG9iamVjdCwgb2Jqc1RvUmVuZGVyLCBhY3RpdmVHcm91cE9iamVjdHM7XG5cbiAgICAgIGlmIChhY3RpdmVPYmplY3RzLmxlbmd0aCA+IDAgJiYgIXRoaXMucHJlc2VydmVPYmplY3RTdGFja2luZykge1xuICAgICAgICBvYmpzVG9SZW5kZXIgPSBbXTtcbiAgICAgICAgYWN0aXZlR3JvdXBPYmplY3RzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb2JqZWN0ID0gdGhpcy5fb2JqZWN0c1tpXTtcbiAgICAgICAgICBpZiAoYWN0aXZlT2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPT09IC0xICkge1xuICAgICAgICAgICAgb2Jqc1RvUmVuZGVyLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVHcm91cE9iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aXZlT2JqZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy5fYWN0aXZlT2JqZWN0Ll9vYmplY3RzID0gYWN0aXZlR3JvdXBPYmplY3RzO1xuICAgICAgICB9XG4gICAgICAgIG9ianNUb1JlbmRlci5wdXNoLmFwcGx5KG9ianNUb1JlbmRlciwgYWN0aXZlR3JvdXBPYmplY3RzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvYmpzVG9SZW5kZXIgPSB0aGlzLl9vYmplY3RzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ianNUb1JlbmRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBib3RoIHRoZSB0b3AgY2FudmFzIGFuZCB0aGUgc2Vjb25kYXJ5IGNvbnRhaW5lciBjYW52YXMuXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0VG9wRGlydHkgJiYgIXRoaXMuX2dyb3VwU2VsZWN0b3IgJiYgIXRoaXMuaXNEcmF3aW5nTW9kZSkge1xuICAgICAgICB0aGlzLmNsZWFyQ29udGV4dCh0aGlzLmNvbnRleHRUb3ApO1xuICAgICAgICB0aGlzLmNvbnRleHRUb3BEaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzTG9zdENvbnRleHQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUb3BMYXllcih0aGlzLmNvbnRleHRUb3ApO1xuICAgICAgICB0aGlzLmhhc0xvc3RDb250ZXh0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzVG9EcmF3T24gPSB0aGlzLmNvbnRleHRDb250YWluZXI7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyhjYW52YXNUb0RyYXdPbiwgdGhpcy5fY2hvb3NlT2JqZWN0c1RvUmVuZGVyKCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbmRlclRvcExheWVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBpZiAodGhpcy5pc0RyYXdpbmdNb2RlICYmIHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2ggJiYgdGhpcy5mcmVlRHJhd2luZ0JydXNoLl9yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0VG9wRGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gd2UgcmVuZGVyIHRoZSB0b3AgY29udGV4dCAtIGxhc3Qgb2JqZWN0XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb24gJiYgdGhpcy5fZ3JvdXBTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLl9kcmF3U2VsZWN0aW9uKGN0eCk7XG4gICAgICAgIHRoaXMuY29udGV4dFRvcERpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byByZW5kZXIgb25seSB0aGUgdG9wIGNhbnZhcy5cbiAgICAgKiBBbHNvIHVzZWQgdG8gcmVuZGVyIHRoZSBncm91cCBzZWxlY3Rpb24gYm94LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyVG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0VG9wO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgIHRoaXMucmVuZGVyVG9wTGF5ZXIoY3R4KTtcbiAgICAgIHRoaXMuZmlyZSgnYWZ0ZXI6cmVuZGVyJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbm9ybWFsaXplUG9pbnRlcjogZnVuY3Rpb24gKG9iamVjdCwgcG9pbnRlcikge1xuICAgICAgdmFyIG0gPSBvYmplY3QuY2FsY1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAgIGludmVydGVkTSA9IGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybShtKSxcbiAgICAgICAgICB2cHRQb2ludGVyID0gdGhpcy5yZXN0b3JlUG9pbnRlclZwdChwb2ludGVyKTtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludCh2cHRQb2ludGVyLCBpbnZlcnRlZE0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIHRyYW5zcGFyZW50IGF0IGEgY2VydGFpbiBsb2NhdGlvblxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0IE9iamVjdCB0byBjaGVja1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IExlZnQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRvcCBjb29yZGluYXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1RhcmdldFRyYW5zcGFyZW50OiBmdW5jdGlvbiAodGFyZ2V0LCB4LCB5KSB7XG4gICAgICAvLyBpbiBjYXNlIHRoZSB0YXJnZXQgaXMgdGhlIGFjdGl2ZU9iamVjdCwgd2UgY2Fubm90IGV4ZWN1dGUgdGhpcyBvcHRpbWl6YXRpb25cbiAgICAgIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBkcmF3IGNvbnRyb2xzIHRvby5cbiAgICAgIGlmICh0YXJnZXQuc2hvdWxkQ2FjaGUoKSAmJiB0YXJnZXQuX2NhY2hlQ2FudmFzICYmIHRhcmdldCAhPT0gdGhpcy5fYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkUG9pbnRlciA9IHRoaXMuX25vcm1hbGl6ZVBvaW50ZXIodGFyZ2V0LCB7eDogeCwgeTogeX0pLFxuICAgICAgICAgICAgdGFyZ2V0UmVsYXRpdmVYID0gTWF0aC5tYXgodGFyZ2V0LmNhY2hlVHJhbnNsYXRpb25YICsgKG5vcm1hbGl6ZWRQb2ludGVyLnggKiB0YXJnZXQuem9vbVgpLCAwKSxcbiAgICAgICAgICAgIHRhcmdldFJlbGF0aXZlWSA9IE1hdGgubWF4KHRhcmdldC5jYWNoZVRyYW5zbGF0aW9uWSArIChub3JtYWxpemVkUG9pbnRlci55ICogdGFyZ2V0Lnpvb21ZKSwgMCk7XG5cbiAgICAgICAgdmFyIGlzVHJhbnNwYXJlbnQgPSBmYWJyaWMudXRpbC5pc1RyYW5zcGFyZW50KFxuICAgICAgICAgIHRhcmdldC5fY2FjaGVDb250ZXh0LCBNYXRoLnJvdW5kKHRhcmdldFJlbGF0aXZlWCksIE1hdGgucm91bmQodGFyZ2V0UmVsYXRpdmVZKSwgdGhpcy50YXJnZXRGaW5kVG9sZXJhbmNlKTtcblxuICAgICAgICByZXR1cm4gaXNUcmFuc3BhcmVudDtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dENhY2hlLFxuICAgICAgICAgIG9yaWdpbmFsQ29sb3IgPSB0YXJnZXQuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yLCB2ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybTtcblxuICAgICAgdGFyZ2V0LnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciA9ICcnO1xuXG4gICAgICB0aGlzLmNsZWFyQ29udGV4dChjdHgpO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgIHRhcmdldC5yZW5kZXIoY3R4KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIHRhcmdldC5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IgPSBvcmlnaW5hbENvbG9yO1xuXG4gICAgICB2YXIgaXNUcmFuc3BhcmVudCA9IGZhYnJpYy51dGlsLmlzVHJhbnNwYXJlbnQoXG4gICAgICAgIGN0eCwgeCwgeSwgdGhpcy50YXJnZXRGaW5kVG9sZXJhbmNlKTtcblxuICAgICAgcmV0dXJuIGlzVHJhbnNwYXJlbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRha2VzIGFuIGV2ZW50IGFuZCBkZXRlcm1pbmVzIGlmIHNlbGVjdGlvbiBrZXkgaGFzIGJlZW4gcHJlc3NlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfaXNTZWxlY3Rpb25LZXlQcmVzc2VkOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uS2V5UHJlc3NlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnNlbGVjdGlvbktleSkpIHtcbiAgICAgICAgc2VsZWN0aW9uS2V5UHJlc3NlZCA9ICEhdGhpcy5zZWxlY3Rpb25LZXkuZmluZChmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGVba2V5XSA9PT0gdHJ1ZTsgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uS2V5UHJlc3NlZCA9IGVbdGhpcy5zZWxlY3Rpb25LZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZWN0aW9uS2V5UHJlc3NlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX3Nob3VsZENsZWFyU2VsZWN0aW9uOiBmdW5jdGlvbiAoZSwgdGFyZ2V0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0cyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLFxuICAgICAgICAgIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgIXRhcmdldFxuICAgICAgICB8fFxuICAgICAgICAodGFyZ2V0ICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0cy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0cy5pbmRleE9mKHRhcmdldCkgPT09IC0xICYmXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ICE9PSB0YXJnZXQgJiZcbiAgICAgICAgICAhdGhpcy5faXNTZWxlY3Rpb25LZXlQcmVzc2VkKGUpKVxuICAgICAgICB8fFxuICAgICAgICAodGFyZ2V0ICYmICF0YXJnZXQuZXZlbnRlZClcbiAgICAgICAgfHxcbiAgICAgICAgKHRhcmdldCAmJlxuICAgICAgICAgICF0YXJnZXQuc2VsZWN0YWJsZSAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdCAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdCAhPT0gdGFyZ2V0KVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2VudGVyZWRTY2FsaW5nIGZyb20gb2JqZWN0IGNhbid0IG92ZXJyaWRlIGNlbnRlcmVkU2NhbGluZyBmcm9tIGNhbnZhcy5cbiAgICAgKiB0aGlzIHNob3VsZCBiZSBmaXhlZCwgc2luY2Ugb2JqZWN0IHNldHRpbmcgc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyIGNhbnZhcy5cbiAgICAgKiBhbHNvIHRoaXMgc2hvdWxkIGJlIHNvbWV0aGluZyB0aGF0IHdpbGwgYmUgbWlncmF0ZWQgaW4gdGhlIGNvbnRyb2wgcHJvcGVydGllcy5cbiAgICAgKiBhcyBhYmlsaXR5IHRvIGRlZmluZSB0aGUgb3JpZ2luIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbiB0aGF0IHRoZSBjb250cm9sIHByb3ZpZGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFsdEtleVxuICAgICAqL1xuICAgIF9zaG91bGRDZW50ZXJUcmFuc2Zvcm06IGZ1bmN0aW9uICh0YXJnZXQsIGFjdGlvbiwgYWx0S2V5KSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjZW50ZXJUcmFuc2Zvcm07XG5cbiAgICAgIGlmIChhY3Rpb24gPT09ICdzY2FsZScgfHwgYWN0aW9uID09PSAnc2NhbGVYJyB8fCBhY3Rpb24gPT09ICdzY2FsZVknIHx8IGFjdGlvbiA9PT0gJ3Jlc2l6aW5nJykge1xuICAgICAgICBjZW50ZXJUcmFuc2Zvcm0gPSB0aGlzLmNlbnRlcmVkU2NhbGluZyB8fCB0YXJnZXQuY2VudGVyZWRTY2FsaW5nO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAncm90YXRlJykge1xuICAgICAgICBjZW50ZXJUcmFuc2Zvcm0gPSB0aGlzLmNlbnRlcmVkUm90YXRpb24gfHwgdGFyZ2V0LmNlbnRlcmVkUm90YXRpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjZW50ZXJUcmFuc2Zvcm0gPyAhYWx0S2V5IDogYWx0S2V5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzaG91bGQgZGlzYXBwZWFyIGJlZm9yZSByZWxlYXNlIDQuMFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldE9yaWdpbkZyb21Db3JuZXI6IGZ1bmN0aW9uKHRhcmdldCwgY29ybmVyKSB7XG4gICAgICB2YXIgb3JpZ2luID0ge1xuICAgICAgICB4OiB0YXJnZXQub3JpZ2luWCxcbiAgICAgICAgeTogdGFyZ2V0Lm9yaWdpbllcbiAgICAgIH07XG5cbiAgICAgIGlmIChjb3JuZXIgPT09ICdtbCcgfHwgY29ybmVyID09PSAndGwnIHx8IGNvcm5lciA9PT0gJ2JsJykge1xuICAgICAgICBvcmlnaW4ueCA9ICdyaWdodCc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgPT09ICdtcicgfHwgY29ybmVyID09PSAndHInIHx8IGNvcm5lciA9PT0gJ2JyJykge1xuICAgICAgICBvcmlnaW4ueCA9ICdsZWZ0JztcbiAgICAgIH1cblxuICAgICAgaWYgKGNvcm5lciA9PT0gJ3RsJyB8fCBjb3JuZXIgPT09ICdtdCcgfHwgY29ybmVyID09PSAndHInKSB7XG4gICAgICAgIG9yaWdpbi55ID0gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjb3JuZXIgPT09ICdibCcgfHwgY29ybmVyID09PSAnbWInIHx8IGNvcm5lciA9PT0gJ2JyJykge1xuICAgICAgICBvcmlnaW4ueSA9ICd0b3AnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFscmVhZHlTZWxlY3RlZCB0cnVlIGlmIHRhcmdldCBpcyBhbHJlYWR5IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvcm5lciBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGNvcm5lciBtbCwgbXIsIHRsIC4uLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBbdGFyZ2V0XSBpbnNlcnRlZCBiYWNrIHRvIGhlbHAgb3ZlcnJpZGluZy4gVW51c2VkXG4gICAgICovXG4gICAgX2dldEFjdGlvbkZyb21Db3JuZXI6IGZ1bmN0aW9uKGFscmVhZHlTZWxlY3RlZCwgY29ybmVyLCBlLCB0YXJnZXQpIHtcbiAgICAgIGlmICghY29ybmVyIHx8ICFhbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuICdkcmFnJztcbiAgICAgIH1cbiAgICAgIHZhciBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW2Nvcm5lcl07XG4gICAgICByZXR1cm4gY29udHJvbC5nZXRBY3Rpb25OYW1lKGUsIGNvbnRyb2wsIHRhcmdldCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9zZXR1cEN1cnJlbnRUcmFuc2Zvcm06IGZ1bmN0aW9uIChlLCB0YXJnZXQsIGFscmVhZHlTZWxlY3RlZCkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKSwgY29ybmVyID0gdGFyZ2V0Ll9fY29ybmVyLFxuICAgICAgICAgIGNvbnRyb2wgPSB0YXJnZXQuY29udHJvbHNbY29ybmVyXSxcbiAgICAgICAgICBhY3Rpb25IYW5kbGVyID0gKGFscmVhZHlTZWxlY3RlZCAmJiBjb3JuZXIpID9cbiAgICAgICAgICAgIGNvbnRyb2wuZ2V0QWN0aW9uSGFuZGxlcihlLCB0YXJnZXQsIGNvbnRyb2wpIDogZmFicmljLmNvbnRyb2xzVXRpbHMuZHJhZ0hhbmRsZXIsXG4gICAgICAgICAgYWN0aW9uID0gdGhpcy5fZ2V0QWN0aW9uRnJvbUNvcm5lcihhbHJlYWR5U2VsZWN0ZWQsIGNvcm5lciwgZSwgdGFyZ2V0KSxcbiAgICAgICAgICBvcmlnaW4gPSB0aGlzLl9nZXRPcmlnaW5Gcm9tQ29ybmVyKHRhcmdldCwgY29ybmVyKSxcbiAgICAgICAgICBhbHRLZXkgPSBlW3RoaXMuY2VudGVyZWRLZXldLFxuICAgICAgICAgIHRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBhY3Rpb25IYW5kbGVyOiBhY3Rpb25IYW5kbGVyLFxuICAgICAgICAgICAgY29ybmVyOiBjb3JuZXIsXG4gICAgICAgICAgICBzY2FsZVg6IHRhcmdldC5zY2FsZVgsXG4gICAgICAgICAgICBzY2FsZVk6IHRhcmdldC5zY2FsZVksXG4gICAgICAgICAgICBza2V3WDogdGFyZ2V0LnNrZXdYLFxuICAgICAgICAgICAgc2tld1k6IHRhcmdldC5za2V3WSxcbiAgICAgICAgICAgIC8vIHVzZWQgYnkgdHJhbnNhdGlvblxuICAgICAgICAgICAgb2Zmc2V0WDogcG9pbnRlci54IC0gdGFyZ2V0LmxlZnQsXG4gICAgICAgICAgICBvZmZzZXRZOiBwb2ludGVyLnkgLSB0YXJnZXQudG9wLFxuICAgICAgICAgICAgb3JpZ2luWDogb3JpZ2luLngsXG4gICAgICAgICAgICBvcmlnaW5ZOiBvcmlnaW4ueSxcbiAgICAgICAgICAgIGV4OiBwb2ludGVyLngsXG4gICAgICAgICAgICBleTogcG9pbnRlci55LFxuICAgICAgICAgICAgbGFzdFg6IHBvaW50ZXIueCxcbiAgICAgICAgICAgIGxhc3RZOiBwb2ludGVyLnksXG4gICAgICAgICAgICAvLyB1bnN1cmUgdGhleSBhcmUgdXNlZnVsIGFueW1vcmUuXG4gICAgICAgICAgICAvLyBsZWZ0OiB0YXJnZXQubGVmdCxcbiAgICAgICAgICAgIC8vIHRvcDogdGFyZ2V0LnRvcCxcbiAgICAgICAgICAgIHRoZXRhOiBkZWdyZWVzVG9SYWRpYW5zKHRhcmdldC5hbmdsZSksXG4gICAgICAgICAgICAvLyBlbmQgb2YgdW5zdXJlXG4gICAgICAgICAgICB3aWR0aDogdGFyZ2V0LndpZHRoICogdGFyZ2V0LnNjYWxlWCxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICAgICAgICAgICAgYWx0S2V5OiBhbHRLZXksXG4gICAgICAgICAgICBvcmlnaW5hbDogZmFicmljLnV0aWwuc2F2ZU9iamVjdFRyYW5zZm9ybSh0YXJnZXQpLFxuICAgICAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9zaG91bGRDZW50ZXJUcmFuc2Zvcm0odGFyZ2V0LCBhY3Rpb24sIGFsdEtleSkpIHtcbiAgICAgICAgdHJhbnNmb3JtLm9yaWdpblggPSAnY2VudGVyJztcbiAgICAgICAgdHJhbnNmb3JtLm9yaWdpblkgPSAnY2VudGVyJztcbiAgICAgIH1cbiAgICAgIHRyYW5zZm9ybS5vcmlnaW5hbC5vcmlnaW5YID0gb3JpZ2luLng7XG4gICAgICB0cmFuc2Zvcm0ub3JpZ2luYWwub3JpZ2luWSA9IG9yaWdpbi55O1xuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgIHRoaXMuX2JlZm9yZVRyYW5zZm9ybShlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJzb3IgdHlwZSBvZiB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgQ3Vyc29yIHR5cGUgb2YgdGhlIGNhbnZhcyBlbGVtZW50LlxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy11aS8jY3Vyc29yXG4gICAgICovXG4gICAgc2V0Q3Vyc29yOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXMudXBwZXJDYW52YXNFbC5zdHlsZS5jdXJzb3IgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IHRvIGRyYXcgdGhlIHNlbGVjdGlvbiBvblxuICAgICAqL1xuICAgIF9kcmF3U2VsZWN0aW9uOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLl9ncm91cFNlbGVjdG9yLFxuICAgICAgICAgIHZpZXdwb3J0U3RhcnQgPSBuZXcgZmFicmljLlBvaW50KHNlbGVjdG9yLmV4LCBzZWxlY3Rvci5leSksXG4gICAgICAgICAgc3RhcnQgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludCh2aWV3cG9ydFN0YXJ0LCB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKSxcbiAgICAgICAgICB2aWV3cG9ydEV4dGVudCA9IG5ldyBmYWJyaWMuUG9pbnQoc2VsZWN0b3IuZXggKyBzZWxlY3Rvci5sZWZ0LCBzZWxlY3Rvci5leSArIHNlbGVjdG9yLnRvcCksXG4gICAgICAgICAgZXh0ZW50ID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQodmlld3BvcnRFeHRlbnQsIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pLFxuICAgICAgICAgIG1pblggPSBNYXRoLm1pbihzdGFydC54LCBleHRlbnQueCksXG4gICAgICAgICAgbWluWSA9IE1hdGgubWluKHN0YXJ0LnksIGV4dGVudC55KSxcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgoc3RhcnQueCwgZXh0ZW50LngpLFxuICAgICAgICAgIG1heFkgPSBNYXRoLm1heChzdGFydC55LCBleHRlbnQueSksXG4gICAgICAgICAgc3Ryb2tlT2Zmc2V0ID0gdGhpcy5zZWxlY3Rpb25MaW5lV2lkdGggLyAyO1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25Db2xvcikge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KG1pblgsIG1pblksIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25MaW5lV2lkdGggfHwgIXRoaXMuc2VsZWN0aW9uQm9yZGVyQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc2VsZWN0aW9uTGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zZWxlY3Rpb25Cb3JkZXJDb2xvcjtcblxuICAgICAgbWluWCArPSBzdHJva2VPZmZzZXQ7XG4gICAgICBtaW5ZICs9IHN0cm9rZU9mZnNldDtcbiAgICAgIG1heFggLT0gc3Ryb2tlT2Zmc2V0O1xuICAgICAgbWF4WSAtPSBzdHJva2VPZmZzZXQ7XG4gICAgICAvLyBzZWxlY3Rpb24gYm9yZGVyXG4gICAgICBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5fc2V0TGluZURhc2guY2FsbCh0aGlzLCBjdHgsIHRoaXMuc2VsZWN0aW9uRGFzaEFycmF5KTtcbiAgICAgIGN0eC5zdHJva2VSZWN0KG1pblgsIG1pblksIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRldGVybWluZXMgd2hhdCBvYmplY3Qgd2UgYXJlIGNsaWNraW5nIG9uXG4gICAgICogdGhlIHNraXBHcm91cCBwYXJhbWV0ZXIgaXMgZm9yIGludGVybmFsIHVzZSwgaXMgbmVlZGVkIGZvciBzaGlmdCtjbGljayBhY3Rpb25cbiAgICAgKiAxMS8wOS8yMDE4IFRPRE86IHdvdWxkIGJlIGNvb2wgaWYgZmluZFRhcmdldCBjb3VsZCBkaXNjZXJuIGJldHdlZW4gYmVpbmcgYSBmdWxsIHRhcmdldFxuICAgICAqIG9yIHRoZSBvdXRzaWRlIHBhcnQgb2YgdGhlIGNvcm5lci5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwR3JvdXAgd2hlbiB0cnVlLCBhY3RpdmVHcm91cCBpcyBza2lwcGVkIGFuZCBvbmx5IG9iamVjdHMgYXJlIHRyYXZlcnNlZCB0aHJvdWdoXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhlIHRhcmdldCBmb3VuZFxuICAgICAqL1xuICAgIGZpbmRUYXJnZXQ6IGZ1bmN0aW9uIChlLCBza2lwR3JvdXApIHtcbiAgICAgIGlmICh0aGlzLnNraXBUYXJnZXRGaW5kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlnbm9yZVpvb20gPSB0cnVlLFxuICAgICAgICAgIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSwgaWdub3JlWm9vbSksXG4gICAgICAgICAgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGFPYmplY3RzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksXG4gICAgICAgICAgYWN0aXZlVGFyZ2V0LCBhY3RpdmVUYXJnZXRTdWJzLFxuICAgICAgICAgIGlzVG91Y2ggPSBpc1RvdWNoRXZlbnQoZSksXG4gICAgICAgICAgc2hvdWxkTG9va0ZvckFjdGl2ZSA9IChhT2JqZWN0cy5sZW5ndGggPiAxICYmICFza2lwR3JvdXApIHx8IGFPYmplY3RzLmxlbmd0aCA9PT0gMTtcblxuICAgICAgLy8gZmlyc3QgY2hlY2sgY3VycmVudCBncm91cCAoaWYgb25lIGV4aXN0cylcbiAgICAgIC8vIGFjdGl2ZSBncm91cCBkb2VzIG5vdCBjaGVjayBzdWIgdGFyZ2V0cyBsaWtlIG5vcm1hbCBncm91cHMuXG4gICAgICAvLyBpZiBhY3RpdmUgZ3JvdXAganVzdCBleGl0cy5cbiAgICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuXG4gICAgICAvLyBpZiB3ZSBoaXQgdGhlIGNvcm5lciBvZiBhbiBhY3RpdmVPYmplY3QsIGxldCdzIHJldHVybiB0aGF0LlxuICAgICAgaWYgKHNob3VsZExvb2tGb3JBY3RpdmUgJiYgYWN0aXZlT2JqZWN0Ll9maW5kVGFyZ2V0Q29ybmVyKHBvaW50ZXIsIGlzVG91Y2gpKSB7XG4gICAgICAgIHJldHVybiBhY3RpdmVPYmplY3Q7XG4gICAgICB9XG4gICAgICBpZiAoYU9iamVjdHMubGVuZ3RoID4gMSAmJiAhc2tpcEdyb3VwICYmIGFjdGl2ZU9iamVjdCA9PT0gdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKFthY3RpdmVPYmplY3RdLCBwb2ludGVyKSkge1xuICAgICAgICByZXR1cm4gYWN0aXZlT2JqZWN0O1xuICAgICAgfVxuICAgICAgaWYgKGFPYmplY3RzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBhY3RpdmVPYmplY3QgPT09IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyhbYWN0aXZlT2JqZWN0XSwgcG9pbnRlcikpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlT2JqZWN0U3RhY2tpbmcpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlT2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFjdGl2ZVRhcmdldCA9IGFjdGl2ZU9iamVjdDtcbiAgICAgICAgICBhY3RpdmVUYXJnZXRTdWJzID0gdGhpcy50YXJnZXRzO1xuICAgICAgICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fc2VhcmNoUG9zc2libGVUYXJnZXRzKHRoaXMuX29iamVjdHMsIHBvaW50ZXIpO1xuICAgICAgaWYgKGVbdGhpcy5hbHRTZWxlY3Rpb25LZXldICYmIHRhcmdldCAmJiBhY3RpdmVUYXJnZXQgJiYgdGFyZ2V0ICE9PSBhY3RpdmVUYXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0ID0gYWN0aXZlVGFyZ2V0O1xuICAgICAgICB0aGlzLnRhcmdldHMgPSBhY3RpdmVUYXJnZXRTdWJzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcG9pbnRlcl0geCx5IG9iamVjdCBvZiBwb2ludCBjb29yZGluYXRlcyB3ZSB3YW50IHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIE9iamVjdCB0byB0ZXN0IGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2dsb2JhbFBvaW50ZXJdIHgseSBvYmplY3Qgb2YgcG9pbnQgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gY2FudmFzIHVzZWQgdG8gc2VhcmNoIHBlciBwaXhlbCB0YXJnZXQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIGFuIGFyZWEgb2YgZ2l2ZW4gb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hlY2tUYXJnZXQ6IGZ1bmN0aW9uKHBvaW50ZXIsIG9iaiwgZ2xvYmFsUG9pbnRlcikge1xuICAgICAgaWYgKG9iaiAmJlxuICAgICAgICAgIG9iai52aXNpYmxlICYmXG4gICAgICAgICAgb2JqLmV2ZW50ZWQgJiZcbiAgICAgICAgICAvLyBodHRwOi8vd3d3Lmdlb2cudWJjLmNhL2NvdXJzZXMva2xpbmsvZ2lzLm5vdGVzL25jZ2lhL3UzMi5odG1sXG4gICAgICAgICAgLy8gaHR0cDovL2lkYXYudWNkYXZpcy5lZHUvfm9rcmV5bG9zL1RBc2hpcC9TcHJpbmcyMDAwL1BvaW50SW5Qb2x5Z29uLmh0bWxcbiAgICAgICAgICBvYmouY29udGFpbnNQb2ludChwb2ludGVyKVxuICAgICAgKSB7XG4gICAgICAgIGlmICgodGhpcy5wZXJQaXhlbFRhcmdldEZpbmQgfHwgb2JqLnBlclBpeGVsVGFyZ2V0RmluZCkgJiYgIW9iai5pc0VkaXRpbmcpIHtcbiAgICAgICAgICB2YXIgaXNUcmFuc3BhcmVudCA9IHRoaXMuaXNUYXJnZXRUcmFuc3BhcmVudChvYmosIGdsb2JhbFBvaW50ZXIueCwgZ2xvYmFsUG9pbnRlci55KTtcbiAgICAgICAgICBpZiAoIWlzVHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIHNlYXJjaCBpbnNpZGUgb2JqZWN0cyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBwb2ludGVyIGluIGJvdW5kaW5nIGJveCBvciB0aGF0IGNvbnRhaW5zIHBvaW50ZXJPbkNhbnZhcyB3aGVuIHBhaW50ZWRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb2JqZWN0c10gb2JqZWN0cyBhcnJheSB0byBsb29rIGludG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BvaW50ZXJdIHgseSBvYmplY3Qgb2YgcG9pbnQgY29vcmRpbmF0ZXMgd2Ugd2FudCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgdGhhdCBjb250YWlucyBwb2ludGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2VhcmNoUG9zc2libGVUYXJnZXRzOiBmdW5jdGlvbihvYmplY3RzLCBwb2ludGVyKSB7XG4gICAgICAvLyBDYWNoZSBhbGwgdGFyZ2V0cyB3aGVyZSB0aGVpciBib3VuZGluZyBib3ggY29udGFpbnMgcG9pbnQuXG4gICAgICB2YXIgdGFyZ2V0LCBpID0gb2JqZWN0cy5sZW5ndGgsIHN1YlRhcmdldDtcbiAgICAgIC8vIERvIG5vdCBjaGVjayBmb3IgY3VycmVudGx5IGdyb3VwZWQgb2JqZWN0cywgc2luY2Ugd2UgY2hlY2sgdGhlIHBhcmVudCBncm91cCBpdHNlbGYuXG4gICAgICAvLyB1bnRpbCB3ZSBjYWxsIHRoaXMgZnVuY3Rpb24gc3BlY2lmaWNhbGx5IHRvIHNlYXJjaCBpbnNpZGUgdGhlIGFjdGl2ZUdyb3VwXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBvYmpUb0NoZWNrID0gb2JqZWN0c1tpXTtcbiAgICAgICAgdmFyIHBvaW50ZXJUb1VzZSA9IG9ialRvQ2hlY2suZ3JvdXAgP1xuICAgICAgICAgIHRoaXMuX25vcm1hbGl6ZVBvaW50ZXIob2JqVG9DaGVjay5ncm91cCwgcG9pbnRlcikgOiBwb2ludGVyO1xuICAgICAgICBpZiAodGhpcy5fY2hlY2tUYXJnZXQocG9pbnRlclRvVXNlLCBvYmpUb0NoZWNrLCBwb2ludGVyKSkge1xuICAgICAgICAgIHRhcmdldCA9IG9iamVjdHNbaV07XG4gICAgICAgICAgaWYgKHRhcmdldC5zdWJUYXJnZXRDaGVjayAmJiB0YXJnZXQgaW5zdGFuY2VvZiBmYWJyaWMuR3JvdXApIHtcbiAgICAgICAgICAgIHN1YlRhcmdldCA9IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyh0YXJnZXQuX29iamVjdHMsIHBvaW50ZXIpO1xuICAgICAgICAgICAgc3ViVGFyZ2V0ICYmIHRoaXMudGFyZ2V0cy5wdXNoKHN1YlRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHBvaW50ZXIgY29vcmRpbmF0ZXMgd2l0aG91dCB0aGUgZWZmZWN0IG9mIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyIHdpdGggXCJ4XCIgYW5kIFwieVwiIG51bWJlciB2YWx1ZXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB3aXRoIFwieFwiIGFuZCBcInlcIiBudW1iZXIgdmFsdWVzXG4gICAgICovXG4gICAgcmVzdG9yZVBvaW50ZXJWcHQ6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChcbiAgICAgICAgcG9pbnRlcixcbiAgICAgICAgZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHBvaW50ZXIgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gY2FudmFzLlxuICAgICAqIENhbiByZXR1cm4gY29vcmRpbmF0ZXMgd2l0aCBvciB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtLlxuICAgICAqIGlnbm9yZVpvb20gZmFsc2UgZ2l2ZXMgYmFjayBjb29yZGluYXRlcyB0aGF0IHJlcHJlc2VudFxuICAgICAqIHRoZSBwb2ludCBjbGlja2VkIG9uIGNhbnZhcyBlbGVtZW50LlxuICAgICAqIGlnbm9yZVpvb20gdHJ1ZSBnaXZlcyBiYWNrIGNvb3JkaW5hdGVzIGFmdGVyIGJlaW5nIHByb2Nlc3NlZFxuICAgICAqIGJ5IHRoZSB2aWV3cG9ydFRyYW5zZm9ybSAoIHNvcnQgb2YgY29vcmRpbmF0ZXMgb2Ygd2hhdCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBvbiB0aGUgY2FudmFzIHdoZXJlIHlvdSBhcmUgY2xpY2tpbmcuXG4gICAgICogaWdub3JlWm9vbSB0cnVlID0gSFRNTEVsZW1lbnQgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdG9wLGxlZnRcbiAgICAgKiBpZ25vcmVab29tIGZhbHNlLCBkZWZhdWx0ID0gZmFicmljIHNwYWNlIGNvb3JkaW5hdGVzLCB0aGUgc2FtZSB1c2VkIGZvciBzaGFwZSBwb3NpdGlvblxuICAgICAqIFRvIGludGVyYWN0IHdpdGggeW91ciBzaGFwZXMgdG9wIGFuZCBsZWZ0IHlvdSB3YW50IHRvIHVzZSBpZ25vcmVab29tIHRydWVcbiAgICAgKiBtb3N0IG9mIHRoZSB0aW1lLCB3aGlsZSBpZ25vcmVab29tIGZhbHNlIHdpbGwgZ2l2ZSB5b3UgY29vcmRpbmF0ZXNcbiAgICAgKiBjb21wYXRpYmxlIHdpdGggdGhlIG9iamVjdC5vQ29vcmRzIHN5c3RlbS5cbiAgICAgKiBvZiB0aGUgdGltZS5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVab29tXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBcInhcIiBhbmQgXCJ5XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqL1xuICAgIGdldFBvaW50ZXI6IGZ1bmN0aW9uIChlLCBpZ25vcmVab29tKSB7XG4gICAgICAvLyByZXR1cm4gY2FjaGVkIHZhbHVlcyBpZiB3ZSBhcmUgaW4gdGhlIGV2ZW50IHByb2Nlc3NpbmcgY2hhaW5cbiAgICAgIGlmICh0aGlzLl9hYnNvbHV0ZVBvaW50ZXIgJiYgIWlnbm9yZVpvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fic29sdXRlUG9pbnRlcjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wb2ludGVyICYmIGlnbm9yZVpvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50ZXI7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gZ2V0UG9pbnRlcihlKSxcbiAgICAgICAgICB1cHBlckNhbnZhc0VsID0gdGhpcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIGJvdW5kcyA9IHVwcGVyQ2FudmFzRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgYm91bmRzV2lkdGggPSBib3VuZHMud2lkdGggfHwgMCxcbiAgICAgICAgICBib3VuZHNIZWlnaHQgPSBib3VuZHMuaGVpZ2h0IHx8IDAsXG4gICAgICAgICAgY3NzU2NhbGU7XG5cbiAgICAgIGlmICghYm91bmRzV2lkdGggfHwgIWJvdW5kc0hlaWdodCApIHtcbiAgICAgICAgaWYgKCd0b3AnIGluIGJvdW5kcyAmJiAnYm90dG9tJyBpbiBib3VuZHMpIHtcbiAgICAgICAgICBib3VuZHNIZWlnaHQgPSBNYXRoLmFicyggYm91bmRzLnRvcCAtIGJvdW5kcy5ib3R0b20gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3JpZ2h0JyBpbiBib3VuZHMgJiYgJ2xlZnQnIGluIGJvdW5kcykge1xuICAgICAgICAgIGJvdW5kc1dpZHRoID0gTWF0aC5hYnMoIGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0ICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgICBwb2ludGVyLnggPSBwb2ludGVyLnggLSB0aGlzLl9vZmZzZXQubGVmdDtcbiAgICAgIHBvaW50ZXIueSA9IHBvaW50ZXIueSAtIHRoaXMuX29mZnNldC50b3A7XG4gICAgICBpZiAoIWlnbm9yZVpvb20pIHtcbiAgICAgICAgcG9pbnRlciA9IHRoaXMucmVzdG9yZVBvaW50ZXJWcHQocG9pbnRlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXRpbmFTY2FsaW5nID0gdGhpcy5nZXRSZXRpbmFTY2FsaW5nKCk7XG4gICAgICBpZiAocmV0aW5hU2NhbGluZyAhPT0gMSkge1xuICAgICAgICBwb2ludGVyLnggLz0gcmV0aW5hU2NhbGluZztcbiAgICAgICAgcG9pbnRlci55IC89IHJldGluYVNjYWxpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChib3VuZHNXaWR0aCA9PT0gMCB8fCBib3VuZHNIZWlnaHQgPT09IDApIHtcbiAgICAgICAgLy8gSWYgYm91bmRzIGFyZSBub3QgYXZhaWxhYmxlIChpLmUuIG5vdCB2aXNpYmxlKSwgZG8gbm90IGFwcGx5IHNjYWxlLlxuICAgICAgICBjc3NTY2FsZSA9IHsgd2lkdGg6IDEsIGhlaWdodDogMSB9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNzc1NjYWxlID0ge1xuICAgICAgICAgIHdpZHRoOiB1cHBlckNhbnZhc0VsLndpZHRoIC8gYm91bmRzV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB1cHBlckNhbnZhc0VsLmhlaWdodCAvIGJvdW5kc0hlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwb2ludGVyLnggKiBjc3NTY2FsZS53aWR0aCxcbiAgICAgICAgeTogcG9pbnRlci55ICogY3NzU2NhbGUuaGVpZ2h0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0aHJvd3Mge0NBTlZBU19JTklUX0VSUk9SfSBJZiBjYW52YXMgY2FuIG5vdCBiZSBpbml0aWFsaXplZFxuICAgICAqL1xuICAgIF9jcmVhdGVVcHBlckNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxvd2VyQ2FudmFzQ2xhc3MgPSB0aGlzLmxvd2VyQ2FudmFzRWwuY2xhc3NOYW1lLnJlcGxhY2UoL1xccypsb3dlci1jYW52YXNcXHMqLywgJycpLFxuICAgICAgICAgIGxvd2VyQ2FudmFzRWwgPSB0aGlzLmxvd2VyQ2FudmFzRWwsIHVwcGVyQ2FudmFzRWwgPSB0aGlzLnVwcGVyQ2FudmFzRWw7XG5cbiAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gY3JlYXRlIGEgbmV3IHVwcGVyQ2FudmFzIGVsZW1lbnQgaWYgd2UgaGF2ZSBhbHJlYWR5IG9uZS5cbiAgICAgIGlmICh1cHBlckNhbnZhc0VsKSB7XG4gICAgICAgIHVwcGVyQ2FudmFzRWwuY2xhc3NOYW1lID0gJyc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdXBwZXJDYW52YXNFbCA9IHRoaXMuX2NyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy51cHBlckNhbnZhc0VsID0gdXBwZXJDYW52YXNFbDtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy51dGlsLmFkZENsYXNzKHVwcGVyQ2FudmFzRWwsICd1cHBlci1jYW52YXMgJyArIGxvd2VyQ2FudmFzQ2xhc3MpO1xuXG4gICAgICB0aGlzLndyYXBwZXJFbC5hcHBlbmRDaGlsZCh1cHBlckNhbnZhc0VsKTtcblxuICAgICAgdGhpcy5fY29weUNhbnZhc1N0eWxlKGxvd2VyQ2FudmFzRWwsIHVwcGVyQ2FudmFzRWwpO1xuICAgICAgdGhpcy5fYXBwbHlDYW52YXNTdHlsZSh1cHBlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMuY29udGV4dFRvcCA9IHVwcGVyQ2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250ZXh0IG9mIHRvcCBjYW52YXMgd2hlcmUgaW50ZXJhY3Rpb25zIGFyZSBkcmF3blxuICAgICAqIEByZXR1cm5zIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgZ2V0VG9wQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFRvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQ2FjaGVDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FjaGVDYW52YXNFbCA9IHRoaXMuX2NyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIHRoaXMuY2FjaGVDYW52YXNFbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy53aWR0aCk7XG4gICAgICB0aGlzLmNhY2hlQ2FudmFzRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmhlaWdodCk7XG4gICAgICB0aGlzLmNvbnRleHRDYWNoZSA9IHRoaXMuY2FjaGVDYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0V3JhcHBlckVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMud3JhcHBlckVsID0gZmFicmljLnV0aWwud3JhcEVsZW1lbnQodGhpcy5sb3dlckNhbnZhc0VsLCAnZGl2Jywge1xuICAgICAgICAnY2xhc3MnOiB0aGlzLmNvbnRhaW5lckNsYXNzXG4gICAgICB9KTtcbiAgICAgIGZhYnJpYy51dGlsLnNldFN0eWxlKHRoaXMud3JhcHBlckVsLCB7XG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoICsgJ3B4JyxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCArICdweCcsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICB9KTtcbiAgICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50VW5zZWxlY3RhYmxlKHRoaXMud3JhcHBlckVsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IGNhbnZhcyBlbGVtZW50IHRvIGFwcGx5IHN0eWxlcyBvblxuICAgICAqL1xuICAgIF9hcHBseUNhbnZhc1N0eWxlOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCB8fCBlbGVtZW50LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0O1xuXG4gICAgICBmYWJyaWMudXRpbC5zZXRTdHlsZShlbGVtZW50LCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB3aWR0aDogd2lkdGggKyAncHgnLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCArICdweCcsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgJ3RvdWNoLWFjdGlvbic6IHRoaXMuYWxsb3dUb3VjaFNjcm9sbGluZyA/ICdtYW5pcHVsYXRpb24nIDogJ25vbmUnLFxuICAgICAgICAnLW1zLXRvdWNoLWFjdGlvbic6IHRoaXMuYWxsb3dUb3VjaFNjcm9sbGluZyA/ICdtYW5pcHVsYXRpb24nIDogJ25vbmUnXG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQud2lkdGggPSB3aWR0aDtcbiAgICAgIGVsZW1lbnQuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgZmFicmljLnV0aWwubWFrZUVsZW1lbnRVbnNlbGVjdGFibGUoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvcHkgdGhlIGVudGlyZSBpbmxpbmUgc3R5bGUgZnJvbSBvbmUgZWxlbWVudCAoZnJvbUVsKSB0byBhbm90aGVyICh0b0VsKVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBmcm9tRWwgRWxlbWVudCBzdHlsZSBpcyBjb3BpZWQgZnJvbVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdG9FbCBFbGVtZW50IGNvcGllZCBzdHlsZSBpcyBhcHBsaWVkIHRvXG4gICAgICovXG4gICAgX2NvcHlDYW52YXNTdHlsZTogZnVuY3Rpb24gKGZyb21FbCwgdG9FbCkge1xuICAgICAgdG9FbC5zdHlsZS5jc3NUZXh0ID0gZnJvbUVsLnN0eWxlLmNzc1RleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udGV4dCBvZiBjYW52YXMgd2hlcmUgb2JqZWN0IHNlbGVjdGlvbiBpcyBkcmF3blxuICAgICAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25Db250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHRUb3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgJmx0O2NhbnZhcz4gZWxlbWVudCBvbiB3aGljaCBvYmplY3Qgc2VsZWN0aW9uIGlzIGRyYXduXG4gICAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uRWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMudXBwZXJDYW52YXNFbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJyZW50bHkgYWN0aXZlIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IGFjdGl2ZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgY3VycmVudCBzZWxlY3RlZCBvYmplY3RzXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gYWN0aXZlIG9iamVjdFxuICAgICAqL1xuICAgIGdldEFjdGl2ZU9iamVjdHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhY3RpdmUgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIGlmIChhY3RpdmUudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicgJiYgYWN0aXZlLl9vYmplY3RzKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZS5fb2JqZWN0cy5zbGljZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW2FjdGl2ZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBPYmplY3QgdGhhdCB3YXMgcmVtb3ZlZFxuICAgICAqL1xuICAgIF9vbk9iamVjdFJlbW92ZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgLy8gcmVtb3ZpbmcgYWN0aXZlIG9iamVjdCBzaG91bGQgZmlyZSBcInNlbGVjdGlvbjpjbGVhcmVkXCIgZXZlbnRzXG4gICAgICBpZiAob2JqID09PSB0aGlzLl9hY3RpdmVPYmplY3QpIHtcbiAgICAgICAgdGhpcy5maXJlKCdiZWZvcmU6c2VsZWN0aW9uOmNsZWFyZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgICB0aGlzLl9kaXNjYXJkQWN0aXZlT2JqZWN0KCk7XG4gICAgICAgIHRoaXMuZmlyZSgnc2VsZWN0aW9uOmNsZWFyZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgICBvYmouZmlyZSgnZGVzZWxlY3RlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKG9iaiA9PT0gdGhpcy5faG92ZXJlZFRhcmdldCl7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19vbk9iamVjdFJlbW92ZWQnLCBvYmopO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIENvbXBhcmVzIHRoZSBvbGQgYWN0aXZlT2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgb25lIGFuZCBmaXJlcyBjb3JyZWN0IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIG9sZCBhY3RpdmVPYmplY3RcbiAgICAgKi9cbiAgICBfZmlyZVNlbGVjdGlvbkV2ZW50czogZnVuY3Rpb24ob2xkT2JqZWN0cywgZSkge1xuICAgICAgdmFyIHNvbWV0aGluZ0NoYW5nZWQgPSBmYWxzZSwgb2JqZWN0cyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLFxuICAgICAgICAgIGFkZGVkID0gW10sIHJlbW92ZWQgPSBbXTtcbiAgICAgIG9sZE9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvbGRPYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdHMuaW5kZXhPZihvbGRPYmplY3QpID09PSAtMSkge1xuICAgICAgICAgIHNvbWV0aGluZ0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIG9sZE9iamVjdC5maXJlKCdkZXNlbGVjdGVkJywge1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRhcmdldDogb2xkT2JqZWN0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKG9sZE9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBpZiAob2xkT2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPT09IC0xKSB7XG4gICAgICAgICAgc29tZXRoaW5nQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgb2JqZWN0LmZpcmUoJ3NlbGVjdGVkJywge1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRhcmdldDogb2JqZWN0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWRkZWQucHVzaChvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChvbGRPYmplY3RzLmxlbmd0aCA+IDAgJiYgb2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNvbWV0aGluZ0NoYW5nZWQgJiYgdGhpcy5maXJlKCdzZWxlY3Rpb246dXBkYXRlZCcsIHtcbiAgICAgICAgICBlOiBlLFxuICAgICAgICAgIHNlbGVjdGVkOiBhZGRlZCxcbiAgICAgICAgICBkZXNlbGVjdGVkOiByZW1vdmVkLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjcmVhdGVkJywge1xuICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgc2VsZWN0ZWQ6IGFkZGVkLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9sZE9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjbGVhcmVkJywge1xuICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgZGVzZWxlY3RlZDogcmVtb3ZlZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZ2l2ZW4gb2JqZWN0IGFzIHRoZSBvbmx5IGFjdGl2ZSBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNldCBhcyBhbiBhY3RpdmUgb25lXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IChwYXNzZWQgYWxvbmcgd2hlbiBmaXJpbmcgXCJvYmplY3Q6c2VsZWN0ZWRcIilcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldEFjdGl2ZU9iamVjdDogZnVuY3Rpb24gKG9iamVjdCwgZSkge1xuICAgICAgdmFyIGN1cnJlbnRBY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCk7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVPYmplY3Qob2JqZWN0LCBlKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25FdmVudHMoY3VycmVudEFjdGl2ZXMsIGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBwcml2YXRlIG1ldGhvZCBmb3Igbm93LlxuICAgICAqIFRoaXMgaXMgc3VwcG9zZWQgdG8gYmUgZXF1aXZhbGVudCB0byBzZXRBY3RpdmVPYmplY3QgYnV0IHdpdGhvdXQgZmlyaW5nXG4gICAgICogYW55IGV2ZW50LiBUaGVyZSBpcyBjb21taXRtZW50IHRvIGhhdmUgdGhpcyBzdGF5IHRoaXMgd2F5LlxuICAgICAqIFRoaXMgaXMgdGhlIGZ1bmN0aW9uYWwgcGFydCBvZiBzZXRBY3RpdmVPYmplY3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIHNldCBhcyBhY3RpdmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgKHBhc3NlZCBhbG9uZyB3aGVuIGZpcmluZyBcIm9iamVjdDpzZWxlY3RlZFwiKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNlbGVjdGlvbiBoYXBwZW5lZFxuICAgICAqL1xuICAgIF9zZXRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgZSkge1xuICAgICAgaWYgKHRoaXMuX2FjdGl2ZU9iamVjdCA9PT0gb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdChlLCBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3Qub25TZWxlY3QoeyBlOiBlIH0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdCA9IG9iamVjdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgcHJpdmF0ZSBtZXRob2QgZm9yIG5vdy5cbiAgICAgKiBUaGlzIGlzIHN1cHBvc2VkIHRvIGJlIGVxdWl2YWxlbnQgdG8gZGlzY2FyZEFjdGl2ZU9iamVjdCBidXQgd2l0aG91dCBmaXJpbmdcbiAgICAgKiBhbnkgZXZlbnRzLiBUaGVyZSBpcyBjb21taXRtZW50IHRvIGhhdmUgdGhpcyBzdGF5IHRoaXMgd2F5LlxuICAgICAqIFRoaXMgaXMgdGhlIGZ1bmN0aW9uYWwgcGFydCBvZiBkaXNjYXJkQWN0aXZlT2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCAocGFzc2VkIGFsb25nIHdoZW4gZmlyaW5nIFwib2JqZWN0OmRlc2VsZWN0ZWRcIilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIHNldCBhcyBhY3RpdmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzZWxlY3Rpb24gaGFwcGVuZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaXNjYXJkQWN0aXZlT2JqZWN0OiBmdW5jdGlvbihlLCBvYmplY3QpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICBpZiAob2JqKSB7XG4gICAgICAgIC8vIG9uRGVzZWxlY3QgcmV0dXJuIFRSVUUgdG8gY2FuY2VsIHNlbGVjdGlvbjtcbiAgICAgICAgaWYgKG9iai5vbkRlc2VsZWN0KHsgZTogZSwgb2JqZWN0OiBvYmplY3QgfSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWN0aXZlT2JqZWN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXNjYXJkcyBjdXJyZW50bHkgYWN0aXZlIG9iamVjdCBhbmQgZmlyZSBldmVudHMuIElmIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgZmFicmljXG4gICAgICogYXMgYSBjb25zZXF1ZW5jZSBvZiBhIG1vdXNlIGV2ZW50LCB0aGUgZXZlbnQgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGFuZFxuICAgICAqIHNlbnQgdG8gdGhlIGZpcmUgZnVuY3Rpb24gZm9yIHRoZSBjdXN0b20gZXZlbnRzLiBXaGVuIHVzZWQgYXMgYSBtZXRob2QgdGhlXG4gICAgICogZSBwYXJhbSBkb2VzIG5vdCBoYXZlIGFueSBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2V2ZW50fSBlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXNjYXJkQWN0aXZlT2JqZWN0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGN1cnJlbnRBY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksIGFjdGl2ZU9iamVjdCA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0KCk7XG4gICAgICBpZiAoY3VycmVudEFjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnNlbGVjdGlvbjpjbGVhcmVkJywgeyB0YXJnZXQ6IGFjdGl2ZU9iamVjdCwgZTogZSB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Rpc2NhcmRBY3RpdmVPYmplY3QoZSk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uRXZlbnRzKGN1cnJlbnRBY3RpdmVzLCBlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYSBjYW52YXMgZWxlbWVudCBhbmQgcmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRoaXMud3JhcHBlckVsO1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHdyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy51cHBlckNhbnZhc0VsKTtcbiAgICAgIHdyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMuY29udGV4dENhY2hlID0gbnVsbDtcbiAgICAgIHRoaXMuY29udGV4dFRvcCA9IG51bGw7XG4gICAgICBbJ3VwcGVyQ2FudmFzRWwnLCAnY2FjaGVDYW52YXNFbCddLmZvckVhY2goKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgZmFicmljLnV0aWwuY2xlYW5VcEpzZG9tTm9kZSh0aGlzW2VsZW1lbnRdKTtcbiAgICAgICAgdGhpc1tlbGVtZW50XSA9IHVuZGVmaW5lZDtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgICAgaWYgKHdyYXBwZXIucGFyZW50Tm9kZSkge1xuICAgICAgICB3cmFwcGVyLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRoaXMubG93ZXJDYW52YXNFbCwgdGhpcy53cmFwcGVyRWwpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMud3JhcHBlckVsO1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY29udGV4dHMgKGJhY2tncm91bmQsIG1haW4sIHRvcCkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB0aGlzLmRpc2NhcmRBY3RpdmVHcm91cCgpO1xuICAgICAgdGhpcy5kaXNjYXJkQWN0aXZlT2JqZWN0KCk7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dCh0aGlzLmNvbnRleHRUb3ApO1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdjbGVhcicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBvYmplY3RzJyBjb250cm9scyAoYm9yZGVycy9jb250cm9scylcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIGNvbnRyb2xzIG9uXG4gICAgICovXG4gICAgZHJhd0NvbnRyb2xzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG5cbiAgICAgIGlmIChhY3RpdmVPYmplY3QpIHtcbiAgICAgICAgYWN0aXZlT2JqZWN0Ll9yZW5kZXJDb250cm9scyhjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIC8vSWYgdGhlIG9iamVjdCBpcyBwYXJ0IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBncm91cCwgaXQgc2hvdWxkXG4gICAgICAvL2JlIHRyYW5zZm9ybWVkIGFwcHJvcHJpYXRlbHlcbiAgICAgIC8vaS5lLiBpdCBzaG91bGQgYmUgc2VyaWFsaXNlZCBhcyBpdCB3b3VsZCBhcHBlYXIgaWYgdGhlIHNlbGVjdGlvbiBncm91cFxuICAgICAgLy93ZXJlIHRvIGJlIGRlc3Ryb3llZC5cbiAgICAgIHZhciBvcmlnaW5hbFByb3BlcnRpZXMgPSB0aGlzLl9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSksXG4gICAgICAgICAgb2JqZWN0ID0gdGhpcy5jYWxsU3VwZXIoJ190b09iamVjdCcsIGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIC8vVW5kbyB0aGUgZGFtYWdlIHdlIGRpZCBieSBjaGFuZ2luZyBhbGwgb2YgaXRzIHByb3BlcnRpZXNcbiAgICAgIHRoaXMuX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UsIG9yaWdpbmFsUHJvcGVydGllcyk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFsaXNlcyBhbiBvYmplY3QncyBncm91cCB0cmFuc2Zvcm1hdGlvbiBvbiBpdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBbaW5zdGFuY2VdIHRoZSBvYmplY3QgdG8gdHJhbnNmb3JtIChnZXRzIG11dGF0ZWQpXG4gICAgICogQHJldHVybnMgdGhlIG9yaWdpbmFsIHZhbHVlcyBvZiBpbnN0YW5jZSB3aGljaCB3ZXJlIGNoYW5nZWRcbiAgICAgKi9cbiAgICBfcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuZ3JvdXAgJiYgaW5zdGFuY2UuZ3JvdXAudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicgJiYgdGhpcy5fYWN0aXZlT2JqZWN0ID09PSBpbnN0YW5jZS5ncm91cCkge1xuICAgICAgICB2YXIgbGF5b3V0UHJvcHMgPSBbJ2FuZ2xlJywgJ2ZsaXBYJywgJ2ZsaXBZJywgJ2xlZnQnLCAnc2NhbGVYJywgJ3NjYWxlWScsICdza2V3WCcsICdza2V3WScsICd0b3AnXTtcbiAgICAgICAgLy9Db3B5IGFsbCB0aGUgcG9zaXRpb25hbGx5IHJlbGV2YW50IHByb3BlcnRpZXMgYWNyb3NzIG5vd1xuICAgICAgICB2YXIgb3JpZ2luYWxWYWx1ZXMgPSB7fTtcbiAgICAgICAgbGF5b3V0UHJvcHMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgb3JpZ2luYWxWYWx1ZXNbcHJvcF0gPSBpbnN0YW5jZVtwcm9wXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZhYnJpYy51dGlsLmFkZFRyYW5zZm9ybVRvT2JqZWN0KGluc3RhbmNlLCB0aGlzLl9hY3RpdmVPYmplY3QuY2FsY093bk1hdHJpeCgpKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsVmFsdWVzO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyB0aGUgY2hhbmdlZCBwcm9wZXJ0aWVzIG9mIGluc3RhbmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IFtpbnN0YW5jZV0gdGhlIG9iamVjdCB0byB1bi10cmFuc2Zvcm0gKGdldHMgbXV0YXRlZClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29yaWdpbmFsVmFsdWVzXSB0aGUgb3JpZ2luYWwgdmFsdWVzIG9mIGluc3RhbmNlLCBhcyByZXR1cm5lZCBieSBfcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3RcbiAgICAgKi9cbiAgICBfdW53aW5kR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdDogZnVuY3Rpb24oaW5zdGFuY2UsIG9yaWdpbmFsVmFsdWVzKSB7XG4gICAgICBpZiAob3JpZ2luYWxWYWx1ZXMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0KG9yaWdpbmFsVmFsdWVzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHT2JqZWN0OiBmdW5jdGlvbihtYXJrdXAsIGluc3RhbmNlLCByZXZpdmVyKSB7XG4gICAgICAvL0lmIHRoZSBvYmplY3QgaXMgaW4gYSBzZWxlY3Rpb24gZ3JvdXAsIHNpbXVsYXRlIHdoYXQgd291bGQgaGFwcGVuIHRvIHRoYXRcbiAgICAgIC8vb2JqZWN0IHdoZW4gdGhlIGdyb3VwIGlzIGRlc2VsZWN0ZWRcbiAgICAgIHZhciBvcmlnaW5hbFByb3BlcnRpZXMgPSB0aGlzLl9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSk7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3NldFNWR09iamVjdCcsIG1hcmt1cCwgaW5zdGFuY2UsIHJldml2ZXIpO1xuICAgICAgdGhpcy5fdW53aW5kR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdChpbnN0YW5jZSwgb3JpZ2luYWxQcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgc2V0Vmlld3BvcnRUcmFuc2Zvcm06IGZ1bmN0aW9uICh2cHQpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMuX2FjdGl2ZU9iamVjdCAmJiB0aGlzLl9hY3RpdmVPYmplY3QuaXNFZGl0aW5nKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnNldFZpZXdwb3J0VHJhbnNmb3JtLmNhbGwodGhpcywgdnB0KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNvcHlpbmcgc3RhdGljIHByb3BlcnRpZXMgbWFudWFsbHkgdG8gd29yayBhcm91bmQgT3BlcmEncyBidWcsXG4gIC8vIHdoZXJlIFwicHJvdG90eXBlXCIgcHJvcGVydHkgaXMgZW51bWVyYWJsZSBhbmQgb3ZlcnJpZGVzIGV4aXN0aW5nIHByb3RvdHlwZVxuICBmb3IgKHZhciBwcm9wIGluIGZhYnJpYy5TdGF0aWNDYW52YXMpIHtcbiAgICBpZiAocHJvcCAhPT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgIGZhYnJpYy5DYW52YXNbcHJvcF0gPSBmYWJyaWMuU3RhdGljQ2FudmFzW3Byb3BdO1xuICAgIH1cbiAgfVxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGFkZExpc3RlbmVyID0gZmFicmljLnV0aWwuYWRkTGlzdGVuZXIsXG4gICAgICByZW1vdmVMaXN0ZW5lciA9IGZhYnJpYy51dGlsLnJlbW92ZUxpc3RlbmVyLFxuICAgICAgUklHSFRfQ0xJQ0sgPSAzLCBNSURETEVfQ0xJQ0sgPSAyLCBMRUZUX0NMSUNLID0gMSxcbiAgICAgIGFkZEV2ZW50T3B0aW9ucyA9IHsgcGFzc2l2ZTogZmFsc2UgfTtcblxuICBmdW5jdGlvbiBjaGVja0NsaWNrKGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGUuYnV0dG9uICYmIChlLmJ1dHRvbiA9PT0gdmFsdWUgLSAxKTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLkNhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLkNhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQ29udGFpbnMgdGhlIGlkIG9mIHRoZSB0b3VjaCBldmVudCB0aGF0IG93bnMgdGhlIGZhYnJpYyB0cmFuc2Zvcm1cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG1haW5Ub3VjaElkOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBtb3VzZSBsaXN0ZW5lcnMgdG8gY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBpbiBjYXNlIHdlIGluaXRpYWxpemVkIHRoZSBjbGFzcyB0d2ljZS4gVGhpcyBzaG91bGQgbm90IGhhcHBlbiBub3JtYWxseVxuICAgICAgLy8gYnV0IGluIHNvbWUga2luZCBvZiBhcHBsaWNhdGlvbnMgd2hlcmUgdGhlIGNhbnZhcyBlbGVtZW50IG1heSBiZSBjaGFuZ2VkXG4gICAgICAvLyB0aGlzIGlzIGEgd29ya2Fyb3VuZCB0byBoYXZpbmcgZG91YmxlIGxpc3RlbmVycy5cbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgICB0aGlzLmFkZE9yUmVtb3ZlKGFkZExpc3RlbmVyLCAnYWRkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhbiBldmVudCBwcmVmaXggcG9pbnRlciBvciBtb3VzZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRFdmVudFByZWZpeDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlUG9pbnRlckV2ZW50cyA/ICdwb2ludGVyJyA6ICdtb3VzZSc7XG4gICAgfSxcblxuICAgIGFkZE9yUmVtb3ZlOiBmdW5jdGlvbihmdW5jdG9yLCBldmVudGpzRnVuY3Rvcikge1xuICAgICAgdmFyIGNhbnZhc0VsZW1lbnQgPSB0aGlzLnVwcGVyQ2FudmFzRWwsXG4gICAgICAgICAgZXZlbnRUeXBlUHJlZml4ID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICAgIGZ1bmN0b3IoZmFicmljLndpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ2Rvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdvdXQnLCB0aGlzLl9vbk1vdXNlT3V0KTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ2VudGVyJywgdGhpcy5fb25Nb3VzZUVudGVyKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ3doZWVsJywgdGhpcy5fb25Nb3VzZVdoZWVsKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ2NvbnRleHRtZW51JywgdGhpcy5fb25Db250ZXh0TWVudSk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdkYmxjbGljaycsIHRoaXMuX29uRG91YmxlQ2xpY2spO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCAnZHJhZ292ZXInLCB0aGlzLl9vbkRyYWdPdmVyKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ2RyYWdlbnRlcicsIHRoaXMuX29uRHJhZ0VudGVyKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ2RyYWdsZWF2ZScsIHRoaXMuX29uRHJhZ0xlYXZlKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ2Ryb3AnLCB0aGlzLl9vbkRyb3ApO1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZVBvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZXZlbnRqcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZXZlbnRqc0Z1bmN0b3IgaW4gZXZlbnRqcykge1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXShjYW52YXNFbGVtZW50LCAnZ2VzdHVyZScsIHRoaXMuX29uR2VzdHVyZSk7XG4gICAgICAgIGV2ZW50anNbZXZlbnRqc0Z1bmN0b3JdKGNhbnZhc0VsZW1lbnQsICdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICAgICAgZXZlbnRqc1tldmVudGpzRnVuY3Rvcl0oY2FudmFzRWxlbWVudCwgJ29yaWVudGF0aW9uJywgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSk7XG4gICAgICAgIGV2ZW50anNbZXZlbnRqc0Z1bmN0b3JdKGNhbnZhc0VsZW1lbnQsICdzaGFrZScsIHRoaXMuX29uU2hha2UpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXShjYW52YXNFbGVtZW50LCAnbG9uZ3ByZXNzJywgdGhpcy5fb25Mb25nUHJlc3MpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5hZGRPclJlbW92ZShyZW1vdmVMaXN0ZW5lciwgJ3JlbW92ZScpO1xuICAgICAgLy8gaWYgeW91IGRpc3Bvc2Ugb24gYSBtb3VzZURvd24sIGJlZm9yZSBtb3VzZSB1cCwgeW91IG5lZWQgdG8gY2xlYW4gZG9jdW1lbnQgdG8uLi5cbiAgICAgIHZhciBldmVudFR5cGVQcmVmaXggPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCBldmVudFR5cGVQcmVmaXggKyAndXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2JpbmRFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZXZlbnRzQm91bmQpIHtcbiAgICAgICAgLy8gZm9yIGFueSByZWFzb24gd2UgcGFzcyBoZXJlIHR3aWNlIHdlIGRvIG5vdCB3YW50IHRvIGJpbmQgZXZlbnRzIHR3aWNlLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9vbk1vdXNlRG93biA9IHRoaXMuX29uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblRvdWNoU3RhcnQgPSB0aGlzLl9vblRvdWNoU3RhcnQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VNb3ZlID0gdGhpcy5fb25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VVcCA9IHRoaXMuX29uTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Ub3VjaEVuZCA9IHRoaXMuX29uVG91Y2hFbmQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uUmVzaXplID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uR2VzdHVyZSA9IHRoaXMuX29uR2VzdHVyZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25EcmFnID0gdGhpcy5fb25EcmFnLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblNoYWtlID0gdGhpcy5fb25TaGFrZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Mb25nUHJlc3MgPSB0aGlzLl9vbkxvbmdQcmVzcy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25PcmllbnRhdGlvbkNoYW5nZSA9IHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VXaGVlbCA9IHRoaXMuX29uTW91c2VXaGVlbC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Nb3VzZU91dCA9IHRoaXMuX29uTW91c2VPdXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VFbnRlciA9IHRoaXMuX29uTW91c2VFbnRlci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Db250ZXh0TWVudSA9IHRoaXMuX29uQ29udGV4dE1lbnUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRG91YmxlQ2xpY2sgPSB0aGlzLl9vbkRvdWJsZUNsaWNrLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkRyYWdPdmVyID0gdGhpcy5fb25EcmFnT3Zlci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25EcmFnRW50ZXIgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIuYmluZCh0aGlzLCAnZHJhZ2VudGVyJyk7XG4gICAgICB0aGlzLl9vbkRyYWdMZWF2ZSA9IHRoaXMuX3NpbXBsZUV2ZW50SGFuZGxlci5iaW5kKHRoaXMsICdkcmFnbGVhdmUnKTtcbiAgICAgIHRoaXMuX29uRHJvcCA9IHRoaXMuX29uRHJvcC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5ldmVudHNCb3VuZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBnZXN0dXJlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW3NlbGZdIElubmVyIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9vbkdlc3R1cmU6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vblRyYW5zZm9ybUdlc3R1cmUgJiYgdGhpcy5fX29uVHJhbnNmb3JtR2VzdHVyZShlLCBzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIGRyYWdcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uRHJhZzogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uRHJhZyAmJiB0aGlzLl9fb25EcmFnKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gd2hlZWwgZXZlbnRcbiAgICAgKi9cbiAgICBfb25Nb3VzZVdoZWVsOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZVdoZWVsKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vbk1vdXNlT3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5faG92ZXJlZFRhcmdldDtcbiAgICAgIHRoaXMuZmlyZSgnbW91c2U6b3V0JywgeyB0YXJnZXQ6IHRhcmdldCwgZTogZSB9KTtcbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBudWxsO1xuICAgICAgdGFyZ2V0ICYmIHRhcmdldC5maXJlKCdtb3VzZW91dCcsIHsgZTogZSB9KTtcblxuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzLmZvckVhY2goZnVuY3Rpb24oX3RhcmdldCl7XG4gICAgICAgIF90aGlzLmZpcmUoJ21vdXNlOm91dCcsIHsgdGFyZ2V0OiB0YXJnZXQsIGU6IGUgfSk7XG4gICAgICAgIF90YXJnZXQgJiYgdGFyZ2V0LmZpcmUoJ21vdXNlb3V0JywgeyBlOiBlIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZW50ZXJcbiAgICAgKi9cbiAgICBfb25Nb3VzZUVudGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAvLyBUaGlzIGZpbmQgdGFyZ2V0IGFuZCBjb25zZXF1ZW50ICdtb3VzZTpvdmVyJyBpcyB1c2VkIHRvXG4gICAgICAvLyBjbGVhciBvbGQgaW5zdGFuY2VzIG9uIGhvdmVyZWQgdGFyZ2V0LlxuICAgICAgLy8gY2FsbGluZyBmaW5kVGFyZ2V0IGhhcyB0aGUgc2lkZSBlZmZlY3Qgb2Yga2lsbGluZyB0YXJnZXQuX19jb3JuZXIuXG4gICAgICAvLyBhcyBhIHNob3J0IHRlcm0gZml4IHdlIGFyZSBub3QgZmlyaW5nIHRoaXMgaWYgd2UgYXJlIGN1cnJlbnRseSB0cmFuc2Zvcm1pbmcuXG4gICAgICAvLyBhcyBhIGxvbmcgdGVybSBmaXggd2UgbmVlZCB0byBzZXBhcmF0ZSB0aGUgYWN0aW9uIG9mIGZpbmRpbmcgYSB0YXJnZXQgd2l0aCB0aGVcbiAgICAgIC8vIHNpZGUgZWZmZWN0cyB3ZSBhZGRlZCB0byBpdC5cbiAgICAgIGlmICghdGhpcy5fY3VycmVudFRyYW5zZm9ybSAmJiAhdGhpcy5maW5kVGFyZ2V0KGUpKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnbW91c2U6b3ZlcicsIHsgdGFyZ2V0OiBudWxsLCBlOiBlIH0pO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMgPSBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIG9yaWVudGF0aW9uIGNoYW5nZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25PcmllbnRhdGlvbkNoYW5nZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uT3JpZW50YXRpb25DaGFuZ2UgJiYgdGhpcy5fX29uT3JpZW50YXRpb25DaGFuZ2UoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBzaGFrZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25TaGFrZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uU2hha2UgJiYgdGhpcy5fX29uU2hha2UoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBzaGFrZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25Mb25nUHJlc3M6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vbkxvbmdQcmVzcyAmJiB0aGlzLl9fb25Mb25nUHJlc3MoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHByZXZlbnQgZGVmYXVsdCB0byBhbGxvdyBkcm9wIGV2ZW50IHRvIGJlIGZpcmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIHNoYWtlXG4gICAgICovXG4gICAgX29uRHJhZ092ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIoJ2RyYWdvdmVyJywgZSk7XG4gICAgICB0aGlzLl9maXJlRW50ZXJMZWF2ZUV2ZW50cyh0YXJnZXQsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBgZHJvcDpiZWZvcmVgIGlzIGEgYW4gZXZlbnQgdGhhdCBhbGxvdyB5b3UgdG8gc2NoZWR1bGUgbG9naWNcbiAgICAgKiBiZWZvcmUgdGhlIGBkcm9wYCBldmVudC4gUHJlZmVyIGBkcm9wYCBldmVudCBhbHdheXMsIGJ1dCBpZiB5b3UgbmVlZFxuICAgICAqIHRvIHJ1biBzb21lIGRyb3AtZGlzYWJsaW5nIGxvZ2ljIG9uIGFuIGV2ZW50LCBzaW5jZSB0aGVyZSBpcyBubyB3YXlcbiAgICAgKiB0byBoYW5kbGUgZXZlbnQgaGFuZGxlcnMgb3JkZXJpbmcsIHVzZSBgZHJvcDpiZWZvcmVgXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIF9vbkRyb3A6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIoJ2Ryb3A6YmVmb3JlJywgZSk7XG4gICAgICByZXR1cm4gdGhpcy5fc2ltcGxlRXZlbnRIYW5kbGVyKCdkcm9wJywgZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uQ29udGV4dE1lbnU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAodGhpcy5zdG9wQ29udGV4dE1lbnUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fY2FjaGVUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZGJsY2xpY2snKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB0aGUgaWQgb2YgYW4gZXZlbnQuXG4gICAgICogcmV0dXJucyBlaXRoZXIgdGhlIHBvaW50ZXJJZCBvciB0aGUgaWRlbnRpZmllciBvciAwIGZvciB0aGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2dCBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRQb2ludGVySWQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIGNoYW5nZWRUb3VjaGVzID0gZXZ0LmNoYW5nZWRUb3VjaGVzO1xuXG4gICAgICBpZiAoY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZWRUb3VjaGVzWzBdICYmIGNoYW5nZWRUb3VjaGVzWzBdLmlkZW50aWZpZXI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVuYWJsZVBvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgcmV0dXJuIGV2dC5wb2ludGVySWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhbiBldmVudCBoYXMgdGhlIGlkIG9mIHRoZSBldmVudCB0aGF0IGlzIGNvbnNpZGVyZWQgbWFpblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtldnR9IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9pc01haW5FdmVudDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAoZXZ0LmlzUHJpbWFyeSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChldnQuaXNQcmltYXJ5ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZXZ0LnR5cGUgPT09ICd0b3VjaGVuZCcgJiYgZXZ0LnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV2dC5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICByZXR1cm4gZXZ0LmNoYW5nZWRUb3VjaGVzWzBdLmlkZW50aWZpZXIgPT09IHRoaXMubWFpblRvdWNoSWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAodGhpcy5tYWluVG91Y2hJZCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLm1haW5Ub3VjaElkID0gdGhpcy5nZXRQb2ludGVySWQoZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fb25Nb3VzZURvd24oZSk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgdmFyIGNhbnZhc0VsZW1lbnQgPSB0aGlzLnVwcGVyQ2FudmFzRWwsXG4gICAgICAgICAgZXZlbnRUeXBlUHJlZml4ID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICAgIGFkZExpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIGFkZExpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgLy8gVW5iaW5kIG1vdXNlZG93biB0byBwcmV2ZW50IGRvdWJsZSB0cmlnZ2VycyBmcm9tIHRvdWNoIGRldmljZXNcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdkb3duJywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX19vbk1vdXNlRG93bihlKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICB2YXIgY2FudmFzRWxlbWVudCA9IHRoaXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICBldmVudFR5cGVQcmVmaXggPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoY2FudmFzRWxlbWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ21vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIGFkZExpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ3VwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgIGFkZExpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ21vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Ub3VjaEVuZDogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBzdGlsbCB0b3VjaGVzIHN0b3AgaGVyZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9fb25Nb3VzZVVwKGUpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHRoaXMubWFpblRvdWNoSWQgPSBudWxsO1xuICAgICAgdmFyIGV2ZW50VHlwZVByZWZpeCA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5fd2lsbEFkZE1vdXNlRG93bikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fd2lsbEFkZE1vdXNlRG93bik7XG4gICAgICB9XG4gICAgICB0aGlzLl93aWxsQWRkTW91c2VEb3duID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gV2FpdCA0MDBtcyBiZWZvcmUgcmViaW5kaW5nIG1vdXNlZG93biB0byBwcmV2ZW50IGRvdWJsZSB0cmlnZ2Vyc1xuICAgICAgICAvLyBmcm9tIHRvdWNoIGRldmljZXNcbiAgICAgICAgYWRkTGlzdGVuZXIoX3RoaXMudXBwZXJDYW52YXNFbCwgZXZlbnRUeXBlUHJlZml4ICsgJ2Rvd24nLCBfdGhpcy5fb25Nb3VzZURvd24pO1xuICAgICAgICBfdGhpcy5fd2lsbEFkZE1vdXNlRG93biA9IDA7XG4gICAgICB9LCA0MDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNldXBcbiAgICAgKi9cbiAgICBfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fX29uTW91c2VVcChlKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICB2YXIgY2FudmFzRWxlbWVudCA9IHRoaXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICBldmVudFR5cGVQcmVmaXggPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpO1xuICAgICAgaWYgKHRoaXMuX2lzTWFpbkV2ZW50KGUpKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ3VwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgICBhZGRMaXN0ZW5lcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqL1xuICAgIF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICF0aGlzLmFsbG93VG91Y2hTY3JvbGxpbmcgJiYgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl9fb25Nb3VzZU1vdmUoZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaWRlcyB3aGV0aGVyIHRoZSBjYW52YXMgc2hvdWxkIGJlIHJlZHJhd24gaW4gbW91c2V1cCBhbmQgbW91c2Vkb3duIGV2ZW50cy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2hvdWxkUmVuZGVyOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG5cbiAgICAgIGlmIChcbiAgICAgICAgISFhY3RpdmVPYmplY3QgIT09ICEhdGFyZ2V0IHx8XG4gICAgICAgIChhY3RpdmVPYmplY3QgJiYgdGFyZ2V0ICYmIChhY3RpdmVPYmplY3QgIT09IHRhcmdldCkpXG4gICAgICApIHtcbiAgICAgICAgLy8gdGhpcyBjb3ZlcnM6IHN3aXRjaCBvZiB0YXJnZXQsIGZyb20gdGFyZ2V0IHRvIG5vIHRhcmdldCwgc2VsZWN0aW9uIG9mIHRhcmdldFxuICAgICAgICAvLyBtdWx0aVNlbGVjdGlvbiB3aXRoIGtleSBhbmQgbW91c2VcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhY3RpdmVPYmplY3QgJiYgYWN0aXZlT2JqZWN0LmlzRWRpdGluZykge1xuICAgICAgICAvLyBpZiB3ZSBtb3VzZSB1cC9kb3duIG92ZXIgYSBlZGl0aW5nIHRleHRib3ggYSBjdXJzb3IgY2hhbmdlLFxuICAgICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIHRvIHJlIHJlbmRlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRlZmluZXMgdGhlIGFjdGlvbnMgd2hlbiBtb3VzZSBpcyByZWxlYXNlZCBvbiBjYW52YXMuXG4gICAgICogVGhlIG1ldGhvZCByZXNldHMgdGhlIGN1cnJlbnRUcmFuc2Zvcm0gcGFyYW1ldGVycywgc3RvcmUgdGhlIGltYWdlIGNvcm5lclxuICAgICAqIHBvc2l0aW9uIGluIHRoZSBpbWFnZSBvYmplY3QgYW5kIHJlbmRlciB0aGUgY2FudmFzIG9uIHRvcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNldXBcbiAgICAgKi9cbiAgICBfX29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciB0YXJnZXQsIHRyYW5zZm9ybSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgZ3JvdXBTZWxlY3RvciA9IHRoaXMuX2dyb3VwU2VsZWN0b3IsIHNob3VsZFJlbmRlciA9IGZhbHNlLFxuICAgICAgICAgIGlzQ2xpY2sgPSAoIWdyb3VwU2VsZWN0b3IgfHwgKGdyb3VwU2VsZWN0b3IubGVmdCA9PT0gMCAmJiBncm91cFNlbGVjdG9yLnRvcCA9PT0gMCkpO1xuICAgICAgdGhpcy5fY2FjaGVUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgICB0YXJnZXQgPSB0aGlzLl90YXJnZXQ7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXA6YmVmb3JlJyk7XG4gICAgICAvLyBpZiByaWdodC9taWRkbGUgY2xpY2sganVzdCBmaXJlIGV2ZW50cyBhbmQgcmV0dXJuXG4gICAgICAvLyB0YXJnZXQgdW5kZWZpbmVkIHdpbGwgbWFrZSB0aGUgX2hhbmRsZUV2ZW50IHNlYXJjaCB0aGUgdGFyZ2V0XG4gICAgICBpZiAoY2hlY2tDbGljayhlLCBSSUdIVF9DTElDSykpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyZVJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXAnLCBSSUdIVF9DTElDSywgaXNDbGljayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tDbGljayhlLCBNSURETEVfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVNaWRkbGVDbGljaykge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cCcsIE1JRERMRV9DTElDSywgaXNDbGljayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0RyYXdpbmdNb2RlICYmIHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgICB0aGlzLl9vbk1vdXNlVXBJbkRyYXdpbmdNb2RlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faXNNYWluRXZlbnQoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLl9maW5hbGl6ZUN1cnJlbnRUcmFuc2Zvcm0oZSk7XG4gICAgICAgIHNob3VsZFJlbmRlciA9IHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQ2xpY2spIHtcbiAgICAgICAgdmFyIHRhcmdldFdhc0FjdGl2ZSA9IHRhcmdldCA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgICB0aGlzLl9tYXliZUdyb3VwT2JqZWN0cyhlKTtcbiAgICAgICAgaWYgKCFzaG91bGRSZW5kZXIpIHtcbiAgICAgICAgICBzaG91bGRSZW5kZXIgPSAoXG4gICAgICAgICAgICB0aGlzLl9zaG91bGRSZW5kZXIodGFyZ2V0KSB8fFxuICAgICAgICAgICAgKCF0YXJnZXRXYXNBY3RpdmUgJiYgdGFyZ2V0ID09PSB0aGlzLl9hY3RpdmVPYmplY3QpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNvcm5lciwgcG9pbnRlcjtcbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgY29ybmVyID0gdGFyZ2V0Ll9maW5kVGFyZ2V0Q29ybmVyKFxuICAgICAgICAgIHRoaXMuZ2V0UG9pbnRlcihlLCB0cnVlKSxcbiAgICAgICAgICBmYWJyaWMudXRpbC5pc1RvdWNoRXZlbnQoZSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRhcmdldC5zZWxlY3RhYmxlICYmIHRhcmdldCAhPT0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmIHRhcmdldC5hY3RpdmVPbiA9PT0gJ3VwJykge1xuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KHRhcmdldCwgZSk7XG4gICAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgY29udHJvbCA9IHRhcmdldC5jb250cm9sc1tjb3JuZXJdLFxuICAgICAgICAgICAgICBtb3VzZVVwSGFuZGxlciA9IGNvbnRyb2wgJiYgY29udHJvbC5nZXRNb3VzZVVwSGFuZGxlcihlLCB0YXJnZXQsIGNvbnRyb2wpO1xuICAgICAgICAgIGlmIChtb3VzZVVwSGFuZGxlcikge1xuICAgICAgICAgICAgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgICAgICAgIG1vdXNlVXBIYW5kbGVyKGUsIHRyYW5zZm9ybSwgcG9pbnRlci54LCBwb2ludGVyLnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlIGFyZSBlbmRpbmcgdXAgYSB0cmFuc2Zvcm0gb24gYSBkaWZmZXJlbnQgY29udHJvbCBvciBhIG5ldyBvYmplY3RcbiAgICAgIC8vIGZpcmUgdGhlIG9yaWdpbmFsIG1vdXNlIHVwIGZyb20gdGhlIGNvcm5lciB0aGF0IHN0YXJ0ZWQgdGhlIHRyYW5zZm9ybVxuICAgICAgaWYgKHRyYW5zZm9ybSAmJiAodHJhbnNmb3JtLnRhcmdldCAhPT0gdGFyZ2V0IHx8IHRyYW5zZm9ybS5jb3JuZXIgIT09IGNvcm5lcikpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ29udHJvbCA9IHRyYW5zZm9ybS50YXJnZXQgJiYgdHJhbnNmb3JtLnRhcmdldC5jb250cm9sc1t0cmFuc2Zvcm0uY29ybmVyXSxcbiAgICAgICAgICAgIG9yaWdpbmFsTW91c2VVcEhhbmRsZXIgPSBvcmlnaW5hbENvbnRyb2wgJiYgb3JpZ2luYWxDb250cm9sLmdldE1vdXNlVXBIYW5kbGVyKGUsIHRhcmdldCwgY29udHJvbCk7XG4gICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIHx8IHRoaXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgICAgb3JpZ2luYWxNb3VzZVVwSGFuZGxlciAmJiBvcmlnaW5hbE1vdXNlVXBIYW5kbGVyKGUsIHRyYW5zZm9ybSwgcG9pbnRlci54LCBwb2ludGVyLnkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0Q3Vyc29yRnJvbUV2ZW50KGUsIHRhcmdldCk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXAnLCBMRUZUX0NMSUNLLCBpc0NsaWNrKTtcbiAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSBudWxsO1xuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IG51bGw7XG4gICAgICAvLyByZXNldCB0aGUgdGFyZ2V0IGluZm9ybWF0aW9uIGFib3V0IHdoaWNoIGNvcm5lciBpcyBzZWxlY3RlZFxuICAgICAgdGFyZ2V0ICYmICh0YXJnZXQuX19jb3JuZXIgPSAwKTtcbiAgICAgIGlmIChzaG91bGRSZW5kZXIpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNDbGljaykge1xuICAgICAgICB0aGlzLnJlbmRlclRvcCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEhhbmRsZSBldmVudCBmaXJpbmcgZm9yIHRhcmdldCBhbmQgc3VidGFyZ2V0c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgZXZlbnQgZnJvbSBtb3VzZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgZXZlbnQgdG8gZmlyZSAodXAsIGRvd24gb3IgbW92ZSlcbiAgICAgKiBAcmV0dXJuIHtGYWJyaWMuT2JqZWN0fSB0YXJnZXQgcmV0dXJuIHRoZSB0aGUgdGFyZ2V0IGZvdW5kLCBmb3IgaW50ZXJuYWwgcmVhc29ucy5cbiAgICAgKi9cbiAgICBfc2ltcGxlRXZlbnRIYW5kbGVyOiBmdW5jdGlvbihldmVudFR5cGUsIGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoZSksXG4gICAgICAgICAgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgc3ViVGFyZ2V0czogdGFyZ2V0cyxcbiAgICAgICAgICB9O1xuICAgICAgdGhpcy5maXJlKGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIGlmICghdGFyZ2V0cykge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhcmdldHNbaV0uZmlyZShldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBIYW5kbGUgZXZlbnQgZmlyaW5nIGZvciB0YXJnZXQgYW5kIHN1YnRhcmdldHNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIGV2ZW50IGZyb20gbW91c2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIGV2ZW50IHRvIGZpcmUgKHVwLCBkb3duIG9yIG1vdmUpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRPYmogcmVjZWl2aW5nIGV2ZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtidXR0b25dIGJ1dHRvbiB1c2VkIGluIHRoZSBldmVudCAxID0gbGVmdCwgMiA9IG1pZGRsZSwgMyA9IHJpZ2h0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc0NsaWNrIGZvciBsZWZ0IGJ1dHRvbiBvbmx5LCBpbmRpY2F0ZXMgdGhhdCB0aGUgbW91c2UgdXAgaGFwcGVuZWQgd2l0aG91dCBtb3ZlLlxuICAgICAqL1xuICAgIF9oYW5kbGVFdmVudDogZnVuY3Rpb24oZSwgZXZlbnRUeXBlLCBidXR0b24sIGlzQ2xpY2spIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQsXG4gICAgICAgICAgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyB8fCBbXSxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgc3ViVGFyZ2V0czogdGFyZ2V0cyxcbiAgICAgICAgICAgIGJ1dHRvbjogYnV0dG9uIHx8IExFRlRfQ0xJQ0ssXG4gICAgICAgICAgICBpc0NsaWNrOiBpc0NsaWNrIHx8IGZhbHNlLFxuICAgICAgICAgICAgcG9pbnRlcjogdGhpcy5fcG9pbnRlcixcbiAgICAgICAgICAgIGFic29sdXRlUG9pbnRlcjogdGhpcy5fYWJzb2x1dGVQb2ludGVyLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9jdXJyZW50VHJhbnNmb3JtXG4gICAgICAgICAgfTtcbiAgICAgIGlmIChldmVudFR5cGUgPT09ICd1cCcpIHtcbiAgICAgICAgb3B0aW9ucy5jdXJyZW50VGFyZ2V0ID0gdGhpcy5maW5kVGFyZ2V0KGUpO1xuICAgICAgICBvcHRpb25zLmN1cnJlbnRTdWJUYXJnZXRzID0gdGhpcy50YXJnZXRzO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJlKCdtb3VzZTonICsgZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIHRhcmdldCAmJiB0YXJnZXQuZmlyZSgnbW91c2UnICsgZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0YXJnZXRzW2ldLmZpcmUoJ21vdXNlJyArIGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBzZW5kIHRoZSBtb3VzZSBldmVudCB0aGF0IGdlbmVyYXRlIHRoZSBmaW5hbGl6ZSBkb3duLCBzbyBpdCBjYW4gYmUgdXNlZCBpbiB0aGUgZXZlbnRcbiAgICAgKi9cbiAgICBfZmluYWxpemVDdXJyZW50VHJhbnNmb3JtOiBmdW5jdGlvbihlKSB7XG5cbiAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLFxuICAgICAgICAgIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICAgICAgYWN0aW9uOiB0cmFuc2Zvcm0uYWN0aW9uLFxuICAgICAgICAgIH07XG5cbiAgICAgIGlmICh0YXJnZXQuX3NjYWxpbmcpIHtcbiAgICAgICAgdGFyZ2V0Ll9zY2FsaW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5zZXRDb29yZHMoKTtcblxuICAgICAgaWYgKHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQgfHwgKHRoaXMuc3RhdGVmdWwgJiYgdGFyZ2V0Lmhhc1N0YXRlQ2hhbmdlZCgpKSkge1xuICAgICAgICB0aGlzLl9maXJlKCdtb2RpZmllZCcsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vbk1vdXNlRG93bkluRHJhd2luZ01vZGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZyA9IHRydWU7XG4gICAgICBpZiAodGhpcy5nZXRBY3RpdmVPYmplY3QoKSkge1xuICAgICAgICB0aGlzLmRpc2NhcmRBY3RpdmVPYmplY3QoZSkucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgfVxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZURvd24ocG9pbnRlciwgeyBlOiBlLCBwb2ludGVyOiBwb2ludGVyIH0pO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfb25Nb3VzZU1vdmVJbkRyYXdpbmdNb2RlOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpO1xuICAgICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZU1vdmUocG9pbnRlciwgeyBlOiBlLCBwb2ludGVyOiBwb2ludGVyIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5mcmVlRHJhd2luZ0N1cnNvcik7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnbW92ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNldXBcbiAgICAgKi9cbiAgICBfb25Nb3VzZVVwSW5EcmF3aW5nTW9kZTogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcgPSB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZVVwKHsgZTogZSwgcG9pbnRlcjogcG9pbnRlciB9KTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZWZpbmVzIHRoZSBhY3Rpb25zIHdoZW4gbW91c2UgaXMgY2xpY2tlZCBvbiBjYW52YXMuXG4gICAgICogVGhlIG1ldGhvZCBpbml0cyB0aGUgY3VycmVudFRyYW5zZm9ybSBwYXJhbWV0ZXJzIGFuZCByZW5kZXJzIGFsbCB0aGVcbiAgICAgKiBjYW52YXMgc28gdGhlIGN1cnJlbnQgaW1hZ2UgY2FuIGJlIHBsYWNlZCBvbiB0aGUgdG9wIGNhbnZhcyBhbmQgdGhlIHJlc3RcbiAgICAgKiBpbiBvbiB0aGUgY29udGFpbmVyIG9uZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9fb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duOmJlZm9yZScpO1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldDtcbiAgICAgIC8vIGlmIHJpZ2h0IGNsaWNrIGp1c3QgZmlyZSBldmVudHNcbiAgICAgIGlmIChjaGVja0NsaWNrKGUsIFJJR0hUX0NMSUNLKSkge1xuICAgICAgICBpZiAodGhpcy5maXJlUmlnaHRDbGljaykge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duJywgUklHSFRfQ0xJQ0spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgTUlERExFX0NMSUNLKSkge1xuICAgICAgICBpZiAodGhpcy5maXJlTWlkZGxlQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicsIE1JRERMRV9DTElDSyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0RyYXdpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMuX29uTW91c2VEb3duSW5EcmF3aW5nTW9kZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lzTWFpbkV2ZW50KGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWdub3JlIGlmIHNvbWUgb2JqZWN0IGlzIGJlaW5nIHRyYW5zZm9ybWVkIGF0IHRoaXMgbW9tZW50XG4gICAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5fcG9pbnRlcjtcbiAgICAgIC8vIHNhdmUgcG9pbnRlciBmb3IgY2hlY2sgaW4gX19vbk1vdXNlVXAgZXZlbnRcbiAgICAgIHRoaXMuX3ByZXZpb3VzUG9pbnRlciA9IHBvaW50ZXI7XG4gICAgICB2YXIgc2hvdWxkUmVuZGVyID0gdGhpcy5fc2hvdWxkUmVuZGVyKHRhcmdldCksXG4gICAgICAgICAgc2hvdWxkR3JvdXAgPSB0aGlzLl9zaG91bGRHcm91cChlLCB0YXJnZXQpO1xuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyU2VsZWN0aW9uKGUsIHRhcmdldCkpIHtcbiAgICAgICAgdGhpcy5kaXNjYXJkQWN0aXZlT2JqZWN0KGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2hvdWxkR3JvdXApIHtcbiAgICAgICAgdGhpcy5faGFuZGxlR3JvdXBpbmcoZSwgdGFyZ2V0KTtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb24gJiYgKCF0YXJnZXQgfHxcbiAgICAgICAgKCF0YXJnZXQuc2VsZWN0YWJsZSAmJiAhdGFyZ2V0LmlzRWRpdGluZyAmJiB0YXJnZXQgIT09IHRoaXMuX2FjdGl2ZU9iamVjdCkpKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSB7XG4gICAgICAgICAgZXg6IHRoaXMuX2Fic29sdXRlUG9pbnRlci54LFxuICAgICAgICAgIGV5OiB0aGlzLl9hYnNvbHV0ZVBvaW50ZXIueSxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciBhbHJlYWR5U2VsZWN0ZWQgPSB0YXJnZXQgPT09IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgICAgaWYgKHRhcmdldC5zZWxlY3RhYmxlICYmIHRhcmdldC5hY3RpdmVPbiA9PT0gJ2Rvd24nKSB7XG4gICAgICAgICAgdGhpcy5zZXRBY3RpdmVPYmplY3QodGFyZ2V0LCBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ybmVyID0gdGFyZ2V0Ll9maW5kVGFyZ2V0Q29ybmVyKFxuICAgICAgICAgIHRoaXMuZ2V0UG9pbnRlcihlLCB0cnVlKSxcbiAgICAgICAgICBmYWJyaWMudXRpbC5pc1RvdWNoRXZlbnQoZSlcbiAgICAgICAgKTtcbiAgICAgICAgdGFyZ2V0Ll9fY29ybmVyID0gY29ybmVyO1xuICAgICAgICBpZiAodGFyZ2V0ID09PSB0aGlzLl9hY3RpdmVPYmplY3QgJiYgKGNvcm5lciB8fCAhc2hvdWxkR3JvdXApKSB7XG4gICAgICAgICAgdGhpcy5fc2V0dXBDdXJyZW50VHJhbnNmb3JtKGUsIHRhcmdldCwgYWxyZWFkeVNlbGVjdGVkKTtcbiAgICAgICAgICB2YXIgY29udHJvbCA9IHRhcmdldC5jb250cm9sc1tjb3JuZXJdLFxuICAgICAgICAgICAgICBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpLFxuICAgICAgICAgICAgICBtb3VzZURvd25IYW5kbGVyID0gY29udHJvbCAmJiBjb250cm9sLmdldE1vdXNlRG93bkhhbmRsZXIoZSwgdGFyZ2V0LCBjb250cm9sKTtcbiAgICAgICAgICBpZiAobW91c2VEb3duSGFuZGxlcikge1xuICAgICAgICAgICAgbW91c2VEb3duSGFuZGxlcihlLCB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLCBwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicpO1xuICAgICAgLy8gd2UgbXVzdCByZW5kZXJBbGwgc28gdGhhdCB3ZSB1cGRhdGUgdGhlIHZpc3VhbHNcbiAgICAgIChzaG91bGRSZW5kZXIgfHwgc2hvdWxkR3JvdXApICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXNldCBjYWNoZSBmb3JtIGNvbW1vbiBpbmZvcm1hdGlvbiBuZWVkZWQgZHVyaW5nIGV2ZW50IHByb2Nlc3NpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl90YXJnZXQgPSBudWxsO1xuICAgICAgdGhpcy5fcG9pbnRlciA9IG51bGw7XG4gICAgICB0aGlzLl9hYnNvbHV0ZVBvaW50ZXIgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZSBjb21tb24gaW5mb3JtYXRpb24gbmVlZGVkIGR1cmluZyBldmVudCBwcm9jZXNzaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBldmVudFxuICAgICAqL1xuICAgIF9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YTogZnVuY3Rpb24oZSkge1xuICAgICAgLy8gcmVzZXQgaW4gb3JkZXIgdG8gYXZvaWQgc3RhbGUgY2FjaGluZ1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHRoaXMuX3BvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSk7XG4gICAgICB0aGlzLl9hYnNvbHV0ZVBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHRoaXMuX3BvaW50ZXIpO1xuICAgICAgdGhpcy5fdGFyZ2V0ID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSA/IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0udGFyZ2V0IDogdGhpcy5maW5kVGFyZ2V0KGUpIHx8IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2JlZm9yZVRyYW5zZm9ybTogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtO1xuICAgICAgdGhpcy5zdGF0ZWZ1bCAmJiB0LnRhcmdldC5zYXZlU3RhdGUoKTtcbiAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnRyYW5zZm9ybScsIHtcbiAgICAgICAgZTogZSxcbiAgICAgICAgdHJhbnNmb3JtOiB0LFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRlZmluZXMgdGhlIGFjdGlvbnMgd2hlbiBtb3VzZSBpcyBob3ZlcmluZyB0aGUgY2FudmFzLlxuICAgICAqIFRoZSBjdXJyZW50VHJhbnNmb3JtIHBhcmFtZXRlciB3aWxsIGRlZmluZSB3aGV0aGVyIHRoZSB1c2VyIGlzIHJvdGF0aW5nL3NjYWxpbmcvdHJhbnNsYXRpbmdcbiAgICAgKiBhbiBpbWFnZSBvciBuZWl0aGVyIG9mIHRoZW0gKG9ubHkgaG92ZXJpbmcpLiBBIGdyb3VwIHNlbGVjdGlvbiBpcyBhbHNvIHBvc3NpYmxlIGFuZCB3b3VsZCBjYW5jZWxcbiAgICAgKiBhbGwgYW55IG90aGVyIHR5cGUgb2YgYWN0aW9uLlxuICAgICAqIEluIGNhc2Ugb2YgYW4gaW1hZ2UgdHJhbnNmb3JtYXRpb24gb25seSB0aGUgdG9wIGNhbnZhcyB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICovXG4gICAgX19vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdtb3ZlOmJlZm9yZScpO1xuICAgICAgdGhpcy5fY2FjaGVUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgICB2YXIgdGFyZ2V0LCBwb2ludGVyO1xuXG4gICAgICBpZiAodGhpcy5pc0RyYXdpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMuX29uTW91c2VNb3ZlSW5EcmF3aW5nTW9kZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lzTWFpbkV2ZW50KGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGdyb3VwU2VsZWN0b3IgPSB0aGlzLl9ncm91cFNlbGVjdG9yO1xuXG4gICAgICAvLyBXZSBpbml0aWFsbHkgY2xpY2tlZCBpbiBhbiBlbXB0eSBhcmVhLCBzbyB3ZSBkcmF3IGEgYm94IGZvciBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgIGlmIChncm91cFNlbGVjdG9yKSB7XG4gICAgICAgIHBvaW50ZXIgPSB0aGlzLl9hYnNvbHV0ZVBvaW50ZXI7XG5cbiAgICAgICAgZ3JvdXBTZWxlY3Rvci5sZWZ0ID0gcG9pbnRlci54IC0gZ3JvdXBTZWxlY3Rvci5leDtcbiAgICAgICAgZ3JvdXBTZWxlY3Rvci50b3AgPSBwb2ludGVyLnkgLSBncm91cFNlbGVjdG9yLmV5O1xuXG4gICAgICAgIHRoaXMucmVuZGVyVG9wKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghdGhpcy5fY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICB0YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoZSkgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5fc2V0Q3Vyc29yRnJvbUV2ZW50KGUsIHRhcmdldCk7XG4gICAgICAgIHRoaXMuX2ZpcmVPdmVyT3V0RXZlbnRzKHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtT2JqZWN0KGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ21vdmUnKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZSB0aGUgbW91c2VvdXQsIG1vdXNlb3ZlciBldmVudHMgZm9yIHRoZSBmYWJyaWMgb2JqZWN0IG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCB0aGUgdGFyZ2V0IHdoZXJlIHRoZSB0YXJnZXQgZnJvbSB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZU92ZXJPdXRFdmVudHM6IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdmFyIF9ob3ZlcmVkVGFyZ2V0ID0gdGhpcy5faG92ZXJlZFRhcmdldCxcbiAgICAgICAgICBfaG92ZXJlZFRhcmdldHMgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0cywgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyxcbiAgICAgICAgICBsZW5ndGggPSBNYXRoLm1heChfaG92ZXJlZFRhcmdldHMubGVuZ3RoLCB0YXJnZXRzLmxlbmd0aCk7XG5cbiAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzKHRhcmdldCwgZSwge1xuICAgICAgICBvbGRUYXJnZXQ6IF9ob3ZlcmVkVGFyZ2V0LFxuICAgICAgICBldnRPdXQ6ICdtb3VzZW91dCcsXG4gICAgICAgIGNhbnZhc0V2dE91dDogJ21vdXNlOm91dCcsXG4gICAgICAgIGV2dEluOiAnbW91c2VvdmVyJyxcbiAgICAgICAgY2FudmFzRXZ0SW46ICdtb3VzZTpvdmVyJyxcbiAgICAgIH0pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzKHRhcmdldHNbaV0sIGUsIHtcbiAgICAgICAgICBvbGRUYXJnZXQ6IF9ob3ZlcmVkVGFyZ2V0c1tpXSxcbiAgICAgICAgICBldnRPdXQ6ICdtb3VzZW91dCcsXG4gICAgICAgICAgZXZ0SW46ICdtb3VzZW92ZXInLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMudGFyZ2V0cy5jb25jYXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFuYWdlIHRoZSBkcmFnRW50ZXIsIGRyYWdMZWF2ZSBldmVudHMgZm9yIHRoZSBmYWJyaWMgb2JqZWN0cyBvbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtGYWJyaWMuT2JqZWN0fSB0YXJnZXQgdGhlIHRhcmdldCB3aGVyZSB0aGUgdGFyZ2V0IGZyb20gdGhlIG9uRHJhZyBldmVudFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG9uZHJhZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVFbnRlckxlYXZlRXZlbnRzOiBmdW5jdGlvbih0YXJnZXQsIGUpIHtcbiAgICAgIHZhciBfZHJhZ2dlZG92ZXJUYXJnZXQgPSB0aGlzLl9kcmFnZ2Vkb3ZlclRhcmdldCxcbiAgICAgICAgICBfaG92ZXJlZFRhcmdldHMgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0cywgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyxcbiAgICAgICAgICBsZW5ndGggPSBNYXRoLm1heChfaG92ZXJlZFRhcmdldHMubGVuZ3RoLCB0YXJnZXRzLmxlbmd0aCk7XG5cbiAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzKHRhcmdldCwgZSwge1xuICAgICAgICBvbGRUYXJnZXQ6IF9kcmFnZ2Vkb3ZlclRhcmdldCxcbiAgICAgICAgZXZ0T3V0OiAnZHJhZ2xlYXZlJyxcbiAgICAgICAgZXZ0SW46ICdkcmFnZW50ZXInLFxuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzKHRhcmdldHNbaV0sIGUsIHtcbiAgICAgICAgICBvbGRUYXJnZXQ6IF9ob3ZlcmVkVGFyZ2V0c1tpXSxcbiAgICAgICAgICBldnRPdXQ6ICdkcmFnbGVhdmUnLFxuICAgICAgICAgIGV2dEluOiAnZHJhZ2VudGVyJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kcmFnZ2Vkb3ZlclRhcmdldCA9IHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFuYWdlIHRoZSBzeW50aGV0aWMgaW4vb3V0IGV2ZW50cyBmb3IgdGhlIGZhYnJpYyBvYmplY3RzIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCB0aGUgdGFyZ2V0IHdoZXJlIHRoZSB0YXJnZXQgZnJvbSB0aGUgc3VwcG9ydGVkIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBjb25maWd1cmF0aW9uIGZvciB0aGUgZnVuY3Rpb24gdG8gd29ya1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudGFyZ2V0TmFtZSBwcm9wZXJ0eSBvbiB0aGUgY2FudmFzIHdoZXJlIHRoZSBvbGQgdGFyZ2V0IGlzIHN0b3JlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmNhbnZhc0V2dE91dF0gbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBhdCBjYW52YXMgbGV2ZWwgZm9yIG91dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZXZ0T3V0IG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgZm9yIG91dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmNhbnZhc0V2dEluXSBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIGF0IGNhbnZhcyBsZXZlbCBmb3IgaW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmV2dEluIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgZm9yIGluXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljSW5PdXRFdmVudHM6IGZ1bmN0aW9uKHRhcmdldCwgZSwgY29uZmlnKSB7XG4gICAgICB2YXIgaW5PcHQsIG91dE9wdCwgb2xkVGFyZ2V0ID0gY29uZmlnLm9sZFRhcmdldCwgb3V0RmlyZXMsIGluRmlyZXMsXG4gICAgICAgICAgdGFyZ2V0Q2hhbmdlZCA9IG9sZFRhcmdldCAhPT0gdGFyZ2V0LCBjYW52YXNFdnRJbiA9IGNvbmZpZy5jYW52YXNFdnRJbiwgY2FudmFzRXZ0T3V0ID0gY29uZmlnLmNhbnZhc0V2dE91dDtcbiAgICAgIGlmICh0YXJnZXRDaGFuZ2VkKSB7XG4gICAgICAgIGluT3B0ID0geyBlOiBlLCB0YXJnZXQ6IHRhcmdldCwgcHJldmlvdXNUYXJnZXQ6IG9sZFRhcmdldCB9O1xuICAgICAgICBvdXRPcHQgPSB7IGU6IGUsIHRhcmdldDogb2xkVGFyZ2V0LCBuZXh0VGFyZ2V0OiB0YXJnZXQgfTtcbiAgICAgIH1cbiAgICAgIGluRmlyZXMgPSB0YXJnZXQgJiYgdGFyZ2V0Q2hhbmdlZDtcbiAgICAgIG91dEZpcmVzID0gb2xkVGFyZ2V0ICYmIHRhcmdldENoYW5nZWQ7XG4gICAgICBpZiAob3V0RmlyZXMpIHtcbiAgICAgICAgY2FudmFzRXZ0T3V0ICYmIHRoaXMuZmlyZShjYW52YXNFdnRPdXQsIG91dE9wdCk7XG4gICAgICAgIG9sZFRhcmdldC5maXJlKGNvbmZpZy5ldnRPdXQsIG91dE9wdCk7XG4gICAgICB9XG4gICAgICBpZiAoaW5GaXJlcykge1xuICAgICAgICBjYW52YXNFdnRJbiAmJiB0aGlzLmZpcmUoY2FudmFzRXZ0SW4sIGluT3B0KTtcbiAgICAgICAgdGFyZ2V0LmZpcmUoY29uZmlnLmV2dEluLCBpbk9wdCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRlZmluZXMgYWN0aW9ucyB3aGVuIGFuIEV2ZW50IE1vdXNlIFdoZWVsXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9fb25Nb3VzZVdoZWVsOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd3aGVlbCcpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqL1xuICAgIF90cmFuc2Zvcm1PYmplY3Q6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpLFxuICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm07XG5cbiAgICAgIHRyYW5zZm9ybS5yZXNldCA9IGZhbHNlO1xuICAgICAgdHJhbnNmb3JtLnNoaWZ0S2V5ID0gZS5zaGlmdEtleTtcbiAgICAgIHRyYW5zZm9ybS5hbHRLZXkgPSBlW3RoaXMuY2VudGVyZWRLZXldO1xuXG4gICAgICB0aGlzLl9wZXJmb3JtVHJhbnNmb3JtQWN0aW9uKGUsIHRyYW5zZm9ybSwgcG9pbnRlcik7XG4gICAgICB0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wZXJmb3JtVHJhbnNmb3JtQWN0aW9uOiBmdW5jdGlvbihlLCB0cmFuc2Zvcm0sIHBvaW50ZXIpIHtcbiAgICAgIHZhciB4ID0gcG9pbnRlci54LFxuICAgICAgICAgIHkgPSBwb2ludGVyLnksXG4gICAgICAgICAgYWN0aW9uID0gdHJhbnNmb3JtLmFjdGlvbixcbiAgICAgICAgICBhY3Rpb25QZXJmb3JtZWQgPSBmYWxzZSxcbiAgICAgICAgICBhY3Rpb25IYW5kbGVyID0gdHJhbnNmb3JtLmFjdGlvbkhhbmRsZXI7XG4gICAgICAgICAgLy8gdGhpcyBvYmplY3QgY291bGQgYmUgY3JlYXRlZCBmcm9tIHRoZSBmdW5jdGlvbiBpbiB0aGUgY29udHJvbCBoYW5kbGVyc1xuXG5cbiAgICAgIGlmIChhY3Rpb25IYW5kbGVyKSB7XG4gICAgICAgIGFjdGlvblBlcmZvcm1lZCA9IGFjdGlvbkhhbmRsZXIoZSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgICAgIH1cbiAgICAgIGlmIChhY3Rpb24gPT09ICdkcmFnJyAmJiBhY3Rpb25QZXJmb3JtZWQpIHtcbiAgICAgICAgdHJhbnNmb3JtLnRhcmdldC5pc01vdmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKHRyYW5zZm9ybS50YXJnZXQubW92ZUN1cnNvciB8fCB0aGlzLm1vdmVDdXJzb3IpO1xuICAgICAgfVxuICAgICAgdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCA9IHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQgfHwgYWN0aW9uUGVyZm9ybWVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlOiBmYWJyaWMuY29udHJvbHNVdGlscy5maXJlRXZlbnQsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJzb3IgZGVwZW5kaW5nIG9uIHdoZXJlIHRoZSBjYW52YXMgaXMgYmVpbmcgaG92ZXJlZC5cbiAgICAgKiBOb3RlOiB2ZXJ5IGJ1Z2d5IGluIE9wZXJhXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IE9iamVjdCB0aGF0IHRoZSBtb3VzZSBpcyBob3ZlcmluZywgaWYgc28uXG4gICAgICovXG4gICAgX3NldEN1cnNvckZyb21FdmVudDogZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5kZWZhdWx0Q3Vyc29yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGhvdmVyQ3Vyc29yID0gdGFyZ2V0LmhvdmVyQ3Vyc29yIHx8IHRoaXMuaG92ZXJDdXJzb3IsXG4gICAgICAgICAgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmIHRoaXMuX2FjdGl2ZU9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJyA/XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QgOiBudWxsLFxuICAgICAgICAgIC8vIG9ubHkgc2hvdyBwcm9wZXIgY29ybmVyIHdoZW4gZ3JvdXAgc2VsZWN0aW9uIGlzIG5vdCBhY3RpdmVcbiAgICAgICAgICBjb3JuZXIgPSAoIWFjdGl2ZVNlbGVjdGlvbiB8fCAhYWN0aXZlU2VsZWN0aW9uLmNvbnRhaW5zKHRhcmdldCkpXG4gICAgICAgICAgLy8gaGVyZSB3ZSBjYWxsIGZpbmRUYXJnZXRDb3JuZXIgYWx3YXlzIHdpdGggdW5kZWZpbmVkIGZvciB0aGUgdG91Y2ggcGFyYW1ldGVyLlxuICAgICAgICAgIC8vIHdlIGFzc3VtZSB0aGF0IGlmIHlvdSBhcmUgdXNpbmcgYSBjdXJzb3IgeW91IGRvIG5vdCBuZWVkIHRvIGludGVyYWN0IHdpdGhcbiAgICAgICAgICAvLyB0aGUgYmlnZ2VyIHRvdWNoIGFyZWEuXG4gICAgICAgICAgICAgICAgICAgICYmIHRhcmdldC5fZmluZFRhcmdldENvcm5lcih0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSkpO1xuXG4gICAgICBpZiAoIWNvcm5lcikge1xuICAgICAgICBpZiAodGFyZ2V0LnN1YlRhcmdldENoZWNrKXtcbiAgICAgICAgICAvLyBob3ZlckN1cnNvciBzaG91bGQgY29tZSBmcm9tIHRvcC1tb3N0IHN1YlRhcmdldCxcbiAgICAgICAgICAvLyBzbyB3ZSB3YWxrIHRoZSBhcnJheSBiYWNrd2FyZHNcbiAgICAgICAgICB0aGlzLnRhcmdldHMuY29uY2F0KCkucmV2ZXJzZSgpLm1hcChmdW5jdGlvbihfdGFyZ2V0KXtcbiAgICAgICAgICAgIGhvdmVyQ3Vyc29yID0gX3RhcmdldC5ob3ZlckN1cnNvciB8fCBob3ZlckN1cnNvcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEN1cnNvcihob3ZlckN1cnNvcik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5nZXRDb3JuZXJDdXJzb3IoY29ybmVyLCB0YXJnZXQsIGUpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRDb3JuZXJDdXJzb3I6IGZ1bmN0aW9uKGNvcm5lciwgdGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgY29udHJvbCA9IHRhcmdldC5jb250cm9sc1tjb3JuZXJdO1xuICAgICAgcmV0dXJuIGNvbnRyb2wuY3Vyc29yU3R5bGVIYW5kbGVyKGUsIGNvbnRyb2wsIHRhcmdldCk7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBtaW4gPSBNYXRoLm1pbixcbiAgICAgIG1heCA9IE1hdGgubWF4O1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLkNhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLkNhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBfc2hvdWxkR3JvdXA6IGZ1bmN0aW9uKGUsIHRhcmdldCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIHJldHVybiBhY3RpdmVPYmplY3QgJiYgdGhpcy5faXNTZWxlY3Rpb25LZXlQcmVzc2VkKGUpICYmIHRhcmdldCAmJiB0YXJnZXQuc2VsZWN0YWJsZSAmJiB0aGlzLnNlbGVjdGlvbiAmJlxuICAgICAgICAgICAgKGFjdGl2ZU9iamVjdCAhPT0gdGFyZ2V0IHx8IGFjdGl2ZU9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykgJiYgIXRhcmdldC5vblNlbGVjdCh7IGU6IGUgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9oYW5kbGVHcm91cGluZzogZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIC8vIGF2b2lkIG11bHRpIHNlbGVjdCB3aGVuIHNoaWZ0IGNsaWNrIG9uIGEgY29ybmVyXG4gICAgICBpZiAoYWN0aXZlT2JqZWN0Ll9fY29ybmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQgPT09IGFjdGl2ZU9iamVjdCkge1xuICAgICAgICAvLyBpZiBpdCdzIGEgZ3JvdXAsIGZpbmQgdGFyZ2V0IGFnYWluLCB1c2luZyBhY3RpdmVHcm91cCBvYmplY3RzXG4gICAgICAgIHRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlLCB0cnVlKTtcbiAgICAgICAgLy8gaWYgZXZlbiBvYmplY3QgaXMgbm90IGZvdW5kIG9yIHdlIGFyZSBvbiBhY3RpdmVPYmplY3RDb3JuZXIsIGJhaWwgb3V0XG4gICAgICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQuc2VsZWN0YWJsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZU9iamVjdCAmJiBhY3RpdmVPYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQWN0aXZlU2VsZWN0aW9uKHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlQWN0aXZlU2VsZWN0aW9uKHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZUFjdGl2ZVNlbGVjdGlvbjogZnVuY3Rpb24odGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGN1cnJlbnRBY3RpdmVPYmplY3RzID0gYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzLnNsaWNlKDApO1xuICAgICAgaWYgKGFjdGl2ZVNlbGVjdGlvbi5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIGFjdGl2ZVNlbGVjdGlvbi5yZW1vdmVXaXRoVXBkYXRlKHRhcmdldCk7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gdGhpcy50YXJnZXRzLmNvbmNhdCgpO1xuICAgICAgICBpZiAoYWN0aXZlU2VsZWN0aW9uLnNpemUoKSA9PT0gMSkge1xuICAgICAgICAgIC8vIGFjdGl2YXRlIGxhc3QgcmVtYWluaW5nIG9iamVjdFxuICAgICAgICAgIHRoaXMuX3NldEFjdGl2ZU9iamVjdChhY3RpdmVTZWxlY3Rpb24uaXRlbSgwKSwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhY3RpdmVTZWxlY3Rpb24uYWRkV2l0aFVwZGF0ZSh0YXJnZXQpO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gYWN0aXZlU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMudGFyZ2V0cy5jb25jYXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25FdmVudHMoY3VycmVudEFjdGl2ZU9iamVjdHMsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVBY3RpdmVTZWxlY3Rpb246IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdmFyIGN1cnJlbnRBY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksIGdyb3VwID0gdGhpcy5fY3JlYXRlR3JvdXAodGFyZ2V0KTtcbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBncm91cDtcbiAgICAgIC8vIElTU1VFIDQxMTU6IHNob3VsZCB3ZSBjb25zaWRlciBzdWJUYXJnZXRzIGhlcmU/XG4gICAgICAvLyB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IFtdO1xuICAgICAgLy8gdGhpcy5faG92ZXJlZFRhcmdldHMgPSB0aGlzLnRhcmdldHMuY29uY2F0KCk7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVPYmplY3QoZ3JvdXAsIGUpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhjdXJyZW50QWN0aXZlcywgZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9jcmVhdGVHcm91cDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG4gICAgICAgICAgaXNBY3RpdmVMb3dlciA9IG9iamVjdHMuaW5kZXhPZih0aGlzLl9hY3RpdmVPYmplY3QpIDwgb2JqZWN0cy5pbmRleE9mKHRhcmdldCksXG4gICAgICAgICAgZ3JvdXBPYmplY3RzID0gaXNBY3RpdmVMb3dlclxuICAgICAgICAgICAgPyBbdGhpcy5fYWN0aXZlT2JqZWN0LCB0YXJnZXRdXG4gICAgICAgICAgICA6IFt0YXJnZXQsIHRoaXMuX2FjdGl2ZU9iamVjdF07XG4gICAgICB0aGlzLl9hY3RpdmVPYmplY3QuaXNFZGl0aW5nICYmIHRoaXMuX2FjdGl2ZU9iamVjdC5leGl0RWRpdGluZygpO1xuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKGdyb3VwT2JqZWN0cywge1xuICAgICAgICBjYW52YXM6IHRoaXNcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKi9cbiAgICBfZ3JvdXBTZWxlY3RlZE9iamVjdHM6IGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgIHZhciBncm91cCA9IHRoaXMuX2NvbGxlY3RPYmplY3RzKGUpLFxuICAgICAgICAgIGFHcm91cDtcblxuICAgICAgLy8gZG8gbm90IGNyZWF0ZSBncm91cCBmb3IgMSBlbGVtZW50IG9ubHlcbiAgICAgIGlmIChncm91cC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVPYmplY3QoZ3JvdXBbMF0sIGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZ3JvdXAubGVuZ3RoID4gMSkge1xuICAgICAgICBhR3JvdXAgPSBuZXcgZmFicmljLkFjdGl2ZVNlbGVjdGlvbihncm91cC5yZXZlcnNlKCksIHtcbiAgICAgICAgICBjYW52YXM6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KGFHcm91cCwgZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NvbGxlY3RPYmplY3RzOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBbXSxcbiAgICAgICAgICBjdXJyZW50T2JqZWN0LFxuICAgICAgICAgIHgxID0gdGhpcy5fZ3JvdXBTZWxlY3Rvci5leCxcbiAgICAgICAgICB5MSA9IHRoaXMuX2dyb3VwU2VsZWN0b3IuZXksXG4gICAgICAgICAgeDIgPSB4MSArIHRoaXMuX2dyb3VwU2VsZWN0b3IubGVmdCxcbiAgICAgICAgICB5MiA9IHkxICsgdGhpcy5fZ3JvdXBTZWxlY3Rvci50b3AsXG4gICAgICAgICAgc2VsZWN0aW9uWDFZMSA9IG5ldyBmYWJyaWMuUG9pbnQobWluKHgxLCB4MiksIG1pbih5MSwgeTIpKSxcbiAgICAgICAgICBzZWxlY3Rpb25YMlkyID0gbmV3IGZhYnJpYy5Qb2ludChtYXgoeDEsIHgyKSwgbWF4KHkxLCB5MikpLFxuICAgICAgICAgIGFsbG93SW50ZXJzZWN0ID0gIXRoaXMuc2VsZWN0aW9uRnVsbHlDb250YWluZWQsXG4gICAgICAgICAgaXNDbGljayA9IHgxID09PSB4MiAmJiB5MSA9PT0geTI7XG4gICAgICAvLyB3ZSBpdGVyYXRlIHJldmVyc2Ugb3JkZXIgdG8gY29sbGVjdCB0b3AgZmlyc3QgaW4gY2FzZSBvZiBjbGljay5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgY3VycmVudE9iamVjdCA9IHRoaXMuX29iamVjdHNbaV07XG5cbiAgICAgICAgaWYgKCFjdXJyZW50T2JqZWN0IHx8ICFjdXJyZW50T2JqZWN0LnNlbGVjdGFibGUgfHwgIWN1cnJlbnRPYmplY3QudmlzaWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChhbGxvd0ludGVyc2VjdCAmJiBjdXJyZW50T2JqZWN0LmludGVyc2VjdHNXaXRoUmVjdChzZWxlY3Rpb25YMVkxLCBzZWxlY3Rpb25YMlkyLCB0cnVlKSkgfHxcbiAgICAgICAgICAgIGN1cnJlbnRPYmplY3QuaXNDb250YWluZWRXaXRoaW5SZWN0KHNlbGVjdGlvblgxWTEsIHNlbGVjdGlvblgyWTIsIHRydWUpIHx8XG4gICAgICAgICAgICAoYWxsb3dJbnRlcnNlY3QgJiYgY3VycmVudE9iamVjdC5jb250YWluc1BvaW50KHNlbGVjdGlvblgxWTEsIG51bGwsIHRydWUpKSB8fFxuICAgICAgICAgICAgKGFsbG93SW50ZXJzZWN0ICYmIGN1cnJlbnRPYmplY3QuY29udGFpbnNQb2ludChzZWxlY3Rpb25YMlkyLCBudWxsLCB0cnVlKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgZ3JvdXAucHVzaChjdXJyZW50T2JqZWN0KTtcbiAgICAgICAgICAvLyBvbmx5IGFkZCBvbmUgb2JqZWN0IGlmIGl0J3MgYSBjbGlja1xuICAgICAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdyb3VwLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cC5maWx0ZXIoZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuICFvYmplY3Qub25TZWxlY3QoeyBlOiBlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYXliZUdyb3VwT2JqZWN0czogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICYmIHRoaXMuX2dyb3VwU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RlZE9iamVjdHMoZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmRlZmF1bHRDdXJzb3IpO1xuICAgICAgLy8gY2xlYXIgc2VsZWN0aW9uIGFuZCBjdXJyZW50IHRyYW5zZm9ybWF0aW9uXG4gICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0gbnVsbDtcbiAgICB9XG4gIH0pO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRXhwb3J0cyBjYW52YXMgZWxlbWVudCB0byBhIGRhdGF1cmwgaW1hZ2UuIE5vdGUgdGhhdCB3aGVuIG11bHRpcGxpZXIgaXMgdXNlZCwgY3JvcHBpbmcgaXMgc2NhbGVkIGFwcHJvcHJpYXRlbHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmZvcm1hdD1wbmddIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCBpbWFnZS4gRWl0aGVyIFwianBlZ1wiIG9yIFwicG5nXCJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucXVhbGl0eT0xXSBRdWFsaXR5IGxldmVsICgwLi4xKS4gT25seSB1c2VkIGZvciBqcGVnLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tdWx0aXBsaWVyPTFdIE11bHRpcGxpZXIgdG8gc2NhbGUgYnksIHRvIGhhdmUgY29uc2lzdGVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAyLjAuMFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIGRhdGE6IFVSTCBjb250YWluaW5nIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSBvcHRpb25zLmZvcm1hdFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvTmZaVmIvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2VuZXJhdGUganBlZyBkYXRhVVJMIHdpdGggbG93ZXIgcXVhbGl0eTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoe1xuICAgICAqICAgZm9ybWF0OiAnanBlZycsXG4gICAgICogICBxdWFsaXR5OiAwLjhcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZW5lcmF0ZSBjcm9wcGVkIHBuZyBkYXRhVVJMIChjbGlwcGluZyBvZiBjYW52YXMpPC9jYXB0aW9uPlxuICAgICAqIHZhciBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCh7XG4gICAgICogICBmb3JtYXQ6ICdwbmcnLFxuICAgICAqICAgbGVmdDogMTAwLFxuICAgICAqICAgdG9wOiAxMDAsXG4gICAgICogICB3aWR0aDogMjAwLFxuICAgICAqICAgaGVpZ2h0OiAyMDBcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZW5lcmF0ZSBkb3VibGUgc2NhbGVkIHBuZyBkYXRhVVJMPC9jYXB0aW9uPlxuICAgICAqIHZhciBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCh7XG4gICAgICogICBmb3JtYXQ6ICdwbmcnLFxuICAgICAqICAgbXVsdGlwbGllcjogMlxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgJ3BuZycsXG4gICAgICAgICAgcXVhbGl0eSA9IG9wdGlvbnMucXVhbGl0eSB8fCAxLFxuICAgICAgICAgIG11bHRpcGxpZXIgPSAob3B0aW9ucy5tdWx0aXBsaWVyIHx8IDEpICogKG9wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZyA/IHRoaXMuZ2V0UmV0aW5hU2NhbGluZygpIDogMSksXG4gICAgICAgICAgY2FudmFzRWwgPSB0aGlzLnRvQ2FudmFzRWxlbWVudChtdWx0aXBsaWVyLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC50b0RhdGFVUkwoY2FudmFzRWwsIGZvcm1hdCwgcXVhbGl0eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBIVE1MQ2FudmFzIGVsZW1lbnQgcGFpbnRlZCB3aXRoIHRoZSBjdXJyZW50IGNhbnZhcyBjb250ZW50LlxuICAgICAqIE5vIG5lZWQgdG8gcmVzaXplIHRoZSBhY3R1YWwgb25lIG9yIHJlcGFpbnQgaXQuXG4gICAgICogV2lsbCB0cmFuc2ZlciBvYmplY3Qgb3duZXJzaGlwIHRvIGEgbmV3IGNhbnZhcywgcGFpbnQgaXQsIGFuZCBzZXQgZXZlcnl0aGluZyBiYWNrLlxuICAgICAqIFRoaXMgaXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAgdXNlZCB0byBnZXQgdG8gYSBkYXRhVXJsIGJ1dCBhbHNvIGl0IGlzIHVzZWZ1bCB0b1xuICAgICAqIGNyZWF0ZSBxdWljayBpbWFnZSBjb3BpZXMgb2YgYSBjYW52YXMgd2l0aG91dCBwYXNzaW5nIGZvciB0aGUgZGF0YVVybCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW211bHRpcGxpZXJdIGEgem9vbSBmYWN0b3IuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjcm9wcGluZ10gQ3JvcHBpbmcgaW5mb3JtYXRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjcm9wcGluZy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Nyb3BwaW5nLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Nyb3BwaW5nLndpZHRoXSBDcm9wcGluZyB3aWR0aC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Nyb3BwaW5nLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LlxuICAgICAqL1xuICAgIHRvQ2FudmFzRWxlbWVudDogZnVuY3Rpb24obXVsdGlwbGllciwgY3JvcHBpbmcpIHtcbiAgICAgIG11bHRpcGxpZXIgPSBtdWx0aXBsaWVyIHx8IDE7XG4gICAgICBjcm9wcGluZyA9IGNyb3BwaW5nIHx8IHsgfTtcbiAgICAgIHZhciBzY2FsZWRXaWR0aCA9IChjcm9wcGluZy53aWR0aCB8fCB0aGlzLndpZHRoKSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgc2NhbGVkSGVpZ2h0ID0gKGNyb3BwaW5nLmhlaWdodCB8fCB0aGlzLmhlaWdodCkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHpvb20gPSB0aGlzLmdldFpvb20oKSxcbiAgICAgICAgICBvcmlnaW5hbFdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBvcmlnaW5hbEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIG5ld1pvb20gPSB6b29tICogbXVsdGlwbGllcixcbiAgICAgICAgICB2cCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdHJhbnNsYXRlWCA9ICh2cFs0XSAtIChjcm9wcGluZy5sZWZ0IHx8IDApKSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgdHJhbnNsYXRlWSA9ICh2cFs1XSAtIChjcm9wcGluZy50b3AgfHwgMCkpICogbXVsdGlwbGllcixcbiAgICAgICAgICBvcmlnaW5hbEludGVyYWN0aXZlID0gdGhpcy5pbnRlcmFjdGl2ZSxcbiAgICAgICAgICBuZXdWcCA9IFtuZXdab29tLCAwLCAwLCBuZXdab29tLCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSxcbiAgICAgICAgICBvcmlnaW5hbFJldGluYSA9IHRoaXMuZW5hYmxlUmV0aW5hU2NhbGluZyxcbiAgICAgICAgICBjYW52YXNFbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcbiAgICAgICAgICBvcmlnaW5hbENvbnRleHRUb3AgPSB0aGlzLmNvbnRleHRUb3A7XG4gICAgICBjYW52YXNFbC53aWR0aCA9IHNjYWxlZFdpZHRoO1xuICAgICAgY2FudmFzRWwuaGVpZ2h0ID0gc2NhbGVkSGVpZ2h0O1xuICAgICAgdGhpcy5jb250ZXh0VG9wID0gbnVsbDtcbiAgICAgIHRoaXMuZW5hYmxlUmV0aW5hU2NhbGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSA9IG5ld1ZwO1xuICAgICAgdGhpcy53aWR0aCA9IHNjYWxlZFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBzY2FsZWRIZWlnaHQ7XG4gICAgICB0aGlzLmNhbGNWaWV3cG9ydEJvdW5kYXJpZXMoKTtcbiAgICAgIHRoaXMucmVuZGVyQ2FudmFzKGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksIHRoaXMuX29iamVjdHMpO1xuICAgICAgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSA9IHZwO1xuICAgICAgdGhpcy53aWR0aCA9IG9yaWdpbmFsV2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IG9yaWdpbmFsSGVpZ2h0O1xuICAgICAgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLmludGVyYWN0aXZlID0gb3JpZ2luYWxJbnRlcmFjdGl2ZTtcbiAgICAgIHRoaXMuZW5hYmxlUmV0aW5hU2NhbGluZyA9IG9yaWdpbmFsUmV0aW5hO1xuICAgICAgdGhpcy5jb250ZXh0VG9wID0gb3JpZ2luYWxDb250ZXh0VG9wO1xuICAgICAgcmV0dXJuIGNhbnZhc0VsO1xuICAgIH0sXG4gIH0pO1xuXG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuICAvKipcbiAgICogUG9wdWxhdGVzIGNhbnZhcyB3aXRoIGRhdGEgZnJvbSB0aGUgc3BlY2lmaWVkIEpTT04uXG4gICAqIEpTT04gZm9ybWF0IG11c3QgY29uZm9ybSB0byB0aGUgb25lIG9mIHtAbGluayBmYWJyaWMuQ2FudmFzI3RvSlNPTn1cbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBqc29uIEpTT04gc3RyaW5nIG9yIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjaywgaW52b2tlZCB3aGVuIGpzb24gaXMgcGFyc2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBjb3JyZXNwb25kaW5nIG9iamVjdHMgKGUuZzoge0BsaW5rIGZhYnJpYy5JbWFnZX0pXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBpbml0aWFsaXplZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgSlNPTiBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgKiBAY2hhaW5hYmxlXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI2Rlc2VyaWFsaXphdGlvbn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9mbWdYdC98anNGaWRkbGUgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+bG9hZEZyb21KU09OPC9jYXB0aW9uPlxuICAgKiBjYW52YXMubG9hZEZyb21KU09OKGpzb24sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+bG9hZEZyb21KU09OIHdpdGggcmV2aXZlcjwvY2FwdGlvbj5cbiAgICogY2FudmFzLmxvYWRGcm9tSlNPTihqc29uLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwgZnVuY3Rpb24obywgb2JqZWN0KSB7XG4gICAqICAgLy8gYG9gID0ganNvbiBvYmplY3RcbiAgICogICAvLyBgb2JqZWN0YCA9IGZhYnJpYy5PYmplY3QgaW5zdGFuY2VcbiAgICogICAvLyAuLi4gZG8gc29tZSBzdHVmZiAuLi5cbiAgICogfSk7XG4gICAqL1xuICBsb2FkRnJvbUpTT046IGZ1bmN0aW9uIChqc29uLCBjYWxsYmFjaywgcmV2aXZlcikge1xuICAgIGlmICghanNvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNlcmlhbGl6ZSBpZiBpdCB3YXNuJ3QgYWxyZWFkeVxuICAgIHZhciBzZXJpYWxpemVkID0gKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJylcbiAgICAgID8gSlNPTi5wYXJzZShqc29uKVxuICAgICAgOiBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUoanNvbik7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBjbGlwUGF0aCA9IHNlcmlhbGl6ZWQuY2xpcFBhdGgsXG4gICAgICAgIHJlbmRlck9uQWRkUmVtb3ZlID0gdGhpcy5yZW5kZXJPbkFkZFJlbW92ZTtcblxuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgPSBmYWxzZTtcblxuICAgIGRlbGV0ZSBzZXJpYWxpemVkLmNsaXBQYXRoO1xuXG4gICAgdGhpcy5fZW5saXZlbk9iamVjdHMoc2VyaWFsaXplZC5vYmplY3RzLCBmdW5jdGlvbiAoZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgX3RoaXMuY2xlYXIoKTtcbiAgICAgIF90aGlzLl9zZXRCZ092ZXJsYXkoc2VyaWFsaXplZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgICBfdGhpcy5fZW5saXZlbk9iamVjdHMoW2NsaXBQYXRoXSwgZnVuY3Rpb24gKGVubGl2ZW5lZENhbnZhc0NsaXApIHtcbiAgICAgICAgICAgIF90aGlzLmNsaXBQYXRoID0gZW5saXZlbmVkQ2FudmFzQ2xpcFswXTtcbiAgICAgICAgICAgIF90aGlzLl9fc2V0dXBDYW52YXMuY2FsbChfdGhpcywgc2VyaWFsaXplZCwgZW5saXZlbmVkT2JqZWN0cywgcmVuZGVyT25BZGRSZW1vdmUsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5fX3NldHVwQ2FudmFzLmNhbGwoX3RoaXMsIHNlcmlhbGl6ZWQsIGVubGl2ZW5lZE9iamVjdHMsIHJlbmRlck9uQWRkUmVtb3ZlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHJldml2ZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VyaWFsaXplZCBPYmplY3Qgd2l0aCBiYWNrZ3JvdW5kIGFuZCBvdmVybGF5IGluZm9ybWF0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3RvcmVkIGNhbnZhcyBvYmplY3RzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhY2hlZCByZW5kZXJPbkFkZFJlbW92ZSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIGFmdGVyIGFsbCBiYWNrZ3JvdW5kIGFuZCBvdmVybGF5IGltYWdlcy9wYXR0ZXJucyBsb2FkZWRcbiAgICovXG4gIF9fc2V0dXBDYW52YXM6IGZ1bmN0aW9uKHNlcmlhbGl6ZWQsIGVubGl2ZW5lZE9iamVjdHMsIHJlbmRlck9uQWRkUmVtb3ZlLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgZW5saXZlbmVkT2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iaiwgaW5kZXgpIHtcbiAgICAgIC8vIHdlIHNwbGljZSB0aGUgYXJyYXkganVzdCBpbiBjYXNlIHNvbWUgY3VzdG9tIGNsYXNzZXMgcmVzdG9yZWQgZnJvbSBKU09OXG4gICAgICAvLyB3aWxsIGFkZCBtb3JlIG9iamVjdCB0byBjYW52YXMgYXQgY2FudmFzIGluaXQuXG4gICAgICBfdGhpcy5pbnNlcnRBdChvYmosIGluZGV4KTtcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlID0gcmVuZGVyT25BZGRSZW1vdmU7XG4gICAgLy8gcmVtb3ZlIHBhcnRzIGkgY2Fubm90IHNldCBhcyBvcHRpb25zXG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQub2JqZWN0cztcbiAgICBkZWxldGUgc2VyaWFsaXplZC5iYWNrZ3JvdW5kSW1hZ2U7XG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQub3ZlcmxheUltYWdlO1xuICAgIGRlbGV0ZSBzZXJpYWxpemVkLmJhY2tncm91bmQ7XG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQub3ZlcmxheTtcbiAgICAvLyB0aGlzLl9pbml0T3B0aW9ucyBkb2VzIHRvbyBtYW55IHRoaW5ncyB0byBqdXN0XG4gICAgLy8gY2FsbCBpdC4gTm9ybWFsbHkgbG9hZGluZyBhbiBPYmplY3QgZnJvbSBKU09OXG4gICAgLy8gY3JlYXRlIHRoZSBPYmplY3QgaW5zdGFuY2UuIEhlcmUgdGhlIENhbnZhcyBpc1xuICAgIC8vIGFscmVhZHkgYW4gaW5zdGFuY2UgYW5kIHdlIGFyZSBqdXN0IGxvYWRpbmcgdGhpbmdzIG92ZXIgaXRcbiAgICB0aGlzLl9zZXRPcHRpb25zKHNlcmlhbGl6ZWQpO1xuICAgIHRoaXMucmVuZGVyQWxsKCk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlcmlhbGl6ZWQgT2JqZWN0IHdpdGggYmFja2dyb3VuZCBhbmQgb3ZlcmxheSBpbmZvcm1hdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIGFmdGVyIGFsbCBiYWNrZ3JvdW5kIGFuZCBvdmVybGF5IGltYWdlcy9wYXR0ZXJucyBsb2FkZWRcbiAgICovXG4gIF9zZXRCZ092ZXJsYXk6IGZ1bmN0aW9uKHNlcmlhbGl6ZWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxvYWRlZCA9IHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogZmFsc2UsXG4gICAgICBvdmVybGF5Q29sb3I6IGZhbHNlLFxuICAgICAgYmFja2dyb3VuZEltYWdlOiBmYWxzZSxcbiAgICAgIG92ZXJsYXlJbWFnZTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKCFzZXJpYWxpemVkLmJhY2tncm91bmRJbWFnZSAmJiAhc2VyaWFsaXplZC5vdmVybGF5SW1hZ2UgJiYgIXNlcmlhbGl6ZWQuYmFja2dyb3VuZCAmJiAhc2VyaWFsaXplZC5vdmVybGF5KSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjYklmTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGxvYWRlZC5iYWNrZ3JvdW5kSW1hZ2UgJiYgbG9hZGVkLm92ZXJsYXlJbWFnZSAmJiBsb2FkZWQuYmFja2dyb3VuZENvbG9yICYmIGxvYWRlZC5vdmVybGF5Q29sb3IpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5fX3NldEJnT3ZlcmxheSgnYmFja2dyb3VuZEltYWdlJywgc2VyaWFsaXplZC5iYWNrZ3JvdW5kSW1hZ2UsIGxvYWRlZCwgY2JJZkxvYWRlZCk7XG4gICAgdGhpcy5fX3NldEJnT3ZlcmxheSgnb3ZlcmxheUltYWdlJywgc2VyaWFsaXplZC5vdmVybGF5SW1hZ2UsIGxvYWRlZCwgY2JJZkxvYWRlZCk7XG4gICAgdGhpcy5fX3NldEJnT3ZlcmxheSgnYmFja2dyb3VuZENvbG9yJywgc2VyaWFsaXplZC5iYWNrZ3JvdW5kLCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ292ZXJsYXlDb2xvcicsIHNlcmlhbGl6ZWQub3ZlcmxheSwgbG9hZGVkLCBjYklmTG9hZGVkKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHNldCAoYmFja2dyb3VuZEltYWdlLCBvdmVybGF5SW1hZ2UsIGJhY2tncm91bmRDb2xvciwgb3ZlcmxheUNvbG9yKVxuICAgKiBAcGFyYW0geyhPYmplY3R8U3RyaW5nKX0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkZWQgU2V0IGxvYWRlZCBwcm9wZXJ0eSB0byB0cnVlIGlmIHByb3BlcnR5IGlzIHNldFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlIGFmdGVyIHByb3BlcnR5IGlzIHNldFxuICAgKi9cbiAgX19zZXRCZ092ZXJsYXk6IGZ1bmN0aW9uKHByb3BlcnR5LCB2YWx1ZSwgbG9hZGVkLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICBsb2FkZWRbcHJvcGVydHldID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5ID09PSAnYmFja2dyb3VuZEltYWdlJyB8fCBwcm9wZXJ0eSA9PT0gJ292ZXJsYXlJbWFnZScpIHtcbiAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKFt2YWx1ZV0sIGZ1bmN0aW9uKGVubGl2ZWRPYmplY3Qpe1xuICAgICAgICBfdGhpc1twcm9wZXJ0eV0gPSBlbmxpdmVkT2JqZWN0WzBdO1xuICAgICAgICBsb2FkZWRbcHJvcGVydHldID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXNbJ3NldCcgKyBmYWJyaWMudXRpbC5zdHJpbmcuY2FwaXRhbGl6ZShwcm9wZXJ0eSwgdHJ1ZSldKHZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdXG4gICAqL1xuICBfZW5saXZlbk9iamVjdHM6IGZ1bmN0aW9uIChvYmplY3RzLCBjYWxsYmFjaywgcmV2aXZlcikge1xuICAgIGlmICghb2JqZWN0cyB8fCBvYmplY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soW10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKG9iamVjdHMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZE9iamVjdHMpO1xuICAgIH0sIG51bGwsIHJldml2ZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBfdG9EYXRhVVJMOiBmdW5jdGlvbiAoZm9ybWF0LCBjYWxsYmFjaykge1xuICAgIHRoaXMuY2xvbmUoZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICBjYWxsYmFjayhjbG9uZS50b0RhdGFVUkwoZm9ybWF0KSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG11bHRpcGxpZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIF90b0RhdGFVUkxXaXRoTXVsdGlwbGllcjogZnVuY3Rpb24gKGZvcm1hdCwgbXVsdGlwbGllciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmNsb25lKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgY2FsbGJhY2soY2xvbmUudG9EYXRhVVJMV2l0aE11bHRpcGxpZXIoZm9ybWF0LCBtdWx0aXBsaWVyKSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lcyBjYW52YXMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja10gUmVjZWl2ZXMgY2xvbmVkIGluc3RhbmNlIGFzIGEgZmlyc3QgYXJndW1lbnRcbiAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNdIEFycmF5IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSBpbiB0aGUgY2xvbmVkIGNhbnZhcyBhbmQgY2hpbGRyZW5cbiAgICovXG4gIGNsb25lOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKHByb3BlcnRpZXMpKTtcbiAgICB0aGlzLmNsb25lV2l0aG91dERhdGEoZnVuY3Rpb24oY2xvbmUpIHtcbiAgICAgIGNsb25lLmxvYWRGcm9tSlNPTihkYXRhLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soY2xvbmUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lcyBjYW52YXMgaW5zdGFuY2Ugd2l0aG91dCBjbG9uaW5nIGV4aXN0aW5nIGRhdGEuXG4gICAqIFRoaXMgZXNzZW50aWFsbHkgY29waWVzIGNhbnZhcyBkaW1lbnNpb25zLCBjbGlwcGluZyBwcm9wZXJ0aWVzLCBldGMuXG4gICAqIGJ1dCBsZWF2ZXMgZGF0YSBlbXB0eSAoc28gdGhhdCB5b3UgY2FuIHBvcHVsYXRlIGl0IHdpdGggeW91ciBvd24pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tdIFJlY2VpdmVzIGNsb25lZCBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBjbG9uZVdpdGhvdXREYXRhOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBlbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcblxuICAgIGVsLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICBlbC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgIHZhciBjbG9uZSA9IG5ldyBmYWJyaWMuQ2FudmFzKGVsKTtcbiAgICBpZiAodGhpcy5iYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICAgIGNsb25lLnNldEJhY2tncm91bmRJbWFnZSh0aGlzLmJhY2tncm91bmRJbWFnZS5zcmMsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjbG9uZS5yZW5kZXJBbGwoKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soY2xvbmUpO1xuICAgICAgfSk7XG4gICAgICBjbG9uZS5iYWNrZ3JvdW5kSW1hZ2VPcGFjaXR5ID0gdGhpcy5iYWNrZ3JvdW5kSW1hZ2VPcGFjaXR5O1xuICAgICAgY2xvbmUuYmFja2dyb3VuZEltYWdlU3RyZXRjaCA9IHRoaXMuYmFja2dyb3VuZEltYWdlU3RyZXRjaDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhjbG9uZSk7XG4gICAgfVxuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgY2FwaXRhbGl6ZSA9IGZhYnJpYy51dGlsLnN0cmluZy5jYXBpdGFsaXplLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBvYmplY3RDYWNoaW5nID0gIWZhYnJpYy5pc0xpa2VseU5vZGUsXG4gICAgICBBTElBU0lOR19MSU1JVCA9IDI7XG5cbiAgaWYgKGZhYnJpYy5PYmplY3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUm9vdCBvYmplY3QgY2xhc3MgZnJvbSB3aGljaCBhbGwgMmQgc2hhcGUgY2xhc3NlcyBpbmhlcml0IGZyb21cbiAgICogQGNsYXNzIGZhYnJpYy5PYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjb2JqZWN0c31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLk9iamVjdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKlxuICAgKiBAZmlyZXMgYWRkZWRcbiAgICogQGZpcmVzIHJlbW92ZWRcbiAgICpcbiAgICogQGZpcmVzIHNlbGVjdGVkXG4gICAqIEBmaXJlcyBkZXNlbGVjdGVkXG4gICAqIEBmaXJlcyBtb2RpZmllZFxuICAgKiBAZmlyZXMgbW9kaWZpZWRcbiAgICogQGZpcmVzIG1vdmVkXG4gICAqIEBmaXJlcyBzY2FsZWRcbiAgICogQGZpcmVzIHJvdGF0ZWRcbiAgICogQGZpcmVzIHNrZXdlZFxuICAgKlxuICAgKiBAZmlyZXMgcm90YXRpbmdcbiAgICogQGZpcmVzIHNjYWxpbmdcbiAgICogQGZpcmVzIG1vdmluZ1xuICAgKiBAZmlyZXMgc2tld2luZ1xuICAgKlxuICAgKiBAZmlyZXMgbW91c2Vkb3duXG4gICAqIEBmaXJlcyBtb3VzZXVwXG4gICAqIEBmaXJlcyBtb3VzZW92ZXJcbiAgICogQGZpcmVzIG1vdXNlb3V0XG4gICAqIEBmaXJlcyBtb3VzZXdoZWVsXG4gICAqIEBmaXJlcyBtb3VzZWRibGNsaWNrXG4gICAqXG4gICAqIEBmaXJlcyBkcmFnb3ZlclxuICAgKiBAZmlyZXMgZHJhZ2VudGVyXG4gICAqIEBmaXJlcyBkcmFnbGVhdmVcbiAgICogQGZpcmVzIGRyb3BcbiAgICovXG4gIGZhYnJpYy5PYmplY3QgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQ29tbW9uTWV0aG9kcywgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdCAocmVjdCwgY2lyY2xlLCBwYXRoLCBldGMuKS5cbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBtZWFudCB0byBiZSByZWFkLW9ubHkgYW5kIG5vdCBtZWFudCB0byBiZSBtb2RpZmllZC5cbiAgICAgKiBJZiB5b3UgbW9kaWZ5LCBjZXJ0YWluIHBhcnRzIG9mIEZhYnJpYyAoc3VjaCBhcyBKU09OIGxvYWRpbmcpIHdvbid0IHdvcmsgY29ycmVjdGx5LlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogICAgICAgICAgICAgICAgICAgICAnb2JqZWN0JyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uIG9mIGFuIG9iamVjdCAob25lIG9mIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiY2VudGVyXCIpXG4gICAgICogU2VlIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvMW93MDJnZWEvMjQ0LyBvbiBob3cgb3JpZ2luWC9vcmlnaW5ZIGFmZmVjdCBvYmplY3RzIGluIGdyb3Vwc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3JpZ2luWDogICAgICAgICAgICAgICAgICAnbGVmdCcsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24gb2YgYW4gb2JqZWN0IChvbmUgb2YgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJjZW50ZXJcIilcbiAgICAgKiBTZWUgaHR0cDovL2pzZmlkZGxlLm5ldC8xb3cwMmdlYS8yNDQvIG9uIGhvdyBvcmlnaW5YL29yaWdpblkgYWZmZWN0IG9iamVjdHMgaW4gZ3JvdXBzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvcmlnaW5ZOiAgICAgICAgICAgICAgICAgICd0b3AnLFxuXG4gICAgLyoqXG4gICAgICogVG9wIHBvc2l0aW9uIG9mIGFuIG9iamVjdC4gTm90ZSB0aGF0IGJ5IGRlZmF1bHQgaXQncyByZWxhdGl2ZSB0byBvYmplY3QgdG9wLiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHNldHRpbmcgb3JpZ2luWT17dG9wL2NlbnRlci9ib3R0b219XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0b3A6ICAgICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBMZWZ0IHBvc2l0aW9uIG9mIGFuIG9iamVjdC4gTm90ZSB0aGF0IGJ5IGRlZmF1bHQgaXQncyByZWxhdGl2ZSB0byBvYmplY3QgbGVmdC4gWW91IGNhbiBjaGFuZ2UgdGhpcyBieSBzZXR0aW5nIG9yaWdpblg9e2xlZnQvY2VudGVyL3JpZ2h0fVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbGVmdDogICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHdpZHRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB3aWR0aDogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBoZWlnaHQ6ICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3Qgc2NhbGUgZmFjdG9yIChob3Jpem9udGFsKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVYOiAgICAgICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHNjYWxlIGZhY3RvciAodmVydGljYWwpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVk6ICAgICAgICAgICAgICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGFuIG9iamVjdCBpcyByZW5kZXJlZCBhcyBmbGlwcGVkIGhvcml6b250YWxseVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZsaXBYOiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGFuIG9iamVjdCBpcyByZW5kZXJlZCBhcyBmbGlwcGVkIHZlcnRpY2FsbHlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmbGlwWTogICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogT3BhY2l0eSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHJvdGF0aW9uIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFuZ2xlOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHNrZXcgb24geCBheGVzIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNrZXdYOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHNrZXcgb24geSBheGVzIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNrZXdZOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgY29ybmVycyAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29ybmVyU2l6ZTogICAgICAgICAgICAgICAxMyxcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgY29ybmVycyB3aGVuIHRvdWNoIGludGVyYWN0aW9uIGlzIGRldGVjdGVkXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0b3VjaENvcm5lclNpemU6ICAgICAgICAgICAgICAgMjQsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdCdzIGNvbnRyb2xsaW5nIGNvcm5lcnMgYXJlIHJlbmRlcmVkIGFzIHRyYW5zcGFyZW50IGluc2lkZSAoaS5lLiBzdHJva2UgaW5zdGVhZCBvZiBmaWxsKVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRyYW5zcGFyZW50Q29ybmVyczogICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBob3ZlcmluZyBvdmVyIHRoaXMgb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaG92ZXJDdXJzb3I6ICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIG1vdmluZyB0aGlzIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1vdmVDdXJzb3I6ICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFBhZGRpbmcgYmV0d2VlbiBvYmplY3QgYW5kIGl0cyBjb250cm9sbGluZyBib3JkZXJzIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYWRkaW5nOiAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBjb250cm9sbGluZyBib3JkZXJzIG9mIGFuIG9iamVjdCAod2hlbiBpdCdzIGFjdGl2ZSlcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJvcmRlckNvbG9yOiAgICAgICAgICAgICAgJ3JnYigxNzgsMjA0LDI1NSknLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgc3BlY2lmeWluZyBkYXNoIHBhdHRlcm4gb2YgYW4gb2JqZWN0J3MgYm9yZGVycyAoaGFzQm9yZGVyIG11c3QgYmUgdHJ1ZSlcbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGJvcmRlckRhc2hBcnJheTogICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGNvcm5lcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29ybmVyQ29sb3I6ICAgICAgICAgICAgICAncmdiKDE3OCwyMDQsMjU1KScsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBjb250cm9sbGluZyBjb3JuZXJzIG9mIGFuIG9iamVjdCAod2hlbiBpdCdzIGFjdGl2ZSBhbmQgdHJhbnNwYXJlbnRDb3JuZXJzIGZhbHNlKVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29ybmVyU3Ryb2tlQ29sb3I6ICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBzdHlsZSBvZiBjb250cm9sLCAncmVjdCcgb3IgJ2NpcmNsZSdcbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICBjb3JuZXJTdHlsZTogICAgICAgICAgJ3JlY3QnLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgc3BlY2lmeWluZyBkYXNoIHBhdHRlcm4gb2YgYW4gb2JqZWN0J3MgY29udHJvbCAoaGFzQm9yZGVyIG11c3QgYmUgdHJ1ZSlcbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGNvcm5lckRhc2hBcnJheTogICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGhpcyBvYmplY3Qgd2lsbCB1c2UgY2VudGVyIHBvaW50IGFzIHRoZSBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb25cbiAgICAgKiB3aGVuIGJlaW5nIHNjYWxlZCB2aWEgdGhlIGNvbnRyb2xzLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRTY2FsaW5nOiAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGhpcyBvYmplY3Qgd2lsbCB1c2UgY2VudGVyIHBvaW50IGFzIHRoZSBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb25cbiAgICAgKiB3aGVuIGJlaW5nIHJvdGF0ZWQgdmlhIHRoZSBjb250cm9scy5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkUm90YXRpb246ICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIG9iamVjdCdzIGZpbGxcbiAgICAgKiB0YWtlcyBjc3MgY29sb3JzIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItMy9cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZpbGw6ICAgICAgICAgICAgICAgICAgICAgJ3JnYigwLDAsMCknLFxuXG4gICAgLyoqXG4gICAgICogRmlsbCBydWxlIHVzZWQgdG8gZmlsbCBhbiBvYmplY3RcbiAgICAgKiBhY2NlcHRlZCB2YWx1ZXMgYXJlIG5vbnplcm8sIGV2ZW5vZGRcbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHdhcyB1c2VkIGZvciBzZXR0aW5nIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiB1bnRpbCB2MS40LjEyICh1c2UgYGZhYnJpYy5PYmplY3QjZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uYCBpbnN0ZWFkKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlsbFJ1bGU6ICAgICAgICAgICAgICAgICAnbm9uemVybycsXG5cbiAgICAvKipcbiAgICAgKiBDb21wb3NpdGUgcnVsZSB1c2VkIGZvciBjYW52YXMgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb246ICdzb3VyY2Utb3ZlcicsXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIG9mIGFuIG9iamVjdC5cbiAgICAgKiB0YWtlcyBjc3MgY29sb3JzIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItMy9cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRDb2xvcjogICAgICAgICAgJycsXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3Rpb24gQmFja2dyb3VuZCBjb2xvciBvZiBhbiBvYmplY3QuIGNvbG9yZWQgbGF5ZXIgYmVoaW5kIHRoZSBvYmplY3Qgd2hlbiBpdCBpcyBhY3RpdmUuXG4gICAgICogZG9lcyBub3QgbWl4IGdvb2Qgd2l0aCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gbWV0aG9kcy5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkJhY2tncm91bmRDb2xvcjogICAgICAgICAgJycsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRlZmluZWQsIGFuIG9iamVjdCBpcyByZW5kZXJlZCB2aWEgc3Ryb2tlIGFuZCB0aGlzIHByb3BlcnR5IHNwZWNpZmllcyBpdHMgY29sb3JcbiAgICAgKiB0YWtlcyBjc3MgY29sb3JzIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItMy9cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZTogICAgICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIGEgc3Ryb2tlIHVzZWQgdG8gcmVuZGVyIHRoaXMgb2JqZWN0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VXaWR0aDogICAgICAgICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzcGVjaWZ5aW5nIGRhc2ggcGF0dGVybiBvZiBhbiBvYmplY3QncyBzdHJva2UgKHN0cm9rZSBtdXN0IGJlIGRlZmluZWQpXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdHJva2VEYXNoQXJyYXk6ICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBMaW5lIG9mZnNldCBvZiBhbiBvYmplY3QncyBzdHJva2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZURhc2hPZmZzZXQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBMaW5lIGVuZGluZ3Mgc3R5bGUgb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlIChvbmUgb2YgXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIilcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZUxpbmVDYXA6ICAgICAgICAgICAgJ2J1dHQnLFxuXG4gICAgLyoqXG4gICAgICogQ29ybmVyIHN0eWxlIG9mIGFuIG9iamVjdCdzIHN0cm9rZSAob25lIG9mIFwiYmV2ZWxcIiwgXCJyb3VuZFwiLCBcIm1pdGVyXCIpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VMaW5lSm9pbjogICAgICAgICAgICdtaXRlcicsXG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIG1pdGVyIGxlbmd0aCAodXNlZCBmb3Igc3Ryb2tlTGluZUpvaW4gPSBcIm1pdGVyXCIpIG9mIGFuIG9iamVjdCdzIHN0cm9rZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlTWl0ZXJMaW1pdDogICAgICAgICA0LFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IG9iamVjdCByZXByZXNlbnRpbmcgc2hhZG93IG9mIHRoaXMgc2hhcGVcbiAgICAgKiBAdHlwZSBmYWJyaWMuU2hhZG93XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzaGFkb3c6ICAgICAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBPcGFjaXR5IG9mIG9iamVjdCdzIGNvbnRyb2xsaW5nIGJvcmRlcnMgd2hlbiBvYmplY3QgaXMgYWN0aXZlIGFuZCBtb3ZpbmdcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJvcmRlck9wYWNpdHlXaGVuTW92aW5nOiAgMC40LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgZmFjdG9yIG9mIG9iamVjdCdzIGNvbnRyb2xsaW5nIGJvcmRlcnNcbiAgICAgKiBiaWdnZXIgbnVtYmVyIHdpbGwgbWFrZSBhIHRoaWNrZXIgYm9yZGVyXG4gICAgICogYm9yZGVyIGlzIDEsIHNvIHRoaXMgaXMgYmFzaWNhbGx5IGEgYm9yZGVyIHRoaWNrbmVzc1xuICAgICAqIHNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byBjaGFuZ2UgdGhlIGJvcmRlciBpdHNlbGYuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBib3JkZXJTY2FsZUZhY3RvcjogICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGFsbG93ZWQgc2NhbGUgdmFsdWUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5TY2FsZUxpbWl0OiAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBhbiBvYmplY3QgY2FuIG5vdCBiZSBzZWxlY3RlZCBmb3IgbW9kaWZpY2F0aW9uICh1c2luZyBlaXRoZXIgcG9pbnQtY2xpY2stYmFzZWQgb3IgZ3JvdXAtYmFzZWQgc2VsZWN0aW9uKS5cbiAgICAgKiBCdXQgZXZlbnRzIHN0aWxsIGZpcmUgb24gaXQuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0YWJsZTogICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgYW4gb2JqZWN0IGNhbiBub3QgYmUgYSB0YXJnZXQgb2YgZXZlbnRzLiBBbGwgZXZlbnRzIHByb3BhZ2F0ZSB0aHJvdWdoIGl0LiBJbnRyb2R1Y2VkIGluIHYxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGV2ZW50ZWQ6ICAgICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIGFuIG9iamVjdCBpcyBub3QgcmVuZGVyZWQgb24gY2FudmFzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdmlzaWJsZTogICAgICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgb2JqZWN0J3MgY29udHJvbHMgYXJlIG5vdCBkaXNwbGF5ZWQgYW5kIGNhbiBub3QgYmUgdXNlZCB0byBtYW5pcHVsYXRlIG9iamVjdFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhhc0NvbnRyb2xzOiAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIG9iamVjdCdzIGNvbnRyb2xsaW5nIGJvcmRlcnMgYXJlIG5vdCByZW5kZXJlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhhc0JvcmRlcnM6ICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgb2JqZWN0cyBhcmUgXCJmb3VuZFwiIG9uIGNhbnZhcyBvbiBwZXItcGl4ZWwgYmFzaXMgcmF0aGVyIHRoYW4gYWNjb3JkaW5nIHRvIGJvdW5kaW5nIGJveFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBlclBpeGVsVGFyZ2V0RmluZDogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGBmYWxzZWAsIGRlZmF1bHQgb2JqZWN0J3MgdmFsdWVzIGFyZSBub3QgaW5jbHVkZWQgaW4gaXRzIHNlcmlhbGl6YXRpb25cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGhvcml6b250YWwgbW92ZW1lbnQgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja01vdmVtZW50WDogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgbW92ZW1lbnQgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja01vdmVtZW50WTogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3Qgcm90YXRpb24gaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1JvdGF0aW9uOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaG9yaXpvbnRhbCBzY2FsaW5nIGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTY2FsaW5nWDogICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHZlcnRpY2FsIHNjYWxpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdZOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaG9yaXpvbnRhbCBza2V3aW5nIGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTa2V3aW5nWDogICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHZlcnRpY2FsIHNrZXdpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NrZXdpbmdZOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgY2Fubm90IGJlIGZsaXBwZWQgYnkgc2NhbGluZyBpbnRvIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTY2FsaW5nRmxpcDogICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGlzIG5vdCBleHBvcnRlZCBpbiBPQkpFQ1QvSlNPTlxuICAgICAqIEBzaW5jZSAxLjYuM1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGV4Y2x1ZGVGcm9tRXhwb3J0OiAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGlzIGNhY2hlZCBvbiBhbiBhZGRpdGlvbmFsIGNhbnZhcy5cbiAgICAgKiBXaGVuIGBmYWxzZWAsIG9iamVjdCBpcyBub3QgY2FjaGVkIHVubGVzcyBuZWNlc3NhcnkgKCBjbGlwUGF0aCApXG4gICAgICogZGVmYXVsdCB0byB0cnVlXG4gICAgICogQHNpbmNlIDEuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBvYmplY3RDYWNoaW5nOiAgICAgICAgICAgIG9iamVjdENhY2hpbmcsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIGNoZWNrZWQgZm9yIGNhY2hlIGludmFsaWRhdGlvbi4gSW4gc29tZSBwYXJ0aWN1bGFyXG4gICAgICogc2l0dWF0aW9uIHlvdSBtYXkgd2FudCB0aGlzIHRvIGJlIGRpc2FibGVkICggc3ByYXkgYnJ1c2gsIHZlcnkgYmlnLCBncm91cHMpXG4gICAgICogb3IgaWYgeW91ciBhcHBsaWNhdGlvbiBkb2VzIG5vdCBhbGxvdyB5b3UgdG8gbW9kaWZ5IHByb3BlcnRpZXMgZm9yIGdyb3VwcyBjaGlsZCB5b3Ugd2FudFxuICAgICAqIHRvIGRpc2FibGUgaXQgZm9yIGdyb3Vwcy5cbiAgICAgKiBkZWZhdWx0IHRvIGZhbHNlXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBzdGF0ZWZ1bGxDYWNoZTogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBjYWNoZSBkb2VzIG5vdCBnZXQgdXBkYXRlZCBkdXJpbmcgc2NhbGluZy4gVGhlIHBpY3R1cmUgd2lsbCBnZXQgYmxvY2t5IGlmIHNjYWxlZFxuICAgICAqIHRvbyBtdWNoIGFuZCB3aWxsIGJlIHJlZHJhd24gd2l0aCBjb3JyZWN0IGRldGFpbHMgYXQgdGhlIGVuZCBvZiBzY2FsaW5nLlxuICAgICAqIHRoaXMgc2V0dGluZyBpcyBwZXJmb3JtYW5jZSBhbmQgYXBwbGljYXRpb24gZGVwZW5kYW50LlxuICAgICAqIGRlZmF1bHQgdG8gdHJ1ZVxuICAgICAqIHNpbmNlIDEuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBub1NjYWxlQ2FjaGU6ICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgZmFsc2VgLCB0aGUgc3Rva2Ugd2lkdGggd2lsbCBzY2FsZSB3aXRoIHRoZSBvYmplY3QuXG4gICAgICogV2hlbiBgdHJ1ZWAsIHRoZSBzdHJva2Ugd2lsbCBhbHdheXMgbWF0Y2ggdGhlIGV4YWN0IHBpeGVsIHNpemUgZW50ZXJlZCBmb3Igc3Ryb2tlIHdpZHRoLlxuICAgICAqIHRoaXMgUHJvcGVydHkgZG9lcyBub3Qgd29yayBvbiBUZXh0IGNsYXNzZXMgb3IgZHJhd2luZyBjYWxsIHRoYXQgdXNlcyBzdHJva2VUZXh0LGZpbGxUZXh0IG1ldGhvZHNcbiAgICAgKiBkZWZhdWx0IHRvIGZhbHNlXG4gICAgICogQHNpbmNlIDIuNi4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgc3Ryb2tlVW5pZm9ybTogICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCBvYmplY3QncyBjYWNoZSB3aWxsIGJlIHJlcmVuZGVyZWQgbmV4dCByZW5kZXIgY2FsbC5cbiAgICAgKiBzaW5jZSAxLjcuMFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgZGlydHk6ICAgICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBrZWVwcyB0aGUgdmFsdWUgb2YgdGhlIGxhc3QgaG92ZXJlZCBjb3JuZXIgZHVyaW5nIG1vdXNlIG1vdmUuXG4gICAgICogMCBpcyBubyBjb3JuZXIsIG9yICdtdCcsICdtbCcsICdtdHInIGV0Yy4uXG4gICAgICogSXQgc2hvdWxkIGJlIHByaXZhdGUsIGJ1dCB0aGVyZSBpcyBubyBoYXJtIGluIHVzaW5nIGl0IGFzXG4gICAgICogYSByZWFkLW9ubHkgcHJvcGVydHkuXG4gICAgICogQHR5cGUgbnVtYmVyfHN0cmluZ3xhbnlcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgX19jb3JuZXI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBmaWxsIG9yIHRoZSBzdHJva2UgaXMgZHJhd24gZmlyc3QgKG9uZSBvZiBcImZpbGxcIiBvciBcInN0cm9rZVwiKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGFpbnRGaXJzdDogICAgICAgICAgICdmaWxsJyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gJ2Rvd24nLCBvYmplY3QgaXMgc2V0IHRvIGFjdGl2ZSBvbiBtb3VzZWRvd24vdG91Y2hzdGFydFxuICAgICAqIFdoZW4gJ3VwJywgb2JqZWN0IGlzIHNldCB0byBhY3RpdmUgb24gbW91c2V1cC90b3VjaGVuZFxuICAgICAqIEV4cGVyaW1lbnRhbC4gTGV0J3Mgc2VlIGlmIHRoaXMgYnJlYWtzIGFueXRoaW5nIGJlZm9yZSBzdXBwb3J0aW5nIG9mZmljaWFsbHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHNpbmNlIDQuNC4wXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHQgJ2Rvd24nXG4gICAgICovXG4gICAgYWN0aXZlT246ICAgICAgICAgICAnZG93bicsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBzdGF0ZVxuICAgICAqIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkIChmYWJyaWMuT2JqZWN0I2hhc1N0YXRlQ2hhbmdlZClcbiAgICAgKiBhcyB3ZWxsIGFzIGZvciBoaXN0b3J5ICh1bmRvL3JlZG8pIHB1cnBvc2VzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdGF0ZVByb3BlcnRpZXM6IChcbiAgICAgICd0b3AgbGVmdCB3aWR0aCBoZWlnaHQgc2NhbGVYIHNjYWxlWSBmbGlwWCBmbGlwWSBvcmlnaW5YIG9yaWdpblkgdHJhbnNmb3JtTWF0cml4ICcgK1xuICAgICAgJ3N0cm9rZSBzdHJva2VXaWR0aCBzdHJva2VEYXNoQXJyYXkgc3Ryb2tlTGluZUNhcCBzdHJva2VEYXNoT2Zmc2V0IHN0cm9rZUxpbmVKb2luIHN0cm9rZU1pdGVyTGltaXQgJyArXG4gICAgICAnYW5nbGUgb3BhY2l0eSBmaWxsIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBzaGFkb3cgdmlzaWJsZSBiYWNrZ3JvdW5kQ29sb3IgJyArXG4gICAgICAnc2tld1ggc2tld1kgZmlsbFJ1bGUgcGFpbnRGaXJzdCBjbGlwUGF0aCBzdHJva2VVbmlmb3JtJ1xuICAgICkuc3BsaXQoJyAnKSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmIGNhY2hlIG5lZWRzIHJlZnJlc2hcbiAgICAgKiBUaG9zZSBwcm9wZXJ0aWVzIGFyZSBjaGVja2VkIGJ5IHN0YXRlZnVsbENhY2hlIE9OICggb3IgbGF6eSBtb2RlIGlmIHdlIHdhbnQgKSBvciBmcm9tIHNpbmdsZVxuICAgICAqIGNhbGxzIHRvIE9iamVjdC5zZXQoa2V5LCB2YWx1ZSkuIElmIHRoZSBrZXkgaXMgaW4gdGhpcyBsaXN0LCB0aGUgb2JqZWN0IGlzIG1hcmtlZCBhcyBkaXJ0eVxuICAgICAqIGFuZCByZWZyZXNoZWQgYXQgdGhlIG5leHQgcmVuZGVyXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjYWNoZVByb3BlcnRpZXM6IChcbiAgICAgICdmaWxsIHN0cm9rZSBzdHJva2VXaWR0aCBzdHJva2VEYXNoQXJyYXkgd2lkdGggaGVpZ2h0IHBhaW50Rmlyc3Qgc3Ryb2tlVW5pZm9ybScgK1xuICAgICAgJyBzdHJva2VMaW5lQ2FwIHN0cm9rZURhc2hPZmZzZXQgc3Ryb2tlTGluZUpvaW4gc3Ryb2tlTWl0ZXJMaW1pdCBiYWNrZ3JvdW5kQ29sb3IgY2xpcFBhdGgnXG4gICAgKS5zcGxpdCgnICcpLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIGZvciBhbmltYXRpbmcgY29sb3JzLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY29sb3JQcm9wZXJ0aWVzOiAoXG4gICAgICAnZmlsbCBzdHJva2UgYmFja2dyb3VuZENvbG9yJ1xuICAgICkuc3BsaXQoJyAnKSxcblxuICAgIC8qKlxuICAgICAqIGEgZmFicmljT2JqZWN0IHRoYXQsIHdpdGhvdXQgc3Ryb2tlIGRlZmluZSBhIGNsaXBwaW5nIGFyZWEgd2l0aCB0aGVpciBzaGFwZS4gZmlsbGVkIGluIGJsYWNrXG4gICAgICogdGhlIGNsaXBQYXRoIG9iamVjdCBnZXRzIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGhhcyByZW5kZXJlZCwgYW5kIHRoZSBjb250ZXh0IGlzIHBsYWNlZCBpbiB0aGUgY2VudGVyXG4gICAgICogb2YgdGhlIG9iamVjdCBjYWNoZUNhbnZhcy5cbiAgICAgKiBJZiB5b3Ugd2FudCAwLDAgb2YgYSBjbGlwUGF0aCB0byBhbGlnbiB3aXRoIGFuIG9iamVjdCBjZW50ZXIsIHVzZSBjbGlwUGF0aC5vcmlnaW5YL1kgdG8gJ2NlbnRlcidcbiAgICAgKiBAdHlwZSBmYWJyaWMuT2JqZWN0XG4gICAgICovXG4gICAgY2xpcFBhdGg6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIE1lYW5pbmdmdWwgT05MWSB3aGVuIHRoZSBvYmplY3QgaXMgdXNlZCBhcyBjbGlwUGF0aC5cbiAgICAgKiBpZiB0cnVlLCB0aGUgY2xpcFBhdGggd2lsbCBtYWtlIHRoZSBvYmplY3QgY2xpcCB0byB0aGUgb3V0c2lkZSBvZiB0aGUgY2xpcFBhdGhcbiAgICAgKiBzaW5jZSAyLjQuMFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGludmVydGVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIE1lYW5pbmdmdWwgT05MWSB3aGVuIHRoZSBvYmplY3QgaXMgdXNlZCBhcyBjbGlwUGF0aC5cbiAgICAgKiBpZiB0cnVlLCB0aGUgY2xpcFBhdGggd2lsbCBoYXZlIGl0cyB0b3AgYW5kIGxlZnQgcmVsYXRpdmUgdG8gY2FudmFzLCBhbmQgd2lsbFxuICAgICAqIG5vdCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBvYmplY3QgdHJhbnNmb3JtLiBUaGlzIHdpbGwgbWFrZSB0aGUgY2xpcFBhdGggcmVsYXRpdmVcbiAgICAgKiB0byB0aGUgY2FudmFzLCBidXQgY2xpcHBpbmcganVzdCBhIHBhcnRpY3VsYXIgb2JqZWN0LlxuICAgICAqIFdBUk5JTkcgdGhpcyBpcyBiZXRhLCB0aGlzIGZlYXR1cmUgbWF5IGNoYW5nZSBvciBiZSByZW5hbWVkLlxuICAgICAqIHNpbmNlIDIuNC4wXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgYWJzb2x1dGVQb3NpdGlvbmVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdGhlIGNhbnZhcyB1c2VkIHRvIGtlZXAgdGhlIGNhY2hlZCBjb3B5IG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVDYWNoZUNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jYWNoZVByb3BlcnRpZXMgPSB7fTtcbiAgICAgIHRoaXMuX2NhY2hlQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgdGhpcy5fY2FjaGVDb250ZXh0ID0gdGhpcy5fY2FjaGVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUNhY2hlQ2FudmFzKCk7XG4gICAgICAvLyBpZiBjYW52YXMgZ2V0cyBjcmVhdGVkLCBpcyBlbXB0eSwgc28gZGlydHkuXG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGltaXQgdGhlIGNhY2hlIGRpbWVuc2lvbnMgc28gdGhhdCBYICogWSBkbyBub3QgY3Jvc3MgZmFicmljLnBlcmZMaW1pdFNpemVUb3RhbFxuICAgICAqIGFuZCBlYWNoIHNpZGUgZG8gbm90IGNyb3NzIGZhYnJpYy5jYWNoZVNpZGVMaW1pdFxuICAgICAqIHRob3NlIG51bWJlcnMgYXJlIGNvbmZpZ3VyYWJsZSBzbyB0aGF0IHlvdSBjYW4gZ2V0IGFzIG11Y2ggZGV0YWlsIGFzIHlvdSB3YW50XG4gICAgICogbWFraW5nIGJhcmdhaW4gd2l0aCBwZXJmb3JtYW5jZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltcy53aWR0aCB3aWR0aCBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltcy5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zLnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXMuem9vbVkgem9vbVkgem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uaGVpZ2h0IGhlaWdodCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqL1xuICAgIF9saW1pdENhY2hlU2l6ZTogZnVuY3Rpb24oZGltcykge1xuICAgICAgdmFyIHBlcmZMaW1pdFNpemVUb3RhbCA9IGZhYnJpYy5wZXJmTGltaXRTaXplVG90YWwsXG4gICAgICAgICAgd2lkdGggPSBkaW1zLndpZHRoLCBoZWlnaHQgPSBkaW1zLmhlaWdodCxcbiAgICAgICAgICBtYXggPSBmYWJyaWMubWF4Q2FjaGVTaWRlTGltaXQsIG1pbiA9IGZhYnJpYy5taW5DYWNoZVNpZGVMaW1pdDtcbiAgICAgIGlmICh3aWR0aCA8PSBtYXggJiYgaGVpZ2h0IDw9IG1heCAmJiB3aWR0aCAqIGhlaWdodCA8PSBwZXJmTGltaXRTaXplVG90YWwpIHtcbiAgICAgICAgaWYgKHdpZHRoIDwgbWluKSB7XG4gICAgICAgICAgZGltcy53aWR0aCA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0IDwgbWluKSB7XG4gICAgICAgICAgZGltcy5oZWlnaHQgPSBtaW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpbXM7XG4gICAgICB9XG4gICAgICB2YXIgYXIgPSB3aWR0aCAvIGhlaWdodCwgbGltaXRlZERpbXMgPSBmYWJyaWMudXRpbC5saW1pdERpbXNCeUFyZWEoYXIsIHBlcmZMaW1pdFNpemVUb3RhbCksXG4gICAgICAgICAgY2FwVmFsdWUgPSBmYWJyaWMudXRpbC5jYXBWYWx1ZSxcbiAgICAgICAgICB4ID0gY2FwVmFsdWUobWluLCBsaW1pdGVkRGltcy54LCBtYXgpLFxuICAgICAgICAgIHkgPSBjYXBWYWx1ZShtaW4sIGxpbWl0ZWREaW1zLnksIG1heCk7XG4gICAgICBpZiAod2lkdGggPiB4KSB7XG4gICAgICAgIGRpbXMuem9vbVggLz0gd2lkdGggLyB4O1xuICAgICAgICBkaW1zLndpZHRoID0geDtcbiAgICAgICAgZGltcy5jYXBwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodCA+IHkpIHtcbiAgICAgICAgZGltcy56b29tWSAvPSBoZWlnaHQgLyB5O1xuICAgICAgICBkaW1zLmhlaWdodCA9IHk7XG4gICAgICAgIGRpbXMuY2FwcGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaW1zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRpbWVuc2lvbiBhbmQgdGhlIHpvb20gbGV2ZWwgbmVlZGVkIHRvIGNyZWF0ZSBhIGNhY2hlIGNhbnZhc1xuICAgICAqIGJpZyBlbm91Z2ggdG8gaG9zdCB0aGUgb2JqZWN0IHRvIGJlIGNhY2hlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0ueCB3aWR0aCBvZiBvYmplY3QgdG8gYmUgY2FjaGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fS55IGhlaWdodCBvZiBvYmplY3QgdG8gYmUgY2FjaGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fS53aWR0aCB3aWR0aCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LmhlaWdodCBoZWlnaHQgb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWCB6b29tWCB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVkgem9vbVkgem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKi9cbiAgICBfZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmplY3RTY2FsZSA9IHRoaXMuZ2V0VG90YWxPYmplY3RTY2FsaW5nKCksXG4gICAgICAgICAgLy8gY2FjdWxhdGUgZGltZW5zaW9ucyB3aXRob3V0IHNrZXdpbmdcbiAgICAgICAgICBkaW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoMCwgMCksXG4gICAgICAgICAgbmVlZGVkWCA9IGRpbS54ICogb2JqZWN0U2NhbGUuc2NhbGVYIC8gdGhpcy5zY2FsZVgsXG4gICAgICAgICAgbmVlZGVkWSA9IGRpbS55ICogb2JqZWN0U2NhbGUuc2NhbGVZIC8gdGhpcy5zY2FsZVk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBmb3Igc3VyZSB0aGlzIEFMSUFTSU5HX0xJTUlUIGlzIHNsaWdodGx5IGNyZWF0aW5nIHByb2JsZW1cbiAgICAgICAgLy8gaW4gc2l0dWF0aW9uIGluIHdoaWNoIHRoZSBjYWNoZSBjYW52YXMgZ2V0cyBhbiB1cHBlciBsaW1pdFxuICAgICAgICAvLyBhbHNvIG9iamVjdFNjYWxlIGNvbnRhaW5zIGFscmVhZHkgc2NhbGVYIGFuZCBzY2FsZVlcbiAgICAgICAgd2lkdGg6IG5lZWRlZFggKyBBTElBU0lOR19MSU1JVCxcbiAgICAgICAgaGVpZ2h0OiBuZWVkZWRZICsgQUxJQVNJTkdfTElNSVQsXG4gICAgICAgIHpvb21YOiBvYmplY3RTY2FsZS5zY2FsZVgsXG4gICAgICAgIHpvb21ZOiBvYmplY3RTY2FsZS5zY2FsZVksXG4gICAgICAgIHg6IG5lZWRlZFgsXG4gICAgICAgIHk6IG5lZWRlZFlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBjYW52YXMgZm9yIGNhY2hlXG4gICAgICogcmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIGNhbnZhcyBuZWVkZWQgcmVzaXplLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2FudmFzIGhhcyBiZWVuIHJlc2l6ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlQ2FjaGVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRhcmdldENhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgaWYgKHRoaXMubm9TY2FsZUNhY2hlICYmIHRhcmdldENhbnZhcyAmJiB0YXJnZXRDYW52YXMuX2N1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRhcmdldENhbnZhcy5fY3VycmVudFRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgICAgICBhY3Rpb24gPSB0YXJnZXRDYW52YXMuX2N1cnJlbnRUcmFuc2Zvcm0uYWN0aW9uO1xuICAgICAgICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIGFjdGlvbi5zbGljZSAmJiBhY3Rpb24uc2xpY2UoMCwgNSkgPT09ICdzY2FsZScpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYWNoZUNhbnZhcyxcbiAgICAgICAgICBkaW1zID0gdGhpcy5fbGltaXRDYWNoZVNpemUodGhpcy5fZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zKCkpLFxuICAgICAgICAgIG1pbkNhY2hlU2l6ZSA9IGZhYnJpYy5taW5DYWNoZVNpZGVMaW1pdCxcbiAgICAgICAgICB3aWR0aCA9IGRpbXMud2lkdGgsIGhlaWdodCA9IGRpbXMuaGVpZ2h0LCBkcmF3aW5nV2lkdGgsIGRyYXdpbmdIZWlnaHQsXG4gICAgICAgICAgem9vbVggPSBkaW1zLnpvb21YLCB6b29tWSA9IGRpbXMuem9vbVksXG4gICAgICAgICAgZGltZW5zaW9uc0NoYW5nZWQgPSB3aWR0aCAhPT0gdGhpcy5jYWNoZVdpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5jYWNoZUhlaWdodCxcbiAgICAgICAgICB6b29tQ2hhbmdlZCA9IHRoaXMuem9vbVggIT09IHpvb21YIHx8IHRoaXMuem9vbVkgIT09IHpvb21ZLFxuICAgICAgICAgIHNob3VsZFJlZHJhdyA9IGRpbWVuc2lvbnNDaGFuZ2VkIHx8IHpvb21DaGFuZ2VkLFxuICAgICAgICAgIGFkZGl0aW9uYWxXaWR0aCA9IDAsIGFkZGl0aW9uYWxIZWlnaHQgPSAwLCBzaG91bGRSZXNpemVDYW52YXMgPSBmYWxzZTtcbiAgICAgIGlmIChkaW1lbnNpb25zQ2hhbmdlZCkge1xuICAgICAgICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLl9jYWNoZUNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIGNhbnZhc0hlaWdodCA9IHRoaXMuX2NhY2hlQ2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgIHNpemVHcm93aW5nID0gd2lkdGggPiBjYW52YXNXaWR0aCB8fCBoZWlnaHQgPiBjYW52YXNIZWlnaHQsXG4gICAgICAgICAgICBzaXplU2hyaW5raW5nID0gKHdpZHRoIDwgY2FudmFzV2lkdGggKiAwLjkgfHwgaGVpZ2h0IDwgY2FudmFzSGVpZ2h0ICogMC45KSAmJlxuICAgICAgICAgICAgICBjYW52YXNXaWR0aCA+IG1pbkNhY2hlU2l6ZSAmJiBjYW52YXNIZWlnaHQgPiBtaW5DYWNoZVNpemU7XG4gICAgICAgIHNob3VsZFJlc2l6ZUNhbnZhcyA9IHNpemVHcm93aW5nIHx8IHNpemVTaHJpbmtpbmc7XG4gICAgICAgIGlmIChzaXplR3Jvd2luZyAmJiAhZGltcy5jYXBwZWQgJiYgKHdpZHRoID4gbWluQ2FjaGVTaXplIHx8IGhlaWdodCA+IG1pbkNhY2hlU2l6ZSkpIHtcbiAgICAgICAgICBhZGRpdGlvbmFsV2lkdGggPSB3aWR0aCAqIDAuMTtcbiAgICAgICAgICBhZGRpdGlvbmFsSGVpZ2h0ID0gaGVpZ2h0ICogMC4xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGZhYnJpYy5UZXh0ICYmIHRoaXMucGF0aCkge1xuICAgICAgICBzaG91bGRSZWRyYXcgPSB0cnVlO1xuICAgICAgICBzaG91bGRSZXNpemVDYW52YXMgPSB0cnVlO1xuICAgICAgICBhZGRpdGlvbmFsV2lkdGggKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoMCkgKiB0aGlzLnpvb21YO1xuICAgICAgICBhZGRpdGlvbmFsSGVpZ2h0ICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKDApICogdGhpcy56b29tWTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRSZWRyYXcpIHtcbiAgICAgICAgaWYgKHNob3VsZFJlc2l6ZUNhbnZhcykge1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IE1hdGguY2VpbCh3aWR0aCArIGFkZGl0aW9uYWxXaWR0aCk7XG4gICAgICAgICAgY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKyBhZGRpdGlvbmFsSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgIHRoaXMuX2NhY2hlQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBkcmF3aW5nV2lkdGggPSBkaW1zLnggLyAyO1xuICAgICAgICBkcmF3aW5nSGVpZ2h0ID0gZGltcy55IC8gMjtcbiAgICAgICAgdGhpcy5jYWNoZVRyYW5zbGF0aW9uWCA9IE1hdGgucm91bmQoY2FudmFzLndpZHRoIC8gMiAtIGRyYXdpbmdXaWR0aCkgKyBkcmF3aW5nV2lkdGg7XG4gICAgICAgIHRoaXMuY2FjaGVUcmFuc2xhdGlvblkgPSBNYXRoLnJvdW5kKGNhbnZhcy5oZWlnaHQgLyAyIC0gZHJhd2luZ0hlaWdodCkgKyBkcmF3aW5nSGVpZ2h0O1xuICAgICAgICB0aGlzLmNhY2hlV2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5jYWNoZUhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LnRyYW5zbGF0ZSh0aGlzLmNhY2hlVHJhbnNsYXRpb25YLCB0aGlzLmNhY2hlVHJhbnNsYXRpb25ZKTtcbiAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LnNjYWxlKHpvb21YLCB6b29tWSk7XG4gICAgICAgIHRoaXMuem9vbVggPSB6b29tWDtcbiAgICAgICAgdGhpcy56b29tWSA9IHpvb21ZO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBvYmplY3QncyBwcm9wZXJ0aWVzIGZyb20gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdEdyYWRpZW50KG9wdGlvbnMuZmlsbCwgJ2ZpbGwnKTtcbiAgICAgIHRoaXMuX2luaXRHcmFkaWVudChvcHRpb25zLnN0cm9rZSwgJ3N0cm9rZScpO1xuICAgICAgdGhpcy5faW5pdFBhdHRlcm4ob3B0aW9ucy5maWxsLCAnZmlsbCcpO1xuICAgICAgdGhpcy5faW5pdFBhdHRlcm4ob3B0aW9ucy5zdHJva2UsICdzdHJva2UnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBjb250ZXh0IHdoZW4gcmVuZGVyaW5nIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dFxuICAgICAqL1xuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgbmVlZEZ1bGxUcmFuc2Zvcm0gPSAodGhpcy5ncm91cCAmJiAhdGhpcy5ncm91cC5fdHJhbnNmb3JtRG9uZSkgfHxcbiAgICAgICAgICh0aGlzLmdyb3VwICYmIHRoaXMuY2FudmFzICYmIGN0eCA9PT0gdGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgICB2YXIgbSA9IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCghbmVlZEZ1bGxUcmFuc2Zvcm0pO1xuICAgICAgY3R4LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMsXG5cbiAgICAgICAgICBvYmplY3QgPSB7XG4gICAgICAgICAgICB0eXBlOiAgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSxcbiAgICAgICAgICAgIHZlcnNpb246ICAgICAgICAgICAgICAgICAgZmFicmljLnZlcnNpb24sXG4gICAgICAgICAgICBvcmlnaW5YOiAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luWCxcbiAgICAgICAgICAgIG9yaWdpblk6ICAgICAgICAgICAgICAgICAgdGhpcy5vcmlnaW5ZLFxuICAgICAgICAgICAgbGVmdDogICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMubGVmdCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICB0b3A6ICAgICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy50b3AsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgd2lkdGg6ICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMud2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgaGVpZ2h0OiAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuaGVpZ2h0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGZpbGw6ICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZmlsbCAmJiB0aGlzLmZpbGwudG9PYmplY3QpID8gdGhpcy5maWxsLnRvT2JqZWN0KCkgOiB0aGlzLmZpbGwsXG4gICAgICAgICAgICBzdHJva2U6ICAgICAgICAgICAgICAgICAgICh0aGlzLnN0cm9rZSAmJiB0aGlzLnN0cm9rZS50b09iamVjdCkgPyB0aGlzLnN0cm9rZS50b09iamVjdCgpIDogdGhpcy5zdHJva2UsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5zdHJva2VXaWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBzdHJva2VEYXNoQXJyYXk6ICAgICAgICAgIHRoaXMuc3Ryb2tlRGFzaEFycmF5ID8gdGhpcy5zdHJva2VEYXNoQXJyYXkuY29uY2F0KCkgOiB0aGlzLnN0cm9rZURhc2hBcnJheSxcbiAgICAgICAgICAgIHN0cm9rZUxpbmVDYXA6ICAgICAgICAgICAgdGhpcy5zdHJva2VMaW5lQ2FwLFxuICAgICAgICAgICAgc3Ryb2tlRGFzaE9mZnNldDogICAgICAgICB0aGlzLnN0cm9rZURhc2hPZmZzZXQsXG4gICAgICAgICAgICBzdHJva2VMaW5lSm9pbjogICAgICAgICAgIHRoaXMuc3Ryb2tlTGluZUpvaW4sXG4gICAgICAgICAgICBzdHJva2VVbmlmb3JtOiAgICAgICAgICAgIHRoaXMuc3Ryb2tlVW5pZm9ybSxcbiAgICAgICAgICAgIHN0cm9rZU1pdGVyTGltaXQ6ICAgICAgICAgdG9GaXhlZCh0aGlzLnN0cm9rZU1pdGVyTGltaXQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc2NhbGVYOiAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc2NhbGVYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHNjYWxlWTogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNjYWxlWSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBhbmdsZTogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5hbmdsZSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBmbGlwWDogICAgICAgICAgICAgICAgICAgIHRoaXMuZmxpcFgsXG4gICAgICAgICAgICBmbGlwWTogICAgICAgICAgICAgICAgICAgIHRoaXMuZmxpcFksXG4gICAgICAgICAgICBvcGFjaXR5OiAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5vcGFjaXR5LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHNoYWRvdzogICAgICAgICAgICAgICAgICAgKHRoaXMuc2hhZG93ICYmIHRoaXMuc2hhZG93LnRvT2JqZWN0KSA/IHRoaXMuc2hhZG93LnRvT2JqZWN0KCkgOiB0aGlzLnNoYWRvdyxcbiAgICAgICAgICAgIHZpc2libGU6ICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAgICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGZpbGxSdWxlOiAgICAgICAgICAgICAgICAgdGhpcy5maWxsUnVsZSxcbiAgICAgICAgICAgIHBhaW50Rmlyc3Q6ICAgICAgICAgICAgICAgdGhpcy5wYWludEZpcnN0LFxuICAgICAgICAgICAgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uOiB0aGlzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbixcbiAgICAgICAgICAgIHNrZXdYOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNrZXdYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHNrZXdZOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNrZXdZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5jbGlwUGF0aCAmJiAhdGhpcy5jbGlwUGF0aC5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICBvYmplY3QuY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgICBvYmplY3QuY2xpcFBhdGguaW52ZXJ0ZWQgPSB0aGlzLmNsaXBQYXRoLmludmVydGVkO1xuICAgICAgICBvYmplY3QuY2xpcFBhdGguYWJzb2x1dGVQb3NpdGlvbmVkID0gdGhpcy5jbGlwUGF0aC5hYnNvbHV0ZVBvc2l0aW9uZWQ7XG4gICAgICB9XG5cbiAgICAgIGZhYnJpYy51dGlsLnBvcHVsYXRlV2l0aFByb3BlcnRpZXModGhpcywgb2JqZWN0LCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIGlmICghdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICBvYmplY3QgPSB0aGlzLl9yZW1vdmVEZWZhdWx0VmFsdWVzKG9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgKGRhdGFsZXNzKSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0RhdGFsZXNzT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICAvLyB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHN1YmNsYXNzZXNcbiAgICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKi9cbiAgICBfcmVtb3ZlRGVmYXVsdFZhbHVlczogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcHJvdG90eXBlID0gZmFicmljLnV0aWwuZ2V0S2xhc3Mob2JqZWN0LnR5cGUpLnByb3RvdHlwZSxcbiAgICAgICAgICBzdGF0ZVByb3BlcnRpZXMgPSBwcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzO1xuICAgICAgc3RhdGVQcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICBpZiAocHJvcCA9PT0gJ2xlZnQnIHx8IHByb3AgPT09ICd0b3AnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3RbcHJvcF0gPT09IHByb3RvdHlwZVtwcm9wXSkge1xuICAgICAgICAgIGRlbGV0ZSBvYmplY3RbcHJvcF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmFzaWNhbGx5IGEgY2hlY2sgZm9yIFtdID09PSBbXVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3RbcHJvcF0pICYmIEFycmF5LmlzQXJyYXkocHJvdG90eXBlW3Byb3BdKVxuICAgICAgICAgICYmIG9iamVjdFtwcm9wXS5sZW5ndGggPT09IDAgJiYgcHJvdG90eXBlW3Byb3BdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmplY3RbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuJyArIGNhcGl0YWxpemUodGhpcy50eXBlKSArICc+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBvYmplY3Qgc2NhbGUgZmFjdG9yIGNvdW50aW5nIGFsc28gdGhlIGdyb3VwIHNjYWxpbmdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB3aXRoIHNjYWxlWCBhbmQgc2NhbGVZIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRPYmplY3RTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGlmIHRoZSBvYmplY3QgaXMgYSB0b3AgbGV2ZWwgb25lLCBvbiB0aGUgY2FudmFzLCB3ZSBnbyBmb3Igc2ltcGxlIGFyaXRtZXRpY1xuICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBjb21wbGV4IG1ldGhvZCB3aXRoIGFuZ2xlcyB3aWxsIHJldHVybiBhcHByb3hpbWF0aW9ucyBhbmQgZGVjaW1hbHNcbiAgICAgIC8vIGFuZCB3aWxsIGxpa2VseSBraWxsIHRoZSBjYWNoZSB3aGVuIG5vdCBuZWVkZWRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWJyaWNqcy9mYWJyaWMuanMvaXNzdWVzLzcxNTdcbiAgICAgIGlmICghdGhpcy5ncm91cCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNjYWxlWDogdGhpcy5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZOiB0aGlzLnNjYWxlWSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlIGFyZSBpbnNpZGUgYSBncm91cCB0b3RhbCB6b29tIGNhbGN1bGF0aW9uIGlzIGNvbXBsZXgsIHdlIGRlZmVyIHRvIGdlbmVyaWMgbWF0cmljZXNcbiAgICAgIHZhciBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UodGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCkpO1xuICAgICAgcmV0dXJuIHsgc2NhbGVYOiBNYXRoLmFicyhvcHRpb25zLnNjYWxlWCksIHNjYWxlWTogTWF0aC5hYnMob3B0aW9ucy5zY2FsZVkpIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgb2JqZWN0IHNjYWxlIGZhY3RvciBjb3VudGluZyBhbHNvIHRoZSBncm91cCBzY2FsaW5nLCB6b29tIGFuZCByZXRpbmFcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB3aXRoIHNjYWxlWCBhbmQgc2NhbGVZIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRUb3RhbE9iamVjdFNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRPYmplY3RTY2FsaW5nKCksIHNjYWxlWCA9IHNjYWxlLnNjYWxlWCwgc2NhbGVZID0gc2NhbGUuc2NhbGVZO1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHZhciB6b29tID0gdGhpcy5jYW52YXMuZ2V0Wm9vbSgpO1xuICAgICAgICB2YXIgcmV0aW5hID0gdGhpcy5jYW52YXMuZ2V0UmV0aW5hU2NhbGluZygpO1xuICAgICAgICBzY2FsZVggKj0gem9vbSAqIHJldGluYTtcbiAgICAgICAgc2NhbGVZICo9IHpvb20gKiByZXRpbmE7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzY2FsZVg6IHNjYWxlWCwgc2NhbGVZOiBzY2FsZVkgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBvYmplY3Qgb3BhY2l0eSBjb3VudGluZyBhbHNvIHRoZSBncm91cCBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRPYmplY3RPcGFjaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgICAgb3BhY2l0eSAqPSB0aGlzLmdyb3VwLmdldE9iamVjdE9wYWNpdHkoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcGFjaXR5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzaG91bGRDb25zdHJhaW5WYWx1ZSA9IChrZXkgPT09ICdzY2FsZVgnIHx8IGtleSA9PT0gJ3NjYWxlWScpLFxuICAgICAgICAgIGlzQ2hhbmdlZCA9IHRoaXNba2V5XSAhPT0gdmFsdWUsIGdyb3VwTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgaWYgKHNob3VsZENvbnN0cmFpblZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5fY29uc3RyYWluU2NhbGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NjYWxlWCcgJiYgdmFsdWUgPCAwKSB7XG4gICAgICAgIHRoaXMuZmxpcFggPSAhdGhpcy5mbGlwWDtcbiAgICAgICAgdmFsdWUgKj0gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXkgPT09ICdzY2FsZVknICYmIHZhbHVlIDwgMCkge1xuICAgICAgICB0aGlzLmZsaXBZID0gIXRoaXMuZmxpcFk7XG4gICAgICAgIHZhbHVlICo9IC0xO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc2hhZG93JyAmJiB2YWx1ZSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgZmFicmljLlNoYWRvdykpIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgZmFicmljLlNoYWRvdyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChrZXkgPT09ICdkaXJ0eScgJiYgdGhpcy5ncm91cCkge1xuICAgICAgICB0aGlzLmdyb3VwLnNldCgnZGlydHknLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoaXNDaGFuZ2VkKSB7XG4gICAgICAgIGdyb3VwTmVlZHNVcGRhdGUgPSB0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAuaXNPbkFDYWNoZSgpO1xuICAgICAgICBpZiAodGhpcy5jYWNoZVByb3BlcnRpZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICBncm91cE5lZWRzVXBkYXRlICYmIHRoaXMuZ3JvdXAuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGdyb3VwTmVlZHNVcGRhdGUgJiYgdGhpcy5zdGF0ZVByb3BlcnRpZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICB0aGlzLmdyb3VwLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IHRoZSBwYXJlbnQgZ3JvdXAgb2YgYW4gb2JqZWN0IGV2ZXJ5XG4gICAgICogdGltZSBhIG5vbi1kZWxlZ2F0ZWQgcHJvcGVydHkgY2hhbmdlcyBvbiB0aGUgZ3JvdXAuIEl0IGlzIHBhc3NlZCB0aGUga2V5XG4gICAgICogYW5kIHZhbHVlIGFzIHBhcmFtZXRlcnMuIE5vdCBhZGRpbmcgaW4gdGhpcyBmdW5jdGlvbidzIHNpZ25hdHVyZSB0byBhdm9pZFxuICAgICAqIFRyYXZpcyBidWlsZCBlcnJvciBhYm91dCB1bnVzZWQgdmFyaWFibGVzLlxuICAgICAqL1xuICAgIHNldE9uR3JvdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaW1wbGVtZW50ZWQgYnkgc3ViLWNsYXNzZXMsIGFzIG5lZWRlZC5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHZpZXdwb3J0VHJhbnNmb3JtIGZyb20gT2JqZWN0J3MgY2FudmFzIGlmIHBvc3NpYmxlXG4gICAgICogQG1ldGhvZCBnZXRWaWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGdldFZpZXdwb3J0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFicmljLmlNYXRyaXguY29uY2F0KCk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQHByaXZhdGVcbiAgICAgKiByZXR1cm4gaWYgdGhlIG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGluIHJlbmRlcmluZ1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNOb3RWaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPT09IDAgfHxcbiAgICAgICAgKCF0aGlzLndpZHRoICYmICF0aGlzLmhlaWdodCAmJiB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSB8fFxuICAgICAgICAhdGhpcy52aXNpYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGFuIG9iamVjdCBvbiBhIHNwZWNpZmllZCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAvLyBkbyBub3QgcmVuZGVyIGlmIHdpZHRoL2hlaWdodCBhcmUgemVyb3Mgb3Igb2JqZWN0IGlzIG5vdCB2aXNpYmxlXG4gICAgICBpZiAodGhpcy5pc05vdFZpc2libGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuc2tpcE9mZnNjcmVlbiAmJiAhdGhpcy5ncm91cCAmJiAhdGhpcy5pc09uU2NyZWVuKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldHVwQ29tcG9zaXRlT3BlcmF0aW9uKGN0eCk7XG4gICAgICB0aGlzLmRyYXdTZWxlY3Rpb25CYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB0aGlzLnRyYW5zZm9ybShjdHgpO1xuICAgICAgdGhpcy5fc2V0T3BhY2l0eShjdHgpO1xuICAgICAgdGhpcy5fc2V0U2hhZG93KGN0eCwgdGhpcyk7XG4gICAgICBpZiAodGhpcy5zaG91bGRDYWNoZSgpKSB7XG4gICAgICAgIHRoaXMucmVuZGVyQ2FjaGUoKTtcbiAgICAgICAgdGhpcy5kcmF3Q2FjaGVPbkNhbnZhcyhjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUNhY2hlQ2FudmFzKCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmF3T2JqZWN0KGN0eCk7XG4gICAgICAgIGlmICh0aGlzLm9iamVjdENhY2hpbmcgJiYgdGhpcy5zdGF0ZWZ1bGxDYWNoZSkge1xuICAgICAgICAgIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdjYWNoZVByb3BlcnRpZXMnIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICByZW5kZXJDYWNoZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBpZiAoIXRoaXMuX2NhY2hlQ2FudmFzIHx8ICF0aGlzLl9jYWNoZUNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlQ2FjaGVDYW52YXMoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzQ2FjaGVEaXJ0eSgpKSB7XG4gICAgICAgIHRoaXMuc3RhdGVmdWxsQ2FjaGUgJiYgdGhpcy5zYXZlU3RhdGUoeyBwcm9wZXJ0eVNldDogJ2NhY2hlUHJvcGVydGllcycgfSk7XG4gICAgICAgIHRoaXMuZHJhd09iamVjdCh0aGlzLl9jYWNoZUNvbnRleHQsIG9wdGlvbnMuZm9yQ2xpcHBpbmcpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBjYWNoZUNhbnZhcyBhbmQgaXRzIGRpbWVuc2lvbnMgZnJvbSB0aGUgb2JqZWN0c1xuICAgICAqL1xuICAgIF9yZW1vdmVDYWNoZUNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jYWNoZUNhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLl9jYWNoZUNvbnRleHQgPSBudWxsO1xuICAgICAgdGhpcy5jYWNoZVdpZHRoID0gMDtcbiAgICAgIHRoaXMuY2FjaGVIZWlnaHQgPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IHdpbGwgZHJhdyBhIHN0cm9rZVxuICAgICAqIERvZXMgbm90IGNvbnNpZGVyIHRleHQgc3R5bGVzLiBUaGlzIGlzIGp1c3QgYSBzaG9ydGN1dCB1c2VkIGF0IHJlbmRlcmluZyB0aW1lXG4gICAgICogV2Ugd2FudCBpdCB0byBiZSBhbiBhcHByb3hpbWF0aW9uIGFuZCBiZSBmYXN0LlxuICAgICAqIHdyb3RlIHRvIGF2b2lkIGV4dHJhIGNhY2hpbmcsIGl0IGhhcyB0byByZXR1cm4gdHJ1ZSB3aGVuIHN0cm9rZSBoYXBwZW5zLFxuICAgICAqIGNhbiBndWVzcyB3aGVuIGl0IHdpbGwgbm90IGhhcHBlbiBhdCAxMDAlIGNoYW5jZSwgZG9lcyBub3QgbWF0dGVyIGlmIGl0IG1pc3Nlc1xuICAgICAqIHNvbWUgdXNlIGNhc2Ugd2hlcmUgdGhlIHN0cm9rZSBpcyBpbnZpc2libGUuXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICAqL1xuICAgIGhhc1N0cm9rZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2UgIT09ICd0cmFuc3BhcmVudCcgJiYgdGhpcy5zdHJva2VXaWR0aCAhPT0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCB3aWxsIGRyYXcgYSBmaWxsXG4gICAgICogRG9lcyBub3QgY29uc2lkZXIgdGV4dCBzdHlsZXMuIFRoaXMgaXMganVzdCBhIHNob3J0Y3V0IHVzZWQgYXQgcmVuZGVyaW5nIHRpbWVcbiAgICAgKiBXZSB3YW50IGl0IHRvIGJlIGFuIGFwcHJveGltYXRpb24gYW5kIGJlIGZhc3QuXG4gICAgICogd3JvdGUgdG8gYXZvaWQgZXh0cmEgY2FjaGluZywgaXQgaGFzIHRvIHJldHVybiB0cnVlIHdoZW4gZmlsbCBoYXBwZW5zLFxuICAgICAqIGNhbiBndWVzcyB3aGVuIGl0IHdpbGwgbm90IGhhcHBlbiBhdCAxMDAlIGNoYW5jZSwgZG9lcyBub3QgbWF0dGVyIGlmIGl0IG1pc3Nlc1xuICAgICAqIHNvbWUgdXNlIGNhc2Ugd2hlcmUgdGhlIGZpbGwgaXMgaW52aXNpYmxlLlxuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKi9cbiAgICBoYXNGaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbGwgJiYgdGhpcy5maWxsICE9PSAndHJhbnNwYXJlbnQnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIGZvcmNlIHRoZSBvYmplY3QgdG8gaGF2ZSBpdHMgb3duIGNhY2hlLCBldmVuIGlmIGl0IGlzIGluc2lkZSBhIGdyb3VwXG4gICAgICogaXQgbWF5IGJlIG5lZWRlZCB3aGVuIHlvdXIgb2JqZWN0IGJlaGF2ZSBpbiBhIHBhcnRpY3VsYXIgd2F5IG9uIHRoZSBjYWNoZSBhbmQgYWx3YXlzIG5lZWRzXG4gICAgICogaXRzIG93biBpc29sYXRlZCBjYW52YXMgdG8gcmVuZGVyIGNvcnJlY3RseS5cbiAgICAgKiBDcmVhdGVkIHRvIGJlIG92ZXJyaWRkZW5cbiAgICAgKiBzaW5jZSAxLjcuMTJcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAgICovXG4gICAgbmVlZHNJdHNPd25DYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ID09PSAnc3Ryb2tlJyAmJlxuICAgICAgICB0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpICYmIHR5cGVvZiB0aGlzLnNoYWRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jbGlwUGF0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaWRlIGlmIHRoZSBvYmplY3Qgc2hvdWxkIGNhY2hlIG9yIG5vdC4gQ3JlYXRlIGl0cyBvd24gY2FjaGUgbGV2ZWxcbiAgICAgKiBvYmplY3RDYWNoaW5nIGlzIGEgZ2xvYmFsIGZsYWcsIHdpbnMgb3ZlciBldmVyeXRoaW5nXG4gICAgICogbmVlZHNJdHNPd25DYWNoZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBvYmplY3QgZHJhd2luZyBtZXRob2QgcmVxdWlyZXNcbiAgICAgKiBhIGNhY2hlIHN0ZXAuIE5vbmUgb2YgdGhlIGZhYnJpYyBjbGFzc2VzIHJlcXVpcmVzIGl0LlxuICAgICAqIEdlbmVyYWxseSB5b3UgZG8gbm90IGNhY2hlIG9iamVjdHMgaW4gZ3JvdXBzIGJlY2F1c2UgdGhlIGdyb3VwIG91dHNpZGUgaXMgY2FjaGVkLlxuICAgICAqIFJlYWQgYXM6IGNhY2hlIGlmIGlzIG5lZWRlZCwgb3IgaWYgdGhlIGZlYXR1cmUgaXMgZW5hYmxlZCBidXQgd2UgYXJlIG5vdCBhbHJlYWR5IGNhY2hpbmcuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzaG91bGRDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm93bkNhY2hpbmcgPSB0aGlzLm5lZWRzSXRzT3duQ2FjaGUoKSB8fCAoXG4gICAgICAgIHRoaXMub2JqZWN0Q2FjaGluZyAmJlxuICAgICAgICAoIXRoaXMuZ3JvdXAgfHwgIXRoaXMuZ3JvdXAuaXNPbkFDYWNoZSgpKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzLm93bkNhY2hpbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IG9yIGEgY2hpbGQgb2JqZWN0IHdpbGwgY2FzdCBhIHNoYWRvd1xuICAgICAqIHVzZWQgYnkgR3JvdXAuc2hvdWxkQ2FjaGUgdG8ga25vdyBpZiBjaGlsZCBoYXMgYSBzaGFkb3cgcmVjdXJzaXZlbHlcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHdpbGxEcmF3U2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuc2hhZG93ICYmICh0aGlzLnNoYWRvdy5vZmZzZXRYICE9PSAwIHx8IHRoaXMuc2hhZG93Lm9mZnNldFkgIT09IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBkcmF3aW5nIG9wZXJhdGlvbiBmb3IgYW4gb2JqZWN0IGNsaXBQYXRoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gY2xpcFBhdGhcbiAgICAgKi9cbiAgICBkcmF3Q2xpcFBhdGhPbkNhY2hlOiBmdW5jdGlvbihjdHgsIGNsaXBQYXRoKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgLy8gREVCVUc6IHVuY29tbWVudCB0aGlzIGxpbmUsIGNvbW1lbnQgdGhlIGZvbGxvd2luZ1xuICAgICAgLy8gY3R4Lmdsb2JhbEFscGhhID0gMC40XG4gICAgICBpZiAoY2xpcFBhdGguaW52ZXJ0ZWQpIHtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24taW4nO1xuICAgICAgfVxuICAgICAgLy9jdHguc2NhbGUoMSAvIDIsIDEgLyAyKTtcbiAgICAgIGlmIChjbGlwUGF0aC5hYnNvbHV0ZVBvc2l0aW9uZWQpIHtcbiAgICAgICAgdmFyIG0gPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0odGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCkpO1xuICAgICAgICBjdHgudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgICAgfVxuICAgICAgY2xpcFBhdGgudHJhbnNmb3JtKGN0eCk7XG4gICAgICBjdHguc2NhbGUoMSAvIGNsaXBQYXRoLnpvb21YLCAxIC8gY2xpcFBhdGguem9vbVkpO1xuICAgICAgY3R4LmRyYXdJbWFnZShjbGlwUGF0aC5fY2FjaGVDYW52YXMsIC1jbGlwUGF0aC5jYWNoZVRyYW5zbGF0aW9uWCwgLWNsaXBQYXRoLmNhY2hlVHJhbnNsYXRpb25ZKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGRyYXdpbmcgb3BlcmF0aW9uIGZvciBhbiBvYmplY3Qgb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3T2JqZWN0OiBmdW5jdGlvbihjdHgsIGZvckNsaXBwaW5nKSB7XG4gICAgICB2YXIgb3JpZ2luYWxGaWxsID0gdGhpcy5maWxsLCBvcmlnaW5hbFN0cm9rZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgaWYgKGZvckNsaXBwaW5nKSB7XG4gICAgICAgIHRoaXMuZmlsbCA9ICdibGFjayc7XG4gICAgICAgIHRoaXMuc3Ryb2tlID0gJyc7XG4gICAgICAgIHRoaXMuX3NldENsaXBwaW5nUHJvcGVydGllcyhjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQoY3R4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbmRlcihjdHgpO1xuICAgICAgdGhpcy5fZHJhd0NsaXBQYXRoKGN0eCwgdGhpcy5jbGlwUGF0aCk7XG4gICAgICB0aGlzLmZpbGwgPSBvcmlnaW5hbEZpbGw7XG4gICAgICB0aGlzLnN0cm9rZSA9IG9yaWdpbmFsU3Ryb2tlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIGNsaXBQYXRoIHN0YXRlIGFuZCBjYWNoZSBhbmQgZHJhdyBpdCBvbiBpbnN0YW5jZSdzIGNhY2hlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gY2xpcFBhdGhcbiAgICAgKi9cbiAgICBfZHJhd0NsaXBQYXRoOiBmdW5jdGlvbiAoY3R4LCBjbGlwUGF0aCkge1xuICAgICAgaWYgKCFjbGlwUGF0aCkgeyByZXR1cm47IH1cbiAgICAgIC8vIG5lZWRlZCB0byBzZXR1cCBhIGNvdXBsZSBvZiB2YXJpYWJsZXNcbiAgICAgIC8vIHBhdGggY2FudmFzIGdldHMgb3ZlcnJpZGRlbiB3aXRoIHRoaXMgb25lLlxuICAgICAgLy8gVE9ETyBmaW5kIGEgYmV0dGVyIHNvbHV0aW9uP1xuICAgICAgY2xpcFBhdGguY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICBjbGlwUGF0aC5zaG91bGRDYWNoZSgpO1xuICAgICAgY2xpcFBhdGguX3RyYW5zZm9ybURvbmUgPSB0cnVlO1xuICAgICAgY2xpcFBhdGgucmVuZGVyQ2FjaGUoeyBmb3JDbGlwcGluZzogdHJ1ZSB9KTtcbiAgICAgIHRoaXMuZHJhd0NsaXBQYXRoT25DYWNoZShjdHgsIGNsaXBQYXRoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFpbnQgdGhlIGNhY2hlZCBjb3B5IG9mIHRoZSBvYmplY3Qgb24gdGhlIHRhcmdldCBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3Q2FjaGVPbkNhbnZhczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguc2NhbGUoMSAvIHRoaXMuem9vbVgsIDEgLyB0aGlzLnpvb21ZKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fY2FjaGVDYW52YXMsIC10aGlzLmNhY2hlVHJhbnNsYXRpb25YLCAtdGhpcy5jYWNoZVRyYW5zbGF0aW9uWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGNhY2hlIGlzIGRpcnR5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwQ2FudmFzIHNraXAgY2FudmFzIGNoZWNrcyBiZWNhdXNlIHRoaXMgb2JqZWN0IGlzIHBhaW50ZWRcbiAgICAgKiBvbiBwYXJlbnQgY2FudmFzLlxuICAgICAqL1xuICAgIGlzQ2FjaGVEaXJ0eTogZnVuY3Rpb24oc2tpcENhbnZhcykge1xuICAgICAgaWYgKHRoaXMuaXNOb3RWaXNpYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NhY2hlQ2FudmFzICYmIHRoaXMuX2NhY2hlQ29udGV4dCAmJiAhc2tpcENhbnZhcyAmJiB0aGlzLl91cGRhdGVDYWNoZUNhbnZhcygpKSB7XG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSB0aGUgY29udGV4dCBpcyBhbHJlYWR5IGNsZWFyZWQuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5IHx8XG4gICAgICAgICAgKHRoaXMuY2xpcFBhdGggJiYgdGhpcy5jbGlwUGF0aC5hYnNvbHV0ZVBvc2l0aW9uZWQpIHx8XG4gICAgICAgICAgKHRoaXMuc3RhdGVmdWxsQ2FjaGUgJiYgdGhpcy5oYXNTdGF0ZUNoYW5nZWQoJ2NhY2hlUHJvcGVydGllcycpKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAodGhpcy5fY2FjaGVDYW52YXMgJiYgdGhpcy5fY2FjaGVDb250ZXh0ICYmICFza2lwQ2FudmFzKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmNhY2hlV2lkdGggLyB0aGlzLnpvb21YO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY2FjaGVIZWlnaHQgLyB0aGlzLnpvb21ZO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LmNsZWFyUmVjdCgtd2lkdGggLyAyLCAtaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgYmFja2dyb3VuZCBmb3IgdGhlIG9iamVjdCBiaWcgYXMgaXRzIHVudHJhbnNmb3JtZWQgZGltZW5zaW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJCYWNrZ3JvdW5kOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGRpbSA9IHRoaXMuX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgIC1kaW0ueCAvIDIsXG4gICAgICAgIC1kaW0ueSAvIDIsXG4gICAgICAgIGRpbS54LFxuICAgICAgICBkaW0ueVxuICAgICAgKTtcbiAgICAgIC8vIGlmIHRoZXJlIGlzIGJhY2tncm91bmQgY29sb3Igbm8gb3RoZXIgc2hhZG93c1xuICAgICAgLy8gc2hvdWxkIGJlIGNhc3RlZFxuICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9zZXRPcGFjaXR5OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLmdyb3VwICYmICF0aGlzLmdyb3VwLl90cmFuc2Zvcm1Eb25lKSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuZ2V0T2JqZWN0T3BhY2l0eSgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSAqPSB0aGlzLm9wYWNpdHk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRTdHJva2VTdHlsZXM6IGZ1bmN0aW9uKGN0eCwgZGVjbCkge1xuICAgICAgdmFyIHN0cm9rZSA9IGRlY2wuc3Ryb2tlO1xuICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gZGVjbC5zdHJva2VXaWR0aDtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBkZWNsLnN0cm9rZUxpbmVDYXA7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGRlY2wuc3Ryb2tlRGFzaE9mZnNldDtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gZGVjbC5zdHJva2VMaW5lSm9pbjtcbiAgICAgICAgY3R4Lm1pdGVyTGltaXQgPSBkZWNsLnN0cm9rZU1pdGVyTGltaXQ7XG4gICAgICAgIGlmIChzdHJva2UudG9MaXZlKSB7XG4gICAgICAgICAgaWYgKHN0cm9rZS5ncmFkaWVudFVuaXRzID09PSAncGVyY2VudGFnZScgfHwgc3Ryb2tlLmdyYWRpZW50VHJhbnNmb3JtIHx8IHN0cm9rZS5wYXR0ZXJuVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIHRyYW5zZm9ybSBncmFkaWVudCBpbiBhIHBhdHRlcm4uXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgc2xvdyBwcm9jZXNzLiBJZiB5b3UgYXJlIGhpdHRpbmcgdGhpcyBjb2RlcGF0aCwgYW5kIHRoZSBvYmplY3RcbiAgICAgICAgICAgIC8vIGlzIG5vdCB1c2luZyBjYWNoaW5nLCB5b3Ugc2hvdWxkIGNvbnNpZGVyIHN3aXRjaGluZyBpdCBvbi5cbiAgICAgICAgICAgIC8vIHdlIG5lZWQgYSBjYW52YXMgYXMgYmlnIGFzIHRoZSBjdXJyZW50IG9iamVjdCBjYWNoaW5nIGNhbnZhcy5cbiAgICAgICAgICAgIHRoaXMuX2FwcGx5UGF0dGVybkZvclRyYW5zZm9ybWVkR3JhZGllbnQoY3R4LCBzdHJva2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlzIGEgc2ltcGxlIGdyYWRpZW50IG9yIHBhdHRlcm5cbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZS50b0xpdmUoY3R4LCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKGN0eCwgc3Ryb2tlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gaXMgYSBjb2xvclxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGRlY2wuc3Ryb2tlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRGaWxsU3R5bGVzOiBmdW5jdGlvbihjdHgsIGRlY2wpIHtcbiAgICAgIHZhciBmaWxsID0gZGVjbC5maWxsO1xuICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgaWYgKGZpbGwudG9MaXZlKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGwudG9MaXZlKGN0eCwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0oY3R4LCBkZWNsLmZpbGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRDbGlwcGluZ1Byb3BlcnRpZXM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICd0cmFuc3BhcmVudCc7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJyMwMDAwMDAnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFNldHMgbGluZSBkYXNoXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHNldCB0aGUgZGFzaCBsaW5lIG9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGFzaEFycmF5IGFycmF5IHJlcHJlc2VudGluZyBkYXNoZXNcbiAgICAgKi9cbiAgICBfc2V0TGluZURhc2g6IGZ1bmN0aW9uKGN0eCwgZGFzaEFycmF5KSB7XG4gICAgICBpZiAoIWRhc2hBcnJheSB8fCBkYXNoQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFNwZWMgcmVxdWlyZXMgdGhlIGNvbmNhdGVuYXRpb24gb2YgdHdvIGNvcGllcyB0aGUgZGFzaCBsaXN0IHdoZW4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpcyBvZGRcbiAgICAgIGlmICgxICYgZGFzaEFycmF5Lmxlbmd0aCkge1xuICAgICAgICBkYXNoQXJyYXkucHVzaC5hcHBseShkYXNoQXJyYXksIGRhc2hBcnJheSk7XG4gICAgICB9XG4gICAgICBjdHguc2V0TGluZURhc2goZGFzaEFycmF5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjb250cm9scyBhbmQgYm9yZGVycyBmb3IgdGhlIG9iamVjdFxuICAgICAqIHRoZSBjb250ZXh0IGhlcmUgaXMgbm90IHRyYW5zZm9ybWVkXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVPdmVycmlkZV0gcHJvcGVydGllcyB0byBvdmVycmlkZSB0aGUgb2JqZWN0IHN0eWxlXG4gICAgICovXG4gICAgX3JlbmRlckNvbnRyb2xzOiBmdW5jdGlvbihjdHgsIHN0eWxlT3ZlcnJpZGUpIHtcbiAgICAgIHZhciB2cHQgPSB0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCksXG4gICAgICAgICAgbWF0cml4ID0gdGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICAgb3B0aW9ucywgZHJhd0JvcmRlcnMsIGRyYXdDb250cm9scztcbiAgICAgIHN0eWxlT3ZlcnJpZGUgPSBzdHlsZU92ZXJyaWRlIHx8IHsgfTtcbiAgICAgIGRyYXdCb3JkZXJzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUuaGFzQm9yZGVycyAhPT0gJ3VuZGVmaW5lZCcgPyBzdHlsZU92ZXJyaWRlLmhhc0JvcmRlcnMgOiB0aGlzLmhhc0JvcmRlcnM7XG4gICAgICBkcmF3Q29udHJvbHMgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS5oYXNDb250cm9scyAhPT0gJ3VuZGVmaW5lZCcgPyBzdHlsZU92ZXJyaWRlLmhhc0NvbnRyb2xzIDogdGhpcy5oYXNDb250cm9scztcbiAgICAgIG1hdHJpeCA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXModnB0LCBtYXRyaXgpO1xuICAgICAgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKG1hdHJpeCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZShvcHRpb25zLnRyYW5zbGF0ZVgsIG9wdGlvbnMudHJhbnNsYXRlWSk7XG4gICAgICBjdHgubGluZVdpZHRoID0gMSAqIHRoaXMuYm9yZGVyU2NhbGVGYWN0b3I7XG4gICAgICBpZiAoIXRoaXMuZ3JvdXApIHtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5pc01vdmluZyA/IHRoaXMuYm9yZGVyT3BhY2l0eVdoZW5Nb3ZpbmcgOiAxO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZmxpcFgpIHtcbiAgICAgICAgb3B0aW9ucy5hbmdsZSAtPSAxODA7XG4gICAgICB9XG4gICAgICBjdHgucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnModGhpcy5ncm91cCA/IG9wdGlvbnMuYW5nbGUgOiB0aGlzLmFuZ2xlKSk7XG4gICAgICBpZiAoc3R5bGVPdmVycmlkZS5mb3JBY3RpdmVTZWxlY3Rpb24gfHwgdGhpcy5ncm91cCkge1xuICAgICAgICBkcmF3Qm9yZGVycyAmJiB0aGlzLmRyYXdCb3JkZXJzSW5Hcm91cChjdHgsIG9wdGlvbnMsIHN0eWxlT3ZlcnJpZGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRyYXdCb3JkZXJzICYmIHRoaXMuZHJhd0JvcmRlcnMoY3R4LCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIH1cbiAgICAgIGRyYXdDb250cm9scyAmJiB0aGlzLmRyYXdDb250cm9scyhjdHgsIHN0eWxlT3ZlcnJpZGUpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3NldFNoYWRvdzogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc2hhZG93KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNoYWRvdyA9IHRoaXMuc2hhZG93LCBjYW52YXMgPSB0aGlzLmNhbnZhcywgc2NhbGluZyxcbiAgICAgICAgICBtdWx0WCA9IChjYW52YXMgJiYgY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtWzBdKSB8fCAxLFxuICAgICAgICAgIG11bHRZID0gKGNhbnZhcyAmJiBjYW52YXMudmlld3BvcnRUcmFuc2Zvcm1bM10pIHx8IDE7XG4gICAgICBpZiAoc2hhZG93Lm5vblNjYWxpbmcpIHtcbiAgICAgICAgc2NhbGluZyA9IHsgc2NhbGVYOiAxLCBzY2FsZVk6IDEgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzY2FsaW5nID0gdGhpcy5nZXRPYmplY3RTY2FsaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FudmFzICYmIGNhbnZhcy5faXNSZXRpbmFTY2FsaW5nKCkpIHtcbiAgICAgICAgbXVsdFggKj0gZmFicmljLmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIG11bHRZICo9IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgfVxuICAgICAgY3R4LnNoYWRvd0NvbG9yID0gc2hhZG93LmNvbG9yO1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSBzaGFkb3cuYmx1ciAqIGZhYnJpYy5icm93c2VyU2hhZG93Qmx1ckNvbnN0YW50ICpcbiAgICAgICAgKG11bHRYICsgbXVsdFkpICogKHNjYWxpbmcuc2NhbGVYICsgc2NhbGluZy5zY2FsZVkpIC8gNDtcbiAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gc2hhZG93Lm9mZnNldFggKiBtdWx0WCAqIHNjYWxpbmcuc2NhbGVYO1xuICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSBzaGFkb3cub2Zmc2V0WSAqIG11bHRZICogc2NhbGluZy5zY2FsZVk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnNoYWRvdykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9ICcnO1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSBjdHguc2hhZG93T2Zmc2V0WCA9IGN0eC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbGxlciBmYWJyaWMuUGF0dGVybiBvciBmYWJyaWMuR3JhZGllbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9mZnNldC5vZmZzZXRYIG9mZnNldCBmb3IgdGV4dCByZW5kZXJpbmdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9mZnNldC5vZmZzZXRZIG9mZnNldCBmb3IgdGV4dCByZW5kZXJpbmdcbiAgICAgKi9cbiAgICBfYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm06IGZ1bmN0aW9uKGN0eCwgZmlsbGVyKSB7XG4gICAgICBpZiAoIWZpbGxlciB8fCAhZmlsbGVyLnRvTGl2ZSkge1xuICAgICAgICByZXR1cm4geyBvZmZzZXRYOiAwLCBvZmZzZXRZOiAwIH07XG4gICAgICB9XG4gICAgICB2YXIgdCA9IGZpbGxlci5ncmFkaWVudFRyYW5zZm9ybSB8fCBmaWxsZXIucGF0dGVyblRyYW5zZm9ybTtcbiAgICAgIHZhciBvZmZzZXRYID0gLXRoaXMud2lkdGggLyAyICsgZmlsbGVyLm9mZnNldFggfHwgMCxcbiAgICAgICAgICBvZmZzZXRZID0gLXRoaXMuaGVpZ2h0IC8gMiArIGZpbGxlci5vZmZzZXRZIHx8IDA7XG5cbiAgICAgIGlmIChmaWxsZXIuZ3JhZGllbnRVbml0cyA9PT0gJ3BlcmNlbnRhZ2UnKSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0odGhpcy53aWR0aCwgMCwgMCwgdGhpcy5oZWlnaHQsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICB9XG4gICAgICBpZiAodCkge1xuICAgICAgICBjdHgudHJhbnNmb3JtKHRbMF0sIHRbMV0sIHRbMl0sIHRbM10sIHRbNF0sIHRbNV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgb2Zmc2V0WDogb2Zmc2V0WCwgb2Zmc2V0WTogb2Zmc2V0WSB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyUGFpbnRJbk9yZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICh0aGlzLnBhaW50Rmlyc3QgPT09ICdzdHJva2UnKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclN0cm9rZShjdHgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJGaWxsKGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyRmlsbChjdHgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGFjdHVhbGx5IHJlbmRlciBzb21ldGhpbmcgb24gdGhlIGNvbnRleHQuXG4gICAgICogZW1wdHkgaGVyZSB0byBhbGxvdyBPYmVjdHMgdG8gd29yayBvbiB0ZXN0cyB0byBiZW5jaG1hcmsgZmFicmljIGZ1bmN0aW9uYWxpdGVzXG4gICAgICogbm90IHJlbGF0ZWQgdG8gcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKC8qIGN0eCAqLykge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJGaWxsOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5maWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldEZpbGxTdHlsZXMoY3R4LCB0aGlzKTtcbiAgICAgIGlmICh0aGlzLmZpbGxSdWxlID09PSAnZXZlbm9kZCcpIHtcbiAgICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlV2lkdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaGFkb3cgJiYgIXRoaXMuc2hhZG93LmFmZmVjdFN0cm9rZSkge1xuICAgICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGlmICh0aGlzLnN0cm9rZVVuaWZvcm0gJiYgdGhpcy5ncm91cCkge1xuICAgICAgICB2YXIgc2NhbGluZyA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpO1xuICAgICAgICBjdHguc2NhbGUoMSAvIHNjYWxpbmcuc2NhbGVYLCAxIC8gc2NhbGluZy5zY2FsZVkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zdHJva2VVbmlmb3JtKSB7XG4gICAgICAgIGN0eC5zY2FsZSgxIC8gdGhpcy5zY2FsZVgsIDEgLyB0aGlzLnNjYWxlWSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIHRoaXMuX3NldFN0cm9rZVN0eWxlcyhjdHgsIHRoaXMpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB0cnkgdG8gcGF0Y2ggdGhlIG1pc3NpbmcgZ3JhZGllbnRUcmFuc2Zvcm0gb24gY2FudmFzIGdyYWRpZW50cy5cbiAgICAgKiB0cmFuc2Zvcm1pbmcgYSBjb250ZXh0IHRvIHRyYW5zZm9ybSB0aGUgZ3JhZGllbnQsIGlzIGdvaW5nIHRvIHRyYW5zZm9ybSB0aGUgc3Ryb2tlIHRvby5cbiAgICAgKiB3ZSB3YW50IHRvIHRyYW5zZm9ybSB0aGUgZ3JhZGllbnQgYnV0IG5vdCB0aGUgc3Ryb2tlIG9wZXJhdGlvbiwgc28gd2UgY3JlYXRlXG4gICAgICogYSB0cmFuc2Zvcm1lZCBncmFkaWVudCBvbiBhIHBhdHRlcm4gYW5kIHRoZW4gd2UgdXNlIHRoZSBwYXR0ZXJuIGluc3RlYWQgb2YgdGhlIGdyYWRpZW50LlxuICAgICAqIHRoaXMgbWV0aG9kIGhhcyBkcndhYmFja3M6IGlzIHNsb3csIGlzIGluIGxvdyByZXNvbHV0aW9uLCBuZWVkcyBhIHBhdGNoIGZvciB3aGVuIHRoZSBzaXplXG4gICAgICogaXMgbGltaXRlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5HcmFkaWVudH0gZmlsbGVyIGEgZmFicmljIGdyYWRpZW50IGluc3RhbmNlXG4gICAgICovXG4gICAgX2FwcGx5UGF0dGVybkZvclRyYW5zZm9ybWVkR3JhZGllbnQ6IGZ1bmN0aW9uKGN0eCwgZmlsbGVyKSB7XG4gICAgICB2YXIgZGltcyA9IHRoaXMuX2xpbWl0Q2FjaGVTaXplKHRoaXMuX2dldENhY2hlQ2FudmFzRGltZW5zaW9ucygpKSxcbiAgICAgICAgICBwQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLCBwQ3R4LCByZXRpbmFTY2FsaW5nID0gdGhpcy5jYW52YXMuZ2V0UmV0aW5hU2NhbGluZygpLFxuICAgICAgICAgIHdpZHRoID0gZGltcy54IC8gdGhpcy5zY2FsZVggLyByZXRpbmFTY2FsaW5nLCBoZWlnaHQgPSBkaW1zLnkgLyB0aGlzLnNjYWxlWSAvIHJldGluYVNjYWxpbmc7XG4gICAgICBwQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICBwQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHBDdHggPSBwQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBwQ3R4LmJlZ2luUGF0aCgpOyBwQ3R4Lm1vdmVUbygwLCAwKTsgcEN0eC5saW5lVG8od2lkdGgsIDApOyBwQ3R4LmxpbmVUbyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHBDdHgubGluZVRvKDAsIGhlaWdodCk7IHBDdHguY2xvc2VQYXRoKCk7XG4gICAgICBwQ3R4LnRyYW5zbGF0ZSh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgcEN0eC5zY2FsZShcbiAgICAgICAgZGltcy56b29tWCAvIHRoaXMuc2NhbGVYIC8gcmV0aW5hU2NhbGluZyxcbiAgICAgICAgZGltcy56b29tWSAvIHRoaXMuc2NhbGVZIC8gcmV0aW5hU2NhbGluZ1xuICAgICAgKTtcbiAgICAgIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKHBDdHgsIGZpbGxlcik7XG4gICAgICBwQ3R4LmZpbGxTdHlsZSA9IGZpbGxlci50b0xpdmUoY3R4KTtcbiAgICAgIHBDdHguZmlsbCgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSgtdGhpcy53aWR0aCAvIDIgLSB0aGlzLnN0cm9rZVdpZHRoIC8gMiwgLXRoaXMuaGVpZ2h0IC8gMiAtIHRoaXMuc3Ryb2tlV2lkdGggLyAyKTtcbiAgICAgIGN0eC5zY2FsZShcbiAgICAgICAgcmV0aW5hU2NhbGluZyAqIHRoaXMuc2NhbGVYIC8gZGltcy56b29tWCxcbiAgICAgICAgcmV0aW5hU2NhbGluZyAqIHRoaXMuc2NhbGVZIC8gZGltcy56b29tWVxuICAgICAgKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHBDdHguY3JlYXRlUGF0dGVybihwQ2FudmFzLCAnbm8tcmVwZWF0Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYW4gaGVscGVyIGZvciBzdmcgaW1wb3J0LiBpdCByZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIG9iamVjdCBpbiB0aGUgc3ZnXG4gICAgICogdW50cmFuc2Zvcm1lZCBjb29yZGluYXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgcG9pbnQgZnJvbSBlbGVtZW50IGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgX2ZpbmRDZW50ZXJGcm9tRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geyB4OiB0aGlzLmxlZnQgKyB0aGlzLndpZHRoIC8gMiwgeTogdGhpcy50b3AgKyB0aGlzLmhlaWdodCAvIDIgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhbiBoZWxwZXIgZm9yIHN2ZyBpbXBvcnQuIGl0IGRlY29tcG9zZSB0aGUgdHJhbnNmb3JtTWF0cml4XG4gICAgICogYW5kIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIG9iamVjdC5cbiAgICAgKiB1bnRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX2Fzc2lnblRyYW5zZm9ybU1hdHJpeFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnRyYW5zZm9ybU1hdHJpeCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICAgICAgdGhpcy5mbGlwWCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZsaXBZID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0KCdzY2FsZVgnLCBvcHRpb25zLnNjYWxlWCk7XG4gICAgICAgIHRoaXMuc2V0KCdzY2FsZVknLCBvcHRpb25zLnNjYWxlWSk7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBvcHRpb25zLmFuZ2xlO1xuICAgICAgICB0aGlzLnNrZXdYID0gb3B0aW9ucy5za2V3WDtcbiAgICAgICAgdGhpcy5za2V3WSA9IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYW4gaGVscGVyIGZvciBzdmcgaW1wb3J0LiBpdCByZW1vdmVzIHRoZSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICogYW5kIHNldCB0byBvYmplY3QgcHJvcGVydGllcyB0aGF0IGZhYnJpY2pzIGNhbiBoYW5kbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9uc1xuICAgICAqIEByZXR1cm4ge3RoaXNBcmd9XG4gICAgICovXG4gICAgX3JlbW92ZVRyYW5zZm9ybU1hdHJpeDogZnVuY3Rpb24ocHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLl9maW5kQ2VudGVyRnJvbUVsZW1lbnQoKTtcbiAgICAgIGlmICh0aGlzLnRyYW5zZm9ybU1hdHJpeCkge1xuICAgICAgICB0aGlzLl9hc3NpZ25UcmFuc2Zvcm1NYXRyaXhQcm9wcygpO1xuICAgICAgICBjZW50ZXIgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChjZW50ZXIsIHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gbnVsbDtcbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucykge1xuICAgICAgICB0aGlzLnNjYWxlWCAqPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5zY2FsZVg7XG4gICAgICAgIHRoaXMuc2NhbGVZICo9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLnNjYWxlWTtcbiAgICAgICAgdGhpcy5jcm9wWCA9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLmNyb3BYO1xuICAgICAgICB0aGlzLmNyb3BZID0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuY3JvcFk7XG4gICAgICAgIGNlbnRlci54ICs9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLm9mZnNldExlZnQ7XG4gICAgICAgIGNlbnRlci55ICs9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLm9mZnNldFRvcDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0UG9zaXRpb25CeU9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsb25lcyBhbiBpbnN0YW5jZSwgdXNpbmcgYSBjYWxsYmFjayBtZXRob2Qgd2lsbCB3b3JrIGZvciBldmVyeSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgaXMgaW52b2tlZCB3aXRoIGEgY2xvbmUgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24oY2FsbGJhY2ssIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvYmplY3RGb3JtID0gdGhpcy50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLmZyb21PYmplY3QpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5mcm9tT2JqZWN0KG9iamVjdEZvcm0sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdPYmplY3QnLCBvYmplY3RGb3JtLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZmFicmljLkltYWdlIG91dCBvZiBhbiBvYmplY3RcbiAgICAgKiBtYWtlcyB1c2Ugb2YgdG9DYW52YXNFbGVtZW50LlxuICAgICAqIE9uY2UgdGhpcyBtZXRob2Qgd2FzIGJhc2VkIG9uIHRvRGF0YVVybCBhbmQgbG9hZEltYWdlLCBzbyBpdCBhbHNvIGhhZCBhIHF1YWxpdHlcbiAgICAgKiBhbmQgZm9ybWF0IG9wdGlvbi4gdG9DYW52YXNFbGVtZW50IGlzIGZhc3RlciBhbmQgcHJvZHVjZSBubyBsb3NzIG9mIHF1YWxpdHkuXG4gICAgICogSWYgeW91IG5lZWQgdG8gZ2V0IGEgcmVhbCBKcGVnIG9yIFBuZyBmcm9tIGFuIG9iamVjdCwgdXNpbmcgdG9EYXRhVVJMIGlzIHRoZSByaWdodCB3YXkgdG8gZG8gaXQuXG4gICAgICogdG9DYW52YXNFbGVtZW50IGFuZCB0aGVuIHRvQmxvYiBmcm9tIHRoZSBvYnRhaW5lZCBjYW52YXMgaXMgYWxzbyBhIGdvb2Qgb3B0aW9uLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHN5bmMgbm93LCBidXQgc3RpbGwgc3VwcG9ydCB0aGUgY2FsbGJhY2sgYmVjYXVzZSB3ZSBkaWQgbm90IHdhbnQgdG8gYnJlYWsuXG4gICAgICogV2hlbiBmYWJyaWNKUyA1LjAgd2lsbCBiZSBwbGFubmVkLCB0aGlzIHdpbGwgcHJvYmFibHkgYmUgY2hhbmdlZCB0byBub3QgaGF2ZSBhIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrLCBpbnZva2VkIHdpdGggYW4gaW5zdGFuY2UgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gZm9yIGNsb25lIGFzIGltYWdlLCBwYXNzZWQgdG8gdG9EYXRhVVJMXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAxLjYuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFRyYW5zZm9ybV0gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHRyYW5zZm9ybSAoIG5vIHNjYWxlICwgbm8gYW5nbGUsIG5vIGZsaXAsIG5vIHNrZXcgKS4gSW50cm9kdWNlZCBpbiAyLjMuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFNoYWRvd10gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHNoYWRvdy4gSW50cm9kdWNlZCBpbiAyLjQuMlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBjbG9uZUFzSW1hZ2U6IGZ1bmN0aW9uKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2FudmFzRWwgPSB0aGlzLnRvQ2FudmFzRWxlbWVudChvcHRpb25zKTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhuZXcgZmFicmljLkltYWdlKGNhbnZhc0VsKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBIVE1MQ2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tdWx0aXBsaWVyPTFdIE11bHRpcGxpZXIgdG8gc2NhbGUgYnlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVmdF0gQ3JvcHBpbmcgbGVmdCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b3BdIENyb3BwaW5nIHRvcCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gQ3JvcHBpbmcgd2lkdGguIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIENyb3BwaW5nIGhlaWdodC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nXSBFbmFibGUgcmV0aW5hIHNjYWxpbmcgZm9yIGNsb25lIGltYWdlLiBJbnRyb2R1Y2UgaW4gMS42LjRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRUcmFuc2Zvcm1dIFJlbW92ZSBjdXJyZW50IG9iamVjdCB0cmFuc2Zvcm0gKCBubyBzY2FsZSAsIG5vIGFuZ2xlLCBubyBmbGlwLCBubyBza2V3ICkuIEludHJvZHVjZWQgaW4gMi4zLjRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRTaGFkb3ddIFJlbW92ZSBjdXJyZW50IG9iamVjdCBzaGFkb3cuIEludHJvZHVjZWQgaW4gMi40LjJcbiAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gUmV0dXJucyBET00gZWxlbWVudCA8Y2FudmFzPiB3aXRoIHRoZSBmYWJyaWMuT2JqZWN0XG4gICAgICovXG4gICAgdG9DYW52YXNFbGVtZW50OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIHV0aWxzID0gZmFicmljLnV0aWwsIG9yaWdQYXJhbXMgPSB1dGlscy5zYXZlT2JqZWN0VHJhbnNmb3JtKHRoaXMpLFxuICAgICAgICAgIG9yaWdpbmFsR3JvdXAgPSB0aGlzLmdyb3VwLFxuICAgICAgICAgIG9yaWdpbmFsU2hhZG93ID0gdGhpcy5zaGFkb3csIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgIG11bHRpcGxpZXIgPSAob3B0aW9ucy5tdWx0aXBsaWVyIHx8IDEpICogKG9wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZyA/IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvIDogMSk7XG4gICAgICBkZWxldGUgdGhpcy5ncm91cDtcbiAgICAgIGlmIChvcHRpb25zLndpdGhvdXRUcmFuc2Zvcm0pIHtcbiAgICAgICAgdXRpbHMucmVzZXRPYmplY3RUcmFuc2Zvcm0odGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy53aXRob3V0U2hhZG93KSB7XG4gICAgICAgIHRoaXMuc2hhZG93ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICAgIC8vIHNraXAgY2FudmFzIHpvb20gYW5kIGNhbGN1bGF0ZSB3aXRoIHNldENvb3JkcyBub3cuXG4gICAgICAgICAgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QodHJ1ZSwgdHJ1ZSksXG4gICAgICAgICAgc2hhZG93ID0gdGhpcy5zaGFkb3csIHNjYWxpbmcsXG4gICAgICAgICAgc2hhZG93T2Zmc2V0ID0geyB4OiAwLCB5OiAwIH0sIHNoYWRvd0JsdXIsXG4gICAgICAgICAgd2lkdGgsIGhlaWdodDtcblxuICAgICAgaWYgKHNoYWRvdykge1xuICAgICAgICBzaGFkb3dCbHVyID0gc2hhZG93LmJsdXI7XG4gICAgICAgIGlmIChzaGFkb3cubm9uU2NhbGluZykge1xuICAgICAgICAgIHNjYWxpbmcgPSB7IHNjYWxlWDogMSwgc2NhbGVZOiAxIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2NhbGluZyA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNpZGVyIG5vbiBzY2FsaW5nIHNoYWRvdy5cbiAgICAgICAgc2hhZG93T2Zmc2V0LnggPSAyICogTWF0aC5yb3VuZChhYnMoc2hhZG93Lm9mZnNldFgpICsgc2hhZG93Qmx1cikgKiAoYWJzKHNjYWxpbmcuc2NhbGVYKSk7XG4gICAgICAgIHNoYWRvd09mZnNldC55ID0gMiAqIE1hdGgucm91bmQoYWJzKHNoYWRvdy5vZmZzZXRZKSArIHNoYWRvd0JsdXIpICogKGFicyhzY2FsaW5nLnNjYWxlWSkpO1xuICAgICAgfVxuICAgICAgd2lkdGggPSBib3VuZGluZ1JlY3Qud2lkdGggKyBzaGFkb3dPZmZzZXQueDtcbiAgICAgIGhlaWdodCA9IGJvdW5kaW5nUmVjdC5oZWlnaHQgKyBzaGFkb3dPZmZzZXQueTtcbiAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHdpZHRoL2hlaWdodCBpcyBub3QgYW4gaW50ZWdlclxuICAgICAgLy8gd2UgbmVlZCB0byBtYWtlIGl0IHNvLlxuICAgICAgZWwud2lkdGggPSBNYXRoLmNlaWwod2lkdGgpO1xuICAgICAgZWwuaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCk7XG4gICAgICB2YXIgY2FudmFzID0gbmV3IGZhYnJpYy5TdGF0aWNDYW52YXMoZWwsIHtcbiAgICAgICAgZW5hYmxlUmV0aW5hU2NhbGluZzogZmFsc2UsXG4gICAgICAgIHJlbmRlck9uQWRkUmVtb3ZlOiBmYWxzZSxcbiAgICAgICAgc2tpcE9mZnNjcmVlbjogZmFsc2UsXG4gICAgICB9KTtcbiAgICAgIGlmIChvcHRpb25zLmZvcm1hdCA9PT0gJ2pwZWcnKSB7XG4gICAgICAgIGNhbnZhcy5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmZic7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFBvc2l0aW9uQnlPcmlnaW4obmV3IGZhYnJpYy5Qb2ludChjYW52YXMud2lkdGggLyAyLCBjYW52YXMuaGVpZ2h0IC8gMiksICdjZW50ZXInLCAnY2VudGVyJyk7XG5cbiAgICAgIHZhciBvcmlnaW5hbENhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgY2FudmFzLmFkZCh0aGlzKTtcbiAgICAgIHZhciBjYW52YXNFbCA9IGNhbnZhcy50b0NhbnZhc0VsZW1lbnQobXVsdGlwbGllciB8fCAxLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2hhZG93ID0gb3JpZ2luYWxTaGFkb3c7XG4gICAgICB0aGlzLnNldCgnY2FudmFzJywgb3JpZ2luYWxDYW52YXMpO1xuICAgICAgaWYgKG9yaWdpbmFsR3JvdXApIHtcbiAgICAgICAgdGhpcy5ncm91cCA9IG9yaWdpbmFsR3JvdXA7XG4gICAgICB9XG4gICAgICB0aGlzLnNldChvcmlnUGFyYW1zKS5zZXRDb29yZHMoKTtcbiAgICAgIC8vIGNhbnZhcy5kaXNwb3NlIHdpbGwgY2FsbCBpbWFnZS5kaXNwb3NlIHRoYXQgd2lsbCBudWxsaWZ5IHRoZSBlbGVtZW50c1xuICAgICAgLy8gc2luY2UgdGhpcyBjYW52YXMgaXMgYSBzaW1wbGUgZWxlbWVudCBmb3IgdGhlIHByb2Nlc3MsIHdlIHJlbW92ZSByZWZlcmVuY2VzXG4gICAgICAvLyB0byBvYmplY3RzIGluIHRoaXMgd2F5IGluIG9yZGVyIHRvIGF2b2lkIG9iamVjdCB0cmFzaGluZy5cbiAgICAgIGNhbnZhcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgY2FudmFzLmRpc3Bvc2UoKTtcbiAgICAgIGNhbnZhcyA9IG51bGw7XG5cbiAgICAgIHJldHVybiBjYW52YXNFbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYSBkYXRhLXVybC1saWtlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmZvcm1hdD1wbmddIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCBpbWFnZS4gRWl0aGVyIFwianBlZ1wiIG9yIFwicG5nXCJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucXVhbGl0eT0xXSBRdWFsaXR5IGxldmVsICgwLi4xKS4gT25seSB1c2VkIGZvciBqcGVnLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tdWx0aXBsaWVyPTFdIE11bHRpcGxpZXIgdG8gc2NhbGUgYnlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVmdF0gQ3JvcHBpbmcgbGVmdCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b3BdIENyb3BwaW5nIHRvcCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gQ3JvcHBpbmcgd2lkdGguIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIENyb3BwaW5nIGhlaWdodC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nXSBFbmFibGUgcmV0aW5hIHNjYWxpbmcgZm9yIGNsb25lIGltYWdlLiBJbnRyb2R1Y2UgaW4gMS42LjRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRUcmFuc2Zvcm1dIFJlbW92ZSBjdXJyZW50IG9iamVjdCB0cmFuc2Zvcm0gKCBubyBzY2FsZSAsIG5vIGFuZ2xlLCBubyBmbGlwLCBubyBza2V3ICkuIEludHJvZHVjZWQgaW4gMi4zLjRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRTaGFkb3ddIFJlbW92ZSBjdXJyZW50IG9iamVjdCBzaGFkb3cuIEludHJvZHVjZWQgaW4gMi40LjJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgYSBkYXRhOiBVUkwgY29udGFpbmluZyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QgaW4gdGhlIGZvcm1hdCBzcGVjaWZpZWQgYnkgb3B0aW9ucy5mb3JtYXRcbiAgICAgKi9cbiAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRvRGF0YVVSTCh0aGlzLnRvQ2FudmFzRWxlbWVudChvcHRpb25zKSwgb3B0aW9ucy5mb3JtYXQgfHwgJ3BuZycsIG9wdGlvbnMucXVhbGl0eSB8fCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHNwZWNpZmllZCB0eXBlIGlzIGlkZW50aWNhbCB0byB0aGUgdHlwZSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgdG8gY2hlY2sgYWdhaW5zdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBBcnJheS5mcm9tKGFyZ3VtZW50cykuaW5jbHVkZXModGhpcy50eXBlKSA6IHRoaXMudHlwZSA9PT0gdHlwZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5IG9mIHRoaXMgaW5zdGFuY2UgKGlzIDEgdW5sZXNzIHN1YmNsYXNzZWQpXG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBKU09OXG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICAvLyBkZWxlZ2F0ZSwgbm90IGFsaWFzXG4gICAgICByZXR1cm4gdGhpcy50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBcImFuZ2xlXCIgb2YgYW4gaW5zdGFuY2Ugd2l0aCBjZW50ZXJlZCByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBBbmdsZSB2YWx1ZSAoaW4gZGVncmVlcylcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgIHZhciBzaG91bGRDZW50ZXJPcmlnaW4gPSAodGhpcy5vcmlnaW5YICE9PSAnY2VudGVyJyB8fCB0aGlzLm9yaWdpblkgIT09ICdjZW50ZXInKSAmJiB0aGlzLmNlbnRlcmVkUm90YXRpb247XG5cbiAgICAgIGlmIChzaG91bGRDZW50ZXJPcmlnaW4pIHtcbiAgICAgICAgdGhpcy5fc2V0T3JpZ2luVG9DZW50ZXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXQoJ2FuZ2xlJywgYW5nbGUpO1xuXG4gICAgICBpZiAoc2hvdWxkQ2VudGVyT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0T3JpZ2luKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgb24gY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJIOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jZW50ZXJPYmplY3RIKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBvbiBjdXJyZW50IHZpZXdwb3J0IG9mIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJIOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydENlbnRlck9iamVjdEgodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBvbiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlclY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNlbnRlck9iamVjdFYodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBvbiBjdXJyZW50IHZpZXdwb3J0IG9mIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJWOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydENlbnRlck9iamVjdFYodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5IG9uIGNhbnZhcyB0byB3aGljaCBpcyB3YXMgYWRkZWQgbGFzdFxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNlbnRlck9iamVjdCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBvbiBjdXJyZW50IHZpZXdwb3J0IG9mIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnZpZXdwb3J0Q2VudGVyT2JqZWN0KHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2YgYSBwb2ludGVyIHJlbGF0aXZlIHRvIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgdG8gb3BlcmF0ZSB1cG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwb2ludGVyXSBQb2ludGVyIHRvIG9wZXJhdGUgdXBvbiAoaW5zdGVhZCBvZiBldmVudClcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIGEgcG9pbnRlciAoeCwgeSlcbiAgICAgKi9cbiAgICBnZXRMb2NhbFBvaW50ZXI6IGZ1bmN0aW9uKGUsIHBvaW50ZXIpIHtcbiAgICAgIHBvaW50ZXIgPSBwb2ludGVyIHx8IHRoaXMuY2FudmFzLmdldFBvaW50ZXIoZSk7XG4gICAgICB2YXIgcENsaWNrZWQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KSxcbiAgICAgICAgICBvYmplY3RMZWZ0VG9wID0gdGhpcy5fZ2V0TGVmdFRvcENvb3JkcygpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcENsaWNrZWQgPSBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChcbiAgICAgICAgICBwQ2xpY2tlZCwgb2JqZWN0TGVmdFRvcCwgZGVncmVlc1RvUmFkaWFucygtdGhpcy5hbmdsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcENsaWNrZWQueCAtIG9iamVjdExlZnRUb3AueCxcbiAgICAgICAgeTogcENsaWNrZWQueSAtIG9iamVjdExlZnRUb3AueVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjYW52YXMgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIGZvciBzcGVjaWZpYyBvYmplY3RcbiAgICAgKiBjdXN0b20gY29tcG9zaXRpb24gb3BlcmF0aW9uIGZvciB0aGUgcGFydGljdWxhciBvYmplY3QgY2FuIGJlIHNwZWNpZmllZCB1c2luZyBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFJlbmRlcmluZyBjYW52YXMgY29udGV4dFxuICAgICAqL1xuICAgIF9zZXR1cENvbXBvc2l0ZU9wZXJhdGlvbjogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgaWYgKHRoaXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uKSB7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB0aGlzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FuY2VsIGluc3RhbmNlJ3MgcnVubmluZyBhbmltYXRpb25zXG4gICAgICogb3ZlcnJpZGUgaWYgbmVjZXNzYXJ5IHRvIGRpc3Bvc2UgYXJ0aWZhY3RzIHN1Y2ggYXMgYGNsaXBQYXRoYFxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChmYWJyaWMucnVubmluZ0FuaW1hdGlvbnMpIHtcbiAgICAgICAgZmFicmljLnJ1bm5pbmdBbmltYXRpb25zLmNhbmNlbEJ5VGFyZ2V0KHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzICYmIGZhYnJpYy51dGlsLmNyZWF0ZUFjY2Vzc29ycyhmYWJyaWMuT2JqZWN0KTtcblxuICBleHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIGZhYnJpYy5PYnNlcnZhYmxlKTtcblxuICAvKipcbiAgICogRGVmaW5lcyB0aGUgbnVtYmVyIG9mIGZyYWN0aW9uIGRpZ2l0cyB0byB1c2Ugd2hlbiBzZXJpYWxpemluZyBvYmplY3QgdmFsdWVzLlxuICAgKiBZb3UgY2FuIHVzZSBpdCB0byBpbmNyZWFzZS9kZWNyZWFzZSBwcmVjaXNpb24gb2Ygc3VjaCB2YWx1ZXMgbGlrZSBsZWZ0LCB0b3AsIHNjYWxlWCwgc2NhbGVZLCBldGMuXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3RcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTID0gMjtcblxuICAvKipcbiAgICogRGVmaW5lcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBlbmxpdmVuZWQgZnJvbSB0aGUgb2JqZWN0IHBhc3NlZCB0byB7QGxpbmsgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdH1cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdFxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUgc3RyaW5nW11cbiAgICovXG4gIGZhYnJpYy5PYmplY3QuRU5MSVZFTl9QUk9QUyA9IFsnY2xpcFBhdGgnXTtcblxuICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0ID0gZnVuY3Rpb24oY2xhc3NOYW1lLCBvYmplY3QsIGNhbGxiYWNrLCBleHRyYVBhcmFtKSB7XG4gICAgdmFyIGtsYXNzID0gZmFicmljW2NsYXNzTmFtZV07XG4gICAgb2JqZWN0ID0gY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuUGF0dGVybnMoW29iamVjdC5maWxsLCBvYmplY3Quc3Ryb2tlXSwgZnVuY3Rpb24ocGF0dGVybnMpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0dGVybnNbMF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9iamVjdC5maWxsID0gcGF0dGVybnNbMF07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhdHRlcm5zWzFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvYmplY3Quc3Ryb2tlID0gcGF0dGVybnNbMV07XG4gICAgICB9XG4gICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0RW5saXZhYmxlcyhvYmplY3QsIG9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBleHRyYVBhcmFtID8gbmV3IGtsYXNzKG9iamVjdFtleHRyYVBhcmFtXSwgb2JqZWN0KSA6IG5ldyBrbGFzcyhvYmplY3QpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVW5pcXVlIGlkIHVzZWQgaW50ZXJuYWxseSB3aGVuIGNyZWF0aW5nIFNWRyBlbGVtZW50c1xuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0XG4gICAqIEB0eXBlIE51bWJlclxuICAgKi9cbiAgZmFicmljLk9iamVjdC5fX3VpZCA9IDA7XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyxcbiAgICAgIG9yaWdpblhPZmZzZXQgPSB7XG4gICAgICAgIGxlZnQ6IC0wLjUsXG4gICAgICAgIGNlbnRlcjogMCxcbiAgICAgICAgcmlnaHQ6IDAuNVxuICAgICAgfSxcbiAgICAgIG9yaWdpbllPZmZzZXQgPSB7XG4gICAgICAgIHRvcDogLTAuNSxcbiAgICAgICAgY2VudGVyOiAwLFxuICAgICAgICBib3R0b206IDAuNVxuICAgICAgfTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGNvb3JkaW5hdGVzIGZyb20gYSBzZXQgb2Ygb3JpZ2luIHRvIGFub3RoZXIgKGJhc2VkIG9uIHRoZSBvYmplY3QncyBkaW1lbnNpb25zKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIG9yaWdpblggYW5kIG9yaWdpblkgcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZyb21PcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZnJvbU9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9PcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9PcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW46IGZ1bmN0aW9uKHBvaW50LCBmcm9tT3JpZ2luWCwgZnJvbU9yaWdpblksIHRvT3JpZ2luWCwgdG9PcmlnaW5ZKSB7XG4gICAgICB2YXIgeCA9IHBvaW50LngsXG4gICAgICAgICAgeSA9IHBvaW50LnksXG4gICAgICAgICAgb2Zmc2V0WCwgb2Zmc2V0WSwgZGltO1xuXG4gICAgICBpZiAodHlwZW9mIGZyb21PcmlnaW5YID09PSAnc3RyaW5nJykge1xuICAgICAgICBmcm9tT3JpZ2luWCA9IG9yaWdpblhPZmZzZXRbZnJvbU9yaWdpblhdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZyb21PcmlnaW5YIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0b09yaWdpblggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRvT3JpZ2luWCA9IG9yaWdpblhPZmZzZXRbdG9PcmlnaW5YXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0b09yaWdpblggLT0gMC41O1xuICAgICAgfVxuXG4gICAgICBvZmZzZXRYID0gdG9PcmlnaW5YIC0gZnJvbU9yaWdpblg7XG5cbiAgICAgIGlmICh0eXBlb2YgZnJvbU9yaWdpblkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZyb21PcmlnaW5ZID0gb3JpZ2luWU9mZnNldFtmcm9tT3JpZ2luWV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZnJvbU9yaWdpblkgLT0gMC41O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRvT3JpZ2luWSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9PcmlnaW5ZID0gb3JpZ2luWU9mZnNldFt0b09yaWdpblldO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRvT3JpZ2luWSAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldFkgPSB0b09yaWdpblkgLSBmcm9tT3JpZ2luWTtcblxuICAgICAgaWYgKG9mZnNldFggfHwgb2Zmc2V0WSkge1xuICAgICAgICBkaW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcbiAgICAgICAgeCA9IHBvaW50LnggKyBvZmZzZXRYICogZGltLng7XG4gICAgICAgIHkgPSBwb2ludC55ICsgb2Zmc2V0WSAqIGRpbS55O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludCh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgY29vcmRpbmF0ZXMgZnJvbSBvcmlnaW4gdG8gY2VudGVyIGNvb3JkaW5hdGVzIChiYXNlZCBvbiB0aGUgb2JqZWN0J3MgZGltZW5zaW9ucylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBvcmlnaW5YIGFuZCBvcmlnaW5ZIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVUb0NlbnRlclBvaW50OiBmdW5jdGlvbihwb2ludCwgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIHAgPSB0aGlzLnRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW4ocG9pbnQsIG9yaWdpblgsIG9yaWdpblksICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICByZXR1cm4gZmFicmljLnV0aWwucm90YXRlUG9pbnQocCwgcG9pbnQsIGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGNvb3JkaW5hdGVzIGZyb20gY2VudGVyIHRvIG9yaWdpbiBjb29yZGluYXRlcyAoYmFzZWQgb24gdGhlIG9iamVjdCdzIGRpbWVuc2lvbnMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGNlbnRlciBUaGUgcG9pbnQgd2hpY2ggY29ycmVzcG9uZHMgdG8gY2VudGVyIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdHJhbnNsYXRlVG9PcmlnaW5Qb2ludDogZnVuY3Rpb24oY2VudGVyLCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgICB2YXIgcCA9IHRoaXMudHJhbnNsYXRlVG9HaXZlbk9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJywgb3JpZ2luWCwgb3JpZ2luWSk7XG4gICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICByZXR1cm4gZmFicmljLnV0aWwucm90YXRlUG9pbnQocCwgY2VudGVyLCBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZWFsIGNlbnRlciBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZWZ0VG9wID0gbmV3IGZhYnJpYy5Qb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKTtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQobGVmdFRvcCwgdGhpcy5vcmlnaW5YLCB0aGlzLm9yaWdpblkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGJhc2VkIG9uIGNlbnRlciBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIG9yaWdpblggYW5kIG9yaWdpblkgcGFyYW1zXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIC8vIGdldE9yaWdpblBvaW50OiBmdW5jdGlvbihjZW50ZXIpIHtcbiAgICAvLyAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoY2VudGVyLCB0aGlzLm9yaWdpblgsIHRoaXMub3JpZ2luWSk7XG4gICAgLy8gfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgYXMgaWYgaXQgaGFzIGEgZGlmZmVyZW50IG9yaWdpblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBnZXRQb2ludEJ5T3JpZ2luOiBmdW5jdGlvbihvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIG9yaWdpblgsIG9yaWdpblkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBpbiBsb2NhbCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGdsb2JhbCBjb29yZGluYXRlIHN5c3RlbVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICB0b0xvY2FsUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpLFxuICAgICAgICAgIHAsIHAyO1xuXG4gICAgICBpZiAodHlwZW9mIG9yaWdpblggIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcmlnaW5ZICE9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgcCA9IHRoaXMudHJhbnNsYXRlVG9HaXZlbk9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJywgb3JpZ2luWCwgb3JpZ2luWSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcCA9IG5ldyBmYWJyaWMuUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCk7XG4gICAgICB9XG5cbiAgICAgIHAyID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludC54LCBwb2ludC55KTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHAyID0gZmFicmljLnV0aWwucm90YXRlUG9pbnQocDIsIGNlbnRlciwgLWRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHAyLnN1YnRyYWN0RXF1YWxzKHApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBpbiBnbG9iYWwgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gVGhlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlIHN5c3RlbVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICAvLyB0b0dsb2JhbFBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuICAgIC8vICAgcmV0dXJuIGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHBvaW50LCB0aGlzLmdldENlbnRlclBvaW50KCksIGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpLmFkZEVxdWFscyhuZXcgZmFicmljLlBvaW50KHRoaXMubGVmdCwgdGhpcy50b3ApKTtcbiAgICAvLyB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIG9iamVjdCB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uIHRoZSBvYmplY3QncyBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9zIFRoZSBuZXcgcG9zaXRpb24gb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgc2V0UG9zaXRpb25CeU9yaWdpbjogZnVuY3Rpb24ocG9zLCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy50cmFuc2xhdGVUb0NlbnRlclBvaW50KHBvcywgb3JpZ2luWCwgb3JpZ2luWSksXG4gICAgICAgICAgcG9zaXRpb24gPSB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoY2VudGVyLCB0aGlzLm9yaWdpblgsIHRoaXMub3JpZ2luWSk7XG4gICAgICB0aGlzLnNldCgnbGVmdCcsIHBvc2l0aW9uLngpO1xuICAgICAgdGhpcy5zZXQoJ3RvcCcsIHBvc2l0aW9uLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG8gT25lIG9mICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCdcbiAgICAgKi9cbiAgICBhZGp1c3RQb3NpdGlvbjogZnVuY3Rpb24odG8pIHtcbiAgICAgIHZhciBhbmdsZSA9IGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSksXG4gICAgICAgICAgaHlwb3RGdWxsID0gdGhpcy5nZXRTY2FsZWRXaWR0aCgpLFxuICAgICAgICAgIHhGdWxsID0gZmFicmljLnV0aWwuY29zKGFuZ2xlKSAqIGh5cG90RnVsbCxcbiAgICAgICAgICB5RnVsbCA9IGZhYnJpYy51dGlsLnNpbihhbmdsZSkgKiBoeXBvdEZ1bGwsXG4gICAgICAgICAgb2Zmc2V0RnJvbSwgb2Zmc2V0VG87XG5cbiAgICAgIC8vVE9ETzogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjb25zaWRlciBtaXhlZCBzaXR1YXRpb24gbGlrZSB0b3AsIGNlbnRlci5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcmlnaW5YID09PSAnc3RyaW5nJykge1xuICAgICAgICBvZmZzZXRGcm9tID0gb3JpZ2luWE9mZnNldFt0aGlzLm9yaWdpblhdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9mZnNldEZyb20gPSB0aGlzLm9yaWdpblggLSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRvID09PSAnc3RyaW5nJykge1xuICAgICAgICBvZmZzZXRUbyA9IG9yaWdpblhPZmZzZXRbdG9dO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9mZnNldFRvID0gdG8gLSAwLjU7XG4gICAgICB9XG4gICAgICB0aGlzLmxlZnQgKz0geEZ1bGwgKiAob2Zmc2V0VG8gLSBvZmZzZXRGcm9tKTtcbiAgICAgIHRoaXMudG9wICs9IHlGdWxsICogKG9mZnNldFRvIC0gb2Zmc2V0RnJvbSk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5vcmlnaW5YID0gdG87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG9yaWdpbi9wb3NpdGlvbiBvZiB0aGUgb2JqZWN0IHRvIGl0J3MgY2VudGVyIHBvaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIF9zZXRPcmlnaW5Ub0NlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblggPSB0aGlzLm9yaWdpblg7XG4gICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblkgPSB0aGlzLm9yaWdpblk7XG5cbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCk7XG5cbiAgICAgIHRoaXMub3JpZ2luWCA9ICdjZW50ZXInO1xuICAgICAgdGhpcy5vcmlnaW5ZID0gJ2NlbnRlcic7XG5cbiAgICAgIHRoaXMubGVmdCA9IGNlbnRlci54O1xuICAgICAgdGhpcy50b3AgPSBjZW50ZXIueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBvcmlnaW4vcG9zaXRpb24gb2YgdGhlIG9iamVjdCB0byBpdCdzIG9yaWdpbmFsIG9yaWdpblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBfcmVzZXRPcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9yaWdpblBvaW50ID0gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KFxuICAgICAgICB0aGlzLmdldENlbnRlclBvaW50KCksXG4gICAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWCxcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5ZKTtcblxuICAgICAgdGhpcy5vcmlnaW5YID0gdGhpcy5fb3JpZ2luYWxPcmlnaW5YO1xuICAgICAgdGhpcy5vcmlnaW5ZID0gdGhpcy5fb3JpZ2luYWxPcmlnaW5ZO1xuXG4gICAgICB0aGlzLmxlZnQgPSBvcmlnaW5Qb2ludC54O1xuICAgICAgdGhpcy50b3AgPSBvcmlnaW5Qb2ludC55O1xuXG4gICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblggPSBudWxsO1xuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5ZID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGVmdFRvcENvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSwgJ2xlZnQnLCAndG9wJyk7XG4gICAgfSxcbiAgfSk7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIGFycmF5RnJvbUNvb3Jkcyhjb29yZHMpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IGZhYnJpYy5Qb2ludChjb29yZHMudGwueCwgY29vcmRzLnRsLnkpLFxuICAgICAgbmV3IGZhYnJpYy5Qb2ludChjb29yZHMudHIueCwgY29vcmRzLnRyLnkpLFxuICAgICAgbmV3IGZhYnJpYy5Qb2ludChjb29yZHMuYnIueCwgY29vcmRzLmJyLnkpLFxuICAgICAgbmV3IGZhYnJpYy5Qb2ludChjb29yZHMuYmwueCwgY29vcmRzLmJsLnkpXG4gICAgXTtcbiAgfVxuXG4gIHZhciB1dGlsID0gZmFicmljLnV0aWwsXG4gICAgICBkZWdyZWVzVG9SYWRpYW5zID0gdXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgbXVsdGlwbHlNYXRyaWNlcyA9IHV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyxcbiAgICAgIHRyYW5zZm9ybVBvaW50ID0gdXRpbC50cmFuc2Zvcm1Qb2ludDtcblxuICB1dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgb2JqZWN0J3MgY29ybmVyIHBvc2l0aW9uIGluIGNhbnZhcyBlbGVtZW50IGNvb3JkaW5hdGVzLlxuICAgICAqIHByb3BlcnRpZXMgYXJlIGRlcGVuZGluZyBvbiBjb250cm9sIGtleXMgYW5kIHBhZGRpbmcgdGhlIG1haW4gY29udHJvbHMuXG4gICAgICogZWFjaCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qgd2l0aCB4LCB5IGFuZCBjb3JuZXIuXG4gICAgICogVGhlIGBjb3JuZXJgIHByb3BlcnR5IGNvbnRhaW5zIGluIGEgc2ltaWxhciBtYW5uZXIgdGhlIDQgcG9pbnRzIG9mIHRoZVxuICAgICAqIGludGVyYWN0aXZlIGFyZWEgb2YgdGhlIGNvcm5lci5cbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgZGVwZW5kcyBmcm9tIHRoZSBjb250cm9scyBwb3NpdGlvbkhhbmRsZXIgYW5kIGFyZSB1c2VkXG4gICAgICogdG8gZHJhdyBhbmQgbG9jYXRlIGNvbnRyb2xzXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICovXG4gICAgb0Nvb3JkczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIG9iamVjdCdzIGNvcm5lciBwb3NpdGlvbiBpbiBjYW52YXMgb2JqZWN0IGFic29sdXRlIGNvb3JkaW5hdGVzXG4gICAgICogcHJvcGVydGllcyBhcmUgdGwsdHIsYmwsYnIgYW5kIGRlc2NyaWJlIHRoZSBmb3VyIG1haW4gY29ybmVyLlxuICAgICAqIGVhY2ggcHJvcGVydHkgaXMgYW4gb2JqZWN0IHdpdGggeCwgeSwgaW5zdGFuY2Ugb2YgRmFicmljLlBvaW50LlxuICAgICAqIFRoZSBjb29yZGluYXRlcyBkZXBlbmRzIGZyb20gdGhpcyBwcm9wZXJ0aWVzOiB3aWR0aCwgaGVpZ2h0LCBzY2FsZVgsIHNjYWxlWVxuICAgICAqIHNrZXdYLCBza2V3WSwgYW5nbGUsIHN0cm9rZVdpZHRoLCB0b3AsIGxlZnQuXG4gICAgICogVGhvc2UgY29vcmRpbmF0ZXMgYXJlIHVzZWZ1bCB0byB1bmRlcnN0YW5kIHdoZXJlIGFuIG9iamVjdCBpcy4gVGhleSBnZXQgdXBkYXRlZFxuICAgICAqIHdpdGggb0Nvb3JkcyBidXQgdGhleSBkbyBub3QgbmVlZCB0byBiZSB1cGRhdGVkIHdoZW4gem9vbSBvciBwYW5uaW5nIGNoYW5nZS5cbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgZ2V0IHVwZGF0ZWQgd2l0aCBAbWV0aG9kIHNldENvb3Jkcy5cbiAgICAgKiBZb3UgY2FuIGNhbGN1bGF0ZSB0aGVtIHdpdGhvdXQgdXBkYXRpbmcgd2l0aCBAbWV0aG9kIGNhbGNBQ29vcmRzKCk7XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICovXG4gICAgYUNvb3JkczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIG9iamVjdCdzIGNvcm5lciBwb3NpdGlvbiBpbiBjYW52YXMgZWxlbWVudCBjb29yZGluYXRlcy5cbiAgICAgKiBpbmNsdWRlcyBwYWRkaW5nLiBVc2VkIG9mIG9iamVjdCBkZXRlY3Rpb24uXG4gICAgICogc2V0IGFuZCByZWZyZXNoZWQgd2l0aCBzZXRDb29yZHMuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3QucHJvdG90eXBlXG4gICAgICovXG4gICAgbGluZUNvb3JkczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIHN0b3JhZ2UgZm9yIG9iamVjdCB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgb3duTWF0cml4Q2FjaGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBzdG9yYWdlIGZvciBvYmplY3QgZnVsbCB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgbWF0cml4Q2FjaGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBjdXN0b20gY29udHJvbHMgaW50ZXJmYWNlXG4gICAgICogY29udHJvbHMgYXJlIGFkZGVkIGJ5IGRlZmF1bHRfY29udHJvbHMuanNcbiAgICAgKi9cbiAgICBjb250cm9sczogeyB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGNvcnJlY3Qgc2V0IG9mIGNvb3JkaW5hdGVzIGZvciBpbnRlcnNlY3Rpb25cbiAgICAgKiB0aGlzIHdpbGwgcmV0dXJuIGVpdGhlciBhQ29vcmRzIG9yIGxpbmVDb29yZHMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhYnNvbHV0ZSB3aWxsIHJldHVybiBhQ29vcmRzIGlmIHRydWUgb3IgbGluZUNvb3Jkc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0ge3RsLCB0ciwgYnIsIGJsfSBwb2ludHNcbiAgICAgKi9cbiAgICBfZ2V0Q29vcmRzOiBmdW5jdGlvbihhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICBpZiAoY2FsY3VsYXRlKSB7XG4gICAgICAgIHJldHVybiAoYWJzb2x1dGUgPyB0aGlzLmNhbGNBQ29vcmRzKCkgOiB0aGlzLmNhbGNMaW5lQ29vcmRzKCkpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmFDb29yZHMgfHwgIXRoaXMubGluZUNvb3Jkcykge1xuICAgICAgICB0aGlzLnNldENvb3Jkcyh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoYWJzb2x1dGUgPyB0aGlzLmFDb29yZHMgOiB0aGlzLmxpbmVDb29yZHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gY29ycmVjdCBzZXQgb2YgY29vcmRpbmF0ZXMgZm9yIGludGVyc2VjdGlvblxuICAgICAqIHRoaXMgd2lsbCByZXR1cm4gZWl0aGVyIGFDb29yZHMgb3IgbGluZUNvb3Jkcy5cbiAgICAgKiBUaGUgY29vcmRzIGFyZSByZXR1cm5lZCBpbiBhbiBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gW3RsLCB0ciwgYnIsIGJsXSBvZiBwb2ludHNcbiAgICAgKi9cbiAgICBnZXRDb29yZHM6IGZ1bmN0aW9uKGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHJldHVybiBhcnJheUZyb21Db29yZHModGhpcy5fZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRUTCB0b3AtbGVmdCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50QlIgYm90dG9tLXJpZ2h0IHBvaW50IG9mIGFyZWFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzV2l0aFJlY3Q6IGZ1bmN0aW9uKHBvaW50VEwsIHBvaW50QlIsIGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLmdldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSxcbiAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25SZWN0YW5nbGUoXG4gICAgICAgICAgICBjb29yZHMsXG4gICAgICAgICAgICBwb2ludFRMLFxuICAgICAgICAgICAgcG9pbnRCUlxuICAgICAgICAgICk7XG4gICAgICByZXR1cm4gaW50ZXJzZWN0aW9uLnN0YXR1cyA9PT0gJ0ludGVyc2VjdGlvbic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIGFub3RoZXIgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIE9iamVjdCB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIGFub3RoZXIgb2JqZWN0XG4gICAgICovXG4gICAgaW50ZXJzZWN0c1dpdGhPYmplY3Q6IGZ1bmN0aW9uKG90aGVyLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgaW50ZXJzZWN0aW9uID0gZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUG9seWdvbihcbiAgICAgICAgdGhpcy5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSksXG4gICAgICAgIG90aGVyLmdldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGludGVyc2VjdGlvbi5zdGF0dXMgPT09ICdJbnRlcnNlY3Rpb24nXG4gICAgICAgIHx8IG90aGVyLmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KHRoaXMsIGFic29sdXRlLCBjYWxjdWxhdGUpXG4gICAgICAgIHx8IHRoaXMuaXNDb250YWluZWRXaXRoaW5PYmplY3Qob3RoZXIsIGFic29sdXRlLCBjYWxjdWxhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGlzIGZ1bGx5IGNvbnRhaW5lZCB3aXRoaW4gYXJlYSBvZiBhbm90aGVyIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBPYmplY3QgdG8gdGVzdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGlzIGZ1bGx5IGNvbnRhaW5lZCB3aXRoaW4gYXJlYSBvZiBhbm90aGVyIG9iamVjdFxuICAgICAqL1xuICAgIGlzQ29udGFpbmVkV2l0aGluT2JqZWN0OiBmdW5jdGlvbihvdGhlciwgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpLFxuICAgICAgICAgIG90aGVyQ29vcmRzID0gYWJzb2x1dGUgPyBvdGhlci5hQ29vcmRzIDogb3RoZXIubGluZUNvb3JkcyxcbiAgICAgICAgICBpID0gMCwgbGluZXMgPSBvdGhlci5fZ2V0SW1hZ2VMaW5lcyhvdGhlckNvb3Jkcyk7XG4gICAgICBmb3IgKDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBpZiAoIW90aGVyLmNvbnRhaW5zUG9pbnQocG9pbnRzW2ldLCBsaW5lcykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGlzIGZ1bGx5IGNvbnRhaW5lZCB3aXRoaW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRUTCB0b3AtbGVmdCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50QlIgYm90dG9tLXJpZ2h0IHBvaW50IG9mIGFyZWFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICovXG4gICAgaXNDb250YWluZWRXaXRoaW5SZWN0OiBmdW5jdGlvbihwb2ludFRMLCBwb2ludEJSLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgYm91bmRpbmdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoYWJzb2x1dGUsIGNhbGN1bGF0ZSk7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIGJvdW5kaW5nUmVjdC5sZWZ0ID49IHBvaW50VEwueCAmJlxuICAgICAgICBib3VuZGluZ1JlY3QubGVmdCArIGJvdW5kaW5nUmVjdC53aWR0aCA8PSBwb2ludEJSLnggJiZcbiAgICAgICAgYm91bmRpbmdSZWN0LnRvcCA+PSBwb2ludFRMLnkgJiZcbiAgICAgICAgYm91bmRpbmdSZWN0LnRvcCArIGJvdW5kaW5nUmVjdC5oZWlnaHQgPD0gcG9pbnRCUi55XG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgcG9pbnQgaXMgaW5zaWRlIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgUG9pbnQgdG8gY2hlY2sgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbbGluZXNdIG9iamVjdCByZXR1cm5lZCBmcm9tIEBtZXRob2QgX2dldEltYWdlTGluZXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24ocG9pbnQsIGxpbmVzLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5fZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpLFxuICAgICAgICAgIGxpbmVzID0gbGluZXMgfHwgdGhpcy5fZ2V0SW1hZ2VMaW5lcyhjb29yZHMpLFxuICAgICAgICAgIHhQb2ludHMgPSB0aGlzLl9maW5kQ3Jvc3NQb2ludHMocG9pbnQsIGxpbmVzKTtcbiAgICAgIC8vIGlmIHhQb2ludHMgaXMgb2RkIHRoZW4gcG9pbnQgaXMgaW5zaWRlIHRoZSBvYmplY3RcbiAgICAgIHJldHVybiAoeFBvaW50cyAhPT0gMCAmJiB4UG9pbnRzICUgMiA9PT0gMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgY29udGFpbmVkIHdpdGhpbiB0aGUgY2FudmFzIHdpdGggY3VycmVudCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIHRoZSBjaGVjayBpcyBkb25lIHN0b3BwaW5nIGF0IGZpcnN0IHBvaW50IHRoYXQgYXBwZWFycyBvbiBzY3JlZW5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLmFDb29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBmdWxseSBvciBwYXJ0aWFsbHkgY29udGFpbmVkIHdpdGhpbiBjYW52YXNcbiAgICAgKi9cbiAgICBpc09uU2NyZWVuOiBmdW5jdGlvbihjYWxjdWxhdGUpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBvaW50VEwgPSB0aGlzLmNhbnZhcy52cHRDb29yZHMudGwsIHBvaW50QlIgPSB0aGlzLmNhbnZhcy52cHRDb29yZHMuYnI7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRDb29yZHModHJ1ZSwgY2FsY3VsYXRlKTtcbiAgICAgIC8vIGlmIHNvbWUgcG9pbnQgaXMgb24gc2NyZWVuLCB0aGUgb2JqZWN0IGlzIG9uIHNjcmVlbi5cbiAgICAgIGlmIChwb2ludHMuc29tZShmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gcG9pbnQueCA8PSBwb2ludEJSLnggJiYgcG9pbnQueCA+PSBwb2ludFRMLnggJiZcbiAgICAgICAgcG9pbnQueSA8PSBwb2ludEJSLnkgJiYgcG9pbnQueSA+PSBwb2ludFRMLnk7XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIG5vIHBvaW50cyBvbiBzY3JlZW4sIGNoZWNrIGludGVyc2VjdGlvbiB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzXG4gICAgICBpZiAodGhpcy5pbnRlcnNlY3RzV2l0aFJlY3QocG9pbnRUTCwgcG9pbnRCUiwgdHJ1ZSwgY2FsY3VsYXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jb250YWluc0NlbnRlck9mQ2FudmFzKHBvaW50VEwsIHBvaW50QlIsIGNhbGN1bGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBtaWRwb2ludCBiZXR3ZWVuIGNhbnZhcyBleHRyZW1pdGllc1xuICAgICAqIERvZXMgbm90IG1ha2Ugc2Vuc2Ugb3V0c2lkZSB0aGUgY29udGV4dCBvZiBpc09uU2NyZWVuIGFuZCBpc1BhcnRpYWxseU9uU2NyZWVuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5Qb2ludH0gcG9pbnRUTCBUb3AgTGVmdCBwb2ludFxuICAgICAqIEBwYXJhbSB7RmFicmljLlBvaW50fSBwb2ludEJSIFRvcCBSaWdodCBwb2ludFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FsY3VsYXRlIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBvYmplY3QgY29udGFpbnMgdGhlIHBvaW50XG4gICAgICovXG4gICAgX2NvbnRhaW5zQ2VudGVyT2ZDYW52YXM6IGZ1bmN0aW9uKHBvaW50VEwsIHBvaW50QlIsIGNhbGN1bGF0ZSkge1xuICAgICAgLy8gd29yc3QgY2FzZSBzY2VuYXJpbyB0aGUgb2JqZWN0IGlzIHNvIGJpZyB0aGF0IGNvbnRhaW5zIHRoZSBzY3JlZW5cbiAgICAgIHZhciBjZW50ZXJQb2ludCA9IHsgeDogKHBvaW50VEwueCArIHBvaW50QlIueCkgLyAyLCB5OiAocG9pbnRUTC55ICsgcG9pbnRCUi55KSAvIDIgfTtcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9pbnQoY2VudGVyUG9pbnQsIG51bGwsIHRydWUsIGNhbGN1bGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgcGFydGlhbGx5IGNvbnRhaW5lZCB3aXRoaW4gdGhlIGNhbnZhcyB3aXRoIGN1cnJlbnQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBwYXJ0aWFsbHkgY29udGFpbmVkIHdpdGhpbiBjYW52YXNcbiAgICAgKi9cbiAgICBpc1BhcnRpYWxseU9uU2NyZWVuOiBmdW5jdGlvbihjYWxjdWxhdGUpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHBvaW50VEwgPSB0aGlzLmNhbnZhcy52cHRDb29yZHMudGwsIHBvaW50QlIgPSB0aGlzLmNhbnZhcy52cHRDb29yZHMuYnI7XG4gICAgICBpZiAodGhpcy5pbnRlcnNlY3RzV2l0aFJlY3QocG9pbnRUTCwgcG9pbnRCUiwgdHJ1ZSwgY2FsY3VsYXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBhbGxQb2ludHNBcmVPdXRzaWRlID0gdGhpcy5nZXRDb29yZHModHJ1ZSwgY2FsY3VsYXRlKS5ldmVyeShmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gKHBvaW50LnggPj0gcG9pbnRCUi54IHx8IHBvaW50LnggPD0gcG9pbnRUTC54KSAmJlxuICAgICAgICAocG9pbnQueSA+PSBwb2ludEJSLnkgfHwgcG9pbnQueSA8PSBwb2ludFRMLnkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWxsUG9pbnRzQXJlT3V0c2lkZSAmJiB0aGlzLl9jb250YWluc0NlbnRlck9mQ2FudmFzKHBvaW50VEwsIHBvaW50QlIsIGNhbGN1bGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIG9iamVjdCBlZGdlcyBpbiBpdCwgZ2l2ZW4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb0Nvb3JkcyBDb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGNvcm5lcnNcbiAgICAgKi9cbiAgICBfZ2V0SW1hZ2VMaW5lczogZnVuY3Rpb24ob0Nvb3Jkcykge1xuXG4gICAgICB2YXIgbGluZXMgPSB7XG4gICAgICAgIHRvcGxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLnRsLFxuICAgICAgICAgIGQ6IG9Db29yZHMudHJcbiAgICAgICAgfSxcbiAgICAgICAgcmlnaHRsaW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy50cixcbiAgICAgICAgICBkOiBvQ29vcmRzLmJyXG4gICAgICAgIH0sXG4gICAgICAgIGJvdHRvbWxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLmJyLFxuICAgICAgICAgIGQ6IG9Db29yZHMuYmxcbiAgICAgICAgfSxcbiAgICAgICAgbGVmdGxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLmJsLFxuICAgICAgICAgIGQ6IG9Db29yZHMudGxcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gLy8gZGVidWdnaW5nXG4gICAgICAvLyBpZiAodGhpcy5jYW52YXMuY29udGV4dFRvcCkge1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmJvdHRvbWxpbmUuZC54LCBsaW5lcy5ib3R0b21saW5lLmQueSwgMiwgMik7XG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMuYm90dG9tbGluZS5vLngsIGxpbmVzLmJvdHRvbWxpbmUuby55LCAyLCAyKTtcbiAgICAgIC8vXG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMubGVmdGxpbmUuZC54LCBsaW5lcy5sZWZ0bGluZS5kLnksIDIsIDIpO1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmxlZnRsaW5lLm8ueCwgbGluZXMubGVmdGxpbmUuby55LCAyLCAyKTtcbiAgICAgIC8vXG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMudG9wbGluZS5kLngsIGxpbmVzLnRvcGxpbmUuZC55LCAyLCAyKTtcbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy50b3BsaW5lLm8ueCwgbGluZXMudG9wbGluZS5vLnksIDIsIDIpO1xuICAgICAgLy9cbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5yaWdodGxpbmUuZC54LCBsaW5lcy5yaWdodGxpbmUuZC55LCAyLCAyKTtcbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5yaWdodGxpbmUuby54LCBsaW5lcy5yaWdodGxpbmUuby55LCAyLCAyKTtcbiAgICAgIC8vIH1cblxuICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGRldGVybWluZSBob3cgbWFueSBjcm9zcyBwb2ludHMgYXJlIGJldHdlZW4gdGhlIDQgb2JqZWN0IGVkZ2VzXG4gICAgICogYW5kIHRoZSBob3Jpem9udGFsIGxpbmUgZGV0ZXJtaW5lZCBieSBhIHBvaW50IG9uIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFBvaW50IHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxpbmVzIENvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgYmVpbmcgZXZhbHVhdGVkXG4gICAgICovXG4gICAgLy8gcmVtb3ZlIHlpLCBub3QgdXNlZCBidXQgbGVmdCBjb2RlIGhlcmUganVzdCBpbiBjYXNlLlxuICAgIF9maW5kQ3Jvc3NQb2ludHM6IGZ1bmN0aW9uKHBvaW50LCBsaW5lcykge1xuICAgICAgdmFyIGIxLCBiMiwgYTEsIGEyLCB4aSwgLy8geWksXG4gICAgICAgICAgeGNvdW50ID0gMCxcbiAgICAgICAgICBpTGluZTtcblxuICAgICAgZm9yICh2YXIgbGluZUtleSBpbiBsaW5lcykge1xuICAgICAgICBpTGluZSA9IGxpbmVzW2xpbmVLZXldO1xuICAgICAgICAvLyBvcHRpbWlzYXRpb24gMTogbGluZSBiZWxvdyBwb2ludC4gbm8gY3Jvc3NcbiAgICAgICAgaWYgKChpTGluZS5vLnkgPCBwb2ludC55KSAmJiAoaUxpbmUuZC55IDwgcG9pbnQueSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpbWlzYXRpb24gMjogbGluZSBhYm92ZSBwb2ludC4gbm8gY3Jvc3NcbiAgICAgICAgaWYgKChpTGluZS5vLnkgPj0gcG9pbnQueSkgJiYgKGlMaW5lLmQueSA+PSBwb2ludC55KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbiAzOiB2ZXJ0aWNhbCBsaW5lIGNhc2VcbiAgICAgICAgaWYgKChpTGluZS5vLnggPT09IGlMaW5lLmQueCkgJiYgKGlMaW5lLm8ueCA+PSBwb2ludC54KSkge1xuICAgICAgICAgIHhpID0gaUxpbmUuby54O1xuICAgICAgICAgIC8vIHlpID0gcG9pbnQueTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGludGVyc2VjdGlvbiBwb2ludFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBiMSA9IDA7XG4gICAgICAgICAgYjIgPSAoaUxpbmUuZC55IC0gaUxpbmUuby55KSAvIChpTGluZS5kLnggLSBpTGluZS5vLngpO1xuICAgICAgICAgIGExID0gcG9pbnQueSAtIGIxICogcG9pbnQueDtcbiAgICAgICAgICBhMiA9IGlMaW5lLm8ueSAtIGIyICogaUxpbmUuby54O1xuXG4gICAgICAgICAgeGkgPSAtKGExIC0gYTIpIC8gKGIxIC0gYjIpO1xuICAgICAgICAgIC8vIHlpID0gYTEgKyBiMSAqIHhpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbnQgY291bnQgeGkgPCBwb2ludC54IGNhc2VzXG4gICAgICAgIGlmICh4aSA+PSBwb2ludC54KSB7XG4gICAgICAgICAgeGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDQ6IHNwZWNpZmljIGZvciBzcXVhcmUgaW1hZ2VzXG4gICAgICAgIGlmICh4Y291bnQgPT09IDIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHhjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBvYmplY3QncyBib3VuZGluZyByZWN0YW5nbGUgKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodClcbiAgICAgKiB0aGUgYm94IGlzIGludGVuZGVkIGFzIGFsaWduZWQgdG8gYXhpcyBvZiBjYW52YXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzIC8gLmFDb29yZHNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbihhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSk7XG4gICAgICByZXR1cm4gdXRpbC5tYWtlQm91bmRpbmdCb3hGcm9tUG9pbnRzKGNvb3Jkcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2lkdGggb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94IGNvdW50aW5nIHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIGJlZm9yZSAyLjAgaXQgd2FzIG5hbWVkIGdldFdpZHRoKCk7XG4gICAgICogQHJldHVybiB7TnVtYmVyfSB3aWR0aCB2YWx1ZVxuICAgICAqL1xuICAgIGdldFNjYWxlZFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKS54O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhlaWdodCBvZiBhbiBvYmplY3QgYm91bmRpbmcgYm94IGNvdW50aW5nIHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIGJlZm9yZSAyLjAgaXQgd2FzIG5hbWVkIGdldEhlaWdodCgpO1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gaGVpZ2h0IHZhbHVlXG4gICAgICovXG4gICAgZ2V0U2NhbGVkSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKS55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBzdXJlIHRoZSBzY2FsZSBpcyB2YWxpZCBhbmQgbW9kaWZpZXMgaXQgaWYgbmVjZXNzYXJ5XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgX2NvbnN0cmFpblNjYWxlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKE1hdGguYWJzKHZhbHVlKSA8IHRoaXMubWluU2NhbGVMaW1pdCkge1xuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIC10aGlzLm1pblNjYWxlTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWluU2NhbGVMaW1pdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDAuMDAwMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFuIG9iamVjdCAoZXF1YWxseSBieSB4IGFuZCB5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBTY2FsZSBmYWN0b3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0KCdzY2FsZVgnLCB2YWx1ZSk7XG4gICAgICB0aGlzLl9zZXQoJ3NjYWxlWScsIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzLnNldENvb3JkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgYW4gb2JqZWN0IHRvIGEgZ2l2ZW4gd2lkdGgsIHdpdGggcmVzcGVjdCB0byBib3VuZGluZyBib3ggKHNjYWxpbmcgYnkgeC95IGVxdWFsbHkpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIE5ldyB3aWR0aCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWJzb2x1dGUgaWdub3JlIHZpZXdwb3J0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsZVRvV2lkdGg6IGZ1bmN0aW9uKHZhbHVlLCBhYnNvbHV0ZSkge1xuICAgICAgLy8gYWRqdXN0IHRvIGJvdW5kaW5nIHJlY3QgZmFjdG9yIHNvIHRoYXQgcm90YXRlZCBzaGFwZXMgd291bGQgZml0IGFzIHdlbGxcbiAgICAgIHZhciBib3VuZGluZ1JlY3RGYWN0b3IgPSB0aGlzLmdldEJvdW5kaW5nUmVjdChhYnNvbHV0ZSkud2lkdGggLyB0aGlzLmdldFNjYWxlZFdpZHRoKCk7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSAvIHRoaXMud2lkdGggLyBib3VuZGluZ1JlY3RGYWN0b3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgYW4gb2JqZWN0IHRvIGEgZ2l2ZW4gaGVpZ2h0LCB3aXRoIHJlc3BlY3QgdG8gYm91bmRpbmcgYm94IChzY2FsaW5nIGJ5IHgveSBlcXVhbGx5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBOZXcgaGVpZ2h0IHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhYnNvbHV0ZSBpZ25vcmUgdmlld3BvcnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxlVG9IZWlnaHQ6IGZ1bmN0aW9uKHZhbHVlLCBhYnNvbHV0ZSkge1xuICAgICAgLy8gYWRqdXN0IHRvIGJvdW5kaW5nIHJlY3QgZmFjdG9yIHNvIHRoYXQgcm90YXRlZCBzaGFwZXMgd291bGQgZml0IGFzIHdlbGxcbiAgICAgIHZhciBib3VuZGluZ1JlY3RGYWN0b3IgPSB0aGlzLmdldEJvdW5kaW5nUmVjdChhYnNvbHV0ZSkuaGVpZ2h0IC8gdGhpcy5nZXRTY2FsZWRIZWlnaHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlKHZhbHVlIC8gdGhpcy5oZWlnaHQgLyBib3VuZGluZ1JlY3RGYWN0b3IpO1xuICAgIH0sXG5cbiAgICBjYWxjTGluZUNvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdnB0ID0gdGhpcy5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpLFxuICAgICAgICAgIHBhZGRpbmcgPSB0aGlzLnBhZGRpbmcsIGFuZ2xlID0gZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSxcbiAgICAgICAgICBjb3MgPSB1dGlsLmNvcyhhbmdsZSksIHNpbiA9IHV0aWwuc2luKGFuZ2xlKSxcbiAgICAgICAgICBjb3NQID0gY29zICogcGFkZGluZywgc2luUCA9IHNpbiAqIHBhZGRpbmcsIGNvc1BTaW5QID0gY29zUCArIHNpblAsXG4gICAgICAgICAgY29zUE1pbnVzU2luUCA9IGNvc1AgLSBzaW5QLCBhQ29vcmRzID0gdGhpcy5jYWxjQUNvb3JkcygpO1xuXG4gICAgICB2YXIgbGluZUNvb3JkcyA9IHtcbiAgICAgICAgdGw6IHRyYW5zZm9ybVBvaW50KGFDb29yZHMudGwsIHZwdCksXG4gICAgICAgIHRyOiB0cmFuc2Zvcm1Qb2ludChhQ29vcmRzLnRyLCB2cHQpLFxuICAgICAgICBibDogdHJhbnNmb3JtUG9pbnQoYUNvb3Jkcy5ibCwgdnB0KSxcbiAgICAgICAgYnI6IHRyYW5zZm9ybVBvaW50KGFDb29yZHMuYnIsIHZwdCksXG4gICAgICB9O1xuXG4gICAgICBpZiAocGFkZGluZykge1xuICAgICAgICBsaW5lQ29vcmRzLnRsLnggLT0gY29zUE1pbnVzU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy50bC55IC09IGNvc1BTaW5QO1xuICAgICAgICBsaW5lQ29vcmRzLnRyLnggKz0gY29zUFNpblA7XG4gICAgICAgIGxpbmVDb29yZHMudHIueSAtPSBjb3NQTWludXNTaW5QO1xuICAgICAgICBsaW5lQ29vcmRzLmJsLnggLT0gY29zUFNpblA7XG4gICAgICAgIGxpbmVDb29yZHMuYmwueSArPSBjb3NQTWludXNTaW5QO1xuICAgICAgICBsaW5lQ29vcmRzLmJyLnggKz0gY29zUE1pbnVzU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy5ici55ICs9IGNvc1BTaW5QO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGluZUNvb3JkcztcbiAgICB9LFxuXG4gICAgY2FsY09Db29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJvdGF0ZU1hdHJpeCA9IHRoaXMuX2NhbGNSb3RhdGVNYXRyaXgoKSxcbiAgICAgICAgICB0cmFuc2xhdGVNYXRyaXggPSB0aGlzLl9jYWxjVHJhbnNsYXRlTWF0cml4KCksXG4gICAgICAgICAgdnB0ID0gdGhpcy5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpLFxuICAgICAgICAgIHN0YXJ0TWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyh2cHQsIHRyYW5zbGF0ZU1hdHJpeCksXG4gICAgICAgICAgZmluYWxNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHN0YXJ0TWF0cml4LCByb3RhdGVNYXRyaXgpLFxuICAgICAgICAgIGZpbmFsTWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyhmaW5hbE1hdHJpeCwgWzEgLyB2cHRbMF0sIDAsIDAsIDEgLyB2cHRbM10sIDAsIDBdKSxcbiAgICAgICAgICBkaW0gPSB0aGlzLl9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9ucygpLFxuICAgICAgICAgIGNvb3JkcyA9IHt9O1xuICAgICAgdGhpcy5mb3JFYWNoQ29udHJvbChmdW5jdGlvbihjb250cm9sLCBrZXksIGZhYnJpY09iamVjdCkge1xuICAgICAgICBjb29yZHNba2V5XSA9IGNvbnRyb2wucG9zaXRpb25IYW5kbGVyKGRpbSwgZmluYWxNYXRyaXgsIGZhYnJpY09iamVjdCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gZGVidWcgY29kZVxuICAgICAgLy8gdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgLy8gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgY2FudmFzLmNvbnRleHRUb3AuY2xlYXJSZWN0KDAsIDAsIDcwMCwgNzAwKTtcbiAgICAgIC8vICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFN0eWxlID0gJ2dyZWVuJztcbiAgICAgIC8vICAgT2JqZWN0LmtleXMoY29vcmRzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgLy8gICAgIHZhciBjb250cm9sID0gY29vcmRzW2tleV07XG4gICAgICAvLyAgICAgY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QoY29udHJvbC54LCBjb250cm9sLnksIDMsIDMpO1xuICAgICAgLy8gICB9KTtcbiAgICAgIC8vIH0sIDUwKTtcbiAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfSxcblxuICAgIGNhbGNBQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByb3RhdGVNYXRyaXggPSB0aGlzLl9jYWxjUm90YXRlTWF0cml4KCksXG4gICAgICAgICAgdHJhbnNsYXRlTWF0cml4ID0gdGhpcy5fY2FsY1RyYW5zbGF0ZU1hdHJpeCgpLFxuICAgICAgICAgIGZpbmFsTWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyh0cmFuc2xhdGVNYXRyaXgsIHJvdGF0ZU1hdHJpeCksXG4gICAgICAgICAgZGltID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCksXG4gICAgICAgICAgdyA9IGRpbS54IC8gMiwgaCA9IGRpbS55IC8gMjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIGNvcm5lcnNcbiAgICAgICAgdGw6IHRyYW5zZm9ybVBvaW50KHsgeDogLXcsIHk6IC1oIH0sIGZpbmFsTWF0cml4KSxcbiAgICAgICAgdHI6IHRyYW5zZm9ybVBvaW50KHsgeDogdywgeTogLWggfSwgZmluYWxNYXRyaXgpLFxuICAgICAgICBibDogdHJhbnNmb3JtUG9pbnQoeyB4OiAtdywgeTogaCB9LCBmaW5hbE1hdHJpeCksXG4gICAgICAgIGJyOiB0cmFuc2Zvcm1Qb2ludCh7IHg6IHcsIHk6IGggfSwgZmluYWxNYXRyaXgpXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGNvcm5lciBhbmQgY29udHJvbHMgcG9zaXRpb24gY29vcmRpbmF0ZXMgYmFzZWQgb24gY3VycmVudCBhbmdsZSwgd2lkdGggYW5kIGhlaWdodCwgbGVmdCBhbmQgdG9wLlxuICAgICAqIG9Db29yZHMgYXJlIHVzZWQgdG8gZmluZCB0aGUgY29ybmVyc1xuICAgICAqIGFDb29yZHMgYXJlIHVzZWQgdG8gcXVpY2tseSBmaW5kIGFuIG9iamVjdCBvbiB0aGUgY2FudmFzXG4gICAgICogbGluZUNvb3JkcyBhcmUgdXNlZCB0byBxdWlja2x5IGZpbmQgb2JqZWN0IGR1cmluZyBwb2ludGVyIGV2ZW50cy5cbiAgICAgKiBTZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWJyaWNqcy9mYWJyaWMuanMvd2lraS9XaGVuLXRvLWNhbGwtc2V0Q29vcmRzfSBhbmQge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWdvdGNoYXN9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwQ29ybmVyc10gc2tpcCBjYWxjdWxhdGlvbiBvZiBvQ29vcmRzLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0Q29vcmRzOiBmdW5jdGlvbihza2lwQ29ybmVycykge1xuICAgICAgdGhpcy5hQ29vcmRzID0gdGhpcy5jYWxjQUNvb3JkcygpO1xuICAgICAgLy8gaW4gY2FzZSB3ZSBhcmUgaW4gYSBncm91cCwgZm9yIGhvdyB0aGUgaW5uZXIgZ3JvdXAgdGFyZ2V0IGNoZWNrIHdvcmtzLFxuICAgICAgLy8gbGluZUNvb3JkcyBhcmUgZXhhY3RseSBhQ29vcmRzLiBTaW5jZSB0aGUgdnB0IGdldHMgYWJzb3JiZWQgYnkgdGhlIG5vcm1hbGl6ZWQgcG9pbnRlci5cbiAgICAgIHRoaXMubGluZUNvb3JkcyA9IHRoaXMuZ3JvdXAgPyB0aGlzLmFDb29yZHMgOiB0aGlzLmNhbGNMaW5lQ29vcmRzKCk7XG4gICAgICBpZiAoc2tpcENvcm5lcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICAvLyBzZXQgY29vcmRpbmF0ZXMgb2YgdGhlIGRyYWdnYWJsZSBib3hlcyBpbiB0aGUgY29ybmVycyB1c2VkIHRvIHNjYWxlL3JvdGF0ZSB0aGUgaW1hZ2VcbiAgICAgIHRoaXMub0Nvb3JkcyA9IHRoaXMuY2FsY09Db29yZHMoKTtcbiAgICAgIHRoaXMuX3NldENvcm5lckNvb3JkcyAmJiB0aGlzLl9zZXRDb3JuZXJDb29yZHMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgcm90YXRpb24gbWF0cml4IG9mIGFuIG9iamVjdFxuICAgICAqIEByZXR1cm4ge0FycmF5fSByb3RhdGlvbiBtYXRyaXggZm9yIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBfY2FsY1JvdGF0ZU1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdXRpbC5jYWxjUm90YXRlTWF0cml4KHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdGhlIHRyYW5zbGF0aW9uIG1hdHJpeCBmb3IgYW4gb2JqZWN0IHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm4ge0FycmF5fSByb3RhdGlvbiBtYXRyaXggZm9yIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBfY2FsY1RyYW5zbGF0ZU1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgcmV0dXJuIFsxLCAwLCAwLCAxLCBjZW50ZXIueCwgY2VudGVyLnldO1xuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm1NYXRyaXhLZXk6IGZ1bmN0aW9uKHNraXBHcm91cCkge1xuICAgICAgdmFyIHNlcCA9ICdfJywgcHJlZml4ID0gJyc7XG4gICAgICBpZiAoIXNraXBHcm91cCAmJiB0aGlzLmdyb3VwKSB7XG4gICAgICAgIHByZWZpeCA9IHRoaXMuZ3JvdXAudHJhbnNmb3JtTWF0cml4S2V5KHNraXBHcm91cCkgKyBzZXA7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHByZWZpeCArIHRoaXMudG9wICsgc2VwICsgdGhpcy5sZWZ0ICsgc2VwICsgdGhpcy5zY2FsZVggKyBzZXAgKyB0aGlzLnNjYWxlWSArXG4gICAgICAgIHNlcCArIHRoaXMuc2tld1ggKyBzZXAgKyB0aGlzLnNrZXdZICsgc2VwICsgdGhpcy5hbmdsZSArIHNlcCArIHRoaXMub3JpZ2luWCArIHNlcCArIHRoaXMub3JpZ2luWSArXG4gICAgICAgIHNlcCArIHRoaXMud2lkdGggKyBzZXAgKyB0aGlzLmhlaWdodCArIHNlcCArIHRoaXMuc3Ryb2tlV2lkdGggKyB0aGlzLmZsaXBYICsgdGhpcy5mbGlwWTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRyYW5zZm9ybSBtYXRyaXggdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9ucyBmcm9tIHRoZVxuICAgICAqIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcEdyb3VwXSByZXR1cm4gdHJhbnNmb3JtIG1hdHJpeCBmb3Igb2JqZWN0IG5vdCBjb3VudGluZyBwYXJlbnQgdHJhbnNmb3JtYXRpb25zXG4gICAgICogVGhlcmUgYXJlIHNvbWUgc2l0dWF0aW9uIGluIHdoaWNoIHRoaXMgaXMgdXNlZnVsIHRvIGF2b2lkIHRoZSBmYWtlIHJvdGF0aW9uLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSB0cmFuc2Zvcm0gbWF0cml4IGZvciB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY2FsY1RyYW5zZm9ybU1hdHJpeDogZnVuY3Rpb24oc2tpcEdyb3VwKSB7XG4gICAgICB2YXIgbWF0cml4ID0gdGhpcy5jYWxjT3duTWF0cml4KCk7XG4gICAgICBpZiAoc2tpcEdyb3VwIHx8ICF0aGlzLmdyb3VwKSB7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdGhpcy50cmFuc2Zvcm1NYXRyaXhLZXkoc2tpcEdyb3VwKSwgY2FjaGUgPSB0aGlzLm1hdHJpeENhY2hlIHx8ICh0aGlzLm1hdHJpeENhY2hlID0ge30pO1xuICAgICAgaWYgKGNhY2hlLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiBjYWNoZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIG1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXModGhpcy5ncm91cC5jYWxjVHJhbnNmb3JtTWF0cml4KGZhbHNlKSwgbWF0cml4KTtcbiAgICAgIH1cbiAgICAgIGNhY2hlLmtleSA9IGtleTtcbiAgICAgIGNhY2hlLnZhbHVlID0gbWF0cml4O1xuICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRyYW5zZm9ybSBtYXRyaXggdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9ucyBmcm9tIHRoZVxuICAgICAqIG9iamVjdCdzIHByb3BlcnRpZXMsIHRoaXMgbWF0cml4IGRvZXMgbm90IGluY2x1ZGUgdGhlIGdyb3VwIHRyYW5zZm9ybWF0aW9uXG4gICAgICogQHJldHVybiB7QXJyYXl9IHRyYW5zZm9ybSBtYXRyaXggZm9yIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBjYWxjT3duTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLnRyYW5zZm9ybU1hdHJpeEtleSh0cnVlKSwgY2FjaGUgPSB0aGlzLm93bk1hdHJpeENhY2hlIHx8ICh0aGlzLm93bk1hdHJpeENhY2hlID0ge30pO1xuICAgICAgaWYgKGNhY2hlLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiBjYWNoZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciB0TWF0cml4ID0gdGhpcy5fY2FsY1RyYW5zbGF0ZU1hdHJpeCgpLFxuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhbmdsZTogdGhpcy5hbmdsZSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6IHRNYXRyaXhbNF0sXG4gICAgICAgICAgICB0cmFuc2xhdGVZOiB0TWF0cml4WzVdLFxuICAgICAgICAgICAgc2NhbGVYOiB0aGlzLnNjYWxlWCxcbiAgICAgICAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVksXG4gICAgICAgICAgICBza2V3WDogdGhpcy5za2V3WCxcbiAgICAgICAgICAgIHNrZXdZOiB0aGlzLnNrZXdZLFxuICAgICAgICAgICAgZmxpcFg6IHRoaXMuZmxpcFgsXG4gICAgICAgICAgICBmbGlwWTogdGhpcy5mbGlwWSxcbiAgICAgICAgICB9O1xuICAgICAgY2FjaGUua2V5ID0ga2V5O1xuICAgICAgY2FjaGUudmFsdWUgPSB1dGlsLmNvbXBvc2VNYXRyaXgob3B0aW9ucyk7XG4gICAgICByZXR1cm4gY2FjaGUudmFsdWU7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQ2FsY3VsYXRlIG9iamVjdCBkaW1lbnNpb25zIGZyb20gaXRzIHByb3BlcnRpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnggd2lkdGggZGltZW5zaW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueSBoZWlnaHQgZGltZW5zaW9uXG4gICAgICovXG4gICAgX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIHcgPSB0aGlzLndpZHRoICsgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0ICsgc3Ryb2tlV2lkdGg7XG4gICAgICByZXR1cm4geyB4OiB3LCB5OiBoIH07XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQ2FsY3VsYXRlIG9iamVjdCBib3VuZGluZyBib3ggZGltZW5zaW9ucyBmcm9tIGl0cyBwcm9wZXJ0aWVzIHNjYWxlLCBza2V3LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WCwgYSB2YWx1ZSB0byBvdmVycmlkZSBjdXJyZW50IHNrZXdYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdZLCBhIHZhbHVlIHRvIG92ZXJyaWRlIGN1cnJlbnQgc2tld1lcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnggd2lkdGggZGltZW5zaW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueSBoZWlnaHQgZGltZW5zaW9uXG4gICAgICovXG4gICAgX2dldFRyYW5zZm9ybWVkRGltZW5zaW9uczogZnVuY3Rpb24oc2tld1gsIHNrZXdZKSB7XG4gICAgICBpZiAodHlwZW9mIHNrZXdYID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBza2V3WCA9IHRoaXMuc2tld1g7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNrZXdZID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBza2V3WSA9IHRoaXMuc2tld1k7XG4gICAgICB9XG4gICAgICB2YXIgZGltZW5zaW9ucywgZGltWCwgZGltWSxcbiAgICAgICAgICBub1NrZXcgPSBza2V3WCA9PT0gMCAmJiBza2V3WSA9PT0gMDtcblxuICAgICAgaWYgKHRoaXMuc3Ryb2tlVW5pZm9ybSkge1xuICAgICAgICBkaW1YID0gdGhpcy53aWR0aDtcbiAgICAgICAgZGltWSA9IHRoaXMuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRpbWVuc2lvbnMgPSB0aGlzLl9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcbiAgICAgICAgZGltWCA9IGRpbWVuc2lvbnMueDtcbiAgICAgICAgZGltWSA9IGRpbWVuc2lvbnMueTtcbiAgICAgIH1cbiAgICAgIGlmIChub1NrZXcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplRGltZW5zaW9ucyhkaW1YICogdGhpcy5zY2FsZVgsIGRpbVkgKiB0aGlzLnNjYWxlWSk7XG4gICAgICB9XG4gICAgICB2YXIgYmJveCA9IHV0aWwuc2l6ZUFmdGVyVHJhbnNmb3JtKGRpbVgsIGRpbVksIHtcbiAgICAgICAgc2NhbGVYOiB0aGlzLnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0aGlzLnNjYWxlWSxcbiAgICAgICAgc2tld1g6IHNrZXdYLFxuICAgICAgICBza2V3WTogc2tld1ksXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZURpbWVuc2lvbnMoYmJveC54LCBiYm94LnkpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgYm91bmRpbmcgYm94IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllcyBzY2FsZSwgc2tldy5cbiAgICAgKiBAcGFyYW0gTnVtYmVyIHdpZHRoIHdpZHRoIG9mIHRoZSBiYm94XG4gICAgICogQHBhcmFtIE51bWJlciBoZWlnaHQgaGVpZ2h0IG9mIHRoZSBiYm94XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC54IGZpbmFsaXplZCB3aWR0aCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC55IGZpbmFsaXplZCBoZWlnaHQgZGltZW5zaW9uXG4gICAgICovXG4gICAgX2ZpbmFsaXplRGltZW5zaW9uczogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3Ryb2tlVW5pZm9ybSA/XG4gICAgICAgIHsgeDogd2lkdGggKyB0aGlzLnN0cm9rZVdpZHRoLCB5OiBoZWlnaHQgKyB0aGlzLnN0cm9rZVdpZHRoIH1cbiAgICAgICAgOlxuICAgICAgICB7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZm9yIGNvbnRyb2xzIGJveCwgaW5jbHVkaW5nIHBhZGRpbmcgYW5kIGNhbnZhcyB6b29tLlxuICAgICAqIGFuZCBhY3RpdmUgc2VsZWN0aW9uXG4gICAgICogcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9uczogZnVuY3Rpb24oKSAge1xuICAgICAgdmFyIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBkaW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSxcbiAgICAgICAgICBwID0gdHJhbnNmb3JtUG9pbnQoZGltLCB2cHQsIHRydWUpO1xuICAgICAgcmV0dXJuIHAuc2NhbGFyQWRkKDIgKiB0aGlzLnBhZGRpbmcpO1xuICAgIH0sXG4gIH0pO1xufSkoKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IHRvIHRoZSBib3R0b20gb2YgdGhlIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzZW5kVG9CYWNrOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuc2VuZFRvQmFjay5jYWxsKHRoaXMuZ3JvdXAsIHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMuc2VuZFRvQmFjayh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYnJpbmdUb0Zyb250OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuYnJpbmdUb0Zyb250LmNhbGwodGhpcy5ncm91cCwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5icmluZ1RvRnJvbnQodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgZG93biBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVyc2VjdGluZ10gSWYgYHRydWVgLCBzZW5kIG9iamVjdCBiZWhpbmQgbmV4dCBsb3dlciBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2VuZEJhY2t3YXJkczogZnVuY3Rpb24oaW50ZXJzZWN0aW5nKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnNlbmRCYWNrd2FyZHMuY2FsbCh0aGlzLmdyb3VwLCB0aGlzLCBpbnRlcnNlY3RpbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMuc2VuZEJhY2t3YXJkcyh0aGlzLCBpbnRlcnNlY3RpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IHVwIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaW50ZXJzZWN0aW5nXSBJZiBgdHJ1ZWAsIHNlbmQgb2JqZWN0IGluIGZyb250IG9mIG5leHQgdXBwZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGJyaW5nRm9yd2FyZDogZnVuY3Rpb24oaW50ZXJzZWN0aW5nKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLmJyaW5nRm9yd2FyZC5jYWxsKHRoaXMuZ3JvdXAsIHRoaXMsIGludGVyc2VjdGluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5icmluZ0ZvcndhcmQodGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB0byBzcGVjaWZpZWQgbGV2ZWwgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggTmV3IHBvc2l0aW9uIG9mIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIG1vdmVUbzogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBpZiAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLnR5cGUgIT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5tb3ZlVG8uY2FsbCh0aGlzLmdyb3VwLCB0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5tb3ZlVG8odGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cblxuLyogX1RPX1NWR19TVEFSVF8gKi9cbihmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gZ2V0U3ZnQ29sb3JTdHJpbmcocHJvcCwgdmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gcHJvcCArICc6IG5vbmU7ICc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLnRvTGl2ZSkge1xuICAgICAgcmV0dXJuIHByb3AgKyAnOiB1cmwoI1NWR0lEXycgKyB2YWx1ZS5pZCArICcpOyAnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IodmFsdWUpLFxuICAgICAgICAgIHN0ciA9IHByb3AgKyAnOiAnICsgY29sb3IudG9SZ2IoKSArICc7ICcsXG4gICAgICAgICAgb3BhY2l0eSA9IGNvbG9yLmdldEFscGhhKCk7XG4gICAgICBpZiAob3BhY2l0eSAhPT0gMSkge1xuICAgICAgICAvL2NoYW5nZSB0aGUgY29sb3IgaW4gcmdiICsgb3BhY2l0eVxuICAgICAgICBzdHIgKz0gcHJvcCArICctb3BhY2l0eTogJyArIG9wYWNpdHkudG9TdHJpbmcoKSArICc7ICc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZDtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0eWxlcy1zdHJpbmcgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBTaGFkb3cgYSBib29sZWFuIHRvIHNraXAgc2hhZG93IGZpbHRlciBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnU3R5bGVzOiBmdW5jdGlvbihza2lwU2hhZG93KSB7XG5cbiAgICAgIHZhciBmaWxsUnVsZSA9IHRoaXMuZmlsbFJ1bGUgPyB0aGlzLmZpbGxSdWxlIDogJ25vbnplcm8nLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aCA/IHRoaXMuc3Ryb2tlV2lkdGggOiAnMCcsXG4gICAgICAgICAgc3Ryb2tlRGFzaEFycmF5ID0gdGhpcy5zdHJva2VEYXNoQXJyYXkgPyB0aGlzLnN0cm9rZURhc2hBcnJheS5qb2luKCcgJykgOiAnbm9uZScsXG4gICAgICAgICAgc3Ryb2tlRGFzaE9mZnNldCA9IHRoaXMuc3Ryb2tlRGFzaE9mZnNldCA/IHRoaXMuc3Ryb2tlRGFzaE9mZnNldCA6ICcwJyxcbiAgICAgICAgICBzdHJva2VMaW5lQ2FwID0gdGhpcy5zdHJva2VMaW5lQ2FwID8gdGhpcy5zdHJva2VMaW5lQ2FwIDogJ2J1dHQnLFxuICAgICAgICAgIHN0cm9rZUxpbmVKb2luID0gdGhpcy5zdHJva2VMaW5lSm9pbiA/IHRoaXMuc3Ryb2tlTGluZUpvaW4gOiAnbWl0ZXInLFxuICAgICAgICAgIHN0cm9rZU1pdGVyTGltaXQgPSB0aGlzLnN0cm9rZU1pdGVyTGltaXQgPyB0aGlzLnN0cm9rZU1pdGVyTGltaXQgOiAnNCcsXG4gICAgICAgICAgb3BhY2l0eSA9IHR5cGVvZiB0aGlzLm9wYWNpdHkgIT09ICd1bmRlZmluZWQnID8gdGhpcy5vcGFjaXR5IDogJzEnLFxuICAgICAgICAgIHZpc2liaWxpdHkgPSB0aGlzLnZpc2libGUgPyAnJyA6ICcgdmlzaWJpbGl0eTogaGlkZGVuOycsXG4gICAgICAgICAgZmlsdGVyID0gc2tpcFNoYWRvdyA/ICcnIDogdGhpcy5nZXRTdmdGaWx0ZXIoKSxcbiAgICAgICAgICBmaWxsID0gZ2V0U3ZnQ29sb3JTdHJpbmcoJ2ZpbGwnLCB0aGlzLmZpbGwpLFxuICAgICAgICAgIHN0cm9rZSA9IGdldFN2Z0NvbG9yU3RyaW5nKCdzdHJva2UnLCB0aGlzLnN0cm9rZSk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgJ3N0cm9rZS13aWR0aDogJywgc3Ryb2tlV2lkdGgsICc7ICcsXG4gICAgICAgICdzdHJva2UtZGFzaGFycmF5OiAnLCBzdHJva2VEYXNoQXJyYXksICc7ICcsXG4gICAgICAgICdzdHJva2UtbGluZWNhcDogJywgc3Ryb2tlTGluZUNhcCwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0OiAnLCBzdHJva2VEYXNoT2Zmc2V0LCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVqb2luOiAnLCBzdHJva2VMaW5lSm9pbiwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1taXRlcmxpbWl0OiAnLCBzdHJva2VNaXRlckxpbWl0LCAnOyAnLFxuICAgICAgICBmaWxsLFxuICAgICAgICAnZmlsbC1ydWxlOiAnLCBmaWxsUnVsZSwgJzsgJyxcbiAgICAgICAgJ29wYWNpdHk6ICcsIG9wYWNpdHksICc7JyxcbiAgICAgICAgZmlsdGVyLFxuICAgICAgICB2aXNpYmlsaXR5XG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0eWxlcy1zdHJpbmcgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgdGhlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJldHJpZXZlIHN0eWxlIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZVdoaXRlU3BhY2UgYSBib29sZWFuIHRvIGluY2x1ZGUgYW4gYWRkaXRpb25hbCBhdHRyaWJ1dGUgaW4gdGhlIHN0eWxlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdTcGFuU3R5bGVzOiBmdW5jdGlvbihzdHlsZSwgdXNlV2hpdGVTcGFjZSkge1xuICAgICAgdmFyIHRlcm0gPSAnOyAnO1xuICAgICAgdmFyIGZvbnRGYW1pbHkgPSBzdHlsZS5mb250RmFtaWx5ID9cbiAgICAgICAgJ2ZvbnQtZmFtaWx5OiAnICsgKCgoc3R5bGUuZm9udEZhbWlseS5pbmRleE9mKCdcXCcnKSA9PT0gLTEgJiYgc3R5bGUuZm9udEZhbWlseS5pbmRleE9mKCdcIicpID09PSAtMSkgP1xuICAgICAgICAgICdcXCcnICsgc3R5bGUuZm9udEZhbWlseSAgKyAnXFwnJyA6IHN0eWxlLmZvbnRGYW1pbHkpKSArIHRlcm0gOiAnJztcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHN0eWxlLnN0cm9rZVdpZHRoID8gJ3N0cm9rZS13aWR0aDogJyArIHN0eWxlLnN0cm9rZVdpZHRoICsgdGVybSA6ICcnLFxuICAgICAgICAgIGZvbnRGYW1pbHkgPSBmb250RmFtaWx5LFxuICAgICAgICAgIGZvbnRTaXplID0gc3R5bGUuZm9udFNpemUgPyAnZm9udC1zaXplOiAnICsgc3R5bGUuZm9udFNpemUgKyAncHgnICsgdGVybSA6ICcnLFxuICAgICAgICAgIGZvbnRTdHlsZSA9IHN0eWxlLmZvbnRTdHlsZSA/ICdmb250LXN0eWxlOiAnICsgc3R5bGUuZm9udFN0eWxlICsgdGVybSA6ICcnLFxuICAgICAgICAgIGZvbnRXZWlnaHQgPSBzdHlsZS5mb250V2VpZ2h0ID8gJ2ZvbnQtd2VpZ2h0OiAnICsgc3R5bGUuZm9udFdlaWdodCArIHRlcm0gOiAnJyxcbiAgICAgICAgICBmaWxsID0gc3R5bGUuZmlsbCA/IGdldFN2Z0NvbG9yU3RyaW5nKCdmaWxsJywgc3R5bGUuZmlsbCkgOiAnJyxcbiAgICAgICAgICBzdHJva2UgPSBzdHlsZS5zdHJva2UgPyBnZXRTdmdDb2xvclN0cmluZygnc3Ryb2tlJywgc3R5bGUuc3Ryb2tlKSA6ICcnLFxuICAgICAgICAgIHRleHREZWNvcmF0aW9uID0gdGhpcy5nZXRTdmdUZXh0RGVjb3JhdGlvbihzdHlsZSksXG4gICAgICAgICAgZGVsdGFZID0gc3R5bGUuZGVsdGFZID8gJ2Jhc2VsaW5lLXNoaWZ0OiAnICsgKC1zdHlsZS5kZWx0YVkpICsgJzsgJyA6ICcnO1xuICAgICAgaWYgKHRleHREZWNvcmF0aW9uKSB7XG4gICAgICAgIHRleHREZWNvcmF0aW9uID0gJ3RleHQtZGVjb3JhdGlvbjogJyArIHRleHREZWNvcmF0aW9uICsgdGVybTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgZm9udEZhbWlseSxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIGZvbnRTdHlsZSxcbiAgICAgICAgZm9udFdlaWdodCxcbiAgICAgICAgdGV4dERlY29yYXRpb24sXG4gICAgICAgIGZpbGwsXG4gICAgICAgIGRlbHRhWSxcbiAgICAgICAgdXNlV2hpdGVTcGFjZSA/ICd3aGl0ZS1zcGFjZTogcHJlOyAnIDogJydcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGV4dC1kZWNvcmF0aW9uIHByb3BlcnR5IGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIHRoZSBvYmplY3QgZnJvbSB3aGljaCB0byByZXRyaWV2ZSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1RleHREZWNvcmF0aW9uOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgcmV0dXJuIFsnb3ZlcmxpbmUnLCAndW5kZXJsaW5lJywgJ2xpbmUtdGhyb3VnaCddLmZpbHRlcihmdW5jdGlvbihkZWNvcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBzdHlsZVtkZWNvcmF0aW9uLnJlcGxhY2UoJy0nLCAnJyldO1xuICAgICAgfSkuam9pbignICcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZpbHRlciBmb3Igc3ZnIHNoYWRvd1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hhZG93ID8gJ2ZpbHRlcjogdXJsKCNTVkdJRF8nICsgdGhpcy5zaGFkb3cuaWQgKyAnKTsnIDogJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWQgYXR0cmlidXRlIGZvciBzdmcgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z0NvbW1vbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGhpcy5pZCA/ICdpZD1cIicgKyB0aGlzLmlkICsgJ1wiICcgOiAnJyxcbiAgICAgICAgdGhpcy5jbGlwUGF0aCA/ICdjbGlwLXBhdGg9XCJ1cmwoIycgKyB0aGlzLmNsaXBQYXRoLmNsaXBQYXRoSWQgKyAnKVwiICcgOiAnJyxcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJhbnNmb3JtLXN0cmluZyBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlIHRoZSBmdWxsIHRyYW5zZm9ybSBvciB0aGUgc2luZ2xlIG9iamVjdCBvbmUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1RyYW5zZm9ybTogZnVuY3Rpb24oZnVsbCwgYWRkaXRpb25hbFRyYW5zZm9ybSkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGZ1bGwgPyB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSA6IHRoaXMuY2FsY093bk1hdHJpeCgpLFxuICAgICAgICAgIHN2Z1RyYW5zZm9ybSA9ICd0cmFuc2Zvcm09XCInICsgZmFicmljLnV0aWwubWF0cml4VG9TVkcodHJhbnNmb3JtKTtcbiAgICAgIHJldHVybiBzdmdUcmFuc2Zvcm0gK1xuICAgICAgICAoYWRkaXRpb25hbFRyYW5zZm9ybSB8fCAnJykgKyAnXCIgJztcbiAgICB9LFxuXG4gICAgX3NldFNWR0JnOiBmdW5jdGlvbih0ZXh0QmdSZWN0cykge1xuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuICAgICAgICB0ZXh0QmdSZWN0cy5wdXNoKFxuICAgICAgICAgICdcXHRcXHQ8cmVjdCAnLFxuICAgICAgICAgIHRoaXMuX2dldEZpbGxBdHRyaWJ1dGVzKHRoaXMuYmFja2dyb3VuZENvbG9yKSxcbiAgICAgICAgICAnIHg9XCInLFxuICAgICAgICAgIHRvRml4ZWQoLXRoaXMud2lkdGggLyAyLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCIgeT1cIicsXG4gICAgICAgICAgdG9GaXhlZCgtdGhpcy5oZWlnaHQgLyAyLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCIgd2lkdGg9XCInLFxuICAgICAgICAgIHRvRml4ZWQodGhpcy53aWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgJ1wiIGhlaWdodD1cIicsXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgJ1wiPjwvcmVjdD5cXG4nKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKHRoaXMuX3RvU1ZHKHJldml2ZXIpLCB7IHJldml2ZXI6IHJldml2ZXIgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIGNsaXBQYXRoIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvQ2xpcFBhdGhTVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHJldHVybiAnXFx0JyArIHRoaXMuX2NyZWF0ZUJhc2VDbGlwUGF0aFNWR01hcmt1cCh0aGlzLl90b1NWRyhyZXZpdmVyKSwgeyByZXZpdmVyOiByZXZpdmVyIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVCYXNlQ2xpcFBhdGhTVkdNYXJrdXA6IGZ1bmN0aW9uKG9iamVjdE1hcmt1cCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgcmV2aXZlciA9IG9wdGlvbnMucmV2aXZlcixcbiAgICAgICAgICBhZGRpdGlvbmFsVHJhbnNmb3JtID0gb3B0aW9ucy5hZGRpdGlvbmFsVHJhbnNmb3JtIHx8ICcnLFxuICAgICAgICAgIGNvbW1vblBpZWNlcyA9IFtcbiAgICAgICAgICAgIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKHRydWUsIGFkZGl0aW9uYWxUcmFuc2Zvcm0pLFxuICAgICAgICAgICAgdGhpcy5nZXRTdmdDb21tb25zKCksXG4gICAgICAgICAgXS5qb2luKCcnKSxcbiAgICAgICAgICAvLyBpbnNlcnQgY29tbW9ucyBpbiB0aGUgbWFya3VwLCBzdHlsZSBhbmQgc3ZnQ29tbW9uc1xuICAgICAgICAgIGluZGV4ID0gb2JqZWN0TWFya3VwLmluZGV4T2YoJ0NPTU1PTl9QQVJUUycpO1xuICAgICAgb2JqZWN0TWFya3VwW2luZGV4XSA9IGNvbW1vblBpZWNlcztcbiAgICAgIHJldHVybiByZXZpdmVyID8gcmV2aXZlcihvYmplY3RNYXJrdXAuam9pbignJykpIDogb2JqZWN0TWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVCYXNlU1ZHTWFya3VwOiBmdW5jdGlvbihvYmplY3RNYXJrdXAsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIG5vU3R5bGUgPSBvcHRpb25zLm5vU3R5bGUsXG4gICAgICAgICAgcmV2aXZlciA9IG9wdGlvbnMucmV2aXZlcixcbiAgICAgICAgICBzdHlsZUluZm8gPSBub1N0eWxlID8gJycgOiAnc3R5bGU9XCInICsgdGhpcy5nZXRTdmdTdHlsZXMoKSArICdcIiAnLFxuICAgICAgICAgIHNoYWRvd0luZm8gPSBvcHRpb25zLndpdGhTaGFkb3cgPyAnc3R5bGU9XCInICsgdGhpcy5nZXRTdmdGaWx0ZXIoKSArICdcIiAnIDogJycsXG4gICAgICAgICAgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoLFxuICAgICAgICAgIHZlY3RvckVmZmVjdCA9IHRoaXMuc3Ryb2tlVW5pZm9ybSA/ICd2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgJyA6ICcnLFxuICAgICAgICAgIGFic29sdXRlQ2xpcFBhdGggPSBjbGlwUGF0aCAmJiBjbGlwUGF0aC5hYnNvbHV0ZVBvc2l0aW9uZWQsXG4gICAgICAgICAgc3Ryb2tlID0gdGhpcy5zdHJva2UsIGZpbGwgPSB0aGlzLmZpbGwsIHNoYWRvdyA9IHRoaXMuc2hhZG93LFxuICAgICAgICAgIGNvbW1vblBpZWNlcywgbWFya3VwID0gW10sIGNsaXBQYXRoTWFya3VwLFxuICAgICAgICAgIC8vIGluc2VydCBjb21tb25zIGluIHRoZSBtYXJrdXAsIHN0eWxlIGFuZCBzdmdDb21tb25zXG4gICAgICAgICAgaW5kZXggPSBvYmplY3RNYXJrdXAuaW5kZXhPZignQ09NTU9OX1BBUlRTJyksXG4gICAgICAgICAgYWRkaXRpb25hbFRyYW5zZm9ybSA9IG9wdGlvbnMuYWRkaXRpb25hbFRyYW5zZm9ybTtcbiAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICBjbGlwUGF0aC5jbGlwUGF0aElkID0gJ0NMSVBQQVRIXycgKyBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICAgIGNsaXBQYXRoTWFya3VwID0gJzxjbGlwUGF0aCBpZD1cIicgKyBjbGlwUGF0aC5jbGlwUGF0aElkICsgJ1wiID5cXG4nICtcbiAgICAgICAgICBjbGlwUGF0aC50b0NsaXBQYXRoU1ZHKHJldml2ZXIpICtcbiAgICAgICAgICAnPC9jbGlwUGF0aD5cXG4nO1xuICAgICAgfVxuICAgICAgaWYgKGFic29sdXRlQ2xpcFBhdGgpIHtcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxnICcsIHNoYWRvd0luZm8sIHRoaXMuZ2V0U3ZnQ29tbW9ucygpLCAnID5cXG4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgJzxnICcsXG4gICAgICAgIHRoaXMuZ2V0U3ZnVHJhbnNmb3JtKGZhbHNlKSxcbiAgICAgICAgIWFic29sdXRlQ2xpcFBhdGggPyBzaGFkb3dJbmZvICsgdGhpcy5nZXRTdmdDb21tb25zKCkgOiAnJyxcbiAgICAgICAgJyA+XFxuJ1xuICAgICAgKTtcbiAgICAgIGNvbW1vblBpZWNlcyA9IFtcbiAgICAgICAgc3R5bGVJbmZvLFxuICAgICAgICB2ZWN0b3JFZmZlY3QsXG4gICAgICAgIG5vU3R5bGUgPyAnJyA6IHRoaXMuYWRkUGFpbnRPcmRlcigpLCAnICcsXG4gICAgICAgIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPyAndHJhbnNmb3JtPVwiJyArIGFkZGl0aW9uYWxUcmFuc2Zvcm0gKyAnXCIgJyA6ICcnLFxuICAgICAgXS5qb2luKCcnKTtcbiAgICAgIG9iamVjdE1hcmt1cFtpbmRleF0gPSBjb21tb25QaWVjZXM7XG4gICAgICBpZiAoZmlsbCAmJiBmaWxsLnRvTGl2ZSkge1xuICAgICAgICBtYXJrdXAucHVzaChmaWxsLnRvU1ZHKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJva2UgJiYgc3Ryb2tlLnRvTGl2ZSkge1xuICAgICAgICBtYXJrdXAucHVzaChzdHJva2UudG9TVkcodGhpcykpO1xuICAgICAgfVxuICAgICAgaWYgKHNoYWRvdykge1xuICAgICAgICBtYXJrdXAucHVzaChzaGFkb3cudG9TVkcodGhpcykpO1xuICAgICAgfVxuICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKGNsaXBQYXRoTWFya3VwKTtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKG9iamVjdE1hcmt1cC5qb2luKCcnKSk7XG4gICAgICBtYXJrdXAucHVzaCgnPC9nPlxcbicpO1xuICAgICAgYWJzb2x1dGVDbGlwUGF0aCAmJiBtYXJrdXAucHVzaCgnPC9nPlxcbicpO1xuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG1hcmt1cC5qb2luKCcnKSkgOiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcblxuICAgIGFkZFBhaW50T3JkZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFpbnRGaXJzdCAhPT0gJ2ZpbGwnID8gJyBwYWludC1vcmRlcj1cIicgKyB0aGlzLnBhaW50Rmlyc3QgKyAnXCIgJyA6ICcnO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuLyogX1RPX1NWR19FTkRfICovXG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgb3JpZ2luYWxTZXQgPSAnc3RhdGVQcm9wZXJ0aWVzJztcblxuICAvKlxuICAgIERlcGVuZHMgb24gYHN0YXRlUHJvcGVydGllc2BcbiAgKi9cbiAgZnVuY3Rpb24gc2F2ZVByb3BzKG9yaWdpbiwgZGVzdGluYXRpb24sIHByb3BzKSB7XG4gICAgdmFyIHRtcE9iaiA9IHsgfSwgZGVlcCA9IHRydWU7XG4gICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICB0bXBPYmpbcHJvcF0gPSBvcmlnaW5bcHJvcF07XG4gICAgfSk7XG5cbiAgICBleHRlbmQob3JpZ2luW2Rlc3RpbmF0aW9uXSwgdG1wT2JqLCBkZWVwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pc0VxdWFsKG9yaWdWYWx1ZSwgY3VycmVudFZhbHVlLCBmaXJzdFBhc3MpIHtcbiAgICBpZiAob3JpZ1ZhbHVlID09PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgIC8vIGlmIHRoZSBvYmplY3RzIGFyZSBpZGVudGljYWwsIHJldHVyblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob3JpZ1ZhbHVlKSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkgfHwgb3JpZ1ZhbHVlLmxlbmd0aCAhPT0gY3VycmVudFZhbHVlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb3JpZ1ZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghX2lzRXF1YWwob3JpZ1ZhbHVlW2ldLCBjdXJyZW50VmFsdWVbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3JpZ1ZhbHVlICYmIHR5cGVvZiBvcmlnVmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9yaWdWYWx1ZSksIGtleTtcbiAgICAgIGlmICghY3VycmVudFZhbHVlIHx8XG4gICAgICAgICAgdHlwZW9mIGN1cnJlbnRWYWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAoIWZpcnN0UGFzcyAmJiBrZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoY3VycmVudFZhbHVlKS5sZW5ndGgpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgLy8gc2luY2UgY2xpcFBhdGggaXMgaW4gdGhlIHN0YXRlZnVsbCBjYWNoZSBsaXN0IGFuZCB0aGUgY2xpcFBhdGggb2JqZWN0c1xuICAgICAgICAvLyB3b3VsZCBiZSBpdGVyYXRlZCBhcyBhbiBvYmplY3QsIHRoaXMgd291bGQgbGVhZCB0byBwb3NzaWJsZSBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gY29tcGFyZSB0aG9zZS5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2NhbnZhcycgfHwga2V5ID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfaXNFcXVhbChvcmlnVmFsdWVba2V5XSwgY3VycmVudFZhbHVlW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBzdGF0ZSAob25lIG9mIGl0cyBzdGF0ZSBwcm9wZXJ0aWVzKSB3YXMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHlTZXRdIG9wdGlvbmFsIG5hbWUgZm9yIHRoZSBzZXQgb2YgcHJvcGVydHkgd2Ugd2FudCB0byBzYXZlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBpbnN0YW5jZScgc3RhdGUgaGFzIGNoYW5nZWQgc2luY2UgYHtAbGluayBmYWJyaWMuT2JqZWN0I3NhdmVTdGF0ZX1gIHdhcyBjYWxsZWRcbiAgICAgKi9cbiAgICBoYXNTdGF0ZUNoYW5nZWQ6IGZ1bmN0aW9uKHByb3BlcnR5U2V0KSB7XG4gICAgICBwcm9wZXJ0eVNldCA9IHByb3BlcnR5U2V0IHx8IG9yaWdpbmFsU2V0O1xuICAgICAgdmFyIGRhc2hlZFByb3BlcnR5U2V0ID0gJ18nICsgcHJvcGVydHlTZXQ7XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpc1tkYXNoZWRQcm9wZXJ0eVNldF0pLmxlbmd0aCA8IHRoaXNbcHJvcGVydHlTZXRdLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhX2lzRXF1YWwodGhpc1tkYXNoZWRQcm9wZXJ0eVNldF0sIHRoaXMsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTYXZlcyBzdGF0ZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCB3aXRoIGFkZGl0aW9uYWwgYHN0YXRlUHJvcGVydGllc2AgYXJyYXkgdG8gaW5jbHVkZSB3aGVuIHNhdmluZyBzdGF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzYXZlU3RhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcm9wZXJ0eVNldCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wcm9wZXJ0eVNldCB8fCBvcmlnaW5hbFNldCxcbiAgICAgICAgICBkZXN0aW5hdGlvbiA9ICdfJyArIHByb3BlcnR5U2V0O1xuICAgICAgaWYgKCF0aGlzW2Rlc3RpbmF0aW9uXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR1cFN0YXRlKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgc2F2ZVByb3BzKHRoaXMsIGRlc3RpbmF0aW9uLCB0aGlzW3Byb3BlcnR5U2V0XSk7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN0YXRlUHJvcGVydGllcykge1xuICAgICAgICBzYXZlUHJvcHModGhpcywgZGVzdGluYXRpb24sIG9wdGlvbnMuc3RhdGVQcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXR1cHMgc3RhdGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGBzdGF0ZVByb3BlcnRpZXNgIGFycmF5IHRvIGluY2x1ZGUgd2hlbiBzYXZpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgc2V0dXBTdGF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgICAgdmFyIHByb3BlcnR5U2V0ID0gb3B0aW9ucy5wcm9wZXJ0eVNldCB8fCBvcmlnaW5hbFNldDtcbiAgICAgIG9wdGlvbnMucHJvcGVydHlTZXQgPSBwcm9wZXJ0eVNldDtcbiAgICAgIHRoaXNbJ18nICsgcHJvcGVydHlTZXRdID0geyB9O1xuICAgICAgdGhpcy5zYXZlU3RhdGUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hpY2ggY29ybmVyIGhhcyBiZWVuIGNsaWNrZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyIFRoZSBwb2ludGVyIGluZGljYXRpbmcgdGhlIG1vdXNlIHBvc2l0aW9uXG4gICAgICogQHJldHVybiB7U3RyaW5nfEJvb2xlYW59IGNvcm5lciBjb2RlICh0bCwgdHIsIGJsLCBiciwgZXRjLiksIG9yIGZhbHNlIGlmIG5vdGhpbmcgaXMgZm91bmRcbiAgICAgKi9cbiAgICBfZmluZFRhcmdldENvcm5lcjogZnVuY3Rpb24ocG9pbnRlciwgZm9yVG91Y2gpIHtcbiAgICAgIC8vIG9iamVjdHMgaW4gZ3JvdXAsIGFueWtpbmQsIGFyZSBub3Qgc2VsZiBtb2RpZmljYWJsZSxcbiAgICAgIC8vIG11c3Qgbm90IHJldHVybiBhbiBob3ZlcmVkIGNvcm5lci5cbiAgICAgIGlmICghdGhpcy5oYXNDb250cm9scyB8fCB0aGlzLmdyb3VwIHx8ICghdGhpcy5jYW52YXMgfHwgdGhpcy5jYW52YXMuX2FjdGl2ZU9iamVjdCAhPT0gdGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXggPSBwb2ludGVyLngsXG4gICAgICAgICAgZXkgPSBwb2ludGVyLnksXG4gICAgICAgICAgeFBvaW50cyxcbiAgICAgICAgICBsaW5lcywga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMub0Nvb3JkcyksXG4gICAgICAgICAgaiA9IGtleXMubGVuZ3RoIC0gMSwgaTtcbiAgICAgIHRoaXMuX19jb3JuZXIgPSAwO1xuXG4gICAgICAvLyBjeWNsZSBpbiByZXZlcnNlIG9yZGVyIHNvIHdlIHBpY2sgZmlyc3QgdGhlIG9uZSBvbiB0b3BcbiAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICBpID0ga2V5c1tqXTtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29udHJvbFZpc2libGUoaSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVzID0gdGhpcy5fZ2V0SW1hZ2VMaW5lcyhmb3JUb3VjaCA/IHRoaXMub0Nvb3Jkc1tpXS50b3VjaENvcm5lciA6IHRoaXMub0Nvb3Jkc1tpXS5jb3JuZXIpO1xuICAgICAgICAvLyAvLyBkZWJ1Z2dpbmdcbiAgICAgICAgLy9cbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5ib3R0b21saW5lLmQueCwgbGluZXMuYm90dG9tbGluZS5kLnksIDIsIDIpO1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmJvdHRvbWxpbmUuby54LCBsaW5lcy5ib3R0b21saW5lLm8ueSwgMiwgMik7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMubGVmdGxpbmUuZC54LCBsaW5lcy5sZWZ0bGluZS5kLnksIDIsIDIpO1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmxlZnRsaW5lLm8ueCwgbGluZXMubGVmdGxpbmUuby55LCAyLCAyKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy50b3BsaW5lLmQueCwgbGluZXMudG9wbGluZS5kLnksIDIsIDIpO1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnRvcGxpbmUuby54LCBsaW5lcy50b3BsaW5lLm8ueSwgMiwgMik7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMucmlnaHRsaW5lLmQueCwgbGluZXMucmlnaHRsaW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMucmlnaHRsaW5lLm8ueCwgbGluZXMucmlnaHRsaW5lLm8ueSwgMiwgMik7XG5cbiAgICAgICAgeFBvaW50cyA9IHRoaXMuX2ZpbmRDcm9zc1BvaW50cyh7IHg6IGV4LCB5OiBleSB9LCBsaW5lcyk7XG4gICAgICAgIGlmICh4UG9pbnRzICE9PSAwICYmIHhQb2ludHMgJSAyID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5fX2Nvcm5lciA9IGk7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgYSBmdW5jdGlvbiBmb3IgZWFjaCBjb250cm9sLiBUaGUgZnVuY3Rpb24gZ2V0cyBjYWxsZWQsXG4gICAgICogd2l0aCB0aGUgY29udHJvbCwgdGhlIG9iamVjdCB0aGF0IGlzIGNhbGxpbmcgdGhlIGl0ZXJhdG9yIGFuZCB0aGUgY29udHJvbCdzIGtleVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciB0aGUgY29udHJvbHMgb3ZlclxuICAgICAqL1xuICAgIGZvckVhY2hDb250cm9sOiBmdW5jdGlvbihmbikge1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmNvbnRyb2xzKSB7XG4gICAgICAgIGZuKHRoaXMuY29udHJvbHNbaV0sIGksIHRoaXMpO1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGRyYWdnYWJsZSBib3hlcyBpbiB0aGUgY29ybmVycyBvZlxuICAgICAqIHRoZSBpbWFnZSB1c2VkIHRvIHNjYWxlL3JvdGF0ZSBpdC5cbiAgICAgKiBub3RlOiBpZiB3ZSB3b3VsZCBzd2l0Y2ggdG8gUk9VTkQgY29ybmVyIGFyZWEsIGFsbCBvZiB0aGlzIHdvdWxkIGRpc2FwcGVhci5cbiAgICAgKiBldmVyeXRoaW5nIHdvdWxkIHJlc29sdmUgdG8gYSBzaW5nbGUgcG9pbnQgYW5kIGEgcHl0aGFnb3JlYW4gdGhlb3JlbSBmb3IgdGhlIGRpc3RhbmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0Q29ybmVyQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLm9Db29yZHM7XG5cbiAgICAgIGZvciAodmFyIGNvbnRyb2wgaW4gY29vcmRzKSB7XG4gICAgICAgIHZhciBjb250cm9sT2JqZWN0ID0gdGhpcy5jb250cm9sc1tjb250cm9sXTtcbiAgICAgICAgY29vcmRzW2NvbnRyb2xdLmNvcm5lciA9IGNvbnRyb2xPYmplY3QuY2FsY0Nvcm5lckNvb3JkcyhcbiAgICAgICAgICB0aGlzLmFuZ2xlLCB0aGlzLmNvcm5lclNpemUsIGNvb3Jkc1tjb250cm9sXS54LCBjb29yZHNbY29udHJvbF0ueSwgZmFsc2UpO1xuICAgICAgICBjb29yZHNbY29udHJvbF0udG91Y2hDb3JuZXIgPSBjb250cm9sT2JqZWN0LmNhbGNDb3JuZXJDb29yZHMoXG4gICAgICAgICAgdGhpcy5hbmdsZSwgdGhpcy50b3VjaENvcm5lclNpemUsIGNvb3Jkc1tjb250cm9sXS54LCBjb29yZHNbY29udHJvbF0ueSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgY29sb3JlZCBsYXllciBiZWhpbmQgdGhlIG9iamVjdCwgaW5zaWRlIGl0cyBzZWxlY3Rpb24gYm9yZGVycy5cbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogcGFkZGluZywgc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yXG4gICAgICogdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB0aGUgY29udGV4dCBpcyB0cmFuc2Zvcm1lZFxuICAgICAqIGhhcyBjaGVja3MgdG8gYmUgc2tpcHBlZCB3aGVuIHRoZSBvYmplY3QgaXMgb24gYSBzdGF0aWNDYW52YXNcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gZHJhdyBvblxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZHJhd1NlbGVjdGlvbkJhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciB8fFxuICAgICAgICAodGhpcy5jYW52YXMgJiYgIXRoaXMuY2FudmFzLmludGVyYWN0aXZlKSB8fFxuICAgICAgICAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuX2FjdGl2ZU9iamVjdCAhPT0gdGhpcylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpLCB3aCA9IHRoaXMuX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zKCksXG4gICAgICAgICAgdnB0ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICBjdHgudHJhbnNsYXRlKGNlbnRlci54LCBjZW50ZXIueSk7XG4gICAgICBjdHguc2NhbGUoMSAvIHZwdFswXSwgMSAvIHZwdFszXSk7XG4gICAgICBjdHgucm90YXRlKGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KC13aC54IC8gMiwgLXdoLnkgLyAyLCB3aC54LCB3aC55KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYm9yZGVycyBvZiBhbiBvYmplY3QncyBib3VuZGluZyBib3guXG4gICAgICogUmVxdWlyZXMgcHVibGljIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHRcbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogcGFkZGluZywgYm9yZGVyQ29sb3JcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gZHJhdyBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlIG9iamVjdCB0byBvdmVycmlkZSB0aGUgb2JqZWN0IHN0eWxlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3Qm9yZGVyczogZnVuY3Rpb24oY3R4LCBzdHlsZU92ZXJyaWRlKSB7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICAgIHZhciB3aCA9IHRoaXMuX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zKCksXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSB0aGlzLmJvcmRlclNjYWxlRmFjdG9yLFxuICAgICAgICAgIHdpZHRoID0gd2gueCArIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IHdoLnkgKyBzdHJva2VXaWR0aCxcbiAgICAgICAgICBoYXNDb250cm9scyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLmhhc0NvbnRyb2xzICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICBzdHlsZU92ZXJyaWRlLmhhc0NvbnRyb2xzIDogdGhpcy5oYXNDb250cm9scyxcbiAgICAgICAgICBzaG91bGRTdHJva2UgPSBmYWxzZTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuYm9yZGVyQ29sb3IgfHwgdGhpcy5ib3JkZXJDb2xvcjtcbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgc3R5bGVPdmVycmlkZS5ib3JkZXJEYXNoQXJyYXkgfHwgdGhpcy5ib3JkZXJEYXNoQXJyYXkpO1xuXG4gICAgICBjdHguc3Ryb2tlUmVjdChcbiAgICAgICAgLXdpZHRoIC8gMixcbiAgICAgICAgLWhlaWdodCAvIDIsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgICk7XG5cbiAgICAgIGlmIChoYXNDb250cm9scykge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuZm9yRWFjaENvbnRyb2woZnVuY3Rpb24oY29udHJvbCwga2V5LCBmYWJyaWNPYmplY3QpIHtcbiAgICAgICAgICAvLyBpbiB0aGlzIG1vbWVudCwgdGhlIGN0eCBpcyBjZW50ZXJlZCBvbiB0aGUgb2JqZWN0LlxuICAgICAgICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGFib3ZlIGZ1bmN0aW9uIGFyZSB0aGUgc2l6ZSBvZiB0aGUgYmJveC5cbiAgICAgICAgICBpZiAoY29udHJvbC53aXRoQ29ubmVjdGlvbiAmJiBjb250cm9sLmdldFZpc2liaWxpdHkoZmFicmljT2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAvLyByZXNldCBtb3ZlbWVudCBmb3IgZWFjaCBjb250cm9sXG4gICAgICAgICAgICBzaG91bGRTdHJva2UgPSB0cnVlO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhjb250cm9sLnggKiB3aWR0aCwgY29udHJvbC55ICogaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oXG4gICAgICAgICAgICAgIGNvbnRyb2wueCAqIHdpZHRoICsgY29udHJvbC5vZmZzZXRYLFxuICAgICAgICAgICAgICBjb250cm9sLnkgKiBoZWlnaHQgKyBjb250cm9sLm9mZnNldFlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNob3VsZFN0cm9rZSkge1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib3JkZXJzIG9mIGFuIG9iamVjdCdzIGJvdW5kaW5nIGJveCB3aGVuIGl0IGlzIGluc2lkZSBhIGdyb3VwLlxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBwcm9wZXJ0aWVzOiB3aWR0aCwgaGVpZ2h0XG4gICAgICogUmVxdWlyZXMgcHVibGljIG9wdGlvbnM6IHBhZGRpbmcsIGJvcmRlckNvbG9yXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBvYmplY3QgcmVwcmVzZW50aW5nIGN1cnJlbnQgb2JqZWN0IHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPdmVycmlkZSBvYmplY3QgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZHJhd0JvcmRlcnNJbkdyb3VwOiBmdW5jdGlvbihjdHgsIG9wdGlvbnMsIHN0eWxlT3ZlcnJpZGUpIHtcbiAgICAgIHN0eWxlT3ZlcnJpZGUgPSBzdHlsZU92ZXJyaWRlIHx8IHt9O1xuICAgICAgdmFyIGJib3ggPSBmYWJyaWMudXRpbC5zaXplQWZ0ZXJUcmFuc2Zvcm0odGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIG9wdGlvbnMpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICBzdHJva2VVbmlmb3JtID0gdGhpcy5zdHJva2VVbmlmb3JtLFxuICAgICAgICAgIGJvcmRlclNjYWxlRmFjdG9yID0gdGhpcy5ib3JkZXJTY2FsZUZhY3RvcixcbiAgICAgICAgICB3aWR0aCA9XG4gICAgICAgICAgICBiYm94LnggKyBzdHJva2VXaWR0aCAqIChzdHJva2VVbmlmb3JtID8gdGhpcy5jYW52YXMuZ2V0Wm9vbSgpIDogb3B0aW9ucy5zY2FsZVgpICsgYm9yZGVyU2NhbGVGYWN0b3IsXG4gICAgICAgICAgaGVpZ2h0ID1cbiAgICAgICAgICAgIGJib3gueSArIHN0cm9rZVdpZHRoICogKHN0cm9rZVVuaWZvcm0gPyB0aGlzLmNhbnZhcy5nZXRab29tKCkgOiBvcHRpb25zLnNjYWxlWSkgKyBib3JkZXJTY2FsZUZhY3RvcjtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHN0eWxlT3ZlcnJpZGUuYm9yZGVyRGFzaEFycmF5IHx8IHRoaXMuYm9yZGVyRGFzaEFycmF5KTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuYm9yZGVyQ29sb3IgfHwgdGhpcy5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5zdHJva2VSZWN0KFxuICAgICAgICAtd2lkdGggLyAyLFxuICAgICAgICAtaGVpZ2h0IC8gMixcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgKTtcblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBjb3JuZXJzIG9mIGFuIG9iamVjdCdzIGJvdW5kaW5nIGJveC5cbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgcHJvcGVydGllczogd2lkdGgsIGhlaWdodFxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBvcHRpb25zOiBjb3JuZXJTaXplLCBwYWRkaW5nXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPdmVycmlkZSBvYmplY3QgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZHJhd0NvbnRyb2xzOiBmdW5jdGlvbihjdHgsIHN0eWxlT3ZlcnJpZGUpIHtcbiAgICAgIHN0eWxlT3ZlcnJpZGUgPSBzdHlsZU92ZXJyaWRlIHx8IHt9O1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciByZXRpbmFTY2FsaW5nID0gdGhpcy5jYW52YXMuZ2V0UmV0aW5hU2NhbGluZygpLCBtYXRyaXgsIHA7XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKHJldGluYVNjYWxpbmcsIDAsIDAsIHJldGluYVNjYWxpbmcsIDAsIDApO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyQ29sb3IgfHwgdGhpcy5jb3JuZXJDb2xvcjtcbiAgICAgIGlmICghdGhpcy50cmFuc3BhcmVudENvcm5lcnMpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJTdHJva2VDb2xvciB8fCB0aGlzLmNvcm5lclN0cm9rZUNvbG9yO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCBzdHlsZU92ZXJyaWRlLmNvcm5lckRhc2hBcnJheSB8fCB0aGlzLmNvcm5lckRhc2hBcnJheSk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgICAgLy8gZmFicmljSlMgZG9lcyBub3QgcmVhbGx5IHN1cHBvcnQgZHJhd2luZyBjb250cm9scyBpbnNpZGUgZ3JvdXBzLFxuICAgICAgICAvLyB0aGlzIHBpZWNlIG9mIGNvZGUgaGVyZSBoZWxwcyBoYXZpbmcgYXQgbGVhc3QgdGhlIGNvbnRyb2wgaW4gcGxhY2VzLlxuICAgICAgICAvLyBJZiBhbiBhcHBsaWNhdGlvbiBuZWVkcyB0byBzaG93IHNvbWUgb2JqZWN0cyBhcyBzZWxlY3RlZCBiZWNhdXNlIG9mIHNvbWUgVUkgc3RhdGVcbiAgICAgICAgLy8gY2FuIHN0aWxsIGNhbGwgT2JqZWN0Ll9yZW5kZXJDb250cm9scygpIG9uIGFueSBvYmplY3QgdGhleSBkZXNpcmUsIGluZGVwZW5kZW50bHkgb2YgZ3JvdXBzLlxuICAgICAgICAvLyB1c2luZyBubyBwYWRkaW5nLCBjaXJjdWxhciBjb250cm9scyBhbmQgaGlkaW5nIHRoZSByb3RhdGluZyBjdXJzb3IgaXMgaGlnbHkgc3VnZ2VzdGVkLFxuICAgICAgICBtYXRyaXggPSB0aGlzLmdyb3VwLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZm9yRWFjaENvbnRyb2woZnVuY3Rpb24oY29udHJvbCwga2V5LCBmYWJyaWNPYmplY3QpIHtcbiAgICAgICAgcCA9IGZhYnJpY09iamVjdC5vQ29vcmRzW2tleV07XG4gICAgICAgIGlmIChjb250cm9sLmdldFZpc2liaWxpdHkoZmFicmljT2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgcCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHAsIG1hdHJpeCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2wucmVuZGVyKGN0eCwgcC54LCBwLnksIHN0eWxlT3ZlcnJpZGUsIGZhYnJpY09iamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGNvbnRyb2wgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb250cm9sS2V5IFRoZSBrZXkgb2YgdGhlIGNvbnRyb2wuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3RsJywgJ3RyJywgJ2JyJywgJ2JsJywgJ21sJywgJ210JywgJ21yJywgJ21iJywgJ210cicuXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNwZWNpZmllZCBjb250cm9sIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGlzQ29udHJvbFZpc2libGU6IGZ1bmN0aW9uKGNvbnRyb2xLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzW2NvbnRyb2xLZXldICYmIHRoaXMuY29udHJvbHNbY29udHJvbEtleV0uZ2V0VmlzaWJpbGl0eSh0aGlzLCBjb250cm9sS2V5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgc3BlY2lmaWVkIGNvbnRyb2wuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRyb2xLZXkgVGhlIGtleSBvZiB0aGUgY29udHJvbC4gUG9zc2libGUgdmFsdWVzIGFyZSAndGwnLCAndHInLCAnYnInLCAnYmwnLCAnbWwnLCAnbXQnLCAnbXInLCAnbWInLCAnbXRyJy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUgdHJ1ZSB0byBzZXQgdGhlIHNwZWNpZmllZCBjb250cm9sIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0Q29udHJvbFZpc2libGU6IGZ1bmN0aW9uKGNvbnRyb2xLZXksIHZpc2libGUpIHtcbiAgICAgIGlmICghdGhpcy5fY29udHJvbHNWaXNpYmlsaXR5KSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xzVmlzaWJpbGl0eSA9IHt9O1xuICAgICAgfVxuICAgICAgdGhpcy5fY29udHJvbHNWaXNpYmlsaXR5W2NvbnRyb2xLZXldID0gdmlzaWJsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IHN0YXRlIG9mIG9iamVjdCBjb250cm9scy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ibF0gdHJ1ZSB0byBlbmFibGUgdGhlIGJvdHRvbS1sZWZ0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJyXSB0cnVlIHRvIGVuYWJsZSB0aGUgYm90dG9tLXJpZ2h0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1iXSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLWJvdHRvbSBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tbF0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS1sZWZ0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1yXSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLXJpZ2h0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm10XSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLXRvcCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50bF0gdHJ1ZSB0byBlbmFibGUgdGhlIHRvcC1sZWZ0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyXSB0cnVlIHRvIGVuYWJsZSB0aGUgdG9wLXJpZ2h0IGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm10cl0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS10b3Atcm90YXRlIGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvbnRyb2xzVmlzaWJpbGl0eTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIGZvciAodmFyIHAgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNldENvbnRyb2xWaXNpYmxlKHAsIG9wdGlvbnNbcF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQgZXZlcnkgdGltZSBfZGlzY2FyZEFjdGl2ZU9iamVjdCBvciBfc2V0QWN0aXZlT2JqZWN0XG4gICAgICogdHJ5IHRvIHRvIGRlc2VsZWN0IHRoaXMgb2JqZWN0LiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLCB0aGUgcHJvY2VzcyBpcyBjYW5jZWxsZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgc2VudCBmcm9tIHRoZSB1cHBlciBmdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbb3B0aW9ucy5lXSBldmVudCBpZiB0aGUgcHJvY2VzcyBpcyBnZW5lcmF0ZWQgYnkgYW4gZXZlbnRcbiAgICAgKi9cbiAgICBvbkRlc2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGltcGxlbWVudGVkIGJ5IHN1Yi1jbGFzc2VzLCBhcyBuZWVkZWQuXG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQgZXZlcnkgdGltZSBfZGlzY2FyZEFjdGl2ZU9iamVjdCBvciBfc2V0QWN0aXZlT2JqZWN0XG4gICAgICogdHJ5IHRvIHRvIHNlbGVjdCB0aGlzIG9iamVjdC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgdGhlIHByb2Nlc3MgaXMgY2FuY2VsbGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIHNlbnQgZnJvbSB0aGUgdXBwZXIgZnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtFdmVudH0gW29wdGlvbnMuZV0gZXZlbnQgaWYgdGhlIHByb2Nlc3MgaXMgZ2VuZXJhdGVkIGJ5IGFuIGV2ZW50XG4gICAgICovXG4gICAgb25TZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaW1wbGVtZW50ZWQgYnkgc3ViLWNsYXNzZXMsIGFzIG5lZWRlZC5cbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogQW5pbWF0aW9uIGR1cmF0aW9uIChpbiBtcykgZm9yIGZ4KiBtZXRob2RzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgRlhfRFVSQVRJT046IDUwMCxcblxuICAvKipcbiAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IHdpdGggYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tzXSBDYWxsYmFja3Mgb2JqZWN0IHdpdGggb3B0aW9uYWwgXCJvbkNvbXBsZXRlXCIgYW5kL29yIFwib25DaGFuZ2VcIiBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkFuaW1hdGlvbkNvbnRleHR9IGNvbnRleHRcbiAgICovXG4gIGZ4Q2VudGVyT2JqZWN0SDogZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzIHx8IHsgfTtcblxuICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICBvbkNvbXBsZXRlID0gY2FsbGJhY2tzLm9uQ29tcGxldGUgfHwgZW1wdHksXG4gICAgICAgIG9uQ2hhbmdlID0gY2FsbGJhY2tzLm9uQ2hhbmdlIHx8IGVtcHR5LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICBzdGFydFZhbHVlOiBvYmplY3QubGVmdCxcbiAgICAgIGVuZFZhbHVlOiB0aGlzLmdldENlbnRlclBvaW50KCkueCxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLkZYX0RVUkFUSU9OLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIG9iamVjdC5zZXQoJ2xlZnQnLCB2YWx1ZSk7XG4gICAgICAgIF90aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgb2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgd2l0aCBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja3NdIENhbGxiYWNrcyBvYmplY3Qgd2l0aCBvcHRpb25hbCBcIm9uQ29tcGxldGVcIiBhbmQvb3IgXCJvbkNoYW5nZVwiIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNvbXBsZXRlXSBJbnZva2VkIG9uIGNvbXBsZXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNoYW5nZV0gSW52b2tlZCBvbiBldmVyeSBzdGVwIG9mIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQW5pbWF0aW9uQ29udGV4dH0gY29udGV4dFxuICAgKi9cbiAgZnhDZW50ZXJPYmplY3RWOiBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIHN0YXJ0VmFsdWU6IG9iamVjdC50b3AsXG4gICAgICBlbmRWYWx1ZTogdGhpcy5nZXRDZW50ZXJQb2ludCgpLnksXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCd0b3AnLCB2YWx1ZSk7XG4gICAgICAgIF90aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgb2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgYGZhYnJpYy5DYW52YXMjcmVtb3ZlYCBidXQgYW5pbWF0ZWRcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHJlbW92ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrc10gQ2FsbGJhY2tzIG9iamVjdCB3aXRoIG9wdGlvbmFsIFwib25Db21wbGV0ZVwiIGFuZC9vciBcIm9uQ2hhbmdlXCIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ29tcGxldGVdIEludm9rZWQgb24gY29tcGxldGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ2hhbmdlXSBJbnZva2VkIG9uIGV2ZXJ5IHN0ZXAgb2YgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5BbmltYXRpb25Db250ZXh0fSBjb250ZXh0XG4gICAqL1xuICBmeFJlbW92ZTogZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzIHx8IHsgfTtcblxuICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICBvbkNvbXBsZXRlID0gY2FsbGJhY2tzLm9uQ29tcGxldGUgfHwgZW1wdHksXG4gICAgICAgIG9uQ2hhbmdlID0gY2FsbGJhY2tzLm9uQ2hhbmdlIHx8IGVtcHR5LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICBzdGFydFZhbHVlOiBvYmplY3Qub3BhY2l0eSxcbiAgICAgIGVuZFZhbHVlOiAwLFxuICAgICAgZHVyYXRpb246IHRoaXMuRlhfRFVSQVRJT04sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgb2JqZWN0LnNldCgnb3BhY2l0eScsIHZhbHVlKTtcbiAgICAgICAgX3RoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucmVtb3ZlKG9iamVjdCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSk7XG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuICAvKipcbiAgICogQW5pbWF0ZXMgb2JqZWN0J3MgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHByb3BlcnR5IFByb3BlcnR5IHRvIGFuaW1hdGUgKGlmIHN0cmluZykgb3IgcHJvcGVydGllcyB0byBhbmltYXRlIChpZiBvYmplY3QpXG4gICAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gdmFsdWUgVmFsdWUgdG8gYW5pbWF0ZSBwcm9wZXJ0eSB0byAoaWYgc3RyaW5nIHdhcyBnaXZlbiBmaXJzdCkgb3Igb3B0aW9ucyBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiNhbmltYXRpb259XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5BbmltYXRpb25Db250ZXh0IHwgZmFicmljLkFuaW1hdGlvbkNvbnRleHRbXX0gYW5pbWF0aW9uIGNvbnRleHQgKG9yIGFuIGFycmF5IGlmIHBhc3NlZCBtdWx0aXBsZSBwcm9wZXJ0aWVzKVxuICAgKlxuICAgKiBBcyBvYmplY3Qg4oCUIG11bHRpcGxlIHByb3BlcnRpZXNcbiAgICpcbiAgICogb2JqZWN0LmFuaW1hdGUoeyBsZWZ0OiAuLi4sIHRvcDogLi4uIH0pO1xuICAgKiBvYmplY3QuYW5pbWF0ZSh7IGxlZnQ6IC4uLiwgdG9wOiAuLi4gfSwgeyBkdXJhdGlvbjogLi4uIH0pO1xuICAgKlxuICAgKiBBcyBzdHJpbmcg4oCUIG9uZSBwcm9wZXJ0eVxuICAgKlxuICAgKiBvYmplY3QuYW5pbWF0ZSgnbGVmdCcsIC4uLik7XG4gICAqIG9iamVjdC5hbmltYXRlKCdsZWZ0JywgeyBkdXJhdGlvbjogLi4uIH0pO1xuICAgKlxuICAgKi9cbiAgYW5pbWF0ZTogZnVuY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBwcm9wc1RvQW5pbWF0ZSA9IFtdLCBwcm9wLCBza2lwQ2FsbGJhY2tzLCBvdXQgPSBbXTtcbiAgICAgIGZvciAocHJvcCBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgcHJvcHNUb0FuaW1hdGUucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwcm9wc1RvQW5pbWF0ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwcm9wID0gcHJvcHNUb0FuaW1hdGVbaV07XG4gICAgICAgIHNraXBDYWxsYmFja3MgPSBpICE9PSBsZW4gLSAxO1xuICAgICAgICBvdXQucHVzaCh0aGlzLl9hbmltYXRlKHByb3AsIGFyZ3VtZW50c1swXVtwcm9wXSwgYXJndW1lbnRzWzFdLCBza2lwQ2FsbGJhY2tzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbmltYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gYW5pbWF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdG8gVmFsdWUgdG8gYW5pbWF0ZSB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDYWxsYmFja3NdIFdoZW4gdHJ1ZSwgY2FsbGJhY2tzIGxpa2Ugb25jaGFuZ2UgYW5kIG9uY29tcGxldGUgYXJlIG5vdCBpbnZva2VkXG4gICAqL1xuICBfYW5pbWF0ZTogZnVuY3Rpb24ocHJvcGVydHksIHRvLCBvcHRpb25zLCBza2lwQ2FsbGJhY2tzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcywgcHJvcFBhaXI7XG5cbiAgICB0byA9IHRvLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7IH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAofnByb3BlcnR5LmluZGV4T2YoJy4nKSkge1xuICAgICAgcHJvcFBhaXIgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgIH1cblxuICAgIHZhciBwcm9wSXNDb2xvciA9XG4gICAgICBfdGhpcy5jb2xvclByb3BlcnRpZXMuaW5kZXhPZihwcm9wZXJ0eSkgPiAtMSB8fFxuICAgICAgKHByb3BQYWlyICYmIF90aGlzLmNvbG9yUHJvcGVydGllcy5pbmRleE9mKHByb3BQYWlyWzFdKSA+IC0xKTtcblxuICAgIHZhciBjdXJyZW50VmFsdWUgPSBwcm9wUGFpclxuICAgICAgPyB0aGlzLmdldChwcm9wUGFpclswXSlbcHJvcFBhaXJbMV1dXG4gICAgICA6IHRoaXMuZ2V0KHByb3BlcnR5KTtcblxuICAgIGlmICghKCdmcm9tJyBpbiBvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucy5mcm9tID0gY3VycmVudFZhbHVlO1xuICAgIH1cblxuICAgIGlmICghcHJvcElzQ29sb3IpIHtcbiAgICAgIGlmICh+dG8uaW5kZXhPZignPScpKSB7XG4gICAgICAgIHRvID0gY3VycmVudFZhbHVlICsgcGFyc2VGbG9hdCh0by5yZXBsYWNlKCc9JywgJycpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0byA9IHBhcnNlRmxvYXQodG8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfb3B0aW9ucyA9IHtcbiAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIHN0YXJ0VmFsdWU6IG9wdGlvbnMuZnJvbSxcbiAgICAgIGVuZFZhbHVlOiB0byxcbiAgICAgIGJ5VmFsdWU6IG9wdGlvbnMuYnksXG4gICAgICBlYXNpbmc6IG9wdGlvbnMuZWFzaW5nLFxuICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICBhYm9ydDogb3B0aW9ucy5hYm9ydCAmJiBmdW5jdGlvbih2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmFib3J0LmNhbGwoX3RoaXMsIHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpO1xuICAgICAgfSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAodmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcykge1xuICAgICAgICBpZiAocHJvcFBhaXIpIHtcbiAgICAgICAgICBfdGhpc1twcm9wUGFpclswXV1bcHJvcFBhaXJbMV1dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgX3RoaXMuc2V0KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBDYWxsYmFja3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5vbkNoYW5nZSAmJiBvcHRpb25zLm9uQ2hhbmdlKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uICh2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKSB7XG4gICAgICAgIGlmIChza2lwQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuc2V0Q29vcmRzKCk7XG4gICAgICAgIG9wdGlvbnMub25Db21wbGV0ZSAmJiBvcHRpb25zLm9uQ29tcGxldGUodmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChwcm9wSXNDb2xvcikge1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLmFuaW1hdGVDb2xvcihfb3B0aW9ucy5zdGFydFZhbHVlLCBfb3B0aW9ucy5lbmRWYWx1ZSwgX29wdGlvbnMuZHVyYXRpb24sIF9vcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwuYW5pbWF0ZShfb3B0aW9ucyk7XG4gICAgfVxuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSxcbiAgICAgIGNvb3JkUHJvcHMgPSB7IHgxOiAxLCB4MjogMSwgeTE6IDEsIHkyOiAxIH07XG5cbiAgaWYgKGZhYnJpYy5MaW5lKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5MaW5lIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaW5lIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuTGluZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5MaW5lI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuTGluZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLkxpbmUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnbGluZScsXG5cbiAgICAvKipcbiAgICAgKiB4IHZhbHVlIG9yIGZpcnN0IGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeDE6IDAsXG5cbiAgICAvKipcbiAgICAgKiB5IHZhbHVlIG9yIGZpcnN0IGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeTE6IDAsXG5cbiAgICAvKipcbiAgICAgKiB4IHZhbHVlIG9yIHNlY29uZCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHgyOiAwLFxuXG4gICAgLyoqXG4gICAgICogeSB2YWx1ZSBvciBzZWNvbmQgbGluZSBlZGdlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB5MjogMCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgneDEnLCAneDInLCAneTEnLCAneTInKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BvaW50c10gQXJyYXkgb2YgcG9pbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5MaW5lfSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocG9pbnRzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXBvaW50cykge1xuICAgICAgICBwb2ludHMgPSBbMCwgMCwgMCwgMF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuc2V0KCd4MScsIHBvaW50c1swXSk7XG4gICAgICB0aGlzLnNldCgneTEnLCBwb2ludHNbMV0pO1xuICAgICAgdGhpcy5zZXQoJ3gyJywgcG9pbnRzWzJdKTtcbiAgICAgIHRoaXMuc2V0KCd5MicsIHBvaW50c1szXSk7XG5cbiAgICAgIHRoaXMuX3NldFdpZHRoSGVpZ2h0KG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uc1xuICAgICAqL1xuICAgIF9zZXRXaWR0aEhlaWdodDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHRoaXMud2lkdGggPSBNYXRoLmFicyh0aGlzLngyIC0gdGhpcy54MSk7XG4gICAgICB0aGlzLmhlaWdodCA9IE1hdGguYWJzKHRoaXMueTIgLSB0aGlzLnkxKTtcblxuICAgICAgdGhpcy5sZWZ0ID0gJ2xlZnQnIGluIG9wdGlvbnNcbiAgICAgICAgPyBvcHRpb25zLmxlZnRcbiAgICAgICAgOiB0aGlzLl9nZXRMZWZ0VG9PcmlnaW5YKCk7XG5cbiAgICAgIHRoaXMudG9wID0gJ3RvcCcgaW4gb3B0aW9uc1xuICAgICAgICA/IG9wdGlvbnMudG9wXG4gICAgICAgIDogdGhpcy5fZ2V0VG9wVG9PcmlnaW5ZKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3NldCcsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBjb29yZFByb3BzW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuX3NldFdpZHRoSGVpZ2h0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGxlZnRUb09yaWdpblggRGlzdGFuY2UgZnJvbSBsZWZ0IGVkZ2Ugb2YgY2FudmFzIHRvIG9yaWdpblggb2YgTGluZS5cbiAgICAgKi9cbiAgICBfZ2V0TGVmdFRvT3JpZ2luWDogbWFrZUVkZ2VUb09yaWdpbkdldHRlcihcbiAgICAgIHsgLy8gcHJvcGVydHkgbmFtZXNcbiAgICAgICAgb3JpZ2luOiAnb3JpZ2luWCcsXG4gICAgICAgIGF4aXMxOiAneDEnLFxuICAgICAgICBheGlzMjogJ3gyJyxcbiAgICAgICAgZGltZW5zaW9uOiAnd2lkdGgnXG4gICAgICB9LFxuICAgICAgeyAvLyBwb3NzaWJsZSB2YWx1ZXMgb2Ygb3JpZ2luXG4gICAgICAgIG5lYXJlc3Q6ICdsZWZ0JyxcbiAgICAgICAgY2VudGVyOiAnY2VudGVyJyxcbiAgICAgICAgZmFydGhlc3Q6ICdyaWdodCdcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRvcFRvT3JpZ2luWSBEaXN0YW5jZSBmcm9tIHRvcCBlZGdlIG9mIGNhbnZhcyB0byBvcmlnaW5ZIG9mIExpbmUuXG4gICAgICovXG4gICAgX2dldFRvcFRvT3JpZ2luWTogbWFrZUVkZ2VUb09yaWdpbkdldHRlcihcbiAgICAgIHsgLy8gcHJvcGVydHkgbmFtZXNcbiAgICAgICAgb3JpZ2luOiAnb3JpZ2luWScsXG4gICAgICAgIGF4aXMxOiAneTEnLFxuICAgICAgICBheGlzMjogJ3kyJyxcbiAgICAgICAgZGltZW5zaW9uOiAnaGVpZ2h0J1xuICAgICAgfSxcbiAgICAgIHsgLy8gcG9zc2libGUgdmFsdWVzIG9mIG9yaWdpblxuICAgICAgICBuZWFyZXN0OiAndG9wJyxcbiAgICAgICAgY2VudGVyOiAnY2VudGVyJyxcbiAgICAgICAgZmFydGhlc3Q6ICdib3R0b20nXG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG5cbiAgICAgIHZhciBwID0gdGhpcy5jYWxjTGluZVBvaW50cygpO1xuICAgICAgY3R4Lm1vdmVUbyhwLngxLCBwLnkxKTtcbiAgICAgIGN0eC5saW5lVG8ocC54MiwgcC55Mik7XG5cbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xuXG4gICAgICAvLyBUT0RPOiB0ZXN0IHRoaXNcbiAgICAgIC8vIG1ha2Ugc3VyZSBzZXR0aW5nIFwiZmlsbFwiIGNoYW5nZXMgY29sb3Igb2YgYSBsaW5lXG4gICAgICAvLyAoYnkgY29weWluZyBmaWxsU3R5bGUgdG8gc3Ryb2tlU3R5bGUsIHNpbmNlIGxpbmUgaXMgc3Ryb2tlZCwgbm90IGZpbGxlZClcbiAgICAgIHZhciBvcmlnU3Ryb2tlU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZSB8fCBjdHguZmlsbFN0eWxlO1xuICAgICAgdGhpcy5zdHJva2UgJiYgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcmlnU3Ryb2tlU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYW4gaGVscGVyIGZvciBzdmcgaW1wb3J0LiBpdCByZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIG9iamVjdCBpbiB0aGUgc3ZnXG4gICAgICogdW50cmFuc2Zvcm1lZCBjb29yZGluYXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgcG9pbnQgZnJvbSBlbGVtZW50IGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgX2ZpbmRDZW50ZXJGcm9tRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAodGhpcy54MSArIHRoaXMueDIpIC8gMixcbiAgICAgICAgeTogKHRoaXMueTEgKyB0aGlzLnkyKSAvIDIsXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBtZXRob2QgdG9PYmplY3RcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwgdGhpcy5jYWxjTGluZVBvaW50cygpKTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGltID0gdGhpcy5jYWxsU3VwZXIoJ19nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMnKTtcbiAgICAgIGlmICh0aGlzLnN0cm9rZUxpbmVDYXAgPT09ICdidXR0Jykge1xuICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCkge1xuICAgICAgICAgIGRpbS55IC09IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgZGltLnggLT0gdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRpbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGVzIGxpbmUgcG9pbnRzIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNhbGNMaW5lUG9pbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB4TXVsdCA9IHRoaXMueDEgPD0gdGhpcy54MiA/IC0xIDogMSxcbiAgICAgICAgICB5TXVsdCA9IHRoaXMueTEgPD0gdGhpcy55MiA/IC0xIDogMSxcbiAgICAgICAgICB4MSA9ICh4TXVsdCAqIHRoaXMud2lkdGggKiAwLjUpLFxuICAgICAgICAgIHkxID0gKHlNdWx0ICogdGhpcy5oZWlnaHQgKiAwLjUpLFxuICAgICAgICAgIHgyID0gKHhNdWx0ICogdGhpcy53aWR0aCAqIC0wLjUpLFxuICAgICAgICAgIHkyID0gKHlNdWx0ICogdGhpcy5oZWlnaHQgKiAtMC41KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeTI6IHkyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwID0gdGhpcy5jYWxjTGluZVBvaW50cygpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxsaW5lICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAneDE9XCInLCBwLngxLFxuICAgICAgICAnXCIgeTE9XCInLCBwLnkxLFxuICAgICAgICAnXCIgeDI9XCInLCBwLngyLFxuICAgICAgICAnXCIgeTI9XCInLCBwLnkyLFxuICAgICAgICAnXCIgLz5cXG4nXG4gICAgICBdO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkxpbmUuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuTGluZVxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNMaW5lRWxlbWVudFxuICAgKi9cbiAgZmFicmljLkxpbmUuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgneDEgeTEgeDIgeTInLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5MaW5lIGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkxpbmVcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgYWZ0ZXIgcGFyc2luZ1xuICAgKi9cbiAgZmFicmljLkxpbmUuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLkxpbmUuQVRUUklCVVRFX05BTUVTKSxcbiAgICAgICAgcG9pbnRzID0gW1xuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMueDEgfHwgMCxcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLnkxIHx8IDAsXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy54MiB8fCAwLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMueTIgfHwgMFxuICAgICAgICBdO1xuICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuTGluZShwb2ludHMsIGV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSkpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5MaW5lIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5MaW5lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgZmFicmljLkxpbmUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBfY2FsbGJhY2soaW5zdGFuY2UpIHtcbiAgICAgIGRlbGV0ZSBpbnN0YW5jZS5wb2ludHM7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgfTtcbiAgICB2YXIgb3B0aW9ucyA9IGNsb25lKG9iamVjdCwgdHJ1ZSk7XG4gICAgb3B0aW9ucy5wb2ludHMgPSBbb2JqZWN0LngxLCBvYmplY3QueTEsIG9iamVjdC54Miwgb2JqZWN0LnkyXTtcbiAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdMaW5lJywgb3B0aW9ucywgX2NhbGxiYWNrLCAncG9pbnRzJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIGEgZnVuY3Rpb24gdGhhdCBjYWxjdWxhdGVzIGRpc3RhbmNlIGZyb20gY2FudmFzIGVkZ2UgdG8gTGluZSBvcmlnaW4uXG4gICAqL1xuICBmdW5jdGlvbiBtYWtlRWRnZVRvT3JpZ2luR2V0dGVyKHByb3BlcnR5TmFtZXMsIG9yaWdpblZhbHVlcykge1xuICAgIHZhciBvcmlnaW4gPSBwcm9wZXJ0eU5hbWVzLm9yaWdpbixcbiAgICAgICAgYXhpczEgPSBwcm9wZXJ0eU5hbWVzLmF4aXMxLFxuICAgICAgICBheGlzMiA9IHByb3BlcnR5TmFtZXMuYXhpczIsXG4gICAgICAgIGRpbWVuc2lvbiA9IHByb3BlcnR5TmFtZXMuZGltZW5zaW9uLFxuICAgICAgICBuZWFyZXN0ID0gb3JpZ2luVmFsdWVzLm5lYXJlc3QsXG4gICAgICAgIGNlbnRlciA9IG9yaWdpblZhbHVlcy5jZW50ZXIsXG4gICAgICAgIGZhcnRoZXN0ID0gb3JpZ2luVmFsdWVzLmZhcnRoZXN0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgc3dpdGNoICh0aGlzLmdldChvcmlnaW4pKSB7XG4gICAgICAgIGNhc2UgbmVhcmVzdDpcbiAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5nZXQoYXhpczEpLCB0aGlzLmdldChheGlzMikpO1xuICAgICAgICBjYXNlIGNlbnRlcjpcbiAgICAgICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5nZXQoYXhpczEpLCB0aGlzLmdldChheGlzMikpICsgKDAuNSAqIHRoaXMuZ2V0KGRpbWVuc2lvbikpO1xuICAgICAgICBjYXNlIGZhcnRoZXN0OlxuICAgICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmdldChheGlzMSksIHRoaXMuZ2V0KGF4aXMyKSk7XG4gICAgICB9XG4gICAgfTtcblxuICB9XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zO1xuXG4gIGlmIChmYWJyaWMuQ2lyY2xlKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5DaXJjbGUgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjbGUgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5DaXJjbGVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuQ2lyY2xlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuQ2lyY2xlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuQ2lyY2xlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2NpcmNsZScsXG5cbiAgICAvKipcbiAgICAgKiBSYWRpdXMgb2YgdGhpcyBjaXJjbGVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJhZGl1czogMCxcblxuICAgIC8qKlxuICAgICAqIGRlZ3JlZXMgb2Ygc3RhcnQgb2YgdGhlIGNpcmNsZS5cbiAgICAgKiBwcm9iYWJseSB3aWxsIGNoYW5nZSB0byBkZWdyZWVzIGluIG5leHQgbWFqb3IgdmVyc2lvblxuICAgICAqIEB0eXBlIE51bWJlciAwIC0gMzU5XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHN0YXJ0QW5nbGU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBFbmQgYW5nbGUgb2YgdGhlIGNpcmNsZVxuICAgICAqIHByb2JhYmx5IHdpbGwgY2hhbmdlIHRvIGRlZ3JlZXMgaW4gbmV4dCBtYWpvciB2ZXJzaW9uXG4gICAgICogQHR5cGUgTnVtYmVyIDEgLSAzNjBcbiAgICAgKiBAZGVmYXVsdCAzNjBcbiAgICAgKi9cbiAgICBlbmRBbmdsZTogMzYwLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdyYWRpdXMnLCAnc3RhcnRBbmdsZScsICdlbmRBbmdsZScpLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DaXJjbGV9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3NldCcsIGtleSwgdmFsdWUpO1xuXG4gICAgICBpZiAoa2V5ID09PSAncmFkaXVzJykge1xuICAgICAgICB0aGlzLnNldFJhZGl1cyh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgWydyYWRpdXMnLCAnc3RhcnRBbmdsZScsICdlbmRBbmdsZSddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3ZnU3RyaW5nLCB4ID0gMCwgeSA9IDAsXG4gICAgICAgICAgYW5nbGUgPSAodGhpcy5lbmRBbmdsZSAtIHRoaXMuc3RhcnRBbmdsZSkgJSAzNjA7XG5cbiAgICAgIGlmIChhbmdsZSA9PT0gMCkge1xuICAgICAgICBzdmdTdHJpbmcgPSBbXG4gICAgICAgICAgJzxjaXJjbGUgJywgJ0NPTU1PTl9QQVJUUycsXG4gICAgICAgICAgJ2N4PVwiJyArIHggKyAnXCIgY3k9XCInICsgeSArICdcIiAnLFxuICAgICAgICAgICdyPVwiJywgdGhpcy5yYWRpdXMsXG4gICAgICAgICAgJ1wiIC8+XFxuJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBzdGFydCA9IGRlZ3JlZXNUb1JhZGlhbnModGhpcy5zdGFydEFuZ2xlKSxcbiAgICAgICAgICAgIGVuZCA9IGRlZ3JlZXNUb1JhZGlhbnModGhpcy5lbmRBbmdsZSksXG4gICAgICAgICAgICByYWRpdXMgPSB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAgIHN0YXJ0WCA9IGZhYnJpYy51dGlsLmNvcyhzdGFydCkgKiByYWRpdXMsXG4gICAgICAgICAgICBzdGFydFkgPSBmYWJyaWMudXRpbC5zaW4oc3RhcnQpICogcmFkaXVzLFxuICAgICAgICAgICAgZW5kWCA9IGZhYnJpYy51dGlsLmNvcyhlbmQpICogcmFkaXVzLFxuICAgICAgICAgICAgZW5kWSA9IGZhYnJpYy51dGlsLnNpbihlbmQpICogcmFkaXVzLFxuICAgICAgICAgICAgbGFyZ2VGbGFnID0gYW5nbGUgPiAxODAgPyAnMScgOiAnMCc7XG4gICAgICAgIHN2Z1N0cmluZyA9IFtcbiAgICAgICAgICAnPHBhdGggZD1cIk0gJyArIHN0YXJ0WCArICcgJyArIHN0YXJ0WSxcbiAgICAgICAgICAnIEEgJyArIHJhZGl1cyArICcgJyArIHJhZGl1cyxcbiAgICAgICAgICAnIDAgJywgK2xhcmdlRmxhZyArICcgMScsICcgJyArIGVuZFggKyAnICcgKyBlbmRZLFxuICAgICAgICAgICdcIiAnLCAnQ09NTU9OX1BBUlRTJywgJyAvPlxcbidcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdmdTdHJpbmc7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5yYWRpdXMsXG4gICAgICAgIGRlZ3JlZXNUb1JhZGlhbnModGhpcy5zdGFydEFuZ2xlKSxcbiAgICAgICAgZGVncmVlc1RvUmFkaWFucyh0aGlzLmVuZEFuZ2xlKSxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBob3Jpem9udGFsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0UmFkaXVzWDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3JhZGl1cycpICogdGhpcy5nZXQoJ3NjYWxlWCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHZlcnRpY2FsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0UmFkaXVzWTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3JhZGl1cycpICogdGhpcy5nZXQoJ3NjYWxlWScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFuZCB1cGRhdGVzIHdpZHRoIGFjY29yZGluZ2x5KVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DaXJjbGV9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXRSYWRpdXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnJhZGl1cyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KCd3aWR0aCcsIHZhbHVlICogMikuc2V0KCdoZWlnaHQnLCB2YWx1ZSAqIDIpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkNpcmNsZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5DaXJjbGVcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0NpcmNsZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5DaXJjbGUuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgnY3ggY3kgcicuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5DaXJjbGV9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNpcmNsZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbnMgY2FsbGJhY2sgaW52b2tlZCBhZnRlciBwYXJzaW5nIGlzIGZpbmlzaGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHZhbHVlIG9mIGByYCBhdHRyaWJ1dGUgaXMgbWlzc2luZyBvciBpbnZhbGlkXG4gICAqL1xuICBmYWJyaWMuQ2lyY2xlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLkNpcmNsZS5BVFRSSUJVVEVfTkFNRVMpO1xuXG4gICAgaWYgKCFpc1ZhbGlkUmFkaXVzKHBhcnNlZEF0dHJpYnV0ZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIG9mIGByYCBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgYW5kIGNhbiBub3QgYmUgbmVnYXRpdmUnKTtcbiAgICB9XG5cbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgPSAocGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDApIC0gcGFyc2VkQXR0cmlidXRlcy5yYWRpdXM7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgPSAocGFyc2VkQXR0cmlidXRlcy50b3AgfHwgMCkgLSBwYXJzZWRBdHRyaWJ1dGVzLnJhZGl1cztcbiAgICBjYWxsYmFjayhuZXcgZmFicmljLkNpcmNsZShwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBpc1ZhbGlkUmFkaXVzKGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKCgncmFkaXVzJyBpbiBhdHRyaWJ1dGVzKSAmJiAoYXR0cmlidXRlcy5yYWRpdXMgPj0gMCkpO1xuICB9XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5DaXJjbGV9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5DaXJjbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBmYWJyaWMuQ2lyY2xlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnQ2lyY2xlJywgb2JqZWN0LCBjYWxsYmFjayk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLlRyaWFuZ2xlKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5UcmlhbmdsZSBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogVHJpYW5nbGUgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5UcmlhbmdsZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5UcmlhbmdsZX0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuVHJpYW5nbGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5UcmlhbmdsZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlRyaWFuZ2xlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3RyaWFuZ2xlJyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIGlzIHNldCB0byAxMDAgdG8gY29tcGVuc2F0ZSB0aGUgb2xkIGluaXRpYWxpemUgY29kZSB0aGF0IHdhcyBzZXR0aW5nIGl0IHRvIDEwMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgd2lkdGg6IDEwMCxcblxuICAgIC8qKlxuICAgICAqIEhlaWdodCBpcyBzZXQgdG8gMTAwIHRvIGNvbXBlbnNhdGUgdGhlIG9sZCBpbml0aWFsaXplIGNvZGUgdGhhdCB3YXMgc2V0dGluZyBpdCB0byAxMDBcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhlaWdodDogMTAwLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgd2lkdGhCeTIgPSB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgICBoZWlnaHRCeTIgPSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oLXdpZHRoQnkyLCBoZWlnaHRCeTIpO1xuICAgICAgY3R4LmxpbmVUbygwLCAtaGVpZ2h0QnkyKTtcbiAgICAgIGN0eC5saW5lVG8od2lkdGhCeTIsIGhlaWdodEJ5Mik7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB3aWR0aEJ5MiA9IHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIGhlaWdodEJ5MiA9IHRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgICAtd2lkdGhCeTIgKyAnICcgKyBoZWlnaHRCeTIsXG4gICAgICAgICAgICAnMCAnICsgLWhlaWdodEJ5MixcbiAgICAgICAgICAgIHdpZHRoQnkyICsgJyAnICsgaGVpZ2h0QnkyXG4gICAgICAgICAgXS5qb2luKCcsJyk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPHBvbHlnb24gJywgJ0NPTU1PTl9QQVJUUycsXG4gICAgICAgICdwb2ludHM9XCInLCBwb2ludHMsXG4gICAgICAgICdcIiAvPidcbiAgICAgIF07XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5UcmlhbmdsZX0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRyaWFuZ2xlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgZmFicmljLlRyaWFuZ2xlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1RyaWFuZ2xlJywgb2JqZWN0LCBjYWxsYmFjayk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIHBpQnkyICAgPSBNYXRoLlBJICogMjtcblxuICBpZiAoZmFicmljLkVsbGlwc2UpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkVsbGlwc2UgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbGxpcHNlIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuRWxsaXBzZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5FbGxpcHNlfSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5FbGxpcHNlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuRWxsaXBzZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLkVsbGlwc2UucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnZWxsaXBzZScsXG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIHJhZGl1c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcng6ICAgMCxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIHJhZGl1c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcnk6ICAgMCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncngnLCAncnknKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5FbGxpcHNlfSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0KCdyeCcsIG9wdGlvbnMgJiYgb3B0aW9ucy5yeCB8fCAwKTtcbiAgICAgIHRoaXMuc2V0KCdyeScsIG9wdGlvbnMgJiYgb3B0aW9ucy5yeSB8fCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5FbGxpcHNlfSB0aGlzQXJnXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXQnLCBrZXksIHZhbHVlKTtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG5cbiAgICAgICAgY2FzZSAncngnOlxuICAgICAgICAgIHRoaXMucnggPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNldCgnd2lkdGgnLCB2YWx1ZSAqIDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3J5JzpcbiAgICAgICAgICB0aGlzLnJ5ID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zZXQoJ2hlaWdodCcsIHZhbHVlICogMik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhvcml6b250YWwgcmFkaXVzIG9mIGFuIG9iamVjdCAoYWNjb3JkaW5nIHRvIGhvdyBhbiBvYmplY3QgaXMgc2NhbGVkKVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSeDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3J4JykgKiB0aGlzLmdldCgnc2NhbGVYJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgVmVydGljYWwgcmFkaXVzIG9mIGFuIG9iamVjdCAoYWNjb3JkaW5nIHRvIGhvdyBhbiBvYmplY3QgaXMgc2NhbGVkKVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSeTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3J5JykgKiB0aGlzLmdldCgnc2NhbGVZJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3J4JywgJ3J5J10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPGVsbGlwc2UgJywgJ0NPTU1PTl9QQVJUUycsXG4gICAgICAgICdjeD1cIjBcIiBjeT1cIjBcIiAnLFxuICAgICAgICAncng9XCInLCB0aGlzLnJ4LFxuICAgICAgICAnXCIgcnk9XCInLCB0aGlzLnJ5LFxuICAgICAgICAnXCIgLz5cXG4nXG4gICAgICBdO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKDEsIDAsIDAsIHRoaXMucnkgLyB0aGlzLnJ4LCAwLCAwKTtcbiAgICAgIGN0eC5hcmMoXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMucngsXG4gICAgICAgIDAsXG4gICAgICAgIHBpQnkyLFxuICAgICAgICBmYWxzZSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuRWxsaXBzZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0VsbGlwc2VFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuRWxsaXBzZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCdjeCBjeSByeCByeScuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5FbGxpcHNlfSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gT3B0aW9ucyBjYWxsYmFjayBpbnZva2VkIGFmdGVyIHBhcnNpbmcgaXMgZmluaXNoZWRcbiAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9XG4gICAqL1xuICBmYWJyaWMuRWxsaXBzZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG5cbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLkVsbGlwc2UuQVRUUklCVVRFX05BTUVTKTtcblxuICAgIHBhcnNlZEF0dHJpYnV0ZXMubGVmdCA9IChwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgfHwgMCkgLSBwYXJzZWRBdHRyaWJ1dGVzLnJ4O1xuICAgIHBhcnNlZEF0dHJpYnV0ZXMudG9wID0gKHBhcnNlZEF0dHJpYnV0ZXMudG9wIHx8IDApIC0gcGFyc2VkQXR0cmlidXRlcy5yeTtcbiAgICBjYWxsYmFjayhuZXcgZmFicmljLkVsbGlwc2UocGFyc2VkQXR0cmlidXRlcykpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuRWxsaXBzZX0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkVsbGlwc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBmYWJyaWMuRWxsaXBzZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0VsbGlwc2UnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZDtcblxuICBpZiAoZmFicmljLlJlY3QpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlJlY3QgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3RhbmdsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlJlY3RcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUmVjdH0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUmVjdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlJlY3QgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5SZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBzdGF0ZSBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoe0BsaW5rIGZhYnJpYy5PYmplY3QjaGFzU3RhdGVDaGFuZ2VkfSlcbiAgICAgKiBhcyB3ZWxsIGFzIGZvciBoaXN0b3J5ICh1bmRvL3JlZG8pIHB1cnBvc2VzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdGF0ZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoJ3J4JywgJ3J5JyksXG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3JlY3QnLFxuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCBib3JkZXIgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeDogICAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgYm9yZGVyIHJhZGl1c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcnk6ICAgMCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncngnLCAncnknKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0UnhSeSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyByeC9yeSBhdHRyaWJ1dGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFJ4Unk6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucnggJiYgIXRoaXMucnkpIHtcbiAgICAgICAgdGhpcy5yeSA9IHRoaXMucng7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnJ5ICYmICF0aGlzLnJ4KSB7XG4gICAgICAgIHRoaXMucnggPSB0aGlzLnJ5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcblxuICAgICAgLy8gMXgxIGNhc2UgKHVzZWQgaW4gc3ByYXkgYnJ1c2gpIG9wdGltaXphdGlvbiB3YXMgcmVtb3ZlZCBiZWNhdXNlXG4gICAgICAvLyB3aXRoIGNhY2hpbmcgYW5kIGhpZ2hlciB6b29tIGxldmVsIHRoaXMgbWFrZXMgbW9yZSBkYW1hZ2UgdGhhbiBoZWxwXG5cbiAgICAgIHZhciByeCA9IHRoaXMucnggPyBNYXRoLm1pbih0aGlzLnJ4LCB0aGlzLndpZHRoIC8gMikgOiAwLFxuICAgICAgICAgIHJ5ID0gdGhpcy5yeSA/IE1hdGgubWluKHRoaXMucnksIHRoaXMuaGVpZ2h0IC8gMikgOiAwLFxuICAgICAgICAgIHcgPSB0aGlzLndpZHRoLFxuICAgICAgICAgIGggPSB0aGlzLmhlaWdodCxcbiAgICAgICAgICB4ID0gLXRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIHkgPSAtdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICAgIGlzUm91bmRlZCA9IHJ4ICE9PSAwIHx8IHJ5ICE9PSAwLFxuICAgICAgICAgIC8qIFwibWFnaWMgbnVtYmVyXCIgZm9yIGJlemllciBhcHByb3hpbWF0aW9ucyBvZiBhcmNzIChodHRwOi8vaXRjLmt0dS5sdC9pdGMzNTQvUmlza3VzMzU0LnBkZikgKi9cbiAgICAgICAgICBrID0gMSAtIDAuNTUyMjg0NzQ5ODtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgY3R4Lm1vdmVUbyh4ICsgcngsIHkpO1xuXG4gICAgICBjdHgubGluZVRvKHggKyB3IC0gcngsIHkpO1xuICAgICAgaXNSb3VuZGVkICYmIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyB3IC0gayAqIHJ4LCB5LCB4ICsgdywgeSArIGsgKiByeSwgeCArIHcsIHkgKyByeSk7XG5cbiAgICAgIGN0eC5saW5lVG8oeCArIHcsIHkgKyBoIC0gcnkpO1xuICAgICAgaXNSb3VuZGVkICYmIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyB3LCB5ICsgaCAtIGsgKiByeSwgeCArIHcgLSBrICogcngsIHkgKyBoLCB4ICsgdyAtIHJ4LCB5ICsgaCk7XG5cbiAgICAgIGN0eC5saW5lVG8oeCArIHJ4LCB5ICsgaCk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIGsgKiByeCwgeSArIGgsIHgsIHkgKyBoIC0gayAqIHJ5LCB4LCB5ICsgaCAtIHJ5KTtcblxuICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcnkpO1xuICAgICAgaXNSb3VuZGVkICYmIGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHkgKyBrICogcnksIHggKyBrICogcngsIHksIHggKyByeCwgeSk7XG5cbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3J4JywgJ3J5J10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeCA9IC10aGlzLndpZHRoIC8gMiwgeSA9IC10aGlzLmhlaWdodCAvIDI7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPHJlY3QgJywgJ0NPTU1PTl9QQVJUUycsXG4gICAgICAgICd4PVwiJywgeCwgJ1wiIHk9XCInLCB5LFxuICAgICAgICAnXCIgcng9XCInLCB0aGlzLnJ4LCAnXCIgcnk9XCInLCB0aGlzLnJ5LFxuICAgICAgICAnXCIgd2lkdGg9XCInLCB0aGlzLndpZHRoLCAnXCIgaGVpZ2h0PVwiJywgdGhpcy5oZWlnaHQsXG4gICAgICAgICdcIiAvPlxcbidcbiAgICAgIF07XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IGBmYWJyaWMuUmVjdC5mcm9tRWxlbWVudGApXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5SZWN0XG4gICAqIEBzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNSZWN0RWxlbWVudFxuICAgKi9cbiAgZmFicmljLlJlY3QuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgneCB5IHJ4IHJ5IHdpZHRoIGhlaWdodCcuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5SZWN0fSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5SZWN0XG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgYWZ0ZXIgcGFyc2luZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuUmVjdC5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcblxuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuUmVjdC5BVFRSSUJVVEVfTkFNRVMpO1xuICAgIHBhcnNlZEF0dHJpYnV0ZXMubGVmdCA9IHBhcnNlZEF0dHJpYnV0ZXMubGVmdCB8fCAwO1xuICAgIHBhcnNlZEF0dHJpYnV0ZXMudG9wICA9IHBhcnNlZEF0dHJpYnV0ZXMudG9wICB8fCAwO1xuICAgIHBhcnNlZEF0dHJpYnV0ZXMuaGVpZ2h0ICA9IHBhcnNlZEF0dHJpYnV0ZXMuaGVpZ2h0IHx8IDA7XG4gICAgcGFyc2VkQXR0cmlidXRlcy53aWR0aCAgPSBwYXJzZWRBdHRyaWJ1dGVzLndpZHRoIHx8IDA7XG4gICAgdmFyIHJlY3QgPSBuZXcgZmFicmljLlJlY3QoZXh0ZW5kKChvcHRpb25zID8gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9wdGlvbnMpIDogeyB9KSwgcGFyc2VkQXR0cmlidXRlcykpO1xuICAgIHJlY3QudmlzaWJsZSA9IHJlY3QudmlzaWJsZSAmJiByZWN0LndpZHRoID4gMCAmJiByZWN0LmhlaWdodCA+IDA7XG4gICAgY2FsbGJhY2socmVjdCk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5SZWN0fSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUmVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5SZWN0IGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5SZWN0LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1JlY3QnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIG1pbiA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbixcbiAgICAgIG1heCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heCxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgcHJvamVjdFN0cm9rZU9uUG9pbnRzID0gZmFicmljLnV0aWwucHJvamVjdFN0cm9rZU9uUG9pbnRzO1xuXG4gIGlmIChmYWJyaWMuUG9seWxpbmUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlBvbHlsaW5lIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2x5bGluZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBvbHlsaW5lXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlBvbHlsaW5lI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuUG9seWxpbmUgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5Qb2x5bGluZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdwb2x5bGluZScsXG5cbiAgICAvKipcbiAgICAgKiBQb2ludHMgYXJyYXlcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcG9pbnRzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogV0FSTklORzogRmVhdHVyZSBpbiBwcm9ncmVzc1xuICAgICAqIENhbGN1bGF0ZSB0aGUgZXhhY3QgYm91bmRpbmcgYm94IHRha2luZyBpbiBhY2NvdW50IHN0cm9rZVdpZHRoIG9uIGFjdXRlIGFuZ2xlc1xuICAgICAqIHRoaXMgd2lsbCBiZSB0dXJuZWQgdG8gdHJ1ZSBieSBkZWZhdWx0IG9uIGZhYnJpYyA2LjBcbiAgICAgKiBtYXliZSB3aWxsIGJlIGxlZnQgaW4gYXMgYW4gb3B0aW1pemF0aW9uIHNpbmNlIGNhbGN1bGF0aW9ucyBtYXkgYmUgc2xvd1xuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZXhhY3RCb3VuZGluZ0JveDogZmFsc2UsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3BvaW50cycpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgQXJyYXkgb2YgcG9pbnRzICh3aGVyZSBlYWNoIHBvaW50IGlzIGFuIG9iamVjdCB3aXRoIHggYW5kIHkpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2x5bGluZX0gdGhpc0FyZ1xuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHBvbHkgPSBuZXcgZmFicmljLlBvbHlsaW5lKFtcbiAgICAgKiAgICAgeyB4OiAxMCwgeTogMTAgfSxcbiAgICAgKiAgICAgeyB4OiA1MCwgeTogMzAgfSxcbiAgICAgKiAgICAgeyB4OiA0MCwgeTogNzAgfSxcbiAgICAgKiAgICAgeyB4OiA2MCwgeTogNTAgfSxcbiAgICAgKiAgICAgeyB4OiAxMDAsIHk6IDE1MCB9LFxuICAgICAqICAgICB7IHg6IDQwLCB5OiAxMDAgfVxuICAgICAqICAgXSwge1xuICAgICAqICAgc3Ryb2tlOiAncmVkJyxcbiAgICAgKiAgIGxlZnQ6IDEwMCxcbiAgICAgKiAgIHRvcDogMTAwXG4gICAgICogfSk7XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ocG9pbnRzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzIHx8IFtdO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX3NldFBvc2l0aW9uRGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcHJvamVjdFN0cm9rZU9uUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcHJvamVjdFN0cm9rZU9uUG9pbnRzKHRoaXMucG9pbnRzLCB0aGlzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgX3NldFBvc2l0aW9uRGltZW5zaW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhbGNEaW0gPSB0aGlzLl9jYWxjRGltZW5zaW9ucyhvcHRpb25zKSwgY29ycmVjdExlZnRUb3AsXG4gICAgICAgICAgY29ycmVjdFNpemUgPSB0aGlzLmV4YWN0Qm91bmRpbmdCb3ggPyB0aGlzLnN0cm9rZVdpZHRoIDogMDtcbiAgICAgIHRoaXMud2lkdGggPSBjYWxjRGltLndpZHRoIC0gY29ycmVjdFNpemU7XG4gICAgICB0aGlzLmhlaWdodCA9IGNhbGNEaW0uaGVpZ2h0IC0gY29ycmVjdFNpemU7XG4gICAgICBpZiAoIW9wdGlvbnMuZnJvbVNWRykge1xuICAgICAgICBjb3JyZWN0TGVmdFRvcCA9IHRoaXMudHJhbnNsYXRlVG9HaXZlbk9yaWdpbihcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyB0aGlzIGxvb2tzIGJhZCwgYnV0IGlzIG9uZSB3YXkgdG8ga2VlcCBpdCBvcHRpb25hbCBmb3Igbm93LlxuICAgICAgICAgICAgeDogY2FsY0RpbS5sZWZ0IC0gdGhpcy5zdHJva2VXaWR0aCAvIDIgKyBjb3JyZWN0U2l6ZSAvIDIsXG4gICAgICAgICAgICB5OiBjYWxjRGltLnRvcCAtIHRoaXMuc3Ryb2tlV2lkdGggLyAyICsgY29ycmVjdFNpemUgLyAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnbGVmdCcsXG4gICAgICAgICAgJ3RvcCcsXG4gICAgICAgICAgdGhpcy5vcmlnaW5YLFxuICAgICAgICAgIHRoaXMub3JpZ2luWVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxlZnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMubGVmdCA9IG9wdGlvbnMuZnJvbVNWRyA/IGNhbGNEaW0ubGVmdCA6IGNvcnJlY3RMZWZ0VG9wLng7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9wID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnRvcCA9IG9wdGlvbnMuZnJvbVNWRyA/IGNhbGNEaW0udG9wIDogY29ycmVjdExlZnRUb3AueTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGF0aE9mZnNldCA9IHtcbiAgICAgICAgeDogY2FsY0RpbS5sZWZ0ICsgdGhpcy53aWR0aCAvIDIgKyBjb3JyZWN0U2l6ZSAvIDIsXG4gICAgICAgIHk6IGNhbGNEaW0udG9wICsgdGhpcy5oZWlnaHQgLyAyICsgY29ycmVjdFNpemUgLyAyXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvbHlnb24gbWluIGFuZCBtYXggcG9pbnQgZnJvbSBwb2ludHMgYXJyYXksXG4gICAgICogcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB0byBtZWFzdXJlIHRoZVxuICAgICAqIHBvbHlnb24gc2l6ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LmxlZnQgWCBjb29yZGluYXRlIG9mIHRoZSBwb2x5Z29uIGxlZnRtb3N0IHBvaW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QudG9wIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9seWdvbiB0b3Btb3N0IHBvaW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qud2lkdGggZGlzdGFuY2UgYmV0d2VlbiBYIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2x5Z29uIGxlZnRtb3N0IGFuZCByaWdodG1vc3QgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC5oZWlnaHQgZGlzdGFuY2UgYmV0d2VlbiBZIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2x5Z29uIHRvcG1vc3QgYW5kIGJvdHRvbW1vc3QgcG9pbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLmV4YWN0Qm91bmRpbmdCb3ggPyB0aGlzLl9wcm9qZWN0U3Ryb2tlT25Qb2ludHMoKSA6IHRoaXMucG9pbnRzLFxuICAgICAgICAgIG1pblggPSBtaW4ocG9pbnRzLCAneCcpIHx8IDAsXG4gICAgICAgICAgbWluWSA9IG1pbihwb2ludHMsICd5JykgfHwgMCxcbiAgICAgICAgICBtYXhYID0gbWF4KHBvaW50cywgJ3gnKSB8fCAwLFxuICAgICAgICAgIG1heFkgPSBtYXgocG9pbnRzLCAneScpIHx8IDAsXG4gICAgICAgICAgd2lkdGggPSAobWF4WCAtIG1pblgpLFxuICAgICAgICAgIGhlaWdodCA9IChtYXhZIC0gbWluWSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IG1pblgsXG4gICAgICAgIHRvcDogbWluWSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSksIHtcbiAgICAgICAgcG9pbnRzOiB0aGlzLnBvaW50cy5jb25jYXQoKVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvaW50cyA9IFtdLCBkaWZmWCA9IHRoaXMucGF0aE9mZnNldC54LCBkaWZmWSA9IHRoaXMucGF0aE9mZnNldC55LFxuICAgICAgICAgIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwb2ludHMucHVzaChcbiAgICAgICAgICB0b0ZpeGVkKHRoaXMucG9pbnRzW2ldLnggLSBkaWZmWCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksICcsJyxcbiAgICAgICAgICB0b0ZpeGVkKHRoaXMucG9pbnRzW2ldLnkgLSBkaWZmWSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksICcgJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzwnICsgdGhpcy50eXBlICsgJyAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ3BvaW50cz1cIicsIHBvaW50cy5qb2luKCcnKSxcbiAgICAgICAgJ1wiIC8+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBjb21tb25SZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHBvaW50LCBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGgsXG4gICAgICAgICAgeCA9IHRoaXMucGF0aE9mZnNldC54LFxuICAgICAgICAgIHkgPSB0aGlzLnBhdGhPZmZzZXQueTtcblxuICAgICAgaWYgKCFsZW4gfHwgaXNOYU4odGhpcy5wb2ludHNbbGVuIC0gMV0ueSkpIHtcbiAgICAgICAgLy8gZG8gbm90IGRyYXcgaWYgbm8gcG9pbnRzIG9yIG9kZCBwb2ludHNcbiAgICAgICAgLy8gTmFOIGNvbWVzIGZyb20gcGFyc2VGbG9hdCBvZiBhIGVtcHR5IHN0cmluZyBpbiBwYXJzZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh0aGlzLnBvaW50c1swXS54IC0geCwgdGhpcy5wb2ludHNbMF0ueSAtIHkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwb2ludCA9IHRoaXMucG9pbnRzW2ldO1xuICAgICAgICBjdHgubGluZVRvKHBvaW50LnggLSB4LCBwb2ludC55IC0geSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuY29tbW9uUmVuZGVyKGN0eCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoJ3BvaW50cycpLmxlbmd0aDtcbiAgICB9XG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlsaW5lXG4gICAqIEBzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNQb2x5bGluZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5Qb2x5bGluZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlBvbHlsaW5lIGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlsaW5lXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIGFmdGVyIHBhcnNpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50R2VuZXJhdG9yID0gZnVuY3Rpb24oX2NsYXNzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHZhciBwb2ludHMgPSBmYWJyaWMucGFyc2VQb2ludHNBdHRyaWJ1dGUoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpKSxcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWNbX2NsYXNzXS5BVFRSSUJVVEVfTkFNRVMpO1xuICAgICAgcGFyc2VkQXR0cmlidXRlcy5mcm9tU1ZHID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKG5ldyBmYWJyaWNbX2NsYXNzXShwb2ludHMsIGV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSkpO1xuICAgIH07XG4gIH07XG5cbiAgZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50ID0gZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50R2VuZXJhdG9yKCdQb2x5bGluZScpO1xuXG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlBvbHlsaW5lIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5bGluZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5QYXRoIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5Qb2x5bGluZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdQb2x5bGluZScsIG9iamVjdCwgY2FsbGJhY2ssICdwb2ludHMnKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7fSksXG4gICAgICBwcm9qZWN0U3Ryb2tlT25Qb2ludHMgPSBmYWJyaWMudXRpbC5wcm9qZWN0U3Ryb2tlT25Qb2ludHM7XG5cbiAgaWYgKGZhYnJpYy5Qb2x5Z29uKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Qb2x5Z29uIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb2x5Z29uIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9seWdvblxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuUG9seWxpbmVcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlBvbHlnb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLlBvbHlsaW5lLCAvKiogQGxlbmRzIGZhYnJpYy5Qb2x5Z29uLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BvbHlnb24nLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcHJvamVjdFN0cm9rZU9uUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcHJvamVjdFN0cm9rZU9uUG9pbnRzKHRoaXMucG9pbnRzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuY29tbW9uUmVuZGVyKGN0eCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5Qb2x5Z29uLmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlnb25cbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1BvbHlnb25FbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUG9seWdvbi5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5Qb2x5Z29ufSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5Z29uXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgYWZ0ZXIgcGFyc2luZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuUG9seWdvbi5mcm9tRWxlbWVudCA9IGZhYnJpYy5Qb2x5bGluZS5mcm9tRWxlbWVudEdlbmVyYXRvcignUG9seWdvbicpO1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5Qb2x5Z29uIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5Z29uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgZmFicmljLlBvbHlnb24uZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdQb2x5Z29uJywgb2JqZWN0LCBjYWxsYmFjaywgJ3BvaW50cycpO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBtaW4gPSBmYWJyaWMudXRpbC5hcnJheS5taW4sXG4gICAgICBtYXggPSBmYWJyaWMudXRpbC5hcnJheS5tYXgsXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZDtcblxuICBpZiAoZmFicmljLlBhdGgpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlBhdGggaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdGggY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QYXRoXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjcGF0aF9hbmRfcGF0aGdyb3VwfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUGF0aCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlBhdGggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5QYXRoLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BhdGgnLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcGF0aCBwb2ludHNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGF0aDogbnVsbCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncGF0aCcsICdmaWxsUnVsZScpLFxuXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KCdwYXRoJyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBwYXRoIFBhdGggZGF0YSAoc2VxdWVuY2Ugb2YgY29vcmRpbmF0ZXMgYW5kIGNvcnJlc3BvbmRpbmcgXCJjb21tYW5kXCIgdG9rZW5zKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGF0aH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gY2xvbmUob3B0aW9ucyB8fCB7fSk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5wYXRoO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX3NldFBhdGgocGF0aCB8fCBbXSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBwYXRoIFBhdGggZGF0YSAoc2VxdWVuY2Ugb2YgY29vcmRpbmF0ZXMgYW5kIGNvcnJlc3BvbmRpbmcgXCJjb21tYW5kXCIgdG9rZW5zKVxuICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICovXG4gICAgX3NldFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICB0aGlzLnBhdGggPSBmYWJyaWMudXRpbC5tYWtlUGF0aFNpbXBsZXIoXG4gICAgICAgIEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogZmFicmljLnV0aWwucGFyc2VQYXRoKHBhdGgpXG4gICAgICApO1xuXG4gICAgICBmYWJyaWMuUG9seWxpbmUucHJvdG90eXBlLl9zZXRQb3NpdGlvbkRpbWVuc2lvbnMuY2FsbCh0aGlzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIHBhdGggb25cbiAgICAgKi9cbiAgICBfcmVuZGVyUGF0aENvbW1hbmRzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBjdXJyZW50LCAvLyBjdXJyZW50IGluc3RydWN0aW9uXG4gICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IDAsXG4gICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IDAsXG4gICAgICAgICAgeCA9IDAsIC8vIGN1cnJlbnQgeFxuICAgICAgICAgIHkgPSAwLCAvLyBjdXJyZW50IHlcbiAgICAgICAgICBjb250cm9sWCA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB4XG4gICAgICAgICAgY29udHJvbFkgPSAwLCAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeVxuICAgICAgICAgIGwgPSAtdGhpcy5wYXRoT2Zmc2V0LngsXG4gICAgICAgICAgdCA9IC10aGlzLnBhdGhPZmZzZXQueTtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wYXRoLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cbiAgICAgICAgY3VycmVudCA9IHRoaXMucGF0aFtpXTtcblxuICAgICAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy8gZmlyc3QgbGV0dGVyXG5cbiAgICAgICAgICBjYXNlICdMJzogLy8gbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTSc6IC8vIG1vdmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRYID0geDtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSB5O1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdDJzogLy8gYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICAgICAgeCArIGwsXG4gICAgICAgICAgICAgIHkgKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdRJzogLy8gcXVhZHJhdGljQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10gKyBsLFxuICAgICAgICAgICAgICBjdXJyZW50WzRdICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgeCA9IHN1YnBhdGhTdGFydFg7XG4gICAgICAgICAgICB5ID0gc3VicGF0aFN0YXJ0WTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBwYXRoIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJQYXRoQ29tbWFuZHMoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5QYXRoICgnICsgdGhpcy5jb21wbGV4aXR5KCkgK1xuICAgICAgICAnKTogeyBcInRvcFwiOiAnICsgdGhpcy50b3AgKyAnLCBcImxlZnRcIjogJyArIHRoaXMubGVmdCArICcgfT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB7XG4gICAgICAgIHBhdGg6IHRoaXMucGF0aC5tYXAoZnVuY3Rpb24oaXRlbSkgeyByZXR1cm4gaXRlbS5zbGljZSgpOyB9KSxcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRhdGFsZXNzIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvRGF0YWxlc3NPYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvID0gdGhpcy50b09iamVjdChbJ3NvdXJjZVBhdGgnXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSkpO1xuICAgICAgaWYgKG8uc291cmNlUGF0aCkge1xuICAgICAgICBkZWxldGUgby5wYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG87XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSBmYWJyaWMudXRpbC5qb2luUGF0aCh0aGlzLnBhdGgpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxwYXRoICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAnZD1cIicsIHBhdGgsXG4gICAgICAgICdcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgJyxcbiAgICAgICAgJy8+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuXG4gICAgX2dldE9mZnNldFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGlnaXRzID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuICAgICAgcmV0dXJuICcgdHJhbnNsYXRlKCcgKyB0b0ZpeGVkKC10aGlzLnBhdGhPZmZzZXQueCwgZGlnaXRzKSArICcsICcgK1xuICAgICAgICAgIHRvRml4ZWQoLXRoaXMucGF0aE9mZnNldC55LCBkaWdpdHMpICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyBjbGlwUGF0aCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0NsaXBQYXRoU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgYWRkaXRpb25hbFRyYW5zZm9ybSA9IHRoaXMuX2dldE9mZnNldFRyYW5zZm9ybSgpO1xuICAgICAgcmV0dXJuICdcXHQnICsgdGhpcy5fY3JlYXRlQmFzZUNsaXBQYXRoU1ZHTWFya3VwKFxuICAgICAgICB0aGlzLl90b1NWRygpLCB7IHJldml2ZXI6IHJldml2ZXIsIGFkZGl0aW9uYWxUcmFuc2Zvcm06IGFkZGl0aW9uYWxUcmFuc2Zvcm0gfVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBhZGRpdGlvbmFsVHJhbnNmb3JtID0gdGhpcy5fZ2V0T2Zmc2V0VHJhbnNmb3JtKCk7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCh0aGlzLl90b1NWRygpLCB7IHJldml2ZXI6IHJldml2ZXIsIGFkZGl0aW9uYWxUcmFuc2Zvcm06IGFkZGl0aW9uYWxUcmFuc2Zvcm0gIH0pO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG51bWJlciByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZSBjb21wbGV4aXR5XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5IG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGgubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhWCA9IFtdLFxuICAgICAgICAgIGFZID0gW10sXG4gICAgICAgICAgY3VycmVudCwgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICAgICAgICAgIHN1YnBhdGhTdGFydFggPSAwLFxuICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSAwLFxuICAgICAgICAgIHggPSAwLCAvLyBjdXJyZW50IHhcbiAgICAgICAgICB5ID0gMCwgLy8gY3VycmVudCB5XG4gICAgICAgICAgYm91bmRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wYXRoLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cbiAgICAgICAgY3VycmVudCA9IHRoaXMucGF0aFtpXTtcblxuICAgICAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy8gZmlyc3QgbGV0dGVyXG5cbiAgICAgICAgICBjYXNlICdMJzogLy8gbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIGJvdW5kcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdNJzogLy8gbW92ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFggPSB4O1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IHk7XG4gICAgICAgICAgICBib3VuZHMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQyc6IC8vIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNl1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdRJzogLy8gcXVhZHJhdGljQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUoeCwgeSxcbiAgICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgICAgY3VycmVudFs0XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgeCA9IHN1YnBhdGhTdGFydFg7XG4gICAgICAgICAgICB5ID0gc3VicGF0aFN0YXJ0WTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJvdW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICAgIGFYLnB1c2gocG9pbnQueCk7XG4gICAgICAgICAgYVkucHVzaChwb2ludC55KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFYLnB1c2goeCk7XG4gICAgICAgIGFZLnB1c2goeSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtaW5YID0gbWluKGFYKSB8fCAwLFxuICAgICAgICAgIG1pblkgPSBtaW4oYVkpIHx8IDAsXG4gICAgICAgICAgbWF4WCA9IG1heChhWCkgfHwgMCxcbiAgICAgICAgICBtYXhZID0gbWF4KGFZKSB8fCAwLFxuICAgICAgICAgIGRlbHRhWCA9IG1heFggLSBtaW5YLFxuICAgICAgICAgIGRlbHRhWSA9IG1heFkgLSBtaW5ZO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBtaW5YLFxuICAgICAgICB0b3A6IG1pblksXG4gICAgICAgIHdpZHRoOiBkZWx0YVgsXG4gICAgICAgIGhlaWdodDogZGVsdGFZXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZmFicmljLlBhdGggZnJvbSBhbiBvYmplY3RcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBhdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5QYXRoIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5QYXRoLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvYmplY3Quc291cmNlUGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwYXRoVXJsID0gb2JqZWN0LnNvdXJjZVBhdGg7XG4gICAgICBmYWJyaWMubG9hZFNWR0Zyb21VUkwocGF0aFVybCwgZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBwYXRoID0gZWxlbWVudHNbMF07XG4gICAgICAgIHBhdGguc2V0T3B0aW9ucyhvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0LmNsaXBQYXRoKSB7XG4gICAgICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMoW29iamVjdC5jbGlwUGF0aF0sIGZ1bmN0aW9uKGVsaXZlbmVkT2JqZWN0cykge1xuICAgICAgICAgICAgcGF0aC5jbGlwUGF0aCA9IGVsaXZlbmVkT2JqZWN0c1swXTtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHBhdGgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdQYXRoJywgb2JqZWN0LCBjYWxsYmFjaywgJ3BhdGgnKTtcbiAgICB9XG4gIH07XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IGBmYWJyaWMuUGF0aC5mcm9tRWxlbWVudGApXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5QYXRoXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aEVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5QYXRoLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoWydkJ10pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5QYXRoIGZyb20gYW4gU1ZHIDxwYXRoPiBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5QYXRoXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUGF0aCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBPcHRpb25zIGNhbGxiYWNrIGludm9rZWQgYWZ0ZXIgcGFyc2luZyBpcyBmaW5pc2hlZFxuICAgKi9cbiAgZmFicmljLlBhdGguZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuUGF0aC5BVFRSSUJVVEVfTkFNRVMpO1xuICAgIHBhcnNlZEF0dHJpYnV0ZXMuZnJvbVNWRyA9IHRydWU7XG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5QYXRoKHBhcnNlZEF0dHJpYnV0ZXMuZCwgZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIG1pbiA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbixcbiAgICAgIG1heCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heDtcblxuICBpZiAoZmFicmljLkdyb3VwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEdyb3VwIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuR3JvdXBcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAbWl4ZXMgZmFicmljLkNvbGxlY3Rpb25cbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjZ3JvdXBzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuR3JvdXAjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5Hcm91cCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIGZhYnJpYy5Db2xsZWN0aW9uLCAvKiogQGxlbmRzIGZhYnJpYy5Hcm91cC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdncm91cCcsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBzdHJva2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZVdpZHRoOiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIGNsaWNrLCBtb3VzZW92ZXIsIG1vdXNlb3V0IGV2ZW50cyAmIGhvdmVyQ3Vyc29yIHNob3VsZCBhbHNvIGNoZWNrIGZvciBzdWJ0YXJnZXRzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3ViVGFyZ2V0Q2hlY2s6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogR3JvdXBzIGFyZSBjb250YWluZXIsIGRvIG5vdCByZW5kZXIgYW55dGhpbmcgb24gdGhleXIgb3duLCBlbmNlIG5vIGNhY2hlIHByb3BlcnRpZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIHNldE9uR3JvdXAgaXMgYSBtZXRob2QgdXNlZCBmb3IgVGV4dEJveCB0aGF0IGlzIG5vIG1vcmUgdXNlZCBzaW5jZSAyLjAuMCBUaGUgYmVoYXZpb3IgaXMgc3RpbGxcbiAgICAgKiBhdmFpbGFibGUgc2V0dGluZyB0aGlzIGJvb2xlYW4gdG8gdHJ1ZS5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB1c2VTZXRPbkdyb3VwOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdHMgR3JvdXAgb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc0FscmVhZHlHcm91cGVkXSBpZiB0cnVlLCBvYmplY3RzIGhhdmUgYmVlbiBncm91cGVkIGFscmVhZHkuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob2JqZWN0cywgb3B0aW9ucywgaXNBbHJlYWR5R3JvdXBlZCkge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICAvLyBpZiBvYmplY3RzIGVuY2xvc2VkIGluIGEgZ3JvdXAgaGF2ZSBiZWVuIGdyb3VwZWQgYWxyZWFkeSxcbiAgICAgIC8vIHdlIGNhbm5vdCBjaGFuZ2UgcHJvcGVydGllcyBvZiBvYmplY3RzLlxuICAgICAgLy8gVGh1cyB3ZSBuZWVkIHRvIHNldCBvcHRpb25zIHRvIGdyb3VwIHdpdGhvdXQgb2JqZWN0cyxcbiAgICAgIGlzQWxyZWFkeUdyb3VwZWQgJiYgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBvYmplY3RzIHx8IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLmdyb3VwID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0FscmVhZHlHcm91cGVkKSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuY2VudGVyUG9pbnQ7XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gc2V0IG9yaWdpbnMgYmVmb3JlIGNhbGN1bGF0aW5nIHRoZSBib3VuZGluZyBib3guXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIHRvcGxlZnQgY2FuIGJlIHNldCB3aXRoIHRoYXQgaW4gbWluZC5cbiAgICAgICAgLy8gaWYgc3BlY2lmaWMgdG9wIGFuZCBsZWZ0IGFyZSBwYXNzZWQsIGFyZSBvdmVyd3JpdHRlbiBsYXRlclxuICAgICAgICAvLyB3aXRoIHRoZSBjYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKVxuICAgICAgICBpZiAob3B0aW9ucy5vcmlnaW5YICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9yaWdpblggPSBvcHRpb25zLm9yaWdpblg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub3JpZ2luWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcmlnaW5ZID0gb3B0aW9ucy5vcmlnaW5ZO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGNvbWluZyBmcm9tIHN2ZyBpIGRvIG5vdCB3YW50IHRvIGNhbGMgYm91bmRzLlxuICAgICAgICAvLyBpIGFzc3VtZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBwYXNzZWQgYWxvbmcgb3B0aW9uc1xuICAgICAgICBjZW50ZXIgfHwgdGhpcy5fY2FsY0JvdW5kcygpO1xuICAgICAgICB0aGlzLl91cGRhdGVPYmplY3RzQ29vcmRzKGNlbnRlcik7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmNlbnRlclBvaW50O1xuICAgICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNBQ29vcmRzKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZU9iamVjdHNBQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBza2lwQ29udHJvbHMgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICl7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0uc2V0Q29vcmRzKHNraXBDb250cm9scyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcENvb3Jkc0NoYW5nZV0gaWYgdHJ1ZSwgY29vcmRpbmF0ZXMgb2Ygb2JqZWN0cyBlbmNsb3NlZCBpbiBhIGdyb3VwIGRvIG5vdCBjaGFuZ2VcbiAgICAgKi9cbiAgICBfdXBkYXRlT2JqZWN0c0Nvb3JkczogZnVuY3Rpb24oY2VudGVyKSB7XG4gICAgICB2YXIgY2VudGVyID0gY2VudGVyIHx8IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApe1xuICAgICAgICB0aGlzLl91cGRhdGVPYmplY3RDb29yZHModGhpcy5fb2JqZWN0c1tpXSwgY2VudGVyKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGNlbnRlciwgY3VycmVudCBjZW50ZXIgb2YgZ3JvdXAuXG4gICAgICovXG4gICAgX3VwZGF0ZU9iamVjdENvb3JkczogZnVuY3Rpb24ob2JqZWN0LCBjZW50ZXIpIHtcbiAgICAgIHZhciBvYmplY3RMZWZ0ID0gb2JqZWN0LmxlZnQsXG4gICAgICAgICAgb2JqZWN0VG9wID0gb2JqZWN0LnRvcCxcbiAgICAgICAgICBza2lwQ29udHJvbHMgPSB0cnVlO1xuXG4gICAgICBvYmplY3Quc2V0KHtcbiAgICAgICAgbGVmdDogb2JqZWN0TGVmdCAtIGNlbnRlci54LFxuICAgICAgICB0b3A6IG9iamVjdFRvcCAtIGNlbnRlci55XG4gICAgICB9KTtcbiAgICAgIG9iamVjdC5ncm91cCA9IHRoaXM7XG4gICAgICBvYmplY3Quc2V0Q29vcmRzKHNraXBDb250cm9scyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VuYXRpb24gb2YgYSBncm91cFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLkdyb3VwOiAoJyArIHRoaXMuY29tcGxleGl0eSgpICsgJyk+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBvYmplY3QgdG8gYSBncm91cDsgVGhlbiByZWNhbGN1bGF0ZXMgZ3JvdXAncyBkaW1lbnNpb24sIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYWRkV2l0aFVwZGF0ZTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgbmVzdGVkID0gISF0aGlzLmdyb3VwO1xuICAgICAgdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgICAgZmFicmljLnV0aWwucmVzZXRPYmplY3RUcmFuc2Zvcm0odGhpcyk7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgICAgICAvLyBpZiB0aGlzIGdyb3VwIGlzIGluc2lkZSBhbm90aGVyIGdyb3VwLCB3ZSBuZWVkIHRvIHByZSB0cmFuc2Zvcm0gdGhlIG9iamVjdFxuICAgICAgICAgIGZhYnJpYy51dGlsLnJlbW92ZVRyYW5zZm9ybUZyb21PYmplY3Qob2JqZWN0LCB0aGlzLmdyb3VwLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2JqZWN0cy5wdXNoKG9iamVjdCk7XG4gICAgICAgIG9iamVjdC5ncm91cCA9IHRoaXM7XG4gICAgICAgIG9iamVjdC5fc2V0KCdjYW52YXMnLCB0aGlzLmNhbnZhcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICB0aGlzLl91cGRhdGVPYmplY3RzQ29vcmRzKCk7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgICAgdGhpcy5ncm91cC5hZGRXaXRoVXBkYXRlKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIG9iamVjdCBmcm9tIGEgZ3JvdXA7IFRoZW4gcmVjYWxjdWxhdGVzIGdyb3VwJ3MgZGltZW5zaW9uLCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbW92ZVdpdGhVcGRhdGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgICAgZmFicmljLnV0aWwucmVzZXRPYmplY3RUcmFuc2Zvcm0odGhpcyk7XG5cbiAgICAgIHRoaXMucmVtb3ZlKG9iamVjdCk7XG4gICAgICB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICB0aGlzLl91cGRhdGVPYmplY3RzQ29vcmRzKCk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25PYmplY3RBZGRlZDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIG9iamVjdC5ncm91cCA9IHRoaXM7XG4gICAgICBvYmplY3QuX3NldCgnY2FudmFzJywgdGhpcy5jYW52YXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbk9iamVjdFJlbW92ZWQ6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICBkZWxldGUgb2JqZWN0Lmdyb3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7XG4gICAgICBpZiAodGhpcy51c2VTZXRPbkdyb3VwKSB7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLnNldE9uR3JvdXAoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICB0aGlzLl9vYmplY3RzW2ldLl9zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZhYnJpYy5PYmplY3QucHJvdG90eXBlLl9zZXQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIF9pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICB2YXIgb2Jqc1RvT2JqZWN0ID0gdGhpcy5fb2JqZWN0c1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICByZXR1cm4gIW9iai5leGNsdWRlRnJvbUV4cG9ydDtcbiAgICAgICAgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsRGVmYXVsdHMgPSBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgICAgb2JqLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gX2luY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICAgIHZhciBfb2JqID0gb2JqLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsRGVmYXVsdHM7XG4gICAgICAgICAgcmV0dXJuIF9vYmo7XG4gICAgICAgIH0pO1xuICAgICAgdmFyIG9iaiA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcywgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBvYmoub2JqZWN0cyA9IG9ianNUb09iamVjdDtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlLCBpbiBkYXRhbGVzcyBtb2RlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvRGF0YWxlc3NPYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvYmpzVG9PYmplY3QsIHNvdXJjZVBhdGggPSB0aGlzLnNvdXJjZVBhdGg7XG4gICAgICBpZiAoc291cmNlUGF0aCkge1xuICAgICAgICBvYmpzVG9PYmplY3QgPSBzb3VyY2VQYXRoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBfaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSB0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICBvYmpzVG9PYmplY3QgPSB0aGlzLl9vYmplY3RzLm1hcChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxEZWZhdWx0cyA9IG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgICBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBfaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgICAgdmFyIF9vYmogPSBvYmoudG9EYXRhbGVzc09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgICAgICBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBvcmlnaW5hbERlZmF1bHRzO1xuICAgICAgICAgIHJldHVybiBfb2JqO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS50b0RhdGFsZXNzT2JqZWN0LmNhbGwodGhpcywgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBvYmoub2JqZWN0cyA9IG9ianNUb09iamVjdDtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgaW5zdGFuY2Ugb24gYSBnaXZlbiBjb250ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBpbnN0YW5jZSBvblxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1Eb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdyZW5kZXInLCBjdHgpO1xuICAgICAgdGhpcy5fdHJhbnNmb3JtRG9uZSA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGUgaWYgdGhlIG9iamVjdCBzaG91bGQgY2FjaGUgb3Igbm90LiBDcmVhdGUgaXRzIG93biBjYWNoZSBsZXZlbFxuICAgICAqIG5lZWRzSXRzT3duQ2FjaGUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGRyYXdpbmcgbWV0aG9kIHJlcXVpcmVzXG4gICAgICogYSBjYWNoZSBzdGVwLiBOb25lIG9mIHRoZSBmYWJyaWMgY2xhc3NlcyByZXF1aXJlcyBpdC5cbiAgICAgKiBHZW5lcmFsbHkgeW91IGRvIG5vdCBjYWNoZSBvYmplY3RzIGluIGdyb3VwcyBiZWNhdXNlIHRoZSBncm91cCBpcyBhbHJlYWR5IGNhY2hlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNob3VsZENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvd25DYWNoZSA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnNob3VsZENhY2hlLmNhbGwodGhpcyk7XG4gICAgICBpZiAob3duQ2FjaGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fb2JqZWN0c1tpXS53aWxsRHJhd1NoYWRvdygpKSB7XG4gICAgICAgICAgICB0aGlzLm93bkNhY2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvd25DYWNoZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3Qgb3IgYSBjaGlsZCBvYmplY3Qgd2lsbCBjYXN0IGEgc2hhZG93XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB3aWxsRHJhd1NoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZmFicmljLk9iamVjdC5wcm90b3R5cGUud2lsbERyYXdTaGFkb3cuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9vYmplY3RzW2ldLndpbGxEcmF3U2hhZG93KCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGdyb3VwIG9yIGl0cyBwYXJlbnQgZ3JvdXAgYXJlIGNhY2hpbmcsIHJlY3Vyc2l2ZWx5IHVwXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc09uQUNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm93bkNhY2hpbmcgfHwgKHRoaXMuZ3JvdXAgJiYgdGhpcy5ncm91cC5pc09uQUNhY2hlKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBkcmF3aW5nIG9wZXJhdGlvbiBmb3IgYW4gb2JqZWN0IG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd09iamVjdDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLnJlbmRlcihjdHgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZHJhd0NsaXBQYXRoKGN0eCwgdGhpcy5jbGlwUGF0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGNhY2hlIGlzIGRpcnR5XG4gICAgICovXG4gICAgaXNDYWNoZURpcnR5OiBmdW5jdGlvbihza2lwQ2FudmFzKSB7XG4gICAgICBpZiAodGhpcy5jYWxsU3VwZXIoJ2lzQ2FjaGVEaXJ0eScsIHNraXBDYW52YXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN0YXRlZnVsbENhY2hlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9vYmplY3RzW2ldLmlzQ2FjaGVEaXJ0eSh0cnVlKSkge1xuICAgICAgICAgIGlmICh0aGlzLl9jYWNoZUNhbnZhcykge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBncm91cCBoYXMgbm90IGEgY2FjaGUgY2FudmFzIHRoZXJlIGlzIG5vdGhpbmcgdG8gY2xlYW5cbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5jYWNoZVdpZHRoIC8gdGhpcy56b29tWCwgeSA9IHRoaXMuY2FjaGVIZWlnaHQgLyB0aGlzLnpvb21ZO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LmNsZWFyUmVjdCgteCAvIDIsIC15IC8gMiwgeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIG9yaWdpbmFsIHN0YXRlIG9mIGVhY2ggb2YgZ3JvdXAgb2JqZWN0cyAob3JpZ2luYWwgc3RhdGUgaXMgdGhhdCB3aGljaCB3YXMgYmVmb3JlIGdyb3VwIHdhcyBjcmVhdGVkKS5cbiAgICAgKiBpZiB0aGUgbmVzdGVkIGJvb2xlYW4gaXMgdHJ1ZSwgdGhlIG9yaWdpbmFsIHN0YXRlIHdpbGwgYmUgcmVzdG9yZWQganVzdCBmb3IgdGhlXG4gICAgICogZmlyc3QgZ3JvdXAgYW5kIG5vdCBmb3IgYWxsIHRoZSBncm91cCBjaGFpblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBuZXN0ZWQgdGVsbCB0aGUgZnVuY3Rpb24gdG8gcmVzdG9yZSBvYmplY3Qgc3RhdGUgdXAgdG8gdGhlIHBhcmVudCBncm91cCBhbmQgbm90IG1vcmVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX3Jlc3RvcmVPYmplY3RzU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGdyb3VwTWF0cml4ID0gdGhpcy5jYWxjT3duTWF0cml4KCk7XG4gICAgICB0aGlzLl9vYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgX3RoaXMgPSB0aGlzO1xuICAgICAgICBmYWJyaWMudXRpbC5hZGRUcmFuc2Zvcm1Ub09iamVjdChvYmplY3QsIGdyb3VwTWF0cml4KTtcbiAgICAgICAgZGVsZXRlIG9iamVjdC5ncm91cDtcbiAgICAgICAgb2JqZWN0LnNldENvb3JkcygpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBncm91cCAocmVzdG9yaW5nIHN0YXRlIG9mIGl0cyBvYmplY3RzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIHdoZW4gZ3JvdXAgaXMgZGVzdHJveWVkIG9iamVjdHMgbmVlZHMgdG8gZ2V0IGEgcmVwYWludCB0byBiZSBldmVudHVhbGx5XG4gICAgICAvLyBkaXNwbGF5ZWQgb24gY2FudmFzLlxuICAgICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3Quc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignZGlzcG9zZScpO1xuICAgICAgdGhpcy5mb3JFYWNoT2JqZWN0KGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0LmRpc3Bvc2UgJiYgb2JqZWN0LmRpc3Bvc2UoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgZ3JvdXAgYW4gYWN0aXZlIHNlbGVjdGlvbiwgcmVtb3ZlIHRoZSBncm91cCBmcm9tIGNhbnZhc1xuICAgICAqIHRoZSBncm91cCBoYXMgdG8gYmUgb24gY2FudmFzIGZvciB0aGlzIHRvIHdvcmsuXG4gICAgICogQHJldHVybiB7ZmFicmljLkFjdGl2ZVNlbGVjdGlvbn0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB0b0FjdGl2ZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cywgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMudG9PYmplY3QoKTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm9iamVjdHM7XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gbmV3IGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24oW10pO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLnNldChvcHRpb25zKTtcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi50eXBlID0gJ2FjdGl2ZVNlbGVjdGlvbic7XG4gICAgICBjYW52YXMucmVtb3ZlKHRoaXMpO1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3QuZ3JvdXAgPSBhY3RpdmVTZWxlY3Rpb247XG4gICAgICAgIG9iamVjdC5kaXJ0eSA9IHRydWU7XG4gICAgICAgIGNhbnZhcy5hZGQob2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cyA9IG9iamVjdHM7XG4gICAgICBjYW52YXMuX2FjdGl2ZU9iamVjdCA9IGFjdGl2ZVNlbGVjdGlvbjtcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi5zZXRDb29yZHMoKTtcbiAgICAgIHJldHVybiBhY3RpdmVTZWxlY3Rpb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGEgZ3JvdXAgKHJlc3RvcmluZyBzdGF0ZSBvZiBpdHMgb2JqZWN0cylcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdW5ncm91cE9uQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXN0b3JlT2JqZWN0c1N0YXRlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29vcmRpbmF0ZXMgb2YgYWxsIG9iamVjdHMgaW5zaWRlIGdyb3VwXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldE9iamVjdHNDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNraXBDb250cm9scyA9IHRydWU7XG4gICAgICB0aGlzLmZvckVhY2hPYmplY3QoZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5zZXRDb29yZHMoc2tpcENvbnRyb2xzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGNCb3VuZHM6IGZ1bmN0aW9uKG9ubHlXaWR0aEhlaWdodCkge1xuICAgICAgdmFyIGFYID0gW10sXG4gICAgICAgICAgYVkgPSBbXSxcbiAgICAgICAgICBvLCBwcm9wLCBjb29yZHMsXG4gICAgICAgICAgcHJvcHMgPSBbJ3RyJywgJ2JyJywgJ2JsJywgJ3RsJ10sXG4gICAgICAgICAgaSA9IDAsIGlMZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aCxcbiAgICAgICAgICBqLCBqTGVuID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKCA7IGkgPCBpTGVuOyArK2kpIHtcbiAgICAgICAgbyA9IHRoaXMuX29iamVjdHNbaV07XG4gICAgICAgIGNvb3JkcyA9IG8uY2FsY0FDb29yZHMoKTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGorKykge1xuICAgICAgICAgIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgICBhWC5wdXNoKGNvb3Jkc1twcm9wXS54KTtcbiAgICAgICAgICBhWS5wdXNoKGNvb3Jkc1twcm9wXS55KTtcbiAgICAgICAgfVxuICAgICAgICBvLmFDb29yZHMgPSBjb29yZHM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2dldEJvdW5kcyhhWCwgYVksIG9ubHlXaWR0aEhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEJvdW5kczogZnVuY3Rpb24oYVgsIGFZLCBvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgIHZhciBtaW5YWSA9IG5ldyBmYWJyaWMuUG9pbnQobWluKGFYKSwgbWluKGFZKSksXG4gICAgICAgICAgbWF4WFkgPSBuZXcgZmFicmljLlBvaW50KG1heChhWCksIG1heChhWSkpLFxuICAgICAgICAgIHRvcCA9IG1pblhZLnkgfHwgMCwgbGVmdCA9IG1pblhZLnggfHwgMCxcbiAgICAgICAgICB3aWR0aCA9IChtYXhYWS54IC0gbWluWFkueCkgfHwgMCxcbiAgICAgICAgICBoZWlnaHQgPSAobWF4WFkueSAtIG1pblhZLnkpIHx8IDA7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGlmICghb25seVdpZHRoSGVpZ2h0KSB7XG4gICAgICAgIC8vIHRoZSBib3VuZGluZyBib3ggYWx3YXlzIGZpbmRzIHRoZSB0b3BsZWZ0IG1vc3QgY29ybmVyLlxuICAgICAgICAvLyB3aGF0ZXZlciBpcyB0aGUgZ3JvdXAgb3JpZ2luLCB3ZSBzZXQgdXAgaGVyZSB0aGUgbGVmdC90b3AgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb25CeU9yaWdpbih7IHg6IGxlZnQsIHk6IHRvcCB9LCAnbGVmdCcsICd0b3AnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBzdmdTdHJpbmcgPSBbJzxnICcsICdDT01NT05fUEFSVFMnLCAnID5cXG4nXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3ZnU3RyaW5nLnB1c2goJ1xcdFxcdCcsIHRoaXMuX29iamVjdHNbaV0udG9TVkcocmV2aXZlcikpO1xuICAgICAgfVxuICAgICAgc3ZnU3RyaW5nLnB1c2goJzwvZz5cXG4nKTtcbiAgICAgIHJldHVybiBzdmdTdHJpbmc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3R5bGVzLXN0cmluZyBmb3Igc3ZnLWV4cG9ydCwgc3BlY2lmaWMgdmVyc2lvbiBmb3IgZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcGFjaXR5ID0gdHlwZW9mIHRoaXMub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5vcGFjaXR5ICE9PSAxID9cbiAgICAgICAgICAgICdvcGFjaXR5OiAnICsgdGhpcy5vcGFjaXR5ICsgJzsnIDogJycsXG4gICAgICAgICAgdmlzaWJpbGl0eSA9IHRoaXMudmlzaWJsZSA/ICcnIDogJyB2aXNpYmlsaXR5OiBoaWRkZW47JztcbiAgICAgIHJldHVybiBbXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHRoaXMuZ2V0U3ZnRmlsdGVyKCksXG4gICAgICAgIHZpc2liaWxpdHlcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIGNsaXBQYXRoIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvQ2xpcFBhdGhTVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBzdmdTdHJpbmcgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgc3ZnU3RyaW5nLnB1c2goJ1xcdCcsIHRoaXMuX29iamVjdHNbaV0udG9DbGlwUGF0aFNWRyhyZXZpdmVyKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVCYXNlQ2xpcFBhdGhTVkdNYXJrdXAoc3ZnU3RyaW5nLCB7IHJldml2ZXI6IHJldml2ZXIgfSk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5Hcm91cH0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkdyb3VwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhIGdyb3VwIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBncm91cCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuR3JvdXAuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgb2JqZWN0cyA9IG9iamVjdC5vYmplY3RzLFxuICAgICAgICBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9iamVjdCwgdHJ1ZSk7XG4gICAgZGVsZXRlIG9wdGlvbnMub2JqZWN0cztcbiAgICBpZiAodHlwZW9mIG9iamVjdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBpdCBoYXMgdG8gYmUgYW4gdXJsIG9yIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgICAgZmFicmljLmxvYWRTVkdGcm9tVVJMKG9iamVjdHMsIGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBmYWJyaWMudXRpbC5ncm91cFNWR0VsZW1lbnRzKGVsZW1lbnRzLCBvYmplY3QsIG9iamVjdHMpO1xuICAgICAgICB2YXIgY2xpcFBhdGggPSBvcHRpb25zLmNsaXBQYXRoO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5jbGlwUGF0aDtcbiAgICAgICAgZ3JvdXAuc2V0KG9wdGlvbnMpO1xuICAgICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhbY2xpcFBhdGhdLCBmdW5jdGlvbihlbGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgICAgICAgIGdyb3VwLmNsaXBQYXRoID0gZWxpdmVuZWRPYmplY3RzWzBdO1xuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZ3JvdXApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKG9iamVjdHMsIGZ1bmN0aW9uIChlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0RW5saXZhYmxlcyhvYmplY3QsIG9wdGlvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobmV3IGZhYnJpYy5Hcm91cChlbmxpdmVuZWRPYmplY3RzLCBvcHRpb25zLCB0cnVlKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLkFjdGl2ZVNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHcm91cCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkFjdGl2ZVNlbGVjdGlvblxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuR3JvdXBcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTMjZ3JvdXBzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkdyb3VwLCAvKiogQGxlbmRzIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnYWN0aXZlU2VsZWN0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdHMgQWN0aXZlU2VsZWN0aW9uIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob2JqZWN0cywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLl9vYmplY3RzID0gb2JqZWN0cyB8fCBbXTtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5ncm91cCA9IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm9yaWdpblgpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5YID0gb3B0aW9ucy5vcmlnaW5YO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub3JpZ2luWSkge1xuICAgICAgICB0aGlzLm9yaWdpblkgPSBvcHRpb25zLm9yaWdpblk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICB0aGlzLl91cGRhdGVPYmplY3RzQ29vcmRzKCk7XG4gICAgICBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGUgYWN0aXZlU2VsZWN0aW9uIHRvIGEgbm9ybWFsIGdyb3VwLFxuICAgICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdGhhdCBhdXRvbWF0aWNhbGx5IGFkZHMgaXQgdG8gY2FudmFzIGFzXG4gICAgICogYWN0aXZlIG9iamVjdC4gbm8gZXZlbnRzIGZpcmVkLlxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH1cbiAgICAgKi9cbiAgICB0b0dyb3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cy5jb25jYXQoKTtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBbXTtcbiAgICAgIHZhciBvcHRpb25zID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzKTtcbiAgICAgIHZhciBuZXdHcm91cCA9IG5ldyBmYWJyaWMuR3JvdXAoW10pO1xuICAgICAgZGVsZXRlIG9wdGlvbnMudHlwZTtcbiAgICAgIG5ld0dyb3VwLnNldChvcHRpb25zKTtcbiAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0LmNhbnZhcy5yZW1vdmUob2JqZWN0KTtcbiAgICAgICAgb2JqZWN0Lmdyb3VwID0gbmV3R3JvdXA7XG4gICAgICB9KTtcbiAgICAgIG5ld0dyb3VwLl9vYmplY3RzID0gb2JqZWN0cztcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIG5ld0dyb3VwO1xuICAgICAgfVxuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgY2FudmFzLmFkZChuZXdHcm91cCk7XG4gICAgICBjYW52YXMuX2FjdGl2ZU9iamVjdCA9IG5ld0dyb3VwO1xuICAgICAgbmV3R3JvdXAuc2V0Q29vcmRzKCk7XG4gICAgICByZXR1cm4gbmV3R3JvdXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHJldHVybnMgdHJ1ZSwgZGVzZWxlY3Rpb24gaXMgY2FuY2VsbGVkLlxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFtjYW5jZWxdXG4gICAgICovXG4gICAgb25EZXNlbGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBncm91cFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLkFjdGl2ZVNlbGVjdGlvbjogKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArICcpPic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZSBpZiB0aGUgb2JqZWN0IHNob3VsZCBjYWNoZSBvciBub3QuIENyZWF0ZSBpdHMgb3duIGNhY2hlIGxldmVsXG4gICAgICogb2JqZWN0Q2FjaGluZyBpcyBhIGdsb2JhbCBmbGFnLCB3aW5zIG92ZXIgZXZlcnl0aGluZ1xuICAgICAqIG5lZWRzSXRzT3duQ2FjaGUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGRyYXdpbmcgbWV0aG9kIHJlcXVpcmVzXG4gICAgICogYSBjYWNoZSBzdGVwLiBOb25lIG9mIHRoZSBmYWJyaWMgY2xhc3NlcyByZXF1aXJlcyBpdC5cbiAgICAgKiBHZW5lcmFsbHkgeW91IGRvIG5vdCBjYWNoZSBvYmplY3RzIGluIGdyb3VwcyBiZWNhdXNlIHRoZSBncm91cCBvdXRzaWRlIGlzIGNhY2hlZC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNob3VsZENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBncm91cCBvciBpdHMgcGFyZW50IGdyb3VwIGFyZSBjYWNoaW5nLCByZWN1cnNpdmVseSB1cFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNPbkFDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgY29udHJvbHMgYW5kIGJvcmRlcnMgZm9yIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZU92ZXJyaWRlXSBwcm9wZXJ0aWVzIHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NoaWxkcmVuT3ZlcnJpZGVdIHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgdGhlIGNoaWxkcmVuIG92ZXJyaWRlc1xuICAgICAqL1xuICAgIF9yZW5kZXJDb250cm9sczogZnVuY3Rpb24oY3R4LCBzdHlsZU92ZXJyaWRlLCBjaGlsZHJlbk92ZXJyaWRlKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5pc01vdmluZyA/IHRoaXMuYm9yZGVyT3BhY2l0eVdoZW5Nb3ZpbmcgOiAxO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19yZW5kZXJDb250cm9scycsIGN0eCwgc3R5bGVPdmVycmlkZSk7XG4gICAgICBjaGlsZHJlbk92ZXJyaWRlID0gY2hpbGRyZW5PdmVycmlkZSB8fCB7IH07XG4gICAgICBpZiAodHlwZW9mIGNoaWxkcmVuT3ZlcnJpZGUuaGFzQ29udHJvbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNoaWxkcmVuT3ZlcnJpZGUuaGFzQ29udHJvbHMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuT3ZlcnJpZGUuZm9yQWN0aXZlU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0uX3JlbmRlckNvbnRyb2xzKGN0eCwgY2hpbGRyZW5PdmVycmlkZSk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuQWN0aXZlU2VsZWN0aW9ufSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhIGdyb3VwIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBBY3RpdmVTZWxlY3Rpb24gaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLkFjdGl2ZVNlbGVjdGlvbi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKG9iamVjdC5vYmplY3RzLCBmdW5jdGlvbihlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICBkZWxldGUgb2JqZWN0Lm9iamVjdHM7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhuZXcgZmFicmljLkFjdGl2ZVNlbGVjdGlvbihlbmxpdmVuZWRPYmplY3RzLCBvYmplY3QsIHRydWUpKTtcbiAgICB9KTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQ7XG5cbiAgaWYgKCFnbG9iYWwuZmFicmljKSB7XG4gICAgZ2xvYmFsLmZhYnJpYyA9IHsgfTtcbiAgfVxuXG4gIGlmIChnbG9iYWwuZmFicmljLkltYWdlKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5JbWFnZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEltYWdlIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2VcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMSNpbWFnZXN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkltYWdlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnaW1hZ2UnLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgYSBzdHJva2UuXG4gICAgICogRm9yIGltYWdlIHF1YWxpdHkgYSBzdHJva2UgbXVsdGlwbGUgb2YgMiBnaXZlcyBiZXR0ZXIgcmVzdWx0cy5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZVdpZHRoOiAwLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBjYWxsaW5nIHtAbGluayBmYWJyaWMuSW1hZ2UuZ2V0U3JjfSwgcmV0dXJuIHZhbHVlIGZyb20gZWxlbWVudCBzcmMgd2l0aCBgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NyYycpYC5cbiAgICAgKiBUaGlzIGFsbG93cyBmb3IgcmVsYXRpdmUgdXJscyBhcyBpbWFnZSBzcmMuXG4gICAgICogQHNpbmNlIDIuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3JjRnJvbUF0dHJpYnV0ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlXG4gICAgICogY29udGFpbnMgbGFzdCB2YWx1ZSBvZiBzY2FsZVggdG8gZGV0ZWN0XG4gICAgICogaWYgdGhlIEltYWdlIGdvdCByZXNpemVkIGFmdGVyIHRoZSBsYXN0IFJlbmRlclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIF9sYXN0U2NhbGVYOiAxLFxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIGNvbnRhaW5zIGxhc3QgdmFsdWUgb2Ygc2NhbGVZIHRvIGRldGVjdFxuICAgICAqIGlmIHRoZSBJbWFnZSBnb3QgcmVzaXplZCBhZnRlciB0aGUgbGFzdCBSZW5kZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBfbGFzdFNjYWxlWTogMSxcblxuICAgIC8qKlxuICAgICAqIHByaXZhdGVcbiAgICAgKiBjb250YWlucyBsYXN0IHZhbHVlIG9mIHNjYWxpbmcgYXBwbGllZCBieSB0aGUgYXBwbHkgZmlsdGVyIGNoYWluXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgX2ZpbHRlclNjYWxpbmdYOiAxLFxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIGNvbnRhaW5zIGxhc3QgdmFsdWUgb2Ygc2NhbGluZyBhcHBsaWVkIGJ5IHRoZSBhcHBseSBmaWx0ZXIgY2hhaW5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBfZmlsdGVyU2NhbGluZ1k6IDEsXG5cbiAgICAvKipcbiAgICAgKiBtaW5pbXVtIHNjYWxlIGZhY3RvciB1bmRlciB3aGljaCBhbnkgcmVzaXplRmlsdGVyIGlzIHRyaWdnZXJlZCB0byByZXNpemUgdGhlIGltYWdlXG4gICAgICogMCB3aWxsIGRpc2FibGUgdGhlIGF1dG9tYXRpYyByZXNpemUuIDEgd2lsbCB0cmlnZ2VyIGF1dG9tYXRpY2FsbHkgYWx3YXlzLlxuICAgICAqIG51bWJlciBiaWdnZXIgdGhhbiAxIGFyZSBub3QgaW1wbGVtZW50ZWQgeWV0LlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIG1pbmltdW1TY2FsZVRyaWdnZXI6IDAuNSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmXG4gICAgICogc3RhdGUgb2YgYW4gb2JqZWN0IGlzIGNoYW5nZWQgKHtAbGluayBmYWJyaWMuT2JqZWN0I2hhc1N0YXRlQ2hhbmdlZH0pXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KCdjcm9wWCcsICdjcm9wWScpLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgY2FjaGUgbmVlZHMgcmVmcmVzaFxuICAgICAqIFRob3NlIHByb3BlcnRpZXMgYXJlIGNoZWNrZWQgYnkgc3RhdGVmdWxsQ2FjaGUgT04gKCBvciBsYXp5IG1vZGUgaWYgd2Ugd2FudCApIG9yIGZyb20gc2luZ2xlXG4gICAgICogY2FsbHMgdG8gT2JqZWN0LnNldChrZXksIHZhbHVlKS4gSWYgdGhlIGtleSBpcyBpbiB0aGlzIGxpc3QsIHRoZSBvYmplY3QgaXMgbWFya2VkIGFzIGRpcnR5XG4gICAgICogYW5kIHJlZnJlc2hlZCBhdCB0aGUgbmV4dCByZW5kZXJcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgnY3JvcFgnLCAnY3JvcFknKSxcblxuICAgIC8qKlxuICAgICAqIGtleSB1c2VkIHRvIHJldHJpZXZlIHRoZSB0ZXh0dXJlIHJlcHJlc2VudGluZyB0aGlzIGltYWdlXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjYWNoZUtleTogJycsXG5cbiAgICAvKipcbiAgICAgKiBJbWFnZSBjcm9wIGluIHBpeGVscyBmcm9tIG9yaWdpbmFsIGltYWdlIHNpemUuXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjcm9wWDogMCxcblxuICAgIC8qKlxuICAgICAqIEltYWdlIGNyb3AgaW4gcGl4ZWxzIGZyb20gb3JpZ2luYWwgaW1hZ2Ugc2l6ZS5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNyb3BZOiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBjYW52YXMgd2lsbCB1c2UgaW1hZ2Ugc21vb3RoaW5nIHdoZW4gcGFpbnRpbmcgdGhpcyBpbWFnZS5cbiAgICAgKiBBbHNvIGluZmx1ZW5jZSBpZiB0aGUgY2FjaGVDYW52YXMgZm9yIHRoaXMgaW1hZ2UgdXNlcyBpbWFnZVNtb290aGluZ1xuICAgICAqIEBzaW5jZSA0LjAuMC1iZXRhLjExXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW1hZ2VTbW9vdGhpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEltYWdlIGNhbiBiZSBpbml0aWFsaXplZCB3aXRoIGFueSBjYW52YXMgZHJhd2FibGUgb3IgYSBzdHJpbmcuXG4gICAgICogVGhlIHN0cmluZyBzaG91bGQgYmUgYSB1cmwgYW5kIHdpbGwgYmUgbG9hZGVkIGFzIGFuIGltYWdlLlxuICAgICAqIENhbnZhcyBhbmQgSW1hZ2UgZWxlbWVudCB3b3JrIG91dCBvZiB0aGUgYm94LCB3aGlsZSB2aWRlb3MgcmVxdWlyZSBleHRyYSBjb2RlIHRvIHdvcmsuXG4gICAgICogUGxlYXNlIGNoZWNrIHZpZGVvIGVsZW1lbnQgZXZlbnRzIGZvciBzZWVraW5nLlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudCB8IFN0cmluZ30gZWxlbWVudCBJbWFnZSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCBhZnRlciBldmVudHVhbCBmaWx0ZXJzIGFwcGxpZWQuXG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICAgIHRoaXMuY2FjaGVLZXkgPSAndGV4dHVyZScgKyBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdEVsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW1hZ2UgZWxlbWVudCB3aGljaCB0aGlzIGluc3RhbmNlIGlmIGJhc2VkIG9uXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gSW1hZ2UgZWxlbWVudFxuICAgICAqL1xuICAgIGdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQgfHwge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgaW1hZ2UgZWxlbWVudCBmb3IgdGhpcyBpbnN0YW5jZSB0byBhIHNwZWNpZmllZCBvbmUuXG4gICAgICogSWYgZmlsdGVycyBkZWZpbmVkIHRoZXkgYXJlIGFwcGxpZWQgdG8gbmV3IGltYWdlLlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYGNhbnZhcy5yZW5kZXJBbGxgIGFuZCBgb2JqZWN0LnNldENvb3Jkc2AgYWZ0ZXIgcmVwbGFjaW5nLCB0byByZW5kZXIgbmV3IGltYWdlIGFuZCB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMucmVtb3ZlVGV4dHVyZSh0aGlzLmNhY2hlS2V5KTtcbiAgICAgIHRoaXMucmVtb3ZlVGV4dHVyZSh0aGlzLmNhY2hlS2V5ICsgJ19maWx0ZXJlZCcpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9vcmlnaW5hbEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5faW5pdENvbmZpZyhvcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLmZpbHRlcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRoaXMuYXBwbHlGaWx0ZXJzKCk7XG4gICAgICB9XG4gICAgICAvLyByZXNpemVGaWx0ZXJzIHdvcmsgb24gdGhlIGFscmVhZHkgZmlsdGVyZWQgY29weS5cbiAgICAgIC8vIHdlIG5lZWQgdG8gYXBwbHkgcmVzaXplRmlsdGVycyBBRlRFUiBub3JtYWwgZmlsdGVycy5cbiAgICAgIC8vIGFwcGx5UmVzaXplRmlsdGVycyBpcyBydW4gbW9yZSBvZnRlbiB0aGFuIG5vcm1hbCBmaWx0ZXJzXG4gICAgICAvLyBhbmQgaXMgdHJpZ2dlcmVkIGJ5IHVzZXIgaW50ZXJhY3Rpb25zIHJhdGhlciB0aGFuIGRldiBjb2RlXG4gICAgICBpZiAodGhpcy5yZXNpemVGaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5hcHBseVJlc2l6ZUZpbHRlcnMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBzaW5nbGUgdGV4dHVyZSBpZiBpbiB3ZWJnbCBtb2RlXG4gICAgICovXG4gICAgcmVtb3ZlVGV4dHVyZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgYmFja2VuZCA9IGZhYnJpYy5maWx0ZXJCYWNrZW5kO1xuICAgICAgaWYgKGJhY2tlbmQgJiYgYmFja2VuZC5ldmljdENhY2hlc0ZvcktleSkge1xuICAgICAgICBiYWNrZW5kLmV2aWN0Q2FjaGVzRm9yS2V5KGtleSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0ZXh0dXJlcywgcmVmZXJlbmNlIHRvIGVsZW1lbnRzIGFuZCBldmVudHVhbGx5IEpTRE9NIGNsZWFudXBcbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignZGlzcG9zZScpO1xuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkpO1xuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkgKyAnX2ZpbHRlcmVkJyk7XG4gICAgICB0aGlzLl9jYWNoZUNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICBbJ19vcmlnaW5hbEVsZW1lbnQnLCAnX2VsZW1lbnQnLCAnX2ZpbHRlcmVkRWwnLCAnX2NhY2hlQ2FudmFzJ10uZm9yRWFjaCgoZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBmYWJyaWMudXRpbC5jbGVhblVwSnNkb21Ob2RlKHRoaXNbZWxlbWVudF0pO1xuICAgICAgICB0aGlzW2VsZW1lbnRdID0gdW5kZWZpbmVkO1xuICAgICAgfSkuYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3Jvc3NPcmlnaW4gdmFsdWUgKG9mIHRoZSBjb3JyZXNwb25kaW5nIGltYWdlIGVsZW1lbnQpXG4gICAgICovXG4gICAgZ2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsRWxlbWVudCAmJiAodGhpcy5fb3JpZ2luYWxFbGVtZW50LmNyb3NzT3JpZ2luIHx8IG51bGwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9yaWdpbmFsIHNpemUgb2YgYW4gaW1hZ2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIFwid2lkdGhcIiBhbmQgXCJoZWlnaHRcIiBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0T3JpZ2luYWxTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogZWxlbWVudC5uYXR1cmFsV2lkdGggfHwgZWxlbWVudC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBlbGVtZW50Lm5hdHVyYWxIZWlnaHQgfHwgZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9zdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB3ID0gdGhpcy53aWR0aCAvIDIsIGggPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKC13LCAtaCk7XG4gICAgICBjdHgubGluZVRvKHcsIC1oKTtcbiAgICAgIGN0eC5saW5lVG8odywgaCk7XG4gICAgICBjdHgubGluZVRvKC13LCBoKTtcbiAgICAgIGN0eC5saW5lVG8oLXcsIC1oKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIGZpbHRlcnMgPSBbXTtcblxuICAgICAgdGhpcy5maWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oZmlsdGVyT2JqKSB7XG4gICAgICAgIGlmIChmaWx0ZXJPYmopIHtcbiAgICAgICAgICBmaWx0ZXJzLnB1c2goZmlsdGVyT2JqLnRvT2JqZWN0KCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBvYmplY3QgPSBleHRlbmQoXG4gICAgICAgIHRoaXMuY2FsbFN1cGVyKFxuICAgICAgICAgICd0b09iamVjdCcsXG4gICAgICAgICAgWydjcm9wWCcsICdjcm9wWSddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKVxuICAgICAgICApLCB7XG4gICAgICAgICAgc3JjOiB0aGlzLmdldFNyYygpLFxuICAgICAgICAgIGNyb3NzT3JpZ2luOiB0aGlzLmdldENyb3NzT3JpZ2luKCksXG4gICAgICAgICAgZmlsdGVyczogZmlsdGVycyxcbiAgICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5yZXNpemVGaWx0ZXIpIHtcbiAgICAgICAgb2JqZWN0LnJlc2l6ZUZpbHRlciA9IHRoaXMucmVzaXplRmlsdGVyLnRvT2JqZWN0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYW4gaW1hZ2UgaGFzIGNyb3AgYXBwbGllZCwgaW5zcGVjdGluZyB2YWx1ZXMgb2YgY3JvcFgsY3JvcFksd2lkdGgsaGVpZ2h0LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzQ3JvcDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcm9wWCB8fCB0aGlzLmNyb3BZIHx8IHRoaXMud2lkdGggPCB0aGlzLl9lbGVtZW50LndpZHRoIHx8IHRoaXMuaGVpZ2h0IDwgdGhpcy5fZWxlbWVudC5oZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN2Z1N0cmluZyA9IFtdLCBpbWFnZU1hcmt1cCA9IFtdLCBzdHJva2VTdmcsIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgIHggPSAtdGhpcy53aWR0aCAvIDIsIHkgPSAtdGhpcy5oZWlnaHQgLyAyLCBjbGlwUGF0aCA9ICcnLCBpbWFnZVJlbmRlcmluZyA9ICcnO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc0Nyb3AoKSkge1xuICAgICAgICB2YXIgY2xpcFBhdGhJZCA9IGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgICAgc3ZnU3RyaW5nLnB1c2goXG4gICAgICAgICAgJzxjbGlwUGF0aCBpZD1cImltYWdlQ3JvcF8nICsgY2xpcFBhdGhJZCArICdcIj5cXG4nLFxuICAgICAgICAgICdcXHQ8cmVjdCB4PVwiJyArIHggKyAnXCIgeT1cIicgKyB5ICsgJ1wiIHdpZHRoPVwiJyArIHRoaXMud2lkdGggKyAnXCIgaGVpZ2h0PVwiJyArIHRoaXMuaGVpZ2h0ICsgJ1wiIC8+XFxuJyxcbiAgICAgICAgICAnPC9jbGlwUGF0aD5cXG4nXG4gICAgICAgICk7XG4gICAgICAgIGNsaXBQYXRoID0gJyBjbGlwLXBhdGg9XCJ1cmwoI2ltYWdlQ3JvcF8nICsgY2xpcFBhdGhJZCArICcpXCIgJztcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5pbWFnZVNtb290aGluZykge1xuICAgICAgICBpbWFnZVJlbmRlcmluZyA9ICdcIiBpbWFnZS1yZW5kZXJpbmc9XCJvcHRpbWl6ZVNwZWVkJztcbiAgICAgIH1cbiAgICAgIGltYWdlTWFya3VwLnB1c2goJ1xcdDxpbWFnZSAnLCAnQ09NTU9OX1BBUlRTJywgJ3hsaW5rOmhyZWY9XCInLCB0aGlzLmdldFN2Z1NyYyh0cnVlKSxcbiAgICAgICAgJ1wiIHg9XCInLCB4IC0gdGhpcy5jcm9wWCwgJ1wiIHk9XCInLCB5IC0gdGhpcy5jcm9wWSxcbiAgICAgICAgLy8gd2UncmUgZXNzZW50aWFsbHkgbW92aW5nIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvbiBmcm9tIHRvcC9sZWZ0IGNvcm5lciB0byB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZVxuICAgICAgICAvLyBieSB3cmFwcGluZyBpdCBpbiBjb250YWluZXIgPGc+IGVsZW1lbnQgd2l0aCBhY3R1YWwgdHJhbnNmb3JtYXRpb24sIHRoZW4gb2Zmc2V0dGluZyBvYmplY3QgdG8gdGhlIHRvcC9sZWZ0XG4gICAgICAgIC8vIHNvIHRoYXQgb2JqZWN0J3MgY2VudGVyIGFsaWducyB3aXRoIGNvbnRhaW5lcidzIGxlZnQvdG9wXG4gICAgICAgICdcIiB3aWR0aD1cIicsIGVsZW1lbnQud2lkdGggfHwgZWxlbWVudC5uYXR1cmFsV2lkdGgsXG4gICAgICAgICdcIiBoZWlnaHQ9XCInLCBlbGVtZW50LmhlaWdodCB8fCBlbGVtZW50LmhlaWdodCxcbiAgICAgICAgaW1hZ2VSZW5kZXJpbmcsXG4gICAgICAgICdcIicsIGNsaXBQYXRoLFxuICAgICAgICAnPjwvaW1hZ2U+XFxuJyk7XG5cbiAgICAgIGlmICh0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZURhc2hBcnJheSkge1xuICAgICAgICB2YXIgb3JpZ0ZpbGwgPSB0aGlzLmZpbGw7XG4gICAgICAgIHRoaXMuZmlsbCA9IG51bGw7XG4gICAgICAgIHN0cm9rZVN2ZyA9IFtcbiAgICAgICAgICAnXFx0PHJlY3QgJyxcbiAgICAgICAgICAneD1cIicsIHgsICdcIiB5PVwiJywgeSxcbiAgICAgICAgICAnXCIgd2lkdGg9XCInLCB0aGlzLndpZHRoLCAnXCIgaGVpZ2h0PVwiJywgdGhpcy5oZWlnaHQsXG4gICAgICAgICAgJ1wiIHN0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMoKSxcbiAgICAgICAgICAnXCIvPlxcbidcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5maWxsID0gb3JpZ0ZpbGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ICE9PSAnZmlsbCcpIHtcbiAgICAgICAgc3ZnU3RyaW5nID0gc3ZnU3RyaW5nLmNvbmNhdChzdHJva2VTdmcsIGltYWdlTWFya3VwKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdmdTdHJpbmcgPSBzdmdTdHJpbmcuY29uY2F0KGltYWdlTWFya3VwLCBzdHJva2VTdmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN2Z1N0cmluZztcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzb3VyY2Ugb2YgYW4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbHRlcmVkIGluZGljYXRlcyBpZiB0aGUgc3JjIGlzIG5lZWRlZCBmb3Igc3ZnXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTb3VyY2Ugb2YgYW4gaW1hZ2VcbiAgICAgKi9cbiAgICBnZXRTcmM6IGZ1bmN0aW9uKGZpbHRlcmVkKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IGZpbHRlcmVkID8gdGhpcy5fZWxlbWVudCA6IHRoaXMuX29yaWdpbmFsRWxlbWVudDtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50LnRvRGF0YVVSTCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LnRvRGF0YVVSTCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3JjRnJvbUF0dHJpYnV0ZSkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuc3JjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3JjIHx8ICcnO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNvdXJjZSBvZiBhbiBpbWFnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgU291cmNlIHN0cmluZyAoVVJMKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgaXMgaW52b2tlZCB3aGVuIGltYWdlIGhhcyBiZWVuIGxvYWRlZCAoYW5kIGFsbCBmaWx0ZXJzIGhhdmUgYmVlbiBhcHBsaWVkKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY3Jvc3NPcmlnaW5dIGNyb3NzT3JpZ2luIHZhbHVlIChvbmUgb2YgXCJcIiwgXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIilcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2V9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0U3JjOiBmdW5jdGlvbihzcmMsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2Uoc3JjLCBmdW5jdGlvbihpbWcsIGlzRXJyb3IpIHtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KGltZywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3NldFdpZHRoSGVpZ2h0KCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHRoaXMsIGlzRXJyb3IpO1xuICAgICAgfSwgdGhpcywgb3B0aW9ucyAmJiBvcHRpb25zLmNyb3NzT3JpZ2luKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5JbWFnZTogeyBzcmM6IFwiJyArIHRoaXMuZ2V0U3JjKCkgKyAnXCIgfT4nO1xuICAgIH0sXG5cbiAgICBhcHBseVJlc2l6ZUZpbHRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGZpbHRlciA9IHRoaXMucmVzaXplRmlsdGVyLFxuICAgICAgICAgIG1pbmltdW1TY2FsZSA9IHRoaXMubWluaW11bVNjYWxlVHJpZ2dlcixcbiAgICAgICAgICBvYmplY3RTY2FsZSA9IHRoaXMuZ2V0VG90YWxPYmplY3RTY2FsaW5nKCksXG4gICAgICAgICAgc2NhbGVYID0gb2JqZWN0U2NhbGUuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlWSA9IG9iamVjdFNjYWxlLnNjYWxlWSxcbiAgICAgICAgICBlbGVtZW50VG9GaWx0ZXIgPSB0aGlzLl9maWx0ZXJlZEVsIHx8IHRoaXMuX29yaWdpbmFsRWxlbWVudDtcbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFmaWx0ZXIgfHwgKHNjYWxlWCA+IG1pbmltdW1TY2FsZSAmJiBzY2FsZVkgPiBtaW5pbXVtU2NhbGUpKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50VG9GaWx0ZXI7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdYID0gMTtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1kgPSAxO1xuICAgICAgICB0aGlzLl9sYXN0U2NhbGVYID0gc2NhbGVYO1xuICAgICAgICB0aGlzLl9sYXN0U2NhbGVZID0gc2NhbGVZO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWZhYnJpYy5maWx0ZXJCYWNrZW5kKSB7XG4gICAgICAgIGZhYnJpYy5maWx0ZXJCYWNrZW5kID0gZmFicmljLmluaXRGaWx0ZXJCYWNrZW5kKCk7XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzRWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksXG4gICAgICAgICAgY2FjaGVLZXkgPSB0aGlzLl9maWx0ZXJlZEVsID8gKHRoaXMuY2FjaGVLZXkgKyAnX2ZpbHRlcmVkJykgOiB0aGlzLmNhY2hlS2V5LFxuICAgICAgICAgIHNvdXJjZVdpZHRoID0gZWxlbWVudFRvRmlsdGVyLndpZHRoLCBzb3VyY2VIZWlnaHQgPSBlbGVtZW50VG9GaWx0ZXIuaGVpZ2h0O1xuICAgICAgY2FudmFzRWwud2lkdGggPSBzb3VyY2VXaWR0aDtcbiAgICAgIGNhbnZhc0VsLmhlaWdodCA9IHNvdXJjZUhlaWdodDtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBjYW52YXNFbDtcbiAgICAgIHRoaXMuX2xhc3RTY2FsZVggPSBmaWx0ZXIuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgdGhpcy5fbGFzdFNjYWxlWSA9IGZpbHRlci5zY2FsZVkgPSBzY2FsZVk7XG4gICAgICBmYWJyaWMuZmlsdGVyQmFja2VuZC5hcHBseUZpbHRlcnMoXG4gICAgICAgIFtmaWx0ZXJdLCBlbGVtZW50VG9GaWx0ZXIsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsIHRoaXMuX2VsZW1lbnQsIGNhY2hlS2V5KTtcbiAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdYID0gY2FudmFzRWwud2lkdGggLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQud2lkdGg7XG4gICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IGNhbnZhc0VsLmhlaWdodCAvIHRoaXMuX29yaWdpbmFsRWxlbWVudC5oZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVycyBhc3NpZ25lZCB0byB0aGlzIGltYWdlIChmcm9tIFwiZmlsdGVyc1wiIGFycmF5KSBvciBmcm9tIGZpbHRlciBwYXJhbVxuICAgICAqIEBtZXRob2QgYXBwbHlGaWx0ZXJzXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVycyB0byBiZSBhcHBsaWVkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmb3JSZXNpemluZyBzcGVjaWZ5IGlmIHRoZSBmaWx0ZXIgb3BlcmF0aW9uIGlzIGEgcmVzaXplIG9wZXJhdGlvblxuICAgICAqIEByZXR1cm4ge3RoaXNBcmd9IHJldHVybiB0aGUgZmFicmljLkltYWdlIG9iamVjdFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhcHBseUZpbHRlcnM6IGZ1bmN0aW9uKGZpbHRlcnMpIHtcblxuICAgICAgZmlsdGVycyA9IGZpbHRlcnMgfHwgdGhpcy5maWx0ZXJzIHx8IFtdO1xuICAgICAgZmlsdGVycyA9IGZpbHRlcnMuZmlsdGVyKGZ1bmN0aW9uKGZpbHRlcikgeyByZXR1cm4gZmlsdGVyICYmICFmaWx0ZXIuaXNOZXV0cmFsU3RhdGUoKTsgfSk7XG4gICAgICB0aGlzLnNldCgnZGlydHknLCB0cnVlKTtcblxuICAgICAgLy8gbmVlZHMgdG8gY2xlYXIgb3V0IG9yIFdFQkdMIHdpbGwgbm90IHJlc2l6ZSBjb3JyZWN0bHlcbiAgICAgIHRoaXMucmVtb3ZlVGV4dHVyZSh0aGlzLmNhY2hlS2V5ICsgJ19maWx0ZXJlZCcpO1xuXG4gICAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IHRoaXMuX29yaWdpbmFsRWxlbWVudDtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWRFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdYID0gMTtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1kgPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGltZ0VsZW1lbnQgPSB0aGlzLl9vcmlnaW5hbEVsZW1lbnQsXG4gICAgICAgICAgc291cmNlV2lkdGggPSBpbWdFbGVtZW50Lm5hdHVyYWxXaWR0aCB8fCBpbWdFbGVtZW50LndpZHRoLFxuICAgICAgICAgIHNvdXJjZUhlaWdodCA9IGltZ0VsZW1lbnQubmF0dXJhbEhlaWdodCB8fCBpbWdFbGVtZW50LmhlaWdodDtcblxuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQgPT09IHRoaXMuX29yaWdpbmFsRWxlbWVudCkge1xuICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyB0aGUgc2FtZSB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBlbGVtZW50XG4gICAgICAgIHZhciBjYW52YXNFbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgICAgY2FudmFzRWwud2lkdGggPSBzb3VyY2VXaWR0aDtcbiAgICAgICAgY2FudmFzRWwuaGVpZ2h0ID0gc291cmNlSGVpZ2h0O1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gY2FudmFzRWw7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmVkRWwgPSBjYW52YXNFbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBjbGVhciB0aGUgZXhpc3RpbmcgZWxlbWVudCB0byBnZXQgbmV3IGZpbHRlciBkYXRhXG4gICAgICAgIC8vIGFsc28gZGVyZWZlcmVuY2UgdGhlIGV2ZW50dWFsIHJlc2l6ZWQgX2VsZW1lbnRcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IHRoaXMuX2ZpbHRlcmVkRWw7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmVkRWwuZ2V0Q29udGV4dCgnMmQnKS5jbGVhclJlY3QoMCwgMCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCk7XG4gICAgICAgIC8vIHdlIGFsc28gbmVlZCB0byByZXNpemUgYWdhaW4gYXQgbmV4dCByZW5kZXJBbGwsIHNvIHJlbW92ZSBzYXZlZCBfbGFzdFNjYWxlWC9ZXG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVggPSAxO1xuICAgICAgICB0aGlzLl9sYXN0U2NhbGVZID0gMTtcbiAgICAgIH1cbiAgICAgIGlmICghZmFicmljLmZpbHRlckJhY2tlbmQpIHtcbiAgICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQgPSBmYWJyaWMuaW5pdEZpbHRlckJhY2tlbmQoKTtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy5maWx0ZXJCYWNrZW5kLmFwcGx5RmlsdGVycyhcbiAgICAgICAgZmlsdGVycywgdGhpcy5fb3JpZ2luYWxFbGVtZW50LCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LCB0aGlzLl9lbGVtZW50LCB0aGlzLmNhY2hlS2V5KTtcbiAgICAgIGlmICh0aGlzLl9vcmlnaW5hbEVsZW1lbnQud2lkdGggIT09IHRoaXMuX2VsZW1lbnQud2lkdGggfHxcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxFbGVtZW50LmhlaWdodCAhPT0gdGhpcy5fZWxlbWVudC5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSB0aGlzLl9lbGVtZW50LndpZHRoIC8gdGhpcy5fb3JpZ2luYWxFbGVtZW50LndpZHRoO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IHRoaXMuX2VsZW1lbnQuaGVpZ2h0IC8gdGhpcy5fb3JpZ2luYWxFbGVtZW50LmhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGZhYnJpYy51dGlsLnNldEltYWdlU21vb3RoaW5nKGN0eCwgdGhpcy5pbWFnZVNtb290aGluZyk7XG4gICAgICBpZiAodGhpcy5pc01vdmluZyAhPT0gdHJ1ZSAmJiB0aGlzLnJlc2l6ZUZpbHRlciAmJiB0aGlzLl9uZWVkc1Jlc2l6ZSgpKSB7XG4gICAgICAgIHRoaXMuYXBwbHlSZXNpemVGaWx0ZXJzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdHJva2UoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYWludCB0aGUgY2FjaGVkIGNvcHkgb2YgdGhlIG9iamVjdCBvbiB0aGUgdGFyZ2V0IGNvbnRleHQuXG4gICAgICogaXQgd2lsbCBzZXQgdGhlIGltYWdlU21vb3RoaW5nIGZvciB0aGUgZHJhdyBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd0NhY2hlT25DYW52YXM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgZmFicmljLnV0aWwuc2V0SW1hZ2VTbW9vdGhpbmcoY3R4LCB0aGlzLmltYWdlU21vb3RoaW5nKTtcbiAgICAgIGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmRyYXdDYWNoZU9uQ2FudmFzLmNhbGwodGhpcywgY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaWRlIGlmIHRoZSBvYmplY3Qgc2hvdWxkIGNhY2hlIG9yIG5vdC4gQ3JlYXRlIGl0cyBvd24gY2FjaGUgbGV2ZWxcbiAgICAgKiBuZWVkc0l0c093bkNhY2hlIHNob3VsZCBiZSB1c2VkIHdoZW4gdGhlIG9iamVjdCBkcmF3aW5nIG1ldGhvZCByZXF1aXJlc1xuICAgICAqIGEgY2FjaGUgc3RlcC4gTm9uZSBvZiB0aGUgZmFicmljIGNsYXNzZXMgcmVxdWlyZXMgaXQuXG4gICAgICogR2VuZXJhbGx5IHlvdSBkbyBub3QgY2FjaGUgb2JqZWN0cyBpbiBncm91cHMgYmVjYXVzZSB0aGUgZ3JvdXAgb3V0c2lkZSBpcyBjYWNoZWQuXG4gICAgICogVGhpcyBpcyB0aGUgc3BlY2lhbCBpbWFnZSB2ZXJzaW9uIHdoZXJlIHdlIHdvdWxkIGxpa2UgdG8gYXZvaWQgY2FjaGluZyB3aGVyZSBwb3NzaWJsZS5cbiAgICAgKiBFc3NlbnRpYWxseSBpbWFnZXMgZG8gbm90IGJlbmVmaXQgZnJvbSBjYWNoaW5nLiBUaGV5IG1heSByZXF1aXJlIGNhY2hpbmcsIGFuZCBpbiB0aGF0XG4gICAgICogY2FzZSB3ZSBkbyBpdC4gQWxzbyBjYWNoaW5nIGFuIGltYWdlIHVzdWFsbHkgZW5kcyBpbiBhIGxvc3Mgb2YgZGV0YWlscy5cbiAgICAgKiBBIGZ1bGwgcGVyZm9ybWFuY2UgYXVkaXQgc2hvdWxkIGJlIGRvbmUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzaG91bGRDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZWVkc0l0c093bkNhY2hlKCk7XG4gICAgfSxcblxuICAgIF9yZW5kZXJGaWxsOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBlbGVtZW50VG9EcmF3ID0gdGhpcy5fZWxlbWVudDtcbiAgICAgIGlmICghZWxlbWVudFRvRHJhdykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc2NhbGVYID0gdGhpcy5fZmlsdGVyU2NhbGluZ1gsIHNjYWxlWSA9IHRoaXMuX2ZpbHRlclNjYWxpbmdZLFxuICAgICAgICAgIHcgPSB0aGlzLndpZHRoLCBoID0gdGhpcy5oZWlnaHQsIG1pbiA9IE1hdGgubWluLCBtYXggPSBNYXRoLm1heCxcbiAgICAgICAgICAvLyBjcm9wIHZhbHVlcyBjYW5ub3QgYmUgbGVzc2VyIHRoYW4gMC5cbiAgICAgICAgICBjcm9wWCA9IG1heCh0aGlzLmNyb3BYLCAwKSwgY3JvcFkgPSBtYXgodGhpcy5jcm9wWSwgMCksXG4gICAgICAgICAgZWxXaWR0aCA9IGVsZW1lbnRUb0RyYXcubmF0dXJhbFdpZHRoIHx8IGVsZW1lbnRUb0RyYXcud2lkdGgsXG4gICAgICAgICAgZWxIZWlnaHQgPSBlbGVtZW50VG9EcmF3Lm5hdHVyYWxIZWlnaHQgfHwgZWxlbWVudFRvRHJhdy5oZWlnaHQsXG4gICAgICAgICAgc1ggPSBjcm9wWCAqIHNjYWxlWCxcbiAgICAgICAgICBzWSA9IGNyb3BZICogc2NhbGVZLFxuICAgICAgICAgIC8vIHRoZSB3aWR0aCBoZWlnaHQgY2Fubm90IGV4Y2VlZCBlbGVtZW50IHdpZHRoL2hlaWdodCwgc3RhcnRpbmcgZnJvbSB0aGUgY3JvcCBvZmZzZXQuXG4gICAgICAgICAgc1cgPSBtaW4odyAqIHNjYWxlWCwgZWxXaWR0aCAtIHNYKSxcbiAgICAgICAgICBzSCA9IG1pbihoICogc2NhbGVZLCBlbEhlaWdodCAtIHNZKSxcbiAgICAgICAgICB4ID0gLXcgLyAyLCB5ID0gLWggLyAyLFxuICAgICAgICAgIG1heERlc3RXID0gbWluKHcsIGVsV2lkdGggLyBzY2FsZVggLSBjcm9wWCksXG4gICAgICAgICAgbWF4RGVzdEggPSBtaW4oaCwgZWxIZWlnaHQgLyBzY2FsZVkgLSBjcm9wWSk7XG5cbiAgICAgIGVsZW1lbnRUb0RyYXcgJiYgY3R4LmRyYXdJbWFnZShlbGVtZW50VG9EcmF3LCBzWCwgc1ksIHNXLCBzSCwgeCwgeSwgbWF4RGVzdFcsIG1heERlc3RIKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbmVlZGVkIHRvIGNoZWNrIGlmIGltYWdlIG5lZWRzIHJlc2l6ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX25lZWRzUmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0VG90YWxPYmplY3RTY2FsaW5nKCk7XG4gICAgICByZXR1cm4gKHNjYWxlLnNjYWxlWCAhPT0gdGhpcy5fbGFzdFNjYWxlWCB8fCBzY2FsZS5zY2FsZVkgIT09IHRoaXMuX2xhc3RTY2FsZVkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldFdpZHRoSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0KHRoaXMuZ2V0T3JpZ2luYWxTaXplKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgSW1hZ2UgY2xhc3MncyBpbml0aWFsaXphdGlvbiBtZXRob2QuIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHlcbiAgICAgKiBjYWxsZWQgYnkgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fFN0cmluZ30gZWxlbWVudCBUaGUgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9pbml0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5zZXRFbGVtZW50KGZhYnJpYy51dGlsLmdldEJ5SWQoZWxlbWVudCksIG9wdGlvbnMpO1xuICAgICAgZmFicmljLnV0aWwuYWRkQ2xhc3ModGhpcy5nZXRFbGVtZW50KCksIGZhYnJpYy5JbWFnZS5DU1NfQ0FOVkFTKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRDb25maWc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVycyB0byBiZSBpbml0aWFsaXplZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFsbCBmYWJyaWMuSW1hZ2UuZmlsdGVycyBpbnN0YW5jZXMgYXJlIGNyZWF0ZWRcbiAgICAgKi9cbiAgICBfaW5pdEZpbHRlcnM6IGZ1bmN0aW9uKGZpbHRlcnMsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoZmlsdGVycyAmJiBmaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhmaWx0ZXJzLCBmdW5jdGlvbihlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkT2JqZWN0cyk7XG4gICAgICAgIH0sICdmYWJyaWMuSW1hZ2UuZmlsdGVycycpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogU2V0IHRoZSB3aWR0aCBhbmQgdGhlIGhlaWdodCBvZiB0aGUgaW1hZ2Ugb2JqZWN0LCB1c2luZyB0aGUgZWxlbWVudCBvciB0aGVcbiAgICAgKiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggd2lkdGgvaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBfc2V0V2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdmFyIGVsID0gdGhpcy5nZXRFbGVtZW50KCk7XG4gICAgICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aCB8fCBlbC5uYXR1cmFsV2lkdGggfHwgZWwud2lkdGggfHwgMDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgZWwubmF0dXJhbEhlaWdodCB8fCBlbC5oZWlnaHQgfHwgMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIG9mZnNldCBmb3IgY2VudGVyIGFuZCBzY2FsZSBmYWN0b3IgZm9yIHRoZSBpbWFnZSBpbiBvcmRlciB0byByZXNwZWN0XG4gICAgICogdGhlIHByZXNlcnZlQXNwZWN0UmF0aW8gYXR0cmlidXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgcGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwQVIgPSBmYWJyaWMudXRpbC5wYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGUodGhpcy5wcmVzZXJ2ZUFzcGVjdFJhdGlvIHx8ICcnKSxcbiAgICAgICAgICByV2lkdGggPSB0aGlzLl9lbGVtZW50LndpZHRoLCBySGVpZ2h0ID0gdGhpcy5fZWxlbWVudC5oZWlnaHQsXG4gICAgICAgICAgc2NhbGVYID0gMSwgc2NhbGVZID0gMSwgb2Zmc2V0TGVmdCA9IDAsIG9mZnNldFRvcCA9IDAsIGNyb3BYID0gMCwgY3JvcFkgPSAwLFxuICAgICAgICAgIG9mZnNldCwgcFdpZHRoID0gdGhpcy53aWR0aCwgcEhlaWdodCA9IHRoaXMuaGVpZ2h0LCBwYXJzZWRBdHRyaWJ1dGVzID0geyB3aWR0aDogcFdpZHRoLCBoZWlnaHQ6IHBIZWlnaHQgfTtcbiAgICAgIGlmIChwQVIgJiYgKHBBUi5hbGlnblggIT09ICdub25lJyB8fCBwQVIuYWxpZ25ZICE9PSAnbm9uZScpKSB7XG4gICAgICAgIGlmIChwQVIubWVldE9yU2xpY2UgPT09ICdtZWV0Jykge1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IGZhYnJpYy51dGlsLmZpbmRTY2FsZVRvRml0KHRoaXMuX2VsZW1lbnQsIHBhcnNlZEF0dHJpYnV0ZXMpO1xuICAgICAgICAgIG9mZnNldCA9IChwV2lkdGggLSByV2lkdGggKiBzY2FsZVgpIC8gMjtcbiAgICAgICAgICBpZiAocEFSLmFsaWduWCA9PT0gJ01pbicpIHtcbiAgICAgICAgICAgIG9mZnNldExlZnQgPSAtb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWCA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIG9mZnNldExlZnQgPSBvZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9mZnNldCA9IChwSGVpZ2h0IC0gckhlaWdodCAqIHNjYWxlWSkgLyAyO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25ZID09PSAnTWluJykge1xuICAgICAgICAgICAgb2Zmc2V0VG9wID0gLW9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNYXgnKSB7XG4gICAgICAgICAgICBvZmZzZXRUb3AgPSBvZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwQVIubWVldE9yU2xpY2UgPT09ICdzbGljZScpIHtcbiAgICAgICAgICBzY2FsZVggPSBzY2FsZVkgPSBmYWJyaWMudXRpbC5maW5kU2NhbGVUb0NvdmVyKHRoaXMuX2VsZW1lbnQsIHBhcnNlZEF0dHJpYnV0ZXMpO1xuICAgICAgICAgIG9mZnNldCA9IHJXaWR0aCAtIHBXaWR0aCAvIHNjYWxlWDtcbiAgICAgICAgICBpZiAocEFSLmFsaWduWCA9PT0gJ01pZCcpIHtcbiAgICAgICAgICAgIGNyb3BYID0gb2Zmc2V0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblggPT09ICdNYXgnKSB7XG4gICAgICAgICAgICBjcm9wWCA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Zmc2V0ID0gckhlaWdodCAtIHBIZWlnaHQgLyBzY2FsZVk7XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNaWQnKSB7XG4gICAgICAgICAgICBjcm9wWSA9IG9mZnNldCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwQVIuYWxpZ25ZID09PSAnTWF4Jykge1xuICAgICAgICAgICAgY3JvcFkgPSBvZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJXaWR0aCA9IHBXaWR0aCAvIHNjYWxlWDtcbiAgICAgICAgICBySGVpZ2h0ID0gcEhlaWdodCAvIHNjYWxlWTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNjYWxlWCA9IHBXaWR0aCAvIHJXaWR0aDtcbiAgICAgICAgc2NhbGVZID0gcEhlaWdodCAvIHJIZWlnaHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogcldpZHRoLFxuICAgICAgICBoZWlnaHQ6IHJIZWlnaHQsXG4gICAgICAgIHNjYWxlWDogc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHNjYWxlWSxcbiAgICAgICAgb2Zmc2V0TGVmdDogb2Zmc2V0TGVmdCxcbiAgICAgICAgb2Zmc2V0VG9wOiBvZmZzZXRUb3AsXG4gICAgICAgIGNyb3BYOiBjcm9wWCxcbiAgICAgICAgY3JvcFk6IGNyb3BZXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgQ1NTIGNsYXNzIG5hbWUgZm9yIGNhbnZhc1xuICAgKiBAc3RhdGljXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgZmFicmljLkltYWdlLkNTU19DQU5WQVMgPSAnY2FudmFzLWltZyc7XG5cbiAgLyoqXG4gICAqIEFsaWFzIGZvciBnZXRTcmNcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgZmFicmljLkltYWdlLnByb3RvdHlwZS5nZXRTdmdTcmMgPSBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLmdldFNyYztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UgZnJvbSBpdHMgb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gaW1hZ2UgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZyb21PYmplY3QgPSBmdW5jdGlvbihfb2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBvYmplY3QgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUoX29iamVjdCk7XG4gICAgZmFicmljLnV0aWwubG9hZEltYWdlKG9iamVjdC5zcmMsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy5JbWFnZS5wcm90b3R5cGUuX2luaXRGaWx0ZXJzLmNhbGwob2JqZWN0LCBvYmplY3QuZmlsdGVycywgZnVuY3Rpb24oZmlsdGVycykge1xuICAgICAgICBvYmplY3QuZmlsdGVycyA9IGZpbHRlcnMgfHwgW107XG4gICAgICAgIGZhYnJpYy5JbWFnZS5wcm90b3R5cGUuX2luaXRGaWx0ZXJzLmNhbGwob2JqZWN0LCBbb2JqZWN0LnJlc2l6ZUZpbHRlcl0sIGZ1bmN0aW9uKHJlc2l6ZUZpbHRlcnMpIHtcbiAgICAgICAgICBvYmplY3QucmVzaXplRmlsdGVyID0gcmVzaXplRmlsdGVyc1swXTtcbiAgICAgICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0RW5saXZhYmxlcyhvYmplY3QsIG9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGltYWdlID0gbmV3IGZhYnJpYy5JbWFnZShpbWcsIG9iamVjdCk7XG4gICAgICAgICAgICBjYWxsYmFjayhpbWFnZSwgZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sIG51bGwsIG9iamVjdC5jcm9zc09yaWdpbik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZmFicmljLkltYWdlIGZyb20gYW4gVVJMIHN0cmluZ1xuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIGNyZWF0ZSBhbiBpbWFnZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gaW1hZ2UgaXMgY3JlYXRlZCAobmV3bHkgY3JlYXRlZCBpbWFnZSBpcyBwYXNzZWQgYXMgYSBmaXJzdCBhcmd1bWVudCkuIFNlY29uZCBhcmd1bWVudCBpcyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhbiBlcnJvciBvY2N1cnJlZCBvciBub3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbaW1nT3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5mcm9tVVJMID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaywgaW1nT3B0aW9ucykge1xuICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZSh1cmwsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobmV3IGZhYnJpYy5JbWFnZShpbWcsIGltZ09wdGlvbnMpLCBpc0Vycm9yKTtcbiAgICB9LCBudWxsLCBpbWdPcHRpb25zICYmIGltZ09wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICB9O1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkltYWdlLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjSW1hZ2VFbGVtZW50fVxuICAgKi9cbiAgZmFicmljLkltYWdlLkFUVFJJQlVURV9OQU1FUyA9XG4gICAgZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdChcbiAgICAgICd4IHkgd2lkdGggaGVpZ2h0IHByZXNlcnZlQXNwZWN0UmF0aW8geGxpbms6aHJlZiBjcm9zc09yaWdpbiBpbWFnZS1yZW5kZXJpbmcnLnNwbGl0KCcgJylcbiAgICApO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuSW1hZ2V9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBmYWJyaWMuSW1hZ2Ugb2JqZWN0IGlzIGNyZWF0ZWRcbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5JbWFnZS5BVFRSSUJVVEVfTkFNRVMpO1xuICAgIGZhYnJpYy5JbWFnZS5mcm9tVVJMKHBhcnNlZEF0dHJpYnV0ZXNbJ3hsaW5rOmhyZWYnXSwgY2FsbGJhY2ssXG4gICAgICBleHRlbmQoKG9wdGlvbnMgPyBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7TnVtYmVyfSBhbmdsZSB2YWx1ZVxuICAgKi9cbiAgX2dldEFuZ2xlVmFsdWVGb3JTdHJhaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYW5nbGUgPSB0aGlzLmFuZ2xlICUgMzYwO1xuICAgIGlmIChhbmdsZSA+IDApIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKChhbmdsZSAtIDEpIC8gOTApICogOTA7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKGFuZ2xlIC8gOTApICogOTA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0cmFpZ2h0ZW5zIGFuIG9iamVjdCAocm90YXRpbmcgaXQgZnJvbSBjdXJyZW50IGFuZ2xlIHRvIG9uZSBvZiAwLCA5MCwgMTgwLCAyNzAsIGV0Yy4gZGVwZW5kaW5nIG9uIHdoaWNoIGlzIGNsb3NlcilcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzdHJhaWdodGVuOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yb3RhdGUodGhpcy5fZ2V0QW5nbGVWYWx1ZUZvclN0cmFpZ2h0ZW4oKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMge0BsaW5rIGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0cmFpZ2h0ZW59IGJ1dCB3aXRoIGFuaW1hdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2tzIE9iamVjdCB3aXRoIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ29tcGxldGVdIEludm9rZWQgb24gY29tcGxldGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ2hhbmdlXSBJbnZva2VkIG9uIGV2ZXJ5IHN0ZXAgb2YgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICovXG4gIGZ4U3RyYWlnaHRlbjogZnVuY3Rpb24oY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzIHx8IHsgfTtcblxuICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICBvbkNvbXBsZXRlID0gY2FsbGJhY2tzLm9uQ29tcGxldGUgfHwgZW1wdHksXG4gICAgICAgIG9uQ2hhbmdlID0gY2FsbGJhY2tzLm9uQ2hhbmdlIHx8IGVtcHR5LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICBzdGFydFZhbHVlOiB0aGlzLmdldCgnYW5nbGUnKSxcbiAgICAgIGVuZFZhbHVlOiB0aGlzLl9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbigpLFxuICAgICAgZHVyYXRpb246IHRoaXMuRlhfRFVSQVRJT04sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgX3RoaXMucm90YXRlKHZhbHVlKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuc2V0Q29vcmRzKCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn0pO1xuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogU3RyYWlnaHRlbnMgb2JqZWN0LCB0aGVuIHJlcmVuZGVycyBjYW52YXNcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHN0cmFpZ2h0ZW5cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzdHJhaWdodGVuT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgb2JqZWN0LnN0cmFpZ2h0ZW4oKTtcbiAgICB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyB7QGxpbmsgZmFicmljLkNhbnZhcy5wcm90b3R5cGUuc3RyYWlnaHRlbk9iamVjdH0sIGJ1dCBhbmltYXRlZFxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc3RyYWlnaHRlblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqL1xuICBmeFN0cmFpZ2h0ZW5PYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0LmZ4U3RyYWlnaHRlbih7XG4gICAgICBvbkNoYW5nZTogdGhpcy5yZXF1ZXN0UmVuZGVyQWxsQm91bmRcbiAgICB9KTtcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKipcbiAgICogVGVzdHMgaWYgd2ViZ2wgc3VwcG9ydHMgY2VydGFpbiBwcmVjaXNpb25cbiAgICogQHBhcmFtIHtXZWJHTH0gQ2FudmFzIFdlYkdMIGNvbnRleHQgdG8gdGVzdCBvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gUHJlY2lzaW9uIHRvIHRlc3QgY2FuIGJlIGFueSBvZiBmb2xsb3dpbmc6ICdsb3dwJywgJ21lZGl1bXAnLCAnaGlnaHAnXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBXZWJHTCBzdXBwb3J0cyBnaXZlbiBwcmVjaXNpb24uXG4gICAqL1xuICBmdW5jdGlvbiB0ZXN0UHJlY2lzaW9uKGdsLCBwcmVjaXNpb24pe1xuICAgIHZhciBmcmFnbWVudFNvdXJjZSA9ICdwcmVjaXNpb24gJyArIHByZWNpc2lvbiArICcgZmxvYXQ7XFxudm9pZCBtYWluKCl7fSc7XG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHRoaXMgZmlsdGVyaW5nIGJhY2tlbmQgaXMgc3VwcG9ydGVkIGJ5IHRoZSB1c2VyJ3MgYnJvd3Nlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbGVTaXplIGNoZWNrIGlmIHRoZSB0aWxlU2l6ZSBpcyBzdXBwb3J0ZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIHN1cHBvcnRzIFdlYkdMLlxuICAgKi9cbiAgZmFicmljLmlzV2ViZ2xTdXBwb3J0ZWQgPSBmdW5jdGlvbih0aWxlU2l6ZSkge1xuICAgIGlmIChmYWJyaWMuaXNMaWtlbHlOb2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRpbGVTaXplID0gdGlsZVNpemUgfHwgZmFicmljLldlYmdsRmlsdGVyQmFja2VuZC5wcm90b3R5cGUudGlsZVNpemU7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKTtcbiAgICB2YXIgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBpZiAoZ2wpIHtcbiAgICAgIGZhYnJpYy5tYXhUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKTtcbiAgICAgIGlzU3VwcG9ydGVkID0gZmFicmljLm1heFRleHR1cmVTaXplID49IHRpbGVTaXplO1xuICAgICAgdmFyIHByZWNpc2lvbnMgPSBbJ2hpZ2hwJywgJ21lZGl1bXAnLCAnbG93cCddO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspe1xuICAgICAgICBpZiAodGVzdFByZWNpc2lvbihnbCwgcHJlY2lzaW9uc1tpXSkpe1xuICAgICAgICAgIGZhYnJpYy53ZWJHbFByZWNpc2lvbiA9IHByZWNpc2lvbnNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBpc1N1cHBvcnRlZDtcbiAgICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG4gIH07XG5cbiAgZmFicmljLldlYmdsRmlsdGVyQmFja2VuZCA9IFdlYmdsRmlsdGVyQmFja2VuZDtcblxuICAvKipcbiAgICogV2ViR0wgZmlsdGVyIGJhY2tlbmQuXG4gICAqL1xuICBmdW5jdGlvbiBXZWJnbEZpbHRlckJhY2tlbmQob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudGlsZVNpemUpIHtcbiAgICAgIHRoaXMudGlsZVNpemUgPSBvcHRpb25zLnRpbGVTaXplO1xuICAgIH1cbiAgICB0aGlzLnNldHVwR0xDb250ZXh0KHRoaXMudGlsZVNpemUsIHRoaXMudGlsZVNpemUpO1xuICAgIHRoaXMuY2FwdHVyZUdQVUluZm8oKTtcbiAgfTtcblxuICBXZWJnbEZpbHRlckJhY2tlbmQucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuV2ViZ2xGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZSAqLyB7XG5cbiAgICB0aWxlU2l6ZTogMjA0OCxcblxuICAgIC8qKlxuICAgICAqIEV4cGVyaW1lbnRhbC4gVGhpcyBvYmplY3QgaXMgYSBzb3J0IG9mIHJlcG9zaXRvcnkgb2YgaGVscCBsYXllcnMgdXNlZCB0byBhdm9pZFxuICAgICAqIG9mIHJlY3JlYXRpbmcgdGhlbSBkdXJpbmcgZnJlcXVlbnQgZmlsdGVyaW5nLiBJZiB5b3UgYXJlIHByZXZpZXdpbmcgYSBmaWx0ZXIgd2l0aFxuICAgICAqIGEgc2xpZGVyIHlvdSBwcm9iYWJseSBkbyBub3Qgd2FudCB0byBjcmVhdGUgaGVscCBsYXllcnMgZXZlcnkgZmlsdGVyIHN0ZXAuXG4gICAgICogaW4gdGhpcyBvYmplY3QgdGhlcmUgd2lsbCBiZSBhcHBlbmRlZCBzb21lIGNhbnZhc2VzLCBjcmVhdGVkIG9uY2UsIHJlc2l6ZWQgc29tZXRpbWVzXG4gICAgICogY2xlYXJlZCBuZXZlci4gQ2xlYXJpbmcgaXMgbGVmdCB0byB0aGUgZGV2ZWxvcGVyLlxuICAgICAqKi9cbiAgICByZXNvdXJjZXM6IHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXR1cCBhIFdlYkdMIGNvbnRleHQgc3VpdGFibGUgZm9yIGZpbHRlcmluZywgYW5kIGJpbmQgYW55IG5lZWRlZCBldmVudCBoYW5kbGVycy5cbiAgICAgKi9cbiAgICBzZXR1cEdMQ29udGV4dDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLmNyZWF0ZVdlYkdMQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB0aGlzLmFQb3NpdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDAsIDEsIDEsIDAsIDEsIDFdKTtcbiAgICAgIHRoaXMuY2hvb3NlRmFzdGVzdENvcHlHTFRvMkRNZXRob2Qod2lkdGgsIGhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBpY2sgYSBtZXRob2QgdG8gY29weSBkYXRhIGZyb20gR0wgY29udGV4dCB0byAyZCBjYW52YXMuICBJbiBzb21lIGJyb3dzZXJzIHVzaW5nXG4gICAgICogcHV0SW1hZ2VEYXRhIGlzIGZhc3RlciB0aGFuIGRyYXdJbWFnZSBmb3IgdGhhdCBzcGVjaWZpYyBvcGVyYXRpb24uXG4gICAgICovXG4gICAgY2hvb3NlRmFzdGVzdENvcHlHTFRvMkRNZXRob2Q6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBjYW5NZWFzdXJlUGVyZiA9IHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnLCBjYW5Vc2VJbWFnZURhdGE7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgSW1hZ2VEYXRhKDEsIDEpO1xuICAgICAgICBjYW5Vc2VJbWFnZURhdGEgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FuVXNlSW1hZ2VEYXRhID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBjYW5Vc2VBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBjYW5Vc2VVaW50OENsYW1wZWQgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICBpZiAoIShjYW5NZWFzdXJlUGVyZiAmJiBjYW5Vc2VJbWFnZURhdGEgJiYgY2FuVXNlQXJyYXlCdWZmZXIgJiYgY2FuVXNlVWludDhDbGFtcGVkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnZXRDYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBpbWFnZUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgaWYgKGZhYnJpYy5mb3JjZUdMUHV0SW1hZ2VEYXRhKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VCdWZmZXIgPSBpbWFnZUJ1ZmZlcjtcbiAgICAgICAgdGhpcy5jb3B5R0xUbzJEID0gY29weUdMVG8yRFB1dEltYWdlRGF0YTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHRlc3RDb250ZXh0ID0ge1xuICAgICAgICBpbWFnZUJ1ZmZlcjogaW1hZ2VCdWZmZXIsXG4gICAgICAgIGRlc3RpbmF0aW9uV2lkdGg6IHdpZHRoLFxuICAgICAgICBkZXN0aW5hdGlvbkhlaWdodDogaGVpZ2h0LFxuICAgICAgICB0YXJnZXRDYW52YXM6IHRhcmdldENhbnZhc1xuICAgICAgfTtcbiAgICAgIHZhciBzdGFydFRpbWUsIGRyYXdJbWFnZVRpbWUsIHB1dEltYWdlRGF0YVRpbWU7XG4gICAgICB0YXJnZXRDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIHN0YXJ0VGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvcHlHTFRvMkREcmF3SW1hZ2UuY2FsbCh0ZXN0Q29udGV4dCwgdGhpcy5nbCwgdGVzdENvbnRleHQpO1xuICAgICAgZHJhd0ltYWdlVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgc3RhcnRUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29weUdMVG8yRFB1dEltYWdlRGF0YS5jYWxsKHRlc3RDb250ZXh0LCB0aGlzLmdsLCB0ZXN0Q29udGV4dCk7XG4gICAgICBwdXRJbWFnZURhdGFUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICBpZiAoZHJhd0ltYWdlVGltZSA+IHB1dEltYWdlRGF0YVRpbWUpIHtcbiAgICAgICAgdGhpcy5pbWFnZUJ1ZmZlciA9IGltYWdlQnVmZmVyO1xuICAgICAgICB0aGlzLmNvcHlHTFRvMkQgPSBjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuY29weUdMVG8yRCA9IGNvcHlHTFRvMkREcmF3SW1hZ2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNhbnZhcyBlbGVtZW50IGFuZCBhc3NvY2lhdGVkIFdlYkdMIGNvbnRleHQgYW5kIGF0dGFjaGVzIHRoZW0gYXNcbiAgICAgKiBjbGFzcyBwcm9wZXJ0aWVzIHRvIHRoZSBHTEZpbHRlckJhY2tlbmQgY2xhc3MuXG4gICAgICovXG4gICAgY3JlYXRlV2ViR0xDYW52YXM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBjYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB2YXIgZ2xPcHRpb25zID0ge1xuICAgICAgICAgICAgYWxwaGE6IHRydWUsXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLFxuICAgICAgICAgICAgZGVwdGg6IGZhbHNlLFxuICAgICAgICAgICAgc3RlbmNpbDogZmFsc2UsXG4gICAgICAgICAgICBhbnRpYWxpYXM6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGdsT3B0aW9ucyk7XG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGdsT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgICAvLyB0aGlzIGNhbnZhcyBjYW4gZmlyZSB3ZWJnbGNvbnRleHRsb3N0IGFuZCB3ZWJnbGNvbnRleHRyZXN0b3JlZFxuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLmdsID0gZ2w7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGFwcGx5IHRoZSByZXF1ZXN0ZWQgZmlsdGVycyB0byB0aGUgc291cmNlIHByb3ZpZGVkLCBkcmF3aW5nIHRoZSBmaWx0ZXJlZCBvdXRwdXRcbiAgICAgKiB0byB0aGUgcHJvdmlkZWQgdGFyZ2V0IGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgVGhlIGZpbHRlcnMgdG8gYXBwbHkuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBzb3VyY2UgVGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBzb3VyY2UgaW5wdXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBzb3VyY2UgaW5wdXQuXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gdGFyZ2V0Q2FudmFzIFRoZSBkZXN0aW5hdGlvbiBmb3IgZmlsdGVyZWQgb3V0cHV0IHRvIGJlIGRyYXduLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfHVuZGVmaW5lZH0gY2FjaGVLZXkgQSBrZXkgdXNlZCB0byBjYWNoZSByZXNvdXJjZXMgcmVsYXRlZCB0byB0aGUgc291cmNlLiBJZlxuICAgICAqIG9taXR0ZWQsIGNhY2hpbmcgd2lsbCBiZSBza2lwcGVkLlxuICAgICAqL1xuICAgIGFwcGx5RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycywgc291cmNlLCB3aWR0aCwgaGVpZ2h0LCB0YXJnZXRDYW52YXMsIGNhY2hlS2V5KSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgdmFyIGNhY2hlZFRleHR1cmU7XG4gICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgY2FjaGVkVGV4dHVyZSA9IHRoaXMuZ2V0Q2FjaGVkVGV4dHVyZShjYWNoZUtleSwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBwaXBlbGluZVN0YXRlID0ge1xuICAgICAgICBvcmlnaW5hbFdpZHRoOiBzb3VyY2Uud2lkdGggfHwgc291cmNlLm9yaWdpbmFsV2lkdGgsXG4gICAgICAgIG9yaWdpbmFsSGVpZ2h0OiBzb3VyY2UuaGVpZ2h0IHx8IHNvdXJjZS5vcmlnaW5hbEhlaWdodCxcbiAgICAgICAgc291cmNlV2lkdGg6IHdpZHRoLFxuICAgICAgICBzb3VyY2VIZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgZGVzdGluYXRpb25XaWR0aDogd2lkdGgsXG4gICAgICAgIGRlc3RpbmF0aW9uSGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGNvbnRleHQ6IGdsLFxuICAgICAgICBzb3VyY2VUZXh0dXJlOiB0aGlzLmNyZWF0ZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsICFjYWNoZWRUZXh0dXJlICYmIHNvdXJjZSksXG4gICAgICAgIHRhcmdldFRleHR1cmU6IHRoaXMuY3JlYXRlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCksXG4gICAgICAgIG9yaWdpbmFsVGV4dHVyZTogY2FjaGVkVGV4dHVyZSB8fFxuICAgICAgICAgIHRoaXMuY3JlYXRlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgIWNhY2hlZFRleHR1cmUgJiYgc291cmNlKSxcbiAgICAgICAgcGFzc2VzOiBmaWx0ZXJzLmxlbmd0aCxcbiAgICAgICAgd2ViZ2w6IHRydWUsXG4gICAgICAgIGFQb3NpdGlvbjogdGhpcy5hUG9zaXRpb24sXG4gICAgICAgIHByb2dyYW1DYWNoZTogdGhpcy5wcm9ncmFtQ2FjaGUsXG4gICAgICAgIHBhc3M6IDAsXG4gICAgICAgIGZpbHRlckJhY2tlbmQ6IHRoaXMsXG4gICAgICAgIHRhcmdldENhbnZhczogdGFyZ2V0Q2FudmFzXG4gICAgICB9O1xuICAgICAgdmFyIHRlbXBGYm8gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0ZW1wRmJvKTtcbiAgICAgIGZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXIpIHsgZmlsdGVyICYmIGZpbHRlci5hcHBseVRvKHBpcGVsaW5lU3RhdGUpOyB9KTtcbiAgICAgIHJlc2l6ZUNhbnZhc0lmTmVlZGVkKHBpcGVsaW5lU3RhdGUpO1xuICAgICAgdGhpcy5jb3B5R0xUbzJEKGdsLCBwaXBlbGluZVN0YXRlKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgZ2wuZGVsZXRlVGV4dHVyZShwaXBlbGluZVN0YXRlLnNvdXJjZVRleHR1cmUpO1xuICAgICAgZ2wuZGVsZXRlVGV4dHVyZShwaXBlbGluZVN0YXRlLnRhcmdldFRleHR1cmUpO1xuICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIodGVtcEZibyk7XG4gICAgICB0YXJnZXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICByZXR1cm4gcGlwZWxpbmVTdGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0YWNoIGV2ZW50IGxpc3RlbmVycywgcmVtb3ZlIHJlZmVyZW5jZXMsIGFuZCBjbGVhbiB1cCBjYWNoZXMuXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgICB0aGlzLmdsID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJXZWJHTENhY2hlcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaXBlIG91dCBXZWJHTC1yZWxhdGVkIGNhY2hlcy5cbiAgICAgKi9cbiAgICBjbGVhcldlYkdMQ2FjaGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucHJvZ3JhbUNhY2hlID0ge307XG4gICAgICB0aGlzLnRleHR1cmVDYWNoZSA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBXZWJHTCB0ZXh0dXJlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEFjY2VwdHMgc3BlY2lmaWMgZGltZW5zaW9ucyB0byBpbml0aWFsaXplIHRoZSB0ZXh0dXJlIHRvIG9yIGEgc291cmNlIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjb250ZXh0IHRvIHVzZSBmb3IgY3JlYXRpbmcgdGhlIHRleHR1cmUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCB0byBpbml0aWFsaXplIHRoZSB0ZXh0dXJlIGF0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCB0byBpbml0aWFsaXplIHRoZSB0ZXh0dXJlLlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gdGV4dHVyZUltYWdlU291cmNlIEEgc291cmNlIGZvciB0aGUgdGV4dHVyZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmaWx0ZXJUeXBlIGdsLk5FQVJFU1Qgb3IgZ2wuTElORUFSIHVzdWFsbHksIHdlYmdsIG51bWVyaSBjb25zdGFudHNcbiAgICAgKiBAcmV0dXJucyB7V2ViR0xUZXh0dXJlfVxuICAgICAqL1xuICAgIGNyZWF0ZVRleHR1cmU6IGZ1bmN0aW9uKGdsLCB3aWR0aCwgaGVpZ2h0LCB0ZXh0dXJlSW1hZ2VTb3VyY2UsIGZpbHRlclR5cGUpIHtcbiAgICAgIHZhciB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyVHlwZSB8fCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJUeXBlIHx8IGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGlmICh0ZXh0dXJlSW1hZ2VTb3VyY2UpIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0ZXh0dXJlSW1hZ2VTb3VyY2UpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgd2lkdGgsIGhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FuIGJlIG9wdGlvbmFsbHkgdXNlZCB0byBnZXQgYSB0ZXh0dXJlIGZyb20gdGhlIGNhY2hlIGFycmF5XG4gICAgICpcbiAgICAgKiBJZiBhbiBleGlzdGluZyB0ZXh0dXJlIGlzIG5vdCBmb3VuZCwgYSBuZXcgdGV4dHVyZSBpcyBjcmVhdGVkIGFuZCBjYWNoZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdW5pcXVlSWQgQSBjYWNoZSBrZXkgdG8gdXNlIHRvIGZpbmQgYW4gZXhpc3RpbmcgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHRleHR1cmVJbWFnZVNvdXJjZSBBIHNvdXJjZSB0byB1c2UgdG8gY3JlYXRlIHRoZVxuICAgICAqIHRleHR1cmUgY2FjaGUgZW50cnkgaWYgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXG4gICAgICovXG4gICAgZ2V0Q2FjaGVkVGV4dHVyZTogZnVuY3Rpb24odW5pcXVlSWQsIHRleHR1cmVJbWFnZVNvdXJjZSkge1xuICAgICAgaWYgKHRoaXMudGV4dHVyZUNhY2hlW3VuaXF1ZUlkXSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlQ2FjaGVbdW5pcXVlSWRdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKFxuICAgICAgICAgIHRoaXMuZ2wsIHRleHR1cmVJbWFnZVNvdXJjZS53aWR0aCwgdGV4dHVyZUltYWdlU291cmNlLmhlaWdodCwgdGV4dHVyZUltYWdlU291cmNlKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlQ2FjaGVbdW5pcXVlSWRdID0gdGV4dHVyZTtcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIG91dCBjYWNoZWQgcmVzb3VyY2VzIHJlbGF0ZWQgdG8gYSBzb3VyY2UgaW1hZ2UgdGhhdCBoYXMgYmVlblxuICAgICAqIGZpbHRlcmVkIHByZXZpb3VzbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2FjaGVLZXkgVGhlIGNhY2hlIGtleSBwcm92aWRlZCB3aGVuIHRoZSBzb3VyY2UgaW1hZ2Ugd2FzIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGV2aWN0Q2FjaGVzRm9yS2V5OiBmdW5jdGlvbihjYWNoZUtleSkge1xuICAgICAgaWYgKHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XSkge1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldKTtcbiAgICAgICAgZGVsZXRlIHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29weUdMVG8yRDogY29weUdMVG8yRERyYXdJbWFnZSxcblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gZXh0cmFjdCBHUFUgaW5mb3JtYXRpb24gc3RyaW5ncyBmcm9tIGEgV2ViR0wgY29udGV4dC5cbiAgICAgKlxuICAgICAqIFVzZWZ1bCBpbmZvcm1hdGlvbiB3aGVuIGRlYnVnZ2luZyBvciBibGFja2xpc3Rpbmcgc3BlY2lmaWMgR1BVcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEEgR1BVIGluZm8gb2JqZWN0IHdpdGggcmVuZGVyZXIgYW5kIHZlbmRvciBzdHJpbmdzLlxuICAgICAqL1xuICAgIGNhcHR1cmVHUFVJbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmdwdUluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3B1SW5mbztcbiAgICAgIH1cbiAgICAgIHZhciBnbCA9IHRoaXMuZ2wsIGdwdUluZm8gPSB7IHJlbmRlcmVyOiAnJywgdmVuZG9yOiAnJyB9O1xuICAgICAgaWYgKCFnbCkge1xuICAgICAgICByZXR1cm4gZ3B1SW5mbztcbiAgICAgIH1cbiAgICAgIHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RlYnVnX3JlbmRlcmVyX2luZm8nKTtcbiAgICAgIGlmIChleHQpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gZ2wuZ2V0UGFyYW1ldGVyKGV4dC5VTk1BU0tFRF9SRU5ERVJFUl9XRUJHTCk7XG4gICAgICAgIHZhciB2ZW5kb3IgPSBnbC5nZXRQYXJhbWV0ZXIoZXh0LlVOTUFTS0VEX1ZFTkRPUl9XRUJHTCk7XG4gICAgICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgICAgIGdwdUluZm8ucmVuZGVyZXIgPSByZW5kZXJlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZW5kb3IpIHtcbiAgICAgICAgICBncHVJbmZvLnZlbmRvciA9IHZlbmRvci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmdwdUluZm8gPSBncHVJbmZvO1xuICAgICAgcmV0dXJuIGdwdUluZm87XG4gICAgfSxcbiAgfTtcbn0pKCk7XG5cbmZ1bmN0aW9uIHJlc2l6ZUNhbnZhc0lmTmVlZGVkKHBpcGVsaW5lU3RhdGUpIHtcbiAgdmFyIHRhcmdldENhbnZhcyA9IHBpcGVsaW5lU3RhdGUudGFyZ2V0Q2FudmFzLFxuICAgICAgd2lkdGggPSB0YXJnZXRDYW52YXMud2lkdGgsIGhlaWdodCA9IHRhcmdldENhbnZhcy5oZWlnaHQsXG4gICAgICBkV2lkdGggPSBwaXBlbGluZVN0YXRlLmRlc3RpbmF0aW9uV2lkdGgsXG4gICAgICBkSGVpZ2h0ID0gcGlwZWxpbmVTdGF0ZS5kZXN0aW5hdGlvbkhlaWdodDtcblxuICBpZiAod2lkdGggIT09IGRXaWR0aCB8fCBoZWlnaHQgIT09IGRIZWlnaHQpIHtcbiAgICB0YXJnZXRDYW52YXMud2lkdGggPSBkV2lkdGg7XG4gICAgdGFyZ2V0Q2FudmFzLmhlaWdodCA9IGRIZWlnaHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5IGFuIGlucHV0IFdlYkdMIGNhbnZhcyBvbiB0byBhbiBvdXRwdXQgMkQgY2FudmFzLlxuICpcbiAqIFRoZSBXZWJHTCBjYW52YXMgaXMgYXNzdW1lZCB0byBiZSB1cHNpZGUgZG93biwgd2l0aCB0aGUgdG9wLWxlZnQgcGl4ZWwgb2YgdGhlXG4gKiBkZXNpcmVkIG91dHB1dCBpbWFnZSBhcHBlYXJpbmcgaW4gdGhlIGJvdHRvbS1sZWZ0IGNvcm5lciBvZiB0aGUgV2ViR0wgY2FudmFzLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBzb3VyY2VDb250ZXh0IFRoZSBXZWJHTCBjb250ZXh0IHRvIGNvcHkgZnJvbS5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IHRhcmdldENhbnZhcyBUaGUgMkQgdGFyZ2V0IGNhbnZhcyB0byBjb3B5IG9uIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IHBpcGVsaW5lU3RhdGUgVGhlIDJEIHRhcmdldCBjYW52YXMgdG8gY29weSBvbiB0by5cbiAqL1xuZnVuY3Rpb24gY29weUdMVG8yRERyYXdJbWFnZShnbCwgcGlwZWxpbmVTdGF0ZSkge1xuICB2YXIgZ2xDYW52YXMgPSBnbC5jYW52YXMsIHRhcmdldENhbnZhcyA9IHBpcGVsaW5lU3RhdGUudGFyZ2V0Q2FudmFzLFxuICAgICAgY3R4ID0gdGFyZ2V0Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGN0eC50cmFuc2xhdGUoMCwgdGFyZ2V0Q2FudmFzLmhlaWdodCk7IC8vIG1vdmUgaXQgZG93biBhZ2FpblxuICBjdHguc2NhbGUoMSwgLTEpOyAvLyB2ZXJ0aWNhbCBmbGlwXG4gIC8vIHdoZXJlIGlzIG15IGltYWdlIG9uIHRoZSBiaWcgZ2xjYW52YXM/XG4gIHZhciBzb3VyY2VZID0gZ2xDYW52YXMuaGVpZ2h0IC0gdGFyZ2V0Q2FudmFzLmhlaWdodDtcbiAgY3R4LmRyYXdJbWFnZShnbENhbnZhcywgMCwgc291cmNlWSwgdGFyZ2V0Q2FudmFzLndpZHRoLCB0YXJnZXRDYW52YXMuaGVpZ2h0LCAwLCAwLFxuICAgIHRhcmdldENhbnZhcy53aWR0aCwgdGFyZ2V0Q2FudmFzLmhlaWdodCk7XG59XG5cbi8qKlxuICogQ29weSBhbiBpbnB1dCBXZWJHTCBjYW52YXMgb24gdG8gYW4gb3V0cHV0IDJEIGNhbnZhcyB1c2luZyAyZCBjYW52YXMnIHB1dEltYWdlRGF0YVxuICogQVBJLiBNZWFzdXJhYmx5IGZhc3RlciB0aGFuIHVzaW5nIGN0eC5kcmF3SW1hZ2UgaW4gRmlyZWZveCAodmVyc2lvbiA1NCBvbiBPU1ggU2llcnJhKS5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gc291cmNlQ29udGV4dCBUaGUgV2ViR0wgY29udGV4dCB0byBjb3B5IGZyb20uXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSB0YXJnZXRDYW52YXMgVGhlIDJEIHRhcmdldCBjYW52YXMgdG8gY29weSBvbiB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwaXBlbGluZVN0YXRlIFRoZSAyRCB0YXJnZXQgY2FudmFzIHRvIGNvcHkgb24gdG8uXG4gKi9cbmZ1bmN0aW9uIGNvcHlHTFRvMkRQdXRJbWFnZURhdGEoZ2wsIHBpcGVsaW5lU3RhdGUpIHtcbiAgdmFyIHRhcmdldENhbnZhcyA9IHBpcGVsaW5lU3RhdGUudGFyZ2V0Q2FudmFzLCBjdHggPSB0YXJnZXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIGRXaWR0aCA9IHBpcGVsaW5lU3RhdGUuZGVzdGluYXRpb25XaWR0aCxcbiAgICAgIGRIZWlnaHQgPSBwaXBlbGluZVN0YXRlLmRlc3RpbmF0aW9uSGVpZ2h0LFxuICAgICAgbnVtQnl0ZXMgPSBkV2lkdGggKiBkSGVpZ2h0ICogNDtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIHU4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5pbWFnZUJ1ZmZlciwgMCwgbnVtQnl0ZXMpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIHU4Q2xhbXBlZCA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh0aGlzLmltYWdlQnVmZmVyLCAwLCBudW1CeXRlcyk7XG5cbiAgZ2wucmVhZFBpeGVscygwLCAwLCBkV2lkdGgsIGRIZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHU4KTtcbiAgdmFyIGltZ0RhdGEgPSBuZXcgSW1hZ2VEYXRhKHU4Q2xhbXBlZCwgZFdpZHRoLCBkSGVpZ2h0KTtcbiAgY3R4LnB1dEltYWdlRGF0YShpbWdEYXRhLCAwLCAwKTtcbn1cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxuICBmYWJyaWMuQ2FudmFzMmRGaWx0ZXJCYWNrZW5kID0gQ2FudmFzMmRGaWx0ZXJCYWNrZW5kO1xuXG4gIC8qKlxuICAgKiBDYW52YXMgMkQgZmlsdGVyIGJhY2tlbmQuXG4gICAqL1xuICBmdW5jdGlvbiBDYW52YXMyZEZpbHRlckJhY2tlbmQoKSB7fTtcblxuICBDYW52YXMyZEZpbHRlckJhY2tlbmQucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuQ2FudmFzMmRGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZSAqLyB7XG4gICAgZXZpY3RDYWNoZXNGb3JLZXk6IG5vb3AsXG4gICAgZGlzcG9zZTogbm9vcCxcbiAgICBjbGVhcldlYkdMQ2FjaGVzOiBub29wLFxuXG4gICAgLyoqXG4gICAgICogRXhwZXJpbWVudGFsLiBUaGlzIG9iamVjdCBpcyBhIHNvcnQgb2YgcmVwb3NpdG9yeSBvZiBoZWxwIGxheWVycyB1c2VkIHRvIGF2b2lkXG4gICAgICogb2YgcmVjcmVhdGluZyB0aGVtIGR1cmluZyBmcmVxdWVudCBmaWx0ZXJpbmcuIElmIHlvdSBhcmUgcHJldmlld2luZyBhIGZpbHRlciB3aXRoXG4gICAgICogYSBzbGlkZXIgeW91IHByb2JhYmx5IGRvIG5vdCB3YW50IHRvIGNyZWF0ZSBoZWxwIGxheWVycyBldmVyeSBmaWx0ZXIgc3RlcC5cbiAgICAgKiBpbiB0aGlzIG9iamVjdCB0aGVyZSB3aWxsIGJlIGFwcGVuZGVkIHNvbWUgY2FudmFzZXMsIGNyZWF0ZWQgb25jZSwgcmVzaXplZCBzb21ldGltZXNcbiAgICAgKiBjbGVhcmVkIG5ldmVyLiBDbGVhcmluZyBpcyBsZWZ0IHRvIHRoZSBkZXZlbG9wZXIuXG4gICAgICoqL1xuICAgIHJlc291cmNlczoge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IGEgc2V0IG9mIGZpbHRlcnMgYWdhaW5zdCBhIHNvdXJjZSBpbWFnZSBhbmQgZHJhdyB0aGUgZmlsdGVyZWQgb3V0cHV0XG4gICAgICogdG8gdGhlIHByb3ZpZGVkIGRlc3RpbmF0aW9uIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RW5oYW5jZWRGaWx0ZXJ9IGZpbHRlcnMgVGhlIGZpbHRlciB0byBhcHBseS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHNvdXJjZUVsZW1lbnQgVGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBzb3VyY2UgaW5wdXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZUhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBzb3VyY2UgaW5wdXQuXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gdGFyZ2V0Q2FudmFzIFRoZSBkZXN0aW5hdGlvbiBmb3IgZmlsdGVyZWQgb3V0cHV0IHRvIGJlIGRyYXduLlxuICAgICAqL1xuICAgIGFwcGx5RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycywgc291cmNlRWxlbWVudCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGFyZ2V0Q2FudmFzKSB7XG4gICAgICB2YXIgY3R4ID0gdGFyZ2V0Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguZHJhd0ltYWdlKHNvdXJjZUVsZW1lbnQsIDAsIDAsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgICAgdmFyIGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCk7XG4gICAgICB2YXIgb3JpZ2luYWxJbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgICAgdmFyIHBpcGVsaW5lU3RhdGUgPSB7XG4gICAgICAgIHNvdXJjZVdpZHRoOiBzb3VyY2VXaWR0aCxcbiAgICAgICAgc291cmNlSGVpZ2h0OiBzb3VyY2VIZWlnaHQsXG4gICAgICAgIGltYWdlRGF0YTogaW1hZ2VEYXRhLFxuICAgICAgICBvcmlnaW5hbEVsOiBzb3VyY2VFbGVtZW50LFxuICAgICAgICBvcmlnaW5hbEltYWdlRGF0YTogb3JpZ2luYWxJbWFnZURhdGEsXG4gICAgICAgIGNhbnZhc0VsOiB0YXJnZXRDYW52YXMsXG4gICAgICAgIGN0eDogY3R4LFxuICAgICAgICBmaWx0ZXJCYWNrZW5kOiB0aGlzLFxuICAgICAgfTtcbiAgICAgIGZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXIpIHsgZmlsdGVyLmFwcGx5VG8ocGlwZWxpbmVTdGF0ZSk7IH0pO1xuICAgICAgaWYgKHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLndpZHRoICE9PSBzb3VyY2VXaWR0aCB8fCBwaXBlbGluZVN0YXRlLmltYWdlRGF0YS5oZWlnaHQgIT09IHNvdXJjZUhlaWdodCkge1xuICAgICAgICB0YXJnZXRDYW52YXMud2lkdGggPSBwaXBlbGluZVN0YXRlLmltYWdlRGF0YS53aWR0aDtcbiAgICAgICAgdGFyZ2V0Q2FudmFzLmhlaWdodCA9IHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEocGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEsIDAsIDApO1xuICAgICAgcmV0dXJuIHBpcGVsaW5lU3RhdGU7XG4gICAgfSxcblxuICB9O1xufSkoKTtcblxuXG4vKipcbiAqIEBuYW1lc3BhY2UgZmFicmljLkltYWdlLmZpbHRlcnNcbiAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2VcbiAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2ltYWdlX2ZpbHRlcnN9XG4gKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gKi9cbmZhYnJpYy5JbWFnZSA9IGZhYnJpYy5JbWFnZSB8fCB7IH07XG5mYWJyaWMuSW1hZ2UuZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzIHx8IHsgfTtcblxuLyoqXG4gKiBSb290IGZpbHRlciBjbGFzcyBmcm9tIHdoaWNoIGFsbCBmaWx0ZXIgY2xhc3NlcyBpbmhlcml0IGZyb21cbiAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAqL1xuZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlciA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBGaWx0ZXIgdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgdHlwZTogJ0Jhc2VGaWx0ZXInLFxuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHNlbmQgd2l0aCBidWZmZXJzLiBkbyBub3QgbW9kaWZ5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHZlcnRleFNvdXJjZTogJ2F0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcXG4nICtcbiAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgJ3ZUZXhDb29yZCA9IGFQb3NpdGlvbjtcXG4nICtcbiAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uICogMi4wIC0gMS4wLCAwLjAsIDEuMCk7XFxuJyArXG4gICAgJ30nLFxuXG4gIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgJ2dsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAnfScsXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBmaWx0ZXIncyBwcm9wZXJ0aWVzIGZyb20gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIgcHJvZ3JhbS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB0byB1c2UgZm9yIHNoYWRlciBjb21waWxhdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGZyYWdtZW50U291cmNlIGZyYWdtZW50U2hhZGVyIHNvdXJjZSBmb3IgY29tcGlsYXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZlcnRleFNvdXJjZSB2ZXJ0ZXhTaGFkZXIgc291cmNlIGZvciBjb21waWxhdGlvblxuICAgKi9cbiAgY3JlYXRlUHJvZ3JhbTogZnVuY3Rpb24oZ2wsIGZyYWdtZW50U291cmNlLCB2ZXJ0ZXhTb3VyY2UpIHtcbiAgICBmcmFnbWVudFNvdXJjZSA9IGZyYWdtZW50U291cmNlIHx8IHRoaXMuZnJhZ21lbnRTb3VyY2U7XG4gICAgdmVydGV4U291cmNlID0gdmVydGV4U291cmNlIHx8IHRoaXMudmVydGV4U291cmNlO1xuICAgIGlmIChmYWJyaWMud2ViR2xQcmVjaXNpb24gIT09ICdoaWdocCcpe1xuICAgICAgZnJhZ21lbnRTb3VyY2UgPSBmcmFnbWVudFNvdXJjZS5yZXBsYWNlKFxuICAgICAgICAvcHJlY2lzaW9uIGhpZ2hwIGZsb2F0L2csXG4gICAgICAgICdwcmVjaXNpb24gJyArIGZhYnJpYy53ZWJHbFByZWNpc2lvbiArICcgZmxvYXQnXG4gICAgICApO1xuICAgIH1cbiAgICB2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICAgIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnRleFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItdGVtcGxhdGVcbiAgICAgICAgJ1ZlcnRleCBzaGFkZXIgY29tcGlsZSBlcnJvciBmb3IgJyArIHRoaXMudHlwZSArICc6ICcgK1xuICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXRlbXBsYXRlXG4gICAgICAgICdGcmFnbWVudCBzaGFkZXIgY29tcGlsZSBlcnJvciBmb3IgJyArIHRoaXMudHlwZSArICc6ICcgK1xuICAgICAgICBnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdtZW50U2hhZGVyKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci10ZW1wbGF0ZVxuICAgICAgICAnU2hhZGVyIGxpbmsgZXJyb3IgZm9yIFwiJHt0aGlzLnR5cGV9XCIgJyArXG4gICAgICAgIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVMb2NhdGlvbnMgPSB0aGlzLmdldEF0dHJpYnV0ZUxvY2F0aW9ucyhnbCwgcHJvZ3JhbSk7XG4gICAgdmFyIHVuaWZvcm1Mb2NhdGlvbnMgPSB0aGlzLmdldFVuaWZvcm1Mb2NhdGlvbnMoZ2wsIHByb2dyYW0pIHx8IHsgfTtcbiAgICB1bmlmb3JtTG9jYXRpb25zLnVTdGVwVyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVN0ZXBXJyk7XG4gICAgdW5pZm9ybUxvY2F0aW9ucy51U3RlcEggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTdGVwSCcpO1xuICAgIHJldHVybiB7XG4gICAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgICAgYXR0cmlidXRlTG9jYXRpb25zOiBhdHRyaWJ1dGVMb2NhdGlvbnMsXG4gICAgICB1bmlmb3JtTG9jYXRpb25zOiB1bmlmb3JtTG9jYXRpb25zXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbWFwIG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBXZWJHTEF0dHJpYnV0ZUxvY2F0aW9uIG9iamVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhlIHNoYWRlciBwcm9ncmFtIGZyb20gd2hpY2ggdG8gdGFrZSBhdHRyaWJ1dGUgbG9jYXRpb25zLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIG1hcCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYXR0cmlidXRlIGxvY2F0aW9ucy5cbiAgICovXG4gIGdldEF0dHJpYnV0ZUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgYVBvc2l0aW9uOiBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVBvc2l0aW9uJyksXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbWFwIG9mIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0cy5cbiAgICpcbiAgICogSW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoZSBzaGFkZXIgcHJvZ3JhbSBmcm9tIHdoaWNoIHRvIHRha2UgdW5pZm9ybSBsb2NhdGlvbnMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEEgbWFwIG9mIHVuaWZvcm0gbmFtZXMgdG8gdW5pZm9ybSBsb2NhdGlvbnMuXG4gICAqL1xuICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbiAoLyogZ2wsIHByb2dyYW0gKi8pIHtcbiAgICAvLyBpbiBjYXNlIGkgZG8gbm90IG5lZWQgYW55IHNwZWNpYWwgdW5pZm9ybSBpIG5lZWQgdG8gcmV0dXJuIGFuIGVtcHR5IG9iamVjdFxuICAgIHJldHVybiB7IH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbmQgYXR0cmlidXRlIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0gb24gdGhlIEdQVS5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlTG9jYXRpb25zIEEgbWFwIG9mIHNoYWRlciBhdHRyaWJ1dGUgbmFtZXMgdG8gdGhlaXIgbG9jYXRpb25zLlxuICAgKi9cbiAgc2VuZEF0dHJpYnV0ZURhdGE6IGZ1bmN0aW9uKGdsLCBhdHRyaWJ1dGVMb2NhdGlvbnMsIGFQb3NpdGlvbkRhdGEpIHtcbiAgICB2YXIgYXR0cmlidXRlTG9jYXRpb24gPSBhdHRyaWJ1dGVMb2NhdGlvbnMuYVBvc2l0aW9uO1xuICAgIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyaWJ1dGVMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYVBvc2l0aW9uRGF0YSwgZ2wuU1RBVElDX0RSQVcpO1xuICB9LFxuXG4gIF9zZXR1cEZyYW1lQnVmZmVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGdsID0gb3B0aW9ucy5jb250ZXh0LCB3aWR0aCwgaGVpZ2h0O1xuICAgIGlmIChvcHRpb25zLnBhc3NlcyA+IDEpIHtcbiAgICAgIHdpZHRoID0gb3B0aW9ucy5kZXN0aW5hdGlvbldpZHRoO1xuICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodDtcbiAgICAgIGlmIChvcHRpb25zLnNvdXJjZVdpZHRoICE9PSB3aWR0aCB8fCBvcHRpb25zLnNvdXJjZUhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUob3B0aW9ucy50YXJnZXRUZXh0dXJlKTtcbiAgICAgICAgb3B0aW9ucy50YXJnZXRUZXh0dXJlID0gb3B0aW9ucy5maWx0ZXJCYWNrZW5kLmNyZWF0ZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELFxuICAgICAgICBvcHRpb25zLnRhcmdldFRleHR1cmUsIDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGRyYXcgbGFzdCBmaWx0ZXIgb24gY2FudmFzIGFuZCBub3QgdG8gZnJhbWVidWZmZXIuXG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgZ2wuZmluaXNoKCk7XG4gICAgfVxuICB9LFxuXG4gIF9zd2FwVGV4dHVyZXM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnBhc3Nlcy0tO1xuICAgIG9wdGlvbnMucGFzcysrO1xuICAgIHZhciB0ZW1wID0gb3B0aW9ucy50YXJnZXRUZXh0dXJlO1xuICAgIG9wdGlvbnMudGFyZ2V0VGV4dHVyZSA9IG9wdGlvbnMuc291cmNlVGV4dHVyZTtcbiAgICBvcHRpb25zLnNvdXJjZVRleHR1cmUgPSB0ZW1wO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZW5lcmljIGlzTmV1dHJhbCBpbXBsZW1lbnRhdGlvbiBmb3Igb25lIHBhcmFtZXRlciBiYXNlZCBmaWx0ZXJzLlxuICAgKiBVc2VkIG9ubHkgaW4gaW1hZ2UgYXBwbHlGaWx0ZXJzIHRvIGRpc2NhcmQgZmlsdGVycyB0aGF0IHdpbGwgbm90IGhhdmUgYW4gZWZmZWN0XG4gICAqIG9uIHRoZSBpbWFnZVxuICAgKiBPdGhlciBmaWx0ZXJzIG1heSBuZWVkIHRoZWlyIG93biB2ZXJzaW9uICggQ29sb3JNYXRyaXgsIEh1ZVJvdGF0aW9uLCBnYW1tYSwgQ29tcG9zZWRGaWx0ZXIgKVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiovXG4gIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigvKiBvcHRpb25zICovKSB7XG4gICAgdmFyIG1haW4gPSB0aGlzLm1haW5QYXJhbWV0ZXIsXG4gICAgICAgIF9jbGFzcyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzW3RoaXMudHlwZV0ucHJvdG90eXBlO1xuICAgIGlmIChtYWluKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShfY2xhc3NbbWFpbl0pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBfY2xhc3NbbWFpbl0ubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgaWYgKHRoaXNbbWFpbl1baV0gIT09IF9jbGFzc1ttYWluXVtpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gX2NsYXNzW21haW5dID09PSB0aGlzW21haW5dO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGx5IHRoaXMgZmlsdGVyIHRvIHRoZSBpbnB1dCBpbWFnZSBkYXRhIHByb3ZpZGVkLlxuICAgKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gdXNlIFdlYkdMIG9yIENhbnZhczJEIGJhc2VkIG9uIHRoZSBvcHRpb25zLndlYmdsIGZsYWcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGV4ZWN1dGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy53ZWJnbCBXaGV0aGVyIHRvIHVzZSB3ZWJnbCB0byByZW5kZXIgdGhlIGZpbHRlci5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMuc291cmNlVGV4dHVyZSBUaGUgdGV4dHVyZSBzZXR1cCBhcyB0aGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy50YXJnZXRUZXh0dXJlIFRoZSB0ZXh0dXJlIHdoZXJlIGZpbHRlcmVkIG91dHB1dCBzaG91bGQgYmUgZHJhd24uXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICovXG4gIGFwcGx5VG86IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy53ZWJnbCkge1xuICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuYXBwbHlUbzJkKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAqL1xuICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkodGhpcy50eXBlKSkge1xuICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbdGhpcy50eXBlXSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbdGhpcy50eXBlXTtcbiAgfSxcblxuICAvKipcbiAgICogQXBwbHkgdGhpcyBmaWx0ZXIgdXNpbmcgd2ViZ2wuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGV4ZWN1dGVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy53ZWJnbCBXaGV0aGVyIHRvIHVzZSB3ZWJnbCB0byByZW5kZXIgdGhlIGZpbHRlci5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMub3JpZ2luYWxUZXh0dXJlIFRoZSB0ZXh0dXJlIG9mIHRoZSBvcmlnaW5hbCBpbnB1dCBpbWFnZS5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMuc291cmNlVGV4dHVyZSBUaGUgdGV4dHVyZSBzZXR1cCBhcyB0aGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy50YXJnZXRUZXh0dXJlIFRoZSB0ZXh0dXJlIHdoZXJlIGZpbHRlcmVkIG91dHB1dCBzaG91bGQgYmUgZHJhd24uXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICovXG4gIGFwcGx5VG9XZWJHTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBnbCA9IG9wdGlvbnMuY29udGV4dDtcbiAgICB2YXIgc2hhZGVyID0gdGhpcy5yZXRyaWV2ZVNoYWRlcihvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5wYXNzID09PSAwICYmIG9wdGlvbnMub3JpZ2luYWxUZXh0dXJlKSB7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBvcHRpb25zLm9yaWdpbmFsVGV4dHVyZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgb3B0aW9ucy5zb3VyY2VUZXh0dXJlKTtcbiAgICB9XG4gICAgZ2wudXNlUHJvZ3JhbShzaGFkZXIucHJvZ3JhbSk7XG4gICAgdGhpcy5zZW5kQXR0cmlidXRlRGF0YShnbCwgc2hhZGVyLmF0dHJpYnV0ZUxvY2F0aW9ucywgb3B0aW9ucy5hUG9zaXRpb24pO1xuXG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51bmlmb3JtTG9jYXRpb25zLnVTdGVwVywgMSAvIG9wdGlvbnMuc291cmNlV2lkdGgpO1xuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudW5pZm9ybUxvY2F0aW9ucy51U3RlcEgsIDEgLyBvcHRpb25zLnNvdXJjZUhlaWdodCk7XG5cbiAgICB0aGlzLnNlbmRVbmlmb3JtRGF0YShnbCwgc2hhZGVyLnVuaWZvcm1Mb2NhdGlvbnMpO1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIG9wdGlvbnMuZGVzdGluYXRpb25XaWR0aCwgb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCk7XG4gIH0sXG5cbiAgYmluZEFkZGl0aW9uYWxUZXh0dXJlOiBmdW5jdGlvbihnbCwgdGV4dHVyZSwgdGV4dHVyZVVuaXQpIHtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRleHR1cmVVbml0KTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAvLyByZXNldCBhY3RpdmUgdGV4dHVyZSB0byAwIGFzIHVzdWFsXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gIH0sXG5cbiAgdW5iaW5kQWRkaXRpb25hbFRleHR1cmU6IGZ1bmN0aW9uKGdsLCB0ZXh0dXJlVW5pdCkge1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGV4dHVyZVVuaXQpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICB9LFxuXG4gIGdldE1haW5QYXJhbWV0ZXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzW3RoaXMubWFpblBhcmFtZXRlcl07XG4gIH0sXG5cbiAgc2V0TWFpblBhcmFtZXRlcjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzW3RoaXMubWFpblBhcmFtZXRlcl0gPSB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogU2VuZCB1bmlmb3JtIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0gb24gdGhlIEdQVS5cbiAgICpcbiAgICogSW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHNoYWRlciB1bmlmb3JtIG5hbWVzIHRvIHRoZWlyIGxvY2F0aW9ucy5cbiAgICovXG4gIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oLyogZ2wsIHVuaWZvcm1Mb2NhdGlvbnMgKi8pIHtcbiAgICAvLyBJbnRlbnRpb25hbGx5IGxlZnQgYmxhbmsuICBPdmVycmlkZSBtZSBpbiBzdWJjbGFzc2VzLlxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBuZWVkZWQgYnkgYSAyZCBmaWx0ZXIsIHRoaXMgZnVuY3Rpb25zIGNhbiBjcmVhdGUgYW4gaGVscGVyIGNhbnZhcyB0byBiZSB1c2VkXG4gICAqIHJlbWVtYmVyIHRoYXQgb3B0aW9ucy50YXJnZXRDYW52YXMgaXMgYXZhaWxhYmxlIGZvciB1c2UgdGlsbCBlbmQgb2YgY2hhaW4uXG4gICAqL1xuICBjcmVhdGVIZWxwTGF5ZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuaGVscExheWVyKSB7XG4gICAgICB2YXIgaGVscExheWVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBoZWxwTGF5ZXIud2lkdGggPSBvcHRpb25zLnNvdXJjZVdpZHRoO1xuICAgICAgaGVscExheWVyLmhlaWdodCA9IG9wdGlvbnMuc291cmNlSGVpZ2h0O1xuICAgICAgb3B0aW9ucy5oZWxwTGF5ZXIgPSBoZWxwTGF5ZXI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgKi9cbiAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvYmplY3QgPSB7IHR5cGU6IHRoaXMudHlwZSB9LCBtYWluUCA9IHRoaXMubWFpblBhcmFtZXRlcjtcbiAgICBpZiAobWFpblApIHtcbiAgICAgIG9iamVjdFttYWluUF0gPSB0aGlzW21haW5QXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBKU09OXG4gICAqL1xuICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgIC8vIGRlbGVnYXRlLCBub3QgYWxpYXNcbiAgICByZXR1cm4gdGhpcy50b09iamVjdCgpO1xuICB9XG59KTtcblxuZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzW29iamVjdC50eXBlXShvYmplY3QpO1xuICBjYWxsYmFjayAmJiBjYWxsYmFjayhmaWx0ZXIpO1xuICByZXR1cm4gZmlsdGVyO1xufTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBDb2xvciBNYXRyaXggZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBzZWUge0BMaW5rIGh0dHA6Ly93d3cud2Vid2FzcC5jby51ay90dXRvcmlhbHMvMjE5L0NvbG9yX01hdHJpeF9GaWx0ZXIucGhwfVxuICAgKiBAc2VlIHtATGluayBodHRwOi8vcGhvYm9zbGFiLm9yZy9sb2cvMjAxMy8xMS9mYXN0LWltYWdlLWZpbHRlcnMtd2l0aC13ZWJnbH1cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+S29kYWNocm9tZSBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXgoe1xuICAgKiAgbWF0cml4OiBbXG4gICAgICAgMS4xMjg1NTgyMzk2NTkzNTI1LCAtMC4zOTY3MzgyMjgzNjAxMzQ4LCAtMC4wMzk5MjU1OTE3MjkyMTc5MywgMCwgNjMuNzI5NTg3NjIxOTY1MDIsXG4gICAgICAgLTAuMTY0MDQzMzk5NjIyNDQ2MTYsIDEuMDgzNTI1MTU2NjI5MTMwNCwgLTAuMDU0OTg4MDUxMTU2MzMxMzIsIDAsIDI0LjczMjQwNzg5NjcwNjIwMyxcbiAgICAgICAtMC4xNjc4NjAxMDcwNjE1NTc2MywgLTAuNTYwMzQxNjI3NzY5NTI0OCwgMS42MDE0ODUwNzYxOTY0OTQzLCAwLCAzNS42Mjk4MjgwNzQ2MDk0NixcbiAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuQ29sb3JNYXRyaXggPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXgucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdDb2xvck1hdHJpeCcsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gbWF0NCB1Q29sb3JNYXRyaXg7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWM0IHVDb25zdGFudHM7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yICo9IHVDb2xvck1hdHJpeDtcXG4nICtcbiAgICAgICAgJ2NvbG9yICs9IHVDb25zdGFudHM7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIENvbG9ybWF0cml4IGZvciBwaXhlbHMuXG4gICAgICogYXJyYXkgb2YgMjAgZmxvYXRzLiBOdW1iZXJzIGluIHBvc2l0aW9ucyA0LCA5LCAxNCwgMTkgbG9vc2UgbWVhbmluZ1xuICAgICAqIG91dHNpZGUgdGhlIC0xLCAxIHJhbmdlLlxuICAgICAqIDAuMDAzOTIxNTY4NiBpcyB0aGUgcGFydCBvZiAxIHRoYXQgZ2V0IHRyYW5zbGF0ZWQgdG8gMSBpbiAyZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBhcnJheSBvZiAyMCBudW1iZXJzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWF0cml4OiBbXG4gICAgICAxLCAwLCAwLCAwLCAwLFxuICAgICAgMCwgMSwgMCwgMCwgMCxcbiAgICAgIDAsIDAsIDEsIDAsIDAsXG4gICAgICAwLCAwLCAwLCAxLCAwXG4gICAgXSxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdtYXRyaXgnLFxuXG4gICAgLyoqXG4gICAgICogTG9jayB0aGUgY29sb3JtYXRyaXggb24gdGhlIGNvbG9yIHBhcnQsIHNraXBwaW5nIGFscGhhLCBtYWlubHkgZm9yIG5vbiB3ZWJnbCBzY2VuYXJpb1xuICAgICAqIHRvIHNhdmUgc29tZSBjYWxjdWxhdGlvblxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgY29sb3JzT25seTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICAvLyBjcmVhdGUgYSBuZXcgYXJyYXkgaW5zdGVhZCBtdXRhdGluZyB0aGUgcHJvdG90eXBlIHdpdGggcHVzaFxuICAgICAgdGhpcy5tYXRyaXggPSB0aGlzLm1hdHJpeC5zbGljZSgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIENvbG9yTWF0cml4IG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgaUxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIG0gPSB0aGlzLm1hdHJpeCxcbiAgICAgICAgICByLCBnLCBiLCBhLCBpLCBjb2xvcnNPbmx5ID0gdGhpcy5jb2xvcnNPbmx5O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgaWYgKGNvbG9yc09ubHkpIHtcbiAgICAgICAgICBkYXRhW2ldID0gciAqIG1bMF0gKyBnICogbVsxXSArIGIgKiBtWzJdICsgbVs0XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9IHIgKiBtWzVdICsgZyAqIG1bNl0gKyBiICogbVs3XSArIG1bOV0gKiAyNTU7XG4gICAgICAgICAgZGF0YVtpICsgMl0gPSByICogbVsxMF0gKyBnICogbVsxMV0gKyBiICogbVsxMl0gKyBtWzE0XSAqIDI1NTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhID0gZGF0YVtpICsgM107XG4gICAgICAgICAgZGF0YVtpXSA9IHIgKiBtWzBdICsgZyAqIG1bMV0gKyBiICogbVsyXSArIGEgKiBtWzNdICsgbVs0XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9IHIgKiBtWzVdICsgZyAqIG1bNl0gKyBiICogbVs3XSArIGEgKiBtWzhdICsgbVs5XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAyXSA9IHIgKiBtWzEwXSArIGcgKiBtWzExXSArIGIgKiBtWzEyXSArIGEgKiBtWzEzXSArIG1bMTRdICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDNdID0gciAqIG1bMTVdICsgZyAqIG1bMTZdICsgYiAqIG1bMTddICsgYSAqIG1bMThdICsgbVsxOV0gKiAyNTU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVDb2xvck1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29sb3JNYXRyaXgnKSxcbiAgICAgICAgdUNvbnN0YW50czogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29uc3RhbnRzJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgbSA9IHRoaXMubWF0cml4LFxuICAgICAgICAgIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sXG4gICAgICAgICAgICBtWzVdLCBtWzZdLCBtWzddLCBtWzhdLFxuICAgICAgICAgICAgbVsxMF0sIG1bMTFdLCBtWzEyXSwgbVsxM10sXG4gICAgICAgICAgICBtWzE1XSwgbVsxNl0sIG1bMTddLCBtWzE4XVxuICAgICAgICAgIF0sXG4gICAgICAgICAgY29uc3RhbnRzID0gW21bNF0sIG1bOV0sIG1bMTRdLCBtWzE5XV07XG4gICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUNvbG9yTWF0cml4LCBmYWxzZSwgbWF0cml4KTtcbiAgICAgIGdsLnVuaWZvcm00ZnYodW5pZm9ybUxvY2F0aW9ucy51Q29uc3RhbnRzLCBjb25zdGFudHMpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gZnVuY3Rpb24gdG8gaW52b2tlIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeH0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXhcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4LmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQnJpZ2h0bmVzcyBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3NcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcyh7XG4gICAqICAgYnJpZ2h0bmVzczogMC4wNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkJyaWdodG5lc3MgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0JyaWdodG5lc3MnLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgYnJpZ2h0bmVzcyBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1QnJpZ2h0bmVzcztcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdjb2xvci5yZ2IgKz0gdUJyaWdodG5lc3M7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEJyaWdodG5lc3MgdmFsdWUsIGZyb20gLTEgdG8gMS5cbiAgICAgKiB0cmFuc2xhdGVkIHRvIC0yNTUgdG8gMjU1IGZvciAyZFxuICAgICAqIDAuMDAzOTIxNTY4NiBpcyB0aGUgcGFydCBvZiAxIHRoYXQgZ2V0IHRyYW5zbGF0ZWQgdG8gMSBpbiAyZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBicmlnaHRuZXNzOiAwLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgdGhlIHByb3BlcnR5IHRoYXQgaXMgdGhlIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWFpblBhcmFtZXRlcjogJ2JyaWdodG5lc3MnLFxuXG4gICAgLyoqXG4gICAgKiBBcHBseSB0aGUgQnJpZ2h0bmVzcyBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAqXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuYnJpZ2h0bmVzcyA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBicmlnaHRuZXNzID0gTWF0aC5yb3VuZCh0aGlzLmJyaWdodG5lc3MgKiAyNTUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSBkYXRhW2ldICsgYnJpZ2h0bmVzcztcbiAgICAgICAgZGF0YVtpICsgMV0gPSBkYXRhW2kgKyAxXSArIGJyaWdodG5lc3M7XG4gICAgICAgIGRhdGFbaSArIDJdID0gZGF0YVtpICsgMl0gKyBicmlnaHRuZXNzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUJyaWdodG5lc3M6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUJyaWdodG5lc3MnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVCcmlnaHRuZXNzLCB0aGlzLmJyaWdodG5lc3MpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc30gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc1xuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzcy5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEFkYXB0ZWQgZnJvbSA8YSBocmVmPVwiaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvY2FudmFzL2ltYWdlZmlsdGVycy9cIj5odG1sNXJvY2tzIGFydGljbGU8L2E+XG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+U2hhcnBlbiBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBtYXRyaXg6IFsgMCwgLTEsICAwLFxuICAgKiAgICAgICAgICAgIC0xLCAgNSwgLTEsXG4gICAqICAgICAgICAgICAgIDAsIC0xLCAgMCBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5CbHVyIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG1hdHJpeDogWyAxLzksIDEvOSwgMS85LFxuICAgKiAgICAgICAgICAgICAxLzksIDEvOSwgMS85LFxuICAgKiAgICAgICAgICAgICAxLzksIDEvOSwgMS85IF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtYm9zcyBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBtYXRyaXg6IFsgMSwgICAxLCAgMSxcbiAgICogICAgICAgICAgICAgMSwgMC43LCAtMSxcbiAgICogICAgICAgICAgICAtMSwgIC0xLCAtMSBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWJvc3MgZmlsdGVyIHdpdGggb3BhcXVlbmVzczwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG9wYXF1ZTogdHJ1ZSxcbiAgICogICBtYXRyaXg6IFsgMSwgICAxLCAgMSxcbiAgICogICAgICAgICAgICAgMSwgMC43LCAtMSxcbiAgICogICAgICAgICAgICAtMSwgIC0xLCAtMSBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5Db252b2x1dGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQ29udm9sdXRlJyxcblxuICAgIC8qXG4gICAgICogT3BhcXVlIHZhbHVlICh0cnVlL2ZhbHNlKVxuICAgICAqL1xuICAgIG9wYXF1ZTogZmFsc2UsXG5cbiAgICAvKlxuICAgICAqIG1hdHJpeCBmb3IgdGhlIGZpbHRlciwgbWF4IDl4OVxuICAgICAqL1xuICAgIG1hdHJpeDogWzAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDBdLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgYnJpZ2h0bmVzcyBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIENvbnZvbHV0ZV8zXzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgMy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCAzLjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMSksIHVTdGVwSCAqIChoIC0gMSkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpICogdU1hdHJpeFtpbnQoaCAqIDMuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV8zXzA6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgMy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCAzLjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMS4wKSwgdVN0ZXBIICogKGggLSAxLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDMuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV81XzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFsyNV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDUuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNS4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDIuMCksIHVTdGVwSCAqIChoIC0gMi4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogNS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzVfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzI1XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA1LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMi4wKSwgdVN0ZXBIICogKGggLSAyLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDUuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV83XzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs0OV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDcuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNy4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDMuMCksIHVTdGVwSCAqIChoIC0gMy4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogNy4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzdfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzQ5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA3LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMy4wKSwgdVN0ZXBIICogKGggLSAzLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDcuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV85XzE6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs4MV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDkuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgOS4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDQuMCksIHVTdGVwSCAqIChoIC0gNC4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogOS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzlfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzgxXTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAxKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgOS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA5LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gNC4wKSwgdVN0ZXBIICogKGggLSA0LjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yLnJnYiArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykucmdiICogdU1hdHJpeFtpbnQoaCAqIDkuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZmxvYXQgYWxwaGEgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCkuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gYWxwaGE7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9wYXF1ZT1mYWxzZV0gT3BhcXVlIHZhbHVlICh0cnVlL2ZhbHNlKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm1hdHJpeF0gRmlsdGVyIG1hdHJpeFxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBzaXplID0gTWF0aC5zcXJ0KHRoaXMubWF0cml4Lmxlbmd0aCk7XG4gICAgICB2YXIgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyBzaXplICsgJ18nICsgKHRoaXMub3BhcXVlID8gMSA6IDApO1xuICAgICAgdmFyIHNoYWRlclNvdXJjZSA9IHRoaXMuZnJhZ21lbnRTb3VyY2VbY2FjaGVLZXldO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgc2hhZGVyU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCcmlnaHRuZXNzIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICB3ZWlnaHRzID0gdGhpcy5tYXRyaXgsXG4gICAgICAgICAgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSksXG4gICAgICAgICAgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUgLyAyKSxcbiAgICAgICAgICBzdyA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBzaCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgb3V0cHV0ID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKHN3LCBzaCksXG4gICAgICAgICAgZHN0ID0gb3V0cHV0LmRhdGEsXG4gICAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgZGVzdGluYXRpb24gaW1hZ2UgcGl4ZWxzXG4gICAgICAgICAgYWxwaGFGYWMgPSB0aGlzLm9wYXF1ZSA/IDEgOiAwLFxuICAgICAgICAgIHIsIGcsIGIsIGEsIGRzdE9mZixcbiAgICAgICAgICBzY3gsIHNjeSwgc3JjT2ZmLCB3dCxcbiAgICAgICAgICB4LCB5LCBjeCwgY3k7XG5cbiAgICAgIGZvciAoeSA9IDA7IHkgPCBzaDsgeSsrKSB7XG4gICAgICAgIGZvciAoeCA9IDA7IHggPCBzdzsgeCsrKSB7XG4gICAgICAgICAgZHN0T2ZmID0gKHkgKiBzdyArIHgpICogNDtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHdlaWdoZWQgc3VtIG9mIHRoZSBzb3VyY2UgaW1hZ2UgcGl4ZWxzIHRoYXRcbiAgICAgICAgICAvLyBmYWxsIHVuZGVyIHRoZSBjb252b2x1dGlvbiBtYXRyaXhcbiAgICAgICAgICByID0gMDsgZyA9IDA7IGIgPSAwOyBhID0gMDtcblxuICAgICAgICAgIGZvciAoY3kgPSAwOyBjeSA8IHNpZGU7IGN5KyspIHtcbiAgICAgICAgICAgIGZvciAoY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcbiAgICAgICAgICAgICAgc2N5ID0geSArIGN5IC0gaGFsZlNpZGU7XG4gICAgICAgICAgICAgIHNjeCA9IHggKyBjeCAtIGhhbGZTaWRlO1xuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgICAgaWYgKHNjeSA8IDAgfHwgc2N5ID49IHNoIHx8IHNjeCA8IDAgfHwgc2N4ID49IHN3KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzcmNPZmYgPSAoc2N5ICogc3cgKyBzY3gpICogNDtcbiAgICAgICAgICAgICAgd3QgPSB3ZWlnaHRzW2N5ICogc2lkZSArIGN4XTtcblxuICAgICAgICAgICAgICByICs9IGRhdGFbc3JjT2ZmXSAqIHd0O1xuICAgICAgICAgICAgICBnICs9IGRhdGFbc3JjT2ZmICsgMV0gKiB3dDtcbiAgICAgICAgICAgICAgYiArPSBkYXRhW3NyY09mZiArIDJdICogd3Q7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgICAgaWYgKCFhbHBoYUZhYykge1xuICAgICAgICAgICAgICAgIGEgKz0gZGF0YVtzcmNPZmYgKyAzXSAqIHd0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRzdFtkc3RPZmZdID0gcjtcbiAgICAgICAgICBkc3RbZHN0T2ZmICsgMV0gPSBnO1xuICAgICAgICAgIGRzdFtkc3RPZmYgKyAyXSA9IGI7XG4gICAgICAgICAgaWYgKCFhbHBoYUZhYykge1xuICAgICAgICAgICAgZHN0W2RzdE9mZiArIDNdID0gYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkc3RbZHN0T2ZmICsgM10gPSBkYXRhW2RzdE9mZiArIDNdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3B0aW9ucy5pbWFnZURhdGEgPSBvdXRwdXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1TWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VNYXRyaXgnKSxcbiAgICAgICAgdU9wYXF1ZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1T3BhcXVlJyksXG4gICAgICAgIHVIYWxmU2l6ZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1SGFsZlNpemUnKSxcbiAgICAgICAgdVNpemU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNpemUnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZnYodW5pZm9ybUxvY2F0aW9ucy51TWF0cml4LCB0aGlzLm1hdHJpeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIG9wYXF1ZTogdGhpcy5vcGFxdWUsXG4gICAgICAgIG1hdHJpeDogdGhpcy5tYXRyaXhcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBHcmF5c2NhbGUgaW1hZ2UgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZSgpO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuR3JheXNjYWxlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0dyYXlzY2FsZScsXG5cbiAgICBmcmFnbWVudFNvdXJjZToge1xuICAgICAgYXZlcmFnZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAnZmxvYXQgYXZlcmFnZSA9IChjb2xvci5yICsgY29sb3IuYiArIGNvbG9yLmcpIC8gMy4wO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KGF2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGNvbG9yLmEpO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBsaWdodG5lc3M6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gaW50IHVNb2RlO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2wgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGF2ZXJhZ2UgPSAobWF4KG1heChjb2wuciwgY29sLmcpLGNvbC5iKSArIG1pbihtaW4oY29sLnIsIGNvbC5nKSxjb2wuYikpIC8gMi4wO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KGF2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGNvbC5hKTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgbHVtaW5vc2l0eTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBpbnQgdU1vZGU7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbCA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAnZmxvYXQgYXZlcmFnZSA9IDAuMjEgKiBjb2wuciArIDAuNzIgKiBjb2wuZyArIDAuMDcgKiBjb2wuYjtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNChhdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjb2wuYSk7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBHcmF5c2NhbGUgbW9kZSwgYmV0d2VlbiAnYXZlcmFnZScsICdsaWdodG5lc3MnLCAnbHVtaW5vc2l0eSdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbW9kZTogJ2F2ZXJhZ2UnLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ21vZGUnLFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEdyYXlzY2FsZSBvcGVyYXRpb24gdG8gYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4QXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLFxuICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoLCB2YWx1ZSxcbiAgICAgICAgICBtb2RlID0gdGhpcy5tb2RlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGlmIChtb2RlID09PSAnYXZlcmFnZScpIHtcbiAgICAgICAgICB2YWx1ZSA9IChkYXRhW2ldICsgZGF0YVtpICsgMV0gKyBkYXRhW2kgKyAyXSkgLyAzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdsaWdodG5lc3MnKSB7XG4gICAgICAgICAgdmFsdWUgPSAoTWF0aC5taW4oZGF0YVtpXSwgZGF0YVtpICsgMV0sIGRhdGFbaSArIDJdKSArXG4gICAgICAgICAgICBNYXRoLm1heChkYXRhW2ldLCBkYXRhW2kgKyAxXSwgZGF0YVtpICsgMl0pKSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2x1bWlub3NpdHknKSB7XG4gICAgICAgICAgdmFsdWUgPSAwLjIxICogZGF0YVtpXSArIDAuNzIgKiBkYXRhW2kgKyAxXSArIDAuMDcgKiBkYXRhW2kgKyAyXTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2ldID0gdmFsdWU7XG4gICAgICAgIGRhdGFbaSArIDFdID0gdmFsdWU7XG4gICAgICAgIGRhdGFbaSArIDJdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyB0aGlzLm1vZGU7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICB2YXIgc2hhZGVyU291cmNlID0gdGhpcy5mcmFnbWVudFNvdXJjZVt0aGlzLm1vZGVdO1xuICAgICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0LCBzaGFkZXJTb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVNb2RlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VNb2RlJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICAvLyBkZWZhdWx0IGF2ZXJhZ2UgbW9kZS5cbiAgICAgIHZhciBtb2RlID0gMTtcbiAgICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtTG9jYXRpb25zLnVNb2RlLCBtb2RlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR3JheXNjYWxlIGZpbHRlciBpc05ldXRyYWxTdGF0ZSBpbXBsZW1lbnRhdGlvblxuICAgICAqIFRoZSBmaWx0ZXIgaXMgbmV2ZXIgbmV1dHJhbFxuICAgICAqIG9uIHRoZSBpbWFnZVxuICAgICAqKi9cbiAgICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBJbnZlcnQgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydCgpO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKi9cbiAgZmlsdGVycy5JbnZlcnQgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnSW52ZXJ0JyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gaW50IHVJbnZlcnQ7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnaWYgKHVJbnZlcnQgPT0gMSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCAtIGNvbG9yLnIsMS4wIC1jb2xvci5nLDEuMCAtY29sb3IuYixjb2xvci5hKTtcXG4nICtcbiAgICAgICAgJ30gZWxzZSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIGludmVydC4gaWYgZmFsc2UsIGRvZXMgbm90aGluZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW52ZXJ0XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbnZlcnQ6IHRydWUsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnaW52ZXJ0JyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBJbnZlcnQgb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSxcbiAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2ldID0gMjU1IC0gZGF0YVtpXTtcbiAgICAgICAgZGF0YVtpICsgMV0gPSAyNTUgLSBkYXRhW2kgKyAxXTtcbiAgICAgICAgZGF0YVtpICsgMl0gPSAyNTUgLSBkYXRhW2kgKyAyXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52ZXJ0IGZpbHRlciBpc05ldXRyYWxTdGF0ZSBpbXBsZW1lbnRhdGlvblxuICAgICAqIFVzZWQgb25seSBpbiBpbWFnZSBhcHBseUZpbHRlcnMgdG8gZGlzY2FyZCBmaWx0ZXJzIHRoYXQgd2lsbCBub3QgaGF2ZSBhbiBlZmZlY3RcbiAgICAgKiBvbiB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqKi9cbiAgICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaW52ZXJ0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUludmVydDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1SW52ZXJ0JyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWkodW5pZm9ybUxvY2F0aW9ucy51SW52ZXJ0LCB0aGlzLmludmVydCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnR9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0LmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBOb2lzZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZSh7XG4gICAqICAgbm9pc2U6IDcwMFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG4gIGZpbHRlcnMuTm9pc2UgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2UucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdOb2lzZScsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBub2lzZSBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1Tm9pc2U7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U2VlZDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ2Zsb2F0IHJhbmQodmVjMiBjbywgZmxvYXQgc2VlZCwgZmxvYXQgdlNjYWxlKSB7XFxuJyArXG4gICAgICAgICdyZXR1cm4gZnJhY3Qoc2luKGRvdChjby54eSAqIHZTY2FsZSAsdmVjMigxMi45ODk4ICwgNzguMjMzKSkpICogNDM3NTguNTQ1MyAqIChzZWVkICsgMC4wMSkgLyAyLjApO1xcbicgK1xuICAgICAgJ31cXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnY29sb3IucmdiICs9ICgwLjUgLSByYW5kKHZUZXhDb29yZCwgdVNlZWQsIDAuMSAvIHVTdGVwSCkpICogdU5vaXNlO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSB0aGUgcHJvcGVydHkgdGhhdCBpcyB0aGUgZmlsdGVyIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYWluUGFyYW1ldGVyOiAnbm9pc2UnLFxuXG4gICAgLyoqXG4gICAgICogTm9pc2UgdmFsdWUsIGZyb21cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbm9pc2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG5vaXNlOiAwLFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJyaWdodG5lc3Mgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5ub2lzZSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBub2lzZSA9IHRoaXMubm9pc2UsIHJhbmQ7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDQpIHtcblxuICAgICAgICByYW5kID0gKDAuNSAtIE1hdGgucmFuZG9tKCkpICogbm9pc2U7XG5cbiAgICAgICAgZGF0YVtpXSArPSByYW5kO1xuICAgICAgICBkYXRhW2kgKyAxXSArPSByYW5kO1xuICAgICAgICBkYXRhW2kgKyAyXSArPSByYW5kO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdU5vaXNlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VOb2lzZScpLFxuICAgICAgICB1U2VlZDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2VlZCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudU5vaXNlLCB0aGlzLm5vaXNlIC8gMjU1KTtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVTZWVkLCBNYXRoLnJhbmRvbSgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgbm9pc2U6IHRoaXMubm9pc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBQaXhlbGF0ZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZSh7XG4gICAqICAgYmxvY2tzaXplOiA4XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuUGl4ZWxhdGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdQaXhlbGF0ZScsXG5cbiAgICBibG9ja3NpemU6IDQsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnYmxvY2tzaXplJyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIFBpeGVsYXRlIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVCbG9ja3NpemU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICdmbG9hdCBibG9ja1cgPSB1QmxvY2tzaXplICogdVN0ZXBXO1xcbicgK1xuICAgICAgICAnZmxvYXQgYmxvY2tIID0gdUJsb2Nrc2l6ZSAqIHVTdGVwVztcXG4nICtcbiAgICAgICAgJ2ludCBwb3NYID0gaW50KHZUZXhDb29yZC54IC8gYmxvY2tXKTtcXG4nICtcbiAgICAgICAgJ2ludCBwb3NZID0gaW50KHZUZXhDb29yZC55IC8gYmxvY2tIKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGZwb3NYID0gZmxvYXQocG9zWCk7XFxuJyArXG4gICAgICAgICdmbG9hdCBmcG9zWSA9IGZsb2F0KHBvc1kpO1xcbicgK1xuICAgICAgICAndmVjMiBzcXVhcmVDb29yZHMgPSB2ZWMyKGZwb3NYICogYmxvY2tXLCBmcG9zWSAqIGJsb2NrSCk7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCBzcXVhcmVDb29yZHMpO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgUGl4ZWxhdGUgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGlMZW4gPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgIGpMZW4gPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICAgICAgaW5kZXgsIGksIGosIHIsIGcsIGIsIGEsXG4gICAgICAgICAgX2ksIF9qLCBfaUxlbiwgX2pMZW47XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpTGVuOyBpICs9IHRoaXMuYmxvY2tzaXplKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IHRoaXMuYmxvY2tzaXplKSB7XG5cbiAgICAgICAgICBpbmRleCA9IChpICogNCkgKiBqTGVuICsgKGogKiA0KTtcblxuICAgICAgICAgIHIgPSBkYXRhW2luZGV4XTtcbiAgICAgICAgICBnID0gZGF0YVtpbmRleCArIDFdO1xuICAgICAgICAgIGIgPSBkYXRhW2luZGV4ICsgMl07XG4gICAgICAgICAgYSA9IGRhdGFbaW5kZXggKyAzXTtcblxuICAgICAgICAgIF9pTGVuID0gTWF0aC5taW4oaSArIHRoaXMuYmxvY2tzaXplLCBpTGVuKTtcbiAgICAgICAgICBfakxlbiA9IE1hdGgubWluKGogKyB0aGlzLmJsb2Nrc2l6ZSwgakxlbik7XG4gICAgICAgICAgZm9yIChfaSA9IGk7IF9pIDwgX2lMZW47IF9pKyspIHtcbiAgICAgICAgICAgIGZvciAoX2ogPSBqOyBfaiA8IF9qTGVuOyBfaisrKSB7XG4gICAgICAgICAgICAgIGluZGV4ID0gKF9pICogNCkgKiBqTGVuICsgKF9qICogNCk7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gcjtcbiAgICAgICAgICAgICAgZGF0YVtpbmRleCArIDFdID0gZztcbiAgICAgICAgICAgICAgZGF0YVtpbmRleCArIDJdID0gYjtcbiAgICAgICAgICAgICAgZGF0YVtpbmRleCArIDNdID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGUgd2hlbiB0aGUgZmlsdGVyIGlzIG5vdCBnb25uYSBhcHBseSBjaGFuZ2VzIHRvIHRoZSBpbWFnZVxuICAgICAqKi9cbiAgICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ibG9ja3NpemUgPT09IDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1QmxvY2tzaXplOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VCbG9ja3NpemUnKSxcbiAgICAgICAgdVN0ZXBXOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTdGVwVycpLFxuICAgICAgICB1U3RlcEg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVN0ZXBIJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51QmxvY2tzaXplLCB0aGlzLmJsb2Nrc2l6ZSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogUmVtb3ZlIHdoaXRlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3JcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3IjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yKHtcbiAgICogICB0aHJlc2hvbGQ6IDAuMixcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuICBmaWx0ZXJzLlJlbW92ZUNvbG9yID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnUmVtb3ZlQ29sb3InLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3IgdG8gcmVtb3ZlLCBpbiBhbnkgZm9ybWF0IHVuZGVyc3Rvb2QgYnkgZmFicmljLkNvbG9yLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjb2xvcjogJyNGRkZGRkYnLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgYnJpZ2h0bmVzcyBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWM0IHVMb3c7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWM0IHVIaWdoO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnaWYoYWxsKGdyZWF0ZXJUaGFuKGdsX0ZyYWdDb2xvci5yZ2IsdUxvdy5yZ2IpKSAmJiBhbGwoZ3JlYXRlclRoYW4odUhpZ2gucmdiLGdsX0ZyYWdDb2xvci5yZ2IpKSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYSA9IDAuMDtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIGRpc3RhbmNlIHRvIGFjdHVhbCBjb2xvciwgYXMgdmFsdWUgdXAgb3IgZG93biBmcm9tIGVhY2ggcixnLGJcbiAgICAgKiBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiovXG4gICAgZGlzdGFuY2U6IDAuMDIsXG5cbiAgICAvKipcbiAgICAgKiBGb3IgY29sb3IgdG8gcmVtb3ZlIGluc2lkZSBkaXN0YW5jZSwgdXNlIGFscGhhIGNoYW5uZWwgZm9yIGEgc21vb3RoZXIgZGVsZXRpb25cbiAgICAgKiBOT1QgSU1QTEVNRU5URUQgWUVUXG4gICAgICoqL1xuICAgIHVzZUFscGhhOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZVdoaXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29sb3I9I1JSR0dCQl0gVGhyZXNob2xkIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRpc3RhbmNlPTEwXSBEaXN0YW5jZSB2YWx1ZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLFxuICAgICAgICAgIGRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZSAqIDI1NSxcbiAgICAgICAgICByLCBnLCBiLFxuICAgICAgICAgIHNvdXJjZSA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcikuZ2V0U291cmNlKCksXG4gICAgICAgICAgbG93QyA9IFtcbiAgICAgICAgICAgIHNvdXJjZVswXSAtIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzFdIC0gZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMl0gLSBkaXN0YW5jZSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIGhpZ2hDID0gW1xuICAgICAgICAgICAgc291cmNlWzBdICsgZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMV0gKyBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsyXSArIGRpc3RhbmNlLFxuICAgICAgICAgIF07XG5cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgciA9IGRhdGFbaV07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgICAgIGlmIChyID4gbG93Q1swXSAmJlxuICAgICAgICAgICAgZyA+IGxvd0NbMV0gJiZcbiAgICAgICAgICAgIGIgPiBsb3dDWzJdICYmXG4gICAgICAgICAgICByIDwgaGlnaENbMF0gJiZcbiAgICAgICAgICAgIGcgPCBoaWdoQ1sxXSAmJlxuICAgICAgICAgICAgYiA8IGhpZ2hDWzJdKSB7XG4gICAgICAgICAgZGF0YVtpICsgM10gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1TG93OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VMb3cnKSxcbiAgICAgICAgdUhpZ2g6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUhpZ2gnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGRpc3RhbmNlID0gcGFyc2VGbG9hdCh0aGlzLmRpc3RhbmNlKSxcbiAgICAgICAgICBsb3dDID0gW1xuICAgICAgICAgICAgMCArIHNvdXJjZVswXSAvIDI1NSAtIGRpc3RhbmNlLFxuICAgICAgICAgICAgMCArIHNvdXJjZVsxXSAvIDI1NSAtIGRpc3RhbmNlLFxuICAgICAgICAgICAgMCArIHNvdXJjZVsyXSAvIDI1NSAtIGRpc3RhbmNlLFxuICAgICAgICAgICAgMVxuICAgICAgICAgIF0sXG4gICAgICAgICAgaGlnaEMgPSBbXG4gICAgICAgICAgICBzb3VyY2VbMF0gLyAyNTUgKyBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsxXSAvIDI1NSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzJdIC8gMjU1ICsgZGlzdGFuY2UsXG4gICAgICAgICAgICAxXG4gICAgICAgICAgXTtcbiAgICAgIGdsLnVuaWZvcm00ZnYodW5pZm9ybUxvY2F0aW9ucy51TG93LCBsb3dDKTtcbiAgICAgIGdsLnVuaWZvcm00ZnYodW5pZm9ybUxvY2F0aW9ucy51SGlnaCwgaGlnaEMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgZGlzdGFuY2U6IHRoaXMuZGlzdGFuY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvcn0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlV2hpdGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIHZhciBtYXRyaWNlcyA9IHtcbiAgICBCcm93bmllOiBbXG4gICAgICAwLjU5OTcwLDAuMzQ1NTMsLTAuMjcwODIsMCwwLjE4NixcbiAgICAgIC0wLjAzNzcwLDAuODYwOTUsMC4xNTA1OSwwLC0wLjE0NDksXG4gICAgICAwLjI0MTEzLC0wLjA3NDQxLDAuNDQ5NzIsMCwtMC4wMjk2NSxcbiAgICAgIDAsMCwwLDEsMFxuICAgIF0sXG4gICAgVmludGFnZTogW1xuICAgICAgMC42Mjc5MywwLjMyMDIxLC0wLjAzOTY1LDAsMC4wMzc4NCxcbiAgICAgIDAuMDI1NzgsMC42NDQxMSwwLjAzMjU5LDAsMC4wMjkyNixcbiAgICAgIDAuMDQ2NjAsLTAuMDg1MTIsMC41MjQxNiwwLDAuMDIwMjMsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIEtvZGFjaHJvbWU6IFtcbiAgICAgIDEuMTI4NTUsLTAuMzk2NzMsLTAuMDM5OTIsMCwwLjI0OTkxLFxuICAgICAgLTAuMTY0MDQsMS4wODM1MiwtMC4wNTQ5OCwwLDAuMDk2OTgsXG4gICAgICAtMC4xNjc4NiwtMC41NjAzNCwxLjYwMTQ4LDAsMC4xMzk3MixcbiAgICAgIDAsMCwwLDEsMFxuICAgIF0sXG4gICAgVGVjaG5pY29sb3I6IFtcbiAgICAgIDEuOTEyNTIsLTAuODU0NTMsLTAuMDkxNTUsMCwwLjA0NjI0LFxuICAgICAgLTAuMzA4NzgsMS43NjU4OSwtMC4xMDYwMSwwLC0wLjI3NTg5LFxuICAgICAgLTAuMjMxMTAsLTAuNzUwMTgsMS44NDc1OSwwLDAuMTIxMzcsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIFBvbGFyb2lkOiBbXG4gICAgICAxLjQzOCwtMC4wNjIsLTAuMDYyLDAsMCxcbiAgICAgIC0wLjEyMiwxLjM3OCwtMC4xMjIsMCwwLFxuICAgICAgLTAuMDE2LC0wLjAxNiwxLjQ4MywwLDAsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIFNlcGlhOiBbXG4gICAgICAwLjM5MywgMC43NjksIDAuMTg5LCAwLCAwLFxuICAgICAgMC4zNDksIDAuNjg2LCAwLjE2OCwgMCwgMCxcbiAgICAgIDAuMjcyLCAwLjUzNCwgMC4xMzEsIDAsIDAsXG4gICAgICAwLCAwLCAwLCAxLCAwXG4gICAgXSxcbiAgICBCbGFja1doaXRlOiBbXG4gICAgICAxLjUsIDEuNSwgMS41LCAwLCAtMSxcbiAgICAgIDEuNSwgMS41LCAxLjUsIDAsIC0xLFxuICAgICAgMS41LCAxLjUsIDEuNSwgMCwgLTEsXG4gICAgICAwLCAwLCAwLCAxLCAwLFxuICAgIF1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gbWF0cmljZXMpIHtcbiAgICBmaWx0ZXJzW2tleV0gPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkNvbG9yTWF0cml4LCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNlcGlhLnByb3RvdHlwZSAqLyB7XG5cbiAgICAgIC8qKlxuICAgICAgICogRmlsdGVyIHR5cGVcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICAgKiBAZGVmYXVsdFxuICAgICAgICovXG4gICAgICB0eXBlOiBrZXksXG5cbiAgICAgIC8qKlxuICAgICAgICogQ29sb3JtYXRyaXggZm9yIHRoZSBlZmZlY3RcbiAgICAgICAqIGFycmF5IG9mIDIwIGZsb2F0cy4gTnVtYmVycyBpbiBwb3NpdGlvbnMgNCwgOSwgMTQsIDE5IGxvb3NlIG1lYW5pbmdcbiAgICAgICAqIG91dHNpZGUgdGhlIC0xLCAxIHJhbmdlLlxuICAgICAgICogQHBhcmFtIHtBcnJheX0gbWF0cml4IGFycmF5IG9mIDIwIG51bWJlcnMuXG4gICAgICAgKiBAZGVmYXVsdFxuICAgICAgICovXG4gICAgICBtYXRyaXg6IG1hdHJpY2VzW2tleV0sXG5cbiAgICAgIC8qKlxuICAgICAgICogTG9jayB0aGUgbWF0cml4IGV4cG9ydCBmb3IgdGhpcyBraW5kIG9mIHN0YXRpYywgcGFyYW1ldGVyIGxlc3MgZmlsdGVycy5cbiAgICAgICAqL1xuICAgICAgbWFpblBhcmFtZXRlcjogZmFsc2UsXG4gICAgICAvKipcbiAgICAgICAqIExvY2sgdGhlIGNvbG9ybWF0cml4IG9uIHRoZSBjb2xvciBwYXJ0LCBza2lwcGluZyBhbHBoYVxuICAgICAgICovXG4gICAgICBjb2xvcnNPbmx5OiB0cnVlLFxuXG4gICAgfSk7XG4gICAgZmFicmljLkltYWdlLmZpbHRlcnNba2V5XS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuICB9XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBDb2xvciBCbGVuZCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXIuQmxlbmRDb2xvclxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kQ29sb3Ioe1xuICAgKiAgY29sb3I6ICcjMDAwJyxcbiAgICogIG1vZGU6ICdtdWx0aXBseSdcbiAgICogfSk7XG4gICAqXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZSh7XG4gICAqICBpbWFnZTogZmFicmljSW1hZ2VPYmplY3QsXG4gICAqICBtb2RlOiAnbXVsdGlwbHknLFxuICAgKiAgYWxwaGE6IDAuNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG5cbiAgZmlsdGVycy5CbGVuZENvbG9yID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kLnByb3RvdHlwZSAqLyB7XG4gICAgdHlwZTogJ0JsZW5kQ29sb3InLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3IgdG8gbWFrZSB0aGUgYmxlbmQgb3BlcmF0aW9uIHdpdGguIGRlZmF1bHQgdG8gYSByZWRkaXNoIGNvbG9yIHNpbmNlIGJsYWNrIG9yIHdoaXRlXG4gICAgICogZ2l2ZXMgYWx3YXlzIHN0cm9uZyByZXN1bHQuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiovXG4gICAgY29sb3I6ICcjRjk1QzYzJyxcblxuICAgIC8qKlxuICAgICAqIEJsZW5kIG1vZGUgZm9yIHRoZSBmaWx0ZXI6IG9uZSBvZiBtdWx0aXBseSwgYWRkLCBkaWZmLCBzY3JlZW4sIHN1YnRyYWN0LFxuICAgICAqIGRhcmtlbiwgbGlnaHRlbiwgb3ZlcmxheSwgZXhjbHVzaW9uLCB0aW50LlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICoqL1xuICAgIG1vZGU6ICdtdWx0aXBseScsXG5cbiAgICAvKipcbiAgICAgKiBhbHBoYSB2YWx1ZS4gcmVwcmVzZW50IHRoZSBzdHJlbmd0aCBvZiB0aGUgYmxlbmQgY29sb3Igb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICoqL1xuICAgIGFscGhhOiAxLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgTXVsdGlwbHkgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiB7XG4gICAgICBtdWx0aXBseTogJ2dsX0ZyYWdDb2xvci5yZ2IgKj0gdUNvbG9yLnJnYjtcXG4nLFxuICAgICAgc2NyZWVuOiAnZ2xfRnJhZ0NvbG9yLnJnYiA9IDEuMCAtICgxLjAgLSBnbF9GcmFnQ29sb3IucmdiKSAqICgxLjAgLSB1Q29sb3IucmdiKTtcXG4nLFxuICAgICAgYWRkOiAnZ2xfRnJhZ0NvbG9yLnJnYiArPSB1Q29sb3IucmdiO1xcbicsXG4gICAgICBkaWZmOiAnZ2xfRnJhZ0NvbG9yLnJnYiA9IGFicyhnbF9GcmFnQ29sb3IucmdiIC0gdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIHN1YnRyYWN0OiAnZ2xfRnJhZ0NvbG9yLnJnYiAtPSB1Q29sb3IucmdiO1xcbicsXG4gICAgICBsaWdodGVuOiAnZ2xfRnJhZ0NvbG9yLnJnYiA9IG1heChnbF9GcmFnQ29sb3IucmdiLCB1Q29sb3IucmdiKTtcXG4nLFxuICAgICAgZGFya2VuOiAnZ2xfRnJhZ0NvbG9yLnJnYiA9IG1pbihnbF9GcmFnQ29sb3IucmdiLCB1Q29sb3IucmdiKTtcXG4nLFxuICAgICAgZXhjbHVzaW9uOiAnZ2xfRnJhZ0NvbG9yLnJnYiArPSB1Q29sb3IucmdiIC0gMi4wICogKHVDb2xvci5yZ2IgKiBnbF9GcmFnQ29sb3IucmdiKTtcXG4nLFxuICAgICAgb3ZlcmxheTogJ2lmICh1Q29sb3IuciA8IDAuNSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuciAqPSAyLjAgKiB1Q29sb3IucjtcXG4nICtcbiAgICAgICAgJ30gZWxzZSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5yID0gMS4wIC0gMi4wICogKDEuMCAtIGdsX0ZyYWdDb2xvci5yKSAqICgxLjAgLSB1Q29sb3Iucik7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAgICdpZiAodUNvbG9yLmcgPCAwLjUpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmcgKj0gMi4wICogdUNvbG9yLmc7XFxuJyArXG4gICAgICAgICd9IGVsc2Uge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuZyA9IDEuMCAtIDIuMCAqICgxLjAgLSBnbF9GcmFnQ29sb3IuZykgKiAoMS4wIC0gdUNvbG9yLmcpO1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgICAnaWYgKHVDb2xvci5iIDwgMC41KSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5iICo9IDIuMCAqIHVDb2xvci5iO1xcbicgK1xuICAgICAgICAnfSBlbHNlIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmIgPSAxLjAgLSAyLjAgKiAoMS4wIC0gZ2xfRnJhZ0NvbG9yLmIpICogKDEuMCAtIHVDb2xvci5iKTtcXG4nICtcbiAgICAgICAgJ31cXG4nLFxuICAgICAgdGludDogJ2dsX0ZyYWdDb2xvci5yZ2IgKj0gKDEuMCAtIHVDb2xvci5hKTtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvci5yZ2IgKz0gdUNvbG9yLnJnYjtcXG4nLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBidWlsZCB0aGUgZnJhZ21lbnQgc291cmNlIGZvciB0aGUgZmlsdGVycywgam9pbmluZyB0aGUgY29tbW9uIHBhcnQgd2l0aFxuICAgICAqIHRoZSBzcGVjaWZpYyBvbmUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGUgdGhlIG1vZGUgb2YgdGhlIGZpbHRlciwgYSBrZXkgb2YgdGhpcy5mcmFnbWVudFNvdXJjZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHNvdXJjZSB0byBiZSBjb21waWxlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnVpbGRTb3VyY2U6IGZ1bmN0aW9uKG1vZGUpIHtcbiAgICAgIHJldHVybiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHZlYzQgdUNvbG9yO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICAgJ2lmIChjb2xvci5hID4gMC4wKSB7XFxuJyArXG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50U291cmNlW21vZGVdICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAnfSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyB0aGlzLm1vZGUsIHNoYWRlclNvdXJjZTtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgICAgIHNoYWRlclNvdXJjZSA9IHRoaXMuYnVpbGRTb3VyY2UodGhpcy5tb2RlKTtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgc2hhZGVyU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCbGVuZCBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGlMZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICB0ciwgdGcsIHRiLFxuICAgICAgICAgIHIsIGcsIGIsXG4gICAgICAgICAgc291cmNlLCBhbHBoYTEgPSAxIC0gdGhpcy5hbHBoYTtcblxuICAgICAgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKTtcbiAgICAgIHRyID0gc291cmNlWzBdICogdGhpcy5hbHBoYTtcbiAgICAgIHRnID0gc291cmNlWzFdICogdGhpcy5hbHBoYTtcbiAgICAgIHRiID0gc291cmNlWzJdICogdGhpcy5hbHBoYTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpTGVuOyBpICs9IDQpIHtcblxuICAgICAgICByID0gZGF0YVtpXTtcbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBiID0gZGF0YVtpICsgMl07XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICAgICAgICBjYXNlICdtdWx0aXBseSc6XG4gICAgICAgICAgICBkYXRhW2ldID0gciAqIHRyIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBnICogdGcgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGIgKiB0YiAvIDI1NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NjcmVlbic6XG4gICAgICAgICAgICBkYXRhW2ldID0gMjU1IC0gKDI1NSAtIHIpICogKDI1NSAtIHRyKSAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gMjU1IC0gKDI1NSAtIGcpICogKDI1NSAtIHRnKSAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gMjU1IC0gKDI1NSAtIGIpICogKDI1NSAtIHRiKSAvIDI1NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICBkYXRhW2ldID0gciArIHRyO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBnICsgdGc7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGIgKyB0YjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2RpZmYnOlxuICAgICAgICAgIGNhc2UgJ2RpZmZlcmVuY2UnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGguYWJzKHIgLSB0cik7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IE1hdGguYWJzKGcgLSB0Zyk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IE1hdGguYWJzKGIgLSB0Yik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzdWJ0cmFjdCc6XG4gICAgICAgICAgICBkYXRhW2ldID0gciAtIHRyO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBnIC0gdGc7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGIgLSB0YjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Rhcmtlbic6XG4gICAgICAgICAgICBkYXRhW2ldID0gTWF0aC5taW4ociwgdHIpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBNYXRoLm1pbihnLCB0Zyk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IE1hdGgubWluKGIsIHRiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2xpZ2h0ZW4nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGgubWF4KHIsIHRyKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTWF0aC5tYXgoZywgdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLm1heChiLCB0Yik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdvdmVybGF5JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSB0ciA8IDEyOCA/ICgyICogciAqIHRyIC8gMjU1KSA6ICgyNTUgLSAyICogKDI1NSAtIHIpICogKDI1NSAtIHRyKSAvIDI1NSk7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IHRnIDwgMTI4ID8gKDIgKiBnICogdGcgLyAyNTUpIDogKDI1NSAtIDIgKiAoMjU1IC0gZykgKiAoMjU1IC0gdGcpIC8gMjU1KTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gdGIgPCAxMjggPyAoMiAqIGIgKiB0YiAvIDI1NSkgOiAoMjU1IC0gMiAqICgyNTUgLSBiKSAqICgyNTUgLSB0YikgLyAyNTUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZXhjbHVzaW9uJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSB0ciArIHIgLSAoKDIgKiB0ciAqIHIpIC8gMjU1KTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gdGcgKyBnIC0gKCgyICogdGcgKiBnKSAvIDI1NSk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IHRiICsgYiAtICgoMiAqIHRiICogYikgLyAyNTUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGludCc6XG4gICAgICAgICAgICBkYXRhW2ldID0gdHIgKyByICogYWxwaGExO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSB0ZyArIGcgKiBhbHBoYTE7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IHRiICsgYiAqIGFscGhhMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUNvbG9yOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VDb2xvcicpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgdmFyIHNvdXJjZSA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcikuZ2V0U291cmNlKCk7XG4gICAgICBzb3VyY2VbMF0gPSB0aGlzLmFscGhhICogc291cmNlWzBdIC8gMjU1O1xuICAgICAgc291cmNlWzFdID0gdGhpcy5hbHBoYSAqIHNvdXJjZVsxXSAvIDI1NTtcbiAgICAgIHNvdXJjZVsyXSA9IHRoaXMuYWxwaGEgKiBzb3VyY2VbMl0gLyAyNTU7XG4gICAgICBzb3VyY2VbM10gPSB0aGlzLmFscGhhO1xuICAgICAgZ2wudW5pZm9ybTRmdih1bmlmb3JtTG9jYXRpb25zLnVDb2xvciwgc291cmNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgYWxwaGE6IHRoaXMuYWxwaGFcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kQ29sb3J9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kQ29sb3JcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kQ29sb3IuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogSW1hZ2UgQmxlbmQgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVyLkJsZW5kSW1hZ2VcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yKHtcbiAgICogIGNvbG9yOiAnIzAwMCcsXG4gICAqICBtb2RlOiAnbXVsdGlwbHknXG4gICAqIH0pO1xuICAgKlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2Uoe1xuICAgKiAgaW1hZ2U6IGZhYnJpY0ltYWdlT2JqZWN0LFxuICAgKiAgbW9kZTogJ211bHRpcGx5JyxcbiAgICogIGFscGhhOiAwLjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuXG4gIGZpbHRlcnMuQmxlbmRJbWFnZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlLnByb3RvdHlwZSAqLyB7XG4gICAgdHlwZTogJ0JsZW5kSW1hZ2UnLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3IgdG8gbWFrZSB0aGUgYmxlbmQgb3BlcmF0aW9uIHdpdGguIGRlZmF1bHQgdG8gYSByZWRkaXNoIGNvbG9yIHNpbmNlIGJsYWNrIG9yIHdoaXRlXG4gICAgICogZ2l2ZXMgYWx3YXlzIHN0cm9uZyByZXN1bHQuXG4gICAgICoqL1xuICAgIGltYWdlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQmxlbmQgbW9kZSBmb3IgdGhlIGZpbHRlciAob25lIG9mIFwibXVsdGlwbHlcIiwgXCJtYXNrXCIpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiovXG4gICAgbW9kZTogJ211bHRpcGx5JyxcblxuICAgIC8qKlxuICAgICAqIGFscGhhIHZhbHVlLiByZXByZXNlbnQgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibGVuZCBpbWFnZSBvcGVyYXRpb24uXG4gICAgICogbm90IGltcGxlbWVudGVkLlxuICAgICAqKi9cbiAgICBhbHBoYTogMSxcblxuICAgIHZlcnRleFNvdXJjZTogJ2F0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQyO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gbWF0MyB1VHJhbnNmb3JtTWF0cml4O1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZUZXhDb29yZCA9IGFQb3NpdGlvbjtcXG4nICtcbiAgICAgICAgJ3ZUZXhDb29yZDIgPSAodVRyYW5zZm9ybU1hdHJpeCAqIHZlYzMoYVBvc2l0aW9uLCAxLjApKS54eTtcXG4nICtcbiAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNChhUG9zaXRpb24gKiAyLjAgLSAxLjAsIDAuMCwgMS4wKTtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIE11bHRpcGx5IHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZToge1xuICAgICAgbXVsdGlwbHk6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVJbWFnZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCB1Q29sb3I7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDI7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IyID0gdGV4dHVyZTJEKHVJbWFnZSwgdlRleENvb3JkMik7XFxuJyArXG4gICAgICAgICAgJ2NvbG9yLnJnYmEgKj0gY29sb3IyLnJnYmE7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBtYXNrOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1SW1hZ2U7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHZlYzQgdUNvbG9yO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQyO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yMiA9IHRleHR1cmUyRCh1SW1hZ2UsIHZUZXhDb29yZDIpO1xcbicgK1xuICAgICAgICAgICdjb2xvci5hID0gY29sb3IyLmE7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyB0aGlzLm1vZGU7XG4gICAgICB2YXIgc2hhZGVyU291cmNlID0gdGhpcy5mcmFnbWVudFNvdXJjZVt0aGlzLm1vZGVdO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgc2hhZGVyU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIGFwcGx5VG9XZWJHTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgLy8gbG9hZCB0ZXh0dXJlIHRvIGJsZW5kLlxuICAgICAgdmFyIGdsID0gb3B0aW9ucy5jb250ZXh0LFxuICAgICAgICAgIHRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUob3B0aW9ucy5maWx0ZXJCYWNrZW5kLCB0aGlzLmltYWdlKTtcbiAgICAgIHRoaXMuYmluZEFkZGl0aW9uYWxUZXh0dXJlKGdsLCB0ZXh0dXJlLCBnbC5URVhUVVJFMSk7XG4gICAgICB0aGlzLmNhbGxTdXBlcignYXBwbHlUb1dlYkdMJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnVuYmluZEFkZGl0aW9uYWxUZXh0dXJlKGdsLCBnbC5URVhUVVJFMSk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVRleHR1cmU6IGZ1bmN0aW9uKGJhY2tlbmQsIGltYWdlKSB7XG4gICAgICByZXR1cm4gYmFja2VuZC5nZXRDYWNoZWRUZXh0dXJlKGltYWdlLmNhY2hlS2V5LCBpbWFnZS5fZWxlbWVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBhIHRyYW5zZm9ybU1hdHJpeCB0byBhZGFwdCB0aGUgaW1hZ2UgdG8gYmxlbmQgb3ZlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgY2FsY3VsYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2UsXG4gICAgICAgICAgd2lkdGggPSBpbWFnZS5fZWxlbWVudC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBpbWFnZS5fZWxlbWVudC5oZWlnaHQ7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAxIC8gaW1hZ2Uuc2NhbGVYLCAwLCAwLFxuICAgICAgICAwLCAxIC8gaW1hZ2Uuc2NhbGVZLCAwLFxuICAgICAgICAtaW1hZ2UubGVmdCAvIHdpZHRoLCAtaW1hZ2UudG9wIC8gaGVpZ2h0LCAxXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQmxlbmQgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgcmVzb3VyY2VzID0gb3B0aW9ucy5maWx0ZXJCYWNrZW5kLnJlc291cmNlcyxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGlMZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICB3aWR0aCA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgIHRyLCB0ZywgdGIsIHRhLFxuICAgICAgICAgIHIsIGcsIGIsIGEsXG4gICAgICAgICAgY2FudmFzMSwgY29udGV4dCwgaW1hZ2UgPSB0aGlzLmltYWdlLCBibGVuZERhdGE7XG5cbiAgICAgIGlmICghcmVzb3VyY2VzLmJsZW5kSW1hZ2UpIHtcbiAgICAgICAgcmVzb3VyY2VzLmJsZW5kSW1hZ2UgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB9XG4gICAgICBjYW52YXMxID0gcmVzb3VyY2VzLmJsZW5kSW1hZ2U7XG4gICAgICBjb250ZXh0ID0gY2FudmFzMS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgaWYgKGNhbnZhczEud2lkdGggIT09IHdpZHRoIHx8IGNhbnZhczEuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgY2FudmFzMS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMxLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKGltYWdlLnNjYWxlWCwgMCwgMCwgaW1hZ2Uuc2NhbGVZLCBpbWFnZS5sZWZ0LCBpbWFnZS50b3ApO1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UuX2VsZW1lbnQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgYmxlbmREYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgciA9IGRhdGFbaV07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuICAgICAgICBhID0gZGF0YVtpICsgM107XG5cbiAgICAgICAgdHIgPSBibGVuZERhdGFbaV07XG4gICAgICAgIHRnID0gYmxlbmREYXRhW2kgKyAxXTtcbiAgICAgICAgdGIgPSBibGVuZERhdGFbaSArIDJdO1xuICAgICAgICB0YSA9IGJsZW5kRGF0YVtpICsgM107XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICAgICAgICBjYXNlICdtdWx0aXBseSc6XG4gICAgICAgICAgICBkYXRhW2ldID0gciAqIHRyIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBnICogdGcgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IGIgKiB0YiAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDNdID0gYSAqIHRhIC8gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWFzayc6XG4gICAgICAgICAgICBkYXRhW2kgKyAzXSA9IHRhO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVUcmFuc2Zvcm1NYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVRyYW5zZm9ybU1hdHJpeCcpLFxuICAgICAgICB1SW1hZ2U6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUltYWdlJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgbWF0cml4ID0gdGhpcy5jYWxjdWxhdGVNYXRyaXgoKTtcbiAgICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtTG9jYXRpb25zLnVJbWFnZSwgMSk7IC8vIHRleHR1cmUgdW5pdCAxLlxuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1bmlmb3JtTG9jYXRpb25zLnVUcmFuc2Zvcm1NYXRyaXgsIGZhbHNlLCBtYXRyaXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBpbWFnZTogdGhpcy5pbWFnZSAmJiB0aGlzLmltYWdlLnRvT2JqZWN0KCksXG4gICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgYWxwaGE6IHRoaXMuYWxwaGFcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLkltYWdlLmZyb21PYmplY3Qob2JqZWN0LmltYWdlLCBmdW5jdGlvbihpbWFnZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob2JqZWN0KTtcbiAgICAgIG9wdGlvbnMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlKG9wdGlvbnMpKTtcbiAgICB9KTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSwgcG93ID0gTWF0aC5wb3csIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgIHNxcnQgPSBNYXRoLnNxcnQsIGFicyA9IE1hdGguYWJzLCByb3VuZCA9IE1hdGgucm91bmQsIHNpbiA9IE1hdGguc2luLFxuICAgICAgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFJlc2l6ZSBpbWFnZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplKCk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLlJlc2l6ZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdSZXNpemUnLFxuXG4gICAgLyoqXG4gICAgICogUmVzaXplIHR5cGVcbiAgICAgKiBmb3Igd2ViZ2wgcmVzaXplVHlwZSBpcyBqdXN0IGxhbmN6b3MsIGZvciBjYW52YXMyZCBjYW4gYmU6XG4gICAgICogYmlsaW5lYXIsIGhlcm1pdGUsIHNsaWNlSGFjaywgbGFuY3pvcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVzaXplVHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmVzaXplVHlwZTogJ2hlcm1pdGUnLFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgZmFjdG9yIGZvciByZXNpemluZywgeCBheGlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVYOiAxLFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgZmFjdG9yIGZvciByZXNpemluZywgeSBheGlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVZOiAxLFxuXG4gICAgLyoqXG4gICAgICogTGFuY3pvc0xvYmVzIHBhcmFtZXRlciBmb3IgbGFuY3pvcyBmaWx0ZXIsIHZhbGlkIGZvciByZXNpemVUeXBlIGxhbmN6b3NcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGFuY3pvc0xvYmVzXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsYW5jem9zTG9iZXM6IDMsXG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1RGVsdGE6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndURlbHRhJyksXG4gICAgICAgIHVUYXBzOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VUYXBzJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMmZ2KHVuaWZvcm1Mb2NhdGlvbnMudURlbHRhLCB0aGlzLmhvcml6b250YWwgPyBbMSAvIHRoaXMud2lkdGgsIDBdIDogWzAsIDEgLyB0aGlzLmhlaWdodF0pO1xuICAgICAgZ2wudW5pZm9ybTFmdih1bmlmb3JtTG9jYXRpb25zLnVUYXBzLCB0aGlzLnRhcHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGZpbHRlcldpbmRvdyA9IHRoaXMuZ2V0RmlsdGVyV2luZG93KCksIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgZmlsdGVyV2luZG93O1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gdGhpcy5nZW5lcmF0ZVNoYWRlcihmaWx0ZXJXaW5kb3cpO1xuICAgICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0LCBmcmFnbWVudFNoYWRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICBnZXRGaWx0ZXJXaW5kb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy50ZW1wU2NhbGU7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMubGFuY3pvc0xvYmVzIC8gc2NhbGUpO1xuICAgIH0sXG5cbiAgICBnZXRUYXBzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsb2JlRnVuY3Rpb24gPSB0aGlzLmxhbmN6b3NDcmVhdGUodGhpcy5sYW5jem9zTG9iZXMpLCBzY2FsZSA9IHRoaXMudGVtcFNjYWxlLFxuICAgICAgICAgIGZpbHRlcldpbmRvdyA9IHRoaXMuZ2V0RmlsdGVyV2luZG93KCksIHRhcHMgPSBuZXcgQXJyYXkoZmlsdGVyV2luZG93KTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGZpbHRlcldpbmRvdzsgaSsrKSB7XG4gICAgICAgIHRhcHNbaSAtIDFdID0gbG9iZUZ1bmN0aW9uKGkgKiBzY2FsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFwcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdmVydGV4IGFuZCBzaGFkZXIgc291cmNlcyBmcm9tIHRoZSBuZWNlc3Nhcnkgc3RlcHMgbnVtYmVyc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmaWx0ZXJXaW5kb3dcbiAgICAgKi9cbiAgICBnZW5lcmF0ZVNoYWRlcjogZnVuY3Rpb24oZmlsdGVyV2luZG93KSB7XG4gICAgICB2YXIgb2Zmc2V0cyA9IG5ldyBBcnJheShmaWx0ZXJXaW5kb3cpLFxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyID0gdGhpcy5mcmFnbWVudFNvdXJjZVRPUCwgZmlsdGVyV2luZG93O1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBmaWx0ZXJXaW5kb3c7IGkrKykge1xuICAgICAgICBvZmZzZXRzW2kgLSAxXSA9IGkgKyAnLjAgKiB1RGVsdGEnO1xuICAgICAgfVxuXG4gICAgICBmcmFnbWVudFNoYWRlciArPSAndW5pZm9ybSBmbG9hdCB1VGFwc1snICsgZmlsdGVyV2luZG93ICsgJ107XFxuJztcbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICd2b2lkIG1haW4oKSB7XFxuJztcbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJztcbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIGZsb2F0IHN1bSA9IDEuMDtcXG4nO1xuXG4gICAgICBvZmZzZXRzLmZvckVhY2goZnVuY3Rpb24ob2Zmc2V0LCBpKSB7XG4gICAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIGNvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgJyArIG9mZnNldCArICcpICogdVRhcHNbJyArIGkgKyAnXTtcXG4nO1xuICAgICAgICBmcmFnbWVudFNoYWRlciArPSAnICBjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCAtICcgKyBvZmZzZXQgKyAnKSAqIHVUYXBzWycgKyBpICsgJ107XFxuJztcbiAgICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgc3VtICs9IDIuMCAqIHVUYXBzWycgKyBpICsgJ107XFxuJztcbiAgICAgIH0pO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyBzdW07XFxuJztcbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICd9JztcbiAgICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcbiAgICB9LFxuXG4gICAgZnJhZ21lbnRTb3VyY2VUT1A6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWMyIHVEZWx0YTtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgcmVzaXplIGZpbHRlciB0byB0aGUgaW1hZ2VcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gdXNlIFdlYkdMIG9yIENhbnZhczJEIGJhc2VkIG9uIHRoZSBvcHRpb25zLndlYmdsIGZsYWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGV4ZWN1dGVkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLndlYmdsIFdoZXRoZXIgdG8gdXNlIHdlYmdsIHRvIHJlbmRlciB0aGUgZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnNvdXJjZVRleHR1cmUgVGhlIHRleHR1cmUgc2V0dXAgYXMgdGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy50YXJnZXRUZXh0dXJlIFRoZSB0ZXh0dXJlIHdoZXJlIGZpbHRlcmVkIG91dHB1dCBzaG91bGQgYmUgZHJhd24uXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMud2ViZ2wpIHtcbiAgICAgICAgb3B0aW9ucy5wYXNzZXMrKztcbiAgICAgICAgdGhpcy53aWR0aCA9IG9wdGlvbnMuc291cmNlV2lkdGg7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIHRoaXMuZFcgPSBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiB0aGlzLnNjYWxlWCk7XG4gICAgICAgIHRoaXMuZEggPSBvcHRpb25zLnNvdXJjZUhlaWdodDtcbiAgICAgICAgdGhpcy50ZW1wU2NhbGUgPSB0aGlzLmRXIC8gdGhpcy53aWR0aDtcbiAgICAgICAgdGhpcy50YXBzID0gdGhpcy5nZXRUYXBzKCk7XG4gICAgICAgIG9wdGlvbnMuZGVzdGluYXRpb25XaWR0aCA9IHRoaXMuZFc7XG4gICAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuc291cmNlV2lkdGggPSBvcHRpb25zLmRlc3RpbmF0aW9uV2lkdGg7XG5cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLnNvdXJjZUhlaWdodDtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZEggPSBNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0ICogdGhpcy5zY2FsZVkpO1xuICAgICAgICB0aGlzLnRlbXBTY2FsZSA9IHRoaXMuZEggLyB0aGlzLmhlaWdodDtcbiAgICAgICAgdGhpcy50YXBzID0gdGhpcy5nZXRUYXBzKCk7XG4gICAgICAgIG9wdGlvbnMuZGVzdGluYXRpb25IZWlnaHQgPSB0aGlzLmRIO1xuICAgICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLnNvdXJjZUhlaWdodCA9IG9wdGlvbnMuZGVzdGluYXRpb25IZWlnaHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5hcHBseVRvMmQob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlWCA9PT0gMSAmJiB0aGlzLnNjYWxlWSA9PT0gMTtcbiAgICB9LFxuXG4gICAgbGFuY3pvc0NyZWF0ZTogZnVuY3Rpb24obG9iZXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh4ID49IGxvYmVzIHx8IHggPD0gLWxvYmVzKSB7XG4gICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA8IDEuMTkyMDkyOTBFLTA3ICYmIHggPiAtMS4xOTIwOTI5MEUtMDcpIHtcbiAgICAgICAgICByZXR1cm4gMS4wO1xuICAgICAgICB9XG4gICAgICAgIHggKj0gTWF0aC5QSTtcbiAgICAgICAgdmFyIHh4ID0geCAvIGxvYmVzO1xuICAgICAgICByZXR1cm4gKHNpbih4KSAvIHgpICogc2luKHh4KSAvIHh4O1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXIgdG8gY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWVxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIHNjYWxlWCA9IHRoaXMuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlWSA9IHRoaXMuc2NhbGVZO1xuXG4gICAgICB0aGlzLnJjcFNjYWxlWCA9IDEgLyBzY2FsZVg7XG4gICAgICB0aGlzLnJjcFNjYWxlWSA9IDEgLyBzY2FsZVk7XG5cbiAgICAgIHZhciBvVyA9IGltYWdlRGF0YS53aWR0aCwgb0ggPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgIGRXID0gcm91bmQob1cgKiBzY2FsZVgpLCBkSCA9IHJvdW5kKG9IICogc2NhbGVZKSxcbiAgICAgICAgICBuZXdEYXRhO1xuXG4gICAgICBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnc2xpY2VIYWNrJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5zbGljZUJ5VHdvKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2hlcm1pdGUnKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLmhlcm1pdGVGYXN0UmVzaXplKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2JpbGluZWFyJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5iaWxpbmVhckZpbHRlcmluZyhvcHRpb25zLCBvVywgb0gsIGRXLCBkSCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnJlc2l6ZVR5cGUgPT09ICdsYW5jem9zJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5sYW5jem9zUmVzaXplKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuaW1hZ2VEYXRhID0gbmV3RGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHNsaWNlQnlUd29cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIHNsaWNlQnlUd286IGZ1bmN0aW9uKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgbXVsdCA9IDAuNSwgZG9uZVcgPSBmYWxzZSwgZG9uZUggPSBmYWxzZSwgc3RlcFcgPSBvVyAqIG11bHQsXG4gICAgICAgICAgc3RlcEggPSBvSCAqIG11bHQsIHJlc291cmNlcyA9IGZhYnJpYy5maWx0ZXJCYWNrZW5kLnJlc291cmNlcyxcbiAgICAgICAgICB0bXBDYW52YXMsIGN0eCwgc1ggPSAwLCBzWSA9IDAsIGRYID0gb1csIGRZID0gMDtcbiAgICAgIGlmICghcmVzb3VyY2VzLnNsaWNlQnlUd28pIHtcbiAgICAgICAgcmVzb3VyY2VzLnNsaWNlQnlUd28gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIH1cbiAgICAgIHRtcENhbnZhcyA9IHJlc291cmNlcy5zbGljZUJ5VHdvO1xuICAgICAgaWYgKHRtcENhbnZhcy53aWR0aCA8IG9XICogMS41IHx8IHRtcENhbnZhcy5oZWlnaHQgPCBvSCkge1xuICAgICAgICB0bXBDYW52YXMud2lkdGggPSBvVyAqIDEuNTtcbiAgICAgICAgdG1wQ2FudmFzLmhlaWdodCA9IG9IO1xuICAgICAgfVxuICAgICAgY3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIG9XICogMS41LCBvSCk7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG5cbiAgICAgIGRXID0gZmxvb3IoZFcpO1xuICAgICAgZEggPSBmbG9vcihkSCk7XG5cbiAgICAgIHdoaWxlICghZG9uZVcgfHwgIWRvbmVIKSB7XG4gICAgICAgIG9XID0gc3RlcFc7XG4gICAgICAgIG9IID0gc3RlcEg7XG4gICAgICAgIGlmIChkVyA8IGZsb29yKHN0ZXBXICogbXVsdCkpIHtcbiAgICAgICAgICBzdGVwVyA9IGZsb29yKHN0ZXBXICogbXVsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3RlcFcgPSBkVztcbiAgICAgICAgICBkb25lVyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRIIDwgZmxvb3Ioc3RlcEggKiBtdWx0KSkge1xuICAgICAgICAgIHN0ZXBIID0gZmxvb3Ioc3RlcEggKiBtdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzdGVwSCA9IGRIO1xuICAgICAgICAgIGRvbmVIID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZHJhd0ltYWdlKHRtcENhbnZhcywgc1gsIHNZLCBvVywgb0gsIGRYLCBkWSwgc3RlcFcsIHN0ZXBIKTtcbiAgICAgICAgc1ggPSBkWDtcbiAgICAgICAgc1kgPSBkWTtcbiAgICAgICAgZFkgKz0gc3RlcEg7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3R4LmdldEltYWdlRGF0YShzWCwgc1ksIGRXLCBkSCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBsYW5jem9zUmVzaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBsYW5jem9zUmVzaXplOiBmdW5jdGlvbihvcHRpb25zLCBvVywgb0gsIGRXLCBkSCkge1xuXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzKHUpIHtcbiAgICAgICAgdmFyIHYsIGksIHdlaWdodCwgaWR4LCBhLCByZWQsIGdyZWVuLFxuICAgICAgICAgICAgYmx1ZSwgYWxwaGEsIGZYLCBmWTtcbiAgICAgICAgY2VudGVyLnggPSAodSArIDAuNSkgKiByYXRpb1g7XG4gICAgICAgIGljZW50ZXIueCA9IGZsb29yKGNlbnRlci54KTtcbiAgICAgICAgZm9yICh2ID0gMDsgdiA8IGRIOyB2KyspIHtcbiAgICAgICAgICBjZW50ZXIueSA9ICh2ICsgMC41KSAqIHJhdGlvWTtcbiAgICAgICAgICBpY2VudGVyLnkgPSBmbG9vcihjZW50ZXIueSk7XG4gICAgICAgICAgYSA9IDA7IHJlZCA9IDA7IGdyZWVuID0gMDsgYmx1ZSA9IDA7IGFscGhhID0gMDtcbiAgICAgICAgICBmb3IgKGkgPSBpY2VudGVyLnggLSByYW5nZTJYOyBpIDw9IGljZW50ZXIueCArIHJhbmdlMlg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gb1cpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmWCA9IGZsb29yKDEwMDAgKiBhYnMoaSAtIGNlbnRlci54KSk7XG4gICAgICAgICAgICBpZiAoIWNhY2hlTGFuY1tmWF0pIHtcbiAgICAgICAgICAgICAgY2FjaGVMYW5jW2ZYXSA9IHsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpY2VudGVyLnkgLSByYW5nZTJZOyBqIDw9IGljZW50ZXIueSArIHJhbmdlMlk7IGorKykge1xuICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBvSCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZZID0gZmxvb3IoMTAwMCAqIGFicyhqIC0gY2VudGVyLnkpKTtcbiAgICAgICAgICAgICAgaWYgKCFjYWNoZUxhbmNbZlhdW2ZZXSkge1xuICAgICAgICAgICAgICAgIGNhY2hlTGFuY1tmWF1bZlldID0gbGFuY3pvcyhzcXJ0KHBvdyhmWCAqIHJjcFJhdGlvWCwgMikgKyBwb3coZlkgKiByY3BSYXRpb1ksIDIpKSAvIDEwMDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdlaWdodCA9IGNhY2hlTGFuY1tmWF1bZlldO1xuICAgICAgICAgICAgICBpZiAod2VpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIGlkeCA9IChqICogb1cgKyBpKSAqIDQ7XG4gICAgICAgICAgICAgICAgYSArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmVkICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4XTtcbiAgICAgICAgICAgICAgICBncmVlbiArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDFdO1xuICAgICAgICAgICAgICAgIGJsdWUgKz0gd2VpZ2h0ICogc3JjRGF0YVtpZHggKyAyXTtcbiAgICAgICAgICAgICAgICBhbHBoYSArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDNdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkeCA9ICh2ICogZFcgKyB1KSAqIDQ7XG4gICAgICAgICAgZGVzdERhdGFbaWR4XSA9IHJlZCAvIGE7XG4gICAgICAgICAgZGVzdERhdGFbaWR4ICsgMV0gPSBncmVlbiAvIGE7XG4gICAgICAgICAgZGVzdERhdGFbaWR4ICsgMl0gPSBibHVlIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAzXSA9IGFscGhhIC8gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgrK3UgPCBkVykge1xuICAgICAgICAgIHJldHVybiBwcm9jZXNzKHUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZXN0SW1nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzcmNEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBkZXN0SW1nID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKGRXLCBkSCksXG4gICAgICAgICAgZGVzdERhdGEgPSBkZXN0SW1nLmRhdGEsXG4gICAgICAgICAgbGFuY3pvcyA9IHRoaXMubGFuY3pvc0NyZWF0ZSh0aGlzLmxhbmN6b3NMb2JlcyksXG4gICAgICAgICAgcmF0aW9YID0gdGhpcy5yY3BTY2FsZVgsIHJhdGlvWSA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJjcFJhdGlvWCA9IDIgLyB0aGlzLnJjcFNjYWxlWCwgcmNwUmF0aW9ZID0gMiAvIHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJhbmdlMlggPSBjZWlsKHJhdGlvWCAqIHRoaXMubGFuY3pvc0xvYmVzIC8gMiksXG4gICAgICAgICAgcmFuZ2UyWSA9IGNlaWwocmF0aW9ZICogdGhpcy5sYW5jem9zTG9iZXMgLyAyKSxcbiAgICAgICAgICBjYWNoZUxhbmMgPSB7IH0sIGNlbnRlciA9IHsgfSwgaWNlbnRlciA9IHsgfTtcblxuICAgICAgcmV0dXJuIHByb2Nlc3MoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGJpbGluZWFyRmlsdGVyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBiaWxpbmVhckZpbHRlcmluZzogZnVuY3Rpb24ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpIHtcbiAgICAgIHZhciBhLCBiLCBjLCBkLCB4LCB5LCBpLCBqLCB4RGlmZiwgeURpZmYsIGNobmwsXG4gICAgICAgICAgY29sb3IsIG9mZnNldCA9IDAsIG9yaWdQaXgsIHJhdGlvWCA9IHRoaXMucmNwU2NhbGVYLFxuICAgICAgICAgIHJhdGlvWSA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHc0ID0gNCAqIChvVyAtIDEpLCBpbWcgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBwaXhlbHMgPSBpbWcuZGF0YSwgZGVzdEltYWdlID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKGRXLCBkSCksXG4gICAgICAgICAgZGVzdFBpeGVscyA9IGRlc3RJbWFnZS5kYXRhO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGRIOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGRXOyBqKyspIHtcbiAgICAgICAgICB4ID0gZmxvb3IocmF0aW9YICogaik7XG4gICAgICAgICAgeSA9IGZsb29yKHJhdGlvWSAqIGkpO1xuICAgICAgICAgIHhEaWZmID0gcmF0aW9YICogaiAtIHg7XG4gICAgICAgICAgeURpZmYgPSByYXRpb1kgKiBpIC0geTtcbiAgICAgICAgICBvcmlnUGl4ID0gNCAqICh5ICogb1cgKyB4KTtcblxuICAgICAgICAgIGZvciAoY2hubCA9IDA7IGNobmwgPCA0OyBjaG5sKyspIHtcbiAgICAgICAgICAgIGEgPSBwaXhlbHNbb3JpZ1BpeCArIGNobmxdO1xuICAgICAgICAgICAgYiA9IHBpeGVsc1tvcmlnUGl4ICsgNCArIGNobmxdO1xuICAgICAgICAgICAgYyA9IHBpeGVsc1tvcmlnUGl4ICsgdzQgKyBjaG5sXTtcbiAgICAgICAgICAgIGQgPSBwaXhlbHNbb3JpZ1BpeCArIHc0ICsgNCArIGNobmxdO1xuICAgICAgICAgICAgY29sb3IgPSBhICogKDEgLSB4RGlmZikgKiAoMSAtIHlEaWZmKSArIGIgKiB4RGlmZiAqICgxIC0geURpZmYpICtcbiAgICAgICAgICAgICAgICAgICAgYyAqIHlEaWZmICogKDEgLSB4RGlmZikgKyBkICogeERpZmYgKiB5RGlmZjtcbiAgICAgICAgICAgIGRlc3RQaXhlbHNbb2Zmc2V0KytdID0gY29sb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzdEltYWdlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoZXJtaXRlRmFzdFJlc2l6ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb1cgT3JpZ2luYWwgV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb0ggT3JpZ2luYWwgSGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRXIERlc3RpbmF0aW9uIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRIIERlc3RpbmF0aW9uIEhlaWdodFxuICAgICAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gICAgICovXG4gICAgaGVybWl0ZUZhc3RSZXNpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKSB7XG4gICAgICB2YXIgcmF0aW9XID0gdGhpcy5yY3BTY2FsZVgsIHJhdGlvSCA9IHRoaXMucmNwU2NhbGVZLFxuICAgICAgICAgIHJhdGlvV0hhbGYgPSBjZWlsKHJhdGlvVyAvIDIpLFxuICAgICAgICAgIHJhdGlvSEhhbGYgPSBjZWlsKHJhdGlvSCAvIDIpLFxuICAgICAgICAgIGltZyA9IG9wdGlvbnMuaW1hZ2VEYXRhLCBkYXRhID0gaW1nLmRhdGEsXG4gICAgICAgICAgaW1nMiA9IG9wdGlvbnMuY3R4LmNyZWF0ZUltYWdlRGF0YShkVywgZEgpLCBkYXRhMiA9IGltZzIuZGF0YTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZEg7IGorKykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRXOyBpKyspIHtcbiAgICAgICAgICB2YXIgeDIgPSAoaSArIGogKiBkVykgKiA0LCB3ZWlnaHQgPSAwLCB3ZWlnaHRzID0gMCwgd2VpZ2h0c0FscGhhID0gMCxcbiAgICAgICAgICAgICAgZ3hSID0gMCwgZ3hHID0gMCwgZ3hCID0gMCwgZ3hBID0gMCwgY2VudGVyWSA9IChqICsgMC41KSAqIHJhdGlvSDtcbiAgICAgICAgICBmb3IgKHZhciB5eSA9IGZsb29yKGogKiByYXRpb0gpOyB5eSA8IChqICsgMSkgKiByYXRpb0g7IHl5KyspIHtcbiAgICAgICAgICAgIHZhciBkeSA9IGFicyhjZW50ZXJZIC0gKHl5ICsgMC41KSkgLyByYXRpb0hIYWxmLFxuICAgICAgICAgICAgICAgIGNlbnRlclggPSAoaSArIDAuNSkgKiByYXRpb1csIHcwID0gZHkgKiBkeTtcbiAgICAgICAgICAgIGZvciAodmFyIHh4ID0gZmxvb3IoaSAqIHJhdGlvVyk7IHh4IDwgKGkgKyAxKSAqIHJhdGlvVzsgeHgrKykge1xuICAgICAgICAgICAgICB2YXIgZHggPSBhYnMoY2VudGVyWCAtICh4eCArIDAuNSkpIC8gcmF0aW9XSGFsZixcbiAgICAgICAgICAgICAgICAgIHcgPSBzcXJ0KHcwICsgZHggKiBkeCk7XG4gICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuICAgICAgICAgICAgICBpZiAodyA+IDEgJiYgdyA8IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy9oZXJtaXRlIGZpbHRlclxuICAgICAgICAgICAgICB3ZWlnaHQgPSAyICogdyAqIHcgKiB3IC0gMyAqIHcgKiB3ICsgMTtcbiAgICAgICAgICAgICAgaWYgKHdlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICBkeCA9IDQgKiAoeHggKyB5eSAqIG9XKTtcbiAgICAgICAgICAgICAgICAvL2FscGhhXG4gICAgICAgICAgICAgICAgZ3hBICs9IHdlaWdodCAqIGRhdGFbZHggKyAzXTtcbiAgICAgICAgICAgICAgICB3ZWlnaHRzQWxwaGEgKz0gd2VpZ2h0O1xuICAgICAgICAgICAgICAgIC8vY29sb3JzXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbZHggKyAzXSA8IDI1NSkge1xuICAgICAgICAgICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0ICogZGF0YVtkeCArIDNdIC8gMjUwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBneFIgKz0gd2VpZ2h0ICogZGF0YVtkeF07XG4gICAgICAgICAgICAgICAgZ3hHICs9IHdlaWdodCAqIGRhdGFbZHggKyAxXTtcbiAgICAgICAgICAgICAgICBneEIgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDJdO1xuICAgICAgICAgICAgICAgIHdlaWdodHMgKz0gd2VpZ2h0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGEyW3gyXSA9IGd4UiAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAxXSA9IGd4RyAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAyXSA9IGd4QiAvIHdlaWdodHM7XG4gICAgICAgICAgZGF0YTJbeDIgKyAzXSA9IGd4QSAvIHdlaWdodHNBbHBoYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGltZzI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIHNjYWxlWDogdGhpcy5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVksXG4gICAgICAgIHJlc2l6ZVR5cGU6IHRoaXMucmVzaXplVHlwZSxcbiAgICAgICAgbGFuY3pvc0xvYmVzOiB0aGlzLmxhbmN6b3NMb2Jlc1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29udHJhc3QgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3Qoe1xuICAgKiAgIGNvbnRyYXN0OiAwLjI1XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuQ29udHJhc3QgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdDb250cmFzdCcsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVDb250cmFzdDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdmbG9hdCBjb250cmFzdEYgPSAxLjAxNSAqICh1Q29udHJhc3QgKyAxLjApIC8gKDEuMCAqICgxLjAxNSAtIHVDb250cmFzdCkpO1xcbicgK1xuICAgICAgICAnY29sb3IucmdiID0gY29udHJhc3RGICogKGNvbG9yLnJnYiAtIDAuNSkgKyAwLjU7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIGNvbnRyYXN0IHZhbHVlLCByYW5nZSBmcm9tIC0xIHRvIDEuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbnRyYXN0XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGNvbnRyYXN0OiAwLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ2NvbnRyYXN0JyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29udHJhc3Q9MF0gVmFsdWUgdG8gY29udHJhc3QgdGhlIGltYWdlIHVwICgtMS4uLjEpXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgICogQXBwbHkgdGhlIENvbnRyYXN0IG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICAqXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5jb250cmFzdCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsIGksIGxlbixcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGNvbnRyYXN0ID0gTWF0aC5mbG9vcih0aGlzLmNvbnRyYXN0ICogMjU1KSxcbiAgICAgICAgICBjb250cmFzdEYgPSAyNTkgKiAoY29udHJhc3QgKyAyNTUpIC8gKDI1NSAqICgyNTkgLSBjb250cmFzdCkpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IGNvbnRyYXN0RiAqIChkYXRhW2ldIC0gMTI4KSArIDEyODtcbiAgICAgICAgZGF0YVtpICsgMV0gPSBjb250cmFzdEYgKiAoZGF0YVtpICsgMV0gLSAxMjgpICsgMTI4O1xuICAgICAgICBkYXRhW2kgKyAyXSA9IGNvbnRyYXN0RiAqIChkYXRhW2kgKyAyXSAtIDEyOCkgKyAxMjg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1Q29udHJhc3Q6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUNvbnRyYXN0JyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51Q29udHJhc3QsIHRoaXMuY29udHJhc3QpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3R9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdC5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogU2F0dXJhdGUgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb24oe1xuICAgKiAgIHNhdHVyYXRpb246IDFcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5TYXR1cmF0aW9uID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb24ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdTYXR1cmF0aW9uJyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVNhdHVyYXRpb247XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnZmxvYXQgcmdNYXggPSBtYXgoY29sb3IuciwgY29sb3IuZyk7XFxuJyArXG4gICAgICAgICdmbG9hdCByZ2JNYXggPSBtYXgocmdNYXgsIGNvbG9yLmIpO1xcbicgK1xuICAgICAgICAnY29sb3IuciArPSByZ2JNYXggIT0gY29sb3IuciA/IChyZ2JNYXggLSBjb2xvci5yKSAqIHVTYXR1cmF0aW9uIDogMC4wMDtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmcgKz0gcmdiTWF4ICE9IGNvbG9yLmcgPyAocmdiTWF4IC0gY29sb3IuZykgKiB1U2F0dXJhdGlvbiA6IDAuMDA7XFxuJyArXG4gICAgICAgICdjb2xvci5iICs9IHJnYk1heCAhPSBjb2xvci5iID8gKHJnYk1heCAtIGNvbG9yLmIpICogdVNhdHVyYXRpb24gOiAwLjAwO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBTYXR1cmF0aW9uIHZhbHVlLCBmcm9tIC0xIHRvIDEuXG4gICAgICogSW5jcmVhc2VzL2RlY3JlYXNlcyB0aGUgY29sb3Igc2F0dXJhdGlvbi5cbiAgICAgKiBBIHZhbHVlIG9mIDAgaGFzIG5vIGVmZmVjdC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2F0dXJhdGlvbjogMCxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdzYXR1cmF0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2F0dXJhdGU9MF0gVmFsdWUgdG8gc2F0dXJhdGUgdGhlIGltYWdlICgtMS4uLjEpXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgU2F0dXJhdGlvbiBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLnNhdHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgYWRqdXN0ID0gLXRoaXMuc2F0dXJhdGlvbiwgaSwgbWF4O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgoZGF0YVtpXSwgZGF0YVtpICsgMV0sIGRhdGFbaSArIDJdKTtcbiAgICAgICAgZGF0YVtpXSArPSBtYXggIT09IGRhdGFbaV0gPyAobWF4IC0gZGF0YVtpXSkgKiBhZGp1c3QgOiAwO1xuICAgICAgICBkYXRhW2kgKyAxXSArPSBtYXggIT09IGRhdGFbaSArIDFdID8gKG1heCAtIGRhdGFbaSArIDFdKSAqIGFkanVzdCA6IDA7XG4gICAgICAgIGRhdGFbaSArIDJdICs9IG1heCAhPT0gZGF0YVtpICsgMl0gPyAobWF4IC0gZGF0YVtpICsgMl0pICogYWRqdXN0IDogMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVTYXR1cmF0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTYXR1cmF0aW9uJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51U2F0dXJhdGlvbiwgLXRoaXMuc2F0dXJhdGlvbik7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9ufSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbi5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogVmlicmFuY2UgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5WaWJyYW5jZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5WaWJyYW5jZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuVmlicmFuY2Uoe1xuICAgKiAgIHZpYnJhbmNlOiAxXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuVmlicmFuY2UgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuVmlicmFuY2UucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdWaWJyYW5jZScsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVWaWJyYW5jZTtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdmbG9hdCBtYXggPSBtYXgoY29sb3IuciwgbWF4KGNvbG9yLmcsIGNvbG9yLmIpKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGF2ZyA9IChjb2xvci5yICsgY29sb3IuZyArIGNvbG9yLmIpIC8gMy4wO1xcbicgK1xuICAgICAgICAnZmxvYXQgYW10ID0gKGFicyhtYXggLSBhdmcpICogMi4wKSAqIHVWaWJyYW5jZTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnIgKz0gbWF4ICE9IGNvbG9yLnIgPyAobWF4IC0gY29sb3IucikgKiBhbXQgOiAwLjAwO1xcbicgK1xuICAgICAgICAnY29sb3IuZyArPSBtYXggIT0gY29sb3IuZyA/IChtYXggLSBjb2xvci5nKSAqIGFtdCA6IDAuMDA7XFxuJyArXG4gICAgICAgICdjb2xvci5iICs9IG1heCAhPSBjb2xvci5iID8gKG1heCAtIGNvbG9yLmIpICogYW10IDogMC4wMDtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogVmlicmFuY2UgdmFsdWUsIGZyb20gLTEgdG8gMS5cbiAgICAgKiBJbmNyZWFzZXMvZGVjcmVhc2VzIHRoZSBzYXR1cmF0aW9uIG9mIG1vcmUgbXV0ZWQgY29sb3JzIHdpdGggbGVzcyBlZmZlY3Qgb24gc2F0dXJhdGVkIGNvbG9ycy5cbiAgICAgKiBBIHZhbHVlIG9mIDAgaGFzIG5vIGVmZmVjdC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmlicmFuY2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHZpYnJhbmNlOiAwLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ3ZpYnJhbmNlJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlZpYnJhbmNlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlicmFuY2U9MF0gVmlicmFuY2UgdmFsdWUgZm9yIHRoZSBpbWFnZSAoYmV0d2VlbiAtMSBhbmQgMSlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBWaWJyYW5jZSBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLnZpYnJhbmNlID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGFkanVzdCA9IC10aGlzLnZpYnJhbmNlLCBpLCBtYXgsIGF2ZywgYW10O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgoZGF0YVtpXSwgZGF0YVtpICsgMV0sIGRhdGFbaSArIDJdKTtcbiAgICAgICAgYXZnID0gKGRhdGFbaV0gKyBkYXRhW2kgKyAxXSArIGRhdGFbaSArIDJdKSAvIDM7XG4gICAgICAgIGFtdCA9ICgoTWF0aC5hYnMobWF4IC0gYXZnKSAqIDIgLyAyNTUpICogYWRqdXN0KTtcbiAgICAgICAgZGF0YVtpXSArPSBtYXggIT09IGRhdGFbaV0gPyAobWF4IC0gZGF0YVtpXSkgKiBhbXQgOiAwO1xuICAgICAgICBkYXRhW2kgKyAxXSArPSBtYXggIT09IGRhdGFbaSArIDFdID8gKG1heCAtIGRhdGFbaSArIDFdKSAqIGFtdCA6IDA7XG4gICAgICAgIGRhdGFbaSArIDJdICs9IG1heCAhPT0gZGF0YVtpICsgMl0gPyAobWF4IC0gZGF0YVtpICsgMl0pICogYW10IDogMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVWaWJyYW5jZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1VmlicmFuY2UnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVWaWJyYW5jZSwgLXRoaXMudmlicmFuY2UpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuVmlicmFuY2V9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlZpYnJhbmNlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5WaWJyYW5jZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQmx1ciBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsdXJcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQmx1ciNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmx1cih7XG4gICAqICAgYmx1cjogMC41XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5CbHVyID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsdXIucHJvdG90eXBlICovIHtcblxuICAgIHR5cGU6ICdCbHVyJyxcblxuICAgIC8qXG4nZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtNyAqIHVEZWx0YSkqMC4wMDQ0Mjk5MTIxMDU1MTEzMjY1OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtNiAqIHVEZWx0YSkqMC4wMDg5NTc4MTIxMTc5NDsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTUgKiB1RGVsdGEpKjAuMDIxNTk2Mzg2NjA1MzsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTQgKiB1RGVsdGEpKjAuMDQ0MzY4MzMzODcxODsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTMgKiB1RGVsdGEpKjAuMDc3Njc0NDIxOTkzMzsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTIgKiB1RGVsdGEpKjAuMTE1ODc2NjIxMTA1OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtMSAqIHVEZWx0YSkqMC4xNDczMDgwNTYxMjE7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCAgICAgICAgICAgICAgKSowLjE1OTU3NjkxMjE2MTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgMSAqIHVEZWx0YSkqMC4xNDczMDgwNTYxMjE7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDIgKiB1RGVsdGEpKjAuMTE1ODc2NjIxMTA1OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAzICogdURlbHRhKSowLjA3NzY3NDQyMTk5MzM7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDQgKiB1RGVsdGEpKjAuMDQ0MzY4MzMzODcxODsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgNSAqIHVEZWx0YSkqMC4wMjE1OTYzODY2MDUzOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyA2ICogdURlbHRhKSowLjAwODk1NzgxMjExNzk0OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyA3ICogdURlbHRhKSowLjAwNDQyOTkxMjEwNTUxMTMyNjU7JyxcbiovXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWMyIHVEZWx0YTtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ2NvbnN0IGZsb2F0IG5TYW1wbGVzID0gMTUuMDtcXG4nICtcbiAgICAgICd2ZWMzIHYzb2Zmc2V0ID0gdmVjMygxMi45ODk4LCA3OC4yMzMsIDE1MS43MTgyKTtcXG4nICtcbiAgICAgICdmbG9hdCByYW5kb20odmVjMyBzY2FsZSkge1xcbicgK1xuICAgICAgICAvKiB1c2UgdGhlIGZyYWdtZW50IHBvc2l0aW9uIGZvciBhIGRpZmZlcmVudCBzZWVkIHBlci1waXhlbCAqL1xuICAgICAgICAncmV0dXJuIGZyYWN0KHNpbihkb3QoZ2xfRnJhZ0Nvb3JkLnh5eiwgc2NhbGUpKSAqIDQzNzU4LjU0NTMpO1xcbicgK1xuICAgICAgJ31cXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcbicgK1xuICAgICAgICAnZmxvYXQgdG90YWwgPSAwLjA7XFxuJyArXG4gICAgICAgICdmbG9hdCBvZmZzZXQgPSByYW5kb20odjNvZmZzZXQpO1xcbicgK1xuICAgICAgICAnZm9yIChmbG9hdCB0ID0gLW5TYW1wbGVzOyB0IDw9IG5TYW1wbGVzOyB0KyspIHtcXG4nICtcbiAgICAgICAgICAnZmxvYXQgcGVyY2VudCA9ICh0ICsgb2Zmc2V0IC0gMC41KSAvIG5TYW1wbGVzO1xcbicgK1xuICAgICAgICAgICdmbG9hdCB3ZWlnaHQgPSAxLjAgLSBhYnMocGVyY2VudCk7XFxuJyArXG4gICAgICAgICAgJ2NvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgdURlbHRhICogcGVyY2VudCkgKiB3ZWlnaHQ7XFxuJyArXG4gICAgICAgICAgJ3RvdGFsICs9IHdlaWdodDtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yIC8gdG90YWw7XFxuJyArXG4gICAgICAnfScsXG4gICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbiAgICAvKipcbiAgICAgKiBibHVyIHZhbHVlLCBpbiBwZXJjZW50YWdlIG9mIGltYWdlIGRpbWVuc2lvbnMuXG4gICAgICogc3BlY2lmaWMgdG8ga2VlcCB0aGUgaW1hZ2UgYmx1ciBjb25zdGFudCBhdCBkaWZmZXJlbnQgcmVzb2x1dGlvbnNcbiAgICAgKiByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBibHVyOiAwLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ2JsdXInLFxuXG4gICAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMud2ViZ2wpIHtcbiAgICAgICAgLy8gdGhpcyBhc3BlY3RSYXRpbyBpcyB1c2VkIHRvIGdpdmUgdGhlIHNhbWUgYmx1ciB0byB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbFxuICAgICAgICB0aGlzLmFzcGVjdFJhdGlvID0gb3B0aW9ucy5zb3VyY2VXaWR0aCAvIG9wdGlvbnMuc291cmNlSGVpZ2h0O1xuICAgICAgICBvcHRpb25zLnBhc3NlcysrO1xuICAgICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSB0cnVlO1xuICAgICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3N3YXBUZXh0dXJlcyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGx5VG8yZChvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAvLyBwYWludCBjYW52YXNFbCB3aXRoIGN1cnJlbnQgaW1hZ2UgZGF0YS5cbiAgICAgIC8vb3B0aW9ucy5jdHgucHV0SW1hZ2VEYXRhKG9wdGlvbnMuaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgIG9wdGlvbnMuaW1hZ2VEYXRhID0gdGhpcy5zaW1wbGVCbHVyKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBzaW1wbGVCbHVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgcmVzb3VyY2VzID0gb3B0aW9ucy5maWx0ZXJCYWNrZW5kLnJlc291cmNlcywgY2FudmFzMSwgY2FudmFzMixcbiAgICAgICAgICB3aWR0aCA9IG9wdGlvbnMuaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IG9wdGlvbnMuaW1hZ2VEYXRhLmhlaWdodDtcblxuICAgICAgaWYgKCFyZXNvdXJjZXMuYmx1ckxheWVyMSkge1xuICAgICAgICByZXNvdXJjZXMuYmx1ckxheWVyMSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgICAgcmVzb3VyY2VzLmJsdXJMYXllcjIgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB9XG4gICAgICBjYW52YXMxID0gcmVzb3VyY2VzLmJsdXJMYXllcjE7XG4gICAgICBjYW52YXMyID0gcmVzb3VyY2VzLmJsdXJMYXllcjI7XG4gICAgICBpZiAoY2FudmFzMS53aWR0aCAhPT0gd2lkdGggfHwgY2FudmFzMS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICBjYW52YXMyLndpZHRoID0gY2FudmFzMS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMyLmhlaWdodCA9IGNhbnZhczEuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuICAgICAgdmFyIGN0eDEgPSBjYW52YXMxLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgY3R4MiA9IGNhbnZhczIuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBuU2FtcGxlcyA9IDE1LFxuICAgICAgICAgIHJhbmRvbSwgcGVyY2VudCwgaiwgaSxcbiAgICAgICAgICBibHVyID0gdGhpcy5ibHVyICogMC4wNiAqIDAuNTtcblxuICAgICAgLy8gbG9hZCBmaXJzdCBjYW52YXNcbiAgICAgIGN0eDEucHV0SW1hZ2VEYXRhKG9wdGlvbnMuaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgIGN0eDIuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICBmb3IgKGkgPSAtblNhbXBsZXM7IGkgPD0gblNhbXBsZXM7IGkrKykge1xuICAgICAgICByYW5kb20gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgLyA0O1xuICAgICAgICBwZXJjZW50ID0gaSAvIG5TYW1wbGVzO1xuICAgICAgICBqID0gYmx1ciAqIHBlcmNlbnQgKiB3aWR0aCArIHJhbmRvbTtcbiAgICAgICAgY3R4Mi5nbG9iYWxBbHBoYSA9IDEgLSBNYXRoLmFicyhwZXJjZW50KTtcbiAgICAgICAgY3R4Mi5kcmF3SW1hZ2UoY2FudmFzMSwgaiwgcmFuZG9tKTtcbiAgICAgICAgY3R4MS5kcmF3SW1hZ2UoY2FudmFzMiwgMCwgMCk7XG4gICAgICAgIGN0eDIuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBjdHgyLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMyLndpZHRoLCBjYW52YXMyLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAtblNhbXBsZXM7IGkgPD0gblNhbXBsZXM7IGkrKykge1xuICAgICAgICByYW5kb20gPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgLyA0O1xuICAgICAgICBwZXJjZW50ID0gaSAvIG5TYW1wbGVzO1xuICAgICAgICBqID0gYmx1ciAqIHBlcmNlbnQgKiBoZWlnaHQgKyByYW5kb207XG4gICAgICAgIGN0eDIuZ2xvYmFsQWxwaGEgPSAxIC0gTWF0aC5hYnMocGVyY2VudCk7XG4gICAgICAgIGN0eDIuZHJhd0ltYWdlKGNhbnZhczEsIHJhbmRvbSwgaik7XG4gICAgICAgIGN0eDEuZHJhd0ltYWdlKGNhbnZhczIsIDAsIDApO1xuICAgICAgICBjdHgyLmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgY3R4Mi5jbGVhclJlY3QoMCwgMCwgY2FudmFzMi53aWR0aCwgY2FudmFzMi5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5jdHguZHJhd0ltYWdlKGNhbnZhczEsIDAsIDApO1xuICAgICAgdmFyIG5ld0ltYWdlRGF0YSA9IG9wdGlvbnMuY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMxLndpZHRoLCBjYW52YXMxLmhlaWdodCk7XG4gICAgICBjdHgxLmdsb2JhbEFscGhhID0gMTtcbiAgICAgIGN0eDEuY2xlYXJSZWN0KDAsIDAsIGNhbnZhczEud2lkdGgsIGNhbnZhczEuaGVpZ2h0KTtcbiAgICAgIHJldHVybiBuZXdJbWFnZURhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkZWx0YTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1RGVsdGEnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBkZWx0YSA9IHRoaXMuY2hvb3NlUmlnaHREZWx0YSgpO1xuICAgICAgZ2wudW5pZm9ybTJmdih1bmlmb3JtTG9jYXRpb25zLmRlbHRhLCBkZWx0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNob29zZSByaWdodCB2YWx1ZSBvZiBpbWFnZSBwZXJjZW50YWdlIHRvIGJsdXIgd2l0aFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gYSBudW1lcmljIGFycmF5IHdpdGggZGVsdGEgdmFsdWVzXG4gICAgICovXG4gICAgY2hvb3NlUmlnaHREZWx0YTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYmx1clNjYWxlID0gMSwgZGVsdGEgPSBbMCwgMF0sIGJsdXI7XG4gICAgICBpZiAodGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIGlmICh0aGlzLmFzcGVjdFJhdGlvID4gMSkge1xuICAgICAgICAgIC8vIGltYWdlIGlzIHdpZGUsIGkgd2FudCB0byBzaHJpbmsgcmFkaXVzIGhvcml6b250YWxcbiAgICAgICAgICBibHVyU2NhbGUgPSAxIC8gdGhpcy5hc3BlY3RSYXRpbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmFzcGVjdFJhdGlvIDwgMSkge1xuICAgICAgICAgIC8vIGltYWdlIGlzIHRhbGwsIGkgd2FudCB0byBzaHJpbmsgcmFkaXVzIHZlcnRpY2FsXG4gICAgICAgICAgYmx1clNjYWxlID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmx1ciA9IGJsdXJTY2FsZSAqIHRoaXMuYmx1ciAqIDAuMTI7XG4gICAgICBpZiAodGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIGRlbHRhWzBdID0gYmx1cjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkZWx0YVsxXSA9IGJsdXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVsdGE7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgSlNPTiBkZWZpbml0aW9uIG9mIGEgQmx1ckZpbHRlciBpbnRvIGEgY29uY3JldGUgaW5zdGFuY2UuXG4gICAqL1xuICBmaWx0ZXJzLkJsdXIuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEdhbW1hIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWFcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hKHtcbiAgICogICBnYW1tYTogWzEsIDAuNSwgMi4xXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkdhbW1hID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnR2FtbWEnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSB2ZWMzIHVHYW1tYTtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICd2ZWMzIGNvcnJlY3Rpb24gPSAoMS4wIC8gdUdhbW1hKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnIgPSBwb3coY29sb3IuciwgY29ycmVjdGlvbi5yKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmcgPSBwb3coY29sb3IuZywgY29ycmVjdGlvbi5nKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmIgPSBwb3coY29sb3IuYiwgY29ycmVjdGlvbi5iKTtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvci5hO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogR2FtbWEgYXJyYXkgdmFsdWUsIGZyb20gMC4wMSB0byAyLjIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ2FtbWFcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGdhbW1hOiBbMSwgMSwgMV0sXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSB0aGUgcHJvcGVydHkgdGhhdCBpcyB0aGUgZmlsdGVyIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYWluUGFyYW1ldGVyOiAnZ2FtbWEnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5nYW1tYSA9IFsxLCAxLCAxXTtcbiAgICAgIGZpbHRlcnMuQmFzZUZpbHRlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgR2FtbWEgb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLCBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgZ2FtbWEgPSB0aGlzLmdhbW1hLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBySW52ID0gMSAvIGdhbW1hWzBdLCBnSW52ID0gMSAvIGdhbW1hWzFdLFxuICAgICAgICAgIGJJbnYgPSAxIC8gZ2FtbWFbMl0sIGk7XG5cbiAgICAgIGlmICghdGhpcy5yVmFscykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5yVmFscyA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLmdWYWxzID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuYlZhbHMgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiAtIHByZS1jb21wdXRlIGEgbG9vay11cCB0YWJsZSBmb3IgZWFjaCBjb2xvciBjaGFubmVsXG4gICAgICAvLyBpbnN0ZWFkIG9mIHBlcmZvcm1pbmcgdGhlc2UgcG93IGNhbGxzIGZvciBlYWNoIHBpeGVsIGluIHRoZSBpbWFnZS5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IDI1NjsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuclZhbHNbaV0gPSBNYXRoLnBvdyhpIC8gMjU1LCBySW52KSAqIDI1NTtcbiAgICAgICAgdGhpcy5nVmFsc1tpXSA9IE1hdGgucG93KGkgLyAyNTUsIGdJbnYpICogMjU1O1xuICAgICAgICB0aGlzLmJWYWxzW2ldID0gTWF0aC5wb3coaSAvIDI1NSwgYkludikgKiAyNTU7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSB0aGlzLnJWYWxzW2RhdGFbaV1dO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IHRoaXMuZ1ZhbHNbZGF0YVtpICsgMV1dO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IHRoaXMuYlZhbHNbZGF0YVtpICsgMl1dO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUdhbW1hOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VHYW1tYScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTNmdih1bmlmb3JtTG9jYXRpb25zLnVHYW1tYSwgdGhpcy5nYW1tYSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWFcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBBIGNvbnRhaW5lciBjbGFzcyB0aGF0IGtub3dzIGhvdyB0byBhcHBseSBhIHNlcXVlbmNlIG9mIGZpbHRlcnMgdG8gYW4gaW5wdXQgaW1hZ2UuXG4gICAqL1xuICBmaWx0ZXJzLkNvbXBvc2VkID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbXBvc2VkLnByb3RvdHlwZSAqLyB7XG5cbiAgICB0eXBlOiAnQ29tcG9zZWQnLFxuXG4gICAgLyoqXG4gICAgICogQSBub24gc3BhcnNlIGFycmF5IG9mIGZpbHRlcnMgdG8gYXBwbHlcbiAgICAgKi9cbiAgICBzdWJGaWx0ZXJzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICAvLyBjcmVhdGUgYSBuZXcgYXJyYXkgaW5zdGVhZCBtdXRhdGluZyB0aGUgcHJvdG90eXBlIHdpdGggcHVzaFxuICAgICAgdGhpcy5zdWJGaWx0ZXJzID0gdGhpcy5zdWJGaWx0ZXJzLnNsaWNlKDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGlzIGNvbnRhaW5lcidzIGZpbHRlcnMgdG8gdGhlIGlucHV0IGltYWdlIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYXNzZXMgVGhlIG51bWJlciBvZiBmaWx0ZXJzIHJlbWFpbmluZyB0byBiZSBhcHBsaWVkLlxuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMucGFzc2VzICs9IHRoaXMuc3ViRmlsdGVycy5sZW5ndGggLSAxO1xuICAgICAgdGhpcy5zdWJGaWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgIGZpbHRlci5hcHBseVRvKG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGlzIGZpbHRlciBpbnRvIEpTT04uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmaWx0ZXIuXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgc3ViRmlsdGVyczogdGhpcy5zdWJGaWx0ZXJzLm1hcChmdW5jdGlvbihmaWx0ZXIpIHsgcmV0dXJuIGZpbHRlci50b09iamVjdCgpOyB9KSxcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuc3ViRmlsdGVycy5zb21lKGZ1bmN0aW9uKGZpbHRlcikgeyByZXR1cm4gIWZpbHRlci5pc05ldXRyYWxTdGF0ZSgpOyB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhIEpTT04gZGVmaW5pdGlvbiBvZiBhIENvbXBvc2VkRmlsdGVyIGludG8gYSBjb25jcmV0ZSBpbnN0YW5jZS5cbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbXBvc2VkLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpbHRlcnMgPSBvYmplY3Quc3ViRmlsdGVycyB8fCBbXSxcbiAgICAgICAgc3ViRmlsdGVycyA9IGZpbHRlcnMubWFwKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgZmFicmljLkltYWdlLmZpbHRlcnNbZmlsdGVyLnR5cGVdKGZpbHRlcik7XG4gICAgICAgIH0pLFxuICAgICAgICBpbnN0YW5jZSA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db21wb3NlZCh7IHN1YkZpbHRlcnM6IHN1YkZpbHRlcnMgfSk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBIdWVSb3RhdGlvbiBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbih7XG4gICAqICAgcm90YXRpb246IC0wLjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5IdWVSb3RhdGlvbiA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQ29sb3JNYXRyaXgsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb24ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdIdWVSb3RhdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBIdWVSb3RhdGlvbiB2YWx1ZSwgZnJvbSAtMSB0byAxLlxuICAgICAqIHRoZSB1bml0IGlzIHJhZGlhbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbXlQYXJhbWV0ZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJvdGF0aW9uOiAwLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgdGhlIHByb3BlcnR5IHRoYXQgaXMgdGhlIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWFpblBhcmFtZXRlcjogJ3JvdGF0aW9uJyxcblxuICAgIGNhbGN1bGF0ZU1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmFkID0gdGhpcy5yb3RhdGlvbiAqIE1hdGguUEksIGNvcyA9IGZhYnJpYy51dGlsLmNvcyhyYWQpLCBzaW4gPSBmYWJyaWMudXRpbC5zaW4ocmFkKSxcbiAgICAgICAgICBhVGhpcmQgPSAxIC8gMywgYVRoaXJkU3F0U2luID0gTWF0aC5zcXJ0KGFUaGlyZCkgKiBzaW4sIE9uZU1pbnVzQ29zID0gMSAtIGNvcztcbiAgICAgIHRoaXMubWF0cml4ID0gW1xuICAgICAgICAxLCAwLCAwLCAwLCAwLFxuICAgICAgICAwLCAxLCAwLCAwLCAwLFxuICAgICAgICAwLCAwLCAxLCAwLCAwLFxuICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICBdO1xuICAgICAgdGhpcy5tYXRyaXhbMF0gPSBjb3MgKyBPbmVNaW51c0NvcyAvIDM7XG4gICAgICB0aGlzLm1hdHJpeFsxXSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zIC0gYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbMl0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyArIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzVdID0gYVRoaXJkICogT25lTWludXNDb3MgKyBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFs2XSA9IGNvcyArIGFUaGlyZCAqIE9uZU1pbnVzQ29zO1xuICAgICAgdGhpcy5tYXRyaXhbN10gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyAtIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzEwXSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zIC0gYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbMTFdID0gYVRoaXJkICogT25lTWludXNDb3MgKyBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFsxMl0gPSBjb3MgKyBhVGhpcmQgKiBPbmVNaW51c0NvcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSHVlUm90YXRpb24gaXNOZXV0cmFsU3RhdGUgaW1wbGVtZW50YXRpb25cbiAgICAgKiBVc2VkIG9ubHkgaW4gaW1hZ2UgYXBwbHlGaWx0ZXJzIHRvIGRpc2NhcmQgZmlsdGVycyB0aGF0IHdpbGwgbm90IGhhdmUgYW4gZWZmZWN0XG4gICAgICogb24gdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiovXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRlTWF0cml4KCk7XG4gICAgICByZXR1cm4gZmlsdGVycy5CYXNlRmlsdGVyLnByb3RvdHlwZS5pc05ldXRyYWxTdGF0ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGlzIGZpbHRlciB0byB0aGUgaW5wdXQgaW1hZ2UgZGF0YSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byB1c2UgV2ViR0wgb3IgQ2FudmFzMkQgYmFzZWQgb24gdGhlIG9wdGlvbnMud2ViZ2wgZmxhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMud2ViZ2wgV2hldGhlciB0byB1c2Ugd2ViZ2wgdG8gcmVuZGVyIHRoZSBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMuc291cmNlVGV4dHVyZSBUaGUgdGV4dHVyZSBzZXR1cCBhcyB0aGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZU1hdHJpeCgpO1xuICAgICAgZmlsdGVycy5CYXNlRmlsdGVyLnByb3RvdHlwZS5hcHBseVRvLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9ufSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvblxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb24uZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgaWYgKGZhYnJpYy5UZXh0KSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5UZXh0IGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBhZGRpdGlvbmFsUHJvcHMgPVxuICAgICgnZm9udEZhbWlseSBmb250V2VpZ2h0IGZvbnRTaXplIHRleHQgdW5kZXJsaW5lIG92ZXJsaW5lIGxpbmV0aHJvdWdoJyArXG4gICAgJyB0ZXh0QWxpZ24gZm9udFN0eWxlIGxpbmVIZWlnaHQgdGV4dEJhY2tncm91bmRDb2xvciBjaGFyU3BhY2luZyBzdHlsZXMnICtcbiAgICAnIGRpcmVjdGlvbiBwYXRoIHBhdGhTdGFydE9mZnNldCBwYXRoU2lkZSBwYXRoQWxpZ24nKS5zcGxpdCgnICcpO1xuXG4gIC8qKlxuICAgKiBUZXh0IGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuVGV4dFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI3RleHR9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UZXh0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuVGV4dCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlRleHQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgd2hpY2ggd2hlbiBzZXQgY2F1c2Ugb2JqZWN0IHRvIGNoYW5nZSBkaW1lbnNpb25zXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaW1lbnNpb25BZmZlY3RpbmdQcm9wczogW1xuICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICdmb250U3R5bGUnLFxuICAgICAgJ2xpbmVIZWlnaHQnLFxuICAgICAgJ3RleHQnLFxuICAgICAgJ2NoYXJTcGFjaW5nJyxcbiAgICAgICd0ZXh0QWxpZ24nLFxuICAgICAgJ3N0eWxlcycsXG4gICAgICAncGF0aCcsXG4gICAgICAncGF0aFN0YXJ0T2Zmc2V0JyxcbiAgICAgICdwYXRoU2lkZScsXG4gICAgICAncGF0aEFsaWduJ1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZU5ld2xpbmU6IC9cXHI/XFxuLyxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaWx0ZXIgZm9yIHdoaXRlc3BhY2VzIHRoYXQgaXMgbm90IGEgbmV3IGxpbmUuXG4gICAgICogTW9zdGx5IHVzZWQgd2hlbiB0ZXh0IGlzICdqdXN0aWZ5JyBhbGlnbmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlU3BhY2VzQW5kVGFiczogL1sgXFx0XFxyXS9nLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBmb3Igd2hpdGVzcGFjZSB0aGF0IGlzIG5vdCBhIG5ldyBsaW5lLlxuICAgICAqIE1vc3RseSB1c2VkIHdoZW4gdGV4dCBpcyAnanVzdGlmeScgYWxpZ25lZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZVNwYWNlQW5kVGFiOiAvWyBcXHRcXHJdLyxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaWx0ZXIgY29uc2VjdXRpdmUgZ3JvdXBzIG9mIG5vbiBzcGFjZXMuXG4gICAgICogTW9zdGx5IHVzZWQgd2hlbiB0ZXh0IGlzICdqdXN0aWZ5JyBhbGlnbmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlV29yZHM6IC9cXFMrL2csXG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogICAgICAgICAgICAgICAgICd0ZXh0JyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgc2l6ZSAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udFNpemU6ICAgICAgICAgICAgIDQwLFxuXG4gICAgLyoqXG4gICAgICogRm9udCB3ZWlnaHQgKGUuZy4gYm9sZCwgbm9ybWFsLCA0MDAsIDYwMCwgODAwKVxuICAgICAqIEB0eXBlIHsoTnVtYmVyfFN0cmluZyl9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmb250V2VpZ2h0OiAgICAgICAgICAgJ25vcm1hbCcsXG5cbiAgICAvKipcbiAgICAgKiBGb250IGZhbWlseVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udEZhbWlseTogICAgICAgICAgICdUaW1lcyBOZXcgUm9tYW4nLFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBkZWNvcmF0aW9uIHVuZGVybGluZS5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB1bmRlcmxpbmU6ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBkZWNvcmF0aW9uIG92ZXJsaW5lLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsaW5lOiAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRleHQgZGVjb3JhdGlvbiBsaW5ldGhyb3VnaC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsaW5ldGhyb3VnaDogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGFsaWdubWVudC4gUG9zc2libGUgdmFsdWVzOiBcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiLCBcImp1c3RpZnlcIixcbiAgICAgKiBcImp1c3RpZnktbGVmdFwiLCBcImp1c3RpZnktY2VudGVyXCIgb3IgXCJqdXN0aWZ5LXJpZ2h0XCIuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0ZXh0QWxpZ246ICAgICAgICAgICAgJ2xlZnQnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBzdHlsZSAuIFBvc3NpYmxlIHZhbHVlczogXCJcIiwgXCJub3JtYWxcIiwgXCJpdGFsaWNcIiBvciBcIm9ibGlxdWVcIi5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRTdHlsZTogICAgICAgICAgICAnbm9ybWFsJyxcblxuICAgIC8qKlxuICAgICAqIExpbmUgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsaW5lSGVpZ2h0OiAgICAgICAgICAgMS4xNixcblxuICAgIC8qKlxuICAgICAqIFN1cGVyc2NyaXB0IHNjaGVtYSBvYmplY3QgKG1pbmltdW0gb3ZlcmxhcClcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3VwZXJzY3JpcHQ6IHtcbiAgICAgIHNpemU6ICAgICAgMC42MCwgLy8gZm9udFNpemUgZmFjdG9yXG4gICAgICBiYXNlbGluZTogLTAuMzUgIC8vIGJhc2VsaW5lLXNoaWZ0IGZhY3RvciAodXB3YXJkcylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaXB0IHNjaGVtYSBvYmplY3QgKG1pbmltdW0gb3ZlcmxhcClcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Vic2NyaXB0OiB7XG4gICAgICBzaXplOiAgICAgIDAuNjAsIC8vIGZvbnRTaXplIGZhY3RvclxuICAgICAgYmFzZWxpbmU6ICAwLjExICAvLyBiYXNlbGluZS1zaGlmdCBmYWN0b3IgKGRvd253YXJkcylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBvZiB0ZXh0IGxpbmVzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0ZXh0QmFja2dyb3VuZENvbG9yOiAgJycsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZlxuICAgICAqIHN0YXRlIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkICh7QGxpbmsgZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWR9KVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzLmNvbmNhdChhZGRpdGlvbmFsUHJvcHMpLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgY2FjaGUgbmVlZHMgcmVmcmVzaFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KGFkZGl0aW9uYWxQcm9wcyksXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRlZmluZWQsIGFuIG9iamVjdCBpcyByZW5kZXJlZCB2aWEgc3Ryb2tlIGFuZCB0aGlzIHByb3BlcnR5IHNwZWNpZmllcyBpdHMgY29sb3IuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSB3YXMgbmFtZWQgXCJzdHJva2VTdHlsZVwiIHVudGlsIHYxLjEuNlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlOiAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgb2JqZWN0IHJlcHJlc2VudGluZyBzaGFkb3cgb2YgdGhpcyBzaGFwZS5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHdhcyBuYW1lZCBcInRleHRTaGFkb3dcIiAoU3RyaW5nKSB1bnRpbCB2MS4yLjExXG4gICAgICogQHR5cGUgZmFicmljLlNoYWRvd1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2hhZG93OiAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBmYWJyaWMuUGF0aCB0aGF0IHRoZSB0ZXh0IHNob3VsZCBmb2xsb3cuXG4gICAgICogc2luY2UgNC42LjAgdGhlIHBhdGggd2lsbCBiZSBkcmF3biBhdXRvbWF0aWNhbGx5LlxuICAgICAqIGlmIHlvdSB3YW50IHRvIG1ha2UgdGhlIHBhdGggdmlzaWJsZSwgZ2l2ZSBpdCBhIHN0cm9rZSBhbmQgc3Ryb2tlV2lkdGggb3IgZmlsbCB2YWx1ZVxuICAgICAqIGlmIHlvdSB3YW50IGl0IHRvIGJlIGhpZGRlbiwgYXNzaWduIHZpc2libGUgPSBmYWxzZSB0byB0aGUgcGF0aC5cbiAgICAgKiBUaGlzIGZlYXR1cmUgaXMgaW4gQkVUQSwgYW5kIFNWRyBpbXBvcnQvZXhwb3J0IGlzIG5vdCB5ZXQgc3VwcG9ydGVkLlxuICAgICAqIEB0eXBlIGZhYnJpYy5QYXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgdGV4dFBhdGggPSBuZXcgZmFicmljLlRleHQoJ1RleHQgb24gYSBwYXRoJywge1xuICAgICAqICAgICB0b3A6IDE1MCxcbiAgICAgKiAgICAgbGVmdDogMTUwLFxuICAgICAqICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAqICAgICBjaGFyU3BhY2luZzogLTUwLFxuICAgICAqICAgICBwYXRoOiBuZXcgZmFicmljLlBhdGgoJ00gMCAwIEMgNTAgLTEwMCAxNTAgLTEwMCAyMDAgMCcsIHtcbiAgICAgKiAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAqICAgICAgICAgdmlzaWJsZTogZmFsc2VcbiAgICAgKiAgICAgfSksXG4gICAgICogICAgIHBhdGhTaWRlOiAnbGVmdCcsXG4gICAgICogICAgIHBhdGhTdGFydE9mZnNldDogMFxuICAgICAqIH0pO1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGF0aDogICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogT2Zmc2V0IGFtb3VudCBmb3IgdGV4dCBwYXRoIHN0YXJ0aW5nIHBvc2l0aW9uXG4gICAgICogT25seSB1c2VkIHdoZW4gdGV4dCBoYXMgYSBwYXRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYXRoU3RhcnRPZmZzZXQ6ICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIFdoaWNoIHNpZGUgb2YgdGhlIHBhdGggdGhlIHRleHQgc2hvdWxkIGJlIGRyYXduIG9uLlxuICAgICAqIE9ubHkgdXNlZCB3aGVuIHRleHQgaGFzIGEgcGF0aFxuICAgICAqIEB0eXBlIHtTdHJpbmd9ICdsZWZ0fHJpZ2h0J1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGF0aFNpZGU6ICAgICAgICAgICAgICAgJ2xlZnQnLFxuXG4gICAgLyoqXG4gICAgICogSG93IHRleHQgaXMgYWxpZ25lZCB0byB0aGUgcGF0aC4gVGhpcyBwcm9wZXJ0eSBkZXRlcm1pbmVzXG4gICAgICogdGhlIHBlcnBlbmRpY3VsYXIgcG9zaXRpb24gb2YgZWFjaCBjaGFyYWN0ZXIgcmVsYXRpdmUgdG8gdGhlIHBhdGguXG4gICAgICogKG9uZSBvZiBcImJhc2VsaW5lXCIsIFwiY2VudGVyXCIsIFwiYXNjZW5kZXJcIiwgXCJkZXNjZW5kZXJcIilcbiAgICAgKiBUaGlzIGZlYXR1cmUgaXMgaW4gQkVUQSwgYW5kIGl0cyBiZWhhdmlvciBtYXkgY2hhbmdlXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYXRoQWxpZ246ICAgICAgICAgICAgICAgJ2Jhc2VsaW5lJyxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZvbnRTaXplRnJhY3Rpb246IDAuMjIyLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvZmZzZXRzOiB7XG4gICAgICB1bmRlcmxpbmU6IDAuMTAsXG4gICAgICBsaW5ldGhyb3VnaDogLTAuMzE1LFxuICAgICAgb3ZlcmxpbmU6IC0wLjg4XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRleHQgTGluZSBwcm9wb3J0aW9uIHRvIGZvbnQgU2l6ZSAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgX2ZvbnRTaXplTXVsdDogICAgICAgICAgICAgMS4xMyxcblxuICAgIC8qKlxuICAgICAqIGFkZGl0aW9uYWwgc3BhY2UgYmV0d2VlbiBjaGFyYWN0ZXJzXG4gICAgICogZXhwcmVzc2VkIGluIHRob3VzYW5kcyBvZiBlbSB1bml0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjaGFyU3BhY2luZzogICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBjb250YWluaW5nIGNoYXJhY3RlciBzdHlsZXMgLSB0b3AtbGV2ZWwgcHJvcGVydGllcyAtPiBsaW5lIG51bWJlcnMsXG4gICAgICogMm5kLWxldmVsIHByb3BlcnRpZXMgLSBjaGFyYWN0ZXIgbnVtYmVyc1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3R5bGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIGEgY29udGV4dCB0byBtZWFzdXJlIHRleHQgY2hhciBvciBjb3VwbGUgb2YgY2hhcnNcbiAgICAgKiB0aGUgY2FjaGVDb250ZXh0IG9mIHRoZSBjYW52YXMgd2lsbCBiZSB1c2VkIG9yIGEgZnJlc2hseSBjcmVhdGVkIG9uZSBpZiB0aGUgb2JqZWN0IGlzIG5vdCBvbiBjYW52YXNcbiAgICAgKiBvbmNlIGNyZWF0ZWQgaXQgd2lsbCBiZSByZWZlcmVuY2VkIG9uIGZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dCB0byBhdm9pZCBjcmVhdGluZyBhIGNhbnZhcyBmb3IgZXZlcnlcbiAgICAgKiB0ZXh0IG9iamVjdCBjcmVhdGVkLlxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBfbWVhc3VyaW5nQ29udGV4dDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEJhc2VsaW5lIHNoaWZ0LCBzdHlsZXMgb25seSwga2VlcCBhdCAwIGZvciB0aGUgbWFpbiB0ZXh0IG9iamVjdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBkZWx0YVk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBXQVJOSU5HOiBFWFBFUklNRU5UQUwuIE5PVCBTVVBQT1JURUQgWUVUXG4gICAgICogZGV0ZXJtaW5lIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHRleHQuXG4gICAgICogVGhpcyBoYXMgdG8gYmUgc2V0IG1hbnVhbGx5IHRvZ2V0aGVyIHdpdGggdGV4dEFsaWduIGFuZCBvcmlnaW5YIGZvciBwcm9wZXJcbiAgICAgKiBleHBlcmllbmNlLlxuICAgICAqIHNvbWUgaW50ZXJlc3RpbmcgbGluayBmb3IgdGhlIGZ1dHVyZVxuICAgICAqIGh0dHBzOi8vd3d3LnczLm9yZy9JbnRlcm5hdGlvbmFsL3F1ZXN0aW9ucy9xYS1iaWRpLXVuaWNvZGUtY29udHJvbHNcbiAgICAgKiBAc2luY2UgNC41LjBcbiAgICAgKiBAdHlwZSB7U3RyaW5nfSAnbHRyfHJ0bCdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGRpcmVjdGlvbjogJ2x0cicsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBwcm9wZXJ0aWVzIHRoYXQgZGVmaW5lIGEgc3R5bGUgdW5pdCAob2YgJ3N0eWxlcycpLlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIF9zdHlsZVByb3BlcnRpZXM6IFtcbiAgICAgICdzdHJva2UnLFxuICAgICAgJ3N0cm9rZVdpZHRoJyxcbiAgICAgICdmaWxsJyxcbiAgICAgICdmb250RmFtaWx5JyxcbiAgICAgICdmb250U2l6ZScsXG4gICAgICAnZm9udFdlaWdodCcsXG4gICAgICAnZm9udFN0eWxlJyxcbiAgICAgICd1bmRlcmxpbmUnLFxuICAgICAgJ292ZXJsaW5lJyxcbiAgICAgICdsaW5ldGhyb3VnaCcsXG4gICAgICAnZGVsdGFZJyxcbiAgICAgICd0ZXh0QmFja2dyb3VuZENvbG9yJyxcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogY29udGFpbnMgY2hhcmFjdGVycyBib3VuZGluZyBib3hlc1xuICAgICAqL1xuICAgIF9fY2hhckJvdW5kczogW10sXG5cbiAgICAvKipcbiAgICAgKiB1c2UgdGhpcyBzaXplIHdoZW4gbWVhc3VyaW5nIHRleHQuIFRvIGF2b2lkIElFMTEgcm91bmRpbmcgZXJyb3JzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ0FDSEVfRk9OVF9TSVpFOiA0MDAsXG5cbiAgICAvKipcbiAgICAgKiBjb250YWlucyB0aGUgbWluIHRleHQgd2lkdGggdG8gYXZvaWQgZ2V0dGluZyAwXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIE1JTl9URVhUX1dJRFRIOiAyLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc3R5bGVzID0gb3B0aW9ucyA/IChvcHRpb25zLnN0eWxlcyB8fCB7IH0pIDogeyB9O1xuICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgIHRoaXMuX19za2lwRGltZW5zaW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICAgIHRoaXMuc2V0UGF0aEluZm8oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19za2lwRGltZW5zaW9uID0gZmFsc2U7XG4gICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5zZXR1cFN0YXRlKHsgcHJvcGVydHlTZXQ6ICdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0ZXh0IGhhcyBhIHBhdGgsIGl0IHdpbGwgYWRkIHRoZSBleHRyYSBpbmZvcm1hdGlvbiBuZWVkZWRcbiAgICAgKiBmb3IgcGF0aCBhbmQgdGV4dCBjYWxjdWxhdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNldFBhdGhJbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgcGF0aC5zZWdtZW50c0luZm8gPSBmYWJyaWMudXRpbC5nZXRQYXRoU2VnbWVudHNJbmZvKHBhdGgucGF0aCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGNvbnRleHQgZm9yIG1lYXN1cmVtZW50IG9mIHRleHQgc3RyaW5nLlxuICAgICAqIGlmIGNyZWF0ZWQgaXQgZ2V0cyBzdG9yZWQgZm9yIHJldXNlXG4gICAgICogdGhpcyBpcyBmb3IgaW50ZXJuYWwgdXNlLCBwbGVhc2UgZG8gbm90IHVzZSBpdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGV4dCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBnZXRNZWFzdXJpbmdDb250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGlmIHdlIGRpZCBub3QgcmV0dXJuIHdlIGhhdmUgdG8gbWVhc3VyZSBzb21ldGhpbmcuXG4gICAgICBpZiAoIWZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dCkge1xuICAgICAgICBmYWJyaWMuX21lYXN1cmluZ0NvbnRleHQgPSB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jb250ZXh0Q2FjaGUgfHxcbiAgICAgICAgICBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWJyaWMuX21lYXN1cmluZ0NvbnRleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogRGl2aWRlcyB0ZXh0IGludG8gbGluZXMgb2YgdGV4dCBhbmQgbGluZXMgb2YgZ3JhcGhlbWVzLlxuICAgICAqL1xuICAgIF9zcGxpdFRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5ld0xpbmVzID0gdGhpcy5fc3BsaXRUZXh0SW50b0xpbmVzKHRoaXMudGV4dCk7XG4gICAgICB0aGlzLnRleHRMaW5lcyA9IG5ld0xpbmVzLmxpbmVzO1xuICAgICAgdGhpcy5fdGV4dExpbmVzID0gbmV3TGluZXMuZ3JhcGhlbWVMaW5lcztcbiAgICAgIHRoaXMuX3Vud3JhcHBlZFRleHRMaW5lcyA9IG5ld0xpbmVzLl91bndyYXBwZWRMaW5lcztcbiAgICAgIHRoaXMuX3RleHQgPSBuZXdMaW5lcy5ncmFwaGVtZVRleHQ7XG4gICAgICByZXR1cm4gbmV3TGluZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgb3IgdXBkYXRlIHRleHQgZGltZW5zaW9ucy5cbiAgICAgKiBVcGRhdGVzIHRoaXMud2lkdGggYW5kIHRoaXMuaGVpZ2h0IHdpdGggdGhlIHByb3BlciB2YWx1ZXMuXG4gICAgICogRG9lcyBub3QgcmV0dXJuIGRpbWVuc2lvbnMuXG4gICAgICovXG4gICAgaW5pdERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX19za2lwRGltZW5zaW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NwbGl0VGV4dCgpO1xuICAgICAgdGhpcy5fY2xlYXJDYWNoZSgpO1xuICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5wYXRoLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMucGF0aC5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuY2FsY1RleHRXaWR0aCgpIHx8IHRoaXMuY3Vyc29yV2lkdGggfHwgdGhpcy5NSU5fVEVYVF9XSURUSDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbGNUZXh0SGVpZ2h0KCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSkge1xuICAgICAgICAvLyBvbmNlIHRleHQgaXMgbWVhc3VyZWQgd2UgbmVlZCB0byBtYWtlIHNwYWNlIGZhdHRlciB0byBtYWtlIGp1c3RpZmllZCB0ZXh0LlxuICAgICAgICB0aGlzLmVubGFyZ2VTcGFjZXMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmxhcmdlIHNwYWNlIGJveGVzIGFuZCBzaGlmdCB0aGUgb3RoZXJzXG4gICAgICovXG4gICAgZW5sYXJnZVNwYWNlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGlmZlNwYWNlLCBjdXJyZW50TGluZVdpZHRoLCBudW1iZXJPZlNwYWNlcywgYWNjdW11bGF0ZWRTcGFjZSwgbGluZSwgY2hhckJvdW5kLCBzcGFjZXM7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRBbGlnbiAhPT0gJ2p1c3RpZnknICYmIChpID09PSBsZW4gLSAxIHx8IHRoaXMuaXNFbmRPZldyYXBwaW5nKGkpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGFjY3VtdWxhdGVkU3BhY2UgPSAwO1xuICAgICAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldO1xuICAgICAgICBjdXJyZW50TGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoaSk7XG4gICAgICAgIGlmIChjdXJyZW50TGluZVdpZHRoIDwgdGhpcy53aWR0aCAmJiAoc3BhY2VzID0gdGhpcy50ZXh0TGluZXNbaV0ubWF0Y2godGhpcy5fcmVTcGFjZXNBbmRUYWJzKSkpIHtcbiAgICAgICAgICBudW1iZXJPZlNwYWNlcyA9IHNwYWNlcy5sZW5ndGg7XG4gICAgICAgICAgZGlmZlNwYWNlID0gKHRoaXMud2lkdGggLSBjdXJyZW50TGluZVdpZHRoKSAvIG51bWJlck9mU3BhY2VzO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPD0gamxlbjsgaisrKSB7XG4gICAgICAgICAgICBjaGFyQm91bmQgPSB0aGlzLl9fY2hhckJvdW5kc1tpXVtqXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZVNwYWNlQW5kVGFiLnRlc3QobGluZVtqXSkpIHtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLndpZHRoICs9IGRpZmZTcGFjZTtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLmtlcm5lZFdpZHRoICs9IGRpZmZTcGFjZTtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLmxlZnQgKz0gYWNjdW11bGF0ZWRTcGFjZTtcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZWRTcGFjZSArPSBkaWZmU3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY2hhckJvdW5kLmxlZnQgKz0gYWNjdW11bGF0ZWRTcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIHRoZSB0ZXh0IGxpbmUgaXMgZW5kZWQgd2l0aCBhbiBoYXJkIGJyZWFrXG4gICAgICogdGV4dCBhbmQgaXRleHQgZG8gbm90IGhhdmUgd3JhcHBpbmcsIHJldHVybiBmYWxzZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbmRPZldyYXBwaW5nOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHJldHVybiBsaW5lSW5kZXggPT09IHRoaXMuX3RleHRMaW5lcy5sZW5ndGggLSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgYSBsaW5lIGhhcyBhIGxpbmVicmVhayBhbmQgc28gd2UgbmVlZCB0byBhY2NvdW50IGZvciBpdCB3aGVuIG1vdmluZ1xuICAgICAqIGFuZCBjb3VudGluZyBzdHlsZS5cbiAgICAgKiBJdCByZXR1cm4gYWx3YXlzIGZvciB0ZXh0IGFuZCBJdGV4dC5cbiAgICAgKiBAcmV0dXJuIE51bWJlclxuICAgICAqL1xuICAgIG1pc3NpbmdOZXdsaW5lT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRleHQgb2JqZWN0XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5UZXh0ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgK1xuICAgICAgICAnKTogeyBcInRleHRcIjogXCInICsgdGhpcy50ZXh0ICsgJ1wiLCBcImZvbnRGYW1pbHlcIjogXCInICsgdGhpcy5mb250RmFtaWx5ICsgJ1wiIH0+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkaW1lbnNpb24gYW5kIHRoZSB6b29tIGxldmVsIG5lZWRlZCB0byBjcmVhdGUgYSBjYWNoZSBjYW52YXNcbiAgICAgKiBiaWcgZW5vdWdoIHRvIGhvc3QgdGhlIG9iamVjdCB0byBiZSBjYWNoZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltLnggd2lkdGggb2Ygb2JqZWN0IHRvIGJlIGNhY2hlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW0ueSBoZWlnaHQgb2Ygb2JqZWN0IHRvIGJlIGNhY2hlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0ud2lkdGggd2lkdGggb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVggem9vbVggem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21ZIHpvb21ZIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICovXG4gICAgX2dldENhY2hlQ2FudmFzRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGltcyA9IHRoaXMuY2FsbFN1cGVyKCdfZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zJyk7XG4gICAgICB2YXIgZm9udFNpemUgPSB0aGlzLmZvbnRTaXplO1xuICAgICAgZGltcy53aWR0aCArPSBmb250U2l6ZSAqIGRpbXMuem9vbVg7XG4gICAgICBkaW1zLmhlaWdodCArPSBmb250U2l6ZSAqIGRpbXMuem9vbVk7XG4gICAgICByZXR1cm4gZGltcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgIHBhdGggJiYgIXBhdGguaXNOb3RWaXNpYmxlKCkgJiYgcGF0aC5fcmVuZGVyKGN0eCk7XG4gICAgICB0aGlzLl9zZXRUZXh0U3R5bGVzKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0TGluZXNCYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0RGVjb3JhdGlvbihjdHgsICd1bmRlcmxpbmUnKTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHQoY3R4KTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHREZWNvcmF0aW9uKGN0eCwgJ292ZXJsaW5lJyk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0RGVjb3JhdGlvbihjdHgsICdsaW5ldGhyb3VnaCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ID09PSAnc3Ryb2tlJykge1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0U3Ryb2tlKGN0eCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRGaWxsKGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dEZpbGwoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dFN0cm9rZShjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZvbnQgcGFyYW1ldGVyIG9mIHRoZSBjb250ZXh0IHdpdGggdGhlIG9iamVjdCBwcm9wZXJ0aWVzIG9yIHdpdGggY2hhclN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjaGFyU3R5bGVdIG9iamVjdCB3aXRoIGZvbnQgc3R5bGUgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhclN0eWxlLmZvbnRGYW1pbHldIEZvbnQgRmFtaWx5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjaGFyU3R5bGUuZm9udFNpemVdIEZvbnQgc2l6ZSBpbiBwaXhlbHMuICggd2l0aG91dCBweCBzdWZmaXggKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhclN0eWxlLmZvbnRXZWlnaHRdIEZvbnQgd2VpZ2h0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjaGFyU3R5bGUuZm9udFN0eWxlXSBGb250IHN0eWxlIChpdGFsaWN8bm9ybWFsKVxuICAgICAqL1xuICAgIF9zZXRUZXh0U3R5bGVzOiBmdW5jdGlvbihjdHgsIGNoYXJTdHlsZSwgZm9yTWVhc3VyaW5nKSB7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWNhbCc7XG4gICAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wYXRoQWxpZ24pIHtcbiAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYXNjZW5kZXInOlxuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGVzY2VuZGVyJzpcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHguZm9udCA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbihjaGFyU3R5bGUsIGZvck1lYXN1cmluZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSBhbmQgcmV0dXJuIHRoZSB0ZXh0IFdpZHRoIG1lYXN1cmluZyBlYWNoIGxpbmUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBNYXhpbXVtIHdpZHRoIG9mIGZhYnJpYy5UZXh0IG9iamVjdFxuICAgICAqL1xuICAgIGNhbGNUZXh0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1heFdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoMCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnRMaW5lV2lkdGggPSB0aGlzLmdldExpbmVXaWR0aChpKTtcbiAgICAgICAgaWYgKGN1cnJlbnRMaW5lV2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgIG1heFdpZHRoID0gY3VycmVudExpbmVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1heFdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTWV0aG9kIG5hbWUgKFwiZmlsbFRleHRcIiBvciBcInN0cm9rZVRleHRcIilcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmUgVGV4dCB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IHBvc2l0aW9uIG9mIHRleHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBwb3NpdGlvbiBvZiB0ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmUgaW4gYSB0ZXh0XG4gICAgICovXG4gICAgX3JlbmRlclRleHRMaW5lOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZSwgbGVmdCwgdG9wLCBsaW5lSW5kZXgpIHtcbiAgICAgIHRoaXMuX3JlbmRlckNoYXJzKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHRleHQgYmFja2dyb3VuZCBmb3IgbGluZXMsIHRha2luZyBjYXJlIG9mIHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHRMaW5lc0JhY2tncm91bmQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IgJiYgIXRoaXMuc3R5bGVIYXMoJ3RleHRCYWNrZ3JvdW5kQ29sb3InKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaGVpZ2h0T2ZMaW5lLFxuICAgICAgICAgIGxpbmVMZWZ0T2Zmc2V0LCBvcmlnaW5hbEZpbGwgPSBjdHguZmlsbFN0eWxlLFxuICAgICAgICAgIGxpbmUsIGxhc3RDb2xvcixcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGVmdE9mZnNldCgpLFxuICAgICAgICAgIGxpbmVUb3BPZmZzZXQgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKSxcbiAgICAgICAgICBib3hTdGFydCA9IDAsIGJveFdpZHRoID0gMCwgY2hhckJveCwgY3VycmVudENvbG9yLCBwYXRoID0gdGhpcy5wYXRoLFxuICAgICAgICAgIGRyYXdTdGFydDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgICAgaWYgKCF0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IgJiYgIXRoaXMuc3R5bGVIYXMoJ3RleHRCYWNrZ3JvdW5kQ29sb3InLCBpKSkge1xuICAgICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbaV07XG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgYm94U3RhcnQgPSAwO1xuICAgICAgICBsYXN0Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbaV1bal07XG4gICAgICAgICAgY3VycmVudENvbG9yID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAndGV4dEJhY2tncm91bmRDb2xvcicpO1xuICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjaGFyQm94LnJlbmRlckxlZnQsIGNoYXJCb3gucmVuZGVyVG9wKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoY2hhckJveC5hbmdsZSk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY3VycmVudENvbG9yO1xuICAgICAgICAgICAgY3VycmVudENvbG9yICYmIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgLWNoYXJCb3gud2lkdGggLyAyLFxuICAgICAgICAgICAgICAtaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0ICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKSxcbiAgICAgICAgICAgICAgY2hhckJveC53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoY3VycmVudENvbG9yICE9PSBsYXN0Q29sb3IpIHtcbiAgICAgICAgICAgIGRyYXdTdGFydCA9IGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0O1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICAgICAgICBkcmF3U3RhcnQgPSB0aGlzLndpZHRoIC0gZHJhd1N0YXJ0IC0gYm94V2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFzdENvbG9yO1xuICAgICAgICAgICAgbGFzdENvbG9yICYmIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgZHJhd1N0YXJ0LFxuICAgICAgICAgICAgICBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICAgICAgICBib3hXaWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYm94U3RhcnQgPSBjaGFyQm94LmxlZnQ7XG4gICAgICAgICAgICBib3hXaWR0aCA9IGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgICBsYXN0Q29sb3IgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRDb2xvciAmJiAhcGF0aCkge1xuICAgICAgICAgIGRyYXdTdGFydCA9IGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0O1xuICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgICAgIGRyYXdTdGFydCA9IHRoaXMud2lkdGggLSBkcmF3U3RhcnQgLSBib3hXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICBkcmF3U3RhcnQsXG4gICAgICAgICAgICBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICAgICAgYm94V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9yaWdpbmFsRmlsbDtcbiAgICAgIC8vIGlmIHRoZXJlIGlzIHRleHQgYmFja2dyb3VuZCBjb2xvciBub1xuICAgICAgLy8gb3RoZXIgc2hhZG93cyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVjbCBzdHlsZSBkZWNsYXJhdGlvbiBmb3IgY2FjaGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjbC5mb250RmFtaWx5IGZvbnRGYW1pbHlcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjbC5mb250U3R5bGUgZm9udFN0eWxlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlY2wuZm9udFdlaWdodCBmb250V2VpZ2h0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSByZWZlcmVuY2UgdG8gY2FjaGVcbiAgICAgKi9cbiAgICBnZXRGb250Q2FjaGU6IGZ1bmN0aW9uKGRlY2wpIHtcbiAgICAgIHZhciBmb250RmFtaWx5ID0gZGVjbC5mb250RmFtaWx5LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoIWZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0pIHtcbiAgICAgICAgZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIHZhciBjYWNoZSA9IGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0sXG4gICAgICAgICAgY2FjaGVQcm9wID0gZGVjbC5mb250U3R5bGUudG9Mb3dlckNhc2UoKSArICdfJyArIChkZWNsLmZvbnRXZWlnaHQgKyAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghY2FjaGVbY2FjaGVQcm9wXSkge1xuICAgICAgICBjYWNoZVtjYWNoZVByb3BdID0geyB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlW2NhY2hlUHJvcF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1lYXN1cmUgYW5kIHJldHVybiB0aGUgd2lkdGggb2YgYSBzaW5nbGUgY2hhcmFjdGVyLlxuICAgICAqIHBvc3NpYmx5IG92ZXJyaWRkZW4gdG8gYWNjb21tb2RhdGUgZGlmZmVyZW50IG1lYXN1cmUgbG9naWMgb3JcbiAgICAgKiB0byBob29rIHNvbWUgZXh0ZXJuYWwgbGliIGZvciBjaGFyYWN0ZXIgbWVhc3VyZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBfY2hhciwgY2hhciB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFyU3R5bGUgc3R5bGUgb2YgY2hhciB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJldmlvdXNDaGFyXSBwcmV2aW91cyBjaGFyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcmV2Q2hhclN0eWxlXSBzdHlsZSBvZiBwcmV2aW91cyBjaGFyXG4gICAgICovXG4gICAgX21lYXN1cmVDaGFyOiBmdW5jdGlvbihfY2hhciwgY2hhclN0eWxlLCBwcmV2aW91c0NoYXIsIHByZXZDaGFyU3R5bGUpIHtcbiAgICAgIC8vIGZpcnN0IGkgdHJ5IHRvIHJldHVybiBmcm9tIGNhY2hlXG4gICAgICB2YXIgZm9udENhY2hlID0gdGhpcy5nZXRGb250Q2FjaGUoY2hhclN0eWxlKSwgZm9udERlY2xhcmF0aW9uID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKGNoYXJTdHlsZSksXG4gICAgICAgICAgcHJldmlvdXNGb250RGVjbGFyYXRpb24gPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24ocHJldkNoYXJTdHlsZSksIGNvdXBsZSA9IHByZXZpb3VzQ2hhciArIF9jaGFyLFxuICAgICAgICAgIHN0eWxlc0FyZUVxdWFsID0gZm9udERlY2xhcmF0aW9uID09PSBwcmV2aW91c0ZvbnREZWNsYXJhdGlvbiwgd2lkdGgsIGNvdXBsZVdpZHRoLCBwcmV2aW91c1dpZHRoLFxuICAgICAgICAgIGZvbnRNdWx0aXBsaWVyID0gY2hhclN0eWxlLmZvbnRTaXplIC8gdGhpcy5DQUNIRV9GT05UX1NJWkUsIGtlcm5lZFdpZHRoO1xuXG4gICAgICBpZiAocHJldmlvdXNDaGFyICYmIGZvbnRDYWNoZVtwcmV2aW91c0NoYXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJldmlvdXNXaWR0aCA9IGZvbnRDYWNoZVtwcmV2aW91c0NoYXJdO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRDYWNoZVtfY2hhcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXJuZWRXaWR0aCA9IHdpZHRoID0gZm9udENhY2hlW19jaGFyXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZXNBcmVFcXVhbCAmJiBmb250Q2FjaGVbY291cGxlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvdXBsZVdpZHRoID0gZm9udENhY2hlW2NvdXBsZV07XG4gICAgICAgIGtlcm5lZFdpZHRoID0gY291cGxlV2lkdGggLSBwcmV2aW91c1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgcHJldmlvdXNXaWR0aCA9PT0gdW5kZWZpbmVkIHx8IGNvdXBsZVdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuZ2V0TWVhc3VyaW5nQ29udGV4dCgpO1xuICAgICAgICAvLyBzZW5kIGEgVFJVRSB0byBzcGVjaWZ5IG1lYXN1cmluZyBmb250IHNpemUgQ0FDSEVfRk9OVF9TSVpFXG4gICAgICAgIHRoaXMuX3NldFRleHRTdHlsZXMoY3R4LCBjaGFyU3R5bGUsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2VybmVkV2lkdGggPSB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChfY2hhcikud2lkdGg7XG4gICAgICAgIGZvbnRDYWNoZVtfY2hhcl0gPSB3aWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2aW91c1dpZHRoID09PSB1bmRlZmluZWQgJiYgc3R5bGVzQXJlRXF1YWwgJiYgcHJldmlvdXNDaGFyKSB7XG4gICAgICAgIHByZXZpb3VzV2lkdGggPSBjdHgubWVhc3VyZVRleHQocHJldmlvdXNDaGFyKS53aWR0aDtcbiAgICAgICAgZm9udENhY2hlW3ByZXZpb3VzQ2hhcl0gPSBwcmV2aW91c1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlc0FyZUVxdWFsICYmIGNvdXBsZVdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gd2UgY2FuIG1lYXN1cmUgdGhlIGtlcm5pbmcgY291cGxlIGFuZCBzdWJ0cmFjdCB0aGUgd2lkdGggb2YgdGhlIHByZXZpb3VzIGNoYXJhY3RlclxuICAgICAgICBjb3VwbGVXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChjb3VwbGUpLndpZHRoO1xuICAgICAgICBmb250Q2FjaGVbY291cGxlXSA9IGNvdXBsZVdpZHRoO1xuICAgICAgICBrZXJuZWRXaWR0aCA9IGNvdXBsZVdpZHRoIC0gcHJldmlvdXNXaWR0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCAqIGZvbnRNdWx0aXBsaWVyLCBrZXJuZWRXaWR0aDoga2VybmVkV2lkdGggKiBmb250TXVsdGlwbGllciB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBoZWlnaHQgb2YgY2hhcmFjdGVyIGF0IGdpdmVuIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmUgdGhlIGxpbmUgaW5kZXggbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IF9jaGFyIHRoZSBjaGFyYWN0ZXIgaW5kZXggbnVtYmVyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBmb250U2l6ZSBvZiB0aGUgY2hhcmFjdGVyXG4gICAgICovXG4gICAgZ2V0SGVpZ2h0T2ZDaGFyOiBmdW5jdGlvbihsaW5lLCBfY2hhcikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZSwgX2NoYXIsICdmb250U2l6ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtZWFzdXJlIGEgdGV4dCBsaW5lIG1lYXN1cmluZyBhbGwgY2hhcmFjdGVycy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGxpbmUgbnVtYmVyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMaW5lIHdpZHRoXG4gICAgICovXG4gICAgbWVhc3VyZUxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIGxpbmVJbmZvID0gdGhpcy5fbWVhc3VyZUxpbmUobGluZUluZGV4KTtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIGxpbmVJbmZvLndpZHRoIC09IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVJbmZvLndpZHRoIDwgMCkge1xuICAgICAgICBsaW5lSW5mby53aWR0aCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZUluZm87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1lYXN1cmUgZXZlcnkgZ3JhcGhlbWUgb2YgYSBsaW5lLCBwb3B1bGF0aW5nIF9fY2hhckJvdW5kc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC53aWR0aCB0b3RhbCB3aWR0aCBvZiBjaGFyYWN0ZXJzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qud2lkdGhPZlNwYWNlcyBsZW5ndGggb2YgY2hhcnMgdGhhdCBtYXRjaCB0aGlzLl9yZVNwYWNlc0FuZFRhYnNcbiAgICAgKi9cbiAgICBfbWVhc3VyZUxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIHdpZHRoID0gMCwgaSwgZ3JhcGhlbWUsIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSwgcHJldkdyYXBoZW1lLFxuICAgICAgICAgIGdyYXBoZW1lSW5mbywgbnVtT2ZTcGFjZXMgPSAwLCBsaW5lQm91bmRzID0gbmV3IEFycmF5KGxpbmUubGVuZ3RoKSxcbiAgICAgICAgICBwb3NpdGlvbkluUGF0aCA9IDAsIHN0YXJ0aW5nUG9pbnQsIHRvdGFsUGF0aExlbmd0aCwgcGF0aCA9IHRoaXMucGF0aCxcbiAgICAgICAgICByZXZlcnNlID0gdGhpcy5wYXRoU2lkZSA9PT0gJ3JpZ2h0JztcblxuICAgICAgdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XSA9IGxpbmVCb3VuZHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBncmFwaGVtZSA9IGxpbmVbaV07XG4gICAgICAgIGdyYXBoZW1lSW5mbyA9IHRoaXMuX2dldEdyYXBoZW1lQm94KGdyYXBoZW1lLCBsaW5lSW5kZXgsIGksIHByZXZHcmFwaGVtZSk7XG4gICAgICAgIGxpbmVCb3VuZHNbaV0gPSBncmFwaGVtZUluZm87XG4gICAgICAgIHdpZHRoICs9IGdyYXBoZW1lSW5mby5rZXJuZWRXaWR0aDtcbiAgICAgICAgcHJldkdyYXBoZW1lID0gZ3JhcGhlbWU7XG4gICAgICB9XG4gICAgICAvLyB0aGlzIGxhdGVzdCBib3VuZCBib3ggcmVwcmVzZW50IHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGUgbGluZVxuICAgICAgLy8gdG8gc2ltcGxpZnkgY3Vyc29yIGhhbmRsaW5nIGluIGludGVyYWN0aXZlIG1vZGUuXG4gICAgICBsaW5lQm91bmRzW2ldID0ge1xuICAgICAgICBsZWZ0OiBncmFwaGVtZUluZm8gPyBncmFwaGVtZUluZm8ubGVmdCArIGdyYXBoZW1lSW5mby53aWR0aCA6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBrZXJuZWRXaWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmZvbnRTaXplXG4gICAgICB9O1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdG90YWxQYXRoTGVuZ3RoID0gcGF0aC5zZWdtZW50c0luZm9bcGF0aC5zZWdtZW50c0luZm8ubGVuZ3RoIC0gMV0ubGVuZ3RoO1xuICAgICAgICBzdGFydGluZ1BvaW50ID0gZmFicmljLnV0aWwuZ2V0UG9pbnRPblBhdGgocGF0aC5wYXRoLCAwLCBwYXRoLnNlZ21lbnRzSW5mbyk7XG4gICAgICAgIHN0YXJ0aW5nUG9pbnQueCArPSBwYXRoLnBhdGhPZmZzZXQueDtcbiAgICAgICAgc3RhcnRpbmdQb2ludC55ICs9IHBhdGgucGF0aE9mZnNldC55O1xuICAgICAgICBzd2l0Y2ggKHRoaXMudGV4dEFsaWduKSB7XG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBwb3NpdGlvbkluUGF0aCA9IHJldmVyc2UgPyAodG90YWxQYXRoTGVuZ3RoIC0gd2lkdGgpIDogMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICBwb3NpdGlvbkluUGF0aCA9ICh0b3RhbFBhdGhMZW5ndGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgcG9zaXRpb25JblBhdGggPSByZXZlcnNlID8gMCA6ICh0b3RhbFBhdGhMZW5ndGggLSB3aWR0aCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvL3RvZG8gLSBhZGQgc3VwcG9ydCBmb3IganVzdGlmeVxuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uSW5QYXRoICs9IHRoaXMucGF0aFN0YXJ0T2Zmc2V0ICogKHJldmVyc2UgPyAtMSA6IDEpO1xuICAgICAgICBmb3IgKGkgPSByZXZlcnNlID8gbGluZS5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgICByZXZlcnNlID8gaSA+PSAwIDogaSA8IGxpbmUubGVuZ3RoO1xuICAgICAgICAgIHJldmVyc2UgPyBpLS0gOiBpKyspIHtcbiAgICAgICAgICBncmFwaGVtZUluZm8gPSBsaW5lQm91bmRzW2ldO1xuICAgICAgICAgIGlmIChwb3NpdGlvbkluUGF0aCA+IHRvdGFsUGF0aExlbmd0aCkge1xuICAgICAgICAgICAgcG9zaXRpb25JblBhdGggJT0gdG90YWxQYXRoTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChwb3NpdGlvbkluUGF0aCA8IDApIHtcbiAgICAgICAgICAgIHBvc2l0aW9uSW5QYXRoICs9IHRvdGFsUGF0aExlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaXQgd291bGQgcHJvYmFibHkgbXVjaCBmYXN0ZXIgdG8gc2VuZCBhbGwgdGhlIGdyYXBoZW1lIHBvc2l0aW9uIGZvciBhIGxpbmVcbiAgICAgICAgICAvLyBhbmQgY2FsY3VsYXRlIHBhdGggcG9zaXRpb24vYW5nbGUgYXQgb25jZS5cbiAgICAgICAgICB0aGlzLl9zZXRHcmFwaGVtZU9uUGF0aChwb3NpdGlvbkluUGF0aCwgZ3JhcGhlbWVJbmZvLCBzdGFydGluZ1BvaW50KTtcbiAgICAgICAgICBwb3NpdGlvbkluUGF0aCArPSBncmFwaGVtZUluZm8ua2VybmVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCwgbnVtT2ZTcGFjZXM6IG51bU9mU3BhY2VzIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgYW5nbGUgIGFuZCB0aGUgbGVmdCx0b3AgcG9zaXRpb24gb2YgdGhlIGNoYXIgdGhhdCBmb2xsb3cgYSBwYXRoLlxuICAgICAqIEl0IGFwcGVuZHMgaXQgdG8gZ3JhcGhlbWVJbmZvIHRvIGJlIHJldXNlZCBsYXRlciBhdCByZW5kZXJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbkluUGF0aCB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaGVtZUluZm8gY3VycmVudCBncmFwaGVtZSBib3ggaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhcnRpbmdQb2ludCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRcbiAgICAgKi9cbiAgICBfc2V0R3JhcGhlbWVPblBhdGg6IGZ1bmN0aW9uKHBvc2l0aW9uSW5QYXRoLCBncmFwaGVtZUluZm8sIHN0YXJ0aW5nUG9pbnQpIHtcbiAgICAgIHZhciBjZW50ZXJQb3NpdGlvbiA9IHBvc2l0aW9uSW5QYXRoICsgZ3JhcGhlbWVJbmZvLmtlcm5lZFdpZHRoIC8gMixcbiAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoO1xuXG4gICAgICAvLyB3ZSBhcmUgYXQgY3VycmVudFBvc2l0aW9uT25QYXRoLiB3ZSB3YW50IHRvIGtub3cgd2hhdCBwb2ludCBvbiB0aGUgcGF0aCBpcy5cbiAgICAgIHZhciBpbmZvID0gZmFicmljLnV0aWwuZ2V0UG9pbnRPblBhdGgocGF0aC5wYXRoLCBjZW50ZXJQb3NpdGlvbiwgcGF0aC5zZWdtZW50c0luZm8pO1xuICAgICAgZ3JhcGhlbWVJbmZvLnJlbmRlckxlZnQgPSBpbmZvLnggLSBzdGFydGluZ1BvaW50Lng7XG4gICAgICBncmFwaGVtZUluZm8ucmVuZGVyVG9wID0gaW5mby55IC0gc3RhcnRpbmdQb2ludC55O1xuICAgICAgZ3JhcGhlbWVJbmZvLmFuZ2xlID0gaW5mby5hbmdsZSArICh0aGlzLnBhdGhTaWRlID09PSAgJ3JpZ2h0JyA/IE1hdGguUEkgOiAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZSBhbmQgcmV0dXJuIHRoZSBpbmZvIG9mIGEgc2luZ2xlIGdyYXBoZW1lLlxuICAgICAqIG5lZWRzIHRoZSB0aGUgaW5mbyBvZiBwcmV2aW91cyBncmFwaGVtZXMgYWxyZWFkeSBmaWxsZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncmFwaGVtZSB0byBiZSBtZWFzdXJlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggaW5kZXggb2YgdGhlIGxpbmUgd2hlcmUgdGhlIGNoYXIgaXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IHBvc2l0aW9uIGluIHRoZSBsaW5lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcmV2R3JhcGhlbWVdIGNoYXJhY3RlciBwcmVjZWRpbmcgdGhlIG9uZSB0byBiZSBtZWFzdXJlZFxuICAgICAqL1xuICAgIF9nZXRHcmFwaGVtZUJveDogZnVuY3Rpb24oZ3JhcGhlbWUsIGxpbmVJbmRleCwgY2hhckluZGV4LCBwcmV2R3JhcGhlbWUsIHNraXBMZWZ0KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgcHJldlN0eWxlID0gcHJldkdyYXBoZW1lID8gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXggLSAxKSA6IHsgfSxcbiAgICAgICAgICBpbmZvID0gdGhpcy5fbWVhc3VyZUNoYXIoZ3JhcGhlbWUsIHN0eWxlLCBwcmV2R3JhcGhlbWUsIHByZXZTdHlsZSksXG4gICAgICAgICAga2VybmVkV2lkdGggPSBpbmZvLmtlcm5lZFdpZHRoLFxuICAgICAgICAgIHdpZHRoID0gaW5mby53aWR0aCwgY2hhclNwYWNpbmc7XG5cbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIGNoYXJTcGFjaW5nID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICAgIHdpZHRoICs9IGNoYXJTcGFjaW5nO1xuICAgICAgICBrZXJuZWRXaWR0aCArPSBjaGFyU3BhY2luZztcbiAgICAgIH1cblxuICAgICAgdmFyIGJveCA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBoZWlnaHQ6IHN0eWxlLmZvbnRTaXplLFxuICAgICAgICBrZXJuZWRXaWR0aDoga2VybmVkV2lkdGgsXG4gICAgICAgIGRlbHRhWTogc3R5bGUuZGVsdGFZLFxuICAgICAgfTtcbiAgICAgIGlmIChjaGFySW5kZXggPiAwICYmICFza2lwTGVmdCkge1xuICAgICAgICB2YXIgcHJldmlvdXNCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2NoYXJJbmRleCAtIDFdO1xuICAgICAgICBib3gubGVmdCA9IHByZXZpb3VzQm94LmxlZnQgKyBwcmV2aW91c0JveC53aWR0aCArIGluZm8ua2VybmVkV2lkdGggLSBpbmZvLndpZHRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJveDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGhlaWdodCBvZiBsaW5lIGF0ICdsaW5lSW5kZXgnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBpbmRleCBvZiBsaW5lIHRvIGNhbGN1bGF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHRPZkxpbmU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbGluZUhlaWdodHNbbGluZUluZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgICAvLyBjaGFyIDAgaXMgbWVhc3VyZWQgYmVmb3JlIHRoZSBsaW5lIGN5Y2xlIGJlY2F1c2UgaXQgbm5lZHMgdG8gY2hhclxuICAgICAgICAgIC8vIGVtcHR5bGluZXNcbiAgICAgICAgICBtYXhIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mQ2hhcihsaW5lSW5kZXgsIDApO1xuICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IGxpbmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWF4SGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5nZXRIZWlnaHRPZkNoYXIobGluZUluZGV4LCBpKSwgbWF4SGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdID0gbWF4SGVpZ2h0ICogdGhpcy5saW5lSGVpZ2h0ICogdGhpcy5fZm9udFNpemVNdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGV4dCBib3ggaGVpZ2h0XG4gICAgICovXG4gICAgY2FsY1RleHRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVIZWlnaHQsIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpbmVIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgICAgaGVpZ2h0ICs9IChpID09PSBsZW4gLSAxID8gbGluZUhlaWdodCAvIHRoaXMubGluZUhlaWdodCA6IGxpbmVIZWlnaHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExlZnQgb2Zmc2V0XG4gICAgICovXG4gICAgX2dldExlZnRPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uID09PSAnbHRyJyA/IC10aGlzLndpZHRoIC8gMiA6IHRoaXMud2lkdGggLyAyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gVG9wIG9mZnNldFxuICAgICAqL1xuICAgIF9nZXRUb3BPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIC10aGlzLmhlaWdodCAvIDI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTWV0aG9kIG5hbWUgKFwiZmlsbFRleHRcIiBvciBcInN0cm9rZVRleHRcIilcbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dENvbW1vbjogZnVuY3Rpb24oY3R4LCBtZXRob2QpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgbGluZUhlaWdodHMgPSAwLCBsZWZ0ID0gdGhpcy5fZ2V0TGVmdE9mZnNldCgpLCB0b3AgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGhlaWdodE9mTGluZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpLFxuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0LFxuICAgICAgICAgICAgbGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0TGluZShcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgY3R4LFxuICAgICAgICAgIHRoaXMuX3RleHRMaW5lc1tpXSxcbiAgICAgICAgICBsZWZ0ICsgbGVmdE9mZnNldCxcbiAgICAgICAgICB0b3AgKyBsaW5lSGVpZ2h0cyArIG1heEhlaWdodCxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIGxpbmVIZWlnaHRzICs9IGhlaWdodE9mTGluZTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0RmlsbDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuZmlsbCAmJiAhdGhpcy5zdHlsZUhhcygnZmlsbCcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVuZGVyVGV4dENvbW1vbihjdHgsICdmaWxsVGV4dCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dFN0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoKCF0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSAmJiB0aGlzLmlzRW1wdHlTdHlsZXMoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNoYWRvdyAmJiAhdGhpcy5zaGFkb3cuYWZmZWN0U3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0Q29tbW9uKGN0eCwgJ3N0cm9rZVRleHQnKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBmaWxsVGV4dCBvciBzdHJva2VUZXh0LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lIENvbnRlbnQgb2YgdGhlIGxpbmUsIHNwbGl0dGVkIGluIGFuIGFycmF5IGJ5IGdyYXBoZW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqL1xuICAgIF9yZW5kZXJDaGFyczogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4KSB7XG4gICAgICAvLyBzZXQgcHJvcGVyIGxpbmUgb2Zmc2V0XG4gICAgICB2YXIgbGluZUhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGxpbmVJbmRleCksXG4gICAgICAgICAgaXNKdXN0aWZ5ID0gdGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSxcbiAgICAgICAgICBhY3R1YWxTdHlsZSxcbiAgICAgICAgICBuZXh0U3R5bGUsXG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnLFxuICAgICAgICAgIGNoYXJCb3gsXG4gICAgICAgICAgYm94V2lkdGggPSAwLFxuICAgICAgICAgIHRpbWVUb1JlbmRlcixcbiAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoLFxuICAgICAgICAgIHNob3J0Q3V0ID0gIWlzSnVzdGlmeSAmJiB0aGlzLmNoYXJTcGFjaW5nID09PSAwICYmIHRoaXMuaXNFbXB0eVN0eWxlcyhsaW5lSW5kZXgpICYmICFwYXRoLFxuICAgICAgICAgIGlzTHRyID0gdGhpcy5kaXJlY3Rpb24gPT09ICdsdHInLCBzaWduID0gdGhpcy5kaXJlY3Rpb24gPT09ICdsdHInID8gMSA6IC0xLFxuICAgICAgICAgIGRyYXdpbmdMZWZ0LCBjdXJyZW50RGlyZWN0aW9uID0gY3R4LmNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2RpcicpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGlmIChjdXJyZW50RGlyZWN0aW9uICE9PSB0aGlzLmRpcmVjdGlvbikge1xuICAgICAgICBjdHguY2FudmFzLnNldEF0dHJpYnV0ZSgnZGlyJywgaXNMdHIgPyAnbHRyJyA6ICdydGwnKTtcbiAgICAgICAgY3R4LmRpcmVjdGlvbiA9IGlzTHRyID8gJ2x0cicgOiAncnRsJztcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IGlzTHRyID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH1cbiAgICAgIHRvcCAtPSBsaW5lSGVpZ2h0ICogdGhpcy5fZm9udFNpemVGcmFjdGlvbiAvIHRoaXMubGluZUhlaWdodDtcbiAgICAgIGlmIChzaG9ydEN1dCkge1xuICAgICAgICAvLyByZW5kZXIgYWxsIHRoZSBsaW5lIGluIG9uZSBwYXNzIHdpdGhvdXQgY2hlY2tpbmdcbiAgICAgICAgLy8gZHJhd2luZ0xlZnQgPSBpc0x0ciA/IGxlZnQgOiBsZWZ0IC0gdGhpcy5nZXRMaW5lV2lkdGgobGluZUluZGV4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyQ2hhcihtZXRob2QsIGN0eCwgbGluZUluZGV4LCAwLCBsaW5lLmpvaW4oJycpLCBsZWZ0LCB0b3AsIGxpbmVIZWlnaHQpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZS5sZW5ndGggLSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIHRpbWVUb1JlbmRlciA9IGkgPT09IGxlbiB8fCB0aGlzLmNoYXJTcGFjaW5nIHx8IHBhdGg7XG4gICAgICAgIGNoYXJzVG9SZW5kZXIgKz0gbGluZVtpXTtcbiAgICAgICAgY2hhckJveCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1baV07XG4gICAgICAgIGlmIChib3hXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIGxlZnQgKz0gc2lnbiAqIChjaGFyQm94Lmtlcm5lZFdpZHRoIC0gY2hhckJveC53aWR0aCk7XG4gICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0p1c3RpZnkgJiYgIXRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIGlmICh0aGlzLl9yZVNwYWNlQW5kVGFiLnRlc3QobGluZVtpXSkpIHtcbiAgICAgICAgICAgIHRpbWVUb1JlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgLy8gaWYgd2UgaGF2ZSBjaGFyU3BhY2luZywgd2UgcmVuZGVyIGNoYXIgYnkgY2hhclxuICAgICAgICAgIGFjdHVhbFN0eWxlID0gYWN0dWFsU3R5bGUgfHwgdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBpKTtcbiAgICAgICAgICBuZXh0U3R5bGUgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkgKyAxKTtcbiAgICAgICAgICB0aW1lVG9SZW5kZXIgPSBmYWJyaWMudXRpbC5oYXNTdHlsZUNoYW5nZWQoYWN0dWFsU3R5bGUsIG5leHRTdHlsZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY2hhckJveC5yZW5kZXJMZWZ0LCBjaGFyQm94LnJlbmRlclRvcCk7XG4gICAgICAgICAgICBjdHgucm90YXRlKGNoYXJCb3guYW5nbGUpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ2hhcihtZXRob2QsIGN0eCwgbGluZUluZGV4LCBpLCBjaGFyc1RvUmVuZGVyLCAtYm94V2lkdGggLyAyLCAwLCBsaW5lSGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHJhd2luZ0xlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ2hhcihtZXRob2QsIGN0eCwgbGluZUluZGV4LCBpLCBjaGFyc1RvUmVuZGVyLCBkcmF3aW5nTGVmdCwgdG9wLCBsaW5lSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnO1xuICAgICAgICAgIGFjdHVhbFN0eWxlID0gbmV4dFN0eWxlO1xuICAgICAgICAgIGxlZnQgKz0gc2lnbiAqIGJveFdpZHRoO1xuICAgICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB0cnkgdG8gcGF0Y2ggdGhlIG1pc3NpbmcgZ3JhZGllbnRUcmFuc2Zvcm0gb24gY2FudmFzIGdyYWRpZW50cy5cbiAgICAgKiB0cmFuc2Zvcm1pbmcgYSBjb250ZXh0IHRvIHRyYW5zZm9ybSB0aGUgZ3JhZGllbnQsIGlzIGdvaW5nIHRvIHRyYW5zZm9ybSB0aGUgc3Ryb2tlIHRvby5cbiAgICAgKiB3ZSB3YW50IHRvIHRyYW5zZm9ybSB0aGUgZ3JhZGllbnQgYnV0IG5vdCB0aGUgc3Ryb2tlIG9wZXJhdGlvbiwgc28gd2UgY3JlYXRlXG4gICAgICogYSB0cmFuc2Zvcm1lZCBncmFkaWVudCBvbiBhIHBhdHRlcm4gYW5kIHRoZW4gd2UgdXNlIHRoZSBwYXR0ZXJuIGluc3RlYWQgb2YgdGhlIGdyYWRpZW50LlxuICAgICAqIHRoaXMgbWV0aG9kIGhhcyBkcmF3YmFja3M6IGlzIHNsb3csIGlzIGluIGxvdyByZXNvbHV0aW9uLCBuZWVkcyBhIHBhdGNoIGZvciB3aGVuIHRoZSBzaXplXG4gICAgICogaXMgbGltaXRlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLkdyYWRpZW50fSBmaWxsZXIgYSBmYWJyaWMgZ3JhZGllbnQgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtDYW52YXNQYXR0ZXJufSBhIHBhdHRlcm4gdG8gdXNlIGFzIGZpbGwvc3Ryb2tlIHN0eWxlXG4gICAgICovXG4gICAgX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtVGV4dDogZnVuY3Rpb24oZmlsbGVyKSB7XG4gICAgICB2YXIgcENhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSwgcEN0eCxcbiAgICAgICAgICAvLyBUT0RPOiB2ZXJpZnkgY29tcGF0aWJpbGl0eSB3aXRoIHN0cm9rZVVuaWZvcm1cbiAgICAgICAgICB3aWR0aCA9IHRoaXMud2lkdGggKyB0aGlzLnN0cm9rZVdpZHRoLCBoZWlnaHQgPSB0aGlzLmhlaWdodCArIHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICBwQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICBwQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHBDdHggPSBwQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBwQ3R4LmJlZ2luUGF0aCgpOyBwQ3R4Lm1vdmVUbygwLCAwKTsgcEN0eC5saW5lVG8od2lkdGgsIDApOyBwQ3R4LmxpbmVUbyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHBDdHgubGluZVRvKDAsIGhlaWdodCk7IHBDdHguY2xvc2VQYXRoKCk7XG4gICAgICBwQ3R4LnRyYW5zbGF0ZSh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgcEN0eC5maWxsU3R5bGUgPSBmaWxsZXIudG9MaXZlKHBDdHgpO1xuICAgICAgdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0ocEN0eCwgZmlsbGVyKTtcbiAgICAgIHBDdHguZmlsbCgpO1xuICAgICAgcmV0dXJuIHBDdHguY3JlYXRlUGF0dGVybihwQ2FudmFzLCAnbm8tcmVwZWF0Jyk7XG4gICAgfSxcblxuICAgIGhhbmRsZUZpbGxlcjogZnVuY3Rpb24oY3R4LCBwcm9wZXJ0eSwgZmlsbGVyKSB7XG4gICAgICB2YXIgb2Zmc2V0WCwgb2Zmc2V0WTtcbiAgICAgIGlmIChmaWxsZXIudG9MaXZlKSB7XG4gICAgICAgIGlmIChmaWxsZXIuZ3JhZGllbnRVbml0cyA9PT0gJ3BlcmNlbnRhZ2UnIHx8IGZpbGxlci5ncmFkaWVudFRyYW5zZm9ybSB8fCBmaWxsZXIucGF0dGVyblRyYW5zZm9ybSkge1xuICAgICAgICAgIC8vIG5lZWQgdG8gdHJhbnNmb3JtIGdyYWRpZW50IGluIGEgcGF0dGVybi5cbiAgICAgICAgICAvLyB0aGlzIGlzIGEgc2xvdyBwcm9jZXNzLiBJZiB5b3UgYXJlIGhpdHRpbmcgdGhpcyBjb2RlcGF0aCwgYW5kIHRoZSBvYmplY3RcbiAgICAgICAgICAvLyBpcyBub3QgdXNpbmcgY2FjaGluZywgeW91IHNob3VsZCBjb25zaWRlciBzd2l0Y2hpbmcgaXQgb24uXG4gICAgICAgICAgLy8gd2UgbmVlZCBhIGNhbnZhcyBhcyBiaWcgYXMgdGhlIGN1cnJlbnQgb2JqZWN0IGNhY2hpbmcgY2FudmFzLlxuICAgICAgICAgIG9mZnNldFggPSAtdGhpcy53aWR0aCAvIDI7XG4gICAgICAgICAgb2Zmc2V0WSA9IC10aGlzLmhlaWdodCAvIDI7XG4gICAgICAgICAgY3R4LnRyYW5zbGF0ZShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICBjdHhbcHJvcGVydHldID0gdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm1UZXh0KGZpbGxlcik7XG4gICAgICAgICAgcmV0dXJuIHsgb2Zmc2V0WDogb2Zmc2V0WCwgb2Zmc2V0WTogb2Zmc2V0WSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGlzIGEgc2ltcGxlIGdyYWRpZW50IG9yIHBhdHRlcm5cbiAgICAgICAgICBjdHhbcHJvcGVydHldID0gZmlsbGVyLnRvTGl2ZShjdHgsIHRoaXMpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShjdHgsIGZpbGxlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBpcyBhIGNvbG9yXG4gICAgICAgIGN0eFtwcm9wZXJ0eV0gPSBmaWxsZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBvZmZzZXRYOiAwLCBvZmZzZXRZOiAwIH07XG4gICAgfSxcblxuICAgIF9zZXRTdHJva2VTdHlsZXM6IGZ1bmN0aW9uKGN0eCwgZGVjbCkge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGRlY2wuc3Ryb2tlV2lkdGg7XG4gICAgICBjdHgubGluZUNhcCA9IHRoaXMuc3Ryb2tlTGluZUNhcDtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHRoaXMuc3Ryb2tlRGFzaE9mZnNldDtcbiAgICAgIGN0eC5saW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW47XG4gICAgICBjdHgubWl0ZXJMaW1pdCA9IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdDtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZUZpbGxlcihjdHgsICdzdHJva2VTdHlsZScsIGRlY2wuc3Ryb2tlKTtcbiAgICB9LFxuXG4gICAgX3NldEZpbGxTdHlsZXM6IGZ1bmN0aW9uKGN0eCwgZGVjbCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRmlsbGVyKGN0eCwgJ2ZpbGxTdHlsZScsIGRlY2wuZmlsbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBfY2hhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUhlaWdodCBIZWlnaHQgb2YgdGhlIGxpbmVcbiAgICAgKi9cbiAgICBfcmVuZGVyQ2hhcjogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGxpbmVJbmRleCwgY2hhckluZGV4LCBfY2hhciwgbGVmdCwgdG9wKSB7XG4gICAgICB2YXIgZGVjbCA9IHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICAgIGZ1bGxEZWNsID0gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICAgIHNob3VsZEZpbGwgPSBtZXRob2QgPT09ICdmaWxsVGV4dCcgJiYgZnVsbERlY2wuZmlsbCxcbiAgICAgICAgICBzaG91bGRTdHJva2UgPSBtZXRob2QgPT09ICdzdHJva2VUZXh0JyAmJiBmdWxsRGVjbC5zdHJva2UgJiYgZnVsbERlY2wuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgZmlsbE9mZnNldHMsIHN0cm9rZU9mZnNldHM7XG5cbiAgICAgIGlmICghc2hvdWxkU3Ryb2tlICYmICFzaG91bGRGaWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIHNob3VsZEZpbGwgJiYgKGZpbGxPZmZzZXRzID0gdGhpcy5fc2V0RmlsbFN0eWxlcyhjdHgsIGZ1bGxEZWNsKSk7XG4gICAgICBzaG91bGRTdHJva2UgJiYgKHN0cm9rZU9mZnNldHMgPSB0aGlzLl9zZXRTdHJva2VTdHlsZXMoY3R4LCBmdWxsRGVjbCkpO1xuXG4gICAgICBjdHguZm9udCA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbihmdWxsRGVjbCk7XG5cblxuICAgICAgaWYgKGRlY2wgJiYgZGVjbC50ZXh0QmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgICAgfVxuICAgICAgaWYgKGRlY2wgJiYgZGVjbC5kZWx0YVkpIHtcbiAgICAgICAgdG9wICs9IGRlY2wuZGVsdGFZO1xuICAgICAgfVxuICAgICAgc2hvdWxkRmlsbCAmJiBjdHguZmlsbFRleHQoX2NoYXIsIGxlZnQgLSBmaWxsT2Zmc2V0cy5vZmZzZXRYLCB0b3AgLSBmaWxsT2Zmc2V0cy5vZmZzZXRZKTtcbiAgICAgIHNob3VsZFN0cm9rZSAmJiBjdHguc3Ryb2tlVGV4dChfY2hhciwgbGVmdCAtIHN0cm9rZU9mZnNldHMub2Zmc2V0WCwgdG9wIC0gc3Ryb2tlT2Zmc2V0cy5vZmZzZXRZKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIHRoZSBjaGFyYWN0ZXIgaW50byBhICdzdXBlcmlvciBmaWd1cmUnIChpLmUuICdzdXBlcnNjcmlwdCcpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHNlbGVjdGlvbiBzdGFydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgc2VsZWN0aW9uIGVuZFxuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTdXBlcnNjcmlwdDogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFNjcmlwdChzdGFydCwgZW5kLCB0aGlzLnN1cGVyc2NyaXB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHVybnMgdGhlIGNoYXJhY3RlciBpbnRvIGFuICdpbmZlcmlvciBmaWd1cmUnIChpLmUuICdzdWJzY3JpcHQnKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBzZWxlY3Rpb24gc3RhcnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIHNlbGVjdGlvbiBlbmRcbiAgICAgKiBAcmV0dXJucyB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0U3Vic2NyaXB0OiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0U2NyaXB0KHN0YXJ0LCBlbmQsIHRoaXMuc3Vic2NyaXB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyAnc2NoZW1hJyBhdCBnaXZlbiBwb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHNlbGVjdGlvbiBzdGFydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgc2VsZWN0aW9uIGVuZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2hlbWFcbiAgICAgKiBAcmV0dXJucyB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX3NldFNjcmlwdDogZnVuY3Rpb24oc3RhcnQsIGVuZCwgc2NoZW1hKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHN0YXJ0LCB0cnVlKSxcbiAgICAgICAgICBmb250U2l6ZSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwgJ2ZvbnRTaXplJyksXG4gICAgICAgICAgZHkgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgsICdkZWx0YVknKSxcbiAgICAgICAgICBzdHlsZSA9IHsgZm9udFNpemU6IGZvbnRTaXplICogc2NoZW1hLnNpemUsIGRlbHRhWTogZHkgKyBmb250U2l6ZSAqIHNjaGVtYS5iYXNlbGluZSB9O1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdHlsZXMoc3R5bGUsIHN0YXJ0LCBlbmQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBpbmRleCB0ZXh0IGxpbmVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExpbmUgbGVmdCBvZmZzZXRcbiAgICAgKi9cbiAgICBfZ2V0TGluZUxlZnRPZmZzZXQ6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IHRoaXMuZ2V0TGluZVdpZHRoKGxpbmVJbmRleCksXG4gICAgICAgICAgbGluZURpZmYgPSB0aGlzLndpZHRoIC0gbGluZVdpZHRoLCB0ZXh0QWxpZ24gPSB0aGlzLnRleHRBbGlnbiwgZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb24sXG4gICAgICAgICAgaXNFbmRPZldyYXBwaW5nLCBsZWZ0T2Zmc2V0ID0gMCwgaXNFbmRPZldyYXBwaW5nID0gdGhpcy5pc0VuZE9mV3JhcHBpbmcobGluZUluZGV4KTtcbiAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdqdXN0aWZ5J1xuICAgICAgICB8fCAodGV4dEFsaWduID09PSAnanVzdGlmeS1jZW50ZXInICYmICFpc0VuZE9mV3JhcHBpbmcpXG4gICAgICAgIHx8ICh0ZXh0QWxpZ24gPT09ICdqdXN0aWZ5LXJpZ2h0JyAmJiAhaXNFbmRPZldyYXBwaW5nKVxuICAgICAgICB8fCAodGV4dEFsaWduID09PSAnanVzdGlmeS1sZWZ0JyAmJiAhaXNFbmRPZldyYXBwaW5nKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgbGVmdE9mZnNldCA9IGxpbmVEaWZmIC8gMjtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgbGVmdE9mZnNldCA9IGxpbmVEaWZmO1xuICAgICAgfVxuICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2p1c3RpZnktY2VudGVyJykge1xuICAgICAgICBsZWZ0T2Zmc2V0ID0gbGluZURpZmYgLyAyO1xuICAgICAgfVxuICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2p1c3RpZnktcmlnaHQnKSB7XG4gICAgICAgIGxlZnRPZmZzZXQgPSBsaW5lRGlmZjtcbiAgICAgIH1cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgIGxlZnRPZmZzZXQgLT0gbGluZURpZmY7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdE9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2xlYXJDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9fbGluZVdpZHRocyA9IFtdO1xuICAgICAgdGhpcy5fX2xpbmVIZWlnaHRzID0gW107XG4gICAgICB0aGlzLl9fY2hhckJvdW5kcyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzaG91bGRDbGVhciA9IHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZTtcbiAgICAgIHNob3VsZENsZWFyIHx8IChzaG91bGRDbGVhciA9IHRoaXMuaGFzU3RhdGVDaGFuZ2VkKCdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnKSk7XG4gICAgICBpZiAoc2hvdWxkQ2xlYXIpIHtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNob3VsZENsZWFyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZWFzdXJlIGEgc2luZ2xlIGxpbmUgZ2l2ZW4gaXRzIGluZGV4LiBVc2VkIHRvIGNhbGN1bGF0ZSB0aGUgaW5pdGlhbFxuICAgICAqIHRleHQgYm91bmRpbmcgYm94LiBUaGUgdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGFuZCBzdG9yZWQgaW4gX19saW5lV2lkdGhzIGNhY2hlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBsaW5lIG51bWJlclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGluZSB3aWR0aFxuICAgICAqL1xuICAgIGdldExpbmVXaWR0aDogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fX2xpbmVXaWR0aHNbbGluZUluZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbGluZVdpZHRoc1tsaW5lSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZUluZm8gPSB0aGlzLm1lYXN1cmVMaW5lKGxpbmVJbmRleCk7XG4gICAgICB2YXIgd2lkdGggPSBsaW5lSW5mby53aWR0aDtcbiAgICAgIHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF0gPSB3aWR0aDtcbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgX2dldFdpZHRoT2ZDaGFyU3BhY2luZzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb250U2l6ZSAqIHRoaXMuY2hhclNwYWNpbmcgLyAxMDAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgcHJvcGVydHkgYXQgZ2l2ZW4gY2hhcmFjdGVyIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCB0aGUgbGluZSBudW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IHRoZSBjaGFyYWN0ZXIgbnVtYmVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IHRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybnMgdGhlIHZhbHVlIG9mICdwcm9wZXJ0eSdcbiAgICAgKi9cbiAgICBnZXRWYWx1ZU9mUHJvcGVydHlBdDogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHByb3BlcnR5KSB7XG4gICAgICB2YXIgY2hhclN0eWxlID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCk7XG4gICAgICBpZiAoY2hhclN0eWxlICYmIHR5cGVvZiBjaGFyU3R5bGVbcHJvcGVydHldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gY2hhclN0eWxlW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzW3Byb3BlcnR5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHREZWNvcmF0aW9uOiBmdW5jdGlvbihjdHgsIHR5cGUpIHtcbiAgICAgIGlmICghdGhpc1t0eXBlXSAmJiAhdGhpcy5zdHlsZUhhcyh0eXBlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaGVpZ2h0T2ZMaW5lLCBzaXplLCBfc2l6ZSxcbiAgICAgICAgICBsaW5lTGVmdE9mZnNldCwgZHksIF9keSxcbiAgICAgICAgICBsaW5lLCBsYXN0RGVjb3JhdGlvbixcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGVmdE9mZnNldCgpLFxuICAgICAgICAgIHRvcE9mZnNldCA9IHRoaXMuX2dldFRvcE9mZnNldCgpLCB0b3AsXG4gICAgICAgICAgYm94U3RhcnQsIGJveFdpZHRoLCBjaGFyQm94LCBjdXJyZW50RGVjb3JhdGlvbixcbiAgICAgICAgICBtYXhIZWlnaHQsIGN1cnJlbnRGaWxsLCBsYXN0RmlsbCwgcGF0aCA9IHRoaXMucGF0aCxcbiAgICAgICAgICBjaGFyU3BhY2luZyA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpLFxuICAgICAgICAgIG9mZnNldFkgPSB0aGlzLm9mZnNldHNbdHlwZV07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaGVpZ2h0T2ZMaW5lID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSk7XG4gICAgICAgIGlmICghdGhpc1t0eXBlXSAmJiAhdGhpcy5zdHlsZUhhcyh0eXBlLCBpKSkge1xuICAgICAgICAgIHRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXTtcbiAgICAgICAgbWF4SGVpZ2h0ID0gaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpO1xuICAgICAgICBib3hTdGFydCA9IDA7XG4gICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgbGFzdERlY29yYXRpb24gPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsIHR5cGUpO1xuICAgICAgICBsYXN0RmlsbCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ2ZpbGwnKTtcbiAgICAgICAgdG9wID0gdG9wT2Zmc2V0ICsgbWF4SGVpZ2h0ICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKTtcbiAgICAgICAgc2l6ZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZDaGFyKGksIDApO1xuICAgICAgICBkeSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ2RlbHRhWScpO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgICAgY2hhckJveCA9IHRoaXMuX19jaGFyQm91bmRzW2ldW2pdO1xuICAgICAgICAgIGN1cnJlbnREZWNvcmF0aW9uID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCB0eXBlKTtcbiAgICAgICAgICBjdXJyZW50RmlsbCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgaiwgJ2ZpbGwnKTtcbiAgICAgICAgICBfc2l6ZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZDaGFyKGksIGopO1xuICAgICAgICAgIF9keSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgaiwgJ2RlbHRhWScpO1xuICAgICAgICAgIGlmIChwYXRoICYmIGN1cnJlbnREZWNvcmF0aW9uICYmIGN1cnJlbnRGaWxsKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhc3RGaWxsO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjaGFyQm94LnJlbmRlckxlZnQsIGNoYXJCb3gucmVuZGVyVG9wKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoY2hhckJveC5hbmdsZSk7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgIC1jaGFyQm94Lmtlcm5lZFdpZHRoIC8gMixcbiAgICAgICAgICAgICAgb2Zmc2V0WSAqIF9zaXplICsgX2R5LFxuICAgICAgICAgICAgICBjaGFyQm94Lmtlcm5lZFdpZHRoLFxuICAgICAgICAgICAgICB0aGlzLmZvbnRTaXplIC8gMTVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgIChjdXJyZW50RGVjb3JhdGlvbiAhPT0gbGFzdERlY29yYXRpb24gfHwgY3VycmVudEZpbGwgIT09IGxhc3RGaWxsIHx8IF9zaXplICE9PSBzaXplIHx8IF9keSAhPT0gZHkpXG4gICAgICAgICAgICAmJiBib3hXaWR0aCA+IDBcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBkcmF3U3RhcnQgPSBsZWZ0T2Zmc2V0ICsgbGluZUxlZnRPZmZzZXQgKyBib3hTdGFydDtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgICAgICAgZHJhd1N0YXJ0ID0gdGhpcy53aWR0aCAtIGRyYXdTdGFydCAtIGJveFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3REZWNvcmF0aW9uICYmIGxhc3RGaWxsKSB7XG4gICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYXN0RmlsbDtcbiAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAgIGRyYXdTdGFydCxcbiAgICAgICAgICAgICAgICB0b3AgKyBvZmZzZXRZICogc2l6ZSArIGR5LFxuICAgICAgICAgICAgICAgIGJveFdpZHRoLFxuICAgICAgICAgICAgICAgIHRoaXMuZm9udFNpemUgLyAxNVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm94U3RhcnQgPSBjaGFyQm94LmxlZnQ7XG4gICAgICAgICAgICBib3hXaWR0aCA9IGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgICBsYXN0RGVjb3JhdGlvbiA9IGN1cnJlbnREZWNvcmF0aW9uO1xuICAgICAgICAgICAgbGFzdEZpbGwgPSBjdXJyZW50RmlsbDtcbiAgICAgICAgICAgIHNpemUgPSBfc2l6ZTtcbiAgICAgICAgICAgIGR5ID0gX2R5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkcmF3U3RhcnQgPSBsZWZ0T2Zmc2V0ICsgbGluZUxlZnRPZmZzZXQgKyBib3hTdGFydDtcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICAgIGRyYXdTdGFydCA9IHRoaXMud2lkdGggLSBkcmF3U3RhcnQgLSBib3hXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gY3VycmVudEZpbGw7XG4gICAgICAgIGN1cnJlbnREZWNvcmF0aW9uICYmIGN1cnJlbnRGaWxsICYmIGN0eC5maWxsUmVjdChcbiAgICAgICAgICBkcmF3U3RhcnQsXG4gICAgICAgICAgdG9wICsgb2Zmc2V0WSAqIHNpemUgKyBkeSxcbiAgICAgICAgICBib3hXaWR0aCAtIGNoYXJTcGFjaW5nLFxuICAgICAgICAgIHRoaXMuZm9udFNpemUgLyAxNVxuICAgICAgICApO1xuICAgICAgICB0b3BPZmZzZXQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgfVxuICAgICAgLy8gaWYgdGhlcmUgaXMgdGV4dCBiYWNrZ3JvdW5kIGNvbG9yIG5vXG4gICAgICAvLyBvdGhlciBzaGFkb3dzIHNob3VsZCBiZSBjYXN0ZWRcbiAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gZm9udCBkZWNsYXJhdGlvbiBzdHJpbmcgZm9yIGNhbnZhcyBjb250ZXh0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZU9iamVjdF0gb2JqZWN0XG4gICAgICogQHJldHVybnMge1N0cmluZ30gZm9udCBkZWNsYXJhdGlvbiBmb3JtYXR0ZWQgZm9yIGNhbnZhcyBjb250ZXh0LlxuICAgICAqL1xuICAgIF9nZXRGb250RGVjbGFyYXRpb246IGZ1bmN0aW9uKHN0eWxlT2JqZWN0LCBmb3JNZWFzdXJpbmcpIHtcbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlT2JqZWN0IHx8IHRoaXMsIGZhbWlseSA9IHRoaXMuZm9udEZhbWlseSxcbiAgICAgICAgICBmb250SXNHZW5lcmljID0gZmFicmljLlRleHQuZ2VuZXJpY0ZvbnRzLmluZGV4T2YoZmFtaWx5LnRvTG93ZXJDYXNlKCkpID4gLTE7XG4gICAgICB2YXIgZm9udEZhbWlseSA9IGZhbWlseSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBmYW1pbHkuaW5kZXhPZignXFwnJykgPiAtMSB8fCBmYW1pbHkuaW5kZXhPZignLCcpID4gLTEgfHxcbiAgICAgIGZhbWlseS5pbmRleE9mKCdcIicpID4gLTEgfHwgZm9udElzR2VuZXJpY1xuICAgICAgICA/IHN0eWxlLmZvbnRGYW1pbHkgOiAnXCInICsgc3R5bGUuZm9udEZhbWlseSArICdcIic7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAvLyBub2RlLWNhbnZhcyBuZWVkcyBcIndlaWdodCBzdHlsZVwiLCB3aGlsZSBicm93c2VycyBuZWVkIFwic3R5bGUgd2VpZ2h0XCJcbiAgICAgICAgLy8gdmVyaWZ5IGlmIHRoaXMgY2FuIGJlIGZpeGVkIGluIEpTRE9NXG4gICAgICAgIChmYWJyaWMuaXNMaWtlbHlOb2RlID8gc3R5bGUuZm9udFdlaWdodCA6IHN0eWxlLmZvbnRTdHlsZSksXG4gICAgICAgIChmYWJyaWMuaXNMaWtlbHlOb2RlID8gc3R5bGUuZm9udFN0eWxlIDogc3R5bGUuZm9udFdlaWdodCksXG4gICAgICAgIGZvck1lYXN1cmluZyA/IHRoaXMuQ0FDSEVfRk9OVF9TSVpFICsgJ3B4JyA6IHN0eWxlLmZvbnRTaXplICsgJ3B4JyxcbiAgICAgICAgZm9udEZhbWlseVxuICAgICAgXS5qb2luKCcgJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGV4dCBpbnN0YW5jZSBvbiBhIHNwZWNpZmllZCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAvLyBkbyBub3QgcmVuZGVyIGlmIG9iamVjdCBpcyBub3QgdmlzaWJsZVxuICAgICAgaWYgKCF0aGlzLnZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnNraXBPZmZzY3JlZW4gJiYgIXRoaXMuZ3JvdXAgJiYgIXRoaXMuaXNPblNjcmVlbigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxsU3VwZXIoJ3JlbmRlcicsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRleHQgYXMgYW4gYXJyYXkgb2YgbGluZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGV4dCB0byBzcGxpdFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gTGluZXMgaW4gdGhlIHRleHRcbiAgICAgKi9cbiAgICBfc3BsaXRUZXh0SW50b0xpbmVzOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KHRoaXMuX3JlTmV3bGluZSksXG4gICAgICAgICAgbmV3TGluZXMgPSBuZXcgQXJyYXkobGluZXMubGVuZ3RoKSxcbiAgICAgICAgICBuZXdMaW5lID0gWydcXG4nXSxcbiAgICAgICAgICBuZXdUZXh0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0xpbmVzW2ldID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQobGluZXNbaV0pO1xuICAgICAgICBuZXdUZXh0ID0gbmV3VGV4dC5jb25jYXQobmV3TGluZXNbaV0sIG5ld0xpbmUpO1xuICAgICAgfVxuICAgICAgbmV3VGV4dC5wb3AoKTtcbiAgICAgIHJldHVybiB7IF91bndyYXBwZWRMaW5lczogbmV3TGluZXMsIGxpbmVzOiBsaW5lcywgZ3JhcGhlbWVUZXh0OiBuZXdUZXh0LCBncmFwaGVtZUxpbmVzOiBuZXdMaW5lcyB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgYWxsUHJvcGVydGllcyA9IGFkZGl0aW9uYWxQcm9wcy5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICB2YXIgb2JqID0gdGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgYWxsUHJvcGVydGllcyk7XG4gICAgICBvYmouc3R5bGVzID0gZmFicmljLnV0aWwuc3R5bGVzVG9BcnJheSh0aGlzLnN0eWxlcywgdGhpcy50ZXh0KTtcbiAgICAgIGlmIChvYmoucGF0aCkge1xuICAgICAgICBvYmoucGF0aCA9IHRoaXMucGF0aC50b09iamVjdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBwcm9wZXJ0eSB0byBhIGdpdmVuIHZhbHVlLiBXaGVuIGNoYW5naW5nIHBvc2l0aW9uL2RpbWVuc2lvbiAtcmVsYXRlZCBwcm9wZXJ0aWVzIChsZWZ0LCB0b3AsIHNjYWxlLCBhbmdsZSwgZXRjLikgYHNldGAgZG9lcyBub3QgdXBkYXRlIHBvc2l0aW9uIG9mIG9iamVjdCdzIGJvcmRlcnMvY29udHJvbHMuIElmIHlvdSBuZWVkIHRvIHVwZGF0ZSB0aG9zZSwgY2FsbCBgc2V0Q29vcmRzKClgLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ga2V5IFByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IChpZiBvYmplY3QsIGl0ZXJhdGUgb3ZlciB0aGUgb2JqZWN0IHByb3BlcnRpZXMpXG4gICAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHZhbHVlIFByb3BlcnR5IHZhbHVlIChpZiBmdW5jdGlvbiwgdGhlIHZhbHVlIGlzIHBhc3NlZCBpbnRvIGl0IGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgYXMgYSBuZXcgb25lKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignc2V0Jywga2V5LCB2YWx1ZSk7XG4gICAgICB2YXIgbmVlZHNEaW1zID0gZmFsc2U7XG4gICAgICB2YXIgaXNBZGRpbmdQYXRoID0gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgX2tleSBpbiBrZXkpIHtcbiAgICAgICAgICBpZiAoX2tleSA9PT0gJ3BhdGgnKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhdGhJbmZvKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lZWRzRGltcyA9IG5lZWRzRGltcyB8fCB0aGlzLl9kaW1lbnNpb25BZmZlY3RpbmdQcm9wcy5pbmRleE9mKF9rZXkpICE9PSAtMTtcbiAgICAgICAgICBpc0FkZGluZ1BhdGggPSBpc0FkZGluZ1BhdGggfHwgX2tleSA9PT0gJ3BhdGgnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmVlZHNEaW1zID0gdGhpcy5fZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMuaW5kZXhPZihrZXkpICE9PSAtMTtcbiAgICAgICAgaXNBZGRpbmdQYXRoID0ga2V5ID09PSAncGF0aCc7XG4gICAgICB9XG4gICAgICBpZiAoaXNBZGRpbmdQYXRoKSB7XG4gICAgICAgIHRoaXMuc2V0UGF0aEluZm8oKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc0RpbXMpIHtcbiAgICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5UZXh0LmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3RleHQuaHRtbCNUZXh0RWxlbWVudFxuICAgKi9cbiAgZmFicmljLlRleHQuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdChcbiAgICAneCB5IGR4IGR5IGZvbnQtZmFtaWx5IGZvbnQtc3R5bGUgZm9udC13ZWlnaHQgZm9udC1zaXplIGxldHRlci1zcGFjaW5nIHRleHQtZGVjb3JhdGlvbiB0ZXh0LWFuY2hvcicuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgU1ZHIGZvbnQgc2l6ZVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKi9cbiAgZmFicmljLlRleHQuREVGQVVMVF9TVkdfRk9OVF9TSVpFID0gMTY7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlRleHQgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudCAoPGI+bm90IHlldCBpbXBsZW1lbnRlZDwvYj4pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgYWZ0ZXIgcGFyc2luZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuVGV4dC5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5UZXh0LkFUVFJJQlVURV9OQU1FUyksXG4gICAgICAgIHBhcnNlZEFuY2hvciA9IHBhcnNlZEF0dHJpYnV0ZXMudGV4dEFuY2hvciB8fCAnbGVmdCc7XG4gICAgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoKG9wdGlvbnMgPyBjbG9uZShvcHRpb25zKSA6IHsgfSksIHBhcnNlZEF0dHJpYnV0ZXMpO1xuXG4gICAgb3B0aW9ucy50b3AgPSBvcHRpb25zLnRvcCB8fCAwO1xuICAgIG9wdGlvbnMubGVmdCA9IG9wdGlvbnMubGVmdCB8fCAwO1xuICAgIGlmIChwYXJzZWRBdHRyaWJ1dGVzLnRleHREZWNvcmF0aW9uKSB7XG4gICAgICB2YXIgdGV4dERlY29yYXRpb24gPSBwYXJzZWRBdHRyaWJ1dGVzLnRleHREZWNvcmF0aW9uO1xuICAgICAgaWYgKHRleHREZWNvcmF0aW9uLmluZGV4T2YoJ3VuZGVybGluZScpICE9PSAtMSkge1xuICAgICAgICBvcHRpb25zLnVuZGVybGluZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGV4dERlY29yYXRpb24uaW5kZXhPZignb3ZlcmxpbmUnKSAhPT0gLTEpIHtcbiAgICAgICAgb3B0aW9ucy5vdmVybGluZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGV4dERlY29yYXRpb24uaW5kZXhPZignbGluZS10aHJvdWdoJykgIT09IC0xKSB7XG4gICAgICAgIG9wdGlvbnMubGluZXRocm91Z2ggPSB0cnVlO1xuICAgICAgfVxuICAgICAgZGVsZXRlIG9wdGlvbnMudGV4dERlY29yYXRpb247XG4gICAgfVxuICAgIGlmICgnZHgnIGluIHBhcnNlZEF0dHJpYnV0ZXMpIHtcbiAgICAgIG9wdGlvbnMubGVmdCArPSBwYXJzZWRBdHRyaWJ1dGVzLmR4O1xuICAgIH1cbiAgICBpZiAoJ2R5JyBpbiBwYXJzZWRBdHRyaWJ1dGVzKSB7XG4gICAgICBvcHRpb25zLnRvcCArPSBwYXJzZWRBdHRyaWJ1dGVzLmR5O1xuICAgIH1cbiAgICBpZiAoISgnZm9udFNpemUnIGluIG9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zLmZvbnRTaXplID0gZmFicmljLlRleHQuREVGQVVMVF9TVkdfRk9OVF9TSVpFO1xuICAgIH1cblxuICAgIHZhciB0ZXh0Q29udGVudCA9ICcnO1xuXG4gICAgLy8gVGhlIFhNTCBpcyBub3QgcHJvcGVybHkgcGFyc2VkIGluIElFOSBzbyBhIHdvcmthcm91bmQgdG8gZ2V0XG4gICAgLy8gdGV4dENvbnRlbnQgaXMgdGhyb3VnaCBmaXJzdENoaWxkLmRhdGEuIEFub3RoZXIgd29ya2Fyb3VuZCB3b3VsZCBiZVxuICAgIC8vIHRvIGNvbnZlcnQgWE1MIGxvYWRlZCBmcm9tIGEgZmlsZSB0byBiZSBjb252ZXJ0ZWQgdXNpbmcgRE9NUGFyc2VyIChzYW1lIHdheSBsb2FkU1ZHRnJvbVN0cmluZygpIGRvZXMpXG4gICAgaWYgKCEoJ3RleHRDb250ZW50JyBpbiBlbGVtZW50KSkge1xuICAgICAgaWYgKCdmaXJzdENoaWxkJyBpbiBlbGVtZW50ICYmIGVsZW1lbnQuZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoJ2RhdGEnIGluIGVsZW1lbnQuZmlyc3RDaGlsZCAmJiBlbGVtZW50LmZpcnN0Q2hpbGQuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRleHRDb250ZW50ID0gZWxlbWVudC5maXJzdENoaWxkLmRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0ZXh0Q29udGVudCA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgfVxuXG4gICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5yZXBsYWNlKC9eXFxzK3xcXHMrJHxcXG4rL2csICcnKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgdmFyIG9yaWdpbmFsU3Ryb2tlV2lkdGggPSBvcHRpb25zLnN0cm9rZVdpZHRoO1xuICAgIG9wdGlvbnMuc3Ryb2tlV2lkdGggPSAwO1xuXG4gICAgdmFyIHRleHQgPSBuZXcgZmFicmljLlRleHQodGV4dENvbnRlbnQsIG9wdGlvbnMpLFxuICAgICAgICB0ZXh0SGVpZ2h0U2NhbGVGYWN0b3IgPSB0ZXh0LmdldFNjYWxlZEhlaWdodCgpIC8gdGV4dC5oZWlnaHQsXG4gICAgICAgIGxpbmVIZWlnaHREaWZmID0gKHRleHQuaGVpZ2h0ICsgdGV4dC5zdHJva2VXaWR0aCkgKiB0ZXh0LmxpbmVIZWlnaHQgLSB0ZXh0LmhlaWdodCxcbiAgICAgICAgc2NhbGVkRGlmZiA9IGxpbmVIZWlnaHREaWZmICogdGV4dEhlaWdodFNjYWxlRmFjdG9yLFxuICAgICAgICB0ZXh0SGVpZ2h0ID0gdGV4dC5nZXRTY2FsZWRIZWlnaHQoKSArIHNjYWxlZERpZmYsXG4gICAgICAgIG9mZlggPSAwO1xuICAgIC8qXG4gICAgICBBZGp1c3QgcG9zaXRpb25pbmc6XG4gICAgICAgIHgveSBhdHRyaWJ1dGVzIGluIFNWRyBjb3JyZXNwb25kIHRvIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2YgdGV4dCBib3VuZGluZyBib3hcbiAgICAgICAgZmFicmljIG91dHB1dCBieSBkZWZhdWx0IGF0IHRvcCwgbGVmdC5cbiAgICAqL1xuICAgIGlmIChwYXJzZWRBbmNob3IgPT09ICdjZW50ZXInKSB7XG4gICAgICBvZmZYID0gdGV4dC5nZXRTY2FsZWRXaWR0aCgpIC8gMjtcbiAgICB9XG4gICAgaWYgKHBhcnNlZEFuY2hvciA9PT0gJ3JpZ2h0Jykge1xuICAgICAgb2ZmWCA9IHRleHQuZ2V0U2NhbGVkV2lkdGgoKTtcbiAgICB9XG4gICAgdGV4dC5zZXQoe1xuICAgICAgbGVmdDogdGV4dC5sZWZ0IC0gb2ZmWCxcbiAgICAgIHRvcDogdGV4dC50b3AgLSAodGV4dEhlaWdodCAtIHRleHQuZm9udFNpemUgKiAoMC4wNyArIHRleHQuX2ZvbnRTaXplRnJhY3Rpb24pKSAvIHRleHQubGluZUhlaWdodCxcbiAgICAgIHN0cm9rZVdpZHRoOiB0eXBlb2Ygb3JpZ2luYWxTdHJva2VXaWR0aCAhPT0gJ3VuZGVmaW5lZCcgPyBvcmlnaW5hbFN0cm9rZVdpZHRoIDogMSxcbiAgICB9KTtcbiAgICBjYWxsYmFjayh0ZXh0KTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVGV4dCBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHBsYWluIGpzIE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5UZXh0IGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5UZXh0LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9iamVjdENvcHkgPSBjbG9uZShvYmplY3QpLCBwYXRoID0gb2JqZWN0LnBhdGg7XG4gICAgZGVsZXRlIG9iamVjdENvcHkucGF0aDtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnVGV4dCcsIG9iamVjdENvcHksIGZ1bmN0aW9uKHRleHRJbnN0YW5jZSkge1xuICAgICAgdGV4dEluc3RhbmNlLnN0eWxlcyA9IGZhYnJpYy51dGlsLnN0eWxlc0Zyb21BcnJheShvYmplY3Quc3R5bGVzLCBvYmplY3QudGV4dCk7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdQYXRoJywgcGF0aCwgZnVuY3Rpb24ocGF0aEluc3RhbmNlKSB7XG4gICAgICAgICAgdGV4dEluc3RhbmNlLnNldCgncGF0aCcsIHBhdGhJbnN0YW5jZSk7XG4gICAgICAgICAgY2FsbGJhY2sodGV4dEluc3RhbmNlKTtcbiAgICAgICAgfSwgJ3BhdGgnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjYWxsYmFjayh0ZXh0SW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH0sICd0ZXh0Jyk7XG4gIH07XG5cbiAgZmFicmljLlRleHQuZ2VuZXJpY0ZvbnRzID0gWydzYW5zLXNlcmlmJywgJ3NlcmlmJywgJ2N1cnNpdmUnLCAnZmFudGFzeScsICdtb25vc3BhY2UnXTtcblxuICBmYWJyaWMudXRpbC5jcmVhdGVBY2Nlc3NvcnMgJiYgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzKGZhYnJpYy5UZXh0KTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlRleHQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBubyBzdHlsaW5nIG9yIG5vIHN0eWxpbmcgaW4gYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCAsIGxpbmVJbmRleCBpcyBvbiB3cmFwcGVkIGxpbmVzLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsaW5lSW5kZXggIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHR5cGVvZiBsaW5lSW5kZXggPT09ICd1bmRlZmluZWQnID8gdGhpcy5zdHlsZXMgOiB7IGxpbmU6IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gfTtcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgZm9yICh2YXIgcDMgaW4gb2JqW3AxXVtwMl0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBhIHN0eWxlIHByb3BlcnR5IG9yIGhhcyBpdCBpbmEgc3BlY2lmaWVkIGxpbmVcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZGV0ZWN0IGlmIGEgdGV4dCB3aWxsIHVzZSBhIHBhcnRpY3VsYXIgcHJvcGVydHkgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSB0byBjaGVjayBmb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IHRvIGNoZWNrIHRoZSBzdHlsZSBvblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3R5bGVIYXM6IGZ1bmN0aW9uKHByb3BlcnR5LCBsaW5lSW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMgfHwgIXByb3BlcnR5IHx8IHByb3BlcnR5ID09PSAnJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxpbmVJbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgIXRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHR5cGVvZiBsaW5lSW5kZXggPT09ICd1bmRlZmluZWQnID8gdGhpcy5zdHlsZXMgOiB7IDA6IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gfTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgZm9yICh2YXIgcDEgaW4gb2JqKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmpbcDFdW3AyXVtwcm9wZXJ0eV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY2hhcmFjdGVycyBpbiBhIHRleHQgaGF2ZSBhIHZhbHVlIGZvciBhIHByb3BlcnR5XG4gICAgICogd2hvc2UgdmFsdWUgbWF0Y2hlcyB0aGUgdGV4dGJveCdzIHZhbHVlIGZvciB0aGF0IHByb3BlcnR5LiAgSWYgc28sXG4gICAgICogdGhlIGNoYXJhY3Rlci1sZXZlbCBwcm9wZXJ0eSBpcyBkZWxldGVkLiAgSWYgdGhlIGNoYXJhY3RlclxuICAgICAqIGhhcyBubyBvdGhlciBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFsc28gZGVsZXRlZC4gIEZpbmFsbHksXG4gICAgICogaWYgdGhlIGxpbmUgY29udGFpbmluZyB0aGF0IGNoYXJhY3RlciBoYXMgbm8gb3RoZXIgY2hhcmFjdGVyc1xuICAgICAqIHRoZW4gaXQgYWxzbyBpcyBkZWxldGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBjb21wYXJlIGJldHdlZW4gY2hhcmFjdGVycyBhbmQgdGV4dC5cbiAgICAgKi9cbiAgICBjbGVhblN0eWxlOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcyB8fCAhcHJvcGVydHkgfHwgcHJvcGVydHkgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB0aGlzLnN0eWxlcywgc3R5bGVzQ291bnQgPSAwLCBsZXR0ZXJDb3VudCwgc3R5bGVQcm9wZXJ0eVZhbHVlLFxuICAgICAgICAgIGFsbFN0eWxlT2JqZWN0UHJvcGVydGllc01hdGNoID0gdHJ1ZSwgZ3JhcGhlbWVDb3VudCA9IDAsIHN0eWxlT2JqZWN0O1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBmb3IgKHZhciBwMSBpbiBvYmopIHtcbiAgICAgICAgbGV0dGVyQ291bnQgPSAwO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gb2JqW3AxXSkge1xuICAgICAgICAgIHZhciBzdHlsZU9iamVjdCA9IG9ialtwMV1bcDJdLFxuICAgICAgICAgICAgICBzdHlsZVByb3BlcnR5SGFzQmVlblNldCA9IHN0eWxlT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KTtcblxuICAgICAgICAgIHN0eWxlc0NvdW50Kys7XG5cbiAgICAgICAgICBpZiAoc3R5bGVQcm9wZXJ0eUhhc0JlZW5TZXQpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVQcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICAgIHN0eWxlUHJvcGVydHlWYWx1ZSA9IHN0eWxlT2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlT2JqZWN0W3Byb3BlcnR5XSAhPT0gc3R5bGVQcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICAgIGFsbFN0eWxlT2JqZWN0UHJvcGVydGllc01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHlsZU9iamVjdFtwcm9wZXJ0eV0gPT09IHRoaXNbcHJvcGVydHldKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZU9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoc3R5bGVPYmplY3QpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgbGV0dGVyQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqW3AxXVtwMl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxldHRlckNvdW50ID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIG9ialtwMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIGV2ZXJ5IGdyYXBoZW1lIGhhcyB0aGUgc2FtZSBzdHlsZSBzZXQgdGhlblxuICAgICAgLy8gZGVsZXRlIHRob3NlIHN0eWxlcyBhbmQgc2V0IGl0IG9uIHRoZSBwYXJlbnRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyYXBoZW1lQ291bnQgKz0gdGhpcy5fdGV4dExpbmVzW2ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChhbGxTdHlsZU9iamVjdFByb3BlcnRpZXNNYXRjaCAmJiBzdHlsZXNDb3VudCA9PT0gZ3JhcGhlbWVDb3VudCkge1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IHN0eWxlUHJvcGVydHlWYWx1ZTtcbiAgICAgICAgdGhpcy5yZW1vdmVTdHlsZShwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHN0eWxlIHByb3BlcnR5IG9yIHByb3BlcnRpZXMgZnJvbSBhbGwgaW5kaXZpZHVhbCBjaGFyYWN0ZXIgc3R5bGVzXG4gICAgICogaW4gYSB0ZXh0IG9iamVjdC4gIERlbGV0ZXMgdGhlIGNoYXJhY3RlciBzdHlsZSBvYmplY3QgaWYgaXQgY29udGFpbnMgbm8gb3RoZXIgc3R5bGVcbiAgICAgKiBwcm9wcy4gIERlbGV0ZXMgYSBsaW5lIHN0eWxlIG9iamVjdCBpZiBpdCBjb250YWlucyBubyBvdGhlciBjaGFyYWN0ZXIgc3R5bGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BzIFRoZSBwcm9wZXJ0eSB0byByZW1vdmUgZnJvbSBjaGFyYWN0ZXIgc3R5bGVzLlxuICAgICAqL1xuICAgIHJlbW92ZVN0eWxlOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcyB8fCAhcHJvcGVydHkgfHwgcHJvcGVydHkgPT09ICcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB0aGlzLnN0eWxlcywgbGluZSwgbGluZU51bSwgY2hhck51bTtcbiAgICAgIGZvciAobGluZU51bSBpbiBvYmopIHtcbiAgICAgICAgbGluZSA9IG9ialtsaW5lTnVtXTtcbiAgICAgICAgZm9yIChjaGFyTnVtIGluIGxpbmUpIHtcbiAgICAgICAgICBkZWxldGUgbGluZVtjaGFyTnVtXVtwcm9wZXJ0eV07XG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGxpbmVbY2hhck51bV0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGxpbmVbY2hhck51bV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhsaW5lKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqW2xpbmVOdW1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2V4dGVuZFN0eWxlczogZnVuY3Rpb24oaW5kZXgsIHN0eWxlcykge1xuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihpbmRleCk7XG5cbiAgICAgIGlmICghdGhpcy5fZ2V0TGluZVN0eWxlKGxvYy5saW5lSW5kZXgpKSB7XG4gICAgICAgIHRoaXMuX3NldExpbmVTdHlsZShsb2MubGluZUluZGV4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgpKSB7XG4gICAgICAgIHRoaXMuX3NldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwge30pO1xuICAgICAgfVxuXG4gICAgICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCksIHN0eWxlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgMmQgcmVwcmVzZW50YXRpb24gKGxpbmVJbmRleCBhbmQgY2hhckluZGV4KSBvZiBjdXJzb3IgKG9yIHNlbGVjdGlvbiBzdGFydClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlbGVjdGlvblN0YXJ0XSBPcHRpb25hbCBpbmRleC4gV2hlbiBub3QgZ2l2ZW4sIGN1cnJlbnQgc2VsZWN0aW9uU3RhcnQgaXMgdXNlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwV3JhcHBpbmddIGNvbnNpZGVyIHRoZSBsb2NhdGlvbiBmb3IgdW53cmFwcGVkIGxpbmVzLiB1c2VmdWwgdG8gbWFuYWdlIHN0eWxlcy5cbiAgICAgKi9cbiAgICBnZXQyREN1cnNvckxvY2F0aW9uOiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCwgc2tpcFdyYXBwaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdGlvblN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB9XG4gICAgICB2YXIgbGluZXMgPSBza2lwV3JhcHBpbmcgPyB0aGlzLl91bndyYXBwZWRUZXh0TGluZXMgOiB0aGlzLl90ZXh0TGluZXMsXG4gICAgICAgICAgbGVuID0gbGluZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPD0gbGluZXNbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmVJbmRleDogaSxcbiAgICAgICAgICAgIGNoYXJJbmRleDogc2VsZWN0aW9uU3RhcnRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvblN0YXJ0IC09IGxpbmVzW2ldLmxlbmd0aCArIHRoaXMubWlzc2luZ05ld2xpbmVPZmZzZXQoaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lSW5kZXg6IGkgLSAxLFxuICAgICAgICBjaGFySW5kZXg6IGxpbmVzW2kgLSAxXS5sZW5ndGggPCBzZWxlY3Rpb25TdGFydCA/IGxpbmVzW2kgLSAxXS5sZW5ndGggOiBzZWxlY3Rpb25TdGFydFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBzdHlsZSBvZiBhIGN1cnJlbnQgc2VsZWN0aW9uL2N1cnNvciAoYXQgdGhlIHN0YXJ0IHBvc2l0aW9uKVxuICAgICAqIGlmIHN0YXJ0SW5kZXggb3IgZW5kSW5kZXggYXJlIG5vdCBwcm92aWRlZCwgc2VsZWN0aW9uU3RhcnQgb3Igc2VsZWN0aW9uRW5kIHdpbGwgYmUgdXNlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0SW5kZXhdIFN0YXJ0IGluZGV4IHRvIGdldCBzdHlsZXMgYXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZEluZGV4XSBFbmQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdCwgaWYgbm90IHNwZWNpZmllZCBzZWxlY3Rpb25FbmQgb3Igc3RhcnRJbmRleCArIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wbGV0ZV0gZ2V0IGZ1bGwgc3R5bGUgb3Igbm90XG4gICAgICogQHJldHVybiB7QXJyYXl9IHN0eWxlcyBhbiBhcnJheSB3aXRoIG9uZSwgemVybyBvciBtb3JlIFN0eWxlIG9iamVjdHNcbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25TdHlsZXM6IGZ1bmN0aW9uKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBjb21wbGV0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdGFydEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdGFydEluZGV4ID0gdGhpcy5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbmRJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZW5kSW5kZXggPSB0aGlzLnNlbGVjdGlvbkVuZCB8fCBzdGFydEluZGV4O1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgIHN0eWxlcy5wdXNoKHRoaXMuZ2V0U3R5bGVBdFBvc2l0aW9uKGksIGNvbXBsZXRlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHN0eWxlIG9mIGEgY3VycmVudCBzZWxlY3Rpb24vY3Vyc29yIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uICB0byBnZXQgc3R5bGVzIGF0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29tcGxldGVdIGZ1bGwgc3R5bGUgaWYgdHJ1ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgU3R5bGUgb2JqZWN0IGF0IGEgc3BlY2lmaWVkIGluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRTdHlsZUF0UG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uLCBjb21wbGV0ZSkge1xuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihwb3NpdGlvbiksXG4gICAgICAgICAgc3R5bGUgPSBjb21wbGV0ZSA/IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgpIDpcbiAgICAgICAgICAgIHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCk7XG4gICAgICByZXR1cm4gc3R5bGUgfHwge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc3R5bGUgb2YgYSBjdXJyZW50IHNlbGVjdGlvbiwgaWYgbm8gc2VsZWN0aW9uIGV4aXN0LCBkbyBub3Qgc2V0IGFueXRoaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVzXSBTdHlsZXMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydEluZGV4XSBTdGFydCBpbmRleCB0byBnZXQgc3R5bGVzIGF0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRJbmRleF0gRW5kIGluZGV4IHRvIGdldCBzdHlsZXMgYXQsIGlmIG5vdCBzcGVjaWZpZWQgc2VsZWN0aW9uRW5kIG9yIHN0YXJ0SW5kZXggKyAxXG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0eWxlczogZnVuY3Rpb24oc3R5bGVzLCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgaWYgKHR5cGVvZiBzdGFydEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdGFydEluZGV4ID0gdGhpcy5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbmRJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZW5kSW5kZXggPSB0aGlzLnNlbGVjdGlvbkVuZCB8fCBzdGFydEluZGV4O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2V4dGVuZFN0eWxlcyhpLCBzdHlsZXMpO1xuICAgICAgfVxuICAgICAgLyogbm90IGluY2x1ZGVkIGluIF9leHRlbmRTdHlsZXMgdG8gYXZvaWQgY2xlYXJpbmcgY2FjaGUgbW9yZSB0aGFuIG9uY2UgKi9cbiAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSByZWZlcmVuY2UsIG5vdCBhIGNsb25lLCBvZiB0aGUgc3R5bGUgb2JqZWN0IGZvciBhIGdpdmVuIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBvYmplY3RcbiAgICAgKi9cbiAgICBfZ2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIHZhciBsaW5lU3R5bGUgPSB0aGlzLnN0eWxlcyAmJiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdO1xuICAgICAgaWYgKCFsaW5lU3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZVN0eWxlW2NoYXJJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIG5ldyBvYmplY3QgdGhhdCBjb250YWlucyBhbGwgdGhlIHN0eWxlIHByb3BlcnR5IGZvciBhIGNoYXJhY3RlclxuICAgICAqIHRoZSBvYmplY3QgcmV0dXJuZWQgaXMgbmV3bHkgY3JlYXRlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggb2YgdGhlIGxpbmUgd2hlcmUgdGhlIGNoYXJhY3RlciBpc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggcG9zaXRpb24gb2YgdGhlIGNoYXJhY3RlciBvbiB0aGUgbGluZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIHN0eWxlID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkgfHwgeyB9LFxuICAgICAgICAgIHN0eWxlT2JqZWN0ID0geyB9LCBwcm9wO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdHlsZVByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvcCA9IHRoaXMuX3N0eWxlUHJvcGVydGllc1tpXTtcbiAgICAgICAgc3R5bGVPYmplY3RbcHJvcF0gPSB0eXBlb2Ygc3R5bGVbcHJvcF0gPT09ICd1bmRlZmluZWQnID8gdGhpc1twcm9wXSA6IHN0eWxlW3Byb3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBzdHlsZSkge1xuICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdID0gc3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGlmIHRoZSBsaW5lIGV4aXN0cyBvciBub3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5zdHlsZXNbbGluZUluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsaW5lIHN0eWxlIHRvIGFuIGVtcHR5IG9iamVjdCBzbyB0aGF0IGlzIGluaXRpYWxpemVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleF07XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIHBhcnNlRGVjb3JhdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0LnRleHREZWNvcmF0aW9uKSB7XG4gICAgICBvYmplY3QudGV4dERlY29yYXRpb24uaW5kZXhPZigndW5kZXJsaW5lJykgPiAtMSAmJiAob2JqZWN0LnVuZGVybGluZSA9IHRydWUpO1xuICAgICAgb2JqZWN0LnRleHREZWNvcmF0aW9uLmluZGV4T2YoJ2xpbmUtdGhyb3VnaCcpID4gLTEgJiYgKG9iamVjdC5saW5ldGhyb3VnaCA9IHRydWUpO1xuICAgICAgb2JqZWN0LnRleHREZWNvcmF0aW9uLmluZGV4T2YoJ292ZXJsaW5lJykgPiAtMSAmJiAob2JqZWN0Lm92ZXJsaW5lID0gdHJ1ZSk7XG4gICAgICBkZWxldGUgb2JqZWN0LnRleHREZWNvcmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJVGV4dCBjbGFzcyAoaW50cm9kdWNlZCBpbiA8Yj52MS40PC9iPikgRXZlbnRzIGFyZSBhbHNvIGZpcmVkIHdpdGggXCJ0ZXh0OlwiXG4gICAqIHByZWZpeCB3aGVuIG9ic2VydmluZyBjYW52YXMuXG4gICAqIEBjbGFzcyBmYWJyaWMuSVRleHRcbiAgICogQGV4dGVuZHMgZmFicmljLlRleHRcbiAgICogQG1peGVzIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqXG4gICAqIEBmaXJlcyBjaGFuZ2VkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246Y2hhbmdlZFxuICAgKiBAZmlyZXMgZWRpdGluZzplbnRlcmVkXG4gICAqIEBmaXJlcyBlZGl0aW5nOmV4aXRlZFxuICAgKlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLklUZXh0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqXG4gICAqIDxwPlN1cHBvcnRlZCBrZXkgY29tYmluYXRpb25zOjwvcD5cbiAgICogPHByZT5cbiAgICogICBNb3ZlIGN1cnNvcjogICAgICAgICAgICAgICAgICAgIGxlZnQsIHJpZ2h0LCB1cCwgZG93blxuICAgKiAgIFNlbGVjdCBjaGFyYWN0ZXI6ICAgICAgICAgICAgICAgc2hpZnQgKyBsZWZ0LCBzaGlmdCArIHJpZ2h0XG4gICAqICAgU2VsZWN0IHRleHQgdmVydGljYWxseTogICAgICAgICBzaGlmdCArIHVwLCBzaGlmdCArIGRvd25cbiAgICogICBNb3ZlIGN1cnNvciBieSB3b3JkOiAgICAgICAgICAgIGFsdCArIGxlZnQsIGFsdCArIHJpZ2h0XG4gICAqICAgU2VsZWN0IHdvcmRzOiAgICAgICAgICAgICAgICAgICBzaGlmdCArIGFsdCArIGxlZnQsIHNoaWZ0ICsgYWx0ICsgcmlnaHRcbiAgICogICBNb3ZlIGN1cnNvciB0byBsaW5lIHN0YXJ0L2VuZDogIGNtZCArIGxlZnQsIGNtZCArIHJpZ2h0IG9yIGhvbWUsIGVuZFxuICAgKiAgIFNlbGVjdCB0aWxsIHN0YXJ0L2VuZCBvZiBsaW5lOiAgY21kICsgc2hpZnQgKyBsZWZ0LCBjbWQgKyBzaGlmdCArIHJpZ2h0IG9yIHNoaWZ0ICsgaG9tZSwgc2hpZnQgKyBlbmRcbiAgICogICBKdW1wIHRvIHN0YXJ0L2VuZCBvZiB0ZXh0OiAgICAgIGNtZCArIHVwLCBjbWQgKyBkb3duXG4gICAqICAgU2VsZWN0IHRpbGwgc3RhcnQvZW5kIG9mIHRleHQ6ICBjbWQgKyBzaGlmdCArIHVwLCBjbWQgKyBzaGlmdCArIGRvd24gb3Igc2hpZnQgKyBwZ1VwLCBzaGlmdCArIHBnRG93blxuICAgKiAgIERlbGV0ZSBjaGFyYWN0ZXI6ICAgICAgICAgICAgICAgYmFja3NwYWNlXG4gICAqICAgRGVsZXRlIHdvcmQ6ICAgICAgICAgICAgICAgICAgICBhbHQgKyBiYWNrc3BhY2VcbiAgICogICBEZWxldGUgbGluZTogICAgICAgICAgICAgICAgICAgIGNtZCArIGJhY2tzcGFjZVxuICAgKiAgIEZvcndhcmQgZGVsZXRlOiAgICAgICAgICAgICAgICAgZGVsZXRlXG4gICAqICAgQ29weSB0ZXh0OiAgICAgICAgICAgICAgICAgICAgICBjdHJsL2NtZCArIGNcbiAgICogICBQYXN0ZSB0ZXh0OiAgICAgICAgICAgICAgICAgICAgIGN0cmwvY21kICsgdlxuICAgKiAgIEN1dCB0ZXh0OiAgICAgICAgICAgICAgICAgICAgICAgY3RybC9jbWQgKyB4XG4gICAqICAgU2VsZWN0IGVudGlyZSB0ZXh0OiAgICAgICAgICAgICBjdHJsL2NtZCArIGFcbiAgICogICBRdWl0IGVkaXRpbmcgICAgICAgICAgICAgICAgICAgIHRhYiBvciBlc2NcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIDxwPlN1cHBvcnRlZCBtb3VzZS90b3VjaCBjb21iaW5hdGlvbjwvcD5cbiAgICogPHByZT5cbiAgICogICBQb3NpdGlvbiBjdXJzb3I6ICAgICAgICAgICAgICAgIGNsaWNrL3RvdWNoXG4gICAqICAgQ3JlYXRlIHNlbGVjdGlvbjogICAgICAgICAgICAgICBjbGljay90b3VjaCAmIGRyYWdcbiAgICogICBDcmVhdGUgc2VsZWN0aW9uOiAgICAgICAgICAgICAgIGNsaWNrICYgc2hpZnQgKyBjbGlja1xuICAgKiAgIFNlbGVjdCB3b3JkOiAgICAgICAgICAgICAgICAgICAgZG91YmxlIGNsaWNrXG4gICAqICAgU2VsZWN0IGxpbmU6ICAgICAgICAgICAgICAgICAgICB0cmlwbGUgY2xpY2tcbiAgICogPC9wcmU+XG4gICAqL1xuICBmYWJyaWMuSVRleHQgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuVGV4dCwgZmFicmljLk9ic2VydmFibGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2ktdGV4dCcsXG5cbiAgICAvKipcbiAgICAgKiBJbmRleCB3aGVyZSB0ZXh0IHNlbGVjdGlvbiBzdGFydHMgKG9yIHdoZXJlIGN1cnNvciBpcyB3aGVuIHRoZXJlIGlzIG5vIHNlbGVjdGlvbilcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvblN0YXJ0OiAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kZXggd2hlcmUgdGV4dCBzZWxlY3Rpb24gZW5kc1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uRW5kOiAwLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgdGV4dCBzZWxlY3Rpb25cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkNvbG9yOiAncmdiYSgxNywxMTksMjU1LDAuMyknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGV4dCBpcyBpbiBlZGl0aW5nIG1vZGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpc0VkaXRpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgYSB0ZXh0IGNhbiBiZSBlZGl0ZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBlZGl0YWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEJvcmRlciBjb2xvciBvZiB0ZXh0IG9iamVjdCB3aGlsZSBpdCdzIGluIGVkaXRpbmcgbW9kZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZWRpdGluZ0JvcmRlckNvbG9yOiAncmdiYSgxMDIsMTUzLDI1NSwwLjI1KScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBjdXJzb3IgKGluIHB4KVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yV2lkdGg6IDIsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiB0ZXh0IGN1cnNvciBjb2xvciBpbiBlZGl0aW5nIG1vZGUuXG4gICAgICogaWYgbm90IHNldCAoZGVmYXVsdCkgd2lsbCB0YWtlIGNvbG9yIGZyb20gdGhlIHRleHQuXG4gICAgICogaWYgc2V0IHRvIGEgY29sb3IgdmFsdWUgdGhhdCBmYWJyaWMgY2FuIHVuZGVyc3RhbmQsIGl0IHdpbGxcbiAgICAgKiBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGNvbG9yIG9mIHRoZSB0ZXh0IGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yQ29sb3I6ICcnLFxuXG4gICAgLyoqXG4gICAgICogRGVsYXkgYmV0d2VlbiBjdXJzb3IgYmxpbmsgKGluIG1zKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yRGVsYXk6IDEwMDAsXG5cbiAgICAvKipcbiAgICAgKiBEdXJhdGlvbiBvZiBjdXJzb3IgZmFkZWluIChpbiBtcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGN1cnNvckR1cmF0aW9uOiA2MDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBpbnRlcm5hbCB0ZXh0IGNoYXIgd2lkdGhzIGNhbiBiZSBjYWNoZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjYWNoaW5nOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRE9NIGNvbnRhaW5lciB0byBhcHBlbmQgdGhlIGhpZGRlblRleHRhcmVhLlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGF0dGFjaGluZyB0byB0aGUgZG9jdW1lbnQuYm9keS5cbiAgICAgKiBVc2VmdWwgdG8gcmVkdWNlIGxhZ2dpc2ggcmVkcmF3IG9mIHRoZSBmdWxsIGRvY3VtZW50LmJvZHkgdHJlZSBhbmRcbiAgICAgKiBhbHNvIHdpdGggbW9kYWxzIGV2ZW50IGNhcHR1cmluZyB0aGF0IHdvbid0IGxldCB0aGUgdGV4dGFyZWEgdGFrZSBmb2N1cy5cbiAgICAgKiBAdHlwZSBIVE1MRWxlbWVudFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGlkZGVuVGV4dGFyZWFDb250YWluZXI6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZVNwYWNlOiAvXFxzfFxcbi8sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jdXJyZW50Q3Vyc29yT3BhY2l0eTogMCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlbGVjdGlvbkRpcmVjdGlvbjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Fib3J0Q3Vyc29yQW5pbWF0aW9uOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX193aWR0aE9mU3BhY2U6IFtdLFxuXG4gICAgLyoqXG4gICAgICogSGVscHMgZGV0ZXJtaW5pbmcgd2hlbiB0aGUgdGV4dCBpcyBpbiBjb21wb3NpdGlvbiwgc28gdGhhdCB0aGUgY3Vyc29yXG4gICAgICogcmVuZGVyaW5nIGlzIGFsdGVyZWQuXG4gICAgICovXG4gICAgaW5Db21wb3NpdGlvbk1vZGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbih0ZXh0LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIHRleHQsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5pbml0QmVoYXZpb3IoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzZWxlY3Rpb24gc3RhcnQgKGxlZnQgYm91bmRhcnkgb2YgYSBzZWxlY3Rpb24pXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEluZGV4IHRvIHNldCBzZWxlY3Rpb24gc3RhcnQgdG9cbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25TdGFydDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoaW5kZXgsIDApO1xuICAgICAgdGhpcy5fdXBkYXRlQW5kRmlyZSgnc2VsZWN0aW9uU3RhcnQnLCBpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc2VsZWN0aW9uIGVuZCAocmlnaHQgYm91bmRhcnkgb2YgYSBzZWxlY3Rpb24pXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEluZGV4IHRvIHNldCBzZWxlY3Rpb24gZW5kIHRvXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uRW5kOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdGhpcy50ZXh0Lmxlbmd0aCk7XG4gICAgICB0aGlzLl91cGRhdGVBbmRGaXJlKCdzZWxlY3Rpb25FbmQnLCBpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5ICdzZWxlY3Rpb25TdGFydCcgb3IgJ3NlbGVjdGlvbkVuZCdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggbmV3IHBvc2l0aW9uIG9mIHByb3BlcnR5XG4gICAgICovXG4gICAgX3VwZGF0ZUFuZEZpcmU6IGZ1bmN0aW9uKHByb3BlcnR5LCBpbmRleCkge1xuICAgICAgaWYgKHRoaXNbcHJvcGVydHldICE9PSBpbmRleCkge1xuICAgICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGluZGV4O1xuICAgICAgfVxuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlyZXMgdGhlIGV2ZW4gb2Ygc2VsZWN0aW9uIGNoYW5nZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlU2VsZWN0aW9uQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjaGFuZ2VkJyk7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OnNlbGVjdGlvbjpjaGFuZ2VkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGV4dCBkaW1lbnNpb25zLiBSZW5kZXIgYWxsIHRleHQgb24gZ2l2ZW4gY29udGV4dFxuICAgICAqIG9yIG9uIGEgb2Zmc2NyZWVuIGNhbnZhcyB0byBnZXQgdGhlIHRleHQgd2lkdGggd2l0aCBtZWFzdXJlVGV4dC5cbiAgICAgKiBVcGRhdGVzIHRoaXMud2lkdGggYW5kIHRoaXMuaGVpZ2h0IHdpdGggdGhlIHByb3BlciB2YWx1ZXMuXG4gICAgICogRG9lcyBub3QgcmV0dXJuIGRpbWVuc2lvbnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzRWRpdGluZyAmJiB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dFRvcCgpO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXREaW1lbnNpb25zJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dFRvcCgpO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ3JlbmRlcicsIGN0eCk7XG4gICAgICAvLyBjbGVhciB0aGUgY3Vyc29yT2Zmc2V0Q2FjaGUsIHNvIHdlIGVuc3VyZSB0byBjYWxjdWxhdGUgb25jZSBwZXIgcmVuZGVyQ3Vyc29yXG4gICAgICAvLyB0aGUgY29ycmVjdCBwb3NpdGlvbiBidXQgbm90IGF0IGV2ZXJ5IGN1cnNvciBhbmltYXRpb24uXG4gICAgICB0aGlzLmN1cnNvck9mZnNldENhY2hlID0geyB9O1xuICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfcmVuZGVyJywgY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSBhbmQgY2xlYW4gdGhlIGNvbnRleHRUb3BcbiAgICAgKi9cbiAgICBjbGVhckNvbnRleHRUb3A6IGZ1bmN0aW9uKHNraXBSZXN0b3JlKSB7XG4gICAgICBpZiAoIXRoaXMuaXNFZGl0aW5nIHx8ICF0aGlzLmNhbnZhcyB8fCAhdGhpcy5jYW52YXMuY29udGV4dFRvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcCwgdiA9IHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICB0aGlzLnRyYW5zZm9ybShjdHgpO1xuICAgICAgdGhpcy5fY2xlYXJUZXh0QXJlYShjdHgpO1xuICAgICAgc2tpcFJlc3RvcmUgfHwgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgY3Vyc29yIG9yIHNlbGVjdGlvbiAoZGVwZW5kaW5nIG9uIHdoYXQgZXhpc3RzKVxuICAgICAqIGl0IGRvZXMgb24gdGhlIGNvbnRleHRUb3AuIElmIGNvbnRleHRUb3AgaXMgbm90IGF2YWlsYWJsZSwgZG8gbm90aGluZy5cbiAgICAgKi9cbiAgICByZW5kZXJDdXJzb3JPclNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaXNFZGl0aW5nIHx8ICF0aGlzLmNhbnZhcyB8fCAhdGhpcy5jYW52YXMuY29udGV4dFRvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYm91bmRhcmllcyA9IHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXMoKSxcbiAgICAgICAgICBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHRUb3AodHJ1ZSk7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJDdXJzb3IoYm91bmRhcmllcywgY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnJlbmRlclNlbGVjdGlvbihib3VuZGFyaWVzLCBjdHgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgX2NsZWFyVGV4dEFyZWE6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgLy8gd2UgYWRkIDQgcGl4ZWwsIHRvIGJlIHN1cmUgdG8gZG8gbm90IGxlYXZlIGFueSBwaXhlbCBvdXRcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGggKyA0LCBoZWlnaHQgPSB0aGlzLmhlaWdodCArIDQ7XG4gICAgICBjdHguY2xlYXJSZWN0KC13aWR0aCAvIDIsIC1oZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJzb3IgYm91bmRhcmllcyAobGVmdCwgdG9wLCBsZWZ0T2Zmc2V0LCB0b3BPZmZzZXQpXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjaGFycyBBcnJheSBvZiBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVPZkJvdW5kYXJpZXNcbiAgICAgKi9cbiAgICBfZ2V0Q3Vyc29yQm91bmRhcmllczogZnVuY3Rpb24ocG9zaXRpb24pIHtcblxuICAgICAgLy8gbGVmdC90b3AgYXJlIGxlZnQvdG9wIG9mIGVudGlyZSB0ZXh0IGJveFxuICAgICAgLy8gbGVmdE9mZnNldC90b3BPZmZzZXQgYXJlIG9mZnNldCBmcm9tIHRoYXQgbGVmdC90b3AgcG9pbnQgb2YgYSB0ZXh0IGJveFxuXG4gICAgICBpZiAodHlwZW9mIHBvc2l0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWZ0ID0gdGhpcy5fZ2V0TGVmdE9mZnNldCgpLFxuICAgICAgICAgIHRvcCA9IHRoaXMuX2dldFRvcE9mZnNldCgpLFxuICAgICAgICAgIG9mZnNldHMgPSB0aGlzLl9nZXRDdXJzb3JCb3VuZGFyaWVzT2Zmc2V0cyhwb3NpdGlvbik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgbGVmdE9mZnNldDogb2Zmc2V0cy5sZWZ0LFxuICAgICAgICB0b3BPZmZzZXQ6IG9mZnNldHMudG9wXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDdXJzb3JCb3VuZGFyaWVzT2Zmc2V0czogZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgIGlmICh0aGlzLmN1cnNvck9mZnNldENhY2hlICYmICd0b3AnIGluIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGU7XG4gICAgICB9XG4gICAgICB2YXIgbGluZUxlZnRPZmZzZXQsXG4gICAgICAgICAgbGluZUluZGV4LFxuICAgICAgICAgIGNoYXJJbmRleCxcbiAgICAgICAgICB0b3BPZmZzZXQgPSAwLFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSAwLFxuICAgICAgICAgIGJvdW5kYXJpZXMsXG4gICAgICAgICAgY3Vyc29yUG9zaXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24ocG9zaXRpb24pO1xuICAgICAgY2hhckluZGV4ID0gY3Vyc29yUG9zaXRpb24uY2hhckluZGV4O1xuICAgICAgbGluZUluZGV4ID0gY3Vyc29yUG9zaXRpb24ubGluZUluZGV4O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lSW5kZXg7IGkrKykge1xuICAgICAgICB0b3BPZmZzZXQgKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSk7XG4gICAgICB9XG4gICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVJbmRleCk7XG4gICAgICB2YXIgYm91bmQgPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2NoYXJJbmRleF07XG4gICAgICBib3VuZCAmJiAobGVmdE9mZnNldCA9IGJvdW5kLmxlZnQpO1xuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDAgJiYgY2hhckluZGV4ID09PSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XS5sZW5ndGgpIHtcbiAgICAgICAgbGVmdE9mZnNldCAtPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgIH1cbiAgICAgIGJvdW5kYXJpZXMgPSB7XG4gICAgICAgIHRvcDogdG9wT2Zmc2V0LFxuICAgICAgICBsZWZ0OiBsaW5lTGVmdE9mZnNldCArIChsZWZ0T2Zmc2V0ID4gMCA/IGxlZnRPZmZzZXQgOiAwKSxcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgIGJvdW5kYXJpZXMubGVmdCAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSBib3VuZGFyaWVzO1xuICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgY3Vyc29yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJvdW5kYXJpZXNcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IHRyYW5zZm9ybWVkIGNvbnRleHQgdG8gZHJhdyBvblxuICAgICAqL1xuICAgIHJlbmRlckN1cnNvcjogZnVuY3Rpb24oYm91bmRhcmllcywgY3R4KSB7XG4gICAgICB2YXIgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oKSxcbiAgICAgICAgICBsaW5lSW5kZXggPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4ID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4ID4gMCA/IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCAtIDEgOiAwLFxuICAgICAgICAgIGNoYXJIZWlnaHQgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZm9udFNpemUnKSxcbiAgICAgICAgICBtdWx0aXBsaWVyID0gdGhpcy5zY2FsZVggKiB0aGlzLmNhbnZhcy5nZXRab29tKCksXG4gICAgICAgICAgY3Vyc29yV2lkdGggPSB0aGlzLmN1cnNvcldpZHRoIC8gbXVsdGlwbGllcixcbiAgICAgICAgICB0b3BPZmZzZXQgPSBib3VuZGFyaWVzLnRvcE9mZnNldCxcbiAgICAgICAgICBkeSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZUluZGV4LCBjaGFySW5kZXgsICdkZWx0YVknKTtcbiAgICAgIHRvcE9mZnNldCArPSAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pICogdGhpcy5nZXRIZWlnaHRPZkxpbmUobGluZUluZGV4KSAvIHRoaXMubGluZUhlaWdodFxuICAgICAgICAtIGNoYXJIZWlnaHQgKiAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pO1xuXG4gICAgICBpZiAodGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgICB0aGlzLnJlbmRlclNlbGVjdGlvbihib3VuZGFyaWVzLCBjdHgpO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY3Vyc29yQ29sb3IgfHwgdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsaW5lSW5kZXgsIGNoYXJJbmRleCwgJ2ZpbGwnKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuX19pc01vdXNlZG93biA/IDEgOiB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eTtcbiAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgYm91bmRhcmllcy5sZWZ0ICsgYm91bmRhcmllcy5sZWZ0T2Zmc2V0IC0gY3Vyc29yV2lkdGggLyAyLFxuICAgICAgICB0b3BPZmZzZXQgKyBib3VuZGFyaWVzLnRvcCArIGR5LFxuICAgICAgICBjdXJzb3JXaWR0aCxcbiAgICAgICAgY2hhckhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGV4dCBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYm91bmRhcmllcyBPYmplY3Qgd2l0aCBsZWZ0L3RvcC9sZWZ0T2Zmc2V0L3RvcE9mZnNldFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdHJhbnNmb3JtZWQgY29udGV4dCB0byBkcmF3IG9uXG4gICAgICovXG4gICAgcmVuZGVyU2VsZWN0aW9uOiBmdW5jdGlvbihib3VuZGFyaWVzLCBjdHgpIHtcblxuICAgICAgdmFyIHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA/IHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQgOiB0aGlzLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIHNlbGVjdGlvbkVuZCA9IHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPyB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvbkVuZCA6IHRoaXMuc2VsZWN0aW9uRW5kLFxuICAgICAgICAgIGlzSnVzdGlmeSA9IHRoaXMudGV4dEFsaWduLmluZGV4T2YoJ2p1c3RpZnknKSAhPT0gLTEsXG4gICAgICAgICAgc3RhcnQgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uU3RhcnQpLFxuICAgICAgICAgIGVuZCA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25FbmQpLFxuICAgICAgICAgIHN0YXJ0TGluZSA9IHN0YXJ0LmxpbmVJbmRleCxcbiAgICAgICAgICBlbmRMaW5lID0gZW5kLmxpbmVJbmRleCxcbiAgICAgICAgICBzdGFydENoYXIgPSBzdGFydC5jaGFySW5kZXggPCAwID8gMCA6IHN0YXJ0LmNoYXJJbmRleCxcbiAgICAgICAgICBlbmRDaGFyID0gZW5kLmNoYXJJbmRleCA8IDAgPyAwIDogZW5kLmNoYXJJbmRleDtcblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmVPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChpKSB8fCAwLFxuICAgICAgICAgICAgbGluZUhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpLFxuICAgICAgICAgICAgcmVhbExpbmVIZWlnaHQgPSAwLCBib3hTdGFydCA9IDAsIGJveEVuZCA9IDA7XG5cbiAgICAgICAgaWYgKGkgPT09IHN0YXJ0TGluZSkge1xuICAgICAgICAgIGJveFN0YXJ0ID0gdGhpcy5fX2NoYXJCb3VuZHNbc3RhcnRMaW5lXVtzdGFydENoYXJdLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPj0gc3RhcnRMaW5lICYmIGkgPCBlbmRMaW5lKSB7XG4gICAgICAgICAgYm94RW5kID0gaXNKdXN0aWZ5ICYmICF0aGlzLmlzRW5kT2ZXcmFwcGluZyhpKSA/IHRoaXMud2lkdGggOiB0aGlzLmdldExpbmVXaWR0aChpKSB8fCA1OyAvLyBXVEYgaXMgdGhpcyA1P1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGkgPT09IGVuZExpbmUpIHtcbiAgICAgICAgICBpZiAoZW5kQ2hhciA9PT0gMCkge1xuICAgICAgICAgICAgYm94RW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbZW5kTGluZV1bZW5kQ2hhcl0ubGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2hhclNwYWNpbmcgPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgICAgICAgIGJveEVuZCA9IHRoaXMuX19jaGFyQm91bmRzW2VuZExpbmVdW2VuZENoYXIgLSAxXS5sZWZ0XG4gICAgICAgICAgICAgICsgdGhpcy5fX2NoYXJCb3VuZHNbZW5kTGluZV1bZW5kQ2hhciAtIDFdLndpZHRoIC0gY2hhclNwYWNpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlYWxMaW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMubGluZUhlaWdodCA8IDEgfHwgKGkgPT09IGVuZExpbmUgJiYgdGhpcy5saW5lSGVpZ2h0ID4gMSkpIHtcbiAgICAgICAgICBsaW5lSGVpZ2h0IC89IHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZHJhd1N0YXJ0ID0gYm91bmRhcmllcy5sZWZ0ICsgbGluZU9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICAgICAgZHJhd1dpZHRoID0gYm94RW5kIC0gYm94U3RhcnQsXG4gICAgICAgICAgICBkcmF3SGVpZ2h0ID0gbGluZUhlaWdodCwgZXh0cmFUb3AgPSAwO1xuICAgICAgICBpZiAodGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbXBvc2l0aW9uQ29sb3IgfHwgJ2JsYWNrJztcbiAgICAgICAgICBkcmF3SGVpZ2h0ID0gMTtcbiAgICAgICAgICBleHRyYVRvcCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuc2VsZWN0aW9uQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICAgIGRyYXdTdGFydCA9IHRoaXMud2lkdGggLSBkcmF3U3RhcnQgLSBkcmF3V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgIGRyYXdTdGFydCxcbiAgICAgICAgICBib3VuZGFyaWVzLnRvcCArIGJvdW5kYXJpZXMudG9wT2Zmc2V0ICsgZXh0cmFUb3AsXG4gICAgICAgICAgZHJhd1dpZHRoLFxuICAgICAgICAgIGRyYXdIZWlnaHQpO1xuICAgICAgICBib3VuZGFyaWVzLnRvcE9mZnNldCArPSByZWFsTGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlnaCBsZXZlbCBmdW5jdGlvbiB0byBrbm93IHRoZSBoZWlnaHQgb2YgdGhlIGN1cnNvci5cbiAgICAgKiB0aGUgY3VycmVudENoYXIgaXMgdGhlIG9uZSB0aGF0IHByZWNlZGVzIHRoZSBjdXJzb3JcbiAgICAgKiBSZXR1cm5zIGZvbnRTaXplIG9mIGNoYXIgYXQgdGhlIGN1cnJlbnQgY3Vyc29yXG4gICAgICogVW51c2VkIGZyb20gdGhlIGxpYnJhcnksIGlzIGZvciB0aGUgZW5kIHVzZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IENoYXJhY3RlciBmb250IHNpemVcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50Q2hhckZvbnRTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjcCA9IHRoaXMuX2dldEN1cnJlbnRDaGFySW5kZXgoKTtcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGNwLmwsIGNwLmMsICdmb250U2l6ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWdoIGxldmVsIGZ1bmN0aW9uIHRvIGtub3cgdGhlIGNvbG9yIG9mIHRoZSBjdXJzb3IuXG4gICAgICogdGhlIGN1cnJlbnRDaGFyIGlzIHRoZSBvbmUgdGhhdCBwcmVjZWRlcyB0aGUgY3Vyc29yXG4gICAgICogUmV0dXJucyBjb2xvciAoZmlsbCkgb2YgY2hhciBhdCB0aGUgY3VycmVudCBjdXJzb3JcbiAgICAgKiBpZiB0aGUgdGV4dCBvYmplY3QgaGFzIGEgcGF0dGVybiBvciBncmFkaWVudCBmb3IgZmlsbGVyLCBpdCB3aWxsIHJldHVybiB0aGF0LlxuICAgICAqIFVudXNlZCBieSB0aGUgbGlicmFyeSwgaXMgZm9yIHRoZSBlbmQgdXNlclxuICAgICAqIEByZXR1cm4ge1N0cmluZyB8IGZhYnJpYy5HcmFkaWVudCB8IGZhYnJpYy5QYXR0ZXJufSBDaGFyYWN0ZXIgY29sb3IgKGZpbGwpXG4gICAgICovXG4gICAgZ2V0Q3VycmVudENoYXJDb2xvcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3AgPSB0aGlzLl9nZXRDdXJyZW50Q2hhckluZGV4KCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChjcC5sLCBjcC5jLCAnZmlsbCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJzb3IgcG9zaXRpb24gZm9yIHRoZSBnZXRDdXJyZW50Li4gZnVuY3Rpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q3VycmVudENoYXJJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3Vyc29yUG9zaXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24odGhpcy5zZWxlY3Rpb25TdGFydCwgdHJ1ZSksXG4gICAgICAgICAgY2hhckluZGV4ID0gY3Vyc29yUG9zaXRpb24uY2hhckluZGV4ID4gMCA/IGN1cnNvclBvc2l0aW9uLmNoYXJJbmRleCAtIDEgOiAwO1xuICAgICAgcmV0dXJuIHsgbDogY3Vyc29yUG9zaXRpb24ubGluZUluZGV4LCBjOiBjaGFySW5kZXggfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5JVGV4dCBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSVRleHRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGFyZ3VtZW50XG4gICAqL1xuICBmYWJyaWMuSVRleHQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgc3R5bGVzID0gZmFicmljLnV0aWwuc3R5bGVzRnJvbUFycmF5KG9iamVjdC5zdHlsZXMsIG9iamVjdC50ZXh0KTtcbiAgICAvL2NvcHkgb2JqZWN0IHRvIHByZXZlbnQgbXV0YXRpb25cbiAgICB2YXIgb2JqQ29weSA9IE9iamVjdC5hc3NpZ24oe30sIG9iamVjdCwgeyBzdHlsZXM6IHN0eWxlcyB9KTtcbiAgICBwYXJzZURlY29yYXRpb24ob2JqQ29weSk7XG4gICAgaWYgKG9iakNvcHkuc3R5bGVzKSB7XG4gICAgICBmb3IgKHZhciBpIGluIG9iakNvcHkuc3R5bGVzKSB7XG4gICAgICAgIGZvciAodmFyIGogaW4gb2JqQ29weS5zdHlsZXNbaV0pIHtcbiAgICAgICAgICBwYXJzZURlY29yYXRpb24ob2JqQ29weS5zdHlsZXNbaV1bal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0lUZXh0Jywgb2JqQ29weSwgY2FsbGJhY2ssICd0ZXh0Jyk7XG4gIH07XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYWxsIHRoZSBpbnRlcmFjdGl2ZSBiZWhhdmlvciBvZiBJVGV4dFxuICAgICAqL1xuICAgIGluaXRCZWhhdmlvcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmluaXRBZGRlZEhhbmRsZXIoKTtcbiAgICAgIHRoaXMuaW5pdFJlbW92ZWRIYW5kbGVyKCk7XG4gICAgICB0aGlzLmluaXRDdXJzb3JTZWxlY3Rpb25IYW5kbGVycygpO1xuICAgICAgdGhpcy5pbml0RG91YmxlQ2xpY2tTaW11bGF0aW9uKCk7XG4gICAgICB0aGlzLm1vdXNlTW92ZUhhbmRsZXIgPSB0aGlzLm1vdXNlTW92ZUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB9LFxuXG4gICAgb25EZXNlbGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzRWRpdGluZyAmJiB0aGlzLmV4aXRFZGl0aW5nKCk7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIFwiYWRkZWRcIiBldmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgaW5pdEFkZGVkSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5vbignYWRkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IF90aGlzLmNhbnZhcztcbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIGlmICghY2FudmFzLl9oYXNJVGV4dEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBjYW52YXMuX2hhc0lUZXh0SGFuZGxlcnMgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuX2luaXRDYW52YXNIYW5kbGVycyhjYW52YXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzID0gY2FudmFzLl9pVGV4dEluc3RhbmNlcyB8fCBbXTtcbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzLnB1c2goX3RoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW5pdFJlbW92ZWRIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLm9uKCdyZW1vdmVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBfdGhpcy5jYW52YXM7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzID0gY2FudmFzLl9pVGV4dEluc3RhbmNlcyB8fCBbXTtcbiAgICAgICAgICBmYWJyaWMudXRpbC5yZW1vdmVGcm9tQXJyYXkoY2FudmFzLl9pVGV4dEluc3RhbmNlcywgX3RoaXMpO1xuICAgICAgICAgIGlmIChjYW52YXMuX2lUZXh0SW5zdGFuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY2FudmFzLl9oYXNJVGV4dEhhbmRsZXJzID0gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy5fcmVtb3ZlQ2FudmFzSGFuZGxlcnMoY2FudmFzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZWdpc3RlciBjYW52YXMgZXZlbnQgdG8gbWFuYWdlIGV4aXRpbmcgb24gb3RoZXIgaW5zdGFuY2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdENhbnZhc0hhbmRsZXJzOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIGNhbnZhcy5fbW91c2VVcElUZXh0SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoY2FudmFzLl9pVGV4dEluc3RhbmNlcykge1xuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIG9iai5fX2lzTW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjYW52YXMub24oJ21vdXNlOnVwJywgY2FudmFzLl9tb3VzZVVwSVRleHRIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGNhbnZhcyBldmVudCB0byBtYW5hZ2UgZXhpdGluZyBvbiBvdGhlciBpbnN0YW5jZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVDYW52YXNIYW5kbGVyczogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICBjYW52YXMub2ZmKCdtb3VzZTp1cCcsIGNhbnZhcy5fbW91c2VVcElUZXh0SGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY3VycmVudFRpY2tTdGF0ZSA9IHRoaXMuX2FuaW1hdGVDdXJzb3IodGhpcywgMSwgdGhpcy5jdXJzb3JEdXJhdGlvbiwgJ19vblRpY2tDb21wbGV0ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hbmltYXRlQ3Vyc29yOiBmdW5jdGlvbihvYmosIHRhcmdldE9wYWNpdHksIGR1cmF0aW9uLCBjb21wbGV0ZU1ldGhvZCkge1xuXG4gICAgICB2YXIgdGlja1N0YXRlO1xuXG4gICAgICB0aWNrU3RhdGUgPSB7XG4gICAgICAgIGlzQWJvcnRlZDogZmFsc2UsXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmlzQWJvcnRlZCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBvYmouYW5pbWF0ZSgnX2N1cnJlbnRDdXJzb3JPcGFjaXR5JywgdGFyZ2V0T3BhY2l0eSwge1xuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghdGlja1N0YXRlLmlzQWJvcnRlZCkge1xuICAgICAgICAgICAgb2JqW2NvbXBsZXRlTWV0aG9kXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGFuaW1hdGUgYSBzZWxlY3Rpb24sIG9ubHkgY3Vyc29yXG4gICAgICAgICAgaWYgKG9iai5jYW52YXMgJiYgb2JqLnNlbGVjdGlvblN0YXJ0ID09PSBvYmouc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICBvYmoucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGlja1N0YXRlLmlzQWJvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGlja1N0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblRpY2tDb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9jdXJzb3JUaW1lb3V0MSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fY3Vyc29yVGltZW91dDEpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY3Vyc29yVGltZW91dDEgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlID0gX3RoaXMuX2FuaW1hdGVDdXJzb3IoX3RoaXMsIDAsIHRoaXMuY3Vyc29yRHVyYXRpb24gLyAyLCAnX3RpY2snKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGRlbGF5ZWQgY3Vyc29yXG4gICAgICovXG4gICAgaW5pdERlbGF5ZWRDdXJzb3I6IGZ1bmN0aW9uKHJlc3RhcnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgZGVsYXkgPSByZXN0YXJ0ID8gMCA6IHRoaXMuY3Vyc29yRGVsYXk7XG5cbiAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMTtcbiAgICAgIHRoaXMuX2N1cnNvclRpbWVvdXQyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuX3RpY2soKTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWJvcnRzIGN1cnNvciBhbmltYXRpb24gYW5kIGNsZWFycyBhbGwgdGltZW91dHNcbiAgICAgKi9cbiAgICBhYm9ydEN1cnNvckFuaW1hdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2hvdWxkQ2xlYXIgPSB0aGlzLl9jdXJyZW50VGlja1N0YXRlIHx8IHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZSxcbiAgICAgICAgICBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUgJiYgdGhpcy5fY3VycmVudFRpY2tTdGF0ZS5hYm9ydCgpO1xuICAgICAgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlICYmIHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZS5hYm9ydCgpO1xuXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fY3Vyc29yVGltZW91dDEpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2N1cnNvclRpbWVvdXQyKTtcblxuICAgICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAwO1xuICAgICAgLy8gdG8gY2xlYXIganVzdCBpdGV4dCBhcmVhIHdlIG5lZWQgdG8gdHJhbnNmb3JtIHRoZSBjb250ZXh0XG4gICAgICAvLyBpdCBtYXkgbm90IGJlIHdvcnRoIGl0XG4gICAgICBpZiAoc2hvdWxkQ2xlYXIgJiYgY2FudmFzKSB7XG4gICAgICAgIGNhbnZhcy5jbGVhckNvbnRleHQoY2FudmFzLmNvbnRleHRUb3AgfHwgY2FudmFzLmNvbnRleHRDb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgZW50aXJlIHRleHRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLl90ZXh0Lmxlbmd0aDtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2VsZWN0ZWQgdGV4dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RleHQuc2xpY2UodGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQpLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIHN0YXJ0IG9mIGN1cnJlbnQgd29yZCBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIEN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZFdvcmRCb3VuZGFyeUxlZnQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tIC0gMTtcblxuICAgICAgLy8gcmVtb3ZlIHNwYWNlIGJlZm9yZSBjdXJzb3IgZmlyc3RcbiAgICAgIGlmICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pKSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKC9cXFMvLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pICYmIGluZGV4ID4gLTEpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydEZyb20gLSBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbmV3IHNlbGVjdGlvbiBpbmRleCByZXByZXNlbnRpbmcgZW5kIG9mIGN1cnJlbnQgd29yZCBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIEN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZFdvcmRCb3VuZGFyeVJpZ2h0OiBmdW5jdGlvbihzdGFydEZyb20pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLCBpbmRleCA9IHN0YXJ0RnJvbTtcblxuICAgICAgLy8gcmVtb3ZlIHNwYWNlIGFmdGVyIGN1cnNvciBmaXJzdFxuICAgICAgaWYgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLl90ZXh0W2luZGV4XSkpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLl90ZXh0W2luZGV4XSkpIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoL1xcUy8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPCB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSArIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBzdGFydCBvZiBjdXJyZW50IGxpbmUgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBDdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRMaW5lQm91bmRhcnlMZWZ0OiBmdW5jdGlvbihzdGFydEZyb20pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLCBpbmRleCA9IHN0YXJ0RnJvbSAtIDE7XG5cbiAgICAgIHdoaWxlICghL1xcbi8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPiAtMSkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSAtIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBlbmQgb2YgY3VycmVudCBsaW5lIGFjY29yZGluZyB0byBjdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb20gQ3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE5ldyBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kTGluZUJvdW5kYXJ5UmlnaHQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tO1xuXG4gICAgICB3aGlsZSAoIS9cXG4vLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pICYmIGluZGV4IDwgdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydEZyb20gKyBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGluZGV4IGNvcnJlc3BvbmRpbmcgdG8gYmVnaW5uaW5nIG9yIGVuZCBvZiBhIHdvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VsZWN0aW9uU3RhcnQgSW5kZXggb2YgYSBjaGFyYWN0ZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uIDEgb3IgLTFcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBiZWdpbm5pbmcgb3IgZW5kIG9mIGEgd29yZFxuICAgICAqL1xuICAgIHNlYXJjaFdvcmRCb3VuZGFyeTogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQsIGRpcmVjdGlvbikge1xuICAgICAgdmFyIHRleHQgPSB0aGlzLl90ZXh0LFxuICAgICAgICAgIGluZGV4ICAgICA9IHRoaXMuX3JlU3BhY2UudGVzdCh0ZXh0W3NlbGVjdGlvblN0YXJ0XSkgPyBzZWxlY3Rpb25TdGFydCAtIDEgOiBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICBfY2hhciAgICAgPSB0ZXh0W2luZGV4XSxcbiAgICAgICAgICAvLyB3cm9uZ1xuICAgICAgICAgIHJlTm9uV29yZCA9IGZhYnJpYy5yZU5vbldvcmQ7XG5cbiAgICAgIHdoaWxlICghcmVOb25Xb3JkLnRlc3QoX2NoYXIpICYmIGluZGV4ID4gMCAmJiBpbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ICs9IGRpcmVjdGlvbjtcbiAgICAgICAgX2NoYXIgPSB0ZXh0W2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGlmIChyZU5vbldvcmQudGVzdChfY2hhcikpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyZWN0aW9uID09PSAxID8gMCA6IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSB3b3JkIGJhc2VkIG9uIHRoZSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWxlY3Rpb25TdGFydCBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgICAqL1xuICAgIHNlbGVjdFdvcmQ6IGZ1bmN0aW9uKHNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICBzZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvblN0YXJ0IHx8IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB2YXIgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlYXJjaFdvcmRCb3VuZGFyeShzZWxlY3Rpb25TdGFydCwgLTEpLCAvKiBzZWFyY2ggYmFja3dhcmRzICovXG4gICAgICAgICAgbmV3U2VsZWN0aW9uRW5kID0gdGhpcy5zZWFyY2hXb3JkQm91bmRhcnkoc2VsZWN0aW9uU3RhcnQsIDEpOyAvKiBzZWFyY2ggZm9yd2FyZCAqL1xuXG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbkVuZDtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgbGluZSBiYXNlZCBvbiB0aGUgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VsZWN0aW9uU3RhcnQgSW5kZXggb2YgYSBjaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VsZWN0TGluZTogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgIHNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQgfHwgdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIHZhciBuZXdTZWxlY3Rpb25TdGFydCA9IHRoaXMuZmluZExpbmVCb3VuZGFyeUxlZnQoc2VsZWN0aW9uU3RhcnQpLFxuICAgICAgICAgIG5ld1NlbGVjdGlvbkVuZCA9IHRoaXMuZmluZExpbmVCb3VuZGFyeVJpZ2h0KHNlbGVjdGlvblN0YXJ0KTtcblxuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb25FbmQ7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbnRlcnMgZWRpdGluZyBzdGF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBlbnRlckVkaXRpbmc6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLmlzRWRpdGluZyB8fCAhdGhpcy5lZGl0YWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5jYWxjT2Zmc2V0KCk7XG4gICAgICAgIHRoaXMuZXhpdEVkaXRpbmdPbk90aGVycyh0aGlzLmNhbnZhcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTtcblxuICAgICAgdGhpcy5pbml0SGlkZGVuVGV4dGFyZWEoZSk7XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLmZvY3VzKCk7XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlID0gdGhpcy50ZXh0O1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHRoaXMuX3NhdmVFZGl0aW5nUHJvcHMoKTtcbiAgICAgIHRoaXMuX3NldEVkaXRpbmdQcm9wcygpO1xuICAgICAgdGhpcy5fdGV4dEJlZm9yZUVkaXQgPSB0aGlzLnRleHQ7XG5cbiAgICAgIHRoaXMuX3RpY2soKTtcbiAgICAgIHRoaXMuZmlyZSgnZWRpdGluZzplbnRlcmVkJyk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6ZWRpdGluZzplbnRlcmVkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgICB0aGlzLmluaXRNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZXhpdEVkaXRpbmdPbk90aGVyczogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICBpZiAoY2FudmFzLl9pVGV4dEluc3RhbmNlcykge1xuICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgb2JqLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG9iai5pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIG9iai5leGl0RWRpdGluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIFwibW91c2Vtb3ZlXCIgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIGluaXRNb3VzZU1vdmVIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2FudmFzLm9uKCdtb3VzZTptb3ZlJywgdGhpcy5tb3VzZU1vdmVIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtb3VzZU1vdmVIYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuX19pc01vdXNlZG93biB8fCAhdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyByZWdhaW4gZm9jdXNcbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRoaXMuaGlkZGVuVGV4dGFyZWEgJiYgdGhpcy5oaWRkZW5UZXh0YXJlYS5mb2N1cygpO1xuXG4gICAgICB2YXIgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIob3B0aW9ucy5lKSxcbiAgICAgICAgICBjdXJyZW50U3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIGN1cnJlbnRFbmQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICAgIGlmIChcbiAgICAgICAgKG5ld1NlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93biB8fCBjdXJyZW50U3RhcnQgPT09IGN1cnJlbnRFbmQpXG4gICAgICAgICYmXG4gICAgICAgIChjdXJyZW50U3RhcnQgPT09IG5ld1NlbGVjdGlvblN0YXJ0IHx8IGN1cnJlbnRFbmQgPT09IG5ld1NlbGVjdGlvblN0YXJ0KVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdTZWxlY3Rpb25TdGFydCA+IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93bjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd247XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gY3VycmVudFN0YXJ0IHx8IHRoaXMuc2VsZWN0aW9uRW5kICE9PSBjdXJyZW50RW5kKSB7XG4gICAgICAgIHRoaXMucmVzdGFydEN1cnNvcklmTmVlZGVkKCk7XG4gICAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0RWRpdGluZ1Byb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaG92ZXJDdXJzb3IgPSAndGV4dCc7XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5kZWZhdWx0Q3Vyc29yID0gdGhpcy5jYW52YXMubW92ZUN1cnNvciA9ICd0ZXh0JztcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IHRoaXMuZWRpdGluZ0JvcmRlckNvbG9yO1xuICAgICAgdGhpcy5oYXNDb250cm9scyA9IHRoaXMuc2VsZWN0YWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5sb2NrTW92ZW1lbnRYID0gdGhpcy5sb2NrTW92ZW1lbnRZID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBmcm9tIHRleHRhcmVhIHRvIGdyYXBoZW1lIGluZGV4ZXNcbiAgICAgKi9cbiAgICBmcm9tU3RyaW5nVG9HcmFwaGVtZVNlbGVjdGlvbjogZnVuY3Rpb24oc3RhcnQsIGVuZCwgdGV4dCkge1xuICAgICAgdmFyIHNtYWxsZXJUZXh0U3RhcnQgPSB0ZXh0LnNsaWNlKDAsIHN0YXJ0KSxcbiAgICAgICAgICBncmFwaGVtZVN0YXJ0ID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQoc21hbGxlclRleHRTdGFydCkubGVuZ3RoO1xuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc2VsZWN0aW9uU3RhcnQ6IGdyYXBoZW1lU3RhcnQsIHNlbGVjdGlvbkVuZDogZ3JhcGhlbWVTdGFydCB9O1xuICAgICAgfVxuICAgICAgdmFyIHNtYWxsZXJUZXh0RW5kID0gdGV4dC5zbGljZShzdGFydCwgZW5kKSxcbiAgICAgICAgICBncmFwaGVtZUVuZCA9IGZhYnJpYy51dGlsLnN0cmluZy5ncmFwaGVtZVNwbGl0KHNtYWxsZXJUZXh0RW5kKS5sZW5ndGg7XG4gICAgICByZXR1cm4geyBzZWxlY3Rpb25TdGFydDogZ3JhcGhlbWVTdGFydCwgc2VsZWN0aW9uRW5kOiBncmFwaGVtZVN0YXJ0ICsgZ3JhcGhlbWVFbmQgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBmcm9tIGZhYnJpYyB0byB0ZXh0YXJlYSB2YWx1ZXNcbiAgICAgKi9cbiAgICBmcm9tR3JhcGhlbWVUb1N0cmluZ1NlbGVjdGlvbjogZnVuY3Rpb24oc3RhcnQsIGVuZCwgX3RleHQpIHtcbiAgICAgIHZhciBzbWFsbGVyVGV4dFN0YXJ0ID0gX3RleHQuc2xpY2UoMCwgc3RhcnQpLFxuICAgICAgICAgIGdyYXBoZW1lU3RhcnQgPSBzbWFsbGVyVGV4dFN0YXJ0LmpvaW4oJycpLmxlbmd0aDtcbiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICAgIHJldHVybiB7IHNlbGVjdGlvblN0YXJ0OiBncmFwaGVtZVN0YXJ0LCBzZWxlY3Rpb25FbmQ6IGdyYXBoZW1lU3RhcnQgfTtcbiAgICAgIH1cbiAgICAgIHZhciBzbWFsbGVyVGV4dEVuZCA9IF90ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgIGdyYXBoZW1lRW5kID0gc21hbGxlclRleHRFbmQuam9pbignJykubGVuZ3RoO1xuICAgICAgcmV0dXJuIHsgc2VsZWN0aW9uU3RhcnQ6IGdyYXBoZW1lU3RhcnQsIHNlbGVjdGlvbkVuZDogZ3JhcGhlbWVTdGFydCArIGdyYXBoZW1lRW5kIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVRleHRhcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSB7IH07XG4gICAgICBpZiAoIXRoaXMuaGlkZGVuVGV4dGFyZWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmZyb21HcmFwaGVtZVRvU3RyaW5nU2VsZWN0aW9uKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kLCB0aGlzLl90ZXh0KTtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb24uc2VsZWN0aW9uRW5kO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXBkYXRlRnJvbVRleHRBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5oaWRkZW5UZXh0YXJlYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnNvck9mZnNldENhY2hlID0geyB9O1xuICAgICAgdGhpcy50ZXh0ID0gdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZTtcbiAgICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZnJvbVN0cmluZ1RvR3JhcGhlbWVTZWxlY3Rpb24oXG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQsIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uRW5kLCB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25FbmQ7XG4gICAgICBpZiAoIXRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlVGV4dGFyZWFQb3NpdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZVRleHRhcmVhUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX2NhbGNUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUubGVmdCA9IHN0eWxlLmxlZnQ7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUudG9wID0gc3R5bGUudG9wO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgY29udGFpbnMgc3R5bGUgZm9yIGhpZGRlblRleHRhcmVhXG4gICAgICovXG4gICAgX2NhbGNUZXh0YXJlYVBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMSwgeTogMSB9O1xuICAgICAgfVxuICAgICAgdmFyIGRlc2lyZWRQb3NpdGlvbiA9IHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPyB0aGlzLmNvbXBvc2l0aW9uU3RhcnQgOiB0aGlzLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIGJvdW5kYXJpZXMgPSB0aGlzLl9nZXRDdXJzb3JCb3VuZGFyaWVzKGRlc2lyZWRQb3NpdGlvbiksXG4gICAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oZGVzaXJlZFBvc2l0aW9uKSxcbiAgICAgICAgICBsaW5lSW5kZXggPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4ID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4LFxuICAgICAgICAgIGNoYXJIZWlnaHQgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZm9udFNpemUnKSAqIHRoaXMubGluZUhlaWdodCxcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gYm91bmRhcmllcy5sZWZ0T2Zmc2V0LFxuICAgICAgICAgIG0gPSB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBwID0ge1xuICAgICAgICAgICAgeDogYm91bmRhcmllcy5sZWZ0ICsgbGVmdE9mZnNldCxcbiAgICAgICAgICAgIHk6IGJvdW5kYXJpZXMudG9wICsgYm91bmRhcmllcy50b3BPZmZzZXQgKyBjaGFySGVpZ2h0XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXRpbmFTY2FsaW5nID0gdGhpcy5jYW52YXMuZ2V0UmV0aW5hU2NhbGluZygpLFxuICAgICAgICAgIHVwcGVyQ2FudmFzID0gdGhpcy5jYW52YXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICB1cHBlckNhbnZhc1dpZHRoID0gdXBwZXJDYW52YXMud2lkdGggLyByZXRpbmFTY2FsaW5nLFxuICAgICAgICAgIHVwcGVyQ2FudmFzSGVpZ2h0ID0gdXBwZXJDYW52YXMuaGVpZ2h0IC8gcmV0aW5hU2NhbGluZyxcbiAgICAgICAgICBtYXhXaWR0aCA9IHVwcGVyQ2FudmFzV2lkdGggLSBjaGFySGVpZ2h0LFxuICAgICAgICAgIG1heEhlaWdodCA9IHVwcGVyQ2FudmFzSGVpZ2h0IC0gY2hhckhlaWdodCxcbiAgICAgICAgICBzY2FsZVggPSB1cHBlckNhbnZhcy5jbGllbnRXaWR0aCAvIHVwcGVyQ2FudmFzV2lkdGgsXG4gICAgICAgICAgc2NhbGVZID0gdXBwZXJDYW52YXMuY2xpZW50SGVpZ2h0IC8gdXBwZXJDYW52YXNIZWlnaHQ7XG5cbiAgICAgIHAgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwLCBtKTtcbiAgICAgIHAgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwLCB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICBwLnggKj0gc2NhbGVYO1xuICAgICAgcC55ICo9IHNjYWxlWTtcbiAgICAgIGlmIChwLnggPCAwKSB7XG4gICAgICAgIHAueCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocC54ID4gbWF4V2lkdGgpIHtcbiAgICAgICAgcC54ID0gbWF4V2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAocC55IDwgMCkge1xuICAgICAgICBwLnkgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHAueSA+IG1heEhlaWdodCkge1xuICAgICAgICBwLnkgPSBtYXhIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCBjYW52YXMgb2Zmc2V0IG9uIGRvY3VtZW50XG4gICAgICBwLnggKz0gdGhpcy5jYW52YXMuX29mZnNldC5sZWZ0O1xuICAgICAgcC55ICs9IHRoaXMuY2FudmFzLl9vZmZzZXQudG9wO1xuXG4gICAgICByZXR1cm4geyBsZWZ0OiBwLnggKyAncHgnLCB0b3A6IHAueSArICdweCcsIGZvbnRTaXplOiBjaGFySGVpZ2h0ICsgJ3B4JywgY2hhckhlaWdodDogY2hhckhlaWdodCB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zYXZlRWRpdGluZ1Byb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3NhdmVkUHJvcHMgPSB7XG4gICAgICAgIGhhc0NvbnRyb2xzOiB0aGlzLmhhc0NvbnRyb2xzLFxuICAgICAgICBib3JkZXJDb2xvcjogdGhpcy5ib3JkZXJDb2xvcixcbiAgICAgICAgbG9ja01vdmVtZW50WDogdGhpcy5sb2NrTW92ZW1lbnRYLFxuICAgICAgICBsb2NrTW92ZW1lbnRZOiB0aGlzLmxvY2tNb3ZlbWVudFksXG4gICAgICAgIGhvdmVyQ3Vyc29yOiB0aGlzLmhvdmVyQ3Vyc29yLFxuICAgICAgICBzZWxlY3RhYmxlOiB0aGlzLnNlbGVjdGFibGUsXG4gICAgICAgIGRlZmF1bHRDdXJzb3I6IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmRlZmF1bHRDdXJzb3IsXG4gICAgICAgIG1vdmVDdXJzb3I6IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLm1vdmVDdXJzb3JcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc3RvcmVFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9zYXZlZFByb3BzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ob3ZlckN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMuaG92ZXJDdXJzb3I7XG4gICAgICB0aGlzLmhhc0NvbnRyb2xzID0gdGhpcy5fc2F2ZWRQcm9wcy5oYXNDb250cm9scztcbiAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSB0aGlzLl9zYXZlZFByb3BzLmJvcmRlckNvbG9yO1xuICAgICAgdGhpcy5zZWxlY3RhYmxlID0gdGhpcy5fc2F2ZWRQcm9wcy5zZWxlY3RhYmxlO1xuICAgICAgdGhpcy5sb2NrTW92ZW1lbnRYID0gdGhpcy5fc2F2ZWRQcm9wcy5sb2NrTW92ZW1lbnRYO1xuICAgICAgdGhpcy5sb2NrTW92ZW1lbnRZID0gdGhpcy5fc2F2ZWRQcm9wcy5sb2NrTW92ZW1lbnRZO1xuXG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZGVmYXVsdEN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMuZGVmYXVsdEN1cnNvcjtcbiAgICAgICAgdGhpcy5jYW52YXMubW92ZUN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMubW92ZUN1cnNvcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhpdHMgZnJvbSBlZGl0aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGV4aXRFZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc1RleHRDaGFuZ2VkID0gKHRoaXMuX3RleHRCZWZvcmVFZGl0ICE9PSB0aGlzLnRleHQpO1xuICAgICAgdmFyIGhpZGRlblRleHRhcmVhID0gdGhpcy5oaWRkZW5UZXh0YXJlYTtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcblxuICAgICAgaWYgKGhpZGRlblRleHRhcmVhKSB7XG4gICAgICAgIGhpZGRlblRleHRhcmVhLmJsdXIgJiYgaGlkZGVuVGV4dGFyZWEuYmx1cigpO1xuICAgICAgICBoaWRkZW5UZXh0YXJlYS5wYXJlbnROb2RlICYmIGhpZGRlblRleHRhcmVhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaGlkZGVuVGV4dGFyZWEpO1xuICAgICAgfVxuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYSA9IG51bGw7XG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLl9yZXN0b3JlRWRpdGluZ1Byb3BzKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDA7XG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlyZSgnZWRpdGluZzpleGl0ZWQnKTtcbiAgICAgIGlzVGV4dENoYW5nZWQgJiYgdGhpcy5maXJlKCdtb2RpZmllZCcpO1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLm9mZignbW91c2U6bW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcik7XG4gICAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6ZWRpdGluZzpleGl0ZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgICAgaXNUZXh0Q2hhbmdlZCAmJiB0aGlzLmNhbnZhcy5maXJlKCdvYmplY3Q6bW9kaWZpZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0TGluZXNbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGFuZCByZWZsb3cgYSBzdHlsZSBibG9jayBmcm9tIHN0YXJ0IHRvIGVuZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgbGluZWFyIHN0YXJ0IHBvc2l0aW9uIGZvciByZW1vdmFsIChpbmNsdWRlZCBpbiByZW1vdmFsKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgbGluZWFyIGVuZCBwb3NpdGlvbiBmb3IgcmVtb3ZhbCAoIGV4Y2x1ZGVkIGZyb20gcmVtb3ZhbCApXG4gICAgICovXG4gICAgcmVtb3ZlU3R5bGVGcm9tVG86IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBjdXJzb3JTdGFydCA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzdGFydCwgdHJ1ZSksXG4gICAgICAgICAgY3Vyc29yRW5kID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKGVuZCwgdHJ1ZSksXG4gICAgICAgICAgbGluZVN0YXJ0ID0gY3Vyc29yU3RhcnQubGluZUluZGV4LFxuICAgICAgICAgIGNoYXJTdGFydCA9IGN1cnNvclN0YXJ0LmNoYXJJbmRleCxcbiAgICAgICAgICBsaW5lRW5kID0gY3Vyc29yRW5kLmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFyRW5kID0gY3Vyc29yRW5kLmNoYXJJbmRleCxcbiAgICAgICAgICBpLCBzdHlsZU9iajtcbiAgICAgIGlmIChsaW5lU3RhcnQgIT09IGxpbmVFbmQpIHtcbiAgICAgICAgLy8gc3RlcDEgcmVtb3ZlIHRoZSB0cmFpbGluZyBvZiBsaW5lU3RhcnRcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVzW2xpbmVTdGFydF0pIHtcbiAgICAgICAgICBmb3IgKGkgPSBjaGFyU3RhcnQ7IGkgPCB0aGlzLl91bndyYXBwZWRUZXh0TGluZXNbbGluZVN0YXJ0XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVTdGFydF1baV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXAyIG1vdmUgdGhlIHRyYWlsaW5nIG9mIGxpbmVFbmQgdG8gbGluZVN0YXJ0IGlmIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy5zdHlsZXNbbGluZUVuZF0pIHtcbiAgICAgICAgICBmb3IgKGkgPSBjaGFyRW5kOyBpIDwgdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzW2xpbmVFbmRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdHlsZU9iaiA9IHRoaXMuc3R5bGVzW2xpbmVFbmRdW2ldO1xuICAgICAgICAgICAgaWYgKHN0eWxlT2JqKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVTdGFydF0gfHwgKHRoaXMuc3R5bGVzW2xpbmVTdGFydF0gPSB7IH0pO1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lU3RhcnRdW2NoYXJTdGFydCArIGkgLSBjaGFyRW5kXSA9IHN0eWxlT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwMyBkZXRlY3RzIGxpbmVzIHdpbGwgYmUgY29tcGxldGVseSByZW1vdmVkLlxuICAgICAgICBmb3IgKGkgPSBsaW5lU3RhcnQgKyAxOyBpIDw9IGxpbmVFbmQ7IGkrKykge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwNCBzaGlmdCByZW1haW5pbmcgbGluZXMuXG4gICAgICAgIHRoaXMuc2hpZnRMaW5lU3R5bGVzKGxpbmVFbmQsIGxpbmVTdGFydCAtIGxpbmVFbmQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbmQgc2hpZnQgbGVmdCBvbiB0aGUgc2FtZSBsaW5lXG4gICAgICAgIGlmICh0aGlzLnN0eWxlc1tsaW5lU3RhcnRdKSB7XG4gICAgICAgICAgc3R5bGVPYmogPSB0aGlzLnN0eWxlc1tsaW5lU3RhcnRdO1xuICAgICAgICAgIHZhciBkaWZmID0gY2hhckVuZCAtIGNoYXJTdGFydCwgbnVtZXJpY0NoYXIsIF9jaGFyO1xuICAgICAgICAgIGZvciAoaSA9IGNoYXJTdGFydDsgaSA8IGNoYXJFbmQ7IGkrKykge1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlT2JqW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKF9jaGFyIGluIHRoaXMuc3R5bGVzW2xpbmVTdGFydF0pIHtcbiAgICAgICAgICAgIG51bWVyaWNDaGFyID0gcGFyc2VJbnQoX2NoYXIsIDEwKTtcbiAgICAgICAgICAgIGlmIChudW1lcmljQ2hhciA+PSBjaGFyRW5kKSB7XG4gICAgICAgICAgICAgIHN0eWxlT2JqW251bWVyaWNDaGFyIC0gZGlmZl0gPSBzdHlsZU9ialtfY2hhcl07XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZU9ialtfY2hhcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNoaWZ0cyBsaW5lIHN0eWxlcyB1cCBvciBkb3duXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IENhbiBhbnkgbnVtYmVyP1xuICAgICAqL1xuICAgIHNoaWZ0TGluZVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4LCBvZmZzZXQpIHtcbiAgICAgIC8vIHNoaWZ0IGFsbCBsaW5lIHN0eWxlcyBieSBvZmZzZXQgdXB3YXJkIG9yIGRvd253YXJkXG4gICAgICAvLyBkbyBub3QgY2xvbmUgZGVlcC4gd2UgbmVlZCBuZXcgYXJyYXksIG5vdCBuZXcgc3R5bGUgb2JqZWN0c1xuICAgICAgdmFyIGNsb25lZFN0eWxlcyA9IGNsb25lKHRoaXMuc3R5bGVzKTtcbiAgICAgIGZvciAodmFyIGxpbmUgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgdmFyIG51bWVyaWNMaW5lID0gcGFyc2VJbnQobGluZSwgMTApO1xuICAgICAgICBpZiAobnVtZXJpY0xpbmUgPiBsaW5lSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tudW1lcmljTGluZSArIG9mZnNldF0gPSBjbG9uZWRTdHlsZXNbbnVtZXJpY0xpbmVdO1xuICAgICAgICAgIGlmICghY2xvbmVkU3R5bGVzW251bWVyaWNMaW5lIC0gb2Zmc2V0XSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW251bWVyaWNMaW5lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzdGFydEN1cnNvcklmTmVlZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fY3VycmVudFRpY2tTdGF0ZSB8fCB0aGlzLl9jdXJyZW50VGlja1N0YXRlLmlzQWJvcnRlZFxuICAgICAgICB8fCAhdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlIHx8IHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZS5pc0Fib3J0ZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBpbnNlcnRpb24gb2YgbW9yZSBjb25zZWN1dGl2ZSBzdHlsZSBsaW5lcyBmb3Igd2hlbiBvbmUgb3IgbW9yZVxuICAgICAqIG5ld2xpbmVzIGdldHMgYWRkZWQgdG8gdGhlIHRleHQuIFNpbmNlIGN1cnJlbnQgc3R5bGUgbmVlZHMgdG8gYmUgc2hpZnRlZFxuICAgICAqIGZpcnN0IHdlIHNoaWZ0IHRoZSBjdXJyZW50IHN0eWxlIG9mIHRoZSBudW1iZXIgbGluZXMgbmVlZGVkLCB0aGVuIHdlIGFkZFxuICAgICAqIG5ldyBsaW5lcyBmcm9tIHRoZSBsYXN0IHRvIHRoZSBmaXJzdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IEluZGV4IG9mIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggSW5kZXggb2YgYSBjaGFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHF0eSBudW1iZXIgb2YgbGluZXMgdG8gYWRkXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29waWVkU3R5bGUgQXJyYXkgb2Ygb2JqZWN0cyBzdHlsZXNcbiAgICAgKi9cbiAgICBpbnNlcnROZXdsaW5lU3R5bGVPYmplY3Q6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBxdHksIGNvcGllZFN0eWxlKSB7XG4gICAgICB2YXIgY3VycmVudENoYXJTdHlsZSxcbiAgICAgICAgICBuZXdMaW5lU3R5bGVzID0ge30sXG4gICAgICAgICAgc29tZXRoaW5nQWRkZWQgPSBmYWxzZSxcbiAgICAgICAgICBpc0VuZE9mTGluZSA9IHRoaXMuX3Vud3JhcHBlZFRleHRMaW5lc1tsaW5lSW5kZXhdLmxlbmd0aCA9PT0gY2hhckluZGV4O1xuXG4gICAgICBxdHkgfHwgKHF0eSA9IDEpO1xuICAgICAgdGhpcy5zaGlmdExpbmVTdHlsZXMobGluZUluZGV4LCBxdHkpO1xuICAgICAgaWYgKHRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgY3VycmVudENoYXJTdHlsZSA9IHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4ID09PSAwID8gY2hhckluZGV4IDogY2hhckluZGV4IC0gMV07XG4gICAgICB9XG4gICAgICAvLyB3ZSBjbG9uZSBzdHlsZXMgb2YgYWxsIGNoYXJzXG4gICAgICAvLyBhZnRlciBjdXJzb3Igb250byB0aGUgY3VycmVudCBsaW5lXG4gICAgICBmb3IgKHZhciBpbmRleCBpbiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIHZhciBudW1JbmRleCA9IHBhcnNlSW50KGluZGV4LCAxMCk7XG4gICAgICAgIGlmIChudW1JbmRleCA+PSBjaGFySW5kZXgpIHtcbiAgICAgICAgICBzb21ldGhpbmdBZGRlZCA9IHRydWU7XG4gICAgICAgICAgbmV3TGluZVN0eWxlc1tudW1JbmRleCAtIGNoYXJJbmRleF0gPSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2luZGV4XTtcbiAgICAgICAgICAvLyByZW1vdmUgbGluZXMgZnJvbSB0aGUgcHJldmlvdXMgbGluZSBzaW5jZSB0aGV5J3JlIG9uIGEgbmV3IGxpbmUgbm93XG4gICAgICAgICAgaWYgKCEoaXNFbmRPZkxpbmUgJiYgY2hhckluZGV4ID09PSAwKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1baW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHN0eWxlQ2FycmllZE92ZXIgPSBmYWxzZTtcbiAgICAgIGlmIChzb21ldGhpbmdBZGRlZCAmJiAhaXNFbmRPZkxpbmUpIHtcbiAgICAgICAgLy8gaWYgaXMgZW5kIG9mIGxpbmUsIHRoZSBleHRyYSBzdHlsZSB3ZSBjb3BpZWRcbiAgICAgICAgLy8gaXMgcHJvYmFibHkgbm90IHNvbWV0aGluZyB3ZSB3YW50XG4gICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIHF0eV0gPSBuZXdMaW5lU3R5bGVzO1xuICAgICAgICBzdHlsZUNhcnJpZWRPdmVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZUNhcnJpZWRPdmVyKSB7XG4gICAgICAgIC8vIHNraXAgdGhlIGxhc3QgbGluZSBvZiBzaW5jZSB3ZSBhbHJlYWR5IHByZXBhcmVkIGl0LlxuICAgICAgICBxdHktLTtcbiAgICAgIH1cbiAgICAgIC8vIGZvciB0aGUgYWxsIHRoZSBsaW5lcyBvciBhbGwgdGhlIG90aGVyIGxpbmVzXG4gICAgICAvLyB3ZSBjbG9uZSBjdXJyZW50IGNoYXIgc3R5bGUgb250byB0aGUgbmV4dCAob3RoZXJ3aXNlIGVtcHR5KSBsaW5lXG4gICAgICB3aGlsZSAocXR5ID4gMCkge1xuICAgICAgICBpZiAoY29waWVkU3R5bGUgJiYgY29waWVkU3R5bGVbcXR5IC0gMV0pIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyBxdHldID0geyAwOiBjbG9uZShjb3BpZWRTdHlsZVtxdHkgLSAxXSkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50Q2hhclN0eWxlKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgcXR5XSA9IHsgMDogY2xvbmUoY3VycmVudENoYXJTdHlsZSkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgcXR5XTtcbiAgICAgICAgfVxuICAgICAgICBxdHktLTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgc3R5bGUgb2JqZWN0IGZvciBhIGdpdmVuIGxpbmUvY2hhciBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBJbmRleCBvZiBhIGNoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcXVhbnRpdHkgbnVtYmVyIFN0eWxlIG9iamVjdCB0byBpbnNlcnQsIGlmIGdpdmVuXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29waWVkU3R5bGUgYXJyYXkgb2Ygc3R5bGUgb2JqZWN0c1xuICAgICAqL1xuICAgIGluc2VydENoYXJTdHlsZU9iamVjdDogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHF1YW50aXR5LCBjb3BpZWRTdHlsZSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcykge1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHt9O1xuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRMaW5lU3R5bGVzICAgICAgID0gdGhpcy5zdHlsZXNbbGluZUluZGV4XSxcbiAgICAgICAgICBjdXJyZW50TGluZVN0eWxlc0Nsb25lZCA9IGN1cnJlbnRMaW5lU3R5bGVzID8gY2xvbmUoY3VycmVudExpbmVTdHlsZXMpIDoge307XG5cbiAgICAgIHF1YW50aXR5IHx8IChxdWFudGl0eSA9IDEpO1xuICAgICAgLy8gc2hpZnQgYWxsIGNoYXIgc3R5bGVzIGJ5IHF1YW50aXR5IGZvcndhcmRcbiAgICAgIC8vIDAsMSwyLDMgLT4gKGNoYXJJbmRleD0yKSAtPiAwLDEsMyw0IC0+IChpbnNlcnQgMikgLT4gMCwxLDIsMyw0XG4gICAgICBmb3IgKHZhciBpbmRleCBpbiBjdXJyZW50TGluZVN0eWxlc0Nsb25lZCkge1xuICAgICAgICB2YXIgbnVtZXJpY0luZGV4ID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICAgICAgaWYgKG51bWVyaWNJbmRleCA+PSBjaGFySW5kZXgpIHtcbiAgICAgICAgICBjdXJyZW50TGluZVN0eWxlc1tudW1lcmljSW5kZXggKyBxdWFudGl0eV0gPSBjdXJyZW50TGluZVN0eWxlc0Nsb25lZFtudW1lcmljSW5kZXhdO1xuICAgICAgICAgIC8vIG9ubHkgZGVsZXRlIHRoZSBzdHlsZSBpZiB0aGVyZSB3YXMgbm90aGluZyBtb3ZlZCB0aGVyZVxuICAgICAgICAgIGlmICghY3VycmVudExpbmVTdHlsZXNDbG9uZWRbbnVtZXJpY0luZGV4IC0gcXVhbnRpdHldKSB7XG4gICAgICAgICAgICBkZWxldGUgY3VycmVudExpbmVTdHlsZXNbbnVtZXJpY0luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IHRydWU7XG4gICAgICBpZiAoY29waWVkU3R5bGUpIHtcbiAgICAgICAgd2hpbGUgKHF1YW50aXR5LS0pIHtcbiAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGNvcGllZFN0eWxlW3F1YW50aXR5XSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4ICsgcXVhbnRpdHldID0gY2xvbmUoY29waWVkU3R5bGVbcXVhbnRpdHldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWN1cnJlbnRMaW5lU3R5bGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTdHlsZSA9IGN1cnJlbnRMaW5lU3R5bGVzW2NoYXJJbmRleCA/IGNoYXJJbmRleCAtIDEgOiAxXTtcbiAgICAgIHdoaWxlIChuZXdTdHlsZSAmJiBxdWFudGl0eS0tKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4ICsgcXVhbnRpdHldID0gY2xvbmUobmV3U3R5bGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHN0eWxlIG9iamVjdChzKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluc2VydGVkVGV4dCBDaGFyYWN0ZXJzIGF0IHRoZSBsb2NhdGlvbiB3aGVyZSBzdHlsZSBpcyBpbnNlcnRlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBjdXJzb3IgaW5kZXggZm9yIGluc2VydGluZyBzdHlsZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb3BpZWRTdHlsZV0gYXJyYXkgb2Ygc3R5bGUgb2JqZWN0cyB0byBpbnNlcnQuXG4gICAgICovXG4gICAgaW5zZXJ0TmV3U3R5bGVCbG9jazogZnVuY3Rpb24oaW5zZXJ0ZWRUZXh0LCBzdGFydCwgY29waWVkU3R5bGUpIHtcbiAgICAgIHZhciBjdXJzb3JMb2MgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc3RhcnQsIHRydWUpLFxuICAgICAgICAgIGFkZGVkTGluZXMgPSBbMF0sIGxpbmVzTGVuZ3RoID0gMDtcbiAgICAgIC8vIGdldCBhbiBhcnJheSBvZiBob3cgbWFueSBjaGFyIHBlciBsaW5lcyBhcmUgYmVpbmcgYWRkZWQuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc2VydGVkVGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5zZXJ0ZWRUZXh0W2ldID09PSAnXFxuJykge1xuICAgICAgICAgIGxpbmVzTGVuZ3RoKys7XG4gICAgICAgICAgYWRkZWRMaW5lc1tsaW5lc0xlbmd0aF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFkZGVkTGluZXNbbGluZXNMZW5ndGhdKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGZvciB0aGUgZmlyc3QgbGluZSBjb3B5IHRoZSBzdHlsZSBmcm9tIHRoZSBjdXJyZW50IGNoYXIgcG9zaXRpb24uXG4gICAgICBpZiAoYWRkZWRMaW5lc1swXSA+IDApIHtcbiAgICAgICAgdGhpcy5pbnNlcnRDaGFyU3R5bGVPYmplY3QoY3Vyc29yTG9jLmxpbmVJbmRleCwgY3Vyc29yTG9jLmNoYXJJbmRleCwgYWRkZWRMaW5lc1swXSwgY29waWVkU3R5bGUpO1xuICAgICAgICBjb3BpZWRTdHlsZSA9IGNvcGllZFN0eWxlICYmIGNvcGllZFN0eWxlLnNsaWNlKGFkZGVkTGluZXNbMF0gKyAxKTtcbiAgICAgIH1cbiAgICAgIGxpbmVzTGVuZ3RoICYmIHRoaXMuaW5zZXJ0TmV3bGluZVN0eWxlT2JqZWN0KFxuICAgICAgICBjdXJzb3JMb2MubGluZUluZGV4LCBjdXJzb3JMb2MuY2hhckluZGV4ICsgYWRkZWRMaW5lc1swXSwgbGluZXNMZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaW5lc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhZGRlZExpbmVzW2ldID4gMCkge1xuICAgICAgICAgIHRoaXMuaW5zZXJ0Q2hhclN0eWxlT2JqZWN0KGN1cnNvckxvYy5saW5lSW5kZXggKyBpLCAwLCBhZGRlZExpbmVzW2ldLCBjb3BpZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29waWVkU3R5bGUpIHtcbiAgICAgICAgICAvLyB0aGlzIHRlc3QgaXMgcmVxdWlyZWQgaW4gb3JkZXIgdG8gY2xvc2UgIzY4NDFcbiAgICAgICAgICAvLyB3aGVuIGEgcGFzdGVkIGJ1ZmZlciBiZWdpbnMgd2l0aCBhIG5ld2xpbmUgdGhlblxuICAgICAgICAgIC8vIHRoaXMuc3R5bGVzW2N1cnNvckxvYy5saW5lSW5kZXggKyBpXSBhbmQgY29waWVkU3R5bGVbMF1cbiAgICAgICAgICAvLyBtYXkgYmUgdW5kZWZpbmVkIGZvciBzb21lIHJlYXNvblxuICAgICAgICAgIGlmICh0aGlzLnN0eWxlc1tjdXJzb3JMb2MubGluZUluZGV4ICsgaV0gJiYgY29waWVkU3R5bGVbMF0pIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzW2N1cnNvckxvYy5saW5lSW5kZXggKyBpXVswXSA9IGNvcGllZFN0eWxlWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb3BpZWRTdHlsZSA9IGNvcGllZFN0eWxlICYmIGNvcGllZFN0eWxlLnNsaWNlKGFkZGVkTGluZXNbaV0gKyAxKTtcbiAgICAgIH1cbiAgICAgIC8vIHdlIHVzZSBpIG91dHNpZGUgdGhlIGxvb3AgdG8gZ2V0IGl0IGxpa2UgbGluZXNMZW5ndGhcbiAgICAgIGlmIChhZGRlZExpbmVzW2ldID4gMCkge1xuICAgICAgICB0aGlzLmluc2VydENoYXJTdHlsZU9iamVjdChjdXJzb3JMb2MubGluZUluZGV4ICsgaSwgMCwgYWRkZWRMaW5lc1tpXSwgY29waWVkU3R5bGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNlbGVjdGlvblN0YXJ0IGFuZCBzZWxlY3Rpb25FbmQgYWNjb3JkaW5nIHRvIHRoZSBuZXcgcG9zaXRpb24gb2YgY3Vyc29yXG4gICAgICogbWltaWMgdGhlIGtleSAtIG1vdXNlIG5hdmlnYXRpb24gd2hlbiBzaGlmdCBpcyBwcmVzc2VkLlxuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0OiBmdW5jdGlvbihzdGFydCwgZW5kLCBuZXdTZWxlY3Rpb24pIHtcbiAgICAgIGlmIChuZXdTZWxlY3Rpb24gPD0gc3RhcnQpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG5ld1NlbGVjdGlvbiA+IHN0YXJ0ICYmIG5ld1NlbGVjdGlvbiA8IGVuZCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIG5ld1NlbGVjdGlvbiBpcyA+IHNlbGVjdGlvbiBzdGFydCBhbmQgZW5kXG4gICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0U2VsZWN0aW9uSW5Cb3VuZGFyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPiBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPCAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uRW5kID4gbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25FbmQgPCAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5JVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBcImRiY2xpY2tcIiBldmVudCBoYW5kbGVyXG4gICAqL1xuICBpbml0RG91YmxlQ2xpY2tTaW11bGF0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgIC8vIGZvciBkb3VibGUgY2xpY2tcbiAgICB0aGlzLl9fbGFzdENsaWNrVGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgLy8gZm9yIHRyaXBsZSBjbGlja1xuICAgIHRoaXMuX19sYXN0TGFzdENsaWNrVGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgdGhpcy5fX2xhc3RQb2ludGVyID0geyB9O1xuXG4gICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciB0byBzaW11bGF0ZSB0cmlwbGUgY2xpY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9fbmV3Q2xpY2tUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG5ld1BvaW50ZXIgPSBvcHRpb25zLnBvaW50ZXI7XG4gICAgaWYgKHRoaXMuaXNUcmlwbGVDbGljayhuZXdQb2ludGVyKSkge1xuICAgICAgdGhpcy5maXJlKCd0cmlwbGVjbGljaycsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc3RvcEV2ZW50KG9wdGlvbnMuZSk7XG4gICAgfVxuICAgIHRoaXMuX19sYXN0TGFzdENsaWNrVGltZSA9IHRoaXMuX19sYXN0Q2xpY2tUaW1lO1xuICAgIHRoaXMuX19sYXN0Q2xpY2tUaW1lID0gdGhpcy5fX25ld0NsaWNrVGltZTtcbiAgICB0aGlzLl9fbGFzdFBvaW50ZXIgPSBuZXdQb2ludGVyO1xuICAgIHRoaXMuX19sYXN0SXNFZGl0aW5nID0gdGhpcy5pc0VkaXRpbmc7XG4gICAgdGhpcy5fX2xhc3RTZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWQ7XG4gIH0sXG5cbiAgaXNUcmlwbGVDbGljazogZnVuY3Rpb24obmV3UG9pbnRlcikge1xuICAgIHJldHVybiB0aGlzLl9fbmV3Q2xpY2tUaW1lIC0gdGhpcy5fX2xhc3RDbGlja1RpbWUgPCA1MDAgJiZcbiAgICAgICAgdGhpcy5fX2xhc3RDbGlja1RpbWUgLSB0aGlzLl9fbGFzdExhc3RDbGlja1RpbWUgPCA1MDAgJiZcbiAgICAgICAgdGhpcy5fX2xhc3RQb2ludGVyLnggPT09IG5ld1BvaW50ZXIueCAmJlxuICAgICAgICB0aGlzLl9fbGFzdFBvaW50ZXIueSA9PT0gbmV3UG9pbnRlci55O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N0b3BFdmVudDogZnVuY3Rpb24oZSkge1xuICAgIGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGV2ZW50IGhhbmRsZXJzIHJlbGF0ZWQgdG8gY3Vyc29yIG9yIHNlbGVjdGlvblxuICAgKi9cbiAgaW5pdEN1cnNvclNlbGVjdGlvbkhhbmRsZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluaXRNb3VzZWRvd25IYW5kbGVyKCk7XG4gICAgdGhpcy5pbml0TW91c2V1cEhhbmRsZXIoKTtcbiAgICB0aGlzLmluaXRDbGlja3MoKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBoYW5kbGVyIGZvciBkb3VibGUgY2xpY2ssIHNlbGVjdCBhIHdvcmRcbiAgICovXG4gIGRvdWJsZUNsaWNrSGFuZGxlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RXb3JkKHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihvcHRpb25zLmUpKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBoYW5kbGVyIGZvciB0cmlwbGUgY2xpY2ssIHNlbGVjdCBhIGxpbmVcbiAgICovXG4gIHRyaXBsZUNsaWNrSGFuZGxlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RMaW5lKHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihvcHRpb25zLmUpKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgZG91YmxlIGFuZCB0cmlwbGUgY2xpY2sgZXZlbnQgaGFuZGxlcnNcbiAgICovXG4gIGluaXRDbGlja3M6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub24oJ21vdXNlZGJsY2xpY2snLCB0aGlzLmRvdWJsZUNsaWNrSGFuZGxlcik7XG4gICAgdGhpcy5vbigndHJpcGxlY2xpY2snLCB0aGlzLnRyaXBsZUNsaWNrSGFuZGxlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllcyBuZWVkZWQgb24gX21vdXNlRG93blxuICAgKiBjYW4gYmUgb3ZlcnJpZGRlbiB0byBkbyBzb21ldGhpbmcgZGlmZmVyZW50LlxuICAgKiBTY29wZSBvZiB0aGlzIGltcGxlbWVudGF0aW9uIGlzOiBmaW5kIHRoZSBjbGljayBwb3NpdGlvbiwgc2V0IHNlbGVjdGlvblN0YXJ0XG4gICAqIGZpbmQgc2VsZWN0aW9uRW5kLCBpbml0aWFsaXplIHRoZSBkcmF3aW5nIG9mIGVpdGhlciBjdXJzb3Igb3Igc2VsZWN0aW9uIGFyZWFcbiAgICogaW5pdGlhbGl6aW5nIGEgbW91c2VkRG93biBvbiBhIHRleHQgYXJlYSB3aWxsIGNhbmNlbCBmYWJyaWNqcyBrbm93bGVkZ2Ugb2ZcbiAgICogY3VycmVudCBjb21wb3NpdGlvbk1vZGUuIEl0IHdpbGwgYmUgc2V0IHRvIGZhbHNlLlxuICAgKi9cbiAgX21vdXNlRG93bkhhbmRsZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY2FudmFzIHx8ICF0aGlzLmVkaXRhYmxlIHx8IChvcHRpb25zLmUuYnV0dG9uICYmIG9wdGlvbnMuZS5idXR0b24gIT09IDEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fX2lzTW91c2Vkb3duID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gZmFsc2U7XG4gICAgICB0aGlzLnNldEN1cnNvckJ5Q2xpY2sob3B0aW9ucy5lKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXMgbmVlZGVkIG9uIG1vdXNlZG93bjpiZWZvcmVcbiAgICogY2FuIGJlIG92ZXJyaWRkZW4gdG8gZG8gc29tZXRoaW5nIGRpZmZlcmVudC5cbiAgICogU2NvcGUgb2YgdGhpcyBpbXBsZW1lbnRhdGlvbiBpczogdmVyaWZ5IHRoZSBvYmplY3QgaXMgYWxyZWFkeSBzZWxlY3RlZCB3aGVuIG1vdXNpbmcgZG93blxuICAgKi9cbiAgX21vdXNlRG93bkhhbmRsZXJCZWZvcmU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY2FudmFzIHx8ICF0aGlzLmVkaXRhYmxlIHx8IChvcHRpb25zLmUuYnV0dG9uICYmIG9wdGlvbnMuZS5idXR0b24gIT09IDEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHdlIHdhbnQgdG8gYXZvaWQgdGhhdCBhbiBvYmplY3QgdGhhdCB3YXMgc2VsZWN0ZWQgYW5kIHRoZW4gYmVjb21lcyB1bnNlbGVjdGFibGUsXG4gICAgLy8gbWF5IHRyaWdnZXIgZWRpdGluZyBtb2RlIGluIHNvbWUgd2F5LlxuICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzID09PSB0aGlzLmNhbnZhcy5fYWN0aXZlT2JqZWN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBcIm1vdXNlZG93blwiIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIGluaXRNb3VzZWRvd25IYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9tb3VzZURvd25IYW5kbGVyKTtcbiAgICB0aGlzLm9uKCdtb3VzZWRvd246YmVmb3JlJywgdGhpcy5fbW91c2VEb3duSGFuZGxlckJlZm9yZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIFwibW91c2V1cFwiIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIGluaXRNb3VzZXVwSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vbignbW91c2V1cCcsIHRoaXMubW91c2VVcEhhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzdGFuZGFyZCBoYW5kbGVyIGZvciBtb3VzZSB1cCwgb3ZlcnJpZGFibGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG1vdXNlVXBIYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5fX2lzTW91c2Vkb3duID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmVkaXRhYmxlIHx8IHRoaXMuZ3JvdXAgfHxcbiAgICAgIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvcHRpb25zLnRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQpIHx8XG4gICAgICAob3B0aW9ucy5lLmJ1dHRvbiAmJiBvcHRpb25zLmUuYnV0dG9uICE9PSAxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdmFyIGN1cnJlbnRBY3RpdmUgPSB0aGlzLmNhbnZhcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgaWYgKGN1cnJlbnRBY3RpdmUgJiYgY3VycmVudEFjdGl2ZSAhPT0gdGhpcykge1xuICAgICAgICAvLyBhdm9pZCBydW5uaW5nIHRoaXMgbG9naWMgd2hlbiB0aGVyZSBpcyBhbiBhY3RpdmUgb2JqZWN0XG4gICAgICAgIC8vIHRoaXMgYmVjYXVzZSBpcyBwb3NzaWJsZSB3aXRoIHNoaWZ0IGNsaWNrIGFuZCBmYXN0IGNsaWNrcyxcbiAgICAgICAgLy8gdG8gcmFwaWRseSBkZXNlbGVjdCBhbmQgcmVzZWxlY3QgdGhpcyBvYmplY3QgYW5kIHRyaWdnZXIgYW4gZW50ZXJFZGl0XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fX2xhc3RTZWxlY3RlZCAmJiAhdGhpcy5fX2Nvcm5lcikge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2xhc3RTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbnRlckVkaXRpbmcob3B0aW9ucy5lKTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoYW5nZXMgY3Vyc29yIGxvY2F0aW9uIGluIGEgdGV4dCBkZXBlbmRpbmcgb24gcGFzc2VkIHBvaW50ZXIgKHgveSkgb2JqZWN0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBzZXRDdXJzb3JCeUNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihlKSxcbiAgICAgICAgc3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0LCBlbmQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdChzdGFydCwgZW5kLCBuZXdTZWxlY3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb247XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgaW5kZXggb2YgYSBjaGFyYWN0ZXIgY29ycmVzcG9uZGluZyB0byB3aGVyZSBhbiBvYmplY3Qgd2FzIGNsaWNrZWRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHJldHVybiB7TnVtYmVyfSBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcjogZnVuY3Rpb24oZSkge1xuICAgIHZhciBtb3VzZU9mZnNldCA9IHRoaXMuZ2V0TG9jYWxQb2ludGVyKGUpLFxuICAgICAgICBwcmV2V2lkdGggPSAwLFxuICAgICAgICB3aWR0aCA9IDAsXG4gICAgICAgIGhlaWdodCA9IDAsXG4gICAgICAgIGNoYXJJbmRleCA9IDAsXG4gICAgICAgIGxpbmVJbmRleCA9IDAsXG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0LFxuICAgICAgICBsaW5lO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChoZWlnaHQgPD0gbW91c2VPZmZzZXQueSkge1xuICAgICAgICBoZWlnaHQgKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSkgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgbGluZUluZGV4ID0gaTtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgY2hhckluZGV4ICs9IHRoaXMuX3RleHRMaW5lc1tpIC0gMV0ubGVuZ3RoICsgdGhpcy5taXNzaW5nTmV3bGluZU9mZnNldChpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lSW5kZXgpO1xuICAgIHdpZHRoID0gbGluZUxlZnRPZmZzZXQgKiB0aGlzLnNjYWxlWDtcbiAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF07XG4gICAgLy8gaGFuZGxpbmcgb2YgUlRMOiBpbiBvcmRlciB0byBnZXQgdGhpbmdzIHdvcmsgY29ycmVjdGx5LFxuICAgIC8vIHdlIGFzc3VtZSBSVEwgd3JpdGluZyBpcyBtaXJyb3JlZCBjb21wYXJlZCB0byBMVFIgd3JpdGluZy5cbiAgICAvLyBzbyBpbiBwb3NpdGlvbiBkZXRlY3Rpb24gd2UgbWlycm9yIHRoZSBYIG9mZnNldCwgYW5kIHdoZW4gaXMgdGltZVxuICAgIC8vIG9mIHJlbmRlcmluZyBpdCwgd2UgbWlycm9yIGl0IGFnYWluLlxuICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgIG1vdXNlT2Zmc2V0LnggPSB0aGlzLndpZHRoICogdGhpcy5zY2FsZVggLSBtb3VzZU9mZnNldC54ICsgd2lkdGg7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgIHByZXZXaWR0aCA9IHdpZHRoO1xuICAgICAgLy8gaSByZW1vdmVkIHNvbWV0aGluZyBhYm91dCBmbGlwWCBoZXJlLCBjaGVjay5cbiAgICAgIHdpZHRoICs9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bal0ua2VybmVkV2lkdGggKiB0aGlzLnNjYWxlWDtcbiAgICAgIGlmICh3aWR0aCA8PSBtb3VzZU9mZnNldC54KSB7XG4gICAgICAgIGNoYXJJbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZ2V0TmV3U2VsZWN0aW9uU3RhcnRGcm9tT2Zmc2V0KG1vdXNlT2Zmc2V0LCBwcmV2V2lkdGgsIHdpZHRoLCBjaGFySW5kZXgsIGpsZW4pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE5ld1NlbGVjdGlvblN0YXJ0RnJvbU9mZnNldDogZnVuY3Rpb24obW91c2VPZmZzZXQsIHByZXZXaWR0aCwgd2lkdGgsIGluZGV4LCBqbGVuKSB7XG4gICAgLy8gd2UgbmVlZCBNYXRoLmFicyBiZWNhdXNlIHdoZW4gd2lkdGggaXMgYWZ0ZXIgdGhlIGxhc3QgY2hhciwgdGhlIG9mZnNldCBpcyBnaXZlbiBhcyAxLCB3aGlsZSBpcyAwXG4gICAgdmFyIGRpc3RhbmNlQnR3TGFzdENoYXJBbmRDdXJzb3IgPSBtb3VzZU9mZnNldC54IC0gcHJldldpZHRoLFxuICAgICAgICBkaXN0YW5jZUJ0d05leHRDaGFyQW5kQ3Vyc29yID0gd2lkdGggLSBtb3VzZU9mZnNldC54LFxuICAgICAgICBvZmZzZXQgPSBkaXN0YW5jZUJ0d05leHRDaGFyQW5kQ3Vyc29yID4gZGlzdGFuY2VCdHdMYXN0Q2hhckFuZEN1cnNvciB8fFxuICAgICAgICAgIGRpc3RhbmNlQnR3TmV4dENoYXJBbmRDdXJzb3IgPCAwID8gMCA6IDEsXG4gICAgICAgIG5ld1NlbGVjdGlvblN0YXJ0ID0gaW5kZXggKyBvZmZzZXQ7XG4gICAgLy8gaWYgb2JqZWN0IGlzIGhvcml6b250YWxseSBmbGlwcGVkLCBtaXJyb3IgY3Vyc29yIGxvY2F0aW9uIGZyb20gdGhlIGVuZFxuICAgIGlmICh0aGlzLmZsaXBYKSB7XG4gICAgICBuZXdTZWxlY3Rpb25TdGFydCA9IGpsZW4gLSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICB9XG5cbiAgICBpZiAobmV3U2VsZWN0aW9uU3RhcnQgPiB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLl90ZXh0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gIH1cbn0pO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLklUZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgaGlkZGVuIHRleHRhcmVhIChuZWVkZWQgdG8gYnJpbmcgdXAga2V5Ym9hcmQgaW4gaU9TKVxuICAgKi9cbiAgaW5pdEhpZGRlblRleHRhcmVhOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2F1dG9jYXBpdGFsaXplJywgJ29mZicpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdhdXRvY29ycmVjdCcsICdvZmYnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXV0b2NvbXBsZXRlJywgJ29mZicpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgJ2ZhbHNlJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2RhdGEtZmFicmljLWhpZGRlbnRleHRhcmVhJywgJycpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCd3cmFwJywgJ29mZicpO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuX2NhbGNUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgLy8gbGluZS1oZWlnaHQ6IDFweDsgd2FzIHJlbW92ZWQgZnJvbSB0aGUgc3R5bGUgdG8gZml4IHRoaXM6XG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODcwOTY2XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAnICsgc3R5bGUudG9wICtcbiAgICAnOyBsZWZ0OiAnICsgc3R5bGUubGVmdCArICc7IHotaW5kZXg6IC05OTk7IG9wYWNpdHk6IDA7IHdpZHRoOiAxcHg7IGhlaWdodDogMXB4OyBmb250LXNpemU6IDFweDsnICtcbiAgICAnIHBhZGRpbmctdG9wOiAnICsgc3R5bGUuZm9udFNpemUgKyAnOyc7XG5cbiAgICBpZiAodGhpcy5oaWRkZW5UZXh0YXJlYUNvbnRhaW5lcikge1xuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmhpZGRlblRleHRhcmVhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmYWJyaWMuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmhpZGRlblRleHRhcmVhKTtcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAna2V5ZG93bicsIHRoaXMub25LZXlEb3duLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdrZXl1cCcsIHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnaW5wdXQnLCB0aGlzLm9uSW5wdXQuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2NvcHknLCB0aGlzLmNvcHkuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2N1dCcsIHRoaXMuY29weS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAncGFzdGUnLCB0aGlzLnBhc3RlLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb21wb3NpdGlvbnN0YXJ0JywgdGhpcy5vbkNvbXBvc2l0aW9uU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2NvbXBvc2l0aW9udXBkYXRlJywgdGhpcy5vbkNvbXBvc2l0aW9uVXBkYXRlLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb21wb3NpdGlvbmVuZCcsIHRoaXMub25Db21wb3NpdGlvbkVuZC5iaW5kKHRoaXMpKTtcblxuICAgIGlmICghdGhpcy5fY2xpY2tIYW5kbGVySW5pdGlhbGl6ZWQgJiYgdGhpcy5jYW52YXMpIHtcbiAgICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuY2FudmFzLnVwcGVyQ2FudmFzRWwsICdjbGljaycsIHRoaXMub25DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX2NsaWNrSGFuZGxlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBmdW5jdGlvbmFsaXRpZXMgb24ga2V5RG93blxuICAgKiBNYXAgYSBzcGVjaWFsIGtleSB0byBhIGZ1bmN0aW9uIG9mIHRoZSBpbnN0YW5jZS9wcm90b3R5cGVcbiAgICogSWYgeW91IG5lZWQgZGlmZmVyZW50IGJlaGF2aW91ciBmb3IgRVNDIG9yIFRBQiBvciBhcnJvd3MsIHlvdSBoYXZlIHRvIGNoYW5nZVxuICAgKiB0aGlzIG1hcCBzZXR0aW5nIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gdGhhdCB5b3UgYnVpbGQgb24gdGhlIGZhYnJpYy5JdGV4dCBvclxuICAgKiB5b3VyIHByb3RvdHlwZS5cbiAgICogdGhlIG1hcCBjaGFuZ2Ugd2lsbCBhZmZlY3QgYWxsIEluc3RhbmNlcyB1bmxlc3MgeW91IG5lZWQgZm9yIG9ubHkgc29tZSB0ZXh0IEluc3RhbmNlc1xuICAgKiBpbiB0aGF0IGNhc2UgeW91IGhhdmUgdG8gY2xvbmUgdGhpcyBvYmplY3QgYW5kIGFzc2lnbiB5b3VyIEluc3RhbmNlLlxuICAgKiB0aGlzLmtleXNNYXAgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUodGhpcy5rZXlzTWFwKTtcbiAgICogVGhlIGZ1bmN0aW9uIG11c3QgYmUgaW4gZmFicmljLkl0ZXh0LnByb3RvdHlwZS5teUZ1bmN0aW9uIEFuZCB3aWxsIHJlY2VpdmUgZXZlbnQgYXMgYXJnc1swXVxuICAgKi9cbiAga2V5c01hcDoge1xuICAgIDk6ICAnZXhpdEVkaXRpbmcnLFxuICAgIDI3OiAnZXhpdEVkaXRpbmcnLFxuICAgIDMzOiAnbW92ZUN1cnNvclVwJyxcbiAgICAzNDogJ21vdmVDdXJzb3JEb3duJyxcbiAgICAzNTogJ21vdmVDdXJzb3JSaWdodCcsXG4gICAgMzY6ICdtb3ZlQ3Vyc29yTGVmdCcsXG4gICAgMzc6ICdtb3ZlQ3Vyc29yTGVmdCcsXG4gICAgMzg6ICdtb3ZlQ3Vyc29yVXAnLFxuICAgIDM5OiAnbW92ZUN1cnNvclJpZ2h0JyxcbiAgICA0MDogJ21vdmVDdXJzb3JEb3duJyxcbiAgfSxcblxuICBrZXlzTWFwUnRsOiB7XG4gICAgOTogICdleGl0RWRpdGluZycsXG4gICAgMjc6ICdleGl0RWRpdGluZycsXG4gICAgMzM6ICdtb3ZlQ3Vyc29yVXAnLFxuICAgIDM0OiAnbW92ZUN1cnNvckRvd24nLFxuICAgIDM1OiAnbW92ZUN1cnNvckxlZnQnLFxuICAgIDM2OiAnbW92ZUN1cnNvclJpZ2h0JyxcbiAgICAzNzogJ21vdmVDdXJzb3JSaWdodCcsXG4gICAgMzg6ICdtb3ZlQ3Vyc29yVXAnLFxuICAgIDM5OiAnbW92ZUN1cnNvckxlZnQnLFxuICAgIDQwOiAnbW92ZUN1cnNvckRvd24nLFxuICB9LFxuXG4gIC8qKlxuICAgKiBGb3IgZnVuY3Rpb25hbGl0aWVzIG9uIGtleVVwICsgY3RybCB8fCBjbWRcbiAgICovXG4gIGN0cmxLZXlzTWFwVXA6IHtcbiAgICA2NzogJ2NvcHknLFxuICAgIDg4OiAnY3V0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3IgZnVuY3Rpb25hbGl0aWVzIG9uIGtleURvd24gKyBjdHJsIHx8IGNtZFxuICAgKi9cbiAgY3RybEtleXNNYXBEb3duOiB7XG4gICAgNjU6ICdzZWxlY3RBbGwnXG4gIH0sXG5cbiAgb25DbGljazogZnVuY3Rpb24oKSB7XG4gICAgLy8gTm8gbmVlZCB0byB0cmlnZ2VyIGNsaWNrIGV2ZW50IGhlcmUsIGZvY3VzIGlzIGVub3VnaCB0byBoYXZlIHRoZSBrZXlib2FyZCBhcHBlYXIgb24gQW5kcm9pZFxuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEgJiYgdGhpcy5oaWRkZW5UZXh0YXJlYS5mb2N1cygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleWRvd24gZXZlbnRcbiAgICogb25seSB1c2VkIGZvciBhcnJvd3MgYW5kIGNvbWJpbmF0aW9uIG9mIG1vZGlmaWVyIGtleXMuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBvbktleURvd246IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXlNYXAgPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCcgPyB0aGlzLmtleXNNYXBSdGwgOiB0aGlzLmtleXNNYXA7XG4gICAgaWYgKGUua2V5Q29kZSBpbiBrZXlNYXApIHtcbiAgICAgIHRoaXNba2V5TWFwW2Uua2V5Q29kZV1dKGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoZS5rZXlDb2RlIGluIHRoaXMuY3RybEtleXNNYXBEb3duKSAmJiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkpIHtcbiAgICAgIHRoaXNbdGhpcy5jdHJsS2V5c01hcERvd25bZS5rZXlDb2RlXV0oZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoZS5rZXlDb2RlID49IDMzICYmIGUua2V5Q29kZSA8PSA0MCkge1xuICAgICAgLy8gaWYgaSBwcmVzcyBhbiBhcnJvdyBrZXkganVzdCB1cGRhdGUgc2VsZWN0aW9uXG4gICAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gZmFsc2U7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dFRvcCgpO1xuICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5dXAgZXZlbnRcbiAgICogV2UgaGFuZGxlIEtleVVwIGJlY2F1c2UgaWUxMSBhbmQgZWRnZSBoYXZlIGRpZmZpY3VsdGllcyBjb3B5L3Bhc3RpbmdcbiAgICogaWYgYSBjb3B5L2N1dCBldmVudCBmaXJlZCwga2V5dXAgaXMgZGlzbWlzc2VkXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBvbktleVVwOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZyB8fCB0aGlzLl9jb3B5RG9uZSB8fCB0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICB0aGlzLl9jb3B5RG9uZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoKGUua2V5Q29kZSBpbiB0aGlzLmN0cmxLZXlzTWFwVXApICYmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSkge1xuICAgICAgdGhpc1t0aGlzLmN0cmxLZXlzTWFwVXBbZS5rZXlDb2RlXV0oZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgb25JbnB1dCBldmVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgb25JbnB1dDogZnVuY3Rpb24oZSkge1xuICAgIHZhciBmcm9tUGFzdGUgPSB0aGlzLmZyb21QYXN0ZTtcbiAgICB0aGlzLmZyb21QYXN0ZSA9IGZhbHNlO1xuICAgIGUgJiYgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGRlY2lzaW9ucyBhYm91dCBzdHlsZSBjaGFuZ2VzLlxuICAgIHZhciBuZXh0VGV4dCA9IHRoaXMuX3NwbGl0VGV4dEludG9MaW5lcyh0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlKS5ncmFwaGVtZVRleHQsXG4gICAgICAgIGNoYXJDb3VudCA9IHRoaXMuX3RleHQubGVuZ3RoLFxuICAgICAgICBuZXh0Q2hhckNvdW50ID0gbmV4dFRleHQubGVuZ3RoLFxuICAgICAgICByZW1vdmVkVGV4dCwgaW5zZXJ0ZWRUZXh0LFxuICAgICAgICBjaGFyRGlmZiA9IG5leHRDaGFyQ291bnQgLSBjaGFyQ291bnQsXG4gICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25FbmQsXG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvblN0YXJ0ICE9PSBzZWxlY3Rpb25FbmQsXG4gICAgICAgIGNvcGllZFN0eWxlLCByZW1vdmVGcm9tLCByZW1vdmVUbztcbiAgICBpZiAodGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSA9PT0gJycpIHtcbiAgICAgIHRoaXMuc3R5bGVzID0geyB9O1xuICAgICAgdGhpcy51cGRhdGVGcm9tVGV4dEFyZWEoKTtcbiAgICAgIHRoaXMuZmlyZSgnY2hhbmdlZCcpO1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6Y2hhbmdlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRleHRhcmVhU2VsZWN0aW9uID0gdGhpcy5mcm9tU3RyaW5nVG9HcmFwaGVtZVNlbGVjdGlvbihcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQsXG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvbkVuZCxcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWVcbiAgICApO1xuICAgIHZhciBiYWNrRGVsZXRlID0gc2VsZWN0aW9uU3RhcnQgPiB0ZXh0YXJlYVNlbGVjdGlvbi5zZWxlY3Rpb25TdGFydDtcblxuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIHJlbW92ZWRUZXh0ID0gdGhpcy5fdGV4dC5zbGljZShzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKTtcbiAgICAgIGNoYXJEaWZmICs9IHNlbGVjdGlvbkVuZCAtIHNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIGlmIChuZXh0Q2hhckNvdW50IDwgY2hhckNvdW50KSB7XG4gICAgICBpZiAoYmFja0RlbGV0ZSkge1xuICAgICAgICByZW1vdmVkVGV4dCA9IHRoaXMuX3RleHQuc2xpY2Uoc2VsZWN0aW9uRW5kICsgY2hhckRpZmYsIHNlbGVjdGlvbkVuZCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlZFRleHQgPSB0aGlzLl90ZXh0LnNsaWNlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25TdGFydCAtIGNoYXJEaWZmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW5zZXJ0ZWRUZXh0ID0gbmV4dFRleHQuc2xpY2UodGV4dGFyZWFTZWxlY3Rpb24uc2VsZWN0aW9uRW5kIC0gY2hhckRpZmYsIHRleHRhcmVhU2VsZWN0aW9uLnNlbGVjdGlvbkVuZCk7XG4gICAgaWYgKHJlbW92ZWRUZXh0ICYmIHJlbW92ZWRUZXh0Lmxlbmd0aCkge1xuICAgICAgaWYgKGluc2VydGVkVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgLy8gbGV0J3MgY29weSBzb21lIHN0eWxlIGJlZm9yZSBkZWxldGluZy5cbiAgICAgICAgLy8gd2Ugd2FudCB0byBjb3B5IHRoZSBzdHlsZSBiZWZvcmUgdGhlIGN1cnNvciBPUiB0aGUgc3R5bGUgYXQgdGhlIGN1cnNvciBpZiBzZWxlY3Rpb25cbiAgICAgICAgLy8gaXMgYmlnZ2VyIHRoYW4gMC5cbiAgICAgICAgY29waWVkU3R5bGUgPSB0aGlzLmdldFNlbGVjdGlvblN0eWxlcyhzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uU3RhcnQgKyAxLCBmYWxzZSk7XG4gICAgICAgIC8vIG5vdyBkdXBsaWNhdGUgdGhlIHN0eWxlIG9uZSBmb3IgZWFjaCBpbnNlcnRlZCB0ZXh0LlxuICAgICAgICBjb3BpZWRTdHlsZSA9IGluc2VydGVkVGV4dC5tYXAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gdGhpcyByZXR1cm4gYW4gYXJyYXkgb2YgcmVmZXJlbmNlcywgYnV0IHRoYXQgaXMgZmluZSBzaW5jZSB3ZSBhcmVcbiAgICAgICAgICAvLyBjb3B5aW5nIHRoZSBzdHlsZSBsYXRlci5cbiAgICAgICAgICByZXR1cm4gY29waWVkU3R5bGVbMF07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICByZW1vdmVGcm9tID0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHJlbW92ZVRvID0gc2VsZWN0aW9uRW5kO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYmFja0RlbGV0ZSkge1xuICAgICAgICAvLyBkZXRlY3QgZGlmZmVyZW5jZXMgYmV0d2VlbiBmb3J3YXJkRGVsZXRlIGFuZCBiYWNrRGVsZXRlXG4gICAgICAgIHJlbW92ZUZyb20gPSBzZWxlY3Rpb25FbmQgLSByZW1vdmVkVGV4dC5sZW5ndGg7XG4gICAgICAgIHJlbW92ZVRvID0gc2VsZWN0aW9uRW5kO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyb20gPSBzZWxlY3Rpb25FbmQ7XG4gICAgICAgIHJlbW92ZVRvID0gc2VsZWN0aW9uRW5kICsgcmVtb3ZlZFRleHQubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW1vdmVTdHlsZUZyb21UbyhyZW1vdmVGcm9tLCByZW1vdmVUbyk7XG4gICAgfVxuICAgIGlmIChpbnNlcnRlZFRleHQubGVuZ3RoKSB7XG4gICAgICBpZiAoZnJvbVBhc3RlICYmIGluc2VydGVkVGV4dC5qb2luKCcnKSA9PT0gZmFicmljLmNvcGllZFRleHQgJiYgIWZhYnJpYy5kaXNhYmxlU3R5bGVDb3B5UGFzdGUpIHtcbiAgICAgICAgY29waWVkU3R5bGUgPSBmYWJyaWMuY29waWVkVGV4dFN0eWxlO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnNlcnROZXdTdHlsZUJsb2NrKGluc2VydGVkVGV4dCwgc2VsZWN0aW9uU3RhcnQsIGNvcGllZFN0eWxlKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVGcm9tVGV4dEFyZWEoKTtcbiAgICB0aGlzLmZpcmUoJ2NoYW5nZWQnKTtcbiAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6Y2hhbmdlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIENvbXBvc2l0aW9uIHN0YXJ0XG4gICAqL1xuICBvbkNvbXBvc2l0aW9uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wb3NpdGlvbiBlbmRcbiAgICovXG4gIG9uQ29tcG9zaXRpb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPSBmYWxzZTtcbiAgfSxcblxuICAvLyAvKipcbiAgLy8gICogQ29tcG9zaXRpb24gdXBkYXRlXG4gIC8vICAqL1xuICBvbkNvbXBvc2l0aW9uVXBkYXRlOiBmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5jb21wb3NpdGlvblN0YXJ0ID0gZS50YXJnZXQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgdGhpcy5jb21wb3NpdGlvbkVuZCA9IGUudGFyZ2V0LnNlbGVjdGlvbkVuZDtcbiAgICB0aGlzLnVwZGF0ZVRleHRhcmVhUG9zaXRpb24oKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29waWVzIHNlbGVjdGVkIHRleHRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgLy9kbyBub3QgY3V0LWNvcHkgaWYgbm8gc2VsZWN0aW9uXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmFicmljLmNvcGllZFRleHQgPSB0aGlzLmdldFNlbGVjdGVkVGV4dCgpO1xuICAgIGlmICghZmFicmljLmRpc2FibGVTdHlsZUNvcHlQYXN0ZSkge1xuICAgICAgZmFicmljLmNvcGllZFRleHRTdHlsZSA9IHRoaXMuZ2V0U2VsZWN0aW9uU3R5bGVzKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kLCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmYWJyaWMuY29waWVkVGV4dFN0eWxlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fY29weURvbmUgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYXN0ZXMgdGV4dFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgcGFzdGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZnJvbVBhc3RlID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHJldHVybiB7T2JqZWN0fSBDbGlwYm9hcmQgZGF0YSBvYmplY3RcbiAgICovXG4gIF9nZXRDbGlwYm9hcmREYXRhOiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIChlICYmIGUuY2xpcGJvYXJkRGF0YSkgfHwgZmFicmljLndpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgd2lkdGggaW4gcGl4ZWxzIGJlZm9yZSB0aGUgY3Vyc29yIG9uIHRoZSBzYW1lIGxpbmVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAqIEByZXR1cm4ge051bWJlcn0gd2lkdGhCZWZvcmVDdXJzb3Igd2lkdGggYmVmb3JlIGN1cnNvclxuICAgKi9cbiAgX2dldFdpZHRoQmVmb3JlQ3Vyc29yOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgIHZhciB3aWR0aEJlZm9yZUN1cnNvciA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVJbmRleCksIGJvdW5kO1xuXG4gICAgaWYgKGNoYXJJbmRleCA+IDApIHtcbiAgICAgIGJvdW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtjaGFySW5kZXggLSAxXTtcbiAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yICs9IGJvdW5kLmxlZnQgKyBib3VuZC53aWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoQmVmb3JlQ3Vyc29yO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHN0YXJ0IG9mZnNldCBvZiBhIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0RG93bkN1cnNvck9mZnNldDogZnVuY3Rpb24oZSwgaXNSaWdodCkge1xuICAgIHZhciBzZWxlY3Rpb25Qcm9wID0gdGhpcy5fZ2V0U2VsZWN0aW9uRm9yT2Zmc2V0KGUsIGlzUmlnaHQpLFxuICAgICAgICBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25Qcm9wKSxcbiAgICAgICAgbGluZUluZGV4ID0gY3Vyc29yTG9jYXRpb24ubGluZUluZGV4O1xuICAgIC8vIGlmIG9uIGxhc3QgbGluZSwgZG93biBjdXJzb3IgZ29lcyB0byBlbmQgb2YgbGluZVxuICAgIGlmIChsaW5lSW5kZXggPT09IHRoaXMuX3RleHRMaW5lcy5sZW5ndGggLSAxIHx8IGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDM0KSB7XG4gICAgICAvLyBtb3ZlIHRvIHRoZSBlbmQgb2YgYSB0ZXh0XG4gICAgICByZXR1cm4gdGhpcy5fdGV4dC5sZW5ndGggLSBzZWxlY3Rpb25Qcm9wO1xuICAgIH1cbiAgICB2YXIgY2hhckluZGV4ID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4LFxuICAgICAgICB3aWR0aEJlZm9yZUN1cnNvciA9IHRoaXMuX2dldFdpZHRoQmVmb3JlQ3Vyc29yKGxpbmVJbmRleCwgY2hhckluZGV4KSxcbiAgICAgICAgaW5kZXhPbk90aGVyTGluZSA9IHRoaXMuX2dldEluZGV4T25MaW5lKGxpbmVJbmRleCArIDEsIHdpZHRoQmVmb3JlQ3Vyc29yKSxcbiAgICAgICAgdGV4dEFmdGVyQ3Vyc29yID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0uc2xpY2UoY2hhckluZGV4KTtcbiAgICByZXR1cm4gdGV4dEFmdGVyQ3Vyc29yLmxlbmd0aCArIGluZGV4T25PdGhlckxpbmUgKyAxICsgdGhpcy5taXNzaW5nTmV3bGluZU9mZnNldChsaW5lSW5kZXgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBwcml2YXRlXG4gICAqIEhlbHBzIGZpbmRpbmcgaWYgdGhlIG9mZnNldCBzaG91bGQgYmUgY291bnRlZCBmcm9tIFN0YXJ0IG9yIEVuZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgX2dldFNlbGVjdGlvbkZvck9mZnNldDogZnVuY3Rpb24oZSwgaXNSaWdodCkge1xuICAgIGlmIChlLnNoaWZ0S2V5ICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kICYmIGlzUmlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNSaWdodFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRVcEN1cnNvck9mZnNldDogZnVuY3Rpb24oZSwgaXNSaWdodCkge1xuICAgIHZhciBzZWxlY3Rpb25Qcm9wID0gdGhpcy5fZ2V0U2VsZWN0aW9uRm9yT2Zmc2V0KGUsIGlzUmlnaHQpLFxuICAgICAgICBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25Qcm9wKSxcbiAgICAgICAgbGluZUluZGV4ID0gY3Vyc29yTG9jYXRpb24ubGluZUluZGV4O1xuICAgIGlmIChsaW5lSW5kZXggPT09IDAgfHwgZS5tZXRhS2V5IHx8IGUua2V5Q29kZSA9PT0gMzMpIHtcbiAgICAgIC8vIGlmIG9uIGZpcnN0IGxpbmUsIHVwIGN1cnNvciBnb2VzIHRvIHN0YXJ0IG9mIGxpbmVcbiAgICAgIHJldHVybiAtc2VsZWN0aW9uUHJvcDtcbiAgICB9XG4gICAgdmFyIGNoYXJJbmRleCA9IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCxcbiAgICAgICAgd2lkdGhCZWZvcmVDdXJzb3IgPSB0aGlzLl9nZXRXaWR0aEJlZm9yZUN1cnNvcihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgIGluZGV4T25PdGhlckxpbmUgPSB0aGlzLl9nZXRJbmRleE9uTGluZShsaW5lSW5kZXggLSAxLCB3aWR0aEJlZm9yZUN1cnNvciksXG4gICAgICAgIHRleHRCZWZvcmVDdXJzb3IgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XS5zbGljZSgwLCBjaGFySW5kZXgpLFxuICAgICAgICBtaXNzaW5nTmV3bGluZU9mZnNldCA9IHRoaXMubWlzc2luZ05ld2xpbmVPZmZzZXQobGluZUluZGV4IC0gMSk7XG4gICAgLy8gcmV0dXJuIGEgbmVnYXRpdmUgb2Zmc2V0XG4gICAgcmV0dXJuIC10aGlzLl90ZXh0TGluZXNbbGluZUluZGV4IC0gMV0ubGVuZ3RoXG4gICAgICsgaW5kZXhPbk90aGVyTGluZSAtIHRleHRCZWZvcmVDdXJzb3IubGVuZ3RoICsgKDEgLSBtaXNzaW5nTmV3bGluZU9mZnNldCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZvciBhIGdpdmVuIHdpZHRoIGl0IGZvdW5kcyB0aGUgbWF0Y2hpbmcgY2hhcmFjdGVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEluZGV4T25MaW5lOiBmdW5jdGlvbihsaW5lSW5kZXgsIHdpZHRoKSB7XG5cbiAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLFxuICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVJbmRleCksXG4gICAgICAgIHdpZHRoT2ZDaGFyc09uTGluZSA9IGxpbmVMZWZ0T2Zmc2V0LFxuICAgICAgICBpbmRleE9uTGluZSA9IDAsIGNoYXJXaWR0aCwgZm91bmRNYXRjaDtcblxuICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgIGNoYXJXaWR0aCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bal0ud2lkdGg7XG4gICAgICB3aWR0aE9mQ2hhcnNPbkxpbmUgKz0gY2hhcldpZHRoO1xuICAgICAgaWYgKHdpZHRoT2ZDaGFyc09uTGluZSA+IHdpZHRoKSB7XG4gICAgICAgIGZvdW5kTWF0Y2ggPSB0cnVlO1xuICAgICAgICB2YXIgbGVmdEVkZ2UgPSB3aWR0aE9mQ2hhcnNPbkxpbmUgLSBjaGFyV2lkdGgsXG4gICAgICAgICAgICByaWdodEVkZ2UgPSB3aWR0aE9mQ2hhcnNPbkxpbmUsXG4gICAgICAgICAgICBvZmZzZXRGcm9tTGVmdEVkZ2UgPSBNYXRoLmFicyhsZWZ0RWRnZSAtIHdpZHRoKSxcbiAgICAgICAgICAgIG9mZnNldEZyb21SaWdodEVkZ2UgPSBNYXRoLmFicyhyaWdodEVkZ2UgLSB3aWR0aCk7XG5cbiAgICAgICAgaW5kZXhPbkxpbmUgPSBvZmZzZXRGcm9tUmlnaHRFZGdlIDwgb2Zmc2V0RnJvbUxlZnRFZGdlID8gaiA6IChqIC0gMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlYWNoZWQgZW5kXG4gICAgaWYgKCFmb3VuZE1hdGNoKSB7XG4gICAgICBpbmRleE9uTGluZSA9IGxpbmUubGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXhPbkxpbmU7XG4gIH0sXG5cblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIGRvd25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JEb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPj0gdGhpcy5fdGV4dC5sZW5ndGggJiYgdGhpcy5zZWxlY3Rpb25FbmQgPj0gdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvclVwT3JEb3duKCdEb3duJywgZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB1cFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvclVwOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IDAgJiYgdGhpcy5zZWxlY3Rpb25FbmQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvclVwT3JEb3duKCdVcCcsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgdXAgb3IgZG93biwgZmlyZXMgdGhlIGV2ZW50c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uICdVcCcgb3IgJ0Rvd24nXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBfbW92ZUN1cnNvclVwT3JEb3duOiBmdW5jdGlvbihkaXJlY3Rpb24sIGUpIHtcbiAgICAvLyBnZXRVcEN1cnNvck9mZnNldFxuICAgIC8vIGdldERvd25DdXJzb3JPZmZzZXRcbiAgICB2YXIgYWN0aW9uID0gJ2dldCcgKyBkaXJlY3Rpb24gKyAnQ3Vyc29yT2Zmc2V0JyxcbiAgICAgICAgb2Zmc2V0ID0gdGhpc1thY3Rpb25dKGUsIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jyk7XG4gICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgIHRoaXMubW92ZUN1cnNvcldpdGhTaGlmdChvZmZzZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMubW92ZUN1cnNvcldpdGhvdXRTaGlmdChvZmZzZXQpO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvbkluQm91bmRhcmllcygpO1xuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAxO1xuICAgICAgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3Igd2l0aCBzaGlmdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBtb3ZlQ3Vyc29yV2l0aFNoaWZ0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAnbGVmdCdcbiAgICAgID8gdGhpcy5zZWxlY3Rpb25TdGFydCArIG9mZnNldFxuICAgICAgOiB0aGlzLnNlbGVjdGlvbkVuZCArIG9mZnNldDtcbiAgICB0aGlzLnNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0KHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kLCBuZXdTZWxlY3Rpb24pO1xuICAgIHJldHVybiBvZmZzZXQgIT09IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB1cCB3aXRob3V0IHNoaWZ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIG1vdmVDdXJzb3JXaXRob3V0U2hpZnQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ICs9IG9mZnNldDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCArPSBvZmZzZXQ7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgIT09IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciBsZWZ0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yTGVmdDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSAwICYmIHRoaXMuc2VsZWN0aW9uRW5kID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3JMZWZ0T3JSaWdodCgnTGVmdCcsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGEgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBfbW92ZTogZnVuY3Rpb24oZSwgcHJvcCwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIG5ld1ZhbHVlO1xuICAgIGlmIChlLmFsdEtleSkge1xuICAgICAgbmV3VmFsdWUgPSB0aGlzWydmaW5kV29yZEJvdW5kYXJ5JyArIGRpcmVjdGlvbl0odGhpc1twcm9wXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDM1IHx8ICBlLmtleUNvZGUgPT09IDM2ICkge1xuICAgICAgbmV3VmFsdWUgPSB0aGlzWydmaW5kTGluZUJvdW5kYXJ5JyArIGRpcmVjdGlvbl0odGhpc1twcm9wXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1twcm9wXSArPSBkaXJlY3Rpb24gPT09ICdMZWZ0JyA/IC0xIDogMTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld1ZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzW3Byb3BdICE9PSBuZXdWYWx1ZSkge1xuICAgICAgdGhpc1twcm9wXSA9IG5ld1ZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vdmVMZWZ0OiBmdW5jdGlvbihlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vdmUoZSwgcHJvcCwgJ0xlZnQnKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb3ZlUmlnaHQ6IGZ1bmN0aW9uKGUsIHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5fbW92ZShlLCBwcm9wLCAnUmlnaHQnKTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIGxlZnQgd2l0aG91dCBrZWVwaW5nIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBtb3ZlQ3Vyc29yTGVmdFdpdGhvdXRTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIHZhciBjaGFuZ2UgPSB0cnVlO1xuICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdsZWZ0JztcblxuICAgIC8vIG9ubHkgbW92ZSBjdXJzb3Igd2hlbiB0aGVyZSBpcyBubyBzZWxlY3Rpb24sXG4gICAgLy8gb3RoZXJ3aXNlIHdlIGRpc2NhcmQgaXQsIGFuZCBsZWF2ZSBjdXJzb3Igb24gc2FtZSBwbGFjZVxuICAgIGlmICh0aGlzLnNlbGVjdGlvbkVuZCA9PT0gdGhpcy5zZWxlY3Rpb25TdGFydCAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSAwKSB7XG4gICAgICBjaGFuZ2UgPSB0aGlzLl9tb3ZlTGVmdChlLCAnc2VsZWN0aW9uU3RhcnQnKTtcblxuICAgIH1cbiAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIGxlZnQgd2hpbGUga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgbW92ZUN1cnNvckxlZnRXaXRoU2hpZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZUxlZnQoZSwgJ3NlbGVjdGlvbkVuZCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSAwKXtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlTGVmdChlLCAnc2VsZWN0aW9uU3RhcnQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciByaWdodFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvclJpZ2h0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPj0gdGhpcy5fdGV4dC5sZW5ndGggJiYgdGhpcy5zZWxlY3Rpb25FbmQgPj0gdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvckxlZnRPclJpZ2h0KCdSaWdodCcsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHQgb3IgTGVmdCwgZmlyZXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiAnTGVmdCcsICdSaWdodCdcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIF9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQ6IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgIHZhciBhY3Rpb25OYW1lID0gJ21vdmVDdXJzb3InICsgZGlyZWN0aW9uICsgJ1dpdGgnO1xuICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMTtcblxuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICBhY3Rpb25OYW1lICs9ICdTaGlmdCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWN0aW9uTmFtZSArPSAnb3V0U2hpZnQnO1xuICAgIH1cbiAgICBpZiAodGhpc1thY3Rpb25OYW1lXShlKSkge1xuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHQgd2hpbGUga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgbW92ZUN1cnNvclJpZ2h0V2l0aFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ2xlZnQnICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZVJpZ2h0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbkVuZCAhPT0gdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZVJpZ2h0KGUsICdzZWxlY3Rpb25FbmQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciByaWdodCB3aXRob3V0IGtlZXBpbmcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yUmlnaHRXaXRob3V0U2hpZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcblxuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgY2hhbmdlZCA9IHRoaXMuX21vdmVSaWdodChlLCAnc2VsZWN0aW9uU3RhcnQnKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGNoYXJhY3RlcnMgZnJvbSBzdGFydC9lbmRcbiAgICogc3RhcnQvZW5kIGFyIHBlciBncmFwaGVtZSBwb3NpdGlvbiBpbiBfdGV4dCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgZGVmYXVsdCB0byBzdGFydCArIDFcbiAgICovXG4gIHJlbW92ZUNoYXJzOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBzdGFydCArIDE7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8oc3RhcnQsIGVuZCk7XG4gICAgdGhpcy5fdGV4dC5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbiAgICB0aGlzLnRleHQgPSB0aGlzLl90ZXh0LmpvaW4oJycpO1xuICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfVxuICAgIHRoaXMuX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXMoKTtcbiAgfSxcblxuICAvKipcbiAgICogaW5zZXJ0IGNoYXJhY3RlcnMgYXQgc3RhcnQgcG9zaXRpb24sIGJlZm9yZSBzdGFydCBwb3NpdGlvbi5cbiAgICogc3RhcnQgIGVxdWFsIDEgaXQgbWVhbnMgdGhlIHRleHQgZ2V0IGluc2VydGVkIGJldHdlZW4gYWN0dWFsIGdyYXBoZW1lIDAgYW5kIDFcbiAgICogaWYgc3R5bGUgYXJyYXkgaXMgcHJvdmlkZWQsIGl0IG11c3QgYmUgYXMgdGhlIHNhbWUgbGVuZ3RoIG9mIHRleHQgaW4gZ3JhcGhlbWVzXG4gICAqIGlmIGVuZCBpcyBwcm92aWRlZCBhbmQgaXMgYmlnZ2VyIHRoYW4gc3RhcnQsIG9sZCB0ZXh0IGlzIHJlcGxhY2VkLlxuICAgKiBzdGFydC9lbmQgYXIgcGVyIGdyYXBoZW1lIHBvc2l0aW9uIGluIF90ZXh0IGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0ZXh0IHRvIGluc2VydFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHlsZSBhcnJheSBvZiBzdHlsZSBvYmplY3RzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIGRlZmF1bHQgdG8gc3RhcnQgKyAxXG4gICAqL1xuICBpbnNlcnRDaGFyczogZnVuY3Rpb24odGV4dCwgc3R5bGUsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8oc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIHZhciBncmFwaGVtZXMgPSBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdCh0ZXh0KTtcbiAgICB0aGlzLmluc2VydE5ld1N0eWxlQmxvY2soZ3JhcGhlbWVzLCBzdGFydCwgc3R5bGUpO1xuICAgIHRoaXMuX3RleHQgPSBbXS5jb25jYXQodGhpcy5fdGV4dC5zbGljZSgwLCBzdGFydCksIGdyYXBoZW1lcywgdGhpcy5fdGV4dC5zbGljZShlbmQpKTtcbiAgICB0aGlzLnRleHQgPSB0aGlzLl90ZXh0LmpvaW4oJycpO1xuICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfVxuICAgIHRoaXMuX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXMoKTtcbiAgfSxcblxufSk7XG5cblxuLyogX1RPX1NWR19TVEFSVF8gKi9cbihmdW5jdGlvbigpIHtcbiAgdmFyIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgbXVsdGlwbGVTcGFjZXNSZWdleCA9IC8gICsvZztcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5UZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvZmZzZXRzID0gdGhpcy5fZ2V0U1ZHTGVmdFRvcE9mZnNldHMoKSxcbiAgICAgICAgICB0ZXh0QW5kQmcgPSB0aGlzLl9nZXRTVkdUZXh0QW5kQmcob2Zmc2V0cy50ZXh0VG9wLCBvZmZzZXRzLnRleHRMZWZ0KTtcbiAgICAgIHJldHVybiB0aGlzLl93cmFwU1ZHVGV4dEFuZEJnKHRleHRBbmRCZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cChcbiAgICAgICAgdGhpcy5fdG9TVkcoKSxcbiAgICAgICAgeyByZXZpdmVyOiByZXZpdmVyLCBub1N0eWxlOiB0cnVlLCB3aXRoU2hhZG93OiB0cnVlIH1cbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFNWR0xlZnRUb3BPZmZzZXRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHRMZWZ0OiAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAgIHRleHRUb3A6IC10aGlzLmhlaWdodCAvIDIsXG4gICAgICAgIGxpbmVUb3A6IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKDApXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF93cmFwU1ZHVGV4dEFuZEJnOiBmdW5jdGlvbih0ZXh0QW5kQmcpIHtcbiAgICAgIHZhciBub1NoYWRvdyA9IHRydWUsXG4gICAgICAgICAgdGV4dERlY29yYXRpb24gPSB0aGlzLmdldFN2Z1RleHREZWNvcmF0aW9uKHRoaXMpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGV4dEFuZEJnLnRleHRCZ1JlY3RzLmpvaW4oJycpLFxuICAgICAgICAnXFx0XFx0PHRleHQgeG1sOnNwYWNlPVwicHJlc2VydmVcIiAnLFxuICAgICAgICAodGhpcy5mb250RmFtaWx5ID8gJ2ZvbnQtZmFtaWx5PVwiJyArIHRoaXMuZm9udEZhbWlseS5yZXBsYWNlKC9cIi9nLCAnXFwnJykgKyAnXCIgJyA6ICcnKSxcbiAgICAgICAgKHRoaXMuZm9udFNpemUgPyAnZm9udC1zaXplPVwiJyArIHRoaXMuZm9udFNpemUgKyAnXCIgJyA6ICcnKSxcbiAgICAgICAgKHRoaXMuZm9udFN0eWxlID8gJ2ZvbnQtc3R5bGU9XCInICsgdGhpcy5mb250U3R5bGUgKyAnXCIgJyA6ICcnKSxcbiAgICAgICAgKHRoaXMuZm9udFdlaWdodCA/ICdmb250LXdlaWdodD1cIicgKyB0aGlzLmZvbnRXZWlnaHQgKyAnXCIgJyA6ICcnKSxcbiAgICAgICAgKHRleHREZWNvcmF0aW9uID8gJ3RleHQtZGVjb3JhdGlvbj1cIicgKyB0ZXh0RGVjb3JhdGlvbiArICdcIiAnIDogJycpLFxuICAgICAgICAnc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcyhub1NoYWRvdyksICdcIicsIHRoaXMuYWRkUGFpbnRPcmRlcigpLCAnID4nLFxuICAgICAgICB0ZXh0QW5kQmcudGV4dFNwYW5zLmpvaW4oJycpLFxuICAgICAgICAnPC90ZXh0PlxcbidcbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRleHRUb3BPZmZzZXQgVGV4dCB0b3Agb2Zmc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRleHRMZWZ0T2Zmc2V0IFRleHQgbGVmdCBvZmZzZXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgX2dldFNWR1RleHRBbmRCZzogZnVuY3Rpb24odGV4dFRvcE9mZnNldCwgdGV4dExlZnRPZmZzZXQpIHtcbiAgICAgIHZhciB0ZXh0U3BhbnMgPSBbXSxcbiAgICAgICAgICB0ZXh0QmdSZWN0cyA9IFtdLFxuICAgICAgICAgIGhlaWdodCA9IHRleHRUb3BPZmZzZXQsIGxpbmVPZmZzZXQ7XG4gICAgICAvLyBib3VuZGluZy1ib3ggYmFja2dyb3VuZFxuICAgICAgdGhpcy5fc2V0U1ZHQmcodGV4dEJnUmVjdHMpO1xuXG4gICAgICAvLyB0ZXh0IGFuZCB0ZXh0LWJhY2tncm91bmRcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGluZU9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpO1xuICAgICAgICBpZiAodGhpcy50ZXh0QmFja2dyb3VuZENvbG9yIHx8IHRoaXMuc3R5bGVIYXMoJ3RleHRCYWNrZ3JvdW5kQ29sb3InLCBpKSkge1xuICAgICAgICAgIHRoaXMuX3NldFNWR1RleHRMaW5lQmcodGV4dEJnUmVjdHMsIGksIHRleHRMZWZ0T2Zmc2V0ICsgbGluZU9mZnNldCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRTVkdUZXh0TGluZVRleHQodGV4dFNwYW5zLCBpLCB0ZXh0TGVmdE9mZnNldCArIGxpbmVPZmZzZXQsIGhlaWdodCk7XG4gICAgICAgIGhlaWdodCArPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dFNwYW5zOiB0ZXh0U3BhbnMsXG4gICAgICAgIHRleHRCZ1JlY3RzOiB0ZXh0QmdSZWN0c1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlVGV4dENoYXJTcGFuOiBmdW5jdGlvbihfY2hhciwgc3R5bGVEZWNsLCBsZWZ0LCB0b3ApIHtcbiAgICAgIHZhciBzaG91bGRVc2VXaGl0ZXNwYWNlID0gX2NoYXIgIT09IF9jaGFyLnRyaW0oKSB8fCBfY2hhci5tYXRjaChtdWx0aXBsZVNwYWNlc1JlZ2V4KSxcbiAgICAgICAgICBzdHlsZVByb3BzID0gdGhpcy5nZXRTdmdTcGFuU3R5bGVzKHN0eWxlRGVjbCwgc2hvdWxkVXNlV2hpdGVzcGFjZSksXG4gICAgICAgICAgZmlsbFN0eWxlcyA9IHN0eWxlUHJvcHMgPyAnc3R5bGU9XCInICsgc3R5bGVQcm9wcyArICdcIicgOiAnJyxcbiAgICAgICAgICBkeSA9IHN0eWxlRGVjbC5kZWx0YVksIGR5U3BhbiA9ICcnLFxuICAgICAgICAgIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG4gICAgICBpZiAoZHkpIHtcbiAgICAgICAgZHlTcGFuID0gJyBkeT1cIicgKyB0b0ZpeGVkKGR5LCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICdcIiAnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzx0c3BhbiB4PVwiJywgdG9GaXhlZChsZWZ0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSwgJ1wiIHk9XCInLFxuICAgICAgICB0b0ZpeGVkKHRvcCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksICdcIiAnLCBkeVNwYW4sXG4gICAgICAgIGZpbGxTdHlsZXMsICc+JyxcbiAgICAgICAgZmFicmljLnV0aWwuc3RyaW5nLmVzY2FwZVhtbChfY2hhciksXG4gICAgICAgICc8L3RzcGFuPidcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIF9zZXRTVkdUZXh0TGluZVRleHQ6IGZ1bmN0aW9uKHRleHRTcGFucywgbGluZUluZGV4LCB0ZXh0TGVmdE9mZnNldCwgdGV4dFRvcE9mZnNldCkge1xuICAgICAgLy8gc2V0IHByb3BlciBsaW5lIG9mZnNldFxuICAgICAgdmFyIGxpbmVIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShsaW5lSW5kZXgpLFxuICAgICAgICAgIGlzSnVzdGlmeSA9IHRoaXMudGV4dEFsaWduLmluZGV4T2YoJ2p1c3RpZnknKSAhPT0gLTEsXG4gICAgICAgICAgYWN0dWFsU3R5bGUsXG4gICAgICAgICAgbmV4dFN0eWxlLFxuICAgICAgICAgIGNoYXJzVG9SZW5kZXIgPSAnJyxcbiAgICAgICAgICBjaGFyQm94LCBzdHlsZSxcbiAgICAgICAgICBib3hXaWR0aCA9IDAsXG4gICAgICAgICAgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLFxuICAgICAgICAgIHRpbWVUb1JlbmRlcjtcblxuICAgICAgdGV4dFRvcE9mZnNldCArPSBsaW5lSGVpZ2h0ICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKSAvIHRoaXMubGluZUhlaWdodDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lLmxlbmd0aCAtIDE7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgdGltZVRvUmVuZGVyID0gaSA9PT0gbGVuIHx8IHRoaXMuY2hhclNwYWNpbmc7XG4gICAgICAgIGNoYXJzVG9SZW5kZXIgKz0gbGluZVtpXTtcbiAgICAgICAgY2hhckJveCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1baV07XG4gICAgICAgIGlmIChib3hXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIHRleHRMZWZ0T2Zmc2V0ICs9IGNoYXJCb3gua2VybmVkV2lkdGggLSBjaGFyQm94LndpZHRoO1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNKdXN0aWZ5ICYmICF0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcmVTcGFjZUFuZFRhYi50ZXN0KGxpbmVbaV0pKSB7XG4gICAgICAgICAgICB0aW1lVG9SZW5kZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIC8vIGlmIHdlIGhhdmUgY2hhclNwYWNpbmcsIHdlIHJlbmRlciBjaGFyIGJ5IGNoYXJcbiAgICAgICAgICBhY3R1YWxTdHlsZSA9IGFjdHVhbFN0eWxlIHx8IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSk7XG4gICAgICAgICAgbmV4dFN0eWxlID0gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBpICsgMSk7XG4gICAgICAgICAgdGltZVRvUmVuZGVyID0gZmFicmljLnV0aWwuaGFzU3R5bGVDaGFuZ2VkKGFjdHVhbFN0eWxlLCBuZXh0U3R5bGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICBzdHlsZSA9IHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBpKSB8fCB7IH07XG4gICAgICAgICAgdGV4dFNwYW5zLnB1c2godGhpcy5fY3JlYXRlVGV4dENoYXJTcGFuKGNoYXJzVG9SZW5kZXIsIHN0eWxlLCB0ZXh0TGVmdE9mZnNldCwgdGV4dFRvcE9mZnNldCkpO1xuICAgICAgICAgIGNoYXJzVG9SZW5kZXIgPSAnJztcbiAgICAgICAgICBhY3R1YWxTdHlsZSA9IG5leHRTdHlsZTtcbiAgICAgICAgICB0ZXh0TGVmdE9mZnNldCArPSBib3hXaWR0aDtcbiAgICAgICAgICBib3hXaWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3B1c2hUZXh0QmdSZWN0OiBmdW5jdGlvbih0ZXh0QmdSZWN0cywgY29sb3IsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG4gICAgICB0ZXh0QmdSZWN0cy5wdXNoKFxuICAgICAgICAnXFx0XFx0PHJlY3QgJyxcbiAgICAgICAgdGhpcy5fZ2V0RmlsbEF0dHJpYnV0ZXMoY29sb3IpLFxuICAgICAgICAnIHg9XCInLFxuICAgICAgICB0b0ZpeGVkKGxlZnQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCIgeT1cIicsXG4gICAgICAgIHRvRml4ZWQodG9wLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiIHdpZHRoPVwiJyxcbiAgICAgICAgdG9GaXhlZCh3aWR0aCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIiBoZWlnaHQ9XCInLFxuICAgICAgICB0b0ZpeGVkKGhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIj48L3JlY3Q+XFxuJyk7XG4gICAgfSxcblxuICAgIF9zZXRTVkdUZXh0TGluZUJnOiBmdW5jdGlvbih0ZXh0QmdSZWN0cywgaSwgbGVmdE9mZnNldCwgdGV4dFRvcE9mZnNldCkge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbaV0sXG4gICAgICAgICAgaGVpZ2h0T2ZMaW5lID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSkgLyB0aGlzLmxpbmVIZWlnaHQsXG4gICAgICAgICAgYm94V2lkdGggPSAwLFxuICAgICAgICAgIGJveFN0YXJ0ID0gMCxcbiAgICAgICAgICBjaGFyQm94LCBjdXJyZW50Q29sb3IsXG4gICAgICAgICAgbGFzdENvbG9yID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCAwLCAndGV4dEJhY2tncm91bmRDb2xvcicpO1xuICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbaV1bal07XG4gICAgICAgIGN1cnJlbnRDb2xvciA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgaiwgJ3RleHRCYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgaWYgKGN1cnJlbnRDb2xvciAhPT0gbGFzdENvbG9yKSB7XG4gICAgICAgICAgbGFzdENvbG9yICYmIHRoaXMuX3B1c2hUZXh0QmdSZWN0KHRleHRCZ1JlY3RzLCBsYXN0Q29sb3IsIGxlZnRPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgICAgIHRleHRUb3BPZmZzZXQsIGJveFdpZHRoLCBoZWlnaHRPZkxpbmUpO1xuICAgICAgICAgIGJveFN0YXJ0ID0gY2hhckJveC5sZWZ0O1xuICAgICAgICAgIGJveFdpZHRoID0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICBsYXN0Q29sb3IgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VycmVudENvbG9yICYmIHRoaXMuX3B1c2hUZXh0QmdSZWN0KHRleHRCZ1JlY3RzLCBjdXJyZW50Q29sb3IsIGxlZnRPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgdGV4dFRvcE9mZnNldCwgYm94V2lkdGgsIGhlaWdodE9mTGluZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkb2JlIElsbHVzdHJhdG9yIChhdCBsZWFzdCBDUzUpIGlzIHVuYWJsZSB0byByZW5kZXIgcmdiYSgpLWJhc2VkIGZpbGwgdmFsdWVzXG4gICAgICogd2Ugd29yayBhcm91bmQgaXQgYnkgXCJtb3ZpbmdcIiBhbHBoYSBjaGFubmVsIGludG8gb3BhY2l0eSBhdHRyaWJ1dGUgYW5kIHNldHRpbmcgZmlsbCdzIGFscGhhIHRvIDFcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBfZ2V0RmlsbEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZmlsbENvbG9yID0gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpID8gbmV3IGZhYnJpYy5Db2xvcih2YWx1ZSkgOiAnJztcbiAgICAgIGlmICghZmlsbENvbG9yIHx8ICFmaWxsQ29sb3IuZ2V0U291cmNlKCkgfHwgZmlsbENvbG9yLmdldEFscGhhKCkgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdmaWxsPVwiJyArIHZhbHVlICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnb3BhY2l0eT1cIicgKyBmaWxsQ29sb3IuZ2V0QWxwaGEoKSArICdcIiBmaWxsPVwiJyArIGZpbGxDb2xvci5zZXRBbHBoYSgxKS50b1JnYigpICsgJ1wiJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U1ZHTGluZVRvcE9mZnNldDogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbGluZVRvcE9mZnNldCA9IDAsIGxhc3RIZWlnaHQgPSAwO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lSW5kZXg7IGorKykge1xuICAgICAgICBsaW5lVG9wT2Zmc2V0ICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGopO1xuICAgICAgfVxuICAgICAgbGFzdEhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGopO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZVRvcDogbGluZVRvcE9mZnNldCxcbiAgICAgICAgb2Zmc2V0OiAodGhpcy5fZm9udFNpemVNdWx0IC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgKiBsYXN0SGVpZ2h0IC8gKHRoaXMubGluZUhlaWdodCAqIHRoaXMuX2ZvbnRTaXplTXVsdClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3R5bGVzLXN0cmluZyBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcFNoYWRvdyBhIGJvb2xlYW4gdG8gc2tpcCBzaGFkb3cgZmlsdGVyIG91dHB1dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdTdHlsZXM6IGZ1bmN0aW9uKHNraXBTaGFkb3cpIHtcbiAgICAgIHZhciBzdmdTdHlsZSA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmdldFN2Z1N0eWxlcy5jYWxsKHRoaXMsIHNraXBTaGFkb3cpO1xuICAgICAgcmV0dXJuIHN2Z1N0eWxlICsgJyB3aGl0ZS1zcGFjZTogcHJlOyc7XG4gICAgfSxcbiAgfSk7XG59KSgpO1xuLyogX1RPX1NWR19FTkRfICovXG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHt9KTtcblxuICAvKipcbiAgICogVGV4dGJveCBjbGFzcywgYmFzZWQgb24gSVRleHQsIGFsbG93cyB0aGUgdXNlciB0byByZXNpemUgdGhlIHRleHQgcmVjdGFuZ2xlXG4gICAqIGFuZCB3cmFwcyBsaW5lcyBhdXRvbWF0aWNhbGx5LiBUZXh0Ym94ZXMgaGF2ZSB0aGVpciBZIHNjYWxpbmcgbG9ja2VkLCB0aGVcbiAgICogdXNlciBjYW4gb25seSBjaGFuZ2Ugd2lkdGguIEhlaWdodCBpcyBhZGp1c3RlZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoZVxuICAgKiB3cmFwcGluZyBvZiBsaW5lcy5cbiAgICogQGNsYXNzIGZhYnJpYy5UZXh0Ym94XG4gICAqIEBleHRlbmRzIGZhYnJpYy5JVGV4dFxuICAgKiBAbWl4ZXMgZmFicmljLk9ic2VydmFibGVcbiAgICogQHJldHVybiB7ZmFicmljLlRleHRib3h9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlRleHRib3gjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5UZXh0Ym94ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLklUZXh0LCBmYWJyaWMuT2JzZXJ2YWJsZSwge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICd0ZXh0Ym94JyxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gd2lkdGggb2YgdGV4dGJveCwgaW4gcGl4ZWxzLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWluV2lkdGg6IDIwLFxuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBjYWxjdWxhdGVkIHdpZHRoIG9mIGEgdGV4dGJveCwgaW4gcGl4ZWxzLlxuICAgICAqIGZpeGVkIHRvIDIgc28gdGhhdCBhbiBlbXB0eSB0ZXh0Ym94IGNhbm5vdCBnbyB0byAwXG4gICAgICogYW5kIGlzIHN0aWxsIHNlbGVjdGFibGUgd2l0aG91dCB0ZXh0LlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZHluYW1pY01pbldpZHRoOiAyLFxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIGFycmF5IG9mIHRleHQgd3JhcHBpbmcuXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBfX2NhY2hlZExpbmVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgc3RhbmRhcmQgT2JqZWN0IGNsYXNzIHZhbHVlc1xuICAgICAqL1xuICAgIGxvY2tTY2FsaW5nRmxpcDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHN0YW5kYXJkIE9iamVjdCBjbGFzcyB2YWx1ZXNcbiAgICAgKiBUZXh0Ym94IG5lZWRzIHRoaXMgb24gZmFsc2VcbiAgICAgKi9cbiAgICBub1NjYWxlQ2FjaGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyB3aGljaCB3aGVuIHNldCBjYXVzZSBvYmplY3QgdG8gY2hhbmdlIGRpbWVuc2lvbnNcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaW1lbnNpb25BZmZlY3RpbmdQcm9wczogZmFicmljLlRleHQucHJvdG90eXBlLl9kaW1lbnNpb25BZmZlY3RpbmdQcm9wcy5jb25jYXQoJ3dpZHRoJyksXG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyByZWd1bGFyIGV4cHJlc3Npb24gdG8gc3BsaXQgc3RyaW5ncyBpbiBicmVha2FibGUgbGluZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF93b3JkSm9pbmVyczogL1sgXFx0XFxyXS8sXG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBib29sZWFuIHByb3BlcnR5IGluIG9yZGVyIHRvIHNwbGl0IHN0cmluZ3MgdGhhdCBoYXZlIG5vIHdoaXRlIHNwYWNlIGNvbmNlcHQuXG4gICAgICogdGhpcyBpcyBhIGNoZWFwIHdheSB0byBoZWxwIHdpdGggY2hpbmVzZS9qYXBhbmVzZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMi42LjBcbiAgICAgKi9cbiAgICBzcGxpdEJ5R3JhcGhlbWU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVW5saWtlIHN1cGVyY2xhc3MncyB2ZXJzaW9uIG9mIHRoaXMgZnVuY3Rpb24sIFRleHRib3ggZG9lcyBub3QgdXBkYXRlXG4gICAgICogaXRzIHdpZHRoLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgaW5pdERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX19za2lwRGltZW5zaW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNFZGl0aW5nICYmIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKCk7XG4gICAgICAvLyBjbGVhciBkeW5hbWljTWluV2lkdGggYXMgaXQgd2lsbCBiZSBkaWZmZXJlbnQgYWZ0ZXIgd2UgcmUtd3JhcCBsaW5lXG4gICAgICB0aGlzLmR5bmFtaWNNaW5XaWR0aCA9IDA7XG4gICAgICAvLyB3cmFwIGxpbmVzXG4gICAgICB0aGlzLl9zdHlsZU1hcCA9IHRoaXMuX2dlbmVyYXRlU3R5bGVNYXAodGhpcy5fc3BsaXRUZXh0KCkpO1xuICAgICAgLy8gaWYgYWZ0ZXIgd3JhcHBpbmcsIHRoZSB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gZHluYW1pY01pbldpZHRoLCBjaGFuZ2UgdGhlIHdpZHRoIGFuZCByZS13cmFwXG4gICAgICBpZiAodGhpcy5keW5hbWljTWluV2lkdGggPiB0aGlzLndpZHRoKSB7XG4gICAgICAgIHRoaXMuX3NldCgnd2lkdGgnLCB0aGlzLmR5bmFtaWNNaW5XaWR0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSkge1xuICAgICAgICAvLyBvbmNlIHRleHQgaXMgbWVhc3VyZWQgd2UgbmVlZCB0byBtYWtlIHNwYWNlIGZhdHRlciB0byBtYWtlIGp1c3RpZmllZCB0ZXh0LlxuICAgICAgICB0aGlzLmVubGFyZ2VTcGFjZXMoKTtcbiAgICAgIH1cbiAgICAgIC8vIGNsZWFyIGNhY2hlIGFuZCByZS1jYWxjdWxhdGUgaGVpZ2h0XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FsY1RleHRIZWlnaHQoKTtcbiAgICAgIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMnIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBvYmplY3QgdGhhdCB0cmFuc2xhdGVzIHRoZSBzdHlsZSBvYmplY3Qgc28gdGhhdCBpdCBpc1xuICAgICAqIGJyb2tlbiB1cCBieSB2aXN1YWwgbGluZXMgKG5ldyBsaW5lcyBhbmQgYXV0b21hdGljIHdyYXBwaW5nKS5cbiAgICAgKiBUaGUgb3JpZ2luYWwgdGV4dCBzdHlsZXMgb2JqZWN0IGlzIGJyb2tlbiB1cCBieSBhY3R1YWwgbGluZXMgKG5ldyBsaW5lcyBvbmx5KSxcbiAgICAgKiB3aGljaCBpcyBvbmx5IHN1ZmZpY2llbnQgZm9yIFRleHQgLyBJVGV4dFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dlbmVyYXRlU3R5bGVNYXA6IGZ1bmN0aW9uKHRleHRJbmZvKSB7XG4gICAgICB2YXIgcmVhbExpbmVDb3VudCAgICAgPSAwLFxuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ID0gMCxcbiAgICAgICAgICBjaGFyQ291bnQgICAgICAgICA9IDAsXG4gICAgICAgICAgbWFwICAgICAgICAgICAgICAgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0SW5mby5ncmFwaGVtZUxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZXh0SW5mby5ncmFwaGVtZVRleHRbY2hhckNvdW50XSA9PT0gJ1xcbicgJiYgaSA+IDApIHtcbiAgICAgICAgICByZWFsTGluZUNoYXJDb3VudCA9IDA7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgICAgcmVhbExpbmVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLnNwbGl0QnlHcmFwaGVtZSAmJiB0aGlzLl9yZVNwYWNlQW5kVGFiLnRlc3QodGV4dEluZm8uZ3JhcGhlbWVUZXh0W2NoYXJDb3VudF0pICYmIGkgPiAwKSB7XG4gICAgICAgICAgLy8gdGhpcyBjYXNlIGRlYWxzIHdpdGggc3BhY2UncyB0aGF0IGFyZSByZW1vdmVkIGZyb20gZW5kIG9mIGxpbmVzIHdoZW4gd3JhcHBpbmdcbiAgICAgICAgICByZWFsTGluZUNoYXJDb3VudCsrO1xuICAgICAgICAgIGNoYXJDb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFwW2ldID0geyBsaW5lOiByZWFsTGluZUNvdW50LCBvZmZzZXQ6IHJlYWxMaW5lQ2hhckNvdW50IH07XG5cbiAgICAgICAgY2hhckNvdW50ICs9IHRleHRJbmZvLmdyYXBoZW1lTGluZXNbaV0ubGVuZ3RoO1xuICAgICAgICByZWFsTGluZUNoYXJDb3VudCArPSB0ZXh0SW5mby5ncmFwaGVtZUxpbmVzW2ldLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBoYXMgYSBzdHlsZSBwcm9wZXJ0eSBvciBoYXMgaXQgb24gYSBzcGVjaWZpZWQgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0eWxlSGFzOiBmdW5jdGlvbihwcm9wZXJ0eSwgbGluZUluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fc3R5bGVNYXAgJiYgIXRoaXMuaXNXcmFwcGluZykge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFicmljLlRleHQucHJvdG90eXBlLnN0eWxlSGFzLmNhbGwodGhpcywgcHJvcGVydHksIGxpbmVJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaGFzIG5vIHN0eWxpbmcgb3Igbm8gc3R5bGluZyBpbiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4ICwgbGluZUluZGV4IGlzIG9uIHdyYXBwZWQgbGluZXMuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5U3R5bGVzOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgbmV4dExpbmVJbmRleCA9IGxpbmVJbmRleCArIDEsIG5leHRPZmZzZXQsIG9iaiwgc2hvdWxkTGltaXQgPSBmYWxzZSxcbiAgICAgICAgICBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdLCBtYXBOZXh0TGluZSA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdO1xuICAgICAgaWYgKG1hcCkge1xuICAgICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgICAgb2Zmc2V0ID0gbWFwLm9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChtYXBOZXh0TGluZSkge1xuICAgICAgICBuZXh0TGluZUluZGV4ID0gbWFwTmV4dExpbmUubGluZTtcbiAgICAgICAgc2hvdWxkTGltaXQgPSBuZXh0TGluZUluZGV4ID09PSBsaW5lSW5kZXg7XG4gICAgICAgIG5leHRPZmZzZXQgPSBtYXBOZXh0TGluZS5vZmZzZXQ7XG4gICAgICB9XG4gICAgICBvYmogPSB0eXBlb2YgbGluZUluZGV4ID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc3R5bGVzIDogeyBsaW5lOiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdIH07XG4gICAgICBmb3IgKHZhciBwMSBpbiBvYmopIHtcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gb2JqW3AxXSkge1xuICAgICAgICAgIGlmIChwMiA+PSBvZmZzZXQgJiYgKCFzaG91bGRMaW1pdCB8fCBwMiA8IG5leHRPZmZzZXQpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgIGZvciAodmFyIHAzIGluIG9ialtwMV1bcDJdKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fc3R5bGVNYXAgJiYgIXRoaXMuaXNXcmFwcGluZykge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgICAgY2hhckluZGV4ID0gbWFwLm9mZnNldCArIGNoYXJJbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcignX2dldFN0eWxlRGVjbGFyYXRpb24nLCBsaW5lSW5kZXgsIGNoYXJJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHN0eWxlKSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgY2hhckluZGV4ID0gbWFwLm9mZnNldCArIGNoYXJJbmRleDtcblxuICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdID0gc3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGVsZXRlU3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcHJvYmFibHkgYnJva2VuIG5lZWQgYSBmaXhcbiAgICAgKiBSZXR1cm5zIHRoZSByZWFsIHN0eWxlIGxpbmUgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSB3cmFwcGVkIGxpbmVJbmRleCBsaW5lXG4gICAgICogVXNlZCBqdXN0IHRvIHZlcmlmeSBpZiB0aGUgbGluZSBkb2VzIGV4aXN0IG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IGlmIHRoZSBsaW5lIGV4aXN0cyBvciBub3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICByZXR1cm4gISF0aGlzLnN0eWxlc1ttYXAubGluZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbGluZSBzdHlsZSB0byBhbiBlbXB0eSBvYmplY3Qgc28gdGhhdCBpcyBpbml0aWFsaXplZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICB0aGlzLnN0eWxlc1ttYXAubGluZV0gPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgdGV4dCB1c2luZyB0aGUgJ3dpZHRoJyBwcm9wZXJ0eSBvZiBUZXh0Ym94LiBGaXJzdCB0aGlzIGZ1bmN0aW9uXG4gICAgICogc3BsaXRzIHRleHQgb24gbmV3bGluZXMsIHNvIHdlIHByZXNlcnZlIG5ld2xpbmVzIGVudGVyZWQgYnkgdGhlIHVzZXIuXG4gICAgICogVGhlbiBpdCB3cmFwcyBlYWNoIGxpbmUgdXNpbmcgdGhlIHdpZHRoIG9mIHRoZSBUZXh0Ym94IGJ5IGNhbGxpbmdcbiAgICAgKiBfd3JhcExpbmUoKS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lcyBUaGUgc3RyaW5nIGFycmF5IG9mIHRleHQgdGhhdCBpcyBzcGxpdCBpbnRvIGxpbmVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc2lyZWRXaWR0aCB3aWR0aCB5b3Ugd2FudCB0byB3cmFwIHRvXG4gICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBsaW5lc1xuICAgICAqL1xuICAgIF93cmFwVGV4dDogZnVuY3Rpb24obGluZXMsIGRlc2lyZWRXaWR0aCkge1xuICAgICAgdmFyIHdyYXBwZWQgPSBbXSwgaTtcbiAgICAgIHRoaXMuaXNXcmFwcGluZyA9IHRydWU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQuY29uY2F0KHRoaXMuX3dyYXBMaW5lKGxpbmVzW2ldLCBpLCBkZXNpcmVkV2lkdGgpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNXcmFwcGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHdyYXBwZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBtZWFzdXJlIGEgc3RyaW5nIG9mIHRleHQsIGdpdmVuIGl0cyBsaW5lSW5kZXggYW5kIGNoYXJJbmRleCBvZmZzZXRcbiAgICAgKiBpdCBnZXRzIGNhbGxlZCB3aGVuIGNoYXJCb3VuZHMgYXJlIG5vdCBhdmFpbGFibGUgeWV0LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhck9mZnNldFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWVhc3VyZVdvcmQ6IGZ1bmN0aW9uKHdvcmQsIGxpbmVJbmRleCwgY2hhck9mZnNldCkge1xuICAgICAgdmFyIHdpZHRoID0gMCwgcHJldkdyYXBoZW1lLCBza2lwTGVmdCA9IHRydWU7XG4gICAgICBjaGFyT2Zmc2V0ID0gY2hhck9mZnNldCB8fCAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHdvcmQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGJveCA9IHRoaXMuX2dldEdyYXBoZW1lQm94KHdvcmRbaV0sIGxpbmVJbmRleCwgaSArIGNoYXJPZmZzZXQsIHByZXZHcmFwaGVtZSwgc2tpcExlZnQpO1xuICAgICAgICB3aWR0aCArPSBib3gua2VybmVkV2lkdGg7XG4gICAgICAgIHByZXZHcmFwaGVtZSA9IHdvcmRbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIGEgbGluZSBvZiB0ZXh0IHVzaW5nIHRoZSB3aWR0aCBvZiB0aGUgVGV4dGJveCBhbmQgYSBjb250ZXh0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmUgVGhlIGdyYXBoZW1lIGFycmF5IHRoYXQgcmVwcmVzZW50IHRoZSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXNpcmVkV2lkdGggd2lkdGggeW91IHdhbnQgdG8gd3JhcCB0aGUgbGluZSB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZXNlcnZlZFNwYWNlIHNwYWNlIHRvIHJlbW92ZSBmcm9tIHdyYXBwaW5nIGZvciBjdXN0b20gZnVuY3Rpb25hbGl0aWVzXG4gICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBsaW5lKHMpIGludG8gd2hpY2ggdGhlIGdpdmVuIHRleHQgaXMgd3JhcHBlZFxuICAgICAqIHRvLlxuICAgICAqL1xuICAgIF93cmFwTGluZTogZnVuY3Rpb24oX2xpbmUsIGxpbmVJbmRleCwgZGVzaXJlZFdpZHRoLCByZXNlcnZlZFNwYWNlKSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gMCxcbiAgICAgICAgICBzcGxpdEJ5R3JhcGhlbWUgPSB0aGlzLnNwbGl0QnlHcmFwaGVtZSxcbiAgICAgICAgICBncmFwaGVtZUxpbmVzID0gW10sXG4gICAgICAgICAgbGluZSA9IFtdLFxuICAgICAgICAgIC8vIHNwYWNlcyBpbiBkaWZmZXJlbnQgbGFuZ3VhZ2VzP1xuICAgICAgICAgIHdvcmRzID0gc3BsaXRCeUdyYXBoZW1lID8gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQoX2xpbmUpIDogX2xpbmUuc3BsaXQodGhpcy5fd29yZEpvaW5lcnMpLFxuICAgICAgICAgIHdvcmQgPSAnJyxcbiAgICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICAgIGluZml4ID0gc3BsaXRCeUdyYXBoZW1lID8gJycgOiAnICcsXG4gICAgICAgICAgd29yZFdpZHRoID0gMCxcbiAgICAgICAgICBpbmZpeFdpZHRoID0gMCxcbiAgICAgICAgICBsYXJnZXN0V29yZFdpZHRoID0gMCxcbiAgICAgICAgICBsaW5lSnVzdFN0YXJ0ZWQgPSB0cnVlLFxuICAgICAgICAgIGFkZGl0aW9uYWxTcGFjZSA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpLFxuICAgICAgICAgIHJlc2VydmVkU3BhY2UgPSByZXNlcnZlZFNwYWNlIHx8IDA7XG4gICAgICAvLyBmaXggYSBkaWZmZXJlbmNlIGJldHdlZW4gc3BsaXQgYW5kIGdyYXBoZW1lU3BsaXRcbiAgICAgIGlmICh3b3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgd29yZHMucHVzaChbXSk7XG4gICAgICB9XG4gICAgICBkZXNpcmVkV2lkdGggLT0gcmVzZXJ2ZWRTcGFjZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gaWYgdXNpbmcgc3BsaXRCeUdyYXBoZW1lIHdvcmRzIGFyZSBhbHJlYWR5IGluIGdyYXBoZW1lcy5cbiAgICAgICAgd29yZCA9IHNwbGl0QnlHcmFwaGVtZSA/IHdvcmRzW2ldIDogZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQod29yZHNbaV0pO1xuICAgICAgICB3b3JkV2lkdGggPSB0aGlzLl9tZWFzdXJlV29yZCh3b3JkLCBsaW5lSW5kZXgsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSB3b3JkLmxlbmd0aDtcblxuICAgICAgICBsaW5lV2lkdGggKz0gaW5maXhXaWR0aCArIHdvcmRXaWR0aCAtIGFkZGl0aW9uYWxTcGFjZTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCA+IGRlc2lyZWRXaWR0aCAmJiAhbGluZUp1c3RTdGFydGVkKSB7XG4gICAgICAgICAgZ3JhcGhlbWVMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgIGxpbmUgPSBbXTtcbiAgICAgICAgICBsaW5lV2lkdGggPSB3b3JkV2lkdGg7XG4gICAgICAgICAgbGluZUp1c3RTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsaW5lV2lkdGggKz0gYWRkaXRpb25hbFNwYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsaW5lSnVzdFN0YXJ0ZWQgJiYgIXNwbGl0QnlHcmFwaGVtZSkge1xuICAgICAgICAgIGxpbmUucHVzaChpbmZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSA9IGxpbmUuY29uY2F0KHdvcmQpO1xuXG4gICAgICAgIGluZml4V2lkdGggPSBzcGxpdEJ5R3JhcGhlbWUgPyAwIDogdGhpcy5fbWVhc3VyZVdvcmQoW2luZml4XSwgbGluZUluZGV4LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgbGluZUp1c3RTdGFydGVkID0gZmFsc2U7XG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgbGFyZ2VzdCB3b3JkXG4gICAgICAgIGlmICh3b3JkV2lkdGggPiBsYXJnZXN0V29yZFdpZHRoKSB7XG4gICAgICAgICAgbGFyZ2VzdFdvcmRXaWR0aCA9IHdvcmRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpICYmIGdyYXBoZW1lTGluZXMucHVzaChsaW5lKTtcblxuICAgICAgaWYgKGxhcmdlc3RXb3JkV2lkdGggKyByZXNlcnZlZFNwYWNlID4gdGhpcy5keW5hbWljTWluV2lkdGgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljTWluV2lkdGggPSBsYXJnZXN0V29yZFdpZHRoIC0gYWRkaXRpb25hbFNwYWNlICsgcmVzZXJ2ZWRTcGFjZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncmFwaGVtZUxpbmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgdGhlIHRleHQgbGluZSBpcyBlbmRlZCB3aXRoIGFuIGhhcmQgYnJlYWtcbiAgICAgKiB0ZXh0IGFuZCBpdGV4dCBkbyBub3QgaGF2ZSB3cmFwcGluZywgcmV0dXJuIGZhbHNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCB0ZXh0IHRvIHNwbGl0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VuZE9mV3JhcHBpbmc6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXggKyAxXSkge1xuICAgICAgICAvLyBpcyBsYXN0IGxpbmUsIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXggKyAxXS5saW5lICE9PSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdLmxpbmUpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBsYXN0IGxpbmUgYmVmb3JlIGEgbGluZSBicmVhaywgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgYSBsaW5lIGhhcyBhIGxpbmVicmVhayBhbmQgc28gd2UgbmVlZCB0byBhY2NvdW50IGZvciBpdCB3aGVuIG1vdmluZ1xuICAgICAqIGFuZCBjb3VudGluZyBzdHlsZS5cbiAgICAgKiBAcmV0dXJuIE51bWJlclxuICAgICAqL1xuICAgIG1pc3NpbmdOZXdsaW5lT2Zmc2V0OiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLnNwbGl0QnlHcmFwaGVtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0VuZE9mV3JhcHBpbmcobGluZUluZGV4KSA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogR2V0cyBsaW5lcyBvZiB0ZXh0IHRvIHJlbmRlciBpbiB0aGUgVGV4dGJveC4gVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzXG4gICAgKiB0ZXh0IHdyYXBwaW5nIG9uIHRoZSBmbHkgZXZlcnkgdGltZSBpdCBpcyBjYWxsZWQuXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0ZXh0IHRvIHNwbGl0XG4gICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzIGluIHRoZSBUZXh0Ym94LlxuICAgICogQG92ZXJyaWRlXG4gICAgKi9cbiAgICBfc3BsaXRUZXh0SW50b0xpbmVzOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB2YXIgbmV3VGV4dCA9IGZhYnJpYy5UZXh0LnByb3RvdHlwZS5fc3BsaXRUZXh0SW50b0xpbmVzLmNhbGwodGhpcywgdGV4dCksXG4gICAgICAgICAgZ3JhcGhlbWVMaW5lcyA9IHRoaXMuX3dyYXBUZXh0KG5ld1RleHQubGluZXMsIHRoaXMud2lkdGgpLFxuICAgICAgICAgIGxpbmVzID0gbmV3IEFycmF5KGdyYXBoZW1lTGluZXMubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGhlbWVMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaW5lc1tpXSA9IGdyYXBoZW1lTGluZXNbaV0uam9pbignJyk7XG4gICAgICB9XG4gICAgICBuZXdUZXh0LmxpbmVzID0gbGluZXM7XG4gICAgICBuZXdUZXh0LmdyYXBoZW1lTGluZXMgPSBncmFwaGVtZUxpbmVzO1xuICAgICAgcmV0dXJuIG5ld1RleHQ7XG4gICAgfSxcblxuICAgIGdldE1pbldpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLm1pbldpZHRoLCB0aGlzLmR5bmFtaWNNaW5XaWR0aCk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lc1RvS2VlcCA9IHt9O1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLl9zdHlsZU1hcCkge1xuICAgICAgICBpZiAodGhpcy5fdGV4dExpbmVzW3Byb3BdKSB7XG4gICAgICAgICAgbGluZXNUb0tlZXBbdGhpcy5fc3R5bGVNYXBbcHJvcF0ubGluZV0gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuc3R5bGVzKSB7XG4gICAgICAgIGlmICghbGluZXNUb0tlZXBbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIHRvT2JqZWN0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ21pbldpZHRoJywgJ3NwbGl0QnlHcmFwaGVtZSddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVGV4dGJveCBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dGJveFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5UZXh0Ym94IGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5UZXh0Ym94LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0eWxlcyA9IGZhYnJpYy51dGlsLnN0eWxlc0Zyb21BcnJheShvYmplY3Quc3R5bGVzLCBvYmplY3QudGV4dCk7XG4gICAgLy9jb3B5IG9iamVjdCB0byBwcmV2ZW50IG11dGF0aW9uXG4gICAgdmFyIG9iakNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBvYmplY3QsIHsgc3R5bGVzOiBzdHlsZXMgfSk7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1RleHRib3gnLCBvYmpDb3B5LCBjYWxsYmFjaywgJ3RleHQnKTtcbiAgfTtcbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGNvbnRyb2xzVXRpbHMgPSBmYWJyaWMuY29udHJvbHNVdGlscyxcbiAgICAgIHNjYWxlU2tld1N0eWxlSGFuZGxlciA9IGNvbnRyb2xzVXRpbHMuc2NhbGVTa2V3Q3Vyc29yU3R5bGVIYW5kbGVyLFxuICAgICAgc2NhbGVTdHlsZUhhbmRsZXIgPSBjb250cm9sc1V0aWxzLnNjYWxlQ3Vyc29yU3R5bGVIYW5kbGVyLFxuICAgICAgc2NhbGluZ0VxdWFsbHkgPSBjb250cm9sc1V0aWxzLnNjYWxpbmdFcXVhbGx5LFxuICAgICAgc2NhbGluZ1lPclNrZXdpbmdYID0gY29udHJvbHNVdGlscy5zY2FsaW5nWU9yU2tld2luZ1gsXG4gICAgICBzY2FsaW5nWE9yU2tld2luZ1kgPSBjb250cm9sc1V0aWxzLnNjYWxpbmdYT3JTa2V3aW5nWSxcbiAgICAgIHNjYWxlT3JTa2V3QWN0aW9uTmFtZSA9IGNvbnRyb2xzVXRpbHMuc2NhbGVPclNrZXdBY3Rpb25OYW1lLFxuICAgICAgb2JqZWN0Q29udHJvbHMgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jb250cm9scztcblxuICBvYmplY3RDb250cm9scy5tbCA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogLTAuNSxcbiAgICB5OiAwLFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTa2V3U3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdYT3JTa2V3aW5nWSxcbiAgICBnZXRBY3Rpb25OYW1lOiBzY2FsZU9yU2tld0FjdGlvbk5hbWUsXG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLm1yID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLjUsXG4gICAgeTogMCxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU2tld1N0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nWE9yU2tld2luZ1ksXG4gICAgZ2V0QWN0aW9uTmFtZTogc2NhbGVPclNrZXdBY3Rpb25OYW1lLFxuICB9KTtcblxuICBvYmplY3RDb250cm9scy5tYiA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMCxcbiAgICB5OiAwLjUsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVNrZXdTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ1lPclNrZXdpbmdYLFxuICAgIGdldEFjdGlvbk5hbWU6IHNjYWxlT3JTa2V3QWN0aW9uTmFtZSxcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMubXQgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IDAsXG4gICAgeTogLTAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU2tld1N0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nWU9yU2tld2luZ1gsXG4gICAgZ2V0QWN0aW9uTmFtZTogc2NhbGVPclNrZXdBY3Rpb25OYW1lLFxuICB9KTtcblxuICBvYmplY3RDb250cm9scy50bCA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogLTAuNSxcbiAgICB5OiAtMC41LFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ0VxdWFsbHlcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMudHIgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IDAuNSxcbiAgICB5OiAtMC41LFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ0VxdWFsbHlcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMuYmwgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IC0wLjUsXG4gICAgeTogMC41LFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ0VxdWFsbHlcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMuYnIgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IDAuNSxcbiAgICB5OiAwLjUsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVN0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nRXF1YWxseVxuICB9KTtcblxuICBvYmplY3RDb250cm9scy5tdHIgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IDAsXG4gICAgeTogLTAuNSxcbiAgICBhY3Rpb25IYW5kbGVyOiBjb250cm9sc1V0aWxzLnJvdGF0aW9uV2l0aFNuYXBwaW5nLFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogY29udHJvbHNVdGlscy5yb3RhdGlvblN0eWxlSGFuZGxlcixcbiAgICBvZmZzZXRZOiAtNDAsXG4gICAgd2l0aENvbm5lY3Rpb246IHRydWUsXG4gICAgYWN0aW9uTmFtZTogJ3JvdGF0ZScsXG4gIH0pO1xuXG4gIGlmIChmYWJyaWMuVGV4dGJveCkge1xuICAgIC8vIHRoaXMgaXMgYnJlYWtpbmcgdGhlIHByb3RvdHlwZSBpbmhlcml0YW5jZSwgbm8gdGltZSAvIGlkZWFzIHRvIGZpeCBpdC5cbiAgICAvLyBpcyBpbXBvcnRhbnQgdG8gZG9jdW1lbnQgdGhhdCBpZiB5b3Ugd2FudCB0byBoYXZlIGFsbCBvYmplY3RzIHRvIGhhdmUgYVxuICAgIC8vIHNwZWNpZmljIGN1c3RvbSBjb250cm9sLCB5b3UgaGF2ZSB0byBhZGQgaXQgdG8gT2JqZWN0IHByb3RvdHlwZSBhbmQgdG8gVGV4dGJveFxuICAgIC8vIHByb3RvdHlwZS4gVGhlIGNvbnRyb2xzIGFyZSBzaGFyZWQgYXMgcmVmZXJlbmNlcy4gU28gY2hhbmdlcyB0byBjb250cm9sIGB0cmBcbiAgICAvLyBjYW4gc3RpbGwgYXBwbHkgdG8gYWxsIG9iamVjdHMgaWYgbmVlZGVkLlxuICAgIHZhciB0ZXh0Qm94Q29udHJvbHMgPSBmYWJyaWMuVGV4dGJveC5wcm90b3R5cGUuY29udHJvbHMgPSB7IH07XG5cbiAgICB0ZXh0Qm94Q29udHJvbHMubXRyID0gb2JqZWN0Q29udHJvbHMubXRyO1xuICAgIHRleHRCb3hDb250cm9scy50ciA9IG9iamVjdENvbnRyb2xzLnRyO1xuICAgIHRleHRCb3hDb250cm9scy5iciA9IG9iamVjdENvbnRyb2xzLmJyO1xuICAgIHRleHRCb3hDb250cm9scy50bCA9IG9iamVjdENvbnRyb2xzLnRsO1xuICAgIHRleHRCb3hDb250cm9scy5ibCA9IG9iamVjdENvbnRyb2xzLmJsO1xuICAgIHRleHRCb3hDb250cm9scy5tdCA9IG9iamVjdENvbnRyb2xzLm10O1xuICAgIHRleHRCb3hDb250cm9scy5tYiA9IG9iamVjdENvbnRyb2xzLm1iO1xuXG4gICAgdGV4dEJveENvbnRyb2xzLm1yID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICAgIHg6IDAuNSxcbiAgICAgIHk6IDAsXG4gICAgICBhY3Rpb25IYW5kbGVyOiBjb250cm9sc1V0aWxzLmNoYW5nZVdpZHRoLFxuICAgICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVNrZXdTdHlsZUhhbmRsZXIsXG4gICAgICBhY3Rpb25OYW1lOiAncmVzaXppbmcnLFxuICAgIH0pO1xuXG4gICAgdGV4dEJveENvbnRyb2xzLm1sID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICAgIHg6IC0wLjUsXG4gICAgICB5OiAwLFxuICAgICAgYWN0aW9uSGFuZGxlcjogY29udHJvbHNVdGlscy5jaGFuZ2VXaWR0aCxcbiAgICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTa2V3U3R5bGVIYW5kbGVyLFxuICAgICAgYWN0aW9uTmFtZTogJ3Jlc2l6aW5nJyxcbiAgICB9KTtcbiAgfVxufSkoKTtcblxuIl0sIm5hbWVzIjpbImZhYnJpYyIsInZlcnNpb24iLCJleHBvcnRzIiwiZGVmaW5lIiwiYW1kIiwiZG9jdW1lbnQiLCJIVE1MRG9jdW1lbnQiLCJEb2N1bWVudCIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlSFRNTERvY3VtZW50Iiwid2luZG93IiwianNkb20iLCJyZXF1aXJlIiwidmlydHVhbFdpbmRvdyIsIkpTRE9NIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZmVhdHVyZXMiLCJGZXRjaEV4dGVybmFsUmVzb3VyY2VzIiwicmVzb3VyY2VzIiwianNkb21JbXBsRm9yV3JhcHBlciIsImltcGxGb3JXcmFwcGVyIiwibm9kZUNhbnZhcyIsIkNhbnZhcyIsIkRPTVBhcnNlciIsImlzVG91Y2hTdXBwb3J0ZWQiLCJuYXZpZ2F0b3IiLCJtYXhUb3VjaFBvaW50cyIsImlzTGlrZWx5Tm9kZSIsIkJ1ZmZlciIsIlNIQVJFRF9BVFRSSUJVVEVTIiwiRFBJIiwicmVOdW0iLCJjb21tYVdzcCIsInJlUGF0aENvbW1hbmQiLCJyZU5vbldvcmQiLCJmb250UGF0aHMiLCJpTWF0cml4Iiwic3ZnTlMiLCJwZXJmTGltaXRTaXplVG90YWwiLCJtYXhDYWNoZVNpZGVMaW1pdCIsIm1pbkNhY2hlU2lkZUxpbWl0IiwiY2hhcldpZHRoc0NhY2hlIiwidGV4dHVyZVNpemUiLCJkaXNhYmxlU3R5bGVDb3B5UGFzdGUiLCJlbmFibGVHTEZpbHRlcmluZyIsImRldmljZVBpeGVsUmF0aW8iLCJ3ZWJraXREZXZpY2VQaXhlbFJhdGlvIiwibW96RGV2aWNlUGl4ZWxSYXRpbyIsImJyb3dzZXJTaGFkb3dCbHVyQ29uc3RhbnQiLCJhcmNUb1NlZ21lbnRzQ2FjaGUiLCJib3VuZHNPZkN1cnZlQ2FjaGUiLCJjYWNoZXNCb3VuZHNPZkN1cnZlIiwiZm9yY2VHTFB1dEltYWdlRGF0YSIsImluaXRGaWx0ZXJCYWNrZW5kIiwiaXNXZWJnbFN1cHBvcnRlZCIsImNvbnNvbGUiLCJsb2ciLCJtYXhUZXh0dXJlU2l6ZSIsIldlYmdsRmlsdGVyQmFja2VuZCIsInRpbGVTaXplIiwiQ2FudmFzMmRGaWx0ZXJCYWNrZW5kIiwiX3JlbW92ZUV2ZW50TGlzdGVuZXIiLCJldmVudE5hbWUiLCJoYW5kbGVyIiwiX19ldmVudExpc3RlbmVycyIsImV2ZW50TGlzdGVuZXIiLCJpbmRleE9mIiwidXRpbCIsImFycmF5IiwiZmlsbCIsIm9uIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwicHJvcCIsInB1c2giLCJfb25jZSIsIl9oYW5kbGVyIiwiYXBwbHkiLCJvZmYiLCJiaW5kIiwib25jZSIsImNhbGwiLCJmaXJlIiwib3B0aW9ucyIsImxpc3RlbmVyc0ZvckV2ZW50IiwiaSIsImxlbiIsImZpbHRlciIsInZhbHVlIiwiT2JzZXJ2YWJsZSIsIkNvbGxlY3Rpb24iLCJfb2JqZWN0cyIsImFkZCIsIl9vbk9iamVjdEFkZGVkIiwicmVuZGVyT25BZGRSZW1vdmUiLCJyZXF1ZXN0UmVuZGVyQWxsIiwiaW5zZXJ0QXQiLCJvYmplY3QiLCJpbmRleCIsIm5vblNwbGljaW5nIiwib2JqZWN0cyIsInNwbGljZSIsInJlbW92ZSIsInNvbWV0aGluZ1JlbW92ZWQiLCJfb25PYmplY3RSZW1vdmVkIiwiZm9yRWFjaE9iamVjdCIsImNhbGxiYWNrIiwiY29udGV4dCIsImdldE9iamVjdHMiLCJ0eXBlIiwiY29uY2F0IiwibyIsIml0ZW0iLCJpc0VtcHR5Iiwic2l6ZSIsImNvbnRhaW5zIiwiZGVlcCIsInNvbWUiLCJvYmoiLCJjb21wbGV4aXR5IiwicmVkdWNlIiwibWVtbyIsImN1cnJlbnQiLCJDb21tb25NZXRob2RzIiwiX3NldE9wdGlvbnMiLCJzZXQiLCJfaW5pdEdyYWRpZW50IiwiZmlsbGVyIiwicHJvcGVydHkiLCJjb2xvclN0b3BzIiwiR3JhZGllbnQiLCJfaW5pdFBhdHRlcm4iLCJzb3VyY2UiLCJQYXR0ZXJuIiwiX3NldE9iamVjdCIsIl9zZXQiLCJrZXkiLCJ0b2dnbGUiLCJnZXQiLCJnbG9iYWwiLCJzcXJ0IiwiTWF0aCIsImF0YW4yIiwicG93IiwiUGlCeTE4MCIsIlBJIiwiUGlCeTIiLCJjb3MiLCJhbmdsZSIsImFuZ2xlU2xpY2UiLCJzaW4iLCJzaWduIiwicmVtb3ZlRnJvbUFycmF5IiwiaWR4IiwiZ2V0UmFuZG9tSW50IiwibWluIiwibWF4IiwiZmxvb3IiLCJyYW5kb20iLCJkZWdyZWVzVG9SYWRpYW5zIiwiZGVncmVlcyIsInJhZGlhbnNUb0RlZ3JlZXMiLCJyYWRpYW5zIiwicm90YXRlUG9pbnQiLCJwb2ludCIsIm9yaWdpbiIsIm5ld1BvaW50IiwiUG9pbnQiLCJ4IiwieSIsInYiLCJyb3RhdGVWZWN0b3IiLCJhZGRFcXVhbHMiLCJ2ZWN0b3IiLCJyeCIsInJ5IiwiY3JlYXRlVmVjdG9yIiwiZnJvbSIsInRvIiwiY2FsY0FuZ2xlQmV0d2VlblZlY3RvcnMiLCJhIiwiYiIsImFjb3MiLCJoeXBvdCIsImdldEhhdFZlY3RvciIsIm11bHRpcGx5IiwiZ2V0QmlzZWN0b3IiLCJBIiwiQiIsIkMiLCJBQiIsIkFDIiwiYWxwaGEiLCJybyIsInBoaSIsInByb2plY3RTdHJva2VPblBvaW50cyIsInBvaW50cyIsIm9wZW5QYXRoIiwiY29vcmRzIiwicyIsInN0cm9rZVdpZHRoIiwic3Ryb2tlVW5pZm9ybVNjYWxhciIsInN0cm9rZVVuaWZvcm0iLCJzY2FsZVgiLCJzY2FsZVkiLCJnZXRTdHJva2VIYXRWZWN0b3IiLCJzY2FsYXIiLCJmb3JFYWNoIiwicCIsImJpc2VjdG9yIiwiYmlzZWN0b3JWZWN0b3IiLCJtaXRlclZlY3RvciIsInN0cm9rZUxpbmVKb2luIiwic3Ryb2tlTWl0ZXJMaW1pdCIsInN1YnRyYWN0IiwiU1FSVDIiLCJ0cmFuc2Zvcm1Qb2ludCIsInQiLCJpZ25vcmVPZmZzZXQiLCJtYWtlQm91bmRpbmdCb3hGcm9tUG9pbnRzIiwidHJhbnNmb3JtIiwieFBvaW50cyIsIm1pblgiLCJtYXhYIiwid2lkdGgiLCJ5UG9pbnRzIiwibWluWSIsIm1heFkiLCJoZWlnaHQiLCJsZWZ0IiwidG9wIiwiaW52ZXJ0VHJhbnNmb3JtIiwiciIsInRvRml4ZWQiLCJudW1iZXIiLCJmcmFjdGlvbkRpZ2l0cyIsInBhcnNlRmxvYXQiLCJOdW1iZXIiLCJwYXJzZVVuaXQiLCJmb250U2l6ZSIsInVuaXQiLCJleGVjIiwiVGV4dCIsIkRFRkFVTFRfU1ZHX0ZPTlRfU0laRSIsImZhbHNlRnVuY3Rpb24iLCJnZXRLbGFzcyIsIm5hbWVzcGFjZSIsInN0cmluZyIsImNhbWVsaXplIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsInJlc29sdmVOYW1lc3BhY2UiLCJnZXRTdmdBdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsInBhcnRzIiwic3BsaXQiLCJsb2FkSW1hZ2UiLCJ1cmwiLCJjcm9zc09yaWdpbiIsImltZyIsImNyZWF0ZUltYWdlIiwib25Mb2FkQ2FsbGJhY2siLCJvbmxvYWQiLCJvbmVycm9yIiwic3JjIiwidW5kZWZpbmVkIiwic3Vic3RyaW5nIiwibG9hZEltYWdlSW5Eb20iLCJkaXYiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJwb3NpdGlvbiIsImFwcGVuZENoaWxkIiwicXVlcnlTZWxlY3RvciIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImVubGl2ZW5PYmplY3RzIiwicmV2aXZlciIsImVubGl2ZW5lZE9iamVjdHMiLCJudW1Mb2FkZWRPYmplY3RzIiwibnVtVG90YWxPYmplY3RzIiwib25Mb2FkZWQiLCJrbGFzcyIsImZyb21PYmplY3QiLCJlcnJvciIsImVubGl2ZW5PYmplY3RFbmxpdmFibGVzIiwiZW5saXZlblByb3BzIiwiT2JqZWN0IiwiRU5MSVZFTl9QUk9QUyIsIm1hcCIsImVubGl2ZWRQcm9wcyIsImVubGl2ZW5QYXR0ZXJucyIsInBhdHRlcm5zIiwibnVtTG9hZGVkUGF0dGVybnMiLCJudW1QYXR0ZXJucyIsImVubGl2ZW5lZFBhdHRlcm5zIiwicGF0dGVybiIsImdyb3VwU1ZHRWxlbWVudHMiLCJlbGVtZW50cyIsInBhdGgiLCJzb3VyY2VQYXRoIiwiY2VudGVyUG9pbnQiLCJHcm91cCIsInBvcHVsYXRlV2l0aFByb3BlcnRpZXMiLCJkZXN0aW5hdGlvbiIsInByb3BlcnRpZXMiLCJBcnJheSIsImlzQXJyYXkiLCJjcmVhdGVDYW52YXNFbGVtZW50IiwiY29weUNhbnZhc0VsZW1lbnQiLCJjYW52YXMiLCJuZXdDYW52YXMiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwidG9EYXRhVVJMIiwiY2FudmFzRWwiLCJmb3JtYXQiLCJxdWFsaXR5IiwibXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyIsImlzMngyIiwicXJEZWNvbXBvc2UiLCJkZW5vbSIsInNrZXdYIiwic2tld1kiLCJ0cmFuc2xhdGVYIiwidHJhbnNsYXRlWSIsImNhbGNSb3RhdGVNYXRyaXgiLCJ0aGV0YSIsImNhbGNEaW1lbnNpb25zTWF0cml4Iiwic2NhbGVNYXRyaXgiLCJmbGlwWCIsImZsaXBZIiwidGFuIiwiY29tcG9zZU1hdHJpeCIsIm1hdHJpeCIsInJlc2V0T2JqZWN0VHJhbnNmb3JtIiwidGFyZ2V0Iiwicm90YXRlIiwic2F2ZU9iamVjdFRyYW5zZm9ybSIsImlzVHJhbnNwYXJlbnQiLCJjdHgiLCJ0b2xlcmFuY2UiLCJfaXNUcmFuc3BhcmVudCIsInRlbXAiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJsIiwiZGF0YSIsInBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZSIsImF0dHJpYnV0ZSIsIm1lZXRPclNsaWNlIiwiYWxpZ25YIiwiYWxpZ25ZIiwiYXNwZWN0UmF0aW9BdHRycyIsImFsaWduIiwicG9wIiwiY2xlYXJGYWJyaWNGb250Q2FjaGUiLCJmb250RmFtaWx5IiwidG9Mb3dlckNhc2UiLCJsaW1pdERpbXNCeUFyZWEiLCJhciIsIm1heGltdW1BcmVhIiwicm91Z2hXaWR0aCIsInBlcmZMaW1pdFNpemVZIiwiY2FwVmFsdWUiLCJmaW5kU2NhbGVUb0ZpdCIsImZpbmRTY2FsZVRvQ292ZXIiLCJtYXRyaXhUb1NWRyIsIk5VTV9GUkFDVElPTl9ESUdJVFMiLCJqb2luIiwicmVtb3ZlVHJhbnNmb3JtRnJvbU9iamVjdCIsImludmVydGVkIiwiZmluYWxUcmFuc2Zvcm0iLCJjYWxjT3duTWF0cml4IiwiYXBwbHlUcmFuc2Zvcm1Ub09iamVjdCIsImFkZFRyYW5zZm9ybVRvT2JqZWN0IiwiY2VudGVyIiwic2V0UG9zaXRpb25CeU9yaWdpbiIsInNpemVBZnRlclRyYW5zZm9ybSIsImRpbVgiLCJkaW1ZIiwidHJhbnNmb3JtTWF0cml4IiwiYmJveCIsIm1lcmdlQ2xpcFBhdGhzIiwiYzEiLCJjMiIsImNhbGNUcmFuc2Zvcm1NYXRyaXgiLCJjbGlwUGF0aCIsImhhc1N0eWxlQ2hhbmdlZCIsInByZXZTdHlsZSIsInRoaXNTdHlsZSIsImZvclRleHRTcGFucyIsInN0cm9rZSIsImZvbnRXZWlnaHQiLCJmb250U3R5bGUiLCJ0ZXh0QmFja2dyb3VuZENvbG9yIiwiZGVsdGFZIiwib3ZlcmxpbmUiLCJ1bmRlcmxpbmUiLCJsaW5ldGhyb3VnaCIsInN0eWxlc1RvQXJyYXkiLCJzdHlsZXMiLCJ0ZXh0IiwiY2xvbmUiLCJ0ZXh0TGluZXMiLCJjaGFySW5kZXgiLCJzdHlsZXNBcnJheSIsImMiLCJrZXlzIiwic3R5bGVDaGFuZ2VkIiwic3RhcnQiLCJlbmQiLCJzdHlsZXNGcm9tQXJyYXkiLCJzdHlsZUluZGV4Iiwic3R5bGVzT2JqZWN0IiwiYXNzaWduIiwiX2pvaW4iLCJwcm90b3R5cGUiLCJjb21tYW5kTGVuZ3RocyIsIm0iLCJoIiwicSIsInJlcGVhdGVkQ29tbWFuZHMiLCJNIiwic2VnbWVudFRvQmV6aWVyIiwidGgyIiwidGgzIiwiY29zVGgiLCJzaW5UaCIsImN4MSIsImN5MSIsIm1UIiwiZnJvbVgiLCJmcm9tWSIsImNvc3RoMiIsInNpbnRoMiIsImNvc3RoMyIsInNpbnRoMyIsInRvWCIsInRvWSIsImNwMVgiLCJjcDFZIiwiY3AyWCIsImNwMlkiLCJhcmNUb1NlZ21lbnRzIiwibGFyZ2UiLCJzd2VlcCIsInJvdGF0ZVgiLCJ0aCIsImFicyIsInB4IiwicHkiLCJyeDIiLCJyeTIiLCJweTIiLCJweDIiLCJwbCIsInJvb3QiLCJjeCIsImN5IiwibVRoZXRhIiwiY2FsY1ZlY3RvckFuZ2xlIiwiZHRoZXRhIiwic2VnbWVudHMiLCJjZWlsIiwicmVzdWx0IiwibURlbHRhIiwidXgiLCJ1eSIsInZ4IiwidnkiLCJ0YSIsInRiIiwiZ2V0Qm91bmRzT2ZDdXJ2ZSIsIngwIiwieTAiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIngzIiwieTMiLCJhcmdzU3RyaW5nIiwidHZhbHVlcyIsImJvdW5kcyIsInQxIiwidDIiLCJiMmFjIiwic3FydGIyYWMiLCJqIiwiamxlbiIsIm10IiwiZnJvbUFyY1RvQmV6aWVycyIsImZ4IiwiZnkiLCJyb3QiLCJ0eCIsInR5Iiwic2Vnc05vcm0iLCJtYWtlUGF0aFNpbXBsZXIiLCJjb252ZXJ0ZWQiLCJkZXN0aW5hdGlvblBhdGgiLCJwcmV2aW91cyIsImNvbnRyb2xYIiwiY29udHJvbFkiLCJjYWxjTGluZUxlbmd0aCIsIkNCMSIsIkNCMiIsIkNCMyIsIkNCNCIsImdldFBvaW50T25DdWJpY0Jlemllckl0ZXJhdG9yIiwicDF4IiwicDF5IiwicDJ4IiwicDJ5IiwicDN4IiwicDN5IiwicDR4IiwicDR5IiwicGN0IiwiYzMiLCJjNCIsImdldFRhbmdlbnRDdWJpY0l0ZXJhdG9yIiwiaW52VCIsInRhbmdlbnRYIiwidGFuZ2VudFkiLCJRQjEiLCJRQjIiLCJRQjMiLCJnZXRQb2ludE9uUXVhZHJhdGljQmV6aWVySXRlcmF0b3IiLCJnZXRUYW5nZW50UXVhZHJhdGljSXRlcmF0b3IiLCJwYXRoSXRlcmF0b3IiLCJpdGVyYXRvciIsInRlbXBQIiwidG1wTGVuIiwicGVyYyIsImZpbmRQZXJjZW50YWdlRm9yRGlzdGFuY2UiLCJzZWdJbmZvIiwiZGlzdGFuY2UiLCJuZXh0TGVuIiwibmV4dFN0ZXAiLCJhbmdsZUZpbmRlciIsImxhc3RQZXJjIiwiZ2V0UGF0aFNlZ21lbnRzSW5mbyIsInRvdGFsTGVuZ3RoIiwiaW5mbyIsInRlbXBJbmZvIiwiY29tbWFuZCIsImRlc3RYIiwiZGVzdFkiLCJnZXRQb2ludE9uUGF0aCIsImluZm9zIiwic2VnUGVyY2VudCIsInNlZ21lbnQiLCJsZXJwIiwicGFyc2VQYXRoIiwicGF0aFN0cmluZyIsImN1cnJlbnRQYXRoIiwicGFyc2VkIiwicmUiLCJyTnVtYmVyIiwick51bWJlckNvbW1hV3NwIiwickZsYWdDb21tYVdzcCIsInJBcmNTZXEiLCJyZWdBcmNBcmd1bWVudFNlcXVlbmNlIiwiUmVnRXhwIiwibWF0Y2giLCJjb29yZHNTdHIiLCJjb29yZHNQYXJzZWQiLCJ0cmltIiwiYXJncyIsImlzTmFOIiwiY29tbWFuZExlbmd0aCIsInJlcGVhdGVkQ29tbWFuZCIsImsiLCJrbGVuIiwiZ2V0U21vb3RoUGF0aEZyb21Qb2ludHMiLCJjb3JyZWN0aW9uIiwicDEiLCJwMiIsIm11bHRTaWduWCIsIm11bHRTaWduWSIsIm1hbnlQb2ludHMiLCJlcSIsIm1pZFBvaW50IiwibWlkUG9pbnRGcm9tIiwidHJhbnNmb3JtUGF0aCIsInBhdGhPZmZzZXQiLCJwYXRoU2VnbWVudCIsIm5ld1NlZ21lbnQiLCJqb2luUGF0aCIsInBhdGhEYXRhIiwiaW52b2tlIiwibWV0aG9kIiwiYnlQcm9wZXJ0eSIsImZpbmQiLCJ2YWx1ZTEiLCJ2YWx1ZTIiLCJjb25kaXRpb24iLCJleHRlbmQiLCJFbGVtZW50IiwiaGFzT3duUHJvcGVydHkiLCJyZXBsYWNlIiwiY2hhcmFjdGVyIiwiY2FwaXRhbGl6ZSIsImZpcnN0TGV0dGVyT25seSIsImVzY2FwZVhtbCIsImdyYXBoZW1lU3BsaXQiLCJ0ZXh0c3RyaW5nIiwiY2hyIiwiZ3JhcGhlbWVzIiwiZ2V0V2hvbGVDaGFyIiwic3RyIiwiY29kZSIsImNoYXJDb2RlQXQiLCJuZXh0IiwicHJldiIsImVtcHR5RnVuY3Rpb24iLCJJU19ET05URU5VTV9CVUdHWSIsInRvU3RyaW5nIiwiYWRkTWV0aG9kcyIsInBhcmVudCIsInN1cGVyY2xhc3MiLCJjb25zdHJ1Y3RvciIsInJldHVyblZhbHVlIiwidmFsdWVPZiIsIlN1YmNsYXNzIiwiY2FsbFN1cGVyIiwibWV0aG9kTmFtZSIsInBhcmVudE1ldGhvZCIsIl90aGlzIiwic3VwZXJDbGFzc01ldGhvZCIsImNyZWF0ZUNsYXNzIiwic2hpZnQiLCJpbml0aWFsaXplIiwic3ViY2xhc3NlcyIsImNvdWxkVXNlQXR0YWNoRXZlbnQiLCJhdHRhY2hFdmVudCIsInRvdWNoRXZlbnRzIiwiYWRkTGlzdGVuZXIiLCJlbGVtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImdldFRvdWNoSW5mbyIsImV2ZW50IiwidG91Y2hQcm9wIiwiY2hhbmdlZFRvdWNoZXMiLCJnZXRQb2ludGVyIiwic2Nyb2xsIiwiZ2V0U2Nyb2xsTGVmdFRvcCIsIl9ldnQiLCJjbGllbnRYIiwiY2xpZW50WSIsImlzVG91Y2hFdmVudCIsInBvaW50ZXJUeXBlIiwic2V0U3R5bGUiLCJlbGVtZW50U3R5bGUiLCJjc3NUZXh0Iiwic2V0T3BhY2l0eSIsIm5vcm1hbGl6ZWRQcm9wZXJ0eSIsInN0eWxlRmxvYXQiLCJzZXRQcm9wZXJ0eSIsInBhcnNlRWwiLCJzdXBwb3J0c09wYWNpdHkiLCJvcGFjaXR5Iiwic3VwcG9ydHNGaWx0ZXJzIiwicmVPcGFjaXR5IiwiZXMiLCJjdXJyZW50U3R5bGUiLCJoYXNMYXlvdXQiLCJ6b29tIiwidGVzdCIsIl9zbGljZSIsImdldEJ5SWQiLCJpZCIsImdldEVsZW1lbnRCeUlkIiwic2xpY2VDYW5Db252ZXJ0Tm9kZWxpc3RzIiwidG9BcnJheSIsImFycmF5TGlrZSIsImNoaWxkTm9kZXMiLCJlcnIiLCJhcnIiLCJtYWtlRWxlbWVudCIsInRhZ05hbWUiLCJlbCIsImNsYXNzTmFtZSIsImh0bWxGb3IiLCJzZXRBdHRyaWJ1dGUiLCJhZGRDbGFzcyIsIndyYXBFbGVtZW50Iiwid3JhcHBlciIsInJlcGxhY2VDaGlsZCIsImRvY0VsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJib2R5Iiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsImhvc3QiLCJub2RlVHlwZSIsImdldEVsZW1lbnRPZmZzZXQiLCJkb2NFbGVtIiwiZG9jIiwib3duZXJEb2N1bWVudCIsImJveCIsIm9mZnNldCIsInNjcm9sbExlZnRUb3AiLCJvZmZzZXRBdHRyaWJ1dGVzIiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyVG9wV2lkdGgiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdUb3AiLCJhdHRyIiwicGFyc2VJbnQiLCJnZXRFbGVtZW50U3R5bGUiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRMZWZ0IiwiY2xpZW50VG9wIiwiZGVmYXVsdFZpZXciLCJnZXRDb21wdXRlZFN0eWxlIiwic2VsZWN0UHJvcCIsIm1ha2VFbGVtZW50VW5zZWxlY3RhYmxlIiwib25zZWxlY3RzdGFydCIsInVuc2VsZWN0YWJsZSIsIm1ha2VFbGVtZW50U2VsZWN0YWJsZSIsImdldE5vZGVDYW52YXMiLCJpbXBsIiwiX2NhbnZhcyIsIl9pbWFnZSIsImNsZWFuVXBKc2RvbU5vZGUiLCJfY3VycmVudFNyYyIsIl9hdHRyaWJ1dGVzIiwiX2NsYXNzTGlzdCIsInNldEltYWdlU21vb3RoaW5nIiwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwid2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwibW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwibXNJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJvSW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwiYWRkUGFyYW1Ub1VybCIsInBhcmFtIiwiZW1wdHlGbiIsInJlcXVlc3QiLCJvbkNvbXBsZXRlIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJwYXJhbWV0ZXJzIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwic2VuZCIsIndhcm4iLCJSVU5OSU5HX0FOSU1BVElPTlMiLCJjYW5jZWxBbGwiLCJhbmltYXRpb25zIiwiYW5pbWF0aW9uIiwiY2FuY2VsIiwiY2FuY2VsQnlDYW52YXMiLCJjYW5jZWxsZWQiLCJjYW5jZWxCeVRhcmdldCIsImZpbmRBbmltYXRpb25zQnlUYXJnZXQiLCJmaW5kQW5pbWF0aW9uSW5kZXgiLCJjYW5jZWxGdW5jIiwiZmluZEFuaW1hdGlvbiIsIm5vb3AiLCJkZWZhdWx0RWFzaW5nIiwiZCIsImFuaW1hdGUiLCJyZW1vdmVGcm9tUmVnaXN0cnkiLCJydW5uaW5nQW5pbWF0aW9ucyIsImN1cnJlbnRWYWx1ZSIsInN0YXJ0VmFsdWUiLCJjb21wbGV0aW9uUmF0ZSIsImR1cmF0aW9uUmF0ZSIsInJlcXVlc3RBbmltRnJhbWUiLCJ0aW1lc3RhbXAiLCJEYXRlIiwiZHVyYXRpb24iLCJmaW5pc2giLCJ0aW1lIiwib25DaGFuZ2UiLCJhYm9ydCIsImVhc2luZyIsImlzTWFueSIsImVuZFZhbHVlIiwiYnlWYWx1ZSIsIm9uU3RhcnQiLCJ0aWNrIiwidGlja3RpbWUiLCJjdXJyZW50VGltZSIsInRpbWVQZXJjIiwiX3ZhbHVlIiwidmFsdWVQZXJjIiwiX3JlcXVlc3RBbmltRnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzZXRUaW1lb3V0IiwiX2NhbmNlbEFuaW1GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY2xlYXJUaW1lb3V0IiwiY2FuY2VsQW5pbUZyYW1lIiwiY2FsY3VsYXRlQ29sb3IiLCJiZWdpbiIsInBvcyIsImNvbG9yIiwiYW5pbWF0ZUNvbG9yIiwiZnJvbUNvbG9yIiwidG9Db2xvciIsInN0YXJ0Q29sb3IiLCJDb2xvciIsImdldFNvdXJjZSIsImVuZENvbG9yIiwib3JpZ2luYWxPbkNvbXBsZXRlIiwib3JpZ2luYWxPbkNoYW5nZSIsInBvc1ZhbHVlIiwiY29sb3JFYXNpbmciLCJub3JtYWxpemUiLCJhc2luIiwiZWxhc3RpYyIsIm9wdHMiLCJlYXNlT3V0Q3ViaWMiLCJlYXNlSW5PdXRDdWJpYyIsImVhc2VJblF1YXJ0IiwiZWFzZU91dFF1YXJ0IiwiZWFzZUluT3V0UXVhcnQiLCJlYXNlSW5RdWludCIsImVhc2VPdXRRdWludCIsImVhc2VJbk91dFF1aW50IiwiZWFzZUluU2luZSIsImVhc2VPdXRTaW5lIiwiZWFzZUluT3V0U2luZSIsImVhc2VJbkV4cG8iLCJlYXNlT3V0RXhwbyIsImVhc2VJbk91dEV4cG8iLCJlYXNlSW5DaXJjIiwiZWFzZU91dENpcmMiLCJlYXNlSW5PdXRDaXJjIiwiZWFzZUluRWxhc3RpYyIsImVhc2VPdXRFbGFzdGljIiwiZWFzZUluT3V0RWxhc3RpYyIsImVhc2VJbkJhY2siLCJlYXNlT3V0QmFjayIsImVhc2VJbk91dEJhY2siLCJlYXNlSW5Cb3VuY2UiLCJlYXNlT3V0Qm91bmNlIiwiZWFzZUluT3V0Qm91bmNlIiwiZWFzZSIsImVhc2VJblF1YWQiLCJlYXNlT3V0UXVhZCIsImVhc2VJbk91dFF1YWQiLCJlYXNlSW5DdWJpYyIsInN2Z1ZhbGlkVGFnTmFtZXMiLCJzdmdWaWV3Qm94RWxlbWVudHMiLCJzdmdJbnZhbGlkQW5jZXN0b3JzIiwic3ZnVmFsaWRQYXJlbnRzIiwiYXR0cmlidXRlc01hcCIsImRpc3BsYXkiLCJ2aXNpYmlsaXR5IiwiY29sb3JBdHRyaWJ1dGVzIiwiZlNpemUiLCJjUGF0aCIsInN2Z1ZhbGlkVGFnTmFtZXNSZWdFeCIsImdldFN2Z1JlZ2V4Iiwic3ZnVmlld0JveEVsZW1lbnRzUmVnRXgiLCJzdmdJbnZhbGlkQW5jZXN0b3JzUmVnRXgiLCJzdmdWYWxpZFBhcmVudHNSZWdFeCIsImNzc1J1bGVzIiwiZ3JhZGllbnREZWZzIiwiY2xpcFBhdGhzIiwibm9ybWFsaXplQXR0ciIsIm5vcm1hbGl6ZVZhbHVlIiwicGFyZW50QXR0cmlidXRlcyIsInBhcnNlVHJhbnNmb3JtQXR0cmlidXRlIiwidmlzaWJsZSIsImZpbGxJbmRleCIsInN0cm9rZUluZGV4IiwiX3NldFN0cm9rZUZpbGxPcGFjaXR5Iiwic2V0QWxwaGEiLCJnZXRBbHBoYSIsInRvUmdiYSIsIl9nZXRNdWx0aXBsZU5vZGVzIiwibm9kZU5hbWVzIiwibm9kZU5hbWUiLCJub2RlQXJyYXkiLCJub2RlTGlzdCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwicm90YXRlTWF0cml4IiwibXVsdGlwbGllclgiLCJtdWx0aXBsaWVyWSIsInNrZXdNYXRyaXgiLCJ0cmFuc2xhdGVNYXRyaXgiLCJzY2FsZSIsInRyYW5zbGF0ZSIsInRyYW5zZm9ybXMiLCJ0cmFuc2Zvcm1MaXN0IiwicmVUcmFuc2Zvcm1MaXN0IiwicmVUcmFuc2Zvcm0iLCJhdHRyaWJ1dGVWYWx1ZSIsIm1hdHJpY2VzIiwib3BlcmF0aW9uIiwiY29tYmluZWRNYXRyaXgiLCJwYXJzZVN0eWxlU3RyaW5nIiwib1N0eWxlIiwiY2h1bmsiLCJwYWlyIiwicGFyc2VTdHlsZU9iamVjdCIsImdldEdsb2JhbFN0eWxlc0ZvckVsZW1lbnQiLCJzdmdVaWQiLCJydWxlIiwiZWxlbWVudE1hdGNoZXNSdWxlIiwic2VsZWN0b3JzIiwiZmlyc3RNYXRjaGluZyIsInBhcmVudE1hdGNoaW5nIiwic2VsZWN0b3JNYXRjaGVzIiwiZG9lc1NvbWVQYXJlbnRNYXRjaCIsInNlbGVjdG9yIiwiY2xhc3NOYW1lcyIsImdldEF0dHJpYnV0ZSIsIm1hdGNoZXIiLCJlbGVtZW50QnlJZCIsIm5vZGUiLCJub2RlbGlzdCIsInBhcnNlVXNlRGlyZWN0aXZlcyIsInhsaW5rQXR0cmlidXRlIiwieGxpbmsiLCJlbDIiLCJjbG9uZU5vZGUiLCJjdXJyZW50VHJhbnMiLCJvbGRMZW5ndGgiLCJhdHRycyIsImFwcGx5Vmlld2JveFRyYW5zZm9ybSIsImVsMyIsImNyZWF0ZUVsZW1lbnROUyIsInNldEF0dHJpYnV0ZU5TIiwibm9kZVZhbHVlIiwiZmlyc3RDaGlsZCIsInJlbW92ZUF0dHJpYnV0ZSIsInJlVmlld0JveEF0dHJWYWx1ZSIsInZpZXdCb3hBdHRyIiwidmlld0JveFdpZHRoIiwidmlld0JveEhlaWdodCIsIndpZHRoQXR0ciIsImhlaWdodEF0dHIiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwibWlzc2luZ1ZpZXdCb3giLCJtaXNzaW5nRGltQXR0ciIsInRvQmVQYXJzZWQiLCJwYXJzZWREaW0iLCJ3aWR0aERpZmYiLCJoZWlnaHREaWZmIiwiaGFzQW5jZXN0b3JXaXRoTm9kZU5hbWUiLCJwYXJzZVNWR0RvY3VtZW50IiwicGFyc2luZ09wdGlvbnMiLCJfX3VpZCIsImRlc2NlbmRhbnRzIiwic2VsZWN0Tm9kZXMiLCJnZXRHcmFkaWVudERlZnMiLCJnZXRDU1NSdWxlcyIsInBhcnNlRWxlbWVudHMiLCJpbnN0YW5jZXMiLCJyZWN1cnNpdmVseVBhcnNlR3JhZGllbnRzWGxpbmsiLCJncmFkaWVudCIsImdyYWRpZW50c0F0dHJzIiwieGxpbmtBdHRyIiwieExpbmsiLCJyZWZlcmVuY2VkR3JhZGllbnQiLCJoYXNBdHRyaWJ1dGUiLCJjaGlsZHJlbiIsInJlZmVyZW5jZUNsb25lIiwicmVGb250RGVjbGFyYXRpb24iLCJwYXJzZUZvbnREZWNsYXJhdGlvbiIsImxpbmVIZWlnaHQiLCJ0YWdBcnJheSIsImVsTGlzdCIsInBhcnNlQXR0cmlidXRlcyIsInBhcmVudEZvbnRTaXplIiwib3duQXR0cmlidXRlcyIsImNzc0F0dHJzIiwicGFyc2VTdHlsZUF0dHJpYnV0ZSIsIm5vcm1hbGl6ZWRBdHRyIiwibm9ybWFsaXplZFZhbHVlIiwibm9ybWFsaXplZFN0eWxlIiwiZm9udCIsIm1lcmdlZEF0dHJzIiwiRWxlbWVudHNQYXJzZXIiLCJwYXJzZSIsInBhcnNlUG9pbnRzQXR0cmlidXRlIiwicGFyc2VkUG9pbnRzIiwiYWxsUnVsZXMiLCJydWxlcyIsInN0eWxlQ29udGVudHMiLCJ0ZXh0Q29udGVudCIsInJ1bGVPYmoiLCJkZWNsYXJhdGlvbiIsInByb3BlcnR5VmFsdWVQYWlycyIsIl9ydWxlIiwibG9hZFNWR0Zyb21VUkwiLCJ4bWwiLCJyZXNwb25zZVhNTCIsInJlc3VsdHMiLCJfb3B0aW9ucyIsImFsbEVsZW1lbnRzIiwibG9hZFNWR0Zyb21TdHJpbmciLCJwYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJyZWdleFVybCIsInByb3RvIiwibnVtRWxlbWVudHMiLCJjcmVhdGVPYmplY3RzIiwiY3JlYXRlT2JqZWN0IiwiZmluZFRhZyIsImZyb21FbGVtZW50IiwiY3JlYXRlQ2FsbGJhY2siLCJjaGVja0lmRG9uZSIsInJlc29sdmVHcmFkaWVudCIsIkltYWdlIiwiX29yaWdpbmFsRWxlbWVudCIsIl9yZW1vdmVUcmFuc2Zvcm1NYXRyaXgiLCJyZXNvbHZlQ2xpcFBhdGgiLCJleHRyYWN0UHJvcGVydHlEZWZpbml0aW9uIiwic3RvcmFnZSIsInJlZ2V4IiwibGFzdEluZGV4IiwiZ3JhZGllbnREZWYiLCJvcGFjaXR5QXR0ciIsImNyZWF0ZUNsaXBQYXRoQ2FsbGJhY2siLCJjb250YWluZXIiLCJfbmV3T2JqIiwiZmlsbFJ1bGUiLCJjbGlwUnVsZSIsInVzaW5nRWxlbWVudCIsIm9ialRyYW5zZm9ybUludiIsImdUcmFuc2Zvcm0iLCJjbGlwUGF0aFRhZyIsImNsaXBQYXRoT3duZXIiLCJ0aGF0Iiwic2NhbGFyQWRkIiwic2NhbGFyQWRkRXF1YWxzIiwic3VidHJhY3RFcXVhbHMiLCJzY2FsYXJTdWJ0cmFjdCIsInNjYWxhclN1YnRyYWN0RXF1YWxzIiwibXVsdGlwbHlFcXVhbHMiLCJkaXZpZGUiLCJkaXZpZGVFcXVhbHMiLCJsdCIsImx0ZSIsImd0IiwiZ3RlIiwiZGlzdGFuY2VGcm9tIiwiZHgiLCJkeSIsInNldFhZIiwic2V0WCIsInNldFkiLCJzZXRGcm9tUG9pbnQiLCJzd2FwIiwiSW50ZXJzZWN0aW9uIiwic3RhdHVzIiwiYXBwZW5kUG9pbnQiLCJhcHBlbmRQb2ludHMiLCJpbnRlcnNlY3RMaW5lTGluZSIsImExIiwiYTIiLCJiMSIsImIyIiwidWFUIiwidWJUIiwidUIiLCJ1YSIsInViIiwiaW50ZXJzZWN0TGluZVBvbHlnb24iLCJpbnRlciIsImludGVyc2VjdFBvbHlnb25Qb2x5Z29uIiwicG9pbnRzMSIsInBvaW50czIiLCJpbnRlcnNlY3RQb2x5Z29uUmVjdGFuZ2xlIiwicjEiLCJyMiIsInRvcFJpZ2h0IiwiYm90dG9tTGVmdCIsImludGVyMSIsImludGVyMiIsImludGVyMyIsImludGVyNCIsInNldFNvdXJjZSIsIl90cnlQYXJzaW5nQ29sb3IiLCJjb2xvck5hbWVNYXAiLCJzb3VyY2VGcm9tSGV4Iiwic291cmNlRnJvbVJnYiIsInNvdXJjZUZyb21Ic2wiLCJfcmdiVG9Ic2wiLCJnIiwicm91bmQiLCJfc291cmNlIiwidG9SZ2IiLCJ0b0hzbCIsImhzbCIsInRvSHNsYSIsInRvSGV4IiwidG9IZXhhIiwidG9HcmF5c2NhbGUiLCJhdmVyYWdlIiwiY3VycmVudEFscGhhIiwidG9CbGFja1doaXRlIiwidGhyZXNob2xkIiwib3ZlcmxheVdpdGgiLCJvdGhlckNvbG9yIiwib3RoZXJBbHBoYSIsIm90aGVyU291cmNlIiwicmVSR0JhIiwicmVIU0xhIiwicmVIZXgiLCJhbGljZWJsdWUiLCJhbnRpcXVld2hpdGUiLCJhcXVhIiwiYXF1YW1hcmluZSIsImF6dXJlIiwiYmVpZ2UiLCJiaXNxdWUiLCJibGFjayIsImJsYW5jaGVkYWxtb25kIiwiYmx1ZSIsImJsdWV2aW9sZXQiLCJicm93biIsImJ1cmx5d29vZCIsImNhZGV0Ymx1ZSIsImNoYXJ0cmV1c2UiLCJjaG9jb2xhdGUiLCJjb3JhbCIsImNvcm5mbG93ZXJibHVlIiwiY29ybnNpbGsiLCJjcmltc29uIiwiY3lhbiIsImRhcmtibHVlIiwiZGFya2N5YW4iLCJkYXJrZ29sZGVucm9kIiwiZGFya2dyYXkiLCJkYXJrZ3JleSIsImRhcmtncmVlbiIsImRhcmtraGFraSIsImRhcmttYWdlbnRhIiwiZGFya29saXZlZ3JlZW4iLCJkYXJrb3JhbmdlIiwiZGFya29yY2hpZCIsImRhcmtyZWQiLCJkYXJrc2FsbW9uIiwiZGFya3NlYWdyZWVuIiwiZGFya3NsYXRlYmx1ZSIsImRhcmtzbGF0ZWdyYXkiLCJkYXJrc2xhdGVncmV5IiwiZGFya3R1cnF1b2lzZSIsImRhcmt2aW9sZXQiLCJkZWVwcGluayIsImRlZXBza3libHVlIiwiZGltZ3JheSIsImRpbWdyZXkiLCJkb2RnZXJibHVlIiwiZmlyZWJyaWNrIiwiZmxvcmFsd2hpdGUiLCJmb3Jlc3RncmVlbiIsImZ1Y2hzaWEiLCJnYWluc2Jvcm8iLCJnaG9zdHdoaXRlIiwiZ29sZCIsImdvbGRlbnJvZCIsImdyYXkiLCJncmV5IiwiZ3JlZW4iLCJncmVlbnllbGxvdyIsImhvbmV5ZGV3IiwiaG90cGluayIsImluZGlhbnJlZCIsImluZGlnbyIsIml2b3J5Iiwia2hha2kiLCJsYXZlbmRlciIsImxhdmVuZGVyYmx1c2giLCJsYXduZ3JlZW4iLCJsZW1vbmNoaWZmb24iLCJsaWdodGJsdWUiLCJsaWdodGNvcmFsIiwibGlnaHRjeWFuIiwibGlnaHRnb2xkZW5yb2R5ZWxsb3ciLCJsaWdodGdyYXkiLCJsaWdodGdyZXkiLCJsaWdodGdyZWVuIiwibGlnaHRwaW5rIiwibGlnaHRzYWxtb24iLCJsaWdodHNlYWdyZWVuIiwibGlnaHRza3libHVlIiwibGlnaHRzbGF0ZWdyYXkiLCJsaWdodHNsYXRlZ3JleSIsImxpZ2h0c3RlZWxibHVlIiwibGlnaHR5ZWxsb3ciLCJsaW1lIiwibGltZWdyZWVuIiwibGluZW4iLCJtYWdlbnRhIiwibWFyb29uIiwibWVkaXVtYXF1YW1hcmluZSIsIm1lZGl1bWJsdWUiLCJtZWRpdW1vcmNoaWQiLCJtZWRpdW1wdXJwbGUiLCJtZWRpdW1zZWFncmVlbiIsIm1lZGl1bXNsYXRlYmx1ZSIsIm1lZGl1bXNwcmluZ2dyZWVuIiwibWVkaXVtdHVycXVvaXNlIiwibWVkaXVtdmlvbGV0cmVkIiwibWlkbmlnaHRibHVlIiwibWludGNyZWFtIiwibWlzdHlyb3NlIiwibW9jY2FzaW4iLCJuYXZham93aGl0ZSIsIm5hdnkiLCJvbGRsYWNlIiwib2xpdmUiLCJvbGl2ZWRyYWIiLCJvcmFuZ2UiLCJvcmFuZ2VyZWQiLCJvcmNoaWQiLCJwYWxlZ29sZGVucm9kIiwicGFsZWdyZWVuIiwicGFsZXR1cnF1b2lzZSIsInBhbGV2aW9sZXRyZWQiLCJwYXBheWF3aGlwIiwicGVhY2hwdWZmIiwicGVydSIsInBpbmsiLCJwbHVtIiwicG93ZGVyYmx1ZSIsInB1cnBsZSIsInJlYmVjY2FwdXJwbGUiLCJyZWQiLCJyb3N5YnJvd24iLCJyb3lhbGJsdWUiLCJzYWRkbGVicm93biIsInNhbG1vbiIsInNhbmR5YnJvd24iLCJzZWFncmVlbiIsInNlYXNoZWxsIiwic2llbm5hIiwic2lsdmVyIiwic2t5Ymx1ZSIsInNsYXRlYmx1ZSIsInNsYXRlZ3JheSIsInNsYXRlZ3JleSIsInNub3ciLCJzcHJpbmdncmVlbiIsInN0ZWVsYmx1ZSIsInRlYWwiLCJ0aGlzdGxlIiwidG9tYXRvIiwidHVycXVvaXNlIiwidmlvbGV0Iiwid2hlYXQiLCJ3aGl0ZSIsIndoaXRlc21va2UiLCJ5ZWxsb3ciLCJ5ZWxsb3dncmVlbiIsImh1ZTJyZ2IiLCJmcm9tUmdiIiwiZnJvbVNvdXJjZSIsImZyb21SZ2JhIiwiZnJvbUhzbCIsImZyb21Ic2xhIiwiZnJvbUhleCIsImlzU2hvcnROb3RhdGlvbiIsImlzUkdCYSIsIm9Db2xvciIsInNjYWxlTWFwIiwic2tld01hcCIsImNvbnRyb2xzIiwiTEVGVCIsIlRPUCIsIlJJR0hUIiwiQk9UVE9NIiwiQ0VOVEVSIiwib3Bwb3NpdGUiLCJib3R0b20iLCJyaWdodCIsImZpbmRDb3JuZXJRdWFkcmFudCIsImZhYnJpY09iamVjdCIsImNvbnRyb2wiLCJjb3JuZXJBbmdsZSIsImZpcmVFdmVudCIsImNhbnZhc09wdGlvbnMiLCJzY2FsZUlzUHJvcG9ydGlvbmFsIiwiZXZlbnREYXRhIiwidW5pU2NhbGVLZXkiLCJ1bmlmb3JtSXNUb2dnbGVkIiwidW5pZm9ybVNjYWxpbmciLCJpc1RyYW5zZm9ybUNlbnRlcmVkIiwib3JpZ2luWCIsIm9yaWdpblkiLCJzY2FsaW5nSXNGb3JiaWRkZW4iLCJieSIsInNjYWxlUHJvcG9ydGlvbmFsbHkiLCJsb2NrWCIsImxvY2tTY2FsaW5nWCIsImxvY2tZIiwibG9ja1NjYWxpbmdZIiwic2NhbGVDdXJzb3JTdHlsZUhhbmRsZXIiLCJub3RBbGxvd2VkIiwibiIsInNrZXdDdXJzb3JTdHlsZUhhbmRsZXIiLCJsb2NrU2tld2luZ1kiLCJsb2NrU2tld2luZ1giLCJzY2FsZVNrZXdDdXJzb3JTdHlsZUhhbmRsZXIiLCJhbHRBY3Rpb25LZXkiLCJzY2FsZU9yU2tld0FjdGlvbk5hbWUiLCJpc0FsdGVybmF0aXZlIiwicm90YXRpb25TdHlsZUhhbmRsZXIiLCJsb2NrUm90YXRpb24iLCJjdXJzb3JTdHlsZSIsImNvbW1vbkV2ZW50SW5mbyIsImUiLCJwb2ludGVyIiwid3JhcFdpdGhGaXhlZEFuY2hvciIsImFjdGlvbkhhbmRsZXIiLCJnZXRDZW50ZXJQb2ludCIsImNvbnN0cmFpbnQiLCJ0cmFuc2xhdGVUb09yaWdpblBvaW50IiwiYWN0aW9uUGVyZm9ybWVkIiwid3JhcFdpdGhGaXJlRXZlbnQiLCJnZXRMb2NhbFBvaW50IiwiY29ybmVyIiwiZ2V0Wm9vbSIsInBhZGRpbmciLCJsb2NhbFBvaW50IiwidG9Mb2NhbFBvaW50Iiwib2Zmc2V0WCIsIm9mZnNldFkiLCJ0YXJnZXRIYXNPbmVGbGlwIiwiY29tcGVuc2F0ZVNjYWxlRm9yU2tldyIsIm9wcG9zaXRlU2tldyIsInNjYWxlVG9Db21wZW5zYXRlIiwiYXhpcyIsInJlZmVyZW5jZSIsIm5ld0RpbSIsIl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMiLCJuZXdWYWx1ZSIsInNrZXdPYmplY3RYIiwiZGltTm9Ta2V3IiwidG90YWxTa2V3U2l6ZSIsImN1cnJlbnRTa2V3IiwibmV3U2tldyIsImhhc1NrZXdlZCIsImRpbUJlZm9yZVNrZXdpbmciLCJza2V3T2JqZWN0WSIsInNrZXdIYW5kbGVyWCIsImxvY2FsUG9pbnRGcm9tQ2VudGVyIiwiZmluYWxIYW5kbGVyIiwic2tld0hhbmRsZXJZIiwicm90YXRpb25XaXRoU25hcHBpbmciLCJwaXZvdFBvaW50IiwibGFzdEFuZ2xlIiwiZXkiLCJleCIsImN1ckFuZ2xlIiwiaGFzUm90YXRlZCIsInNuYXBBbmdsZSIsInNuYXBUaHJlc2hvbGQiLCJyaWdodEFuZ2xlTG9ja2VkIiwibGVmdEFuZ2xlTG9ja2VkIiwic2NhbGVPYmplY3QiLCJkaW0iLCJmb3JiaWRTY2FsaW5nIiwic2lnblgiLCJzaWduWSIsImdlc3R1cmVTY2FsZSIsImxvY2tTY2FsaW5nRmxpcCIsIm9yaWdpbmFsIiwib3JpZ2luYWxEaXN0YW5jZSIsIm9sZFNjYWxlWCIsIm9sZFNjYWxlWSIsInNjYWxlT2JqZWN0RnJvbUNvcm5lciIsInNjYWxlT2JqZWN0WCIsInNjYWxlT2JqZWN0WSIsInNjYWxpbmdZT3JTa2V3aW5nWCIsInNjYWxpbmdZIiwic2NhbGluZ1hPclNrZXdpbmdZIiwic2NhbGluZ1giLCJjaGFuZ2VXaWR0aCIsInN0cm9rZVBhZGRpbmciLCJtdWx0aXBsaWVyIiwib2xkV2lkdGgiLCJuZXdXaWR0aCIsImRyYWdIYW5kbGVyIiwibmV3TGVmdCIsIm5ld1RvcCIsIm1vdmVYIiwibW92ZVkiLCJzY2FsaW5nRXF1YWxseSIsImNvbnRyb2xzVXRpbHMiLCJyZW5kZXJDaXJjbGVDb250cm9sIiwic3R5bGVPdmVycmlkZSIsInhTaXplIiwic2l6ZVgiLCJjb3JuZXJTaXplIiwieVNpemUiLCJzaXplWSIsInRyYW5zcGFyZW50Q29ybmVycyIsImNvcm5lclN0cm9rZUNvbG9yIiwibXlMZWZ0IiwibXlUb3AiLCJzYXZlIiwiZmlsbFN0eWxlIiwiY29ybmVyQ29sb3IiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsImJlZ2luUGF0aCIsImFyYyIsInJlc3RvcmUiLCJyZW5kZXJTcXVhcmVDb250cm9sIiwieFNpemVCeTIiLCJ5U2l6ZUJ5MiIsInN0cm9rZVJlY3QiLCJDb250cm9sIiwiYWN0aW9uTmFtZSIsInRvdWNoU2l6ZVgiLCJ0b3VjaFNpemVZIiwid2l0aENvbm5lY3Rpb24iLCJtb3VzZURvd25IYW5kbGVyIiwibW91c2VVcEhhbmRsZXIiLCJnZXRBY3Rpb25IYW5kbGVyIiwiZ2V0TW91c2VEb3duSGFuZGxlciIsImdldE1vdXNlVXBIYW5kbGVyIiwiY3Vyc29yU3R5bGVIYW5kbGVyIiwiZ2V0QWN0aW9uTmFtZSIsImdldFZpc2liaWxpdHkiLCJjb250cm9sS2V5Iiwib2JqZWN0VmlzaWJpbGl0eSIsIl9jb250cm9sc1Zpc2liaWxpdHkiLCJzZXRWaXNpYmlsaXR5IiwicG9zaXRpb25IYW5kbGVyIiwiZmluYWxNYXRyaXgiLCJjYWxjQ29ybmVyQ29vcmRzIiwib2JqZWN0QW5nbGUiLCJvYmplY3RDb3JuZXJTaXplIiwiY2VudGVyWCIsImNlbnRlclkiLCJpc1RvdWNoIiwiY29zSGFsZk9mZnNldCIsInNpbkhhbGZPZmZzZXQiLCJjb3NIYWxmT2Zmc2V0Q29tcCIsInNpbkhhbGZPZmZzZXRDb21wIiwiY29udHJvbFRyaWFuZ2xlQW5nbGUiLCJjb3JuZXJIeXBvdGVudXNlIiwibmV3VGhldGEiLCJuZXdUaGV0YUNvbXAiLCJ0bCIsInRyIiwiYmwiLCJiciIsInJlbmRlciIsImNvcm5lclN0eWxlIiwiZ2V0Q29sb3JTdG9wIiwiY29sb3JBbHBoYSIsImtleVZhbHVlUGFpcnMiLCJnZXRMaW5lYXJDb29yZHMiLCJnZXRSYWRpYWxDb29yZHMiLCJncmFkaWVudFRyYW5zZm9ybSIsImdyYWRpZW50VW5pdHMiLCJvcHRpb24iLCJhZGRDb2xvclN0b3AiLCJ0b09iamVjdCIsInByb3BlcnRpZXNUb0luY2x1ZGUiLCJ0b1NWRyIsIm1hcmt1cCIsImNvbW1vbkF0dHJpYnV0ZXMiLCJuZWVkc1N3YXAiLCJ3aXRoVmlld3BvcnQiLCJhZGRpdGlvbmFsVHJhbnNmb3JtIiwic29ydCIsInJldmVyc2UiLCJtaW5SYWRpdXMiLCJtYXhSYWRpdXMiLCJwZXJjZW50YWdlU2hpZnQiLCJjb2xvclN0b3AiLCJ0b0xpdmUiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImNyZWF0ZVJhZGlhbEdyYWRpZW50IiwiaW5zdGFuY2UiLCJzdmdPcHRpb25zIiwiY29sb3JTdG9wRWxzIiwiX19jb252ZXJ0UGVyY2VudFVuaXRzVG9WYWx1ZXMiLCJwcm9wVmFsdWUiLCJmaW5hbFZhbHVlIiwicmVwZWF0IiwicGF0dGVyblRyYW5zZm9ybSIsInNldE9wdGlvbnMiLCJpc0Vycm9yIiwicGF0dGVyblNvdXJjZSIsInBhdHRlcm5XaWR0aCIsInBhdHRlcm5IZWlnaHQiLCJwYXR0ZXJuT2Zmc2V0WCIsInBhdHRlcm5PZmZzZXRZIiwicGF0dGVybkltZ1NyYyIsImNvbXBsZXRlIiwibmF0dXJhbFdpZHRoIiwibmF0dXJhbEhlaWdodCIsImNyZWF0ZVBhdHRlcm4iLCJTaGFkb3ciLCJibHVyIiwiYWZmZWN0U3Ryb2tlIiwiaW5jbHVkZURlZmF1bHRWYWx1ZXMiLCJub25TY2FsaW5nIiwiX3BhcnNlU2hhZG93Iiwic2hhZG93Iiwic2hhZG93U3RyIiwib2Zmc2V0c0FuZEJsdXIiLCJyZU9mZnNldHNBbmRCbHVyIiwiZkJveFgiLCJmQm94WSIsIkJMVVJfQk9YIiwiU3RhdGljQ2FudmFzIiwiQ0FOVkFTX0lOSVRfRVJST1IiLCJFcnJvciIsInJlbmRlckFuZFJlc2V0Qm91bmQiLCJyZW5kZXJBbmRSZXNldCIsInJlcXVlc3RSZW5kZXJBbGxCb3VuZCIsIl9pbml0U3RhdGljIiwiYmFja2dyb3VuZENvbG9yIiwiYmFja2dyb3VuZEltYWdlIiwib3ZlcmxheUNvbG9yIiwib3ZlcmxheUltYWdlIiwic3RhdGVmdWwiLCJjb250cm9sc0Fib3ZlT3ZlcmxheSIsImFsbG93VG91Y2hTY3JvbGxpbmciLCJ2aWV3cG9ydFRyYW5zZm9ybSIsImJhY2tncm91bmRWcHQiLCJvdmVybGF5VnB0IiwiZW5hYmxlUmV0aW5hU2NhbGluZyIsInZwdENvb3JkcyIsInNraXBPZmZzY3JlZW4iLCJjYiIsIl9jcmVhdGVMb3dlckNhbnZhcyIsIl9pbml0T3B0aW9ucyIsImludGVyYWN0aXZlIiwiX2luaXRSZXRpbmFTY2FsaW5nIiwic2V0T3ZlcmxheUltYWdlIiwic2V0QmFja2dyb3VuZEltYWdlIiwic2V0QmFja2dyb3VuZENvbG9yIiwic2V0T3ZlcmxheUNvbG9yIiwiY2FsY09mZnNldCIsIl9pc1JldGluYVNjYWxpbmciLCJnZXRSZXRpbmFTY2FsaW5nIiwic2NhbGVSYXRpbyIsIl9faW5pdFJldGluYVNjYWxpbmciLCJsb3dlckNhbnZhc0VsIiwiY29udGV4dENvbnRhaW5lciIsInVwcGVyQ2FudmFzRWwiLCJjb250ZXh0VG9wIiwiX29mZnNldCIsImltYWdlIiwiX19zZXRCZ092ZXJsYXlJbWFnZSIsIl9fc2V0QmdPdmVybGF5Q29sb3IiLCJfY3JlYXRlQ2FudmFzRWxlbWVudCIsIl9vcmlnaW5hbENhbnZhc1N0eWxlIiwiX2FwcGx5Q2FudmFzU3R5bGUiLCJnZXRXaWR0aCIsImdldEhlaWdodCIsInNldFdpZHRoIiwic2V0RGltZW5zaW9ucyIsInNldEhlaWdodCIsImRpbWVuc2lvbnMiLCJjc3NWYWx1ZSIsImNzc09ubHkiLCJfc2V0QmFja3N0b3JlRGltZW5zaW9uIiwiaGFzTG9zdENvbnRleHQiLCJiYWNrc3RvcmVPbmx5IiwiX3NldENzc0RpbWVuc2lvbiIsIl9pc0N1cnJlbnRseURyYXdpbmciLCJmcmVlRHJhd2luZ0JydXNoIiwiX3NldEJydXNoU3R5bGVzIiwiY2FjaGVDYW52YXNFbCIsIndyYXBwZXJFbCIsInNldFZpZXdwb3J0VHJhbnNmb3JtIiwidnB0IiwiYWN0aXZlT2JqZWN0IiwiX2FjdGl2ZU9iamVjdCIsImJhY2tncm91bmRPYmplY3QiLCJvdmVybGF5T2JqZWN0IiwiZ3JvdXAiLCJzZXRDb29yZHMiLCJjYWxjVmlld3BvcnRCb3VuZGFyaWVzIiwiem9vbVRvUG9pbnQiLCJiZWZvcmUiLCJhZnRlciIsInNldFpvb20iLCJhYnNvbHV0ZVBhbiIsInJlbGF0aXZlUGFuIiwiZ2V0RWxlbWVudCIsInNldHVwU3RhdGUiLCJjbGVhckNvbnRleHQiLCJjbGVhclJlY3QiLCJjbGVhciIsIl9oYXNJVGV4dEhhbmRsZXJzIiwiX21vdXNlVXBJVGV4dEhhbmRsZXIiLCJfaVRleHRJbnN0YW5jZXMiLCJyZW5kZXJBbGwiLCJjYW52YXNUb0RyYXdPbiIsInJlbmRlckNhbnZhcyIsImlzUmVuZGVyaW5nIiwiaVZwdCIsImNhbmNlbFJlcXVlc3RlZFJlbmRlciIsIl9yZW5kZXJCYWNrZ3JvdW5kIiwiX3JlbmRlck9iamVjdHMiLCJkcmF3Q29udHJvbHMiLCJzaG91bGRDYWNoZSIsIl90cmFuc2Zvcm1Eb25lIiwicmVuZGVyQ2FjaGUiLCJmb3JDbGlwcGluZyIsImRyYXdDbGlwUGF0aE9uQ2FudmFzIiwiX3JlbmRlck92ZXJsYXkiLCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24iLCJ6b29tWCIsInpvb21ZIiwiX2NhY2hlQ2FudmFzIiwiY2FjaGVUcmFuc2xhdGlvblgiLCJjYWNoZVRyYW5zbGF0aW9uWSIsIl9yZW5kZXJCYWNrZ3JvdW5kT3JPdmVybGF5IiwibmVlZHNWcHQiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJnZXRDZW50ZXIiLCJjZW50ZXJPYmplY3RIIiwiX2NlbnRlck9iamVjdCIsImNlbnRlck9iamVjdFYiLCJjZW50ZXJPYmplY3QiLCJ2aWV3cG9ydENlbnRlck9iamVjdCIsInZwQ2VudGVyIiwiZ2V0VnBDZW50ZXIiLCJ2aWV3cG9ydENlbnRlck9iamVjdEgiLCJ2aWV3cG9ydENlbnRlck9iamVjdFYiLCJ0b0RhdGFsZXNzSlNPTiIsInRvRGF0YWxlc3NPYmplY3QiLCJfdG9PYmplY3RNZXRob2QiLCJfdG9PYmplY3RzIiwiZXhjbHVkZUZyb21FeHBvcnQiLCJfdG9PYmplY3QiLCJfX3NlcmlhbGl6ZUJnT3ZlcmxheSIsIm9yaWdpbmFsVmFsdWUiLCJiZ0ltYWdlIiwiYmdDb2xvciIsImJhY2tncm91bmQiLCJvdmVybGF5Iiwic3ZnVmlld3BvcnRUcmFuc2Zvcm1hdGlvbiIsIl9zZXRTVkdQcmVhbWJsZSIsIl9zZXRTVkdIZWFkZXIiLCJjbGlwUGF0aElkIiwiX3NldFNWR0JnT3ZlcmxheUNvbG9yIiwiX3NldFNWR0JnT3ZlcmxheUltYWdlIiwiX3NldFNWR09iamVjdHMiLCJzdXBwcmVzc1ByZWFtYmxlIiwiZW5jb2RpbmciLCJ2aWV3Qm94IiwiY3JlYXRlU1ZHRm9udEZhY2VzTWFya3VwIiwiY3JlYXRlU1ZHUmVmRWxlbWVudHNNYXJrdXAiLCJjcmVhdGVTVkdDbGlwUGF0aE1hcmt1cCIsInRvQ2xpcFBhdGhTVkciLCJzaG91bGRUcmFuc2Zvcm0iLCJmb250TGlzdCIsInJvdyIsInJvd0luZGV4IiwiX2NoYXIiLCJfc2V0U1ZHT2JqZWN0IiwiZmluYWxXaWR0aCIsImZpbmFsSGVpZ2h0Iiwic2hvdWxkSW52ZXJ0Iiwic2VuZFRvQmFjayIsImFjdGl2ZVNlbGVjdGlvbiIsIm9ianMiLCJ1bnNoaWZ0IiwiYnJpbmdUb0Zyb250Iiwic2VuZEJhY2t3YXJkcyIsImludGVyc2VjdGluZyIsIm5ld0lkeCIsIm9ianNNb3ZlZCIsIl9maW5kTmV3TG93ZXJJbmRleCIsImlzSW50ZXJzZWN0aW5nIiwiaW50ZXJzZWN0c1dpdGhPYmplY3QiLCJpc0NvbnRhaW5lZFdpdGhpbk9iamVjdCIsImJyaW5nRm9yd2FyZCIsIl9maW5kTmV3VXBwZXJJbmRleCIsImRpc3Bvc2UiLCJjbGFzc0xpc3QiLCJEYXRhVVJMRXhwb3J0ZXIiLCJFTVBUWV9KU09OIiwic3VwcG9ydHMiLCJzZXRMaW5lRGFzaCIsInRvSlNPTiIsImNyZWF0ZVBOR1N0cmVhbSIsImNyZWF0ZUpQRUdTdHJlYW0iLCJCYXNlQnJ1c2giLCJzdHJva2VMaW5lQ2FwIiwic3Ryb2tlRGFzaEFycmF5IiwibGltaXRlZFRvQ2FudmFzU2l6ZSIsImxpbmVDYXAiLCJtaXRlckxpbWl0IiwibGluZUpvaW4iLCJfc2F2ZUFuZFRyYW5zZm9ybSIsIl9zZXRTaGFkb3ciLCJzaGFkb3dDb2xvciIsInNoYWRvd0JsdXIiLCJzaGFkb3dPZmZzZXRYIiwic2hhZG93T2Zmc2V0WSIsIm5lZWRzRnVsbFJlbmRlciIsIl9yZXNldFNoYWRvdyIsIl9pc091dFNpZGVDYW52YXMiLCJQZW5jaWxCcnVzaCIsImRlY2ltYXRlIiwiZHJhd1N0cmFpZ2h0TGluZSIsInN0cmFpZ2h0TGluZUtleSIsIl9wb2ludHMiLCJfaGFzU3RyYWlnaHRMaW5lIiwiX2RyYXdTZWdtZW50IiwicXVhZHJhdGljQ3VydmVUbyIsIm9uTW91c2VEb3duIiwiX2lzTWFpbkV2ZW50IiwiX3ByZXBhcmVGb3JEcmF3aW5nIiwiX2NhcHR1cmVEcmF3aW5nUGF0aCIsIl9yZW5kZXIiLCJvbk1vdXNlTW92ZSIsIm9sZEVuZCIsIm9uTW91c2VVcCIsIl9maW5hbGl6ZUFuZEFkZFBhdGgiLCJfcmVzZXQiLCJfYWRkUG9pbnQiLCJwb2ludGVyUG9pbnQiLCJjb252ZXJ0UG9pbnRzVG9TVkdQYXRoIiwiX2lzRW1wdHlTVkdQYXRoIiwiY3JlYXRlUGF0aCIsIlBhdGgiLCJkZWNpbWF0ZVBvaW50cyIsImFkanVzdGVkRGlzdGFuY2UiLCJsYXN0UG9pbnQiLCJuZXdQb2ludHMiLCJjRGlzdGFuY2UiLCJDaXJjbGVCcnVzaCIsImRyYXdEb3QiLCJhZGRQb2ludCIsImRvdCIsInJhZGl1cyIsIm9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmUiLCJjaXJjbGVzIiwiY2lyY2xlIiwiQ2lyY2xlIiwiY2lyY2xlUmFkaXVzIiwiY2lyY2xlQ29sb3IiLCJTcHJheUJydXNoIiwiZGVuc2l0eSIsImRvdFdpZHRoIiwiZG90V2lkdGhWYXJpYW5jZSIsInJhbmRvbU9wYWNpdHkiLCJvcHRpbWl6ZU92ZXJsYXBwaW5nIiwic3ByYXlDaHVua3MiLCJhZGRTcHJheUNodW5rIiwic3ByYXlDaHVua1BvaW50cyIsInJlY3RzIiwiaWxlbiIsInNwcmF5Q2h1bmsiLCJyZWN0IiwiUmVjdCIsIl9nZXRPcHRpbWl6ZWRSZWN0cyIsInVuaXF1ZVJlY3RzIiwidW5pcXVlUmVjdHNBcnJheSIsImdsb2JhbEFscGhhIiwiZmlsbFJlY3QiLCJQYXR0ZXJuQnJ1c2giLCJnZXRQYXR0ZXJuU3JjIiwiZG90RGlzdGFuY2UiLCJwYXR0ZXJuQ2FudmFzIiwicGF0dGVybkN0eCIsImdldFBhdHRlcm5TcmNGdW5jdGlvbiIsIlN0cmluZyIsImdldFBhdHRlcm4iLCJ0b3BMZWZ0IiwiX2dldExlZnRUb3BDb29yZHMiLCJfaW5pdEludGVyYWN0aXZlIiwiX2NyZWF0ZUNhY2hlQ2FudmFzIiwiY2VudGVyZWRTY2FsaW5nIiwiY2VudGVyZWRSb3RhdGlvbiIsImNlbnRlcmVkS2V5Iiwic2VsZWN0aW9uIiwic2VsZWN0aW9uS2V5IiwiYWx0U2VsZWN0aW9uS2V5Iiwic2VsZWN0aW9uQ29sb3IiLCJzZWxlY3Rpb25EYXNoQXJyYXkiLCJzZWxlY3Rpb25Cb3JkZXJDb2xvciIsInNlbGVjdGlvbkxpbmVXaWR0aCIsInNlbGVjdGlvbkZ1bGx5Q29udGFpbmVkIiwiaG92ZXJDdXJzb3IiLCJtb3ZlQ3Vyc29yIiwiZGVmYXVsdEN1cnNvciIsImZyZWVEcmF3aW5nQ3Vyc29yIiwibm90QWxsb3dlZEN1cnNvciIsImNvbnRhaW5lckNsYXNzIiwicGVyUGl4ZWxUYXJnZXRGaW5kIiwidGFyZ2V0RmluZFRvbGVyYW5jZSIsInNraXBUYXJnZXRGaW5kIiwiaXNEcmF3aW5nTW9kZSIsInByZXNlcnZlT2JqZWN0U3RhY2tpbmciLCJzdG9wQ29udGV4dE1lbnUiLCJmaXJlUmlnaHRDbGljayIsImZpcmVNaWRkbGVDbGljayIsInRhcmdldHMiLCJlbmFibGVQb2ludGVyRXZlbnRzIiwiX2hvdmVyZWRUYXJnZXQiLCJfaG92ZXJlZFRhcmdldHMiLCJfY3VycmVudFRyYW5zZm9ybSIsIl9ncm91cFNlbGVjdG9yIiwiX2luaXRXcmFwcGVyRWxlbWVudCIsIl9jcmVhdGVVcHBlckNhbnZhcyIsIl9pbml0RXZlbnRMaXN0ZW5lcnMiLCJfY2hvb3NlT2JqZWN0c1RvUmVuZGVyIiwiYWN0aXZlT2JqZWN0cyIsImdldEFjdGl2ZU9iamVjdHMiLCJvYmpzVG9SZW5kZXIiLCJhY3RpdmVHcm91cE9iamVjdHMiLCJjb250ZXh0VG9wRGlydHkiLCJyZW5kZXJUb3BMYXllciIsIl9kcmF3U2VsZWN0aW9uIiwicmVuZGVyVG9wIiwiX25vcm1hbGl6ZVBvaW50ZXIiLCJpbnZlcnRlZE0iLCJ2cHRQb2ludGVyIiwicmVzdG9yZVBvaW50ZXJWcHQiLCJpc1RhcmdldFRyYW5zcGFyZW50Iiwibm9ybWFsaXplZFBvaW50ZXIiLCJ0YXJnZXRSZWxhdGl2ZVgiLCJ0YXJnZXRSZWxhdGl2ZVkiLCJfY2FjaGVDb250ZXh0IiwiY29udGV4dENhY2hlIiwib3JpZ2luYWxDb2xvciIsInNlbGVjdGlvbkJhY2tncm91bmRDb2xvciIsIl9pc1NlbGVjdGlvbktleVByZXNzZWQiLCJzZWxlY3Rpb25LZXlQcmVzc2VkIiwiX3Nob3VsZENsZWFyU2VsZWN0aW9uIiwiZXZlbnRlZCIsInNlbGVjdGFibGUiLCJfc2hvdWxkQ2VudGVyVHJhbnNmb3JtIiwiYWN0aW9uIiwiYWx0S2V5IiwiY2VudGVyVHJhbnNmb3JtIiwiX2dldE9yaWdpbkZyb21Db3JuZXIiLCJfZ2V0QWN0aW9uRnJvbUNvcm5lciIsImFscmVhZHlTZWxlY3RlZCIsIl9zZXR1cEN1cnJlbnRUcmFuc2Zvcm0iLCJfX2Nvcm5lciIsImxhc3RYIiwibGFzdFkiLCJzaGlmdEtleSIsIl9iZWZvcmVUcmFuc2Zvcm0iLCJzZXRDdXJzb3IiLCJjdXJzb3IiLCJ2aWV3cG9ydFN0YXJ0Iiwidmlld3BvcnRFeHRlbnQiLCJleHRlbnQiLCJzdHJva2VPZmZzZXQiLCJfc2V0TGluZURhc2giLCJmaW5kVGFyZ2V0Iiwic2tpcEdyb3VwIiwiaWdub3JlWm9vbSIsImFPYmplY3RzIiwiYWN0aXZlVGFyZ2V0IiwiYWN0aXZlVGFyZ2V0U3VicyIsInNob3VsZExvb2tGb3JBY3RpdmUiLCJfZmluZFRhcmdldENvcm5lciIsIl9zZWFyY2hQb3NzaWJsZVRhcmdldHMiLCJfY2hlY2tUYXJnZXQiLCJnbG9iYWxQb2ludGVyIiwiY29udGFpbnNQb2ludCIsImlzRWRpdGluZyIsInN1YlRhcmdldCIsIm9ialRvQ2hlY2siLCJwb2ludGVyVG9Vc2UiLCJzdWJUYXJnZXRDaGVjayIsIl9hYnNvbHV0ZVBvaW50ZXIiLCJfcG9pbnRlciIsImJvdW5kc1dpZHRoIiwiYm91bmRzSGVpZ2h0IiwiY3NzU2NhbGUiLCJyZXRpbmFTY2FsaW5nIiwibG93ZXJDYW52YXNDbGFzcyIsIl9jb3B5Q2FudmFzU3R5bGUiLCJnZXRUb3BDb250ZXh0IiwiZnJvbUVsIiwidG9FbCIsImdldFNlbGVjdGlvbkNvbnRleHQiLCJnZXRTZWxlY3Rpb25FbGVtZW50IiwiZ2V0QWN0aXZlT2JqZWN0IiwiYWN0aXZlIiwiX2Rpc2NhcmRBY3RpdmVPYmplY3QiLCJfZmlyZVNlbGVjdGlvbkV2ZW50cyIsIm9sZE9iamVjdHMiLCJzb21ldGhpbmdDaGFuZ2VkIiwiYWRkZWQiLCJyZW1vdmVkIiwib2xkT2JqZWN0Iiwic2VsZWN0ZWQiLCJkZXNlbGVjdGVkIiwic2V0QWN0aXZlT2JqZWN0IiwiY3VycmVudEFjdGl2ZXMiLCJfc2V0QWN0aXZlT2JqZWN0Iiwib25TZWxlY3QiLCJvbkRlc2VsZWN0IiwiZGlzY2FyZEFjdGl2ZU9iamVjdCIsInJlbW92ZUxpc3RlbmVycyIsIl9yZW5kZXJDb250cm9scyIsIm9yaWdpbmFsUHJvcGVydGllcyIsIl9yZWFsaXplR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdCIsIl91bndpbmRHcm91cFRyYW5zZm9ybU9uT2JqZWN0IiwibGF5b3V0UHJvcHMiLCJvcmlnaW5hbFZhbHVlcyIsImNsZWFyQ29udGV4dFRvcCIsIlJJR0hUX0NMSUNLIiwiTUlERExFX0NMSUNLIiwiTEVGVF9DTElDSyIsImFkZEV2ZW50T3B0aW9ucyIsInBhc3NpdmUiLCJjaGVja0NsaWNrIiwiYnV0dG9uIiwibWFpblRvdWNoSWQiLCJfYmluZEV2ZW50cyIsImFkZE9yUmVtb3ZlIiwiX2dldEV2ZW50UHJlZml4IiwiZnVuY3RvciIsImV2ZW50anNGdW5jdG9yIiwiY2FudmFzRWxlbWVudCIsImV2ZW50VHlwZVByZWZpeCIsIl9vblJlc2l6ZSIsIl9vbk1vdXNlRG93biIsIl9vbk1vdXNlTW92ZSIsIl9vbk1vdXNlT3V0IiwiX29uTW91c2VFbnRlciIsIl9vbk1vdXNlV2hlZWwiLCJfb25Db250ZXh0TWVudSIsIl9vbkRvdWJsZUNsaWNrIiwiX29uRHJhZ092ZXIiLCJfb25EcmFnRW50ZXIiLCJfb25EcmFnTGVhdmUiLCJfb25Ecm9wIiwiX29uVG91Y2hTdGFydCIsImV2ZW50anMiLCJfb25HZXN0dXJlIiwiX29uRHJhZyIsIl9vbk9yaWVudGF0aW9uQ2hhbmdlIiwiX29uU2hha2UiLCJfb25Mb25nUHJlc3MiLCJfb25Nb3VzZVVwIiwiX29uVG91Y2hFbmQiLCJldmVudHNCb3VuZCIsIl9zaW1wbGVFdmVudEhhbmRsZXIiLCJzZWxmIiwiX19vblRyYW5zZm9ybUdlc3R1cmUiLCJfX29uRHJhZyIsIl9fb25Nb3VzZVdoZWVsIiwiX3RhcmdldCIsIl9fb25PcmllbnRhdGlvbkNoYW5nZSIsIl9fb25TaGFrZSIsIl9fb25Mb25nUHJlc3MiLCJwcmV2ZW50RGVmYXVsdCIsIl9maXJlRW50ZXJMZWF2ZUV2ZW50cyIsInN0b3BQcm9wYWdhdGlvbiIsIl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YSIsIl9oYW5kbGVFdmVudCIsIl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSIsImdldFBvaW50ZXJJZCIsImV2dCIsImlkZW50aWZpZXIiLCJwb2ludGVySWQiLCJpc1ByaW1hcnkiLCJ0b3VjaGVzIiwiX19vbk1vdXNlRG93biIsIl9fb25Nb3VzZVVwIiwiX3dpbGxBZGRNb3VzZURvd24iLCJfX29uTW91c2VNb3ZlIiwiX3Nob3VsZFJlbmRlciIsImdyb3VwU2VsZWN0b3IiLCJzaG91bGRSZW5kZXIiLCJpc0NsaWNrIiwiX29uTW91c2VVcEluRHJhd2luZ01vZGUiLCJfZmluYWxpemVDdXJyZW50VHJhbnNmb3JtIiwidGFyZ2V0V2FzQWN0aXZlIiwiX21heWJlR3JvdXBPYmplY3RzIiwiYWN0aXZlT24iLCJpc01vdmluZyIsIm9yaWdpbmFsQ29udHJvbCIsIm9yaWdpbmFsTW91c2VVcEhhbmRsZXIiLCJfc2V0Q3Vyc29yRnJvbUV2ZW50IiwiZXZlbnRUeXBlIiwic3ViVGFyZ2V0cyIsImFic29sdXRlUG9pbnRlciIsImN1cnJlbnRUYXJnZXQiLCJjdXJyZW50U3ViVGFyZ2V0cyIsIl9zY2FsaW5nIiwiaGFzU3RhdGVDaGFuZ2VkIiwiX2ZpcmUiLCJfb25Nb3VzZURvd25JbkRyYXdpbmdNb2RlIiwiX29uTW91c2VNb3ZlSW5EcmF3aW5nTW9kZSIsIl9wcmV2aW91c1BvaW50ZXIiLCJzaG91bGRHcm91cCIsIl9zaG91bGRHcm91cCIsIl9oYW5kbGVHcm91cGluZyIsInNhdmVTdGF0ZSIsIl9maXJlT3Zlck91dEV2ZW50cyIsIl90cmFuc2Zvcm1PYmplY3QiLCJmaXJlU3ludGhldGljSW5PdXRFdmVudHMiLCJvbGRUYXJnZXQiLCJldnRPdXQiLCJjYW52YXNFdnRPdXQiLCJldnRJbiIsImNhbnZhc0V2dEluIiwiX2RyYWdnZWRvdmVyVGFyZ2V0IiwiY29uZmlnIiwiaW5PcHQiLCJvdXRPcHQiLCJvdXRGaXJlcyIsImluRmlyZXMiLCJ0YXJnZXRDaGFuZ2VkIiwicHJldmlvdXNUYXJnZXQiLCJuZXh0VGFyZ2V0IiwicmVzZXQiLCJfcGVyZm9ybVRyYW5zZm9ybUFjdGlvbiIsImdldENvcm5lckN1cnNvciIsIl91cGRhdGVBY3RpdmVTZWxlY3Rpb24iLCJfY3JlYXRlQWN0aXZlU2VsZWN0aW9uIiwiY3VycmVudEFjdGl2ZU9iamVjdHMiLCJyZW1vdmVXaXRoVXBkYXRlIiwiYWRkV2l0aFVwZGF0ZSIsIl9jcmVhdGVHcm91cCIsImlzQWN0aXZlTG93ZXIiLCJncm91cE9iamVjdHMiLCJleGl0RWRpdGluZyIsIkFjdGl2ZVNlbGVjdGlvbiIsIl9ncm91cFNlbGVjdGVkT2JqZWN0cyIsIl9jb2xsZWN0T2JqZWN0cyIsImFHcm91cCIsImN1cnJlbnRPYmplY3QiLCJzZWxlY3Rpb25YMVkxIiwic2VsZWN0aW9uWDJZMiIsImFsbG93SW50ZXJzZWN0IiwiaW50ZXJzZWN0c1dpdGhSZWN0IiwiaXNDb250YWluZWRXaXRoaW5SZWN0IiwidG9DYW52YXNFbGVtZW50IiwiY3JvcHBpbmciLCJzY2FsZWRXaWR0aCIsInNjYWxlZEhlaWdodCIsIm9yaWdpbmFsV2lkdGgiLCJvcmlnaW5hbEhlaWdodCIsIm5ld1pvb20iLCJ2cCIsIm9yaWdpbmFsSW50ZXJhY3RpdmUiLCJuZXdWcCIsIm9yaWdpbmFsUmV0aW5hIiwib3JpZ2luYWxDb250ZXh0VG9wIiwibG9hZEZyb21KU09OIiwianNvbiIsInNlcmlhbGl6ZWQiLCJKU09OIiwiX2VubGl2ZW5PYmplY3RzIiwiX3NldEJnT3ZlcmxheSIsImVubGl2ZW5lZENhbnZhc0NsaXAiLCJfX3NldHVwQ2FudmFzIiwibG9hZGVkIiwiY2JJZkxvYWRlZCIsIl9fc2V0QmdPdmVybGF5IiwiZW5saXZlZE9iamVjdCIsIl90b0RhdGFVUkwiLCJfdG9EYXRhVVJMV2l0aE11bHRpcGxpZXIiLCJ0b0RhdGFVUkxXaXRoTXVsdGlwbGllciIsInN0cmluZ2lmeSIsImNsb25lV2l0aG91dERhdGEiLCJiYWNrZ3JvdW5kSW1hZ2VPcGFjaXR5IiwiYmFja2dyb3VuZEltYWdlU3RyZXRjaCIsIm9iamVjdENhY2hpbmciLCJBTElBU0lOR19MSU1JVCIsInRvdWNoQ29ybmVyU2l6ZSIsImJvcmRlckNvbG9yIiwiYm9yZGVyRGFzaEFycmF5IiwiY29ybmVyRGFzaEFycmF5Iiwic3Ryb2tlRGFzaE9mZnNldCIsImJvcmRlck9wYWNpdHlXaGVuTW92aW5nIiwiYm9yZGVyU2NhbGVGYWN0b3IiLCJtaW5TY2FsZUxpbWl0IiwiaGFzQ29udHJvbHMiLCJoYXNCb3JkZXJzIiwibG9ja01vdmVtZW50WCIsImxvY2tNb3ZlbWVudFkiLCJzdGF0ZWZ1bGxDYWNoZSIsIm5vU2NhbGVDYWNoZSIsImRpcnR5IiwicGFpbnRGaXJzdCIsInN0YXRlUHJvcGVydGllcyIsImNhY2hlUHJvcGVydGllcyIsImNvbG9yUHJvcGVydGllcyIsImFic29sdXRlUG9zaXRpb25lZCIsIl9jYWNoZVByb3BlcnRpZXMiLCJfdXBkYXRlQ2FjaGVDYW52YXMiLCJfbGltaXRDYWNoZVNpemUiLCJkaW1zIiwibGltaXRlZERpbXMiLCJjYXBwZWQiLCJfZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zIiwib2JqZWN0U2NhbGUiLCJnZXRUb3RhbE9iamVjdFNjYWxpbmciLCJuZWVkZWRYIiwibmVlZGVkWSIsInRhcmdldENhbnZhcyIsIm1pbkNhY2hlU2l6ZSIsImRyYXdpbmdXaWR0aCIsImRyYXdpbmdIZWlnaHQiLCJkaW1lbnNpb25zQ2hhbmdlZCIsImNhY2hlV2lkdGgiLCJjYWNoZUhlaWdodCIsInpvb21DaGFuZ2VkIiwic2hvdWxkUmVkcmF3IiwiYWRkaXRpb25hbFdpZHRoIiwiYWRkaXRpb25hbEhlaWdodCIsInNob3VsZFJlc2l6ZUNhbnZhcyIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0Iiwic2l6ZUdyb3dpbmciLCJzaXplU2hyaW5raW5nIiwiZ2V0SGVpZ2h0T2ZMaW5lIiwic2V0VHJhbnNmb3JtIiwibmVlZEZ1bGxUcmFuc2Zvcm0iLCJfcmVtb3ZlRGVmYXVsdFZhbHVlcyIsImdldE9iamVjdFNjYWxpbmciLCJyZXRpbmEiLCJnZXRPYmplY3RPcGFjaXR5Iiwic2hvdWxkQ29uc3RyYWluVmFsdWUiLCJpc0NoYW5nZWQiLCJncm91cE5lZWRzVXBkYXRlIiwiX2NvbnN0cmFpblNjYWxlIiwiaXNPbkFDYWNoZSIsInNldE9uR3JvdXAiLCJnZXRWaWV3cG9ydFRyYW5zZm9ybSIsImlzTm90VmlzaWJsZSIsImlzT25TY3JlZW4iLCJfc2V0dXBDb21wb3NpdGVPcGVyYXRpb24iLCJkcmF3U2VsZWN0aW9uQmFja2dyb3VuZCIsIl9zZXRPcGFjaXR5IiwiZHJhd0NhY2hlT25DYW52YXMiLCJfcmVtb3ZlQ2FjaGVDYW52YXMiLCJkcmF3T2JqZWN0IiwicHJvcGVydHlTZXQiLCJpc0NhY2hlRGlydHkiLCJoYXNTdHJva2UiLCJoYXNGaWxsIiwibmVlZHNJdHNPd25DYWNoZSIsIm93bkNhY2hpbmciLCJ3aWxsRHJhd1NoYWRvdyIsImRyYXdDbGlwUGF0aE9uQ2FjaGUiLCJvcmlnaW5hbEZpbGwiLCJvcmlnaW5hbFN0cm9rZSIsIl9zZXRDbGlwcGluZ1Byb3BlcnRpZXMiLCJfZHJhd0NsaXBQYXRoIiwic2tpcENhbnZhcyIsIl9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMiLCJfcmVtb3ZlU2hhZG93IiwiX3NldFN0cm9rZVN0eWxlcyIsImRlY2wiLCJsaW5lRGFzaE9mZnNldCIsIl9hcHBseVBhdHRlcm5Gb3JUcmFuc2Zvcm1lZEdyYWRpZW50IiwiX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtIiwiX3NldEZpbGxTdHlsZXMiLCJkYXNoQXJyYXkiLCJkcmF3Qm9yZGVycyIsImZvckFjdGl2ZVNlbGVjdGlvbiIsImRyYXdCb3JkZXJzSW5Hcm91cCIsInNjYWxpbmciLCJtdWx0WCIsIm11bHRZIiwiX3JlbmRlclBhaW50SW5PcmRlciIsIl9yZW5kZXJTdHJva2UiLCJfcmVuZGVyRmlsbCIsInBDYW52YXMiLCJwQ3R4IiwiX2ZpbmRDZW50ZXJGcm9tRWxlbWVudCIsIl9hc3NpZ25UcmFuc2Zvcm1NYXRyaXhQcm9wcyIsInByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zIiwiY3JvcFgiLCJjcm9wWSIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJvYmplY3RGb3JtIiwiX2Zyb21PYmplY3QiLCJjbG9uZUFzSW1hZ2UiLCJ1dGlscyIsIm9yaWdQYXJhbXMiLCJvcmlnaW5hbEdyb3VwIiwib3JpZ2luYWxTaGFkb3ciLCJ3aXRob3V0VHJhbnNmb3JtIiwid2l0aG91dFNoYWRvdyIsImJvdW5kaW5nUmVjdCIsImdldEJvdW5kaW5nUmVjdCIsInNoYWRvd09mZnNldCIsIm9yaWdpbmFsQ2FudmFzIiwiaXNUeXBlIiwiaW5jbHVkZXMiLCJzaG91bGRDZW50ZXJPcmlnaW4iLCJfc2V0T3JpZ2luVG9DZW50ZXIiLCJfcmVzZXRPcmlnaW4iLCJjZW50ZXJIIiwidmlld3BvcnRDZW50ZXJIIiwiY2VudGVyViIsInZpZXdwb3J0Q2VudGVyViIsInZpZXdwb3J0Q2VudGVyIiwiZ2V0TG9jYWxQb2ludGVyIiwicENsaWNrZWQiLCJvYmplY3RMZWZ0VG9wIiwiY3JlYXRlQWNjZXNzb3JzIiwiZXh0cmFQYXJhbSIsIm9yaWdpblhPZmZzZXQiLCJvcmlnaW5ZT2Zmc2V0IiwidHJhbnNsYXRlVG9HaXZlbk9yaWdpbiIsImZyb21PcmlnaW5YIiwiZnJvbU9yaWdpblkiLCJ0b09yaWdpblgiLCJ0b09yaWdpblkiLCJ0cmFuc2xhdGVUb0NlbnRlclBvaW50IiwibGVmdFRvcCIsImdldFBvaW50QnlPcmlnaW4iLCJhZGp1c3RQb3NpdGlvbiIsImh5cG90RnVsbCIsImdldFNjYWxlZFdpZHRoIiwieEZ1bGwiLCJ5RnVsbCIsIm9mZnNldEZyb20iLCJvZmZzZXRUbyIsIl9vcmlnaW5hbE9yaWdpblgiLCJfb3JpZ2luYWxPcmlnaW5ZIiwib3JpZ2luUG9pbnQiLCJhcnJheUZyb21Db29yZHMiLCJtdWx0aXBseU1hdHJpY2VzIiwib0Nvb3JkcyIsImFDb29yZHMiLCJsaW5lQ29vcmRzIiwib3duTWF0cml4Q2FjaGUiLCJtYXRyaXhDYWNoZSIsIl9nZXRDb29yZHMiLCJhYnNvbHV0ZSIsImNhbGN1bGF0ZSIsImNhbGNBQ29vcmRzIiwiY2FsY0xpbmVDb29yZHMiLCJnZXRDb29yZHMiLCJwb2ludFRMIiwicG9pbnRCUiIsImludGVyc2VjdGlvbiIsIm90aGVyIiwib3RoZXJDb29yZHMiLCJsaW5lcyIsIl9nZXRJbWFnZUxpbmVzIiwiX2ZpbmRDcm9zc1BvaW50cyIsIl9jb250YWluc0NlbnRlck9mQ2FudmFzIiwiaXNQYXJ0aWFsbHlPblNjcmVlbiIsImFsbFBvaW50c0FyZU91dHNpZGUiLCJldmVyeSIsInRvcGxpbmUiLCJyaWdodGxpbmUiLCJib3R0b21saW5lIiwibGVmdGxpbmUiLCJ4aSIsInhjb3VudCIsImlMaW5lIiwibGluZUtleSIsImdldFNjYWxlZEhlaWdodCIsInNjYWxlVG9XaWR0aCIsImJvdW5kaW5nUmVjdEZhY3RvciIsInNjYWxlVG9IZWlnaHQiLCJjb3NQIiwic2luUCIsImNvc1BTaW5QIiwiY29zUE1pbnVzU2luUCIsImNhbGNPQ29vcmRzIiwiX2NhbGNSb3RhdGVNYXRyaXgiLCJfY2FsY1RyYW5zbGF0ZU1hdHJpeCIsInN0YXJ0TWF0cml4IiwiX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zIiwiZm9yRWFjaENvbnRyb2wiLCJ3Iiwic2tpcENvcm5lcnMiLCJfc2V0Q29ybmVyQ29vcmRzIiwidHJhbnNmb3JtTWF0cml4S2V5Iiwic2VwIiwicHJlZml4IiwiY2FjaGUiLCJ0TWF0cml4Iiwibm9Ta2V3IiwiX2ZpbmFsaXplRGltZW5zaW9ucyIsImdldFN2Z0NvbG9yU3RyaW5nIiwiZ2V0U3ZnU3R5bGVzIiwic2tpcFNoYWRvdyIsImdldFN2Z0ZpbHRlciIsImdldFN2Z1NwYW5TdHlsZXMiLCJ1c2VXaGl0ZVNwYWNlIiwidGVybSIsInRleHREZWNvcmF0aW9uIiwiZ2V0U3ZnVGV4dERlY29yYXRpb24iLCJkZWNvcmF0aW9uIiwiZ2V0U3ZnQ29tbW9ucyIsImdldFN2Z1RyYW5zZm9ybSIsImZ1bGwiLCJzdmdUcmFuc2Zvcm0iLCJfc2V0U1ZHQmciLCJ0ZXh0QmdSZWN0cyIsIl9nZXRGaWxsQXR0cmlidXRlcyIsIl9jcmVhdGVCYXNlU1ZHTWFya3VwIiwiX3RvU1ZHIiwiX2NyZWF0ZUJhc2VDbGlwUGF0aFNWR01hcmt1cCIsIm9iamVjdE1hcmt1cCIsImNvbW1vblBpZWNlcyIsIm5vU3R5bGUiLCJzdHlsZUluZm8iLCJzaGFkb3dJbmZvIiwid2l0aFNoYWRvdyIsInZlY3RvckVmZmVjdCIsImFic29sdXRlQ2xpcFBhdGgiLCJjbGlwUGF0aE1hcmt1cCIsImFkZFBhaW50T3JkZXIiLCJvcmlnaW5hbFNldCIsInNhdmVQcm9wcyIsInByb3BzIiwidG1wT2JqIiwiX2lzRXF1YWwiLCJvcmlnVmFsdWUiLCJmaXJzdFBhc3MiLCJkYXNoZWRQcm9wZXJ0eVNldCIsImZvclRvdWNoIiwiaXNDb250cm9sVmlzaWJsZSIsInRvdWNoQ29ybmVyIiwiZm4iLCJjb250cm9sT2JqZWN0Iiwid2giLCJzaG91bGRTdHJva2UiLCJzZXRDb250cm9sVmlzaWJsZSIsInNldENvbnRyb2xzVmlzaWJpbGl0eSIsIkZYX0RVUkFUSU9OIiwiZnhDZW50ZXJPYmplY3RIIiwiY2FsbGJhY2tzIiwiZW1wdHkiLCJmeENlbnRlck9iamVjdFYiLCJmeFJlbW92ZSIsInByb3BzVG9BbmltYXRlIiwic2tpcENhbGxiYWNrcyIsIm91dCIsIl9hbmltYXRlIiwicHJvcFBhaXIiLCJwcm9wSXNDb2xvciIsInZhbHVlUHJvZ3Jlc3MiLCJ0aW1lUHJvZ3Jlc3MiLCJjb29yZFByb3BzIiwiTGluZSIsIl9zZXRXaWR0aEhlaWdodCIsIl9nZXRMZWZ0VG9PcmlnaW5YIiwiX2dldFRvcFRvT3JpZ2luWSIsIm1ha2VFZGdlVG9PcmlnaW5HZXR0ZXIiLCJheGlzMSIsImF4aXMyIiwiZGltZW5zaW9uIiwibmVhcmVzdCIsImZhcnRoZXN0IiwiY2FsY0xpbmVQb2ludHMiLCJvcmlnU3Ryb2tlU3R5bGUiLCJ4TXVsdCIsInlNdWx0IiwiQVRUUklCVVRFX05BTUVTIiwicGFyc2VkQXR0cmlidXRlcyIsIl9jYWxsYmFjayIsInByb3BlcnR5TmFtZXMiLCJvcmlnaW5WYWx1ZXMiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJzZXRSYWRpdXMiLCJzdmdTdHJpbmciLCJzdGFydFgiLCJzdGFydFkiLCJlbmRYIiwiZW5kWSIsImxhcmdlRmxhZyIsImdldFJhZGl1c1giLCJnZXRSYWRpdXNZIiwiaXNWYWxpZFJhZGl1cyIsIlRyaWFuZ2xlIiwid2lkdGhCeTIiLCJoZWlnaHRCeTIiLCJwaUJ5MiIsIkVsbGlwc2UiLCJnZXRSeCIsImdldFJ5IiwiX2luaXRSeFJ5IiwiaXNSb3VuZGVkIiwiYmV6aWVyQ3VydmVUbyIsIlBvbHlsaW5lIiwiZXhhY3RCb3VuZGluZ0JveCIsIl9zZXRQb3NpdGlvbkRpbWVuc2lvbnMiLCJfcHJvamVjdFN0cm9rZU9uUG9pbnRzIiwiY2FsY0RpbSIsIl9jYWxjRGltZW5zaW9ucyIsImNvcnJlY3RMZWZ0VG9wIiwiY29ycmVjdFNpemUiLCJmcm9tU1ZHIiwiZGlmZlgiLCJkaWZmWSIsImNvbW1vblJlbmRlciIsImZyb21FbGVtZW50R2VuZXJhdG9yIiwiX2NsYXNzIiwiUG9seWdvbiIsIl9zZXRQYXRoIiwiX3JlbmRlclBhdGhDb21tYW5kcyIsInN1YnBhdGhTdGFydFgiLCJzdWJwYXRoU3RhcnRZIiwiX2dldE9mZnNldFRyYW5zZm9ybSIsImRpZ2l0cyIsImFYIiwiYVkiLCJkZWx0YVgiLCJwYXRoVXJsIiwiZWxpdmVuZWRPYmplY3RzIiwidXNlU2V0T25Hcm91cCIsImlzQWxyZWFkeUdyb3VwZWQiLCJfY2FsY0JvdW5kcyIsIl91cGRhdGVPYmplY3RzQ29vcmRzIiwiX3VwZGF0ZU9iamVjdHNBQ29vcmRzIiwic2tpcENvbnRyb2xzIiwiX3VwZGF0ZU9iamVjdENvb3JkcyIsIm9iamVjdExlZnQiLCJvYmplY3RUb3AiLCJuZXN0ZWQiLCJfcmVzdG9yZU9iamVjdHNTdGF0ZSIsIl9pbmNsdWRlRGVmYXVsdFZhbHVlcyIsIm9ianNUb09iamVjdCIsIm9yaWdpbmFsRGVmYXVsdHMiLCJfb2JqIiwib3duQ2FjaGUiLCJncm91cE1hdHJpeCIsImRlc3Ryb3kiLCJ0b0FjdGl2ZVNlbGVjdGlvbiIsInVuZ3JvdXBPbkNhbnZhcyIsInNldE9iamVjdHNDb29yZHMiLCJvbmx5V2lkdGhIZWlnaHQiLCJpTGVuIiwiakxlbiIsIl9nZXRCb3VuZHMiLCJtaW5YWSIsIm1heFhZIiwidG9Hcm91cCIsIm5ld0dyb3VwIiwiY2hpbGRyZW5PdmVycmlkZSIsInNyY0Zyb21BdHRyaWJ1dGUiLCJfbGFzdFNjYWxlWCIsIl9sYXN0U2NhbGVZIiwiX2ZpbHRlclNjYWxpbmdYIiwiX2ZpbHRlclNjYWxpbmdZIiwibWluaW11bVNjYWxlVHJpZ2dlciIsImNhY2hlS2V5IiwiaW1hZ2VTbW9vdGhpbmciLCJmaWx0ZXJzIiwiX2luaXRFbGVtZW50IiwiX2VsZW1lbnQiLCJzZXRFbGVtZW50IiwicmVtb3ZlVGV4dHVyZSIsIl9pbml0Q29uZmlnIiwiYXBwbHlGaWx0ZXJzIiwicmVzaXplRmlsdGVyIiwiYXBwbHlSZXNpemVGaWx0ZXJzIiwiYmFja2VuZCIsImZpbHRlckJhY2tlbmQiLCJldmljdENhY2hlc0ZvcktleSIsImdldENyb3NzT3JpZ2luIiwiZ2V0T3JpZ2luYWxTaXplIiwiX3N0cm9rZSIsImZpbHRlck9iaiIsImdldFNyYyIsImhhc0Nyb3AiLCJpbWFnZU1hcmt1cCIsInN0cm9rZVN2ZyIsImltYWdlUmVuZGVyaW5nIiwiZ2V0U3ZnU3JjIiwib3JpZ0ZpbGwiLCJmaWx0ZXJlZCIsInNldFNyYyIsIm1pbmltdW1TY2FsZSIsImVsZW1lbnRUb0ZpbHRlciIsIl9maWx0ZXJlZEVsIiwic291cmNlV2lkdGgiLCJzb3VyY2VIZWlnaHQiLCJpc05ldXRyYWxTdGF0ZSIsImltZ0VsZW1lbnQiLCJfbmVlZHNSZXNpemUiLCJlbGVtZW50VG9EcmF3IiwiZWxXaWR0aCIsImVsSGVpZ2h0Iiwic1giLCJzWSIsInNXIiwic0giLCJtYXhEZXN0VyIsIm1heERlc3RIIiwiX3Jlc2V0V2lkdGhIZWlnaHQiLCJDU1NfQ0FOVkFTIiwiX2luaXRGaWx0ZXJzIiwicEFSIiwicldpZHRoIiwickhlaWdodCIsInBXaWR0aCIsInBIZWlnaHQiLCJfb2JqZWN0IiwicmVzaXplRmlsdGVycyIsImZyb21VUkwiLCJpbWdPcHRpb25zIiwiX2dldEFuZ2xlVmFsdWVGb3JTdHJhaWdodGVuIiwic3RyYWlnaHRlbiIsImZ4U3RyYWlnaHRlbiIsInN0cmFpZ2h0ZW5PYmplY3QiLCJmeFN0cmFpZ2h0ZW5PYmplY3QiLCJ0ZXN0UHJlY2lzaW9uIiwiZ2wiLCJwcmVjaXNpb24iLCJmcmFnbWVudFNvdXJjZSIsImZyYWdtZW50U2hhZGVyIiwiY3JlYXRlU2hhZGVyIiwiRlJBR01FTlRfU0hBREVSIiwic2hhZGVyU291cmNlIiwiY29tcGlsZVNoYWRlciIsImdldFNoYWRlclBhcmFtZXRlciIsIkNPTVBJTEVfU1RBVFVTIiwiaXNTdXBwb3J0ZWQiLCJnZXRQYXJhbWV0ZXIiLCJNQVhfVEVYVFVSRV9TSVpFIiwicHJlY2lzaW9ucyIsIndlYkdsUHJlY2lzaW9uIiwic2V0dXBHTENvbnRleHQiLCJjYXB0dXJlR1BVSW5mbyIsImNyZWF0ZVdlYkdMQ2FudmFzIiwiYVBvc2l0aW9uIiwiRmxvYXQzMkFycmF5IiwiY2hvb3NlRmFzdGVzdENvcHlHTFRvMkRNZXRob2QiLCJjYW5NZWFzdXJlUGVyZiIsInBlcmZvcm1hbmNlIiwiY2FuVXNlSW1hZ2VEYXRhIiwiSW1hZ2VEYXRhIiwiY2FuVXNlQXJyYXlCdWZmZXIiLCJBcnJheUJ1ZmZlciIsImNhblVzZVVpbnQ4Q2xhbXBlZCIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiaW1hZ2VCdWZmZXIiLCJjb3B5R0xUbzJEIiwiY29weUdMVG8yRFB1dEltYWdlRGF0YSIsInRlc3RDb250ZXh0IiwiZGVzdGluYXRpb25XaWR0aCIsImRlc3RpbmF0aW9uSGVpZ2h0Iiwic3RhcnRUaW1lIiwiZHJhd0ltYWdlVGltZSIsInB1dEltYWdlRGF0YVRpbWUiLCJub3ciLCJjb3B5R0xUbzJERHJhd0ltYWdlIiwiZ2xPcHRpb25zIiwicHJlbXVsdGlwbGllZEFscGhhIiwiZGVwdGgiLCJzdGVuY2lsIiwiYW50aWFsaWFzIiwiY2xlYXJDb2xvciIsImNhY2hlZFRleHR1cmUiLCJnZXRDYWNoZWRUZXh0dXJlIiwicGlwZWxpbmVTdGF0ZSIsInNvdXJjZVRleHR1cmUiLCJjcmVhdGVUZXh0dXJlIiwidGFyZ2V0VGV4dHVyZSIsIm9yaWdpbmFsVGV4dHVyZSIsInBhc3NlcyIsIndlYmdsIiwicHJvZ3JhbUNhY2hlIiwicGFzcyIsInRlbXBGYm8iLCJjcmVhdGVGcmFtZWJ1ZmZlciIsImJpbmRGcmFtZWJ1ZmZlciIsIkZSQU1FQlVGRkVSIiwiYXBwbHlUbyIsInJlc2l6ZUNhbnZhc0lmTmVlZGVkIiwiYmluZFRleHR1cmUiLCJURVhUVVJFXzJEIiwiZGVsZXRlVGV4dHVyZSIsImRlbGV0ZUZyYW1lYnVmZmVyIiwiY2xlYXJXZWJHTENhY2hlcyIsInRleHR1cmVDYWNoZSIsInRleHR1cmVJbWFnZVNvdXJjZSIsImZpbHRlclR5cGUiLCJ0ZXh0dXJlIiwidGV4UGFyYW1ldGVyaSIsIlRFWFRVUkVfTUFHX0ZJTFRFUiIsIk5FQVJFU1QiLCJURVhUVVJFX01JTl9GSUxURVIiLCJURVhUVVJFX1dSQVBfUyIsIkNMQU1QX1RPX0VER0UiLCJURVhUVVJFX1dSQVBfVCIsInRleEltYWdlMkQiLCJSR0JBIiwiVU5TSUdORURfQllURSIsInVuaXF1ZUlkIiwiZ3B1SW5mbyIsInJlbmRlcmVyIiwidmVuZG9yIiwiZXh0IiwiZ2V0RXh0ZW5zaW9uIiwiVU5NQVNLRURfUkVOREVSRVJfV0VCR0wiLCJVTk1BU0tFRF9WRU5ET1JfV0VCR0wiLCJkV2lkdGgiLCJkSGVpZ2h0IiwiZ2xDYW52YXMiLCJzb3VyY2VZIiwibnVtQnl0ZXMiLCJ1OCIsIlVpbnQ4QXJyYXkiLCJ1OENsYW1wZWQiLCJyZWFkUGl4ZWxzIiwiaW1nRGF0YSIsInB1dEltYWdlRGF0YSIsInNvdXJjZUVsZW1lbnQiLCJvcmlnaW5hbEltYWdlRGF0YSIsIm9yaWdpbmFsRWwiLCJCYXNlRmlsdGVyIiwidmVydGV4U291cmNlIiwiY3JlYXRlUHJvZ3JhbSIsInZlcnRleFNoYWRlciIsIlZFUlRFWF9TSEFERVIiLCJnZXRTaGFkZXJJbmZvTG9nIiwicHJvZ3JhbSIsImF0dGFjaFNoYWRlciIsImxpbmtQcm9ncmFtIiwiZ2V0UHJvZ3JhbVBhcmFtZXRlciIsIkxJTktfU1RBVFVTIiwiZ2V0UHJvZ3JhbUluZm9Mb2ciLCJhdHRyaWJ1dGVMb2NhdGlvbnMiLCJnZXRBdHRyaWJ1dGVMb2NhdGlvbnMiLCJ1bmlmb3JtTG9jYXRpb25zIiwiZ2V0VW5pZm9ybUxvY2F0aW9ucyIsInVTdGVwVyIsImdldFVuaWZvcm1Mb2NhdGlvbiIsInVTdGVwSCIsImdldEF0dHJpYkxvY2F0aW9uIiwic2VuZEF0dHJpYnV0ZURhdGEiLCJhUG9zaXRpb25EYXRhIiwiYXR0cmlidXRlTG9jYXRpb24iLCJidWZmZXIiLCJjcmVhdGVCdWZmZXIiLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyIiwiRkxPQVQiLCJidWZmZXJEYXRhIiwiU1RBVElDX0RSQVciLCJfc2V0dXBGcmFtZUJ1ZmZlciIsImZyYW1lYnVmZmVyVGV4dHVyZTJEIiwiQ09MT1JfQVRUQUNITUVOVDAiLCJfc3dhcFRleHR1cmVzIiwibWFpbiIsIm1haW5QYXJhbWV0ZXIiLCJhcHBseVRvV2ViR0wiLCJhcHBseVRvMmQiLCJyZXRyaWV2ZVNoYWRlciIsInNoYWRlciIsInVzZVByb2dyYW0iLCJ1bmlmb3JtMWYiLCJzZW5kVW5pZm9ybURhdGEiLCJ2aWV3cG9ydCIsImRyYXdBcnJheXMiLCJUUklBTkdMRV9TVFJJUCIsImJpbmRBZGRpdGlvbmFsVGV4dHVyZSIsInRleHR1cmVVbml0IiwiYWN0aXZlVGV4dHVyZSIsIlRFWFRVUkUwIiwidW5iaW5kQWRkaXRpb25hbFRleHR1cmUiLCJnZXRNYWluUGFyYW1ldGVyIiwic2V0TWFpblBhcmFtZXRlciIsImNyZWF0ZUhlbHBMYXllciIsImhlbHBMYXllciIsIm1haW5QIiwiQ29sb3JNYXRyaXgiLCJjb2xvcnNPbmx5IiwidUNvbG9yTWF0cml4IiwidUNvbnN0YW50cyIsImNvbnN0YW50cyIsInVuaWZvcm1NYXRyaXg0ZnYiLCJ1bmlmb3JtNGZ2IiwiQnJpZ2h0bmVzcyIsImJyaWdodG5lc3MiLCJ1QnJpZ2h0bmVzcyIsIkNvbnZvbHV0ZSIsIm9wYXF1ZSIsIkNvbnZvbHV0ZV8zXzEiLCJDb252b2x1dGVfM18wIiwiQ29udm9sdXRlXzVfMSIsIkNvbnZvbHV0ZV81XzAiLCJDb252b2x1dGVfN18xIiwiQ29udm9sdXRlXzdfMCIsIkNvbnZvbHV0ZV85XzEiLCJDb252b2x1dGVfOV8wIiwid2VpZ2h0cyIsInNpZGUiLCJoYWxmU2lkZSIsInN3Iiwic2giLCJvdXRwdXQiLCJjcmVhdGVJbWFnZURhdGEiLCJkc3QiLCJhbHBoYUZhYyIsImRzdE9mZiIsInNjeCIsInNjeSIsInNyY09mZiIsInd0IiwidU1hdHJpeCIsInVPcGFxdWUiLCJ1SGFsZlNpemUiLCJ1U2l6ZSIsInVuaWZvcm0xZnYiLCJHcmF5c2NhbGUiLCJsaWdodG5lc3MiLCJsdW1pbm9zaXR5IiwibW9kZSIsInVNb2RlIiwidW5pZm9ybTFpIiwiSW52ZXJ0IiwiaW52ZXJ0IiwidUludmVydCIsIk5vaXNlIiwibm9pc2UiLCJyYW5kIiwidU5vaXNlIiwidVNlZWQiLCJQaXhlbGF0ZSIsImJsb2Nrc2l6ZSIsIl9pIiwiX2oiLCJfaUxlbiIsIl9qTGVuIiwidUJsb2Nrc2l6ZSIsIlJlbW92ZUNvbG9yIiwidXNlQWxwaGEiLCJsb3dDIiwiaGlnaEMiLCJ1TG93IiwidUhpZ2giLCJCcm93bmllIiwiVmludGFnZSIsIktvZGFjaHJvbWUiLCJUZWNobmljb2xvciIsIlBvbGFyb2lkIiwiU2VwaWEiLCJCbGFja1doaXRlIiwiQmxlbmRDb2xvciIsInNjcmVlbiIsImRpZmYiLCJsaWdodGVuIiwiZGFya2VuIiwiZXhjbHVzaW9uIiwidGludCIsImJ1aWxkU291cmNlIiwidGciLCJhbHBoYTEiLCJ1Q29sb3IiLCJCbGVuZEltYWdlIiwibWFzayIsIlRFWFRVUkUxIiwiY2FsY3VsYXRlTWF0cml4IiwiY2FudmFzMSIsImJsZW5kRGF0YSIsImJsZW5kSW1hZ2UiLCJ1VHJhbnNmb3JtTWF0cml4IiwidUltYWdlIiwidW5pZm9ybU1hdHJpeDNmdiIsIlJlc2l6ZSIsInJlc2l6ZVR5cGUiLCJsYW5jem9zTG9iZXMiLCJ1RGVsdGEiLCJ1VGFwcyIsInVuaWZvcm0yZnYiLCJob3Jpem9udGFsIiwidGFwcyIsImZpbHRlcldpbmRvdyIsImdldEZpbHRlcldpbmRvdyIsImdlbmVyYXRlU2hhZGVyIiwidGVtcFNjYWxlIiwiZ2V0VGFwcyIsImxvYmVGdW5jdGlvbiIsImxhbmN6b3NDcmVhdGUiLCJvZmZzZXRzIiwiZnJhZ21lbnRTb3VyY2VUT1AiLCJkVyIsImRIIiwibG9iZXMiLCJ4eCIsInJjcFNjYWxlWCIsInJjcFNjYWxlWSIsIm9XIiwib0giLCJuZXdEYXRhIiwic2xpY2VCeVR3byIsImhlcm1pdGVGYXN0UmVzaXplIiwiYmlsaW5lYXJGaWx0ZXJpbmciLCJsYW5jem9zUmVzaXplIiwibXVsdCIsImRvbmVXIiwiZG9uZUgiLCJzdGVwVyIsInN0ZXBIIiwidG1wQ2FudmFzIiwiZFgiLCJkWSIsInByb2Nlc3MiLCJ1Iiwid2VpZ2h0IiwiZlgiLCJmWSIsInJhdGlvWCIsImljZW50ZXIiLCJyYXRpb1kiLCJyYW5nZTJYIiwiY2FjaGVMYW5jIiwicmFuZ2UyWSIsImxhbmN6b3MiLCJyY3BSYXRpb1giLCJyY3BSYXRpb1kiLCJzcmNEYXRhIiwiZGVzdERhdGEiLCJkZXN0SW1nIiwieERpZmYiLCJ5RGlmZiIsImNobmwiLCJvcmlnUGl4IiwidzQiLCJwaXhlbHMiLCJkZXN0SW1hZ2UiLCJkZXN0UGl4ZWxzIiwicmF0aW9XIiwicmF0aW9IIiwicmF0aW9XSGFsZiIsInJhdGlvSEhhbGYiLCJpbWcyIiwiZGF0YTIiLCJ3ZWlnaHRzQWxwaGEiLCJneFIiLCJneEciLCJneEIiLCJneEEiLCJ5eSIsIncwIiwiQ29udHJhc3QiLCJjb250cmFzdCIsImNvbnRyYXN0RiIsInVDb250cmFzdCIsIlNhdHVyYXRpb24iLCJzYXR1cmF0aW9uIiwiYWRqdXN0IiwidVNhdHVyYXRpb24iLCJWaWJyYW5jZSIsInZpYnJhbmNlIiwiYXZnIiwiYW10IiwidVZpYnJhbmNlIiwiQmx1ciIsImFzcGVjdFJhdGlvIiwic2ltcGxlQmx1ciIsImNhbnZhczIiLCJibHVyTGF5ZXIxIiwiYmx1ckxheWVyMiIsImN0eDEiLCJjdHgyIiwiblNhbXBsZXMiLCJwZXJjZW50IiwibmV3SW1hZ2VEYXRhIiwiZGVsdGEiLCJjaG9vc2VSaWdodERlbHRhIiwiYmx1clNjYWxlIiwiR2FtbWEiLCJnYW1tYSIsInJJbnYiLCJnSW52IiwiYkludiIsInJWYWxzIiwiZ1ZhbHMiLCJiVmFscyIsInVHYW1tYSIsInVuaWZvcm0zZnYiLCJDb21wb3NlZCIsInN1YkZpbHRlcnMiLCJIdWVSb3RhdGlvbiIsInJvdGF0aW9uIiwicmFkIiwiYVRoaXJkIiwiYVRoaXJkU3F0U2luIiwiT25lTWludXNDb3MiLCJhZGRpdGlvbmFsUHJvcHMiLCJfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMiLCJfcmVOZXdsaW5lIiwiX3JlU3BhY2VzQW5kVGFicyIsIl9yZVNwYWNlQW5kVGFiIiwiX3JlV29yZHMiLCJ0ZXh0QWxpZ24iLCJzdXBlcnNjcmlwdCIsImJhc2VsaW5lIiwic3Vic2NyaXB0IiwicGF0aFN0YXJ0T2Zmc2V0IiwicGF0aFNpZGUiLCJwYXRoQWxpZ24iLCJfZm9udFNpemVGcmFjdGlvbiIsIl9mb250U2l6ZU11bHQiLCJjaGFyU3BhY2luZyIsIl9tZWFzdXJpbmdDb250ZXh0IiwiZGlyZWN0aW9uIiwiX3N0eWxlUHJvcGVydGllcyIsIl9fY2hhckJvdW5kcyIsIkNBQ0hFX0ZPTlRfU0laRSIsIk1JTl9URVhUX1dJRFRIIiwiX19za2lwRGltZW5zaW9uIiwic2V0UGF0aEluZm8iLCJpbml0RGltZW5zaW9ucyIsInNlZ21lbnRzSW5mbyIsImdldE1lYXN1cmluZ0NvbnRleHQiLCJfc3BsaXRUZXh0IiwibmV3TGluZXMiLCJfc3BsaXRUZXh0SW50b0xpbmVzIiwiX3RleHRMaW5lcyIsImdyYXBoZW1lTGluZXMiLCJfdW53cmFwcGVkVGV4dExpbmVzIiwiX3Vud3JhcHBlZExpbmVzIiwiX3RleHQiLCJncmFwaGVtZVRleHQiLCJfY2xlYXJDYWNoZSIsImNhbGNUZXh0V2lkdGgiLCJjdXJzb3JXaWR0aCIsImNhbGNUZXh0SGVpZ2h0IiwiZW5sYXJnZVNwYWNlcyIsImRpZmZTcGFjZSIsImN1cnJlbnRMaW5lV2lkdGgiLCJudW1iZXJPZlNwYWNlcyIsImFjY3VtdWxhdGVkU3BhY2UiLCJsaW5lIiwiY2hhckJvdW5kIiwic3BhY2VzIiwiaXNFbmRPZldyYXBwaW5nIiwiZ2V0TGluZVdpZHRoIiwia2VybmVkV2lkdGgiLCJsaW5lSW5kZXgiLCJtaXNzaW5nTmV3bGluZU9mZnNldCIsIl9zZXRUZXh0U3R5bGVzIiwiX3JlbmRlclRleHRMaW5lc0JhY2tncm91bmQiLCJfcmVuZGVyVGV4dERlY29yYXRpb24iLCJfcmVuZGVyVGV4dCIsIl9yZW5kZXJUZXh0U3Ryb2tlIiwiX3JlbmRlclRleHRGaWxsIiwiY2hhclN0eWxlIiwiZm9yTWVhc3VyaW5nIiwidGV4dEJhc2VsaW5lIiwiX2dldEZvbnREZWNsYXJhdGlvbiIsIm1heFdpZHRoIiwiX3JlbmRlclRleHRMaW5lIiwiX3JlbmRlckNoYXJzIiwic3R5bGVIYXMiLCJoZWlnaHRPZkxpbmUiLCJsaW5lTGVmdE9mZnNldCIsImxhc3RDb2xvciIsImxlZnRPZmZzZXQiLCJfZ2V0TGVmdE9mZnNldCIsImxpbmVUb3BPZmZzZXQiLCJfZ2V0VG9wT2Zmc2V0IiwiYm94U3RhcnQiLCJib3hXaWR0aCIsImNoYXJCb3giLCJjdXJyZW50Q29sb3IiLCJkcmF3U3RhcnQiLCJfZ2V0TGluZUxlZnRPZmZzZXQiLCJnZXRWYWx1ZU9mUHJvcGVydHlBdCIsInJlbmRlckxlZnQiLCJnZXRGb250Q2FjaGUiLCJjYWNoZVByb3AiLCJfbWVhc3VyZUNoYXIiLCJwcmV2aW91c0NoYXIiLCJwcmV2Q2hhclN0eWxlIiwiZm9udENhY2hlIiwiZm9udERlY2xhcmF0aW9uIiwicHJldmlvdXNGb250RGVjbGFyYXRpb24iLCJjb3VwbGUiLCJzdHlsZXNBcmVFcXVhbCIsImNvdXBsZVdpZHRoIiwicHJldmlvdXNXaWR0aCIsImZvbnRNdWx0aXBsaWVyIiwibWVhc3VyZVRleHQiLCJnZXRIZWlnaHRPZkNoYXIiLCJtZWFzdXJlTGluZSIsImxpbmVJbmZvIiwiX21lYXN1cmVMaW5lIiwiX2dldFdpZHRoT2ZDaGFyU3BhY2luZyIsImdyYXBoZW1lIiwicHJldkdyYXBoZW1lIiwiZ3JhcGhlbWVJbmZvIiwibnVtT2ZTcGFjZXMiLCJsaW5lQm91bmRzIiwicG9zaXRpb25JblBhdGgiLCJzdGFydGluZ1BvaW50IiwidG90YWxQYXRoTGVuZ3RoIiwiX2dldEdyYXBoZW1lQm94IiwiX3NldEdyYXBoZW1lT25QYXRoIiwiY2VudGVyUG9zaXRpb24iLCJza2lwTGVmdCIsImdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbiIsInByZXZpb3VzQm94IiwiX19saW5lSGVpZ2h0cyIsIm1heEhlaWdodCIsIl9yZW5kZXJUZXh0Q29tbW9uIiwibGluZUhlaWdodHMiLCJpc0VtcHR5U3R5bGVzIiwiaXNKdXN0aWZ5IiwiYWN0dWFsU3R5bGUiLCJuZXh0U3R5bGUiLCJjaGFyc1RvUmVuZGVyIiwidGltZVRvUmVuZGVyIiwic2hvcnRDdXQiLCJpc0x0ciIsImRyYXdpbmdMZWZ0IiwiY3VycmVudERpcmVjdGlvbiIsIl9yZW5kZXJDaGFyIiwiX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtVGV4dCIsImhhbmRsZUZpbGxlciIsIl9nZXRTdHlsZURlY2xhcmF0aW9uIiwiZnVsbERlY2wiLCJzaG91bGRGaWxsIiwiZmlsbE9mZnNldHMiLCJzdHJva2VPZmZzZXRzIiwiZmlsbFRleHQiLCJzdHJva2VUZXh0Iiwic2V0U3VwZXJzY3JpcHQiLCJfc2V0U2NyaXB0Iiwic2V0U3Vic2NyaXB0Iiwic2NoZW1hIiwibG9jIiwiZ2V0MkRDdXJzb3JMb2NhdGlvbiIsInNldFNlbGVjdGlvblN0eWxlcyIsImxpbmVEaWZmIiwiX19saW5lV2lkdGhzIiwiX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUiLCJzaG91bGRDbGVhciIsIl9mb3JjZUNsZWFyQ2FjaGUiLCJfc2l6ZSIsIl9keSIsImxhc3REZWNvcmF0aW9uIiwidG9wT2Zmc2V0IiwiY3VycmVudERlY29yYXRpb24iLCJjdXJyZW50RmlsbCIsImxhc3RGaWxsIiwic3R5bGVPYmplY3QiLCJmYW1pbHkiLCJmb250SXNHZW5lcmljIiwiZ2VuZXJpY0ZvbnRzIiwibmV3TGluZSIsIm5ld1RleHQiLCJhbGxQcm9wZXJ0aWVzIiwibmVlZHNEaW1zIiwiaXNBZGRpbmdQYXRoIiwiX2tleSIsInBhcnNlZEFuY2hvciIsInRleHRBbmNob3IiLCJvcmlnaW5hbFN0cm9rZVdpZHRoIiwidGV4dEhlaWdodFNjYWxlRmFjdG9yIiwibGluZUhlaWdodERpZmYiLCJzY2FsZWREaWZmIiwidGV4dEhlaWdodCIsIm9mZlgiLCJvYmplY3RDb3B5IiwidGV4dEluc3RhbmNlIiwicGF0aEluc3RhbmNlIiwicDMiLCJjbGVhblN0eWxlIiwic3R5bGVzQ291bnQiLCJsZXR0ZXJDb3VudCIsInN0eWxlUHJvcGVydHlWYWx1ZSIsImFsbFN0eWxlT2JqZWN0UHJvcGVydGllc01hdGNoIiwiZ3JhcGhlbWVDb3VudCIsInN0eWxlUHJvcGVydHlIYXNCZWVuU2V0IiwicmVtb3ZlU3R5bGUiLCJsaW5lTnVtIiwiY2hhck51bSIsIl9leHRlbmRTdHlsZXMiLCJfZ2V0TGluZVN0eWxlIiwiX3NldExpbmVTdHlsZSIsIl9zZXRTdHlsZURlY2xhcmF0aW9uIiwic2VsZWN0aW9uU3RhcnQiLCJza2lwV3JhcHBpbmciLCJnZXRTZWxlY3Rpb25TdHlsZXMiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJzZWxlY3Rpb25FbmQiLCJnZXRTdHlsZUF0UG9zaXRpb24iLCJsaW5lU3R5bGUiLCJfZGVsZXRlU3R5bGVEZWNsYXJhdGlvbiIsIl9kZWxldGVMaW5lU3R5bGUiLCJwYXJzZURlY29yYXRpb24iLCJJVGV4dCIsImVkaXRhYmxlIiwiZWRpdGluZ0JvcmRlckNvbG9yIiwiY3Vyc29yQ29sb3IiLCJjdXJzb3JEZWxheSIsImN1cnNvckR1cmF0aW9uIiwiY2FjaGluZyIsImhpZGRlblRleHRhcmVhQ29udGFpbmVyIiwiX3JlU3BhY2UiLCJfY3VycmVudEN1cnNvck9wYWNpdHkiLCJfc2VsZWN0aW9uRGlyZWN0aW9uIiwiX2Fib3J0Q3Vyc29yQW5pbWF0aW9uIiwiX193aWR0aE9mU3BhY2UiLCJpbkNvbXBvc2l0aW9uTW9kZSIsImluaXRCZWhhdmlvciIsInNldFNlbGVjdGlvblN0YXJ0IiwiX3VwZGF0ZUFuZEZpcmUiLCJzZXRTZWxlY3Rpb25FbmQiLCJfZmlyZVNlbGVjdGlvbkNoYW5nZWQiLCJfdXBkYXRlVGV4dGFyZWEiLCJpbml0RGVsYXllZEN1cnNvciIsImN1cnNvck9mZnNldENhY2hlIiwicmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24iLCJza2lwUmVzdG9yZSIsIl9jbGVhclRleHRBcmVhIiwiYm91bmRhcmllcyIsIl9nZXRDdXJzb3JCb3VuZGFyaWVzIiwicmVuZGVyQ3Vyc29yIiwicmVuZGVyU2VsZWN0aW9uIiwiX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzIiwiY3Vyc29yUG9zaXRpb24iLCJib3VuZCIsImN1cnNvckxvY2F0aW9uIiwiY2hhckhlaWdodCIsIl9faXNNb3VzZWRvd24iLCJoaWRkZW5UZXh0YXJlYSIsInN0YXJ0TGluZSIsImVuZExpbmUiLCJzdGFydENoYXIiLCJlbmRDaGFyIiwibGluZU9mZnNldCIsInJlYWxMaW5lSGVpZ2h0IiwiYm94RW5kIiwiZHJhd1dpZHRoIiwiZHJhd0hlaWdodCIsImV4dHJhVG9wIiwiY29tcG9zaXRpb25Db2xvciIsImdldEN1cnJlbnRDaGFyRm9udFNpemUiLCJjcCIsIl9nZXRDdXJyZW50Q2hhckluZGV4IiwiZ2V0Q3VycmVudENoYXJDb2xvciIsIm9iakNvcHkiLCJpbml0QWRkZWRIYW5kbGVyIiwiaW5pdFJlbW92ZWRIYW5kbGVyIiwiaW5pdEN1cnNvclNlbGVjdGlvbkhhbmRsZXJzIiwiaW5pdERvdWJsZUNsaWNrU2ltdWxhdGlvbiIsIm1vdXNlTW92ZUhhbmRsZXIiLCJfaW5pdENhbnZhc0hhbmRsZXJzIiwiX3JlbW92ZUNhbnZhc0hhbmRsZXJzIiwiX3RpY2siLCJfY3VycmVudFRpY2tTdGF0ZSIsIl9hbmltYXRlQ3Vyc29yIiwidGFyZ2V0T3BhY2l0eSIsImNvbXBsZXRlTWV0aG9kIiwidGlja1N0YXRlIiwiaXNBYm9ydGVkIiwiX29uVGlja0NvbXBsZXRlIiwiX2N1cnNvclRpbWVvdXQxIiwiX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZSIsInJlc3RhcnQiLCJkZWxheSIsImFib3J0Q3Vyc29yQW5pbWF0aW9uIiwiX2N1cnNvclRpbWVvdXQyIiwic2VsZWN0QWxsIiwiZ2V0U2VsZWN0ZWRUZXh0IiwiZmluZFdvcmRCb3VuZGFyeUxlZnQiLCJzdGFydEZyb20iLCJmaW5kV29yZEJvdW5kYXJ5UmlnaHQiLCJmaW5kTGluZUJvdW5kYXJ5TGVmdCIsImZpbmRMaW5lQm91bmRhcnlSaWdodCIsInNlYXJjaFdvcmRCb3VuZGFyeSIsInNlbGVjdFdvcmQiLCJuZXdTZWxlY3Rpb25TdGFydCIsIm5ld1NlbGVjdGlvbkVuZCIsInNlbGVjdExpbmUiLCJlbnRlckVkaXRpbmciLCJleGl0RWRpdGluZ09uT3RoZXJzIiwiaW5pdEhpZGRlblRleHRhcmVhIiwiZm9jdXMiLCJfc2F2ZUVkaXRpbmdQcm9wcyIsIl9zZXRFZGl0aW5nUHJvcHMiLCJfdGV4dEJlZm9yZUVkaXQiLCJpbml0TW91c2VNb3ZlSGFuZGxlciIsImFjdGl2ZUVsZW1lbnQiLCJnZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyIiwiY3VycmVudFN0YXJ0IiwiY3VycmVudEVuZCIsIl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93biIsInJlc3RhcnRDdXJzb3JJZk5lZWRlZCIsImZyb21TdHJpbmdUb0dyYXBoZW1lU2VsZWN0aW9uIiwic21hbGxlclRleHRTdGFydCIsImdyYXBoZW1lU3RhcnQiLCJzbWFsbGVyVGV4dEVuZCIsImdyYXBoZW1lRW5kIiwiZnJvbUdyYXBoZW1lVG9TdHJpbmdTZWxlY3Rpb24iLCJuZXdTZWxlY3Rpb24iLCJ1cGRhdGVUZXh0YXJlYVBvc2l0aW9uIiwidXBkYXRlRnJvbVRleHRBcmVhIiwiX2NhbGNUZXh0YXJlYVBvc2l0aW9uIiwiZGVzaXJlZFBvc2l0aW9uIiwiY29tcG9zaXRpb25TdGFydCIsInVwcGVyQ2FudmFzIiwidXBwZXJDYW52YXNXaWR0aCIsInVwcGVyQ2FudmFzSGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJfc2F2ZWRQcm9wcyIsIl9yZXN0b3JlRWRpdGluZ1Byb3BzIiwiaXNUZXh0Q2hhbmdlZCIsIl9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzIiwicmVtb3ZlU3R5bGVGcm9tVG8iLCJjdXJzb3JTdGFydCIsImN1cnNvckVuZCIsImxpbmVTdGFydCIsImNoYXJTdGFydCIsImxpbmVFbmQiLCJjaGFyRW5kIiwic3R5bGVPYmoiLCJzaGlmdExpbmVTdHlsZXMiLCJudW1lcmljQ2hhciIsImNsb25lZFN0eWxlcyIsIm51bWVyaWNMaW5lIiwiaW5zZXJ0TmV3bGluZVN0eWxlT2JqZWN0IiwicXR5IiwiY29waWVkU3R5bGUiLCJjdXJyZW50Q2hhclN0eWxlIiwibmV3TGluZVN0eWxlcyIsInNvbWV0aGluZ0FkZGVkIiwiaXNFbmRPZkxpbmUiLCJudW1JbmRleCIsInN0eWxlQ2FycmllZE92ZXIiLCJpbnNlcnRDaGFyU3R5bGVPYmplY3QiLCJxdWFudGl0eSIsImN1cnJlbnRMaW5lU3R5bGVzIiwiY3VycmVudExpbmVTdHlsZXNDbG9uZWQiLCJudW1lcmljSW5kZXgiLCJuZXdTdHlsZSIsImluc2VydE5ld1N0eWxlQmxvY2siLCJpbnNlcnRlZFRleHQiLCJjdXJzb3JMb2MiLCJhZGRlZExpbmVzIiwibGluZXNMZW5ndGgiLCJzZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdCIsInNldFNlbGVjdGlvbkluQm91bmRhcmllcyIsIl9fbGFzdENsaWNrVGltZSIsIl9fbGFzdExhc3RDbGlja1RpbWUiLCJfX2xhc3RQb2ludGVyIiwiX19uZXdDbGlja1RpbWUiLCJuZXdQb2ludGVyIiwiaXNUcmlwbGVDbGljayIsIl9zdG9wRXZlbnQiLCJfX2xhc3RJc0VkaXRpbmciLCJfX2xhc3RTZWxlY3RlZCIsImluaXRNb3VzZWRvd25IYW5kbGVyIiwiaW5pdE1vdXNldXBIYW5kbGVyIiwiaW5pdENsaWNrcyIsImRvdWJsZUNsaWNrSGFuZGxlciIsInRyaXBsZUNsaWNrSGFuZGxlciIsIl9tb3VzZURvd25IYW5kbGVyIiwic2V0Q3Vyc29yQnlDbGljayIsIl9tb3VzZURvd25IYW5kbGVyQmVmb3JlIiwiY3VycmVudEFjdGl2ZSIsIm1vdXNlT2Zmc2V0IiwicHJldldpZHRoIiwiX2dldE5ld1NlbGVjdGlvblN0YXJ0RnJvbU9mZnNldCIsImRpc3RhbmNlQnR3TGFzdENoYXJBbmRDdXJzb3IiLCJkaXN0YW5jZUJ0d05leHRDaGFyQW5kQ3Vyc29yIiwib25LZXlEb3duIiwib25LZXlVcCIsIm9uSW5wdXQiLCJjb3B5IiwicGFzdGUiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uVXBkYXRlIiwib25Db21wb3NpdGlvbkVuZCIsIl9jbGlja0hhbmRsZXJJbml0aWFsaXplZCIsIm9uQ2xpY2siLCJrZXlzTWFwIiwia2V5c01hcFJ0bCIsImN0cmxLZXlzTWFwVXAiLCJjdHJsS2V5c01hcERvd24iLCJrZXlNYXAiLCJrZXlDb2RlIiwiY3RybEtleSIsIm1ldGFLZXkiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJfY29weURvbmUiLCJmcm9tUGFzdGUiLCJuZXh0VGV4dCIsImNoYXJDb3VudCIsIm5leHRDaGFyQ291bnQiLCJyZW1vdmVkVGV4dCIsImNoYXJEaWZmIiwicmVtb3ZlRnJvbSIsInJlbW92ZVRvIiwidGV4dGFyZWFTZWxlY3Rpb24iLCJiYWNrRGVsZXRlIiwiY29waWVkVGV4dCIsImNvcGllZFRleHRTdHlsZSIsImNvbXBvc2l0aW9uRW5kIiwiX2dldENsaXBib2FyZERhdGEiLCJjbGlwYm9hcmREYXRhIiwiX2dldFdpZHRoQmVmb3JlQ3Vyc29yIiwid2lkdGhCZWZvcmVDdXJzb3IiLCJnZXREb3duQ3Vyc29yT2Zmc2V0IiwiaXNSaWdodCIsInNlbGVjdGlvblByb3AiLCJfZ2V0U2VsZWN0aW9uRm9yT2Zmc2V0IiwiaW5kZXhPbk90aGVyTGluZSIsIl9nZXRJbmRleE9uTGluZSIsInRleHRBZnRlckN1cnNvciIsImdldFVwQ3Vyc29yT2Zmc2V0IiwidGV4dEJlZm9yZUN1cnNvciIsIndpZHRoT2ZDaGFyc09uTGluZSIsImluZGV4T25MaW5lIiwiY2hhcldpZHRoIiwiZm91bmRNYXRjaCIsImxlZnRFZGdlIiwicmlnaHRFZGdlIiwib2Zmc2V0RnJvbUxlZnRFZGdlIiwib2Zmc2V0RnJvbVJpZ2h0RWRnZSIsIm1vdmVDdXJzb3JEb3duIiwiX21vdmVDdXJzb3JVcE9yRG93biIsIm1vdmVDdXJzb3JVcCIsIm1vdmVDdXJzb3JXaXRoU2hpZnQiLCJtb3ZlQ3Vyc29yV2l0aG91dFNoaWZ0IiwibW92ZUN1cnNvckxlZnQiLCJfbW92ZUN1cnNvckxlZnRPclJpZ2h0IiwiX21vdmUiLCJfbW92ZUxlZnQiLCJfbW92ZVJpZ2h0IiwibW92ZUN1cnNvckxlZnRXaXRob3V0U2hpZnQiLCJjaGFuZ2UiLCJtb3ZlQ3Vyc29yTGVmdFdpdGhTaGlmdCIsIm1vdmVDdXJzb3JSaWdodCIsIm1vdmVDdXJzb3JSaWdodFdpdGhTaGlmdCIsIm1vdmVDdXJzb3JSaWdodFdpdGhvdXRTaGlmdCIsImNoYW5nZWQiLCJyZW1vdmVDaGFycyIsImluc2VydENoYXJzIiwibXVsdGlwbGVTcGFjZXNSZWdleCIsIl9nZXRTVkdMZWZ0VG9wT2Zmc2V0cyIsInRleHRBbmRCZyIsIl9nZXRTVkdUZXh0QW5kQmciLCJ0ZXh0VG9wIiwidGV4dExlZnQiLCJfd3JhcFNWR1RleHRBbmRCZyIsImxpbmVUb3AiLCJub1NoYWRvdyIsInRleHRTcGFucyIsInRleHRUb3BPZmZzZXQiLCJ0ZXh0TGVmdE9mZnNldCIsIl9zZXRTVkdUZXh0TGluZUJnIiwiX3NldFNWR1RleHRMaW5lVGV4dCIsIl9jcmVhdGVUZXh0Q2hhclNwYW4iLCJzdHlsZURlY2wiLCJzaG91bGRVc2VXaGl0ZXNwYWNlIiwic3R5bGVQcm9wcyIsImZpbGxTdHlsZXMiLCJkeVNwYW4iLCJfcHVzaFRleHRCZ1JlY3QiLCJmaWxsQ29sb3IiLCJfZ2V0U1ZHTGluZVRvcE9mZnNldCIsImxhc3RIZWlnaHQiLCJzdmdTdHlsZSIsIlRleHRib3giLCJtaW5XaWR0aCIsImR5bmFtaWNNaW5XaWR0aCIsIl9fY2FjaGVkTGluZXMiLCJfd29yZEpvaW5lcnMiLCJzcGxpdEJ5R3JhcGhlbWUiLCJfc3R5bGVNYXAiLCJfZ2VuZXJhdGVTdHlsZU1hcCIsInRleHRJbmZvIiwicmVhbExpbmVDb3VudCIsInJlYWxMaW5lQ2hhckNvdW50IiwiaXNXcmFwcGluZyIsIm5leHRMaW5lSW5kZXgiLCJuZXh0T2Zmc2V0Iiwic2hvdWxkTGltaXQiLCJtYXBOZXh0TGluZSIsIl93cmFwVGV4dCIsImRlc2lyZWRXaWR0aCIsIndyYXBwZWQiLCJfd3JhcExpbmUiLCJfbWVhc3VyZVdvcmQiLCJ3b3JkIiwiY2hhck9mZnNldCIsIl9saW5lIiwicmVzZXJ2ZWRTcGFjZSIsIndvcmRzIiwiaW5maXgiLCJ3b3JkV2lkdGgiLCJpbmZpeFdpZHRoIiwibGFyZ2VzdFdvcmRXaWR0aCIsImxpbmVKdXN0U3RhcnRlZCIsImFkZGl0aW9uYWxTcGFjZSIsImdldE1pbldpZHRoIiwibGluZXNUb0tlZXAiLCJzY2FsZVNrZXdTdHlsZUhhbmRsZXIiLCJzY2FsZVN0eWxlSGFuZGxlciIsIm9iamVjdENvbnRyb2xzIiwibWwiLCJtciIsIm1iIiwibXRyIiwidGV4dEJveENvbnRyb2xzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/fabric/dist/fabric.js\n");

/***/ })

};
;