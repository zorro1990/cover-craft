/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fabric";
exports.ids = ["vendor-chunks/fabric"];
exports.modules = {

/***/ "(ssr)/./node_modules/fabric/dist/fabric.js":
/*!********************************************!*\
  !*** ./node_modules/fabric/dist/fabric.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* build: `node build.js modules=ALL exclude=gestures,accessors,erasing requirejs minifier=uglifyjs` */ /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */ var fabric = fabric || {\n    version: \"5.3.0\"\n};\nif (true) {\n    exports.fabric = fabric;\n} else {}\n/* _AMD_END_ */ if (typeof document !== \"undefined\" && \"undefined\" !== \"undefined\") {} else {\n    // assume we're running under node.js when document/window are not present\n    var jsdom = __webpack_require__(/*! jsdom */ \"(ssr)/../../node_modules/jsdom/lib/api.js\");\n    var virtualWindow = new jsdom.JSDOM(decodeURIComponent(\"%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E\"), {\n        features: {\n            FetchExternalResources: [\n                \"img\"\n            ]\n        },\n        resources: \"usable\"\n    }).window;\n    fabric.document = virtualWindow.document;\n    fabric.jsdomImplForWrapper = (__webpack_require__(/*! jsdom/lib/jsdom/living/generated/utils */ \"(ssr)/../../node_modules/jsdom/lib/jsdom/living/generated/utils.js\").implForWrapper);\n    fabric.nodeCanvas = (__webpack_require__(/*! jsdom/lib/jsdom/utils */ \"(ssr)/../../node_modules/jsdom/lib/jsdom/utils.js\").Canvas);\n    fabric.window = virtualWindow;\n    DOMParser = fabric.window.DOMParser;\n}\n/**\n * True when in environment that supports touch events\n * @type boolean\n */ fabric.isTouchSupported = \"ontouchstart\" in fabric.window || \"ontouchstart\" in fabric.document || fabric.window && fabric.window.navigator && fabric.window.navigator.maxTouchPoints > 0;\n/**\n * True when in environment that's probably Node.js\n * @type boolean\n */ fabric.isLikelyNode = typeof Buffer !== \"undefined\" && \"undefined\" === \"undefined\";\n/* _FROM_SVG_START_ */ /**\n * Attributes parsed from all SVG elements\n * @type array\n */ fabric.SHARED_ATTRIBUTES = [\n    \"display\",\n    \"transform\",\n    \"fill\",\n    \"fill-opacity\",\n    \"fill-rule\",\n    \"opacity\",\n    \"stroke\",\n    \"stroke-dasharray\",\n    \"stroke-linecap\",\n    \"stroke-dashoffset\",\n    \"stroke-linejoin\",\n    \"stroke-miterlimit\",\n    \"stroke-opacity\",\n    \"stroke-width\",\n    \"id\",\n    \"paint-order\",\n    \"vector-effect\",\n    \"instantiated_by_use\",\n    \"clip-path\"\n];\n/* _FROM_SVG_END_ */ /**\n * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.\n */ fabric.DPI = 96;\nfabric.reNum = \"(?:[-+]?(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[eE][-+]?\\\\d+)?)\";\nfabric.commaWsp = \"(?:\\\\s+,?\\\\s*|,\\\\s*)\";\nfabric.rePathCommand = /([-+]?((\\d+\\.\\d+)|((\\d+)|(\\.\\d+)))(?:[eE][-+]?\\d+)?)/ig;\nfabric.reNonWord = /[ \\n\\.,;!\\?\\-]/;\nfabric.fontPaths = {};\nfabric.iMatrix = [\n    1,\n    0,\n    0,\n    1,\n    0,\n    0\n];\nfabric.svgNS = \"http://www.w3.org/2000/svg\";\n/**\n * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.\n * @since 1.7.14\n * @type Number\n * @default\n */ fabric.perfLimitSizeTotal = 2097152;\n/**\n * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000\n * @since 1.7.14\n * @type Number\n * @default\n */ fabric.maxCacheSideLimit = 4096;\n/**\n * Lowest pixel limit for cache canvases, set at 256PX\n * @since 1.7.14\n * @type Number\n * @default\n */ fabric.minCacheSideLimit = 256;\n/**\n * Cache Object for widths of chars in text rendering.\n */ fabric.charWidthsCache = {};\n/**\n * if webgl is enabled and available, textureSize will determine the size\n * of the canvas backend\n * @since 2.0.0\n * @type Number\n * @default\n */ fabric.textureSize = 2048;\n/**\n * When 'true', style information is not retained when copy/pasting text, making\n * pasted text use destination style.\n * Defaults to 'false'.\n * @type Boolean\n * @default\n */ fabric.disableStyleCopyPaste = false;\n/**\n * Enable webgl for filtering picture is available\n * A filtering backend will be initialized, this will both take memory and\n * time since a default 2048x2048 canvas will be created for the gl context\n * @since 2.0.0\n * @type Boolean\n * @default\n */ fabric.enableGLFiltering = true;\n/**\n * Device Pixel Ratio\n * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html\n */ fabric.devicePixelRatio = fabric.window.devicePixelRatio || fabric.window.webkitDevicePixelRatio || fabric.window.mozDevicePixelRatio || 1;\n/**\n * Browser-specific constant to adjust CanvasRenderingContext2D.shadowBlur value,\n * which is unitless and not rendered equally across browsers.\n *\n * Values that work quite well (as of October 2017) are:\n * - Chrome: 1.5\n * - Edge: 1.75\n * - Firefox: 0.9\n * - Safari: 0.95\n *\n * @since 2.0.0\n * @type Number\n * @default 1\n */ fabric.browserShadowBlurConstant = 1;\n/**\n * This object contains the result of arc to bezier conversion for faster retrieving if the same arc needs to be converted again.\n * It was an internal variable, is accessible since version 2.3.4\n */ fabric.arcToSegmentsCache = {};\n/**\n * This object keeps the results of the boundsOfCurve calculation mapped by the joined arguments necessary to calculate it.\n * It does speed up calculation, if you parse and add always the same paths, but in case of heavy usage of freedrawing\n * you do not get any speed benefit and you get a big object in memory.\n * The object was a private variable before, while now is appended to the lib so that you have access to it and you\n * can eventually clear it.\n * It was an internal variable, is accessible since version 2.3.4\n */ fabric.boundsOfCurveCache = {};\n/**\n * If disabled boundsOfCurveCache is not used. For apps that make heavy usage of pencil drawing probably disabling it is better\n * @default true\n */ fabric.cachesBoundsOfCurve = true;\n/**\n * Skip performance testing of setupGLContext and force the use of putImageData that seems to be the one that works best on\n * Chrome + old hardware. if your users are experiencing empty images after filtering you may try to force this to true\n * this has to be set before instantiating the filtering backend ( before filtering the first image )\n * @type Boolean\n * @default false\n */ fabric.forceGLPutImageData = false;\nfabric.initFilterBackend = function() {\n    if (fabric.enableGLFiltering && fabric.isWebglSupported && fabric.isWebglSupported(fabric.textureSize)) {\n        console.log(\"max texture size: \" + fabric.maxTextureSize);\n        return new fabric.WebglFilterBackend({\n            tileSize: fabric.textureSize\n        });\n    } else if (fabric.Canvas2dFilterBackend) {\n        return new fabric.Canvas2dFilterBackend();\n    }\n};\nif (typeof document !== \"undefined\" && \"undefined\" !== \"undefined\") {}\n(function() {\n    /**\n   * @private\n   * @param {String} eventName\n   * @param {Function} handler\n   */ function _removeEventListener(eventName, handler) {\n        if (!this.__eventListeners[eventName]) {\n            return;\n        }\n        var eventListener = this.__eventListeners[eventName];\n        if (handler) {\n            eventListener[eventListener.indexOf(handler)] = false;\n        } else {\n            fabric.util.array.fill(eventListener, false);\n        }\n    }\n    /**\n   * Observes specified event\n   * @memberOf fabric.Observable\n   * @alias on\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\n   * @param {Function} handler Function that receives a notification when an event of the specified type occurs\n   * @return {Self} thisArg\n   * @chainable\n   */ function on(eventName, handler) {\n        if (!this.__eventListeners) {\n            this.__eventListeners = {};\n        }\n        // one object with key/value pairs was passed\n        if (arguments.length === 1) {\n            for(var prop in eventName){\n                this.on(prop, eventName[prop]);\n            }\n        } else {\n            if (!this.__eventListeners[eventName]) {\n                this.__eventListeners[eventName] = [];\n            }\n            this.__eventListeners[eventName].push(handler);\n        }\n        return this;\n    }\n    function _once(eventName, handler) {\n        var _handler = (function() {\n            handler.apply(this, arguments);\n            this.off(eventName, _handler);\n        }).bind(this);\n        this.on(eventName, _handler);\n    }\n    function once(eventName, handler) {\n        // one object with key/value pairs was passed\n        if (arguments.length === 1) {\n            for(var prop in eventName){\n                _once.call(this, prop, eventName[prop]);\n            }\n        } else {\n            _once.call(this, eventName, handler);\n        }\n        return this;\n    }\n    /**\n   * Stops event observing for a particular event handler. Calling this method\n   * without arguments removes all handlers for all events\n   * @memberOf fabric.Observable\n   * @alias off\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\n   * @param {Function} handler Function to be deleted from EventListeners\n   * @return {Self} thisArg\n   * @chainable\n   */ function off(eventName, handler) {\n        if (!this.__eventListeners) {\n            return this;\n        }\n        // remove all key/value pairs (event name -> event handler)\n        if (arguments.length === 0) {\n            for(eventName in this.__eventListeners){\n                _removeEventListener.call(this, eventName);\n            }\n        } else if (arguments.length === 1 && typeof arguments[0] === \"object\") {\n            for(var prop in eventName){\n                _removeEventListener.call(this, prop, eventName[prop]);\n            }\n        } else {\n            _removeEventListener.call(this, eventName, handler);\n        }\n        return this;\n    }\n    /**\n   * Fires event with an optional options object\n   * @memberOf fabric.Observable\n   * @param {String} eventName Event name to fire\n   * @param {Object} [options] Options object\n   * @return {Self} thisArg\n   * @chainable\n   */ function fire(eventName, options) {\n        if (!this.__eventListeners) {\n            return this;\n        }\n        var listenersForEvent = this.__eventListeners[eventName];\n        if (!listenersForEvent) {\n            return this;\n        }\n        for(var i = 0, len = listenersForEvent.length; i < len; i++){\n            listenersForEvent[i] && listenersForEvent[i].call(this, options || {});\n        }\n        this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {\n            return value !== false;\n        });\n        return this;\n    }\n    /**\n   * @namespace fabric.Observable\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}\n   * @see {@link http://fabricjs.com/events|Events demo}\n   */ fabric.Observable = {\n        fire: fire,\n        on: on,\n        once: once,\n        off: off\n    };\n})();\n/**\n * @namespace fabric.Collection\n */ fabric.Collection = {\n    _objects: [],\n    /**\n   * Adds objects to collection, Canvas or Group, then renders canvas\n   * (if `renderOnAddRemove` is not `false`).\n   * in case of Group no changes to bounding box are made.\n   * Objects should be instances of (or inherit from) fabric.Object\n   * Use of this function is highly discouraged for groups.\n   * you can add a bunch of objects with the add method but then you NEED\n   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.\n   * @param {...fabric.Object} object Zero or more fabric instances\n   * @return {Self} thisArg\n   * @chainable\n   */ add: function() {\n        this._objects.push.apply(this._objects, arguments);\n        if (this._onObjectAdded) {\n            for(var i = 0, length = arguments.length; i < length; i++){\n                this._onObjectAdded(arguments[i]);\n            }\n        }\n        this.renderOnAddRemove && this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)\n   * An object should be an instance of (or inherit from) fabric.Object\n   * Use of this function is highly discouraged for groups.\n   * you can add a bunch of objects with the insertAt method but then you NEED\n   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.\n   * @param {Object} object Object to insert\n   * @param {Number} index Index to insert object at\n   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs\n   * @return {Self} thisArg\n   * @chainable\n   */ insertAt: function(object, index, nonSplicing) {\n        var objects = this._objects;\n        if (nonSplicing) {\n            objects[index] = object;\n        } else {\n            objects.splice(index, 0, object);\n        }\n        this._onObjectAdded && this._onObjectAdded(object);\n        this.renderOnAddRemove && this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)\n   * @param {...fabric.Object} object Zero or more fabric instances\n   * @return {Self} thisArg\n   * @chainable\n   */ remove: function() {\n        var objects = this._objects, index, somethingRemoved = false;\n        for(var i = 0, length = arguments.length; i < length; i++){\n            index = objects.indexOf(arguments[i]);\n            // only call onObjectRemoved if an object was actually removed\n            if (index !== -1) {\n                somethingRemoved = true;\n                objects.splice(index, 1);\n                this._onObjectRemoved && this._onObjectRemoved(arguments[i]);\n            }\n        }\n        this.renderOnAddRemove && somethingRemoved && this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Executes given function for each object in this group\n   * @param {Function} callback\n   *                   Callback invoked with current object as first argument,\n   *                   index - as second and an array of all objects - as third.\n   *                   Callback is invoked in a context of Global Object (e.g. `window`)\n   *                   when no `context` argument is given\n   *\n   * @param {Object} context Context (aka thisObject)\n   * @return {Self} thisArg\n   * @chainable\n   */ forEachObject: function(callback, context) {\n        var objects = this.getObjects();\n        for(var i = 0, len = objects.length; i < len; i++){\n            callback.call(context, objects[i], i, objects);\n        }\n        return this;\n    },\n    /**\n   * Returns an array of children objects of this instance\n   * Type parameter introduced in 1.3.10\n   * since 2.3.5 this method return always a COPY of the array;\n   * @param {String} [type] When specified, only objects of this type are returned\n   * @return {Array}\n   */ getObjects: function(type) {\n        if (typeof type === \"undefined\") {\n            return this._objects.concat();\n        }\n        return this._objects.filter(function(o) {\n            return o.type === type;\n        });\n    },\n    /**\n   * Returns object at specified index\n   * @param {Number} index\n   * @return {Self} thisArg\n   */ item: function(index) {\n        return this._objects[index];\n    },\n    /**\n   * Returns true if collection contains no objects\n   * @return {Boolean} true if collection is empty\n   */ isEmpty: function() {\n        return this._objects.length === 0;\n    },\n    /**\n   * Returns a size of a collection (i.e: length of an array containing its objects)\n   * @return {Number} Collection size\n   */ size: function() {\n        return this._objects.length;\n    },\n    /**\n   * Returns true if collection contains an object\n   * @param {Object} object Object to check against\n   * @param {Boolean} [deep=false] `true` to check all descendants, `false` to check only `_objects`\n   * @return {Boolean} `true` if collection contains an object\n   */ contains: function(object, deep) {\n        if (this._objects.indexOf(object) > -1) {\n            return true;\n        } else if (deep) {\n            return this._objects.some(function(obj) {\n                return typeof obj.contains === \"function\" && obj.contains(object, true);\n            });\n        }\n        return false;\n    },\n    /**\n   * Returns number representation of a collection complexity\n   * @return {Number} complexity\n   */ complexity: function() {\n        return this._objects.reduce(function(memo, current) {\n            memo += current.complexity ? current.complexity() : 0;\n            return memo;\n        }, 0);\n    }\n};\n/**\n * @namespace fabric.CommonMethods\n */ fabric.CommonMethods = {\n    /**\n   * Sets object's properties from options\n   * @param {Object} [options] Options object\n   */ _setOptions: function(options) {\n        for(var prop in options){\n            this.set(prop, options[prop]);\n        }\n    },\n    /**\n   * @private\n   * @param {Object} [filler] Options object\n   * @param {String} [property] property to set the Gradient to\n   */ _initGradient: function(filler, property) {\n        if (filler && filler.colorStops && !(filler instanceof fabric.Gradient)) {\n            this.set(property, new fabric.Gradient(filler));\n        }\n    },\n    /**\n   * @private\n   * @param {Object} [filler] Options object\n   * @param {String} [property] property to set the Pattern to\n   * @param {Function} [callback] callback to invoke after pattern load\n   */ _initPattern: function(filler, property, callback) {\n        if (filler && filler.source && !(filler instanceof fabric.Pattern)) {\n            this.set(property, new fabric.Pattern(filler, callback));\n        } else {\n            callback && callback();\n        }\n    },\n    /**\n   * @private\n   */ _setObject: function(obj) {\n        for(var prop in obj){\n            this._set(prop, obj[prop]);\n        }\n    },\n    /**\n   * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.\n   * @param {String|Object} key Property name or object (if object, iterate over the object properties)\n   * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ set: function(key, value) {\n        if (typeof key === \"object\") {\n            this._setObject(key);\n        } else {\n            this._set(key, value);\n        }\n        return this;\n    },\n    _set: function(key, value) {\n        this[key] = value;\n    },\n    /**\n   * Toggles specified property from `true` to `false` or from `false` to `true`\n   * @param {String} property Property to toggle\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ toggle: function(property) {\n        var value = this.get(property);\n        if (typeof value === \"boolean\") {\n            this.set(property, !value);\n        }\n        return this;\n    },\n    /**\n   * Basic getter\n   * @param {String} property Property name\n   * @return {*} value of a property\n   */ get: function(property) {\n        return this[property];\n    }\n};\n(function(global) {\n    var sqrt = Math.sqrt, atan2 = Math.atan2, pow = Math.pow, PiBy180 = Math.PI / 180, PiBy2 = Math.PI / 2;\n    /**\n   * @namespace fabric.util\n   */ fabric.util = {\n        /**\n     * Calculate the cos of an angle, avoiding returning floats for known results\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} angle the angle in radians or in degree\n     * @return {Number}\n     */ cos: function(angle) {\n            if (angle === 0) {\n                return 1;\n            }\n            if (angle < 0) {\n                // cos(a) = cos(-a)\n                angle = -angle;\n            }\n            var angleSlice = angle / PiBy2;\n            switch(angleSlice){\n                case 1:\n                case 3:\n                    return 0;\n                case 2:\n                    return -1;\n            }\n            return Math.cos(angle);\n        },\n        /**\n     * Calculate the sin of an angle, avoiding returning floats for known results\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} angle the angle in radians or in degree\n     * @return {Number}\n     */ sin: function(angle) {\n            if (angle === 0) {\n                return 0;\n            }\n            var angleSlice = angle / PiBy2, sign = 1;\n            if (angle < 0) {\n                // sin(-a) = -sin(a)\n                sign = -1;\n            }\n            switch(angleSlice){\n                case 1:\n                    return sign;\n                case 2:\n                    return 0;\n                case 3:\n                    return -sign;\n            }\n            return Math.sin(angle);\n        },\n        /**\n     * Removes value from an array.\n     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} array\n     * @param {*} value\n     * @return {Array} original array\n     */ removeFromArray: function(array, value) {\n            var idx = array.indexOf(value);\n            if (idx !== -1) {\n                array.splice(idx, 1);\n            }\n            return array;\n        },\n        /**\n     * Returns random number between 2 specified ones.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} min lower limit\n     * @param {Number} max upper limit\n     * @return {Number} random value (between min and max)\n     */ getRandomInt: function(min, max) {\n            return Math.floor(Math.random() * (max - min + 1)) + min;\n        },\n        /**\n     * Transforms degrees to radians.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} degrees value in degrees\n     * @return {Number} value in radians\n     */ degreesToRadians: function(degrees) {\n            return degrees * PiBy180;\n        },\n        /**\n     * Transforms radians to degrees.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} radians value in radians\n     * @return {Number} value in degrees\n     */ radiansToDegrees: function(radians) {\n            return radians / PiBy180;\n        },\n        /**\n     * Rotates `point` around `origin` with `radians`\n     * @static\n     * @memberOf fabric.util\n     * @param {fabric.Point} point The point to rotate\n     * @param {fabric.Point} origin The origin of the rotation\n     * @param {Number} radians The radians of the angle for the rotation\n     * @return {fabric.Point} The new rotated point\n     */ rotatePoint: function(point, origin, radians) {\n            var newPoint = new fabric.Point(point.x - origin.x, point.y - origin.y), v = fabric.util.rotateVector(newPoint, radians);\n            return new fabric.Point(v.x, v.y).addEquals(origin);\n        },\n        /**\n     * Rotates `vector` with `radians`\n     * @static\n     * @memberOf fabric.util\n     * @param {Object} vector The vector to rotate (x and y)\n     * @param {Number} radians The radians of the angle for the rotation\n     * @return {Object} The new rotated point\n     */ rotateVector: function(vector, radians) {\n            var sin = fabric.util.sin(radians), cos = fabric.util.cos(radians), rx = vector.x * cos - vector.y * sin, ry = vector.x * sin + vector.y * cos;\n            return {\n                x: rx,\n                y: ry\n            };\n        },\n        /**\n     * Creates a vetor from points represented as a point\n     * @static\n     * @memberOf fabric.util\n     *\n     * @typedef {Object} Point\n     * @property {number} x\n     * @property {number} y\n     *\n     * @param {Point} from\n     * @param {Point} to\n     * @returns {Point} vector\n     */ createVector: function(from, to) {\n            return new fabric.Point(to.x - from.x, to.y - from.y);\n        },\n        /**\n     * Calculates angle between 2 vectors using dot product\n     * @static\n     * @memberOf fabric.util\n     * @param {Point} a\n     * @param {Point} b\n     * @returns the angle in radian between the vectors\n     */ calcAngleBetweenVectors: function(a, b) {\n            return Math.acos((a.x * b.x + a.y * b.y) / (Math.hypot(a.x, a.y) * Math.hypot(b.x, b.y)));\n        },\n        /**\n     * @static\n     * @memberOf fabric.util\n     * @param {Point} v\n     * @returns {Point} vector representing the unit vector of pointing to the direction of `v`\n     */ getHatVector: function(v) {\n            return new fabric.Point(v.x, v.y).multiply(1 / Math.hypot(v.x, v.y));\n        },\n        /**\n     * @static\n     * @memberOf fabric.util\n     * @param {Point} A\n     * @param {Point} B\n     * @param {Point} C\n     * @returns {{ vector: Point, angle: number }} vector representing the bisector of A and A's angle\n     */ getBisector: function(A, B, C) {\n            var AB = fabric.util.createVector(A, B), AC = fabric.util.createVector(A, C);\n            var alpha = fabric.util.calcAngleBetweenVectors(AB, AC);\n            //  check if alpha is relative to AB->BC\n            var ro = fabric.util.calcAngleBetweenVectors(fabric.util.rotateVector(AB, alpha), AC);\n            var phi = alpha * (ro === 0 ? 1 : -1) / 2;\n            return {\n                vector: fabric.util.getHatVector(fabric.util.rotateVector(AB, phi)),\n                angle: alpha\n            };\n        },\n        /**\n     * Project stroke width on points returning 2 projections for each point as follows:\n     * - `miter`: 2 points corresponding to the outer boundary and the inner boundary of stroke.\n     * - `bevel`: 2 points corresponding to the bevel boundaries, tangent to the bisector.\n     * - `round`: same as `bevel`\n     * Used to calculate object's bounding box\n     * @static\n     * @memberOf fabric.util\n     * @param {Point[]} points\n     * @param {Object} options\n     * @param {number} options.strokeWidth\n     * @param {'miter'|'bevel'|'round'} options.strokeLineJoin\n     * @param {number} options.strokeMiterLimit https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit\n     * @param {boolean} options.strokeUniform\n     * @param {number} options.scaleX\n     * @param {number} options.scaleY\n     * @param {boolean} [openPath] whether the shape is open or not, affects the calculations of the first and last points\n     * @returns {fabric.Point[]} array of size 2n/4n of all suspected points\n     */ projectStrokeOnPoints: function(points, options, openPath) {\n            var coords = [], s = options.strokeWidth / 2, strokeUniformScalar = options.strokeUniform ? new fabric.Point(1 / options.scaleX, 1 / options.scaleY) : new fabric.Point(1, 1), getStrokeHatVector = function(v) {\n                var scalar = s / Math.hypot(v.x, v.y);\n                return new fabric.Point(v.x * scalar * strokeUniformScalar.x, v.y * scalar * strokeUniformScalar.y);\n            };\n            if (points.length <= 1) {\n                return coords;\n            }\n            points.forEach(function(p, index) {\n                var A = new fabric.Point(p.x, p.y), B, C;\n                if (index === 0) {\n                    C = points[index + 1];\n                    B = openPath ? getStrokeHatVector(fabric.util.createVector(C, A)).addEquals(A) : points[points.length - 1];\n                } else if (index === points.length - 1) {\n                    B = points[index - 1];\n                    C = openPath ? getStrokeHatVector(fabric.util.createVector(B, A)).addEquals(A) : points[0];\n                } else {\n                    B = points[index - 1];\n                    C = points[index + 1];\n                }\n                var bisector = fabric.util.getBisector(A, B, C), bisectorVector = bisector.vector, alpha = bisector.angle, scalar, miterVector;\n                if (options.strokeLineJoin === \"miter\") {\n                    scalar = -s / Math.sin(alpha / 2);\n                    miterVector = new fabric.Point(bisectorVector.x * scalar * strokeUniformScalar.x, bisectorVector.y * scalar * strokeUniformScalar.y);\n                    if (Math.hypot(miterVector.x, miterVector.y) / s <= options.strokeMiterLimit) {\n                        coords.push(A.add(miterVector));\n                        coords.push(A.subtract(miterVector));\n                        return;\n                    }\n                }\n                scalar = -s * Math.SQRT2;\n                miterVector = new fabric.Point(bisectorVector.x * scalar * strokeUniformScalar.x, bisectorVector.y * scalar * strokeUniformScalar.y);\n                coords.push(A.add(miterVector));\n                coords.push(A.subtract(miterVector));\n            });\n            return coords;\n        },\n        /**\n     * Apply transform t to point p\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Point} p The point to transform\n     * @param  {Array} t The transform\n     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied\n     * @return {fabric.Point} The transformed point\n     */ transformPoint: function(p, t, ignoreOffset) {\n            if (ignoreOffset) {\n                return new fabric.Point(t[0] * p.x + t[2] * p.y, t[1] * p.x + t[3] * p.y);\n            }\n            return new fabric.Point(t[0] * p.x + t[2] * p.y + t[4], t[1] * p.x + t[3] * p.y + t[5]);\n        },\n        /**\n     * Returns coordinates of points's bounding rectangle (left, top, width, height)\n     * @param {Array} points 4 points array\n     * @param {Array} [transform] an array of 6 numbers representing a 2x3 transform matrix\n     * @return {Object} Object with left, top, width, height properties\n     */ makeBoundingBoxFromPoints: function(points, transform) {\n            if (transform) {\n                for(var i = 0; i < points.length; i++){\n                    points[i] = fabric.util.transformPoint(points[i], transform);\n                }\n            }\n            var xPoints = [\n                points[0].x,\n                points[1].x,\n                points[2].x,\n                points[3].x\n            ], minX = fabric.util.array.min(xPoints), maxX = fabric.util.array.max(xPoints), width = maxX - minX, yPoints = [\n                points[0].y,\n                points[1].y,\n                points[2].y,\n                points[3].y\n            ], minY = fabric.util.array.min(yPoints), maxY = fabric.util.array.max(yPoints), height = maxY - minY;\n            return {\n                left: minX,\n                top: minY,\n                width: width,\n                height: height\n            };\n        },\n        /**\n     * Invert transformation t\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} t The transform\n     * @return {Array} The inverted transform\n     */ invertTransform: function(t) {\n            var a = 1 / (t[0] * t[3] - t[1] * t[2]), r = [\n                a * t[3],\n                -a * t[1],\n                -a * t[2],\n                a * t[0]\n            ], o = fabric.util.transformPoint({\n                x: t[4],\n                y: t[5]\n            }, r, true);\n            r[4] = -o.x;\n            r[5] = -o.y;\n            return r;\n        },\n        /**\n     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number|String} number number to operate on\n     * @param {Number} fractionDigits number of fraction digits to \"leave\"\n     * @return {Number}\n     */ toFixed: function(number, fractionDigits) {\n            return parseFloat(Number(number).toFixed(fractionDigits));\n        },\n        /**\n     * Converts from attribute value to pixel value if applicable.\n     * Returns converted pixels or original value not converted.\n     * @param {Number|String} value number to operate on\n     * @param {Number} fontSize\n     * @return {Number|String}\n     */ parseUnit: function(value, fontSize) {\n            var unit = /\\D{0,2}$/.exec(value), number = parseFloat(value);\n            if (!fontSize) {\n                fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\n            }\n            switch(unit[0]){\n                case \"mm\":\n                    return number * fabric.DPI / 25.4;\n                case \"cm\":\n                    return number * fabric.DPI / 2.54;\n                case \"in\":\n                    return number * fabric.DPI;\n                case \"pt\":\n                    return number * fabric.DPI / 72; // or * 4 / 3\n                case \"pc\":\n                    return number * fabric.DPI / 72 * 12; // or * 16\n                case \"em\":\n                    return number * fontSize;\n                default:\n                    return number;\n            }\n        },\n        /**\n     * Function which always returns `false`.\n     * @static\n     * @memberOf fabric.util\n     * @return {Boolean}\n     */ falseFunction: function() {\n            return false;\n        },\n        /**\n     * Returns klass \"Class\" object of given namespace\n     * @memberOf fabric.util\n     * @param {String} type Type of object (eg. 'circle')\n     * @param {String} namespace Namespace to get klass \"Class\" object from\n     * @return {Object} klass \"Class\"\n     */ getKlass: function(type, namespace) {\n            // capitalize first letter only\n            type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));\n            return fabric.util.resolveNamespace(namespace)[type];\n        },\n        /**\n     * Returns array of attributes for given svg that fabric parses\n     * @memberOf fabric.util\n     * @param {String} type Type of svg element (eg. 'circle')\n     * @return {Array} string names of supported attributes\n     */ getSvgAttributes: function(type) {\n            var attributes = [\n                \"instantiated_by_use\",\n                \"style\",\n                \"id\",\n                \"class\"\n            ];\n            switch(type){\n                case \"linearGradient\":\n                    attributes = attributes.concat([\n                        \"x1\",\n                        \"y1\",\n                        \"x2\",\n                        \"y2\",\n                        \"gradientUnits\",\n                        \"gradientTransform\"\n                    ]);\n                    break;\n                case \"radialGradient\":\n                    attributes = attributes.concat([\n                        \"gradientUnits\",\n                        \"gradientTransform\",\n                        \"cx\",\n                        \"cy\",\n                        \"r\",\n                        \"fx\",\n                        \"fy\",\n                        \"fr\"\n                    ]);\n                    break;\n                case \"stop\":\n                    attributes = attributes.concat([\n                        \"offset\",\n                        \"stop-color\",\n                        \"stop-opacity\"\n                    ]);\n                    break;\n            }\n            return attributes;\n        },\n        /**\n     * Returns object of given namespace\n     * @memberOf fabric.util\n     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'\n     * @return {Object} Object for given namespace (default fabric)\n     */ resolveNamespace: function(namespace) {\n            if (!namespace) {\n                return fabric;\n            }\n            var parts = namespace.split(\".\"), len = parts.length, i, obj = global || fabric.window;\n            for(i = 0; i < len; ++i){\n                obj = obj[parts[i]];\n            }\n            return obj;\n        },\n        /**\n     * Loads image element from given url and passes it to a callback\n     * @memberOf fabric.util\n     * @param {String} url URL representing an image\n     * @param {Function} callback Callback; invoked with loaded image\n     * @param {*} [context] Context to invoke callback in\n     * @param {Object} [crossOrigin] crossOrigin value to set image element to\n     */ loadImage: function(url, callback, context, crossOrigin) {\n            if (!url) {\n                callback && callback.call(context, url);\n                return;\n            }\n            var img = fabric.util.createImage();\n            /** @ignore */ var onLoadCallback = function() {\n                callback && callback.call(context, img, false);\n                img = img.onload = img.onerror = null;\n            };\n            img.onload = onLoadCallback;\n            /** @ignore */ img.onerror = function() {\n                fabric.log(\"Error loading \" + img.src);\n                callback && callback.call(context, null, true);\n                img = img.onload = img.onerror = null;\n            };\n            // data-urls appear to be buggy with crossOrigin\n            // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767\n            // see https://code.google.com/p/chromium/issues/detail?id=315152\n            //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069\n            // crossOrigin null is the same as not set.\n            if (url.indexOf(\"data\") !== 0 && crossOrigin !== undefined && crossOrigin !== null) {\n                img.crossOrigin = crossOrigin;\n            }\n            // IE10 / IE11-Fix: SVG contents from data: URI\n            // will only be available if the IMG is present\n            // in the DOM (and visible)\n            if (url.substring(0, 14) === \"data:image/svg\") {\n                img.onload = null;\n                fabric.util.loadImageInDom(img, onLoadCallback);\n            }\n            img.src = url;\n        },\n        /**\n     * Attaches SVG image with data: URL to the dom\n     * @memberOf fabric.util\n     * @param {Object} img Image object with data:image/svg src\n     * @param {Function} callback Callback; invoked with loaded image\n     * @return {Object} DOM element (div containing the SVG image)\n     */ loadImageInDom: function(img, onLoadCallback) {\n            var div = fabric.document.createElement(\"div\");\n            div.style.width = div.style.height = \"1px\";\n            div.style.left = div.style.top = \"-100%\";\n            div.style.position = \"absolute\";\n            div.appendChild(img);\n            fabric.document.querySelector(\"body\").appendChild(div);\n            /**\n       * Wrap in function to:\n       *   1. Call existing callback\n       *   2. Cleanup DOM\n       */ img.onload = function() {\n                onLoadCallback();\n                div.parentNode.removeChild(div);\n                div = null;\n            };\n        },\n        /**\n     * Creates corresponding fabric instances from their object representations\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} objects Objects to enliven\n     * @param {Function} callback Callback to invoke when all objects are created\n     * @param {String} namespace Namespace to get klass \"Class\" object from\n     * @param {Function} reviver Method for further parsing of object elements,\n     * called after each fabric object created.\n     */ enlivenObjects: function(objects, callback, namespace, reviver) {\n            objects = objects || [];\n            var enlivenedObjects = [], numLoadedObjects = 0, numTotalObjects = objects.length;\n            function onLoaded() {\n                if (++numLoadedObjects === numTotalObjects) {\n                    callback && callback(enlivenedObjects.filter(function(obj) {\n                        // filter out undefined objects (objects that gave error)\n                        return obj;\n                    }));\n                }\n            }\n            if (!numTotalObjects) {\n                callback && callback(enlivenedObjects);\n                return;\n            }\n            objects.forEach(function(o, index) {\n                // if sparse array\n                if (!o || !o.type) {\n                    onLoaded();\n                    return;\n                }\n                var klass = fabric.util.getKlass(o.type, namespace);\n                klass.fromObject(o, function(obj, error) {\n                    error || (enlivenedObjects[index] = obj);\n                    reviver && reviver(o, obj, error);\n                    onLoaded();\n                });\n            });\n        },\n        /**\n     * Creates corresponding fabric instances residing in an object, e.g. `clipPath`\n     * @see {@link fabric.Object.ENLIVEN_PROPS}\n     * @param {Object} object\n     * @param {Object} [context] assign enlived props to this object (pass null to skip this)\n     * @param {(objects:fabric.Object[]) => void} callback\n     */ enlivenObjectEnlivables: function(object, context, callback) {\n            var enlivenProps = fabric.Object.ENLIVEN_PROPS.filter(function(key) {\n                return !!object[key];\n            });\n            fabric.util.enlivenObjects(enlivenProps.map(function(key) {\n                return object[key];\n            }), function(enlivedProps) {\n                var objects = {};\n                enlivenProps.forEach(function(key, index) {\n                    objects[key] = enlivedProps[index];\n                    context && (context[key] = enlivedProps[index]);\n                });\n                callback && callback(objects);\n            });\n        },\n        /**\n     * Create and wait for loading of patterns\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} patterns Objects to enliven\n     * @param {Function} callback Callback to invoke when all objects are created\n     * called after each fabric object created.\n     */ enlivenPatterns: function(patterns, callback) {\n            patterns = patterns || [];\n            function onLoaded() {\n                if (++numLoadedPatterns === numPatterns) {\n                    callback && callback(enlivenedPatterns);\n                }\n            }\n            var enlivenedPatterns = [], numLoadedPatterns = 0, numPatterns = patterns.length;\n            if (!numPatterns) {\n                callback && callback(enlivenedPatterns);\n                return;\n            }\n            patterns.forEach(function(p, index) {\n                if (p && p.source) {\n                    new fabric.Pattern(p, function(pattern) {\n                        enlivenedPatterns[index] = pattern;\n                        onLoaded();\n                    });\n                } else {\n                    enlivenedPatterns[index] = p;\n                    onLoaded();\n                }\n            });\n        },\n        /**\n     * Groups SVG elements (usually those retrieved from SVG document)\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} elements SVG elements to group\n     * @param {Object} [options] Options object\n     * @param {String} path Value to set sourcePath to\n     * @return {fabric.Object|fabric.Group}\n     */ groupSVGElements: function(elements, options, path) {\n            var object;\n            if (elements && elements.length === 1) {\n                if (typeof path !== \"undefined\") {\n                    elements[0].sourcePath = path;\n                }\n                return elements[0];\n            }\n            if (options) {\n                if (options.width && options.height) {\n                    options.centerPoint = {\n                        x: options.width / 2,\n                        y: options.height / 2\n                    };\n                } else {\n                    delete options.width;\n                    delete options.height;\n                }\n            }\n            object = new fabric.Group(elements, options);\n            if (typeof path !== \"undefined\") {\n                object.sourcePath = path;\n            }\n            return object;\n        },\n        /**\n     * Populates an object with properties of another object\n     * @static\n     * @memberOf fabric.util\n     * @param {Object} source Source object\n     * @param {Object} destination Destination object\n     * @return {Array} properties Properties names to include\n     */ populateWithProperties: function(source, destination, properties) {\n            if (properties && Array.isArray(properties)) {\n                for(var i = 0, len = properties.length; i < len; i++){\n                    if (properties[i] in source) {\n                        destination[properties[i]] = source[properties[i]];\n                    }\n                }\n            }\n        },\n        /**\n     * Creates canvas element\n     * @static\n     * @memberOf fabric.util\n     * @return {CanvasElement} initialized canvas element\n     */ createCanvasElement: function() {\n            return fabric.document.createElement(\"canvas\");\n        },\n        /**\n     * Creates a canvas element that is a copy of another and is also painted\n     * @param {CanvasElement} canvas to copy size and content of\n     * @static\n     * @memberOf fabric.util\n     * @return {CanvasElement} initialized canvas element\n     */ copyCanvasElement: function(canvas) {\n            var newCanvas = fabric.util.createCanvasElement();\n            newCanvas.width = canvas.width;\n            newCanvas.height = canvas.height;\n            newCanvas.getContext(\"2d\").drawImage(canvas, 0, 0);\n            return newCanvas;\n        },\n        /**\n     * since 2.6.0 moved from canvas instance to utility.\n     * @param {CanvasElement} canvasEl to copy size and content of\n     * @param {String} format 'jpeg' or 'png', in some browsers 'webp' is ok too\n     * @param {Number} quality <= 1 and > 0\n     * @static\n     * @memberOf fabric.util\n     * @return {String} data url\n     */ toDataURL: function(canvasEl, format, quality) {\n            return canvasEl.toDataURL(\"image/\" + format, quality);\n        },\n        /**\n     * Creates image element (works on client and node)\n     * @static\n     * @memberOf fabric.util\n     * @return {HTMLImageElement} HTML image element\n     */ createImage: function() {\n            return fabric.document.createElement(\"img\");\n        },\n        /**\n     * Multiply matrix A by matrix B to nest transformations\n     * @static\n     * @memberOf fabric.util\n     * @param  {Array} a First transformMatrix\n     * @param  {Array} b Second transformMatrix\n     * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices\n     * @return {Array} The product of the two transform matrices\n     */ multiplyTransformMatrices: function(a, b, is2x2) {\n            // Matrix multiply a * b\n            return [\n                a[0] * b[0] + a[2] * b[1],\n                a[1] * b[0] + a[3] * b[1],\n                a[0] * b[2] + a[2] * b[3],\n                a[1] * b[2] + a[3] * b[3],\n                is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],\n                is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]\n            ];\n        },\n        /**\n     * Decomposes standard 2x3 matrix into transform components\n     * @static\n     * @memberOf fabric.util\n     * @param  {Array} a transformMatrix\n     * @return {Object} Components of transform\n     */ qrDecompose: function(a) {\n            var angle = atan2(a[1], a[0]), denom = pow(a[0], 2) + pow(a[1], 2), scaleX = sqrt(denom), scaleY = (a[0] * a[3] - a[2] * a[1]) / scaleX, skewX = atan2(a[0] * a[2] + a[1] * a[3], denom);\n            return {\n                angle: angle / PiBy180,\n                scaleX: scaleX,\n                scaleY: scaleY,\n                skewX: skewX / PiBy180,\n                skewY: 0,\n                translateX: a[4],\n                translateY: a[5]\n            };\n        },\n        /**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.angle] angle in degrees\n     * @return {Number[]} transform matrix\n     */ calcRotateMatrix: function(options) {\n            if (!options.angle) {\n                return fabric.iMatrix.concat();\n            }\n            var theta = fabric.util.degreesToRadians(options.angle), cos = fabric.util.cos(theta), sin = fabric.util.sin(theta);\n            return [\n                cos,\n                sin,\n                -sin,\n                cos,\n                0,\n                0\n            ];\n        },\n        /**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet.\n     * is called DimensionsTransformMatrix because those properties are the one that influence\n     * the size of the resulting box of the object.\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.scaleX]\n     * @param  {Number} [options.scaleY]\n     * @param  {Boolean} [options.flipX]\n     * @param  {Boolean} [options.flipY]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.skewY]\n     * @return {Number[]} transform matrix\n     */ calcDimensionsMatrix: function(options) {\n            var scaleX = typeof options.scaleX === \"undefined\" ? 1 : options.scaleX, scaleY = typeof options.scaleY === \"undefined\" ? 1 : options.scaleY, scaleMatrix = [\n                options.flipX ? -scaleX : scaleX,\n                0,\n                0,\n                options.flipY ? -scaleY : scaleY,\n                0,\n                0\n            ], multiply = fabric.util.multiplyTransformMatrices, degreesToRadians = fabric.util.degreesToRadians;\n            if (options.skewX) {\n                scaleMatrix = multiply(scaleMatrix, [\n                    1,\n                    0,\n                    Math.tan(degreesToRadians(options.skewX)),\n                    1\n                ], true);\n            }\n            if (options.skewY) {\n                scaleMatrix = multiply(scaleMatrix, [\n                    1,\n                    Math.tan(degreesToRadians(options.skewY)),\n                    0,\n                    1\n                ], true);\n            }\n            return scaleMatrix;\n        },\n        /**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.angle]\n     * @param  {Number} [options.scaleX]\n     * @param  {Number} [options.scaleY]\n     * @param  {Boolean} [options.flipX]\n     * @param  {Boolean} [options.flipY]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.translateX]\n     * @param  {Number} [options.translateY]\n     * @return {Number[]} transform matrix\n     */ composeMatrix: function(options) {\n            var matrix = [\n                1,\n                0,\n                0,\n                1,\n                options.translateX || 0,\n                options.translateY || 0\n            ], multiply = fabric.util.multiplyTransformMatrices;\n            if (options.angle) {\n                matrix = multiply(matrix, fabric.util.calcRotateMatrix(options));\n            }\n            if (options.scaleX !== 1 || options.scaleY !== 1 || options.skewX || options.skewY || options.flipX || options.flipY) {\n                matrix = multiply(matrix, fabric.util.calcDimensionsMatrix(options));\n            }\n            return matrix;\n        },\n        /**\n     * reset an object transform state to neutral. Top and left are not accounted for\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Object} target object to transform\n     */ resetObjectTransform: function(target) {\n            target.scaleX = 1;\n            target.scaleY = 1;\n            target.skewX = 0;\n            target.skewY = 0;\n            target.flipX = false;\n            target.flipY = false;\n            target.rotate(0);\n        },\n        /**\n     * Extract Object transform values\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Object} target object to read from\n     * @return {Object} Components of transform\n     */ saveObjectTransform: function(target) {\n            return {\n                scaleX: target.scaleX,\n                scaleY: target.scaleY,\n                skewX: target.skewX,\n                skewY: target.skewY,\n                angle: target.angle,\n                left: target.left,\n                flipX: target.flipX,\n                flipY: target.flipY,\n                top: target.top\n            };\n        },\n        /**\n     * Returns true if context has transparent pixel\n     * at specified location (taking tolerance into account)\n     * @param {CanvasRenderingContext2D} ctx context\n     * @param {Number} x x coordinate\n     * @param {Number} y y coordinate\n     * @param {Number} tolerance Tolerance\n     */ isTransparent: function(ctx, x, y, tolerance) {\n            // If tolerance is > 0 adjust start coords to take into account.\n            // If moves off Canvas fix to 0\n            if (tolerance > 0) {\n                if (x > tolerance) {\n                    x -= tolerance;\n                } else {\n                    x = 0;\n                }\n                if (y > tolerance) {\n                    y -= tolerance;\n                } else {\n                    y = 0;\n                }\n            }\n            var _isTransparent = true, i, temp, imageData = ctx.getImageData(x, y, tolerance * 2 || 1, tolerance * 2 || 1), l = imageData.data.length;\n            // Split image data - for tolerance > 1, pixelDataSize = 4;\n            for(i = 3; i < l; i += 4){\n                temp = imageData.data[i];\n                _isTransparent = temp <= 0;\n                if (_isTransparent === false) {\n                    break; // Stop if colour found\n                }\n            }\n            imageData = null;\n            return _isTransparent;\n        },\n        /**\n     * Parse preserveAspectRatio attribute from element\n     * @param {string} attribute to be parsed\n     * @return {Object} an object containing align and meetOrSlice attribute\n     */ parsePreserveAspectRatioAttribute: function(attribute) {\n            var meetOrSlice = \"meet\", alignX = \"Mid\", alignY = \"Mid\", aspectRatioAttrs = attribute.split(\" \"), align;\n            if (aspectRatioAttrs && aspectRatioAttrs.length) {\n                meetOrSlice = aspectRatioAttrs.pop();\n                if (meetOrSlice !== \"meet\" && meetOrSlice !== \"slice\") {\n                    align = meetOrSlice;\n                    meetOrSlice = \"meet\";\n                } else if (aspectRatioAttrs.length) {\n                    align = aspectRatioAttrs.pop();\n                }\n            }\n            //divide align in alignX and alignY\n            alignX = align !== \"none\" ? align.slice(1, 4) : \"none\";\n            alignY = align !== \"none\" ? align.slice(5, 8) : \"none\";\n            return {\n                meetOrSlice: meetOrSlice,\n                alignX: alignX,\n                alignY: alignY\n            };\n        },\n        /**\n     * Clear char widths cache for the given font family or all the cache if no\n     * fontFamily is specified.\n     * Use it if you know you are loading fonts in a lazy way and you are not waiting\n     * for custom fonts to load properly when adding text objects to the canvas.\n     * If a text object is added when its own font is not loaded yet, you will get wrong\n     * measurement and so wrong bounding boxes.\n     * After the font cache is cleared, either change the textObject text content or call\n     * initDimensions() to trigger a recalculation\n     * @memberOf fabric.util\n     * @param {String} [fontFamily] font family to clear\n     */ clearFabricFontCache: function(fontFamily) {\n            fontFamily = (fontFamily || \"\").toLowerCase();\n            if (!fontFamily) {\n                fabric.charWidthsCache = {};\n            } else if (fabric.charWidthsCache[fontFamily]) {\n                delete fabric.charWidthsCache[fontFamily];\n            }\n        },\n        /**\n     * Given current aspect ratio, determines the max width and height that can\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Number} ar aspect ratio\n     * @param {Number} maximumArea Maximum area you want to achieve\n     * @return {Object.x} Limited dimensions by X\n     * @return {Object.y} Limited dimensions by Y\n     */ limitDimsByArea: function(ar, maximumArea) {\n            var roughWidth = Math.sqrt(maximumArea * ar), perfLimitSizeY = Math.floor(maximumArea / roughWidth);\n            return {\n                x: Math.floor(roughWidth),\n                y: perfLimitSizeY\n            };\n        },\n        capValue: function(min, value, max) {\n            return Math.max(min, Math.min(value, max));\n        },\n        /**\n     * Finds the scale for the object source to fit inside the object destination,\n     * keeping aspect ratio intact.\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Object | fabric.Object} source\n     * @param {Number} source.height natural unscaled height of the object\n     * @param {Number} source.width natural unscaled width of the object\n     * @param {Object | fabric.Object} destination\n     * @param {Number} destination.height natural unscaled height of the object\n     * @param {Number} destination.width natural unscaled width of the object\n     * @return {Number} scale factor to apply to source to fit into destination\n     */ findScaleToFit: function(source, destination) {\n            return Math.min(destination.width / source.width, destination.height / source.height);\n        },\n        /**\n     * Finds the scale for the object source to cover entirely the object destination,\n     * keeping aspect ratio intact.\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Object | fabric.Object} source\n     * @param {Number} source.height natural unscaled height of the object\n     * @param {Number} source.width natural unscaled width of the object\n     * @param {Object | fabric.Object} destination\n     * @param {Number} destination.height natural unscaled height of the object\n     * @param {Number} destination.width natural unscaled width of the object\n     * @return {Number} scale factor to apply to source to cover destination\n     */ findScaleToCover: function(source, destination) {\n            return Math.max(destination.width / source.width, destination.height / source.height);\n        },\n        /**\n     * given an array of 6 number returns something like `\"matrix(...numbers)\"`\n     * @memberOf fabric.util\n     * @param {Array} transform an array with 6 numbers\n     * @return {String} transform matrix for svg\n     * @return {Object.y} Limited dimensions by Y\n     */ matrixToSVG: function(transform) {\n            return \"matrix(\" + transform.map(function(value) {\n                return fabric.util.toFixed(value, fabric.Object.NUM_FRACTION_DIGITS);\n            }).join(\" \") + \")\";\n        },\n        /**\n     * given an object and a transform, apply the inverse transform to the object,\n     * this is equivalent to remove from that object that transformation, so that\n     * added in a space with the removed transform, the object will be the same as before.\n     * Removing from an object a transform that scale by 2 is like scaling it by 1/2.\n     * Removing from an object a transfrom that rotate by 30deg is like rotating by 30deg\n     * in the opposite direction.\n     * This util is used to add objects inside transformed groups or nested groups.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */ removeTransformFromObject: function(object, transform) {\n            var inverted = fabric.util.invertTransform(transform), finalTransform = fabric.util.multiplyTransformMatrices(inverted, object.calcOwnMatrix());\n            fabric.util.applyTransformToObject(object, finalTransform);\n        },\n        /**\n     * given an object and a transform, apply the transform to the object.\n     * this is equivalent to change the space where the object is drawn.\n     * Adding to an object a transform that scale by 2 is like scaling it by 2.\n     * This is used when removing an object from an active selection for example.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */ addTransformToObject: function(object, transform) {\n            fabric.util.applyTransformToObject(object, fabric.util.multiplyTransformMatrices(transform, object.calcOwnMatrix()));\n        },\n        /**\n     * discard an object transform state and apply the one from the matrix.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */ applyTransformToObject: function(object, transform) {\n            var options = fabric.util.qrDecompose(transform), center = new fabric.Point(options.translateX, options.translateY);\n            object.flipX = false;\n            object.flipY = false;\n            object.set(\"scaleX\", options.scaleX);\n            object.set(\"scaleY\", options.scaleY);\n            object.skewX = options.skewX;\n            object.skewY = options.skewY;\n            object.angle = options.angle;\n            object.setPositionByOrigin(center, \"center\", \"center\");\n        },\n        /**\n     * given a width and height, return the size of the bounding box\n     * that can contains the box with width/height with applied transform\n     * described in options.\n     * Use to calculate the boxes around objects for controls.\n     * @memberOf fabric.util\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Object} options\n     * @param {Number} options.scaleX\n     * @param {Number} options.scaleY\n     * @param {Number} options.skewX\n     * @param {Number} options.skewY\n     * @return {Object.x} width of containing\n     * @return {Object.y} height of containing\n     */ sizeAfterTransform: function(width, height, options) {\n            var dimX = width / 2, dimY = height / 2, points = [\n                {\n                    x: -dimX,\n                    y: -dimY\n                },\n                {\n                    x: dimX,\n                    y: -dimY\n                },\n                {\n                    x: -dimX,\n                    y: dimY\n                },\n                {\n                    x: dimX,\n                    y: dimY\n                }\n            ], transformMatrix = fabric.util.calcDimensionsMatrix(options), bbox = fabric.util.makeBoundingBoxFromPoints(points, transformMatrix);\n            return {\n                x: bbox.width,\n                y: bbox.height\n            };\n        },\n        /**\n     * Merges 2 clip paths into one visually equal clip path\n     *\n     * **IMPORTANT**:\\\n     * Does **NOT** clone the arguments, clone them proir if necessary.\n     *\n     * Creates a wrapper (group) that contains one clip path and is clipped by the other so content is kept where both overlap.\n     * Use this method if both the clip paths may have nested clip paths of their own, so assigning one to the other's clip path property is not possible.\n     *\n     * In order to handle the `inverted` property we follow logic described in the following cases:\\\n     * **(1)** both clip paths are inverted - the clip paths pass the inverted prop to the wrapper and loose it themselves.\\\n     * **(2)** one is inverted and the other isn't - the wrapper shouldn't become inverted and the inverted clip path must clip the non inverted one to produce an identical visual effect.\\\n     * **(3)** both clip paths are not inverted - wrapper and clip paths remain unchanged.\n     *\n     * @memberOf fabric.util\n     * @param {fabric.Object} c1\n     * @param {fabric.Object} c2\n     * @returns {fabric.Object} merged clip path\n     */ mergeClipPaths: function(c1, c2) {\n            var a = c1, b = c2;\n            if (a.inverted && !b.inverted) {\n                //  case (2)\n                a = c2;\n                b = c1;\n            }\n            //  `b` becomes `a`'s clip path so we transform `b` to `a` coordinate plane\n            fabric.util.applyTransformToObject(b, fabric.util.multiplyTransformMatrices(fabric.util.invertTransform(a.calcTransformMatrix()), b.calcTransformMatrix()));\n            //  assign the `inverted` prop to the wrapping group\n            var inverted = a.inverted && b.inverted;\n            if (inverted) {\n                //  case (1)\n                a.inverted = b.inverted = false;\n            }\n            return new fabric.Group([\n                a\n            ], {\n                clipPath: b,\n                inverted: inverted\n            });\n        },\n        /**\n     * @memberOf fabric.util\n     * @param {Object} prevStyle first style to compare\n     * @param {Object} thisStyle second style to compare\n     * @param {boolean} forTextSpans whether to check overline, underline, and line-through properties\n     * @return {boolean} true if the style changed\n     */ hasStyleChanged: function(prevStyle, thisStyle, forTextSpans) {\n            forTextSpans = forTextSpans || false;\n            return prevStyle.fill !== thisStyle.fill || prevStyle.stroke !== thisStyle.stroke || prevStyle.strokeWidth !== thisStyle.strokeWidth || prevStyle.fontSize !== thisStyle.fontSize || prevStyle.fontFamily !== thisStyle.fontFamily || prevStyle.fontWeight !== thisStyle.fontWeight || prevStyle.fontStyle !== thisStyle.fontStyle || prevStyle.textBackgroundColor !== thisStyle.textBackgroundColor || prevStyle.deltaY !== thisStyle.deltaY || forTextSpans && (prevStyle.overline !== thisStyle.overline || prevStyle.underline !== thisStyle.underline || prevStyle.linethrough !== thisStyle.linethrough);\n        },\n        /**\n     * Returns the array form of a text object's inline styles property with styles grouped in ranges\n     * rather than per character. This format is less verbose, and is better suited for storage\n     * so it is used in serialization (not during runtime).\n     * @memberOf fabric.util\n     * @param {object} styles per character styles for a text object\n     * @param {String} text the text string that the styles are applied to\n     * @return {{start: number, end: number, style: object}[]}\n     */ stylesToArray: function(styles, text) {\n            // clone style structure to prevent mutation\n            var styles = fabric.util.object.clone(styles, true), textLines = text.split(\"\\n\"), charIndex = -1, prevStyle = {}, stylesArray = [];\n            //loop through each textLine\n            for(var i = 0; i < textLines.length; i++){\n                if (!styles[i]) {\n                    //no styles exist for this line, so add the line's length to the charIndex total\n                    charIndex += textLines[i].length;\n                    continue;\n                }\n                //loop through each character of the current line\n                for(var c = 0; c < textLines[i].length; c++){\n                    charIndex++;\n                    var thisStyle = styles[i][c];\n                    //check if style exists for this character\n                    if (thisStyle && Object.keys(thisStyle).length > 0) {\n                        var styleChanged = fabric.util.hasStyleChanged(prevStyle, thisStyle, true);\n                        if (styleChanged) {\n                            stylesArray.push({\n                                start: charIndex,\n                                end: charIndex + 1,\n                                style: thisStyle\n                            });\n                        } else {\n                            //if style is the same as previous character, increase end index\n                            stylesArray[stylesArray.length - 1].end++;\n                        }\n                    }\n                    prevStyle = thisStyle || {};\n                }\n            }\n            return stylesArray;\n        },\n        /**\n     * Returns the object form of the styles property with styles that are assigned per\n     * character rather than grouped by range. This format is more verbose, and is\n     * only used during runtime (not for serialization/storage)\n     * @memberOf fabric.util\n     * @param {Array} styles the serialized form of a text object's styles\n     * @param {String} text the text string that the styles are applied to\n     * @return {Object}\n     */ stylesFromArray: function(styles, text) {\n            if (!Array.isArray(styles)) {\n                return styles;\n            }\n            var textLines = text.split(\"\\n\"), charIndex = -1, styleIndex = 0, stylesObject = {};\n            //loop through each textLine\n            for(var i = 0; i < textLines.length; i++){\n                //loop through each character of the current line\n                for(var c = 0; c < textLines[i].length; c++){\n                    charIndex++;\n                    //check if there's a style collection that includes the current character\n                    if (styles[styleIndex] && styles[styleIndex].start <= charIndex && charIndex < styles[styleIndex].end) {\n                        //create object for line index if it doesn't exist\n                        stylesObject[i] = stylesObject[i] || {};\n                        //assign a style at this character's index\n                        stylesObject[i][c] = Object.assign({}, styles[styleIndex].style);\n                        //if character is at the end of the current style collection, move to the next\n                        if (charIndex === styles[styleIndex].end - 1) {\n                            styleIndex++;\n                        }\n                    }\n                }\n            }\n            return stylesObject;\n        }\n    };\n})( true ? exports : 0);\n(function() {\n    var _join = Array.prototype.join, commandLengths = {\n        m: 2,\n        l: 2,\n        h: 1,\n        v: 1,\n        c: 6,\n        s: 4,\n        q: 4,\n        t: 2,\n        a: 7\n    }, repeatedCommands = {\n        m: \"l\",\n        M: \"L\"\n    };\n    function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {\n        var costh2 = fabric.util.cos(th2), sinth2 = fabric.util.sin(th2), costh3 = fabric.util.cos(th3), sinth3 = fabric.util.sin(th3), toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1, toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1, cp1X = fromX + mT * (-cosTh * rx * sinth2 - sinTh * ry * costh2), cp1Y = fromY + mT * (-sinTh * rx * sinth2 + cosTh * ry * costh2), cp2X = toX + mT * (cosTh * rx * sinth3 + sinTh * ry * costh3), cp2Y = toY + mT * (sinTh * rx * sinth3 - cosTh * ry * costh3);\n        return [\n            \"C\",\n            cp1X,\n            cp1Y,\n            cp2X,\n            cp2Y,\n            toX,\n            toY\n        ];\n    }\n    /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp\n   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here\n   * http://mozilla.org/MPL/2.0/\n   */ function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {\n        var PI = Math.PI, th = rotateX * PI / 180, sinTh = fabric.util.sin(th), cosTh = fabric.util.cos(th), fromX = 0, fromY = 0;\n        rx = Math.abs(rx);\n        ry = Math.abs(ry);\n        var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5, py = -cosTh * toY * 0.5 + sinTh * toX * 0.5, rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px, pl = rx2 * ry2 - rx2 * py2 - ry2 * px2, root = 0;\n        if (pl < 0) {\n            var s = Math.sqrt(1 - pl / (rx2 * ry2));\n            rx *= s;\n            ry *= s;\n        } else {\n            root = (large === sweep ? -1.0 : 1.0) * Math.sqrt(pl / (rx2 * py2 + ry2 * px2));\n        }\n        var cx = root * rx * py / ry, cy = -root * ry * px / rx, cx1 = cosTh * cx - sinTh * cy + toX * 0.5, cy1 = sinTh * cx + cosTh * cy + toY * 0.5, mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry), dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);\n        if (sweep === 0 && dtheta > 0) {\n            dtheta -= 2 * PI;\n        } else if (sweep === 1 && dtheta < 0) {\n            dtheta += 2 * PI;\n        }\n        // Convert into cubic bezier segments <= 90deg\n        var segments = Math.ceil(Math.abs(dtheta / PI * 2)), result = [], mDelta = dtheta / segments, mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2), th3 = mTheta + mDelta;\n        for(var i = 0; i < segments; i++){\n            result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);\n            fromX = result[i][5];\n            fromY = result[i][6];\n            mTheta = th3;\n            th3 += mDelta;\n        }\n        return result;\n    }\n    /*\n   * Private\n   */ function calcVectorAngle(ux, uy, vx, vy) {\n        var ta = Math.atan2(uy, ux), tb = Math.atan2(vy, vx);\n        if (tb >= ta) {\n            return tb - ta;\n        } else {\n            return 2 * Math.PI - (ta - tb);\n        }\n    }\n    /**\n   * Calculate bounding box of a beziercurve\n   * @param {Number} x0 starting point\n   * @param {Number} y0\n   * @param {Number} x1 first control point\n   * @param {Number} y1\n   * @param {Number} x2 secondo control point\n   * @param {Number} y2\n   * @param {Number} x3 end of bezier\n   * @param {Number} y3\n   */ // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.\n    // TODO: can we normalize this with the starting points set at 0 and then translated the bbox?\n    function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {\n        var argsString;\n        if (fabric.cachesBoundsOfCurve) {\n            argsString = _join.call(arguments);\n            if (fabric.boundsOfCurveCache[argsString]) {\n                return fabric.boundsOfCurveCache[argsString];\n            }\n        }\n        var sqrt = Math.sqrt, min = Math.min, max = Math.max, abs = Math.abs, tvalues = [], bounds = [\n            [],\n            []\n        ], a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n        for(var i = 0; i < 2; ++i){\n            if (i > 0) {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n            if (abs(a) < 1e-12) {\n                if (abs(b) < 1e-12) {\n                    continue;\n                }\n                t = -c / b;\n                if (0 < t && t < 1) {\n                    tvalues.push(t);\n                }\n                continue;\n            }\n            b2ac = b * b - 4 * c * a;\n            if (b2ac < 0) {\n                continue;\n            }\n            sqrtb2ac = sqrt(b2ac);\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if (0 < t1 && t1 < 1) {\n                tvalues.push(t1);\n            }\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if (0 < t2 && t2 < 1) {\n                tvalues.push(t2);\n            }\n        }\n        var x, y, j = tvalues.length, jlen = j, mt;\n        while(j--){\n            t = tvalues[j];\n            mt = 1 - t;\n            x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n            bounds[0][j] = x;\n            y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n            bounds[1][j] = y;\n        }\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n        var result = [\n            {\n                x: min.apply(null, bounds[0]),\n                y: min.apply(null, bounds[1])\n            },\n            {\n                x: max.apply(null, bounds[0]),\n                y: max.apply(null, bounds[1])\n            }\n        ];\n        if (fabric.cachesBoundsOfCurve) {\n            fabric.boundsOfCurveCache[argsString] = result;\n        }\n        return result;\n    }\n    /**\n   * Converts arc to a bunch of bezier curves\n   * @param {Number} fx starting point x\n   * @param {Number} fy starting point y\n   * @param {Array} coords Arc command\n   */ function fromArcToBeziers(fx, fy, coords) {\n        var rx = coords[1], ry = coords[2], rot = coords[3], large = coords[4], sweep = coords[5], tx = coords[6], ty = coords[7], segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);\n        for(var i = 0, len = segsNorm.length; i < len; i++){\n            segsNorm[i][1] += fx;\n            segsNorm[i][2] += fy;\n            segsNorm[i][3] += fx;\n            segsNorm[i][4] += fy;\n            segsNorm[i][5] += fx;\n            segsNorm[i][6] += fy;\n        }\n        return segsNorm;\n    }\n    ;\n    /**\n   * This function take a parsed SVG path and make it simpler for fabricJS logic.\n   * simplification consist of: only UPPERCASE absolute commands ( relative converted to absolute )\n   * S converted in C, T converted in Q, A converted in C.\n   * @param {Array} path the array of commands of a parsed svg path for fabric.Path\n   * @return {Array} the simplified array of commands of a parsed svg path for fabric.Path\n   */ function makePathSimpler(path) {\n        // x and y represent the last point of the path. the previous command point.\n        // we add them to each relative command to make it an absolute comment.\n        // we also swap the v V h H with L, because are easier to transform.\n        var x = 0, y = 0, len = path.length, // x1 and y1 represent the last point of the subpath. the subpath is started with\n        // m or M command. When a z or Z command is drawn, x and y need to be resetted to\n        // the last x1 and y1.\n        x1 = 0, y1 = 0, current, i, converted, // previous will host the letter of the previous command, to handle S and T.\n        // controlX and controlY will host the previous reflected control point\n        destinationPath = [], previous, controlX, controlY;\n        for(i = 0; i < len; ++i){\n            converted = false;\n            current = path[i].slice(0);\n            switch(current[0]){\n                case \"l\":\n                    current[0] = \"L\";\n                    current[1] += x;\n                    current[2] += y;\n                // falls through\n                case \"L\":\n                    x = current[1];\n                    y = current[2];\n                    break;\n                case \"h\":\n                    current[1] += x;\n                // falls through\n                case \"H\":\n                    current[0] = \"L\";\n                    current[2] = y;\n                    x = current[1];\n                    break;\n                case \"v\":\n                    current[1] += y;\n                // falls through\n                case \"V\":\n                    current[0] = \"L\";\n                    y = current[1];\n                    current[1] = x;\n                    current[2] = y;\n                    break;\n                case \"m\":\n                    current[0] = \"M\";\n                    current[1] += x;\n                    current[2] += y;\n                // falls through\n                case \"M\":\n                    x = current[1];\n                    y = current[2];\n                    x1 = current[1];\n                    y1 = current[2];\n                    break;\n                case \"c\":\n                    current[0] = \"C\";\n                    current[1] += x;\n                    current[2] += y;\n                    current[3] += x;\n                    current[4] += y;\n                    current[5] += x;\n                    current[6] += y;\n                // falls through\n                case \"C\":\n                    controlX = current[3];\n                    controlY = current[4];\n                    x = current[5];\n                    y = current[6];\n                    break;\n                case \"s\":\n                    current[0] = \"S\";\n                    current[1] += x;\n                    current[2] += y;\n                    current[3] += x;\n                    current[4] += y;\n                // falls through\n                case \"S\":\n                    // would be sScC but since we are swapping sSc for C, we check just that.\n                    if (previous === \"C\") {\n                        // calculate reflection of previous control points\n                        controlX = 2 * x - controlX;\n                        controlY = 2 * y - controlY;\n                    } else {\n                        // If there is no previous command or if the previous command was not a C, c, S, or s,\n                        // the control point is coincident with the current point\n                        controlX = x;\n                        controlY = y;\n                    }\n                    x = current[3];\n                    y = current[4];\n                    current[0] = \"C\";\n                    current[5] = current[3];\n                    current[6] = current[4];\n                    current[3] = current[1];\n                    current[4] = current[2];\n                    current[1] = controlX;\n                    current[2] = controlY;\n                    // current[3] and current[4] are NOW the second control point.\n                    // we keep it for the next reflection.\n                    controlX = current[3];\n                    controlY = current[4];\n                    break;\n                case \"q\":\n                    current[0] = \"Q\";\n                    current[1] += x;\n                    current[2] += y;\n                    current[3] += x;\n                    current[4] += y;\n                // falls through\n                case \"Q\":\n                    controlX = current[1];\n                    controlY = current[2];\n                    x = current[3];\n                    y = current[4];\n                    break;\n                case \"t\":\n                    current[0] = \"T\";\n                    current[1] += x;\n                    current[2] += y;\n                // falls through\n                case \"T\":\n                    if (previous === \"Q\") {\n                        // calculate reflection of previous control point\n                        controlX = 2 * x - controlX;\n                        controlY = 2 * y - controlY;\n                    } else {\n                        // If there is no previous command or if the previous command was not a Q, q, T or t,\n                        // assume the control point is coincident with the current point\n                        controlX = x;\n                        controlY = y;\n                    }\n                    current[0] = \"Q\";\n                    x = current[1];\n                    y = current[2];\n                    current[1] = controlX;\n                    current[2] = controlY;\n                    current[3] = x;\n                    current[4] = y;\n                    break;\n                case \"a\":\n                    current[0] = \"A\";\n                    current[6] += x;\n                    current[7] += y;\n                // falls through\n                case \"A\":\n                    converted = true;\n                    destinationPath = destinationPath.concat(fromArcToBeziers(x, y, current));\n                    x = current[6];\n                    y = current[7];\n                    break;\n                case \"z\":\n                case \"Z\":\n                    x = x1;\n                    y = y1;\n                    break;\n                default:\n            }\n            if (!converted) {\n                destinationPath.push(current);\n            }\n            previous = current[0];\n        }\n        return destinationPath;\n    }\n    ;\n    /**\n   * Calc length from point x1,y1 to x2,y2\n   * @param {Number} x1 starting point x\n   * @param {Number} y1 starting point y\n   * @param {Number} x2 starting point x\n   * @param {Number} y2 starting point y\n   * @return {Number} length of segment\n   */ function calcLineLength(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    // functions for the Cubic beizer\n    // taken from: https://github.com/konvajs/konva/blob/7.0.5/src/shapes/Path.ts#L350\n    function CB1(t) {\n        return t * t * t;\n    }\n    function CB2(t) {\n        return 3 * t * t * (1 - t);\n    }\n    function CB3(t) {\n        return 3 * t * (1 - t) * (1 - t);\n    }\n    function CB4(t) {\n        return (1 - t) * (1 - t) * (1 - t);\n    }\n    function getPointOnCubicBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        return function(pct) {\n            var c1 = CB1(pct), c2 = CB2(pct), c3 = CB3(pct), c4 = CB4(pct);\n            return {\n                x: p4x * c1 + p3x * c2 + p2x * c3 + p1x * c4,\n                y: p4y * c1 + p3y * c2 + p2y * c3 + p1y * c4\n            };\n        };\n    }\n    function getTangentCubicIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        return function(pct) {\n            var invT = 1 - pct, tangentX = 3 * invT * invT * (p2x - p1x) + 6 * invT * pct * (p3x - p2x) + 3 * pct * pct * (p4x - p3x), tangentY = 3 * invT * invT * (p2y - p1y) + 6 * invT * pct * (p3y - p2y) + 3 * pct * pct * (p4y - p3y);\n            return Math.atan2(tangentY, tangentX);\n        };\n    }\n    function QB1(t) {\n        return t * t;\n    }\n    function QB2(t) {\n        return 2 * t * (1 - t);\n    }\n    function QB3(t) {\n        return (1 - t) * (1 - t);\n    }\n    function getPointOnQuadraticBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y) {\n        return function(pct) {\n            var c1 = QB1(pct), c2 = QB2(pct), c3 = QB3(pct);\n            return {\n                x: p3x * c1 + p2x * c2 + p1x * c3,\n                y: p3y * c1 + p2y * c2 + p1y * c3\n            };\n        };\n    }\n    function getTangentQuadraticIterator(p1x, p1y, p2x, p2y, p3x, p3y) {\n        return function(pct) {\n            var invT = 1 - pct, tangentX = 2 * invT * (p2x - p1x) + 2 * pct * (p3x - p2x), tangentY = 2 * invT * (p2y - p1y) + 2 * pct * (p3y - p2y);\n            return Math.atan2(tangentY, tangentX);\n        };\n    }\n    // this will run over a path segment ( a cubic or quadratic segment) and approximate it\n    // with 100 segemnts. This will good enough to calculate the length of the curve\n    function pathIterator(iterator, x1, y1) {\n        var tempP = {\n            x: x1,\n            y: y1\n        }, p, tmpLen = 0, perc;\n        for(perc = 1; perc <= 100; perc += 1){\n            p = iterator(perc / 100);\n            tmpLen += calcLineLength(tempP.x, tempP.y, p.x, p.y);\n            tempP = p;\n        }\n        return tmpLen;\n    }\n    /**\n   * Given a pathInfo, and a distance in pixels, find the percentage from 0 to 1\n   * that correspond to that pixels run over the path.\n   * The percentage will be then used to find the correct point on the canvas for the path.\n   * @param {Array} segInfo fabricJS collection of information on a parsed path\n   * @param {Number} distance from starting point, in pixels.\n   * @return {Object} info object with x and y ( the point on canvas ) and angle, the tangent on that point;\n   */ function findPercentageForDistance(segInfo, distance) {\n        var perc = 0, tmpLen = 0, iterator = segInfo.iterator, tempP = {\n            x: segInfo.x,\n            y: segInfo.y\n        }, p, nextLen, nextStep = 0.01, angleFinder = segInfo.angleFinder, lastPerc;\n        // nextStep > 0.0001 covers 0.00015625 that 1/64th of 1/100\n        // the path\n        while(tmpLen < distance && nextStep > 0.0001){\n            p = iterator(perc);\n            lastPerc = perc;\n            nextLen = calcLineLength(tempP.x, tempP.y, p.x, p.y);\n            // compare tmpLen each cycle with distance, decide next perc to test.\n            if (nextLen + tmpLen > distance) {\n                // we discard this step and we make smaller steps.\n                perc -= nextStep;\n                nextStep /= 2;\n            } else {\n                tempP = p;\n                perc += nextStep;\n                tmpLen += nextLen;\n            }\n        }\n        p.angle = angleFinder(lastPerc);\n        return p;\n    }\n    /**\n   * Run over a parsed and simplifed path and extrac some informations.\n   * informations are length of each command and starting point\n   * @param {Array} path fabricJS parsed path commands\n   * @return {Array} path commands informations\n   */ function getPathSegmentsInfo(path) {\n        var totalLength = 0, len = path.length, current, //x2 and y2 are the coords of segment start\n        //x1 and y1 are the coords of the current point\n        x1 = 0, y1 = 0, x2 = 0, y2 = 0, info = [], iterator, tempInfo, angleFinder;\n        for(var i = 0; i < len; i++){\n            current = path[i];\n            tempInfo = {\n                x: x1,\n                y: y1,\n                command: current[0]\n            };\n            switch(current[0]){\n                case \"M\":\n                    tempInfo.length = 0;\n                    x2 = x1 = current[1];\n                    y2 = y1 = current[2];\n                    break;\n                case \"L\":\n                    tempInfo.length = calcLineLength(x1, y1, current[1], current[2]);\n                    x1 = current[1];\n                    y1 = current[2];\n                    break;\n                case \"C\":\n                    iterator = getPointOnCubicBezierIterator(x1, y1, current[1], current[2], current[3], current[4], current[5], current[6]);\n                    angleFinder = getTangentCubicIterator(x1, y1, current[1], current[2], current[3], current[4], current[5], current[6]);\n                    tempInfo.iterator = iterator;\n                    tempInfo.angleFinder = angleFinder;\n                    tempInfo.length = pathIterator(iterator, x1, y1);\n                    x1 = current[5];\n                    y1 = current[6];\n                    break;\n                case \"Q\":\n                    iterator = getPointOnQuadraticBezierIterator(x1, y1, current[1], current[2], current[3], current[4]);\n                    angleFinder = getTangentQuadraticIterator(x1, y1, current[1], current[2], current[3], current[4]);\n                    tempInfo.iterator = iterator;\n                    tempInfo.angleFinder = angleFinder;\n                    tempInfo.length = pathIterator(iterator, x1, y1);\n                    x1 = current[3];\n                    y1 = current[4];\n                    break;\n                case \"Z\":\n                case \"z\":\n                    // we add those in order to ease calculations later\n                    tempInfo.destX = x2;\n                    tempInfo.destY = y2;\n                    tempInfo.length = calcLineLength(x1, y1, x2, y2);\n                    x1 = x2;\n                    y1 = y2;\n                    break;\n            }\n            totalLength += tempInfo.length;\n            info.push(tempInfo);\n        }\n        info.push({\n            length: totalLength,\n            x: x1,\n            y: y1\n        });\n        return info;\n    }\n    function getPointOnPath(path, distance, infos) {\n        if (!infos) {\n            infos = getPathSegmentsInfo(path);\n        }\n        var i = 0;\n        while(distance - infos[i].length > 0 && i < infos.length - 2){\n            distance -= infos[i].length;\n            i++;\n        }\n        // var distance = infos[infos.length - 1] * perc;\n        var segInfo = infos[i], segPercent = distance / segInfo.length, command = segInfo.command, segment = path[i], info;\n        switch(command){\n            case \"M\":\n                return {\n                    x: segInfo.x,\n                    y: segInfo.y,\n                    angle: 0\n                };\n            case \"Z\":\n            case \"z\":\n                info = new fabric.Point(segInfo.x, segInfo.y).lerp(new fabric.Point(segInfo.destX, segInfo.destY), segPercent);\n                info.angle = Math.atan2(segInfo.destY - segInfo.y, segInfo.destX - segInfo.x);\n                return info;\n            case \"L\":\n                info = new fabric.Point(segInfo.x, segInfo.y).lerp(new fabric.Point(segment[1], segment[2]), segPercent);\n                info.angle = Math.atan2(segment[2] - segInfo.y, segment[1] - segInfo.x);\n                return info;\n            case \"C\":\n                return findPercentageForDistance(segInfo, distance);\n            case \"Q\":\n                return findPercentageForDistance(segInfo, distance);\n        }\n    }\n    /**\n   *\n   * @param {string} pathString\n   * @return {(string|number)[][]} An array of SVG path commands\n   * @example <caption>Usage</caption>\n   * parsePath('M 3 4 Q 3 5 2 1 4 0 Q 9 12 2 1 4 0') === [\n   *   ['M', 3, 4],\n   *   ['Q', 3, 5, 2, 1, 4, 0],\n   *   ['Q', 9, 12, 2, 1, 4, 0],\n   * ];\n   *\n   */ function parsePath(pathString) {\n        var result = [], coords = [], currentPath, parsed, re = fabric.rePathCommand, rNumber = \"[-+]?(?:\\\\d*\\\\.\\\\d+|\\\\d+\\\\.?)(?:[eE][-+]?\\\\d+)?\\\\s*\", rNumberCommaWsp = \"(\" + rNumber + \")\" + fabric.commaWsp, rFlagCommaWsp = \"([01])\" + fabric.commaWsp + \"?\", rArcSeq = rNumberCommaWsp + \"?\" + rNumberCommaWsp + \"?\" + rNumberCommaWsp + rFlagCommaWsp + rFlagCommaWsp + rNumberCommaWsp + \"?(\" + rNumber + \")\", regArcArgumentSequence = new RegExp(rArcSeq, \"g\"), match, coordsStr, // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)\n        path;\n        if (!pathString || !pathString.match) {\n            return result;\n        }\n        path = pathString.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);\n        for(var i = 0, coordsParsed, len = path.length; i < len; i++){\n            currentPath = path[i];\n            coordsStr = currentPath.slice(1).trim();\n            coords.length = 0;\n            var command = currentPath.charAt(0);\n            coordsParsed = [\n                command\n            ];\n            if (command.toLowerCase() === \"a\") {\n                // arcs have special flags that apparently don't require spaces so handle special\n                for(var args; args = regArcArgumentSequence.exec(coordsStr);){\n                    for(var j = 1; j < args.length; j++){\n                        coords.push(args[j]);\n                    }\n                }\n            } else {\n                while(match = re.exec(coordsStr)){\n                    coords.push(match[0]);\n                }\n            }\n            for(var j = 0, jlen = coords.length; j < jlen; j++){\n                parsed = parseFloat(coords[j]);\n                if (!isNaN(parsed)) {\n                    coordsParsed.push(parsed);\n                }\n            }\n            var commandLength = commandLengths[command.toLowerCase()], repeatedCommand = repeatedCommands[command] || command;\n            if (coordsParsed.length - 1 > commandLength) {\n                for(var k = 1, klen = coordsParsed.length; k < klen; k += commandLength){\n                    result.push([\n                        command\n                    ].concat(coordsParsed.slice(k, k + commandLength)));\n                    command = repeatedCommand;\n                }\n            } else {\n                result.push(coordsParsed);\n            }\n        }\n        return result;\n    }\n    ;\n    /**\n   *\n   * Converts points to a smooth SVG path\n   * @param {{ x: number,y: number }[]} points Array of points\n   * @param {number} [correction] Apply a correction to the path (usually we use `width / 1000`). If value is undefined 0 is used as the correction value.\n   * @return {(string|number)[][]} An array of SVG path commands\n   */ function getSmoothPathFromPoints(points, correction) {\n        var path = [], i, p1 = new fabric.Point(points[0].x, points[0].y), p2 = new fabric.Point(points[1].x, points[1].y), len = points.length, multSignX = 1, multSignY = 0, manyPoints = len > 2;\n        correction = correction || 0;\n        if (manyPoints) {\n            multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;\n            multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;\n        }\n        path.push([\n            \"M\",\n            p1.x - multSignX * correction,\n            p1.y - multSignY * correction\n        ]);\n        for(i = 1; i < len; i++){\n            if (!p1.eq(p2)) {\n                var midPoint = p1.midPointFrom(p2);\n                // p1 is our bezier control point\n                // midpoint is our endpoint\n                // start point is p(i-1) value.\n                path.push([\n                    \"Q\",\n                    p1.x,\n                    p1.y,\n                    midPoint.x,\n                    midPoint.y\n                ]);\n            }\n            p1 = points[i];\n            if (i + 1 < points.length) {\n                p2 = points[i + 1];\n            }\n        }\n        if (manyPoints) {\n            multSignX = p1.x > points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;\n            multSignY = p1.y > points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;\n        }\n        path.push([\n            \"L\",\n            p1.x + multSignX * correction,\n            p1.y + multSignY * correction\n        ]);\n        return path;\n    }\n    /**\n   * Transform a path by transforming each segment.\n   * it has to be a simplified path or it won't work.\n   * WARNING: this depends from pathOffset for correct operation\n   * @param {Array} path fabricJS parsed and simplified path commands\n   * @param {Array} transform matrix that represent the transformation\n   * @param {Object} [pathOffset] the fabric.Path pathOffset\n   * @param {Number} pathOffset.x\n   * @param {Number} pathOffset.y\n   * @returns {Array} the transformed path\n   */ function transformPath(path, transform, pathOffset) {\n        if (pathOffset) {\n            transform = fabric.util.multiplyTransformMatrices(transform, [\n                1,\n                0,\n                0,\n                1,\n                -pathOffset.x,\n                -pathOffset.y\n            ]);\n        }\n        return path.map(function(pathSegment) {\n            var newSegment = pathSegment.slice(0), point = {};\n            for(var i = 1; i < pathSegment.length - 1; i += 2){\n                point.x = pathSegment[i];\n                point.y = pathSegment[i + 1];\n                point = fabric.util.transformPoint(point, transform);\n                newSegment[i] = point.x;\n                newSegment[i + 1] = point.y;\n            }\n            return newSegment;\n        });\n    }\n    /**\n   * Join path commands to go back to svg format\n   * @param {Array} pathData fabricJS parsed path commands\n   * @return {String} joined path 'M 0 0 L 20 30'\n   */ fabric.util.joinPath = function(pathData) {\n        return pathData.map(function(segment) {\n            return segment.join(\" \");\n        }).join(\" \");\n    };\n    fabric.util.parsePath = parsePath;\n    fabric.util.makePathSimpler = makePathSimpler;\n    fabric.util.getSmoothPathFromPoints = getSmoothPathFromPoints;\n    fabric.util.getPathSegmentsInfo = getPathSegmentsInfo;\n    fabric.util.getBoundsOfCurve = getBoundsOfCurve;\n    fabric.util.getPointOnPath = getPointOnPath;\n    fabric.util.transformPath = transformPath;\n})();\n(function() {\n    var slice = Array.prototype.slice;\n    /**\n   * Invokes method on all items in a given array\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} method Name of a method to invoke\n   * @return {Array}\n   */ function invoke(array, method) {\n        var args = slice.call(arguments, 2), result = [];\n        for(var i = 0, len = array.length; i < len; i++){\n            result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);\n        }\n        return result;\n    }\n    /**\n   * Finds maximum value in array (not necessarily \"first\" one)\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} byProperty\n   * @return {*}\n   */ function max(array, byProperty) {\n        return find(array, byProperty, function(value1, value2) {\n            return value1 >= value2;\n        });\n    }\n    /**\n   * Finds minimum value in array (not necessarily \"first\" one)\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} byProperty\n   * @return {*}\n   */ function min(array, byProperty) {\n        return find(array, byProperty, function(value1, value2) {\n            return value1 < value2;\n        });\n    }\n    /**\n   * @private\n   */ function fill(array, value) {\n        var k = array.length;\n        while(k--){\n            array[k] = value;\n        }\n        return array;\n    }\n    /**\n   * @private\n   */ function find(array, byProperty, condition) {\n        if (!array || array.length === 0) {\n            return;\n        }\n        var i = array.length - 1, result = byProperty ? array[i][byProperty] : array[i];\n        if (byProperty) {\n            while(i--){\n                if (condition(array[i][byProperty], result)) {\n                    result = array[i][byProperty];\n                }\n            }\n        } else {\n            while(i--){\n                if (condition(array[i], result)) {\n                    result = array[i];\n                }\n            }\n        }\n        return result;\n    }\n    /**\n   * @namespace fabric.util.array\n   */ fabric.util.array = {\n        fill: fill,\n        invoke: invoke,\n        min: min,\n        max: max\n    };\n})();\n(function() {\n    /**\n   * Copies all enumerable properties of one js object to another\n   * this does not and cannot compete with generic utils.\n   * Does not clone or extend fabric.Object subclasses.\n   * This is mostly for internal use and has extra handling for fabricJS objects\n   * it skips the canvas and group properties in deep cloning.\n   * @memberOf fabric.util.object\n   * @param {Object} destination Where to copy to\n   * @param {Object} source Where to copy from\n   * @param {Boolean} [deep] Whether to extend nested objects\n   * @return {Object}\n   */ function extend(destination, source, deep) {\n        // JScript DontEnum bug is not taken care of\n        // the deep clone is for internal use, is not meant to avoid\n        // javascript traps or cloning html element or self referenced objects.\n        if (deep) {\n            if (!fabric.isLikelyNode && source instanceof Element) {\n                // avoid cloning deep images, canvases,\n                destination = source;\n            } else if (source instanceof Array) {\n                destination = [];\n                for(var i = 0, len = source.length; i < len; i++){\n                    destination[i] = extend({}, source[i], deep);\n                }\n            } else if (source && typeof source === \"object\") {\n                for(var property in source){\n                    if (property === \"canvas\" || property === \"group\") {\n                        // we do not want to clone this props at all.\n                        // we want to keep the keys in the copy\n                        destination[property] = null;\n                    } else if (source.hasOwnProperty(property)) {\n                        destination[property] = extend({}, source[property], deep);\n                    }\n                }\n            } else {\n                // this sounds odd for an extend but is ok for recursive use\n                destination = source;\n            }\n        } else {\n            for(var property in source){\n                destination[property] = source[property];\n            }\n        }\n        return destination;\n    }\n    /**\n   * Creates an empty object and copies all enumerable properties of another object to it\n   * This method is mostly for internal use, and not intended for duplicating shapes in canvas. \n   * @memberOf fabric.util.object\n   * @param {Object} object Object to clone\n   * @param {Boolean} [deep] Whether to clone nested objects\n   * @return {Object}\n   */ //TODO: this function return an empty object if you try to clone null\n    function clone(object, deep) {\n        return extend({}, object, deep);\n    }\n    /** @namespace fabric.util.object */ fabric.util.object = {\n        extend: extend,\n        clone: clone\n    };\n    fabric.util.object.extend(fabric.util, fabric.Observable);\n})();\n(function() {\n    /**\n   * Camelizes a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to camelize\n   * @return {String} Camelized version of a string\n   */ function camelize(string) {\n        return string.replace(/-+(.)?/g, function(match, character) {\n            return character ? character.toUpperCase() : \"\";\n        });\n    }\n    /**\n   * Capitalizes a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to capitalize\n   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized\n   * and other letters stay untouched, if false first letter is capitalized\n   * and other letters are converted to lowercase.\n   * @return {String} Capitalized version of a string\n   */ function capitalize(string, firstLetterOnly) {\n        return string.charAt(0).toUpperCase() + (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());\n    }\n    /**\n   * Escapes XML in a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to escape\n   * @return {String} Escaped version of a string\n   */ function escapeXml(string) {\n        return string.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&apos;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n    /**\n   * Divide a string in the user perceived single units\n   * @memberOf fabric.util.string\n   * @param {String} textstring String to escape\n   * @return {Array} array containing the graphemes\n   */ function graphemeSplit(textstring) {\n        var i = 0, chr, graphemes = [];\n        for(i = 0, chr; i < textstring.length; i++){\n            if ((chr = getWholeChar(textstring, i)) === false) {\n                continue;\n            }\n            graphemes.push(chr);\n        }\n        return graphemes;\n    }\n    // taken from mdn in the charAt doc page.\n    function getWholeChar(str, i) {\n        var code = str.charCodeAt(i);\n        if (isNaN(code)) {\n            return \"\"; // Position not found\n        }\n        if (code < 0xD800 || code > 0xDFFF) {\n            return str.charAt(i);\n        }\n        // High surrogate (could change last hex to 0xDB7F to treat high private\n        // surrogates as single characters)\n        if (0xD800 <= code && code <= 0xDBFF) {\n            if (str.length <= i + 1) {\n                throw \"High surrogate without following low surrogate\";\n            }\n            var next = str.charCodeAt(i + 1);\n            if (0xDC00 > next || next > 0xDFFF) {\n                throw \"High surrogate without following low surrogate\";\n            }\n            return str.charAt(i) + str.charAt(i + 1);\n        }\n        // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n        if (i === 0) {\n            throw \"Low surrogate without preceding high surrogate\";\n        }\n        var prev = str.charCodeAt(i - 1);\n        // (could change last hex to 0xDB7F to treat high private\n        // surrogates as single characters)\n        if (0xD800 > prev || prev > 0xDBFF) {\n            throw \"Low surrogate without preceding high surrogate\";\n        }\n        // We can pass over low surrogates now as the second component\n        // in a pair which we have already processed\n        return false;\n    }\n    /**\n   * String utilities\n   * @namespace fabric.util.string\n   */ fabric.util.string = {\n        camelize: camelize,\n        capitalize: capitalize,\n        escapeXml: escapeXml,\n        graphemeSplit: graphemeSplit\n    };\n})();\n(function() {\n    var slice = Array.prototype.slice, emptyFunction = function() {}, IS_DONTENUM_BUGGY = function() {\n        for(var p in {\n            toString: 1\n        }){\n            if (p === \"toString\") {\n                return false;\n            }\n        }\n        return true;\n    }(), /** @ignore */ addMethods = function(klass, source, parent) {\n        for(var property in source){\n            if (property in klass.prototype && typeof klass.prototype[property] === \"function\" && (source[property] + \"\").indexOf(\"callSuper\") > -1) {\n                klass.prototype[property] = function(property) {\n                    return function() {\n                        var superclass = this.constructor.superclass;\n                        this.constructor.superclass = parent;\n                        var returnValue = source[property].apply(this, arguments);\n                        this.constructor.superclass = superclass;\n                        if (property !== \"initialize\") {\n                            return returnValue;\n                        }\n                    };\n                }(property);\n            } else {\n                klass.prototype[property] = source[property];\n            }\n            if (IS_DONTENUM_BUGGY) {\n                if (source.toString !== Object.prototype.toString) {\n                    klass.prototype.toString = source.toString;\n                }\n                if (source.valueOf !== Object.prototype.valueOf) {\n                    klass.prototype.valueOf = source.valueOf;\n                }\n            }\n        }\n    };\n    function Subclass() {}\n    function callSuper(methodName) {\n        var parentMethod = null, _this = this;\n        // climb prototype chain to find method not equal to callee's method\n        while(_this.constructor.superclass){\n            var superClassMethod = _this.constructor.superclass.prototype[methodName];\n            if (_this[methodName] !== superClassMethod) {\n                parentMethod = superClassMethod;\n                break;\n            }\n            // eslint-disable-next-line\n            _this = _this.constructor.superclass.prototype;\n        }\n        if (!parentMethod) {\n            return console.log(\"tried to callSuper \" + methodName + \", method not found in prototype chain\", this);\n        }\n        return arguments.length > 1 ? parentMethod.apply(this, slice.call(arguments, 1)) : parentMethod.call(this);\n    }\n    /**\n   * Helper for creation of \"classes\".\n   * @memberOf fabric.util\n   * @param {Function} [parent] optional \"Class\" to inherit from\n   * @param {Object} [properties] Properties shared by all instances of this class\n   *                  (be careful modifying objects defined here as this would affect all instances)\n   */ function createClass() {\n        var parent = null, properties = slice.call(arguments, 0);\n        if (typeof properties[0] === \"function\") {\n            parent = properties.shift();\n        }\n        function klass() {\n            this.initialize.apply(this, arguments);\n        }\n        klass.superclass = parent;\n        klass.subclasses = [];\n        if (parent) {\n            Subclass.prototype = parent.prototype;\n            klass.prototype = new Subclass();\n            parent.subclasses.push(klass);\n        }\n        for(var i = 0, length = properties.length; i < length; i++){\n            addMethods(klass, properties[i], parent);\n        }\n        if (!klass.prototype.initialize) {\n            klass.prototype.initialize = emptyFunction;\n        }\n        klass.prototype.constructor = klass;\n        klass.prototype.callSuper = callSuper;\n        return klass;\n    }\n    fabric.util.createClass = createClass;\n})();\n(function() {\n    // since ie11 can use addEventListener but they do not support options, i need to check\n    var couldUseAttachEvent = !!fabric.document.createElement(\"div\").attachEvent, touchEvents = [\n        \"touchstart\",\n        \"touchmove\",\n        \"touchend\"\n    ];\n    /**\n   * Adds an event listener to an element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {String} eventName\n   * @param {Function} handler\n   */ fabric.util.addListener = function(element, eventName, handler, options) {\n        element && element.addEventListener(eventName, handler, couldUseAttachEvent ? false : options);\n    };\n    /**\n   * Removes an event listener from an element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {String} eventName\n   * @param {Function} handler\n   */ fabric.util.removeListener = function(element, eventName, handler, options) {\n        element && element.removeEventListener(eventName, handler, couldUseAttachEvent ? false : options);\n    };\n    function getTouchInfo(event) {\n        var touchProp = event.changedTouches;\n        if (touchProp && touchProp[0]) {\n            return touchProp[0];\n        }\n        return event;\n    }\n    fabric.util.getPointer = function(event) {\n        var element = event.target, scroll = fabric.util.getScrollLeftTop(element), _evt = getTouchInfo(event);\n        return {\n            x: _evt.clientX + scroll.left,\n            y: _evt.clientY + scroll.top\n        };\n    };\n    fabric.util.isTouchEvent = function(event) {\n        return touchEvents.indexOf(event.type) > -1 || event.pointerType === \"touch\";\n    };\n})();\n(function() {\n    /**\n   * Cross-browser wrapper for setting element's style\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {Object} styles\n   * @return {HTMLElement} Element that was passed as a first argument\n   */ function setStyle(element, styles) {\n        var elementStyle = element.style;\n        if (!elementStyle) {\n            return element;\n        }\n        if (typeof styles === \"string\") {\n            element.style.cssText += \";\" + styles;\n            return styles.indexOf(\"opacity\") > -1 ? setOpacity(element, styles.match(/opacity:\\s*(\\d?\\.?\\d*)/)[1]) : element;\n        }\n        for(var property in styles){\n            if (property === \"opacity\") {\n                setOpacity(element, styles[property]);\n            } else {\n                var normalizedProperty = property === \"float\" || property === \"cssFloat\" ? typeof elementStyle.styleFloat === \"undefined\" ? \"cssFloat\" : \"styleFloat\" : property;\n                elementStyle.setProperty(normalizedProperty, styles[property]);\n            }\n        }\n        return element;\n    }\n    var parseEl = fabric.document.createElement(\"div\"), supportsOpacity = typeof parseEl.style.opacity === \"string\", supportsFilters = typeof parseEl.style.filter === \"string\", reOpacity = /alpha\\s*\\(\\s*opacity\\s*=\\s*([^\\)]+)\\)/, /** @ignore */ setOpacity = function(element) {\n        return element;\n    };\n    if (supportsOpacity) {\n        /** @ignore */ setOpacity = function(element, value) {\n            element.style.opacity = value;\n            return element;\n        };\n    } else if (supportsFilters) {\n        /** @ignore */ setOpacity = function(element, value) {\n            var es = element.style;\n            if (element.currentStyle && !element.currentStyle.hasLayout) {\n                es.zoom = 1;\n            }\n            if (reOpacity.test(es.filter)) {\n                value = value >= 0.9999 ? \"\" : \"alpha(opacity=\" + value * 100 + \")\";\n                es.filter = es.filter.replace(reOpacity, value);\n            } else {\n                es.filter += \" alpha(opacity=\" + value * 100 + \")\";\n            }\n            return element;\n        };\n    }\n    fabric.util.setStyle = setStyle;\n})();\n(function() {\n    var _slice = Array.prototype.slice;\n    /**\n   * Takes id and returns an element with that id (if one exists in a document)\n   * @memberOf fabric.util\n   * @param {String|HTMLElement} id\n   * @return {HTMLElement|null}\n   */ function getById(id) {\n        return typeof id === \"string\" ? fabric.document.getElementById(id) : id;\n    }\n    var sliceCanConvertNodelists, /**\n       * Converts an array-like object (e.g. arguments or NodeList) to an array\n       * @memberOf fabric.util\n       * @param {Object} arrayLike\n       * @return {Array}\n       */ toArray = function(arrayLike) {\n        return _slice.call(arrayLike, 0);\n    };\n    try {\n        sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;\n    } catch (err) {}\n    if (!sliceCanConvertNodelists) {\n        toArray = function(arrayLike) {\n            var arr = new Array(arrayLike.length), i = arrayLike.length;\n            while(i--){\n                arr[i] = arrayLike[i];\n            }\n            return arr;\n        };\n    }\n    /**\n   * Creates specified element with specified attributes\n   * @memberOf fabric.util\n   * @param {String} tagName Type of an element to create\n   * @param {Object} [attributes] Attributes to set on an element\n   * @return {HTMLElement} Newly created element\n   */ function makeElement(tagName, attributes) {\n        var el = fabric.document.createElement(tagName);\n        for(var prop in attributes){\n            if (prop === \"class\") {\n                el.className = attributes[prop];\n            } else if (prop === \"for\") {\n                el.htmlFor = attributes[prop];\n            } else {\n                el.setAttribute(prop, attributes[prop]);\n            }\n        }\n        return el;\n    }\n    /**\n   * Adds class to an element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to add class to\n   * @param {String} className Class to add to an element\n   */ function addClass(element, className) {\n        if (element && (\" \" + element.className + \" \").indexOf(\" \" + className + \" \") === -1) {\n            element.className += (element.className ? \" \" : \"\") + className;\n        }\n    }\n    /**\n   * Wraps element with another element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to wrap\n   * @param {HTMLElement|String} wrapper Element to wrap with\n   * @param {Object} [attributes] Attributes to set on a wrapper\n   * @return {HTMLElement} wrapper\n   */ function wrapElement(element, wrapper, attributes) {\n        if (typeof wrapper === \"string\") {\n            wrapper = makeElement(wrapper, attributes);\n        }\n        if (element.parentNode) {\n            element.parentNode.replaceChild(wrapper, element);\n        }\n        wrapper.appendChild(element);\n        return wrapper;\n    }\n    /**\n   * Returns element scroll offsets\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to operate on\n   * @return {Object} Object with left/top values\n   */ function getScrollLeftTop(element) {\n        var left = 0, top = 0, docElement = fabric.document.documentElement, body = fabric.document.body || {\n            scrollLeft: 0,\n            scrollTop: 0\n        };\n        // While loop checks (and then sets element to) .parentNode OR .host\n        //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,\n        //  but the .parentNode of a root ShadowDOM node will always be null, instead\n        //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938\n        while(element && (element.parentNode || element.host)){\n            // Set element to element parent, or 'host' in case of ShadowDOM\n            element = element.parentNode || element.host;\n            if (element === fabric.document) {\n                left = body.scrollLeft || docElement.scrollLeft || 0;\n                top = body.scrollTop || docElement.scrollTop || 0;\n            } else {\n                left += element.scrollLeft || 0;\n                top += element.scrollTop || 0;\n            }\n            if (element.nodeType === 1 && element.style.position === \"fixed\") {\n                break;\n            }\n        }\n        return {\n            left: left,\n            top: top\n        };\n    }\n    /**\n   * Returns offset for a given element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to get offset for\n   * @return {Object} Object with \"left\" and \"top\" properties\n   */ function getElementOffset(element) {\n        var docElem, doc = element && element.ownerDocument, box = {\n            left: 0,\n            top: 0\n        }, offset = {\n            left: 0,\n            top: 0\n        }, scrollLeftTop, offsetAttributes = {\n            borderLeftWidth: \"left\",\n            borderTopWidth: \"top\",\n            paddingLeft: \"left\",\n            paddingTop: \"top\"\n        };\n        if (!doc) {\n            return offset;\n        }\n        for(var attr in offsetAttributes){\n            offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;\n        }\n        docElem = doc.documentElement;\n        if (typeof element.getBoundingClientRect !== \"undefined\") {\n            box = element.getBoundingClientRect();\n        }\n        scrollLeftTop = getScrollLeftTop(element);\n        return {\n            left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,\n            top: box.top + scrollLeftTop.top - (docElem.clientTop || 0) + offset.top\n        };\n    }\n    /**\n   * Returns style attribute value of a given element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to get style attribute for\n   * @param {String} attr Style attribute to get for element\n   * @return {String} Style attribute value of the given element.\n   */ var getElementStyle;\n    if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {\n        getElementStyle = function(element, attr) {\n            var style = fabric.document.defaultView.getComputedStyle(element, null);\n            return style ? style[attr] : undefined;\n        };\n    } else {\n        getElementStyle = function(element, attr) {\n            var value = element.style[attr];\n            if (!value && element.currentStyle) {\n                value = element.currentStyle[attr];\n            }\n            return value;\n        };\n    }\n    (function() {\n        var style = fabric.document.documentElement.style, selectProp = \"userSelect\" in style ? \"userSelect\" : \"MozUserSelect\" in style ? \"MozUserSelect\" : \"WebkitUserSelect\" in style ? \"WebkitUserSelect\" : \"KhtmlUserSelect\" in style ? \"KhtmlUserSelect\" : \"\";\n        /**\n     * Makes element unselectable\n     * @memberOf fabric.util\n     * @param {HTMLElement} element Element to make unselectable\n     * @return {HTMLElement} Element that was passed in\n     */ function makeElementUnselectable(element) {\n            if (typeof element.onselectstart !== \"undefined\") {\n                element.onselectstart = fabric.util.falseFunction;\n            }\n            if (selectProp) {\n                element.style[selectProp] = \"none\";\n            } else if (typeof element.unselectable === \"string\") {\n                element.unselectable = \"on\";\n            }\n            return element;\n        }\n        /**\n     * Makes element selectable\n     * @memberOf fabric.util\n     * @param {HTMLElement} element Element to make selectable\n     * @return {HTMLElement} Element that was passed in\n     */ function makeElementSelectable(element) {\n            if (typeof element.onselectstart !== \"undefined\") {\n                element.onselectstart = null;\n            }\n            if (selectProp) {\n                element.style[selectProp] = \"\";\n            } else if (typeof element.unselectable === \"string\") {\n                element.unselectable = \"\";\n            }\n            return element;\n        }\n        fabric.util.makeElementUnselectable = makeElementUnselectable;\n        fabric.util.makeElementSelectable = makeElementSelectable;\n    })();\n    function getNodeCanvas(element) {\n        var impl = fabric.jsdomImplForWrapper(element);\n        return impl._canvas || impl._image;\n    }\n    ;\n    function cleanUpJsdomNode(element) {\n        if (!fabric.isLikelyNode) {\n            return;\n        }\n        var impl = fabric.jsdomImplForWrapper(element);\n        if (impl) {\n            impl._image = null;\n            impl._canvas = null;\n            // unsure if necessary\n            impl._currentSrc = null;\n            impl._attributes = null;\n            impl._classList = null;\n        }\n    }\n    function setImageSmoothing(ctx, value) {\n        ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;\n        ctx.imageSmoothingEnabled = value;\n    }\n    /**\n   * setImageSmoothing sets the context imageSmoothingEnabled property.\n   * Used by canvas and by ImageObject.\n   * @memberOf fabric.util\n   * @since 4.0.0\n   * @param {HTMLRenderingContext2D} ctx to set on\n   * @param {Boolean} value true or false\n   */ fabric.util.setImageSmoothing = setImageSmoothing;\n    fabric.util.getById = getById;\n    fabric.util.toArray = toArray;\n    fabric.util.addClass = addClass;\n    fabric.util.makeElement = makeElement;\n    fabric.util.wrapElement = wrapElement;\n    fabric.util.getScrollLeftTop = getScrollLeftTop;\n    fabric.util.getElementOffset = getElementOffset;\n    fabric.util.getNodeCanvas = getNodeCanvas;\n    fabric.util.cleanUpJsdomNode = cleanUpJsdomNode;\n})();\n(function() {\n    function addParamToUrl(url, param) {\n        return url + (/\\?/.test(url) ? \"&\" : \"?\") + param;\n    }\n    function emptyFn() {}\n    /**\n   * Cross-browser abstraction for sending XMLHttpRequest\n   * @memberOf fabric.util\n   * @param {String} url URL to send XMLHttpRequest to\n   * @param {Object} [options] Options object\n   * @param {String} [options.method=\"GET\"]\n   * @param {String} [options.parameters] parameters to append to url in GET or in body\n   * @param {String} [options.body] body to send with POST or PUT request\n   * @param {Function} options.onComplete Callback to invoke when request is completed\n   * @return {XMLHttpRequest} request\n   */ function request(url, options) {\n        options || (options = {});\n        var method = options.method ? options.method.toUpperCase() : \"GET\", onComplete = options.onComplete || function() {}, xhr = new fabric.window.XMLHttpRequest(), body = options.body || options.parameters;\n        /** @ignore */ xhr.onreadystatechange = function() {\n            if (xhr.readyState === 4) {\n                onComplete(xhr);\n                xhr.onreadystatechange = emptyFn;\n            }\n        };\n        if (method === \"GET\") {\n            body = null;\n            if (typeof options.parameters === \"string\") {\n                url = addParamToUrl(url, options.parameters);\n            }\n        }\n        xhr.open(method, url, true);\n        if (method === \"POST\" || method === \"PUT\") {\n            xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        }\n        xhr.send(body);\n        return xhr;\n    }\n    fabric.util.request = request;\n})();\n/**\n * Wrapper around `console.log` (when available)\n * @param {*} [values] Values to log\n */ fabric.log = console.log;\n/**\n * Wrapper around `console.warn` (when available)\n * @param {*} [values] Values to log as a warning\n */ fabric.warn = console.warn;\n(function() {\n    var extend = fabric.util.object.extend, clone = fabric.util.object.clone;\n    /**\n   * @typedef {Object} AnimationOptions\n   * Animation of a value or list of values.\n   * When using lists, think of something like this:\n   * fabric.util.animate({\n   *   startValue: [1, 2, 3],\n   *   endValue: [2, 4, 6],\n   *   onChange: function([a, b, c]) {\n   *     canvas.zoomToPoint({x: b, y: c}, a)\n   *     canvas.renderAll()\n   *   }\n   * });\n   * @example\n   * @property {Function} [onChange] Callback; invoked on every value change\n   * @property {Function} [onComplete] Callback; invoked when value change is completed\n   * @example\n   * // Note: startValue, endValue, and byValue must match the type\n   * var animationOptions = { startValue: 0, endValue: 1, byValue: 0.25 }\n   * var animationOptions = { startValue: [0, 1], endValue: [1, 2], byValue: [0.25, 0.25] }\n   * @property {number | number[]} [startValue=0] Starting value\n   * @property {number | number[]} [endValue=100] Ending value\n   * @property {number | number[]} [byValue=100] Value to modify the property by\n   * @property {Function} [easing] Easing function\n   * @property {Number} [duration=500] Duration of change (in ms)\n   * @property {Function} [abort] Additional function with logic. If returns true, animation aborts.\n   *\n   * @typedef {() => void} CancelFunction\n   *\n   * @typedef {Object} AnimationCurrentState\n   * @property {number | number[]} currentValue value in range [`startValue`, `endValue`]\n   * @property {number} completionRate value in range [0, 1]\n   * @property {number} durationRate value in range [0, 1]\n   *\n   * @typedef {(AnimationOptions & AnimationCurrentState & { cancel: CancelFunction }} AnimationContext\n   */ /**\n   * Array holding all running animations\n   * @memberof fabric\n   * @type {AnimationContext[]}\n   */ var RUNNING_ANIMATIONS = [];\n    fabric.util.object.extend(RUNNING_ANIMATIONS, {\n        /**\n     * cancel all running animations at the next requestAnimFrame\n     * @returns {AnimationContext[]}\n     */ cancelAll: function() {\n            var animations = this.splice(0);\n            animations.forEach(function(animation) {\n                animation.cancel();\n            });\n            return animations;\n        },\n        /**\n     * cancel all running animations attached to canvas at the next requestAnimFrame\n     * @param {fabric.Canvas} canvas\n     * @returns {AnimationContext[]}\n     */ cancelByCanvas: function(canvas) {\n            if (!canvas) {\n                return [];\n            }\n            var cancelled = this.filter(function(animation) {\n                return typeof animation.target === \"object\" && animation.target.canvas === canvas;\n            });\n            cancelled.forEach(function(animation) {\n                animation.cancel();\n            });\n            return cancelled;\n        },\n        /**\n     * cancel all running animations for target at the next requestAnimFrame\n     * @param {*} target\n     * @returns {AnimationContext[]}\n     */ cancelByTarget: function(target) {\n            var cancelled = this.findAnimationsByTarget(target);\n            cancelled.forEach(function(animation) {\n                animation.cancel();\n            });\n            return cancelled;\n        },\n        /**\n     *\n     * @param {CancelFunction} cancelFunc the function returned by animate\n     * @returns {number}\n     */ findAnimationIndex: function(cancelFunc) {\n            return this.indexOf(this.findAnimation(cancelFunc));\n        },\n        /**\n     *\n     * @param {CancelFunction} cancelFunc the function returned by animate\n     * @returns {AnimationContext | undefined} animation's options object\n     */ findAnimation: function(cancelFunc) {\n            return this.find(function(animation) {\n                return animation.cancel === cancelFunc;\n            });\n        },\n        /**\n     *\n     * @param {*} target the object that is assigned to the target property of the animation context\n     * @returns {AnimationContext[]} array of animation options object associated with target\n     */ findAnimationsByTarget: function(target) {\n            if (!target) {\n                return [];\n            }\n            return this.filter(function(animation) {\n                return animation.target === target;\n            });\n        }\n    });\n    function noop() {\n        return false;\n    }\n    function defaultEasing(t, b, c, d) {\n        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n    }\n    /**\n   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.\n   * @memberOf fabric.util\n   * @param {AnimationOptions} [options] Animation options\n   * @example\n   * // Note: startValue, endValue, and byValue must match the type\n   * fabric.util.animate({ startValue: 0, endValue: 1, byValue: 0.25 })\n   * fabric.util.animate({ startValue: [0, 1], endValue: [1, 2], byValue: [0.25, 0.25] })\n   * @returns {CancelFunction} cancel function\n   */ function animate(options) {\n        options || (options = {});\n        var cancel = false, context, removeFromRegistry = function() {\n            var index = fabric.runningAnimations.indexOf(context);\n            return index > -1 && fabric.runningAnimations.splice(index, 1)[0];\n        };\n        context = extend(clone(options), {\n            cancel: function() {\n                cancel = true;\n                return removeFromRegistry();\n            },\n            currentValue: \"startValue\" in options ? options.startValue : 0,\n            completionRate: 0,\n            durationRate: 0\n        });\n        fabric.runningAnimations.push(context);\n        requestAnimFrame(function(timestamp) {\n            var start = timestamp || +new Date(), duration = options.duration || 500, finish = start + duration, time, onChange = options.onChange || noop, abort = options.abort || noop, onComplete = options.onComplete || noop, easing = options.easing || defaultEasing, isMany = \"startValue\" in options ? options.startValue.length > 0 : false, startValue = \"startValue\" in options ? options.startValue : 0, endValue = \"endValue\" in options ? options.endValue : 100, byValue = options.byValue || (isMany ? startValue.map(function(value, i) {\n                return endValue[i] - startValue[i];\n            }) : endValue - startValue);\n            options.onStart && options.onStart();\n            (function tick(ticktime) {\n                time = ticktime || +new Date();\n                var currentTime = time > finish ? duration : time - start, timePerc = currentTime / duration, current = isMany ? startValue.map(function(_value, i) {\n                    return easing(currentTime, startValue[i], byValue[i], duration);\n                }) : easing(currentTime, startValue, byValue, duration), valuePerc = isMany ? Math.abs((current[0] - startValue[0]) / byValue[0]) : Math.abs((current - startValue) / byValue);\n                //  update context\n                context.currentValue = isMany ? current.slice() : current;\n                context.completionRate = valuePerc;\n                context.durationRate = timePerc;\n                if (cancel) {\n                    return;\n                }\n                if (abort(current, valuePerc, timePerc)) {\n                    removeFromRegistry();\n                    return;\n                }\n                if (time > finish) {\n                    //  update context\n                    context.currentValue = isMany ? endValue.slice() : endValue;\n                    context.completionRate = 1;\n                    context.durationRate = 1;\n                    //  execute callbacks\n                    onChange(isMany ? endValue.slice() : endValue, 1, 1);\n                    onComplete(endValue, 1, 1);\n                    removeFromRegistry();\n                    return;\n                } else {\n                    onChange(current, valuePerc, timePerc);\n                    requestAnimFrame(tick);\n                }\n            })(start);\n        });\n        return context.cancel;\n    }\n    var _requestAnimFrame = fabric.window.requestAnimationFrame || fabric.window.webkitRequestAnimationFrame || fabric.window.mozRequestAnimationFrame || fabric.window.oRequestAnimationFrame || fabric.window.msRequestAnimationFrame || function(callback) {\n        return fabric.window.setTimeout(callback, 1000 / 60);\n    };\n    var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;\n    /**\n   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method\n   * @memberOf fabric.util\n   * @param {Function} callback Callback to invoke\n   * @param {DOMElement} element optional Element to associate with animation\n   */ function requestAnimFrame() {\n        return _requestAnimFrame.apply(fabric.window, arguments);\n    }\n    function cancelAnimFrame() {\n        return _cancelAnimFrame.apply(fabric.window, arguments);\n    }\n    fabric.util.animate = animate;\n    fabric.util.requestAnimFrame = requestAnimFrame;\n    fabric.util.cancelAnimFrame = cancelAnimFrame;\n    fabric.runningAnimations = RUNNING_ANIMATIONS;\n})();\n(function() {\n    // Calculate an in-between color. Returns a \"rgba()\" string.\n    // Credit: Edwin Martin <edwin@bitstorm.org>\n    //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js\n    function calculateColor(begin, end, pos) {\n        var color = \"rgba(\" + parseInt(begin[0] + pos * (end[0] - begin[0]), 10) + \",\" + parseInt(begin[1] + pos * (end[1] - begin[1]), 10) + \",\" + parseInt(begin[2] + pos * (end[2] - begin[2]), 10);\n        color += \",\" + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);\n        color += \")\";\n        return color;\n    }\n    /**\n   * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.\n   * @memberOf fabric.util\n   * @param {String} fromColor The starting color in hex or rgb(a) format.\n   * @param {String} toColor The starting color in hex or rgb(a) format.\n   * @param {Number} [duration] Duration of change (in ms).\n   * @param {Object} [options] Animation options\n   * @param {Function} [options.onChange] Callback; invoked on every value change\n   * @param {Function} [options.onComplete] Callback; invoked when value change is completed\n   * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.\n   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.\n   * @returns {Function} abort function\n   */ function animateColor(fromColor, toColor, duration, options) {\n        var startColor = new fabric.Color(fromColor).getSource(), endColor = new fabric.Color(toColor).getSource(), originalOnComplete = options.onComplete, originalOnChange = options.onChange;\n        options = options || {};\n        return fabric.util.animate(fabric.util.object.extend(options, {\n            duration: duration || 500,\n            startValue: startColor,\n            endValue: endColor,\n            byValue: endColor,\n            easing: function(currentTime, startValue, byValue, duration) {\n                var posValue = options.colorEasing ? options.colorEasing(currentTime, duration) : 1 - Math.cos(currentTime / duration * (Math.PI / 2));\n                return calculateColor(startValue, byValue, posValue);\n            },\n            // has to take in account for color restoring;\n            onComplete: function(current, valuePerc, timePerc) {\n                if (originalOnComplete) {\n                    return originalOnComplete(calculateColor(endColor, endColor, 0), valuePerc, timePerc);\n                }\n            },\n            onChange: function(current, valuePerc, timePerc) {\n                if (originalOnChange) {\n                    if (Array.isArray(current)) {\n                        return originalOnChange(calculateColor(current, current, 0), valuePerc, timePerc);\n                    }\n                    originalOnChange(current, valuePerc, timePerc);\n                }\n            }\n        }));\n    }\n    fabric.util.animateColor = animateColor;\n})();\n(function() {\n    function normalize(a, c, p, s) {\n        if (a < Math.abs(c)) {\n            a = c;\n            s = p / 4;\n        } else {\n            //handle the 0/0 case:\n            if (c === 0 && a === 0) {\n                s = p / (2 * Math.PI) * Math.asin(1);\n            } else {\n                s = p / (2 * Math.PI) * Math.asin(c / a);\n            }\n        }\n        return {\n            a: a,\n            c: c,\n            p: p,\n            s: s\n        };\n    }\n    function elastic(opts, t, d) {\n        return opts.a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p);\n    }\n    /**\n   * Cubic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutCubic(t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t + 1) + b;\n    }\n    /**\n   * Cubic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutCubic(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * t * t * t + b;\n        }\n        return c / 2 * ((t -= 2) * t * t + 2) + b;\n    }\n    /**\n   * Quartic easing in\n   * @memberOf fabric.util.ease\n   */ function easeInQuart(t, b, c, d) {\n        return c * (t /= d) * t * t * t + b;\n    }\n    /**\n   * Quartic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutQuart(t, b, c, d) {\n        return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n    }\n    /**\n   * Quartic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutQuart(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * t * t * t * t + b;\n        }\n        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n    }\n    /**\n   * Quintic easing in\n   * @memberOf fabric.util.ease\n   */ function easeInQuint(t, b, c, d) {\n        return c * (t /= d) * t * t * t * t + b;\n    }\n    /**\n   * Quintic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutQuint(t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n    }\n    /**\n   * Quintic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutQuint(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * t * t * t * t * t + b;\n        }\n        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n    }\n    /**\n   * Sinusoidal easing in\n   * @memberOf fabric.util.ease\n   */ function easeInSine(t, b, c, d) {\n        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n    }\n    /**\n   * Sinusoidal easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutSine(t, b, c, d) {\n        return c * Math.sin(t / d * (Math.PI / 2)) + b;\n    }\n    /**\n   * Sinusoidal easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutSine(t, b, c, d) {\n        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n    }\n    /**\n   * Exponential easing in\n   * @memberOf fabric.util.ease\n   */ function easeInExpo(t, b, c, d) {\n        return t === 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n    }\n    /**\n   * Exponential easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutExpo(t, b, c, d) {\n        return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n    }\n    /**\n   * Exponential easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutExpo(t, b, c, d) {\n        if (t === 0) {\n            return b;\n        }\n        if (t === d) {\n            return b + c;\n        }\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n        }\n        return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n    }\n    /**\n   * Circular easing in\n   * @memberOf fabric.util.ease\n   */ function easeInCirc(t, b, c, d) {\n        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n    }\n    /**\n   * Circular easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutCirc(t, b, c, d) {\n        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n    }\n    /**\n   * Circular easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutCirc(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n        }\n        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n    }\n    /**\n   * Elastic easing in\n   * @memberOf fabric.util.ease\n   */ function easeInElastic(t, b, c, d) {\n        var s = 1.70158, p = 0, a = c;\n        if (t === 0) {\n            return b;\n        }\n        t /= d;\n        if (t === 1) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * 0.3;\n        }\n        var opts = normalize(a, c, p, s);\n        return -elastic(opts, t, d) + b;\n    }\n    /**\n   * Elastic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutElastic(t, b, c, d) {\n        var s = 1.70158, p = 0, a = c;\n        if (t === 0) {\n            return b;\n        }\n        t /= d;\n        if (t === 1) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * 0.3;\n        }\n        var opts = normalize(a, c, p, s);\n        return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p) + opts.c + b;\n    }\n    /**\n   * Elastic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutElastic(t, b, c, d) {\n        var s = 1.70158, p = 0, a = c;\n        if (t === 0) {\n            return b;\n        }\n        t /= d / 2;\n        if (t === 2) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * (0.3 * 1.5);\n        }\n        var opts = normalize(a, c, p, s);\n        if (t < 1) {\n            return -0.5 * elastic(opts, t, d) + b;\n        }\n        return opts.a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p) * 0.5 + opts.c + b;\n    }\n    /**\n   * Backwards easing in\n   * @memberOf fabric.util.ease\n   */ function easeInBack(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        return c * (t /= d) * t * ((s + 1) * t - s) + b;\n    }\n    /**\n   * Backwards easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutBack(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n    }\n    /**\n   * Backwards easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutBack(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;\n        }\n        return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;\n    }\n    /**\n   * Bouncing easing in\n   * @memberOf fabric.util.ease\n   */ function easeInBounce(t, b, c, d) {\n        return c - easeOutBounce(d - t, 0, c, d) + b;\n    }\n    /**\n   * Bouncing easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutBounce(t, b, c, d) {\n        if ((t /= d) < 1 / 2.75) {\n            return c * (7.5625 * t * t) + b;\n        } else if (t < 2 / 2.75) {\n            return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;\n        } else if (t < 2.5 / 2.75) {\n            return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;\n        } else {\n            return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;\n        }\n    }\n    /**\n   * Bouncing easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutBounce(t, b, c, d) {\n        if (t < d / 2) {\n            return easeInBounce(t * 2, 0, c, d) * 0.5 + b;\n        }\n        return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;\n    }\n    /**\n   * Easing functions\n   * See <a href=\"http://gizma.com/easing/\">Easing Equations by Robert Penner</a>\n   * @namespace fabric.util.ease\n   */ fabric.util.ease = {\n        /**\n     * Quadratic easing in\n     * @memberOf fabric.util.ease\n     */ easeInQuad: function(t, b, c, d) {\n            return c * (t /= d) * t + b;\n        },\n        /**\n     * Quadratic easing out\n     * @memberOf fabric.util.ease\n     */ easeOutQuad: function(t, b, c, d) {\n            return -c * (t /= d) * (t - 2) + b;\n        },\n        /**\n     * Quadratic easing in and out\n     * @memberOf fabric.util.ease\n     */ easeInOutQuad: function(t, b, c, d) {\n            t /= d / 2;\n            if (t < 1) {\n                return c / 2 * t * t + b;\n            }\n            return -c / 2 * (--t * (t - 2) - 1) + b;\n        },\n        /**\n     * Cubic easing in\n     * @memberOf fabric.util.ease\n     */ easeInCubic: function(t, b, c, d) {\n            return c * (t /= d) * t * t + b;\n        },\n        easeOutCubic: easeOutCubic,\n        easeInOutCubic: easeInOutCubic,\n        easeInQuart: easeInQuart,\n        easeOutQuart: easeOutQuart,\n        easeInOutQuart: easeInOutQuart,\n        easeInQuint: easeInQuint,\n        easeOutQuint: easeOutQuint,\n        easeInOutQuint: easeInOutQuint,\n        easeInSine: easeInSine,\n        easeOutSine: easeOutSine,\n        easeInOutSine: easeInOutSine,\n        easeInExpo: easeInExpo,\n        easeOutExpo: easeOutExpo,\n        easeInOutExpo: easeInOutExpo,\n        easeInCirc: easeInCirc,\n        easeOutCirc: easeOutCirc,\n        easeInOutCirc: easeInOutCirc,\n        easeInElastic: easeInElastic,\n        easeOutElastic: easeOutElastic,\n        easeInOutElastic: easeInOutElastic,\n        easeInBack: easeInBack,\n        easeOutBack: easeOutBack,\n        easeInOutBack: easeInOutBack,\n        easeInBounce: easeInBounce,\n        easeOutBounce: easeOutBounce,\n        easeInOutBounce: easeInOutBounce\n    };\n})();\n(function(global) {\n    \"use strict\";\n    /**\n   * @name fabric\n   * @namespace\n   */ var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, clone = fabric.util.object.clone, toFixed = fabric.util.toFixed, parseUnit = fabric.util.parseUnit, multiplyTransformMatrices = fabric.util.multiplyTransformMatrices, svgValidTagNames = [\n        \"path\",\n        \"circle\",\n        \"polygon\",\n        \"polyline\",\n        \"ellipse\",\n        \"rect\",\n        \"line\",\n        \"image\",\n        \"text\"\n    ], svgViewBoxElements = [\n        \"symbol\",\n        \"image\",\n        \"marker\",\n        \"pattern\",\n        \"view\",\n        \"svg\"\n    ], svgInvalidAncestors = [\n        \"pattern\",\n        \"defs\",\n        \"symbol\",\n        \"metadata\",\n        \"clipPath\",\n        \"mask\",\n        \"desc\"\n    ], svgValidParents = [\n        \"symbol\",\n        \"g\",\n        \"a\",\n        \"svg\",\n        \"clipPath\",\n        \"defs\"\n    ], attributesMap = {\n        cx: \"left\",\n        x: \"left\",\n        r: \"radius\",\n        cy: \"top\",\n        y: \"top\",\n        display: \"visible\",\n        visibility: \"visible\",\n        transform: \"transformMatrix\",\n        \"fill-opacity\": \"fillOpacity\",\n        \"fill-rule\": \"fillRule\",\n        \"font-family\": \"fontFamily\",\n        \"font-size\": \"fontSize\",\n        \"font-style\": \"fontStyle\",\n        \"font-weight\": \"fontWeight\",\n        \"letter-spacing\": \"charSpacing\",\n        \"paint-order\": \"paintFirst\",\n        \"stroke-dasharray\": \"strokeDashArray\",\n        \"stroke-dashoffset\": \"strokeDashOffset\",\n        \"stroke-linecap\": \"strokeLineCap\",\n        \"stroke-linejoin\": \"strokeLineJoin\",\n        \"stroke-miterlimit\": \"strokeMiterLimit\",\n        \"stroke-opacity\": \"strokeOpacity\",\n        \"stroke-width\": \"strokeWidth\",\n        \"text-decoration\": \"textDecoration\",\n        \"text-anchor\": \"textAnchor\",\n        opacity: \"opacity\",\n        \"clip-path\": \"clipPath\",\n        \"clip-rule\": \"clipRule\",\n        \"vector-effect\": \"strokeUniform\",\n        \"image-rendering\": \"imageSmoothing\"\n    }, colorAttributes = {\n        stroke: \"strokeOpacity\",\n        fill: \"fillOpacity\"\n    }, fSize = \"font-size\", cPath = \"clip-path\";\n    fabric.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);\n    fabric.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);\n    fabric.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);\n    fabric.svgValidParentsRegEx = getSvgRegex(svgValidParents);\n    fabric.cssRules = {};\n    fabric.gradientDefs = {};\n    fabric.clipPaths = {};\n    function normalizeAttr(attr) {\n        // transform attribute names\n        if (attr in attributesMap) {\n            return attributesMap[attr];\n        }\n        return attr;\n    }\n    function normalizeValue(attr, value, parentAttributes, fontSize) {\n        var isArray = Array.isArray(value), parsed;\n        if ((attr === \"fill\" || attr === \"stroke\") && value === \"none\") {\n            value = \"\";\n        } else if (attr === \"strokeUniform\") {\n            return value === \"non-scaling-stroke\";\n        } else if (attr === \"strokeDashArray\") {\n            if (value === \"none\") {\n                value = null;\n            } else {\n                value = value.replace(/,/g, \" \").split(/\\s+/).map(parseFloat);\n            }\n        } else if (attr === \"transformMatrix\") {\n            if (parentAttributes && parentAttributes.transformMatrix) {\n                value = multiplyTransformMatrices(parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));\n            } else {\n                value = fabric.parseTransformAttribute(value);\n            }\n        } else if (attr === \"visible\") {\n            value = value !== \"none\" && value !== \"hidden\";\n            // display=none on parent element always takes precedence over child element\n            if (parentAttributes && parentAttributes.visible === false) {\n                value = false;\n            }\n        } else if (attr === \"opacity\") {\n            value = parseFloat(value);\n            if (parentAttributes && typeof parentAttributes.opacity !== \"undefined\") {\n                value *= parentAttributes.opacity;\n            }\n        } else if (attr === \"textAnchor\" /* text-anchor */ ) {\n            value = value === \"start\" ? \"left\" : value === \"end\" ? \"right\" : \"center\";\n        } else if (attr === \"charSpacing\") {\n            // parseUnit returns px and we convert it to em\n            parsed = parseUnit(value, fontSize) / fontSize * 1000;\n        } else if (attr === \"paintFirst\") {\n            var fillIndex = value.indexOf(\"fill\");\n            var strokeIndex = value.indexOf(\"stroke\");\n            var value = \"fill\";\n            if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {\n                value = \"stroke\";\n            } else if (fillIndex === -1 && strokeIndex > -1) {\n                value = \"stroke\";\n            }\n        } else if (attr === \"href\" || attr === \"xlink:href\" || attr === \"font\") {\n            return value;\n        } else if (attr === \"imageSmoothing\") {\n            return value === \"optimizeQuality\";\n        } else {\n            parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);\n        }\n        return !isArray && isNaN(parsed) ? value : parsed;\n    }\n    /**\n    * @private\n    */ function getSvgRegex(arr) {\n        return new RegExp(\"^(\" + arr.join(\"|\") + \")\\\\b\", \"i\");\n    }\n    /**\n   * @private\n   * @param {Object} attributes Array of attributes to parse\n   */ function _setStrokeFillOpacity(attributes) {\n        for(var attr in colorAttributes){\n            if (typeof attributes[colorAttributes[attr]] === \"undefined\" || attributes[attr] === \"\") {\n                continue;\n            }\n            if (typeof attributes[attr] === \"undefined\") {\n                if (!fabric.Object.prototype[attr]) {\n                    continue;\n                }\n                attributes[attr] = fabric.Object.prototype[attr];\n            }\n            if (attributes[attr].indexOf(\"url(\") === 0) {\n                continue;\n            }\n            var color = new fabric.Color(attributes[attr]);\n            attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();\n        }\n        return attributes;\n    }\n    /**\n   * @private\n   */ function _getMultipleNodes(doc, nodeNames) {\n        var nodeName, nodeArray = [], nodeList, i, len;\n        for(i = 0, len = nodeNames.length; i < len; i++){\n            nodeName = nodeNames[i];\n            nodeList = doc.getElementsByTagName(nodeName);\n            nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));\n        }\n        return nodeArray;\n    }\n    /**\n   * Parses \"transform\" attribute, returning an array of values\n   * @static\n   * @function\n   * @memberOf fabric\n   * @param {String} attributeValue String containing attribute value\n   * @return {Array} Array of 6 elements representing transformation matrix\n   */ fabric.parseTransformAttribute = function() {\n        function rotateMatrix(matrix, args) {\n            var cos = fabric.util.cos(args[0]), sin = fabric.util.sin(args[0]), x = 0, y = 0;\n            if (args.length === 3) {\n                x = args[1];\n                y = args[2];\n            }\n            matrix[0] = cos;\n            matrix[1] = sin;\n            matrix[2] = -sin;\n            matrix[3] = cos;\n            matrix[4] = x - (cos * x - sin * y);\n            matrix[5] = y - (sin * x + cos * y);\n        }\n        function scaleMatrix(matrix, args) {\n            var multiplierX = args[0], multiplierY = args.length === 2 ? args[1] : args[0];\n            matrix[0] = multiplierX;\n            matrix[3] = multiplierY;\n        }\n        function skewMatrix(matrix, args, pos) {\n            matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));\n        }\n        function translateMatrix(matrix, args) {\n            matrix[4] = args[0];\n            if (args.length === 2) {\n                matrix[5] = args[1];\n            }\n        }\n        // identity matrix\n        var iMatrix = fabric.iMatrix, // == begin transform regexp\n        number = fabric.reNum, commaWsp = fabric.commaWsp, skewX = \"(?:(skewX)\\\\s*\\\\(\\\\s*(\" + number + \")\\\\s*\\\\))\", skewY = \"(?:(skewY)\\\\s*\\\\(\\\\s*(\" + number + \")\\\\s*\\\\))\", rotate = \"(?:(rotate)\\\\s*\\\\(\\\\s*(\" + number + \")(?:\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \"))?\\\\s*\\\\))\", scale = \"(?:(scale)\\\\s*\\\\(\\\\s*(\" + number + \")(?:\" + commaWsp + \"(\" + number + \"))?\\\\s*\\\\))\", translate = \"(?:(translate)\\\\s*\\\\(\\\\s*(\" + number + \")(?:\" + commaWsp + \"(\" + number + \"))?\\\\s*\\\\))\", matrix = \"(?:(matrix)\\\\s*\\\\(\\\\s*\" + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + \"\\\\s*\\\\))\", transform = \"(?:\" + matrix + \"|\" + translate + \"|\" + scale + \"|\" + rotate + \"|\" + skewX + \"|\" + skewY + \")\", transforms = \"(?:\" + transform + \"(?:\" + commaWsp + \"*\" + transform + \")*\" + \")\", transformList = \"^\\\\s*(?:\" + transforms + \"?)\\\\s*$\", // http://www.w3.org/TR/SVG/coords.html#TransformAttribute\n        reTransformList = new RegExp(transformList), // == end transform regexp\n        reTransform = new RegExp(transform, \"g\");\n        return function(attributeValue) {\n            // start with identity matrix\n            var matrix = iMatrix.concat(), matrices = [];\n            // return if no argument was given or\n            // an argument does not match transform attribute regexp\n            if (!attributeValue || attributeValue && !reTransformList.test(attributeValue)) {\n                return matrix;\n            }\n            attributeValue.replace(reTransform, function(match) {\n                var m = new RegExp(transform).exec(match).filter(function(match) {\n                    // match !== '' && match != null\n                    return !!match;\n                }), operation = m[1], args = m.slice(2).map(parseFloat);\n                switch(operation){\n                    case \"translate\":\n                        translateMatrix(matrix, args);\n                        break;\n                    case \"rotate\":\n                        args[0] = fabric.util.degreesToRadians(args[0]);\n                        rotateMatrix(matrix, args);\n                        break;\n                    case \"scale\":\n                        scaleMatrix(matrix, args);\n                        break;\n                    case \"skewX\":\n                        skewMatrix(matrix, args, 2);\n                        break;\n                    case \"skewY\":\n                        skewMatrix(matrix, args, 1);\n                        break;\n                    case \"matrix\":\n                        matrix = args;\n                        break;\n                }\n                // snapshot current matrix into matrices array\n                matrices.push(matrix.concat());\n                // reset\n                matrix = iMatrix.concat();\n            });\n            var combinedMatrix = matrices[0];\n            while(matrices.length > 1){\n                matrices.shift();\n                combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);\n            }\n            return combinedMatrix;\n        };\n    }();\n    /**\n   * @private\n   */ function parseStyleString(style, oStyle) {\n        var attr, value;\n        style.replace(/;\\s*$/, \"\").split(\";\").forEach(function(chunk) {\n            var pair = chunk.split(\":\");\n            attr = pair[0].trim().toLowerCase();\n            value = pair[1].trim();\n            oStyle[attr] = value;\n        });\n    }\n    /**\n   * @private\n   */ function parseStyleObject(style, oStyle) {\n        var attr, value;\n        for(var prop in style){\n            if (typeof style[prop] === \"undefined\") {\n                continue;\n            }\n            attr = prop.toLowerCase();\n            value = style[prop];\n            oStyle[attr] = value;\n        }\n    }\n    /**\n   * @private\n   */ function getGlobalStylesForElement(element, svgUid) {\n        var styles = {};\n        for(var rule in fabric.cssRules[svgUid]){\n            if (elementMatchesRule(element, rule.split(\" \"))) {\n                for(var property in fabric.cssRules[svgUid][rule]){\n                    styles[property] = fabric.cssRules[svgUid][rule][property];\n                }\n            }\n        }\n        return styles;\n    }\n    /**\n   * @private\n   */ function elementMatchesRule(element, selectors) {\n        var firstMatching, parentMatching = true;\n        //start from rightmost selector.\n        firstMatching = selectorMatches(element, selectors.pop());\n        if (firstMatching && selectors.length) {\n            parentMatching = doesSomeParentMatch(element, selectors);\n        }\n        return firstMatching && parentMatching && selectors.length === 0;\n    }\n    function doesSomeParentMatch(element, selectors) {\n        var selector, parentMatching = true;\n        while(element.parentNode && element.parentNode.nodeType === 1 && selectors.length){\n            if (parentMatching) {\n                selector = selectors.pop();\n            }\n            element = element.parentNode;\n            parentMatching = selectorMatches(element, selector);\n        }\n        return selectors.length === 0;\n    }\n    /**\n   * @private\n   */ function selectorMatches(element, selector) {\n        var nodeName = element.nodeName, classNames = element.getAttribute(\"class\"), id = element.getAttribute(\"id\"), matcher, i;\n        // i check if a selector matches slicing away part from it.\n        // if i get empty string i should match\n        matcher = new RegExp(\"^\" + nodeName, \"i\");\n        selector = selector.replace(matcher, \"\");\n        if (id && selector.length) {\n            matcher = new RegExp(\"#\" + id + \"(?![a-zA-Z\\\\-]+)\", \"i\");\n            selector = selector.replace(matcher, \"\");\n        }\n        if (classNames && selector.length) {\n            classNames = classNames.split(\" \");\n            for(i = classNames.length; i--;){\n                matcher = new RegExp(\"\\\\.\" + classNames[i] + \"(?![a-zA-Z\\\\-]+)\", \"i\");\n                selector = selector.replace(matcher, \"\");\n            }\n        }\n        return selector.length === 0;\n    }\n    /**\n   * @private\n   * to support IE8 missing getElementById on SVGdocument and on node xmlDOM\n   */ function elementById(doc, id) {\n        var el;\n        doc.getElementById && (el = doc.getElementById(id));\n        if (el) {\n            return el;\n        }\n        var node, i, len, nodelist = doc.getElementsByTagName(\"*\");\n        for(i = 0, len = nodelist.length; i < len; i++){\n            node = nodelist[i];\n            if (id === node.getAttribute(\"id\")) {\n                return node;\n            }\n        }\n    }\n    /**\n   * @private\n   */ function parseUseDirectives(doc) {\n        var nodelist = _getMultipleNodes(doc, [\n            \"use\",\n            \"svg:use\"\n        ]), i = 0;\n        while(nodelist.length && i < nodelist.length){\n            var el = nodelist[i], xlinkAttribute = el.getAttribute(\"xlink:href\") || el.getAttribute(\"href\");\n            if (xlinkAttribute === null) {\n                return;\n            }\n            var xlink = xlinkAttribute.slice(1), x = el.getAttribute(\"x\") || 0, y = el.getAttribute(\"y\") || 0, el2 = elementById(doc, xlink).cloneNode(true), currentTrans = (el2.getAttribute(\"transform\") || \"\") + \" translate(\" + x + \", \" + y + \")\", parentNode, oldLength = nodelist.length, attr, j, attrs, len, namespace = fabric.svgNS;\n            applyViewboxTransform(el2);\n            if (/^svg$/i.test(el2.nodeName)) {\n                var el3 = el2.ownerDocument.createElementNS(namespace, \"g\");\n                for(j = 0, attrs = el2.attributes, len = attrs.length; j < len; j++){\n                    attr = attrs.item(j);\n                    el3.setAttributeNS(namespace, attr.nodeName, attr.nodeValue);\n                }\n                // el2.firstChild != null\n                while(el2.firstChild){\n                    el3.appendChild(el2.firstChild);\n                }\n                el2 = el3;\n            }\n            for(j = 0, attrs = el.attributes, len = attrs.length; j < len; j++){\n                attr = attrs.item(j);\n                if (attr.nodeName === \"x\" || attr.nodeName === \"y\" || attr.nodeName === \"xlink:href\" || attr.nodeName === \"href\") {\n                    continue;\n                }\n                if (attr.nodeName === \"transform\") {\n                    currentTrans = attr.nodeValue + \" \" + currentTrans;\n                } else {\n                    el2.setAttribute(attr.nodeName, attr.nodeValue);\n                }\n            }\n            el2.setAttribute(\"transform\", currentTrans);\n            el2.setAttribute(\"instantiated_by_use\", \"1\");\n            el2.removeAttribute(\"id\");\n            parentNode = el.parentNode;\n            parentNode.replaceChild(el2, el);\n            // some browsers do not shorten nodelist after replaceChild (IE8)\n            if (nodelist.length === oldLength) {\n                i++;\n            }\n        }\n    }\n    // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute\n    // matches, e.g.: +14.56e-12, etc.\n    var reViewBoxAttrValue = new RegExp(\"^\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*,?\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*,?\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*,?\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*\" + \"$\");\n    /**\n   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements\n   */ function applyViewboxTransform(element) {\n        if (!fabric.svgViewBoxElementsRegEx.test(element.nodeName)) {\n            return {};\n        }\n        var viewBoxAttr = element.getAttribute(\"viewBox\"), scaleX = 1, scaleY = 1, minX = 0, minY = 0, viewBoxWidth, viewBoxHeight, matrix, el, widthAttr = element.getAttribute(\"width\"), heightAttr = element.getAttribute(\"height\"), x = element.getAttribute(\"x\") || 0, y = element.getAttribute(\"y\") || 0, preserveAspectRatio = element.getAttribute(\"preserveAspectRatio\") || \"\", missingViewBox = !viewBoxAttr || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue)), missingDimAttr = !widthAttr || !heightAttr || widthAttr === \"100%\" || heightAttr === \"100%\", toBeParsed = missingViewBox && missingDimAttr, parsedDim = {}, translateMatrix = \"\", widthDiff = 0, heightDiff = 0;\n        parsedDim.width = 0;\n        parsedDim.height = 0;\n        parsedDim.toBeParsed = toBeParsed;\n        if (missingViewBox) {\n            if ((x || y) && element.parentNode && element.parentNode.nodeName !== \"#document\") {\n                translateMatrix = \" translate(\" + parseUnit(x) + \" \" + parseUnit(y) + \") \";\n                matrix = (element.getAttribute(\"transform\") || \"\") + translateMatrix;\n                element.setAttribute(\"transform\", matrix);\n                element.removeAttribute(\"x\");\n                element.removeAttribute(\"y\");\n            }\n        }\n        if (toBeParsed) {\n            return parsedDim;\n        }\n        if (missingViewBox) {\n            parsedDim.width = parseUnit(widthAttr);\n            parsedDim.height = parseUnit(heightAttr);\n            // set a transform for elements that have x y and are inner(only) SVGs\n            return parsedDim;\n        }\n        minX = -parseFloat(viewBoxAttr[1]);\n        minY = -parseFloat(viewBoxAttr[2]);\n        viewBoxWidth = parseFloat(viewBoxAttr[3]);\n        viewBoxHeight = parseFloat(viewBoxAttr[4]);\n        parsedDim.minX = minX;\n        parsedDim.minY = minY;\n        parsedDim.viewBoxWidth = viewBoxWidth;\n        parsedDim.viewBoxHeight = viewBoxHeight;\n        if (!missingDimAttr) {\n            parsedDim.width = parseUnit(widthAttr);\n            parsedDim.height = parseUnit(heightAttr);\n            scaleX = parsedDim.width / viewBoxWidth;\n            scaleY = parsedDim.height / viewBoxHeight;\n        } else {\n            parsedDim.width = viewBoxWidth;\n            parsedDim.height = viewBoxHeight;\n        }\n        // default is to preserve aspect ratio\n        preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);\n        if (preserveAspectRatio.alignX !== \"none\") {\n            //translate all container for the effect of Mid, Min, Max\n            if (preserveAspectRatio.meetOrSlice === \"meet\") {\n                scaleY = scaleX = scaleX > scaleY ? scaleY : scaleX;\n            // calculate additional translation to move the viewbox\n            }\n            if (preserveAspectRatio.meetOrSlice === \"slice\") {\n                scaleY = scaleX = scaleX > scaleY ? scaleX : scaleY;\n            // calculate additional translation to move the viewbox\n            }\n            widthDiff = parsedDim.width - viewBoxWidth * scaleX;\n            heightDiff = parsedDim.height - viewBoxHeight * scaleX;\n            if (preserveAspectRatio.alignX === \"Mid\") {\n                widthDiff /= 2;\n            }\n            if (preserveAspectRatio.alignY === \"Mid\") {\n                heightDiff /= 2;\n            }\n            if (preserveAspectRatio.alignX === \"Min\") {\n                widthDiff = 0;\n            }\n            if (preserveAspectRatio.alignY === \"Min\") {\n                heightDiff = 0;\n            }\n        }\n        if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {\n            return parsedDim;\n        }\n        if ((x || y) && element.parentNode.nodeName !== \"#document\") {\n            translateMatrix = \" translate(\" + parseUnit(x) + \" \" + parseUnit(y) + \") \";\n        }\n        matrix = translateMatrix + \" matrix(\" + scaleX + \" 0\" + \" 0 \" + scaleY + \" \" + (minX * scaleX + widthDiff) + \" \" + (minY * scaleY + heightDiff) + \") \";\n        // seems unused.\n        // parsedDim.viewboxTransform = fabric.parseTransformAttribute(matrix);\n        if (element.nodeName === \"svg\") {\n            el = element.ownerDocument.createElementNS(fabric.svgNS, \"g\");\n            // element.firstChild != null\n            while(element.firstChild){\n                el.appendChild(element.firstChild);\n            }\n            element.appendChild(el);\n        } else {\n            el = element;\n            el.removeAttribute(\"x\");\n            el.removeAttribute(\"y\");\n            matrix = el.getAttribute(\"transform\") + matrix;\n        }\n        el.setAttribute(\"transform\", matrix);\n        return parsedDim;\n    }\n    function hasAncestorWithNodeName(element, nodeName) {\n        while(element && (element = element.parentNode)){\n            if (element.nodeName && nodeName.test(element.nodeName.replace(\"svg:\", \"\")) && !element.getAttribute(\"instantiated_by_use\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback\n   * @static\n   * @function\n   * @memberOf fabric\n   * @param {SVGDocument} doc SVG document to parse\n   * @param {Function} callback Callback to call when parsing is finished;\n   * It's being passed an array of elements (parsed from a document).\n   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n   * @param {Object} [parsingOptions] options for parsing document\n   * @param {String} [parsingOptions.crossOrigin] crossOrigin settings\n   */ fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {\n        if (!doc) {\n            return;\n        }\n        parseUseDirectives(doc);\n        var svgUid = fabric.Object.__uid++, i, len, options = applyViewboxTransform(doc), descendants = fabric.util.toArray(doc.getElementsByTagName(\"*\"));\n        options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;\n        options.svgUid = svgUid;\n        if (descendants.length === 0 && fabric.isLikelyNode) {\n            // we're likely in node, where \"o3-xml\" library fails to gEBTN(\"*\")\n            // https://github.com/ajaxorg/node-o3-xml/issues/21\n            descendants = doc.selectNodes('//*[name(.)!=\"svg\"]');\n            var arr = [];\n            for(i = 0, len = descendants.length; i < len; i++){\n                arr[i] = descendants[i];\n            }\n            descendants = arr;\n        }\n        var elements = descendants.filter(function(el) {\n            applyViewboxTransform(el);\n            return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace(\"svg:\", \"\")) && !hasAncestorWithNodeName(el, fabric.svgInvalidAncestorsRegEx); // http://www.w3.org/TR/SVG/struct.html#DefsElement\n        });\n        if (!elements || elements && !elements.length) {\n            callback && callback([], {});\n            return;\n        }\n        var clipPaths = {};\n        descendants.filter(function(el) {\n            return el.nodeName.replace(\"svg:\", \"\") === \"clipPath\";\n        }).forEach(function(el) {\n            var id = el.getAttribute(\"id\");\n            clipPaths[id] = fabric.util.toArray(el.getElementsByTagName(\"*\")).filter(function(el) {\n                return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace(\"svg:\", \"\"));\n            });\n        });\n        fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);\n        fabric.cssRules[svgUid] = fabric.getCSSRules(doc);\n        fabric.clipPaths[svgUid] = clipPaths;\n        // Precedence of rules:   style > class > attribute\n        fabric.parseElements(elements, function(instances, elements) {\n            if (callback) {\n                callback(instances, options, elements, descendants);\n                delete fabric.gradientDefs[svgUid];\n                delete fabric.cssRules[svgUid];\n                delete fabric.clipPaths[svgUid];\n            }\n        }, clone(options), reviver, parsingOptions);\n    };\n    function recursivelyParseGradientsXlink(doc, gradient) {\n        var gradientsAttrs = [\n            \"gradientTransform\",\n            \"x1\",\n            \"x2\",\n            \"y1\",\n            \"y2\",\n            \"gradientUnits\",\n            \"cx\",\n            \"cy\",\n            \"r\",\n            \"fx\",\n            \"fy\"\n        ], xlinkAttr = \"xlink:href\", xLink = gradient.getAttribute(xlinkAttr).slice(1), referencedGradient = elementById(doc, xLink);\n        if (referencedGradient && referencedGradient.getAttribute(xlinkAttr)) {\n            recursivelyParseGradientsXlink(doc, referencedGradient);\n        }\n        gradientsAttrs.forEach(function(attr) {\n            if (referencedGradient && !gradient.hasAttribute(attr) && referencedGradient.hasAttribute(attr)) {\n                gradient.setAttribute(attr, referencedGradient.getAttribute(attr));\n            }\n        });\n        if (!gradient.children.length) {\n            var referenceClone = referencedGradient.cloneNode(true);\n            while(referenceClone.firstChild){\n                gradient.appendChild(referenceClone.firstChild);\n            }\n        }\n        gradient.removeAttribute(xlinkAttr);\n    }\n    var reFontDeclaration = new RegExp(\"(normal|italic)?\\\\s*(normal|small-caps)?\\\\s*\" + \"(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\\\s*(\" + fabric.reNum + \"(?:px|cm|mm|em|pt|pc|in)*)(?:\\\\/(normal|\" + fabric.reNum + \"))?\\\\s+(.*)\");\n    extend(fabric, {\n        /**\n     * Parses a short font declaration, building adding its properties to a style object\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {String} value font declaration\n     * @param {Object} oStyle definition\n     */ parseFontDeclaration: function(value, oStyle) {\n            var match = value.match(reFontDeclaration);\n            if (!match) {\n                return;\n            }\n            var fontStyle = match[1], // font variant is not used\n            // fontVariant = match[2],\n            fontWeight = match[3], fontSize = match[4], lineHeight = match[5], fontFamily = match[6];\n            if (fontStyle) {\n                oStyle.fontStyle = fontStyle;\n            }\n            if (fontWeight) {\n                oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);\n            }\n            if (fontSize) {\n                oStyle.fontSize = parseUnit(fontSize);\n            }\n            if (fontFamily) {\n                oStyle.fontFamily = fontFamily;\n            }\n            if (lineHeight) {\n                oStyle.lineHeight = lineHeight === \"normal\" ? 1 : lineHeight;\n            }\n        },\n        /**\n     * Parses an SVG document, returning all of the gradient declarations found in it\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {SVGDocument} doc SVG document to parse\n     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element\n     */ getGradientDefs: function(doc) {\n            var tagArray = [\n                \"linearGradient\",\n                \"radialGradient\",\n                \"svg:linearGradient\",\n                \"svg:radialGradient\"\n            ], elList = _getMultipleNodes(doc, tagArray), el, j = 0, gradientDefs = {};\n            j = elList.length;\n            while(j--){\n                el = elList[j];\n                if (el.getAttribute(\"xlink:href\")) {\n                    recursivelyParseGradientsXlink(doc, el);\n                }\n                gradientDefs[el.getAttribute(\"id\")] = el;\n            }\n            return gradientDefs;\n        },\n        /**\n     * Returns an object of attributes' name/value, given element and an array of attribute names;\n     * Parses parent \"g\" nodes recursively upwards.\n     * @static\n     * @memberOf fabric\n     * @param {DOMElement} element Element to parse\n     * @param {Array} attributes Array of attributes to parse\n     * @return {Object} object containing parsed attributes' names/values\n     */ parseAttributes: function(element, attributes, svgUid) {\n            if (!element) {\n                return;\n            }\n            var value, parentAttributes = {}, fontSize, parentFontSize;\n            if (typeof svgUid === \"undefined\") {\n                svgUid = element.getAttribute(\"svgUid\");\n            }\n            // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards\n            if (element.parentNode && fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)) {\n                parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);\n            }\n            var ownAttributes = attributes.reduce(function(memo, attr) {\n                value = element.getAttribute(attr);\n                if (value) {\n                    memo[attr] = value;\n                }\n                return memo;\n            }, {});\n            // add values parsed from style, which take precedence over attributes\n            // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)\n            var cssAttrs = extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element));\n            ownAttributes = extend(ownAttributes, cssAttrs);\n            if (cssAttrs[cPath]) {\n                element.setAttribute(cPath, cssAttrs[cPath]);\n            }\n            fontSize = parentFontSize = parentAttributes.fontSize || fabric.Text.DEFAULT_SVG_FONT_SIZE;\n            if (ownAttributes[fSize]) {\n                // looks like the minimum should be 9px when dealing with ems. this is what looks like in browsers.\n                ownAttributes[fSize] = fontSize = parseUnit(ownAttributes[fSize], parentFontSize);\n            }\n            var normalizedAttr, normalizedValue, normalizedStyle = {};\n            for(var attr in ownAttributes){\n                normalizedAttr = normalizeAttr(attr);\n                normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);\n                normalizedStyle[normalizedAttr] = normalizedValue;\n            }\n            if (normalizedStyle && normalizedStyle.font) {\n                fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);\n            }\n            var mergedAttrs = extend(parentAttributes, normalizedStyle);\n            return fabric.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);\n        },\n        /**\n     * Transforms an array of svg elements to corresponding fabric.* instances\n     * @static\n     * @memberOf fabric\n     * @param {Array} elements Array of elements to parse\n     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)\n     * @param {Object} [options] Options object\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     */ parseElements: function(elements, callback, options, reviver, parsingOptions) {\n            new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();\n        },\n        /**\n     * Parses \"style\" attribute, retuning an object with values\n     * @static\n     * @memberOf fabric\n     * @param {SVGElement} element Element to parse\n     * @return {Object} Objects with values parsed from style attribute of an element\n     */ parseStyleAttribute: function(element) {\n            var oStyle = {}, style = element.getAttribute(\"style\");\n            if (!style) {\n                return oStyle;\n            }\n            if (typeof style === \"string\") {\n                parseStyleString(style, oStyle);\n            } else {\n                parseStyleObject(style, oStyle);\n            }\n            return oStyle;\n        },\n        /**\n     * Parses \"points\" attribute, returning an array of values\n     * @static\n     * @memberOf fabric\n     * @param {String} points points attribute string\n     * @return {Array} array of points\n     */ parsePointsAttribute: function(points) {\n            // points attribute is required and must not be empty\n            if (!points) {\n                return null;\n            }\n            // replace commas with whitespace and remove bookending whitespace\n            points = points.replace(/,/g, \" \").trim();\n            points = points.split(/\\s+/);\n            var parsedPoints = [], i, len;\n            for(i = 0, len = points.length; i < len; i += 2){\n                parsedPoints.push({\n                    x: parseFloat(points[i]),\n                    y: parseFloat(points[i + 1])\n                });\n            }\n            // odd number of points is an error\n            // if (parsedPoints.length % 2 !== 0) {\n            //   return null;\n            // }\n            return parsedPoints;\n        },\n        /**\n     * Returns CSS rules for a given SVG document\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {SVGDocument} doc SVG document to parse\n     * @return {Object} CSS rules of this document\n     */ getCSSRules: function(doc) {\n            var styles = doc.getElementsByTagName(\"style\"), i, len, allRules = {}, rules;\n            // very crude parsing of style contents\n            for(i = 0, len = styles.length; i < len; i++){\n                var styleContents = styles[i].textContent;\n                // remove comments\n                styleContents = styleContents.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\");\n                if (styleContents.trim() === \"\") {\n                    continue;\n                }\n                // recovers all the rule in this form `body { style code... }`\n                // rules = styleContents.match(/[^{]*\\{[\\s\\S]*?\\}/g);\n                rules = styleContents.split(\"}\");\n                // remove empty rules.\n                rules = rules.filter(function(rule) {\n                    return rule.trim();\n                });\n                // at this point we have hopefully an array of rules `body { style code... `\n                // eslint-disable-next-line no-loop-func\n                rules.forEach(function(rule) {\n                    var match = rule.split(\"{\"), ruleObj = {}, declaration = match[1].trim(), propertyValuePairs = declaration.split(\";\").filter(function(pair) {\n                        return pair.trim();\n                    });\n                    for(i = 0, len = propertyValuePairs.length; i < len; i++){\n                        var pair = propertyValuePairs[i].split(\":\"), property = pair[0].trim(), value = pair[1].trim();\n                        ruleObj[property] = value;\n                    }\n                    rule = match[0].trim();\n                    rule.split(\",\").forEach(function(_rule) {\n                        _rule = _rule.replace(/^svg/i, \"\").trim();\n                        if (_rule === \"\") {\n                            return;\n                        }\n                        if (allRules[_rule]) {\n                            fabric.util.object.extend(allRules[_rule], ruleObj);\n                        } else {\n                            allRules[_rule] = fabric.util.object.clone(ruleObj);\n                        }\n                    });\n                });\n            }\n            return allRules;\n        },\n        /**\n     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.\n     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)\n     * @memberOf fabric\n     * @param {String} url\n     * @param {Function} callback\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     * @param {Object} [options] Object containing options for parsing\n     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources\n     */ loadSVGFromURL: function(url, callback, reviver, options) {\n            url = url.replace(/^\\n\\s*/, \"\").trim();\n            new fabric.util.request(url, {\n                method: \"get\",\n                onComplete: onComplete\n            });\n            function onComplete(r) {\n                var xml = r.responseXML;\n                if (!xml || !xml.documentElement) {\n                    callback && callback(null);\n                    return false;\n                }\n                fabric.parseSVGDocument(xml.documentElement, function(results, _options, elements, allElements) {\n                    callback && callback(results, _options, elements, allElements);\n                }, reviver, options);\n            }\n        },\n        /**\n     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects\n     * @memberOf fabric\n     * @param {String} string\n     * @param {Function} callback\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     * @param {Object} [options] Object containing options for parsing\n     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources\n     */ loadSVGFromString: function(string, callback, reviver, options) {\n            var parser = new fabric.window.DOMParser(), doc = parser.parseFromString(string.trim(), \"text/xml\");\n            fabric.parseSVGDocument(doc.documentElement, function(results, _options, elements, allElements) {\n                callback(results, _options, elements, allElements);\n            }, reviver, options);\n        }\n    });\n})( true ? exports : 0);\nfabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions, doc) {\n    this.elements = elements;\n    this.callback = callback;\n    this.options = options;\n    this.reviver = reviver;\n    this.svgUid = options && options.svgUid || 0;\n    this.parsingOptions = parsingOptions;\n    this.regexUrl = /^url\\(['\"]?#([^'\"]+)['\"]?\\)/g;\n    this.doc = doc;\n};\n(function(proto) {\n    proto.parse = function() {\n        this.instances = new Array(this.elements.length);\n        this.numElements = this.elements.length;\n        this.createObjects();\n    };\n    proto.createObjects = function() {\n        var _this = this;\n        this.elements.forEach(function(element, i) {\n            element.setAttribute(\"svgUid\", _this.svgUid);\n            _this.createObject(element, i);\n        });\n    };\n    proto.findTag = function(el) {\n        return fabric[fabric.util.string.capitalize(el.tagName.replace(\"svg:\", \"\"))];\n    };\n    proto.createObject = function(el, index) {\n        var klass = this.findTag(el);\n        if (klass && klass.fromElement) {\n            try {\n                klass.fromElement(el, this.createCallback(index, el), this.options);\n            } catch (err) {\n                fabric.log(err);\n            }\n        } else {\n            this.checkIfDone();\n        }\n    };\n    proto.createCallback = function(index, el) {\n        var _this = this;\n        return function(obj) {\n            var _options;\n            _this.resolveGradient(obj, el, \"fill\");\n            _this.resolveGradient(obj, el, \"stroke\");\n            if (obj instanceof fabric.Image && obj._originalElement) {\n                _options = obj.parsePreserveAspectRatioAttribute(el);\n            }\n            obj._removeTransformMatrix(_options);\n            _this.resolveClipPath(obj, el);\n            _this.reviver && _this.reviver(el, obj);\n            _this.instances[index] = obj;\n            _this.checkIfDone();\n        };\n    };\n    proto.extractPropertyDefinition = function(obj, property, storage) {\n        var value = obj[property], regex = this.regexUrl;\n        if (!regex.test(value)) {\n            return;\n        }\n        regex.lastIndex = 0;\n        var id = regex.exec(value)[1];\n        regex.lastIndex = 0;\n        return fabric[storage][this.svgUid][id];\n    };\n    proto.resolveGradient = function(obj, el, property) {\n        var gradientDef = this.extractPropertyDefinition(obj, property, \"gradientDefs\");\n        if (gradientDef) {\n            var opacityAttr = el.getAttribute(property + \"-opacity\");\n            var gradient = fabric.Gradient.fromElement(gradientDef, obj, opacityAttr, this.options);\n            obj.set(property, gradient);\n        }\n    };\n    proto.createClipPathCallback = function(obj, container) {\n        return function(_newObj) {\n            _newObj._removeTransformMatrix();\n            _newObj.fillRule = _newObj.clipRule;\n            container.push(_newObj);\n        };\n    };\n    proto.resolveClipPath = function(obj, usingElement) {\n        var clipPath = this.extractPropertyDefinition(obj, \"clipPath\", \"clipPaths\"), element, klass, objTransformInv, container, gTransform, options;\n        if (clipPath) {\n            container = [];\n            objTransformInv = fabric.util.invertTransform(obj.calcTransformMatrix());\n            // move the clipPath tag as sibling to the real element that is using it\n            var clipPathTag = clipPath[0].parentNode;\n            var clipPathOwner = usingElement;\n            while(clipPathOwner.parentNode && clipPathOwner.getAttribute(\"clip-path\") !== obj.clipPath){\n                clipPathOwner = clipPathOwner.parentNode;\n            }\n            clipPathOwner.parentNode.appendChild(clipPathTag);\n            for(var i = 0; i < clipPath.length; i++){\n                element = clipPath[i];\n                klass = this.findTag(element);\n                klass.fromElement(element, this.createClipPathCallback(obj, container), this.options);\n            }\n            if (container.length === 1) {\n                clipPath = container[0];\n            } else {\n                clipPath = new fabric.Group(container);\n            }\n            gTransform = fabric.util.multiplyTransformMatrices(objTransformInv, clipPath.calcTransformMatrix());\n            if (clipPath.clipPath) {\n                this.resolveClipPath(clipPath, clipPathOwner);\n            }\n            var options = fabric.util.qrDecompose(gTransform);\n            clipPath.flipX = false;\n            clipPath.flipY = false;\n            clipPath.set(\"scaleX\", options.scaleX);\n            clipPath.set(\"scaleY\", options.scaleY);\n            clipPath.angle = options.angle;\n            clipPath.skewX = options.skewX;\n            clipPath.skewY = 0;\n            clipPath.setPositionByOrigin({\n                x: options.translateX,\n                y: options.translateY\n            }, \"center\", \"center\");\n            obj.clipPath = clipPath;\n        } else {\n            // if clip-path does not resolve to any element, delete the property.\n            delete obj.clipPath;\n        }\n    };\n    proto.checkIfDone = function() {\n        if (--this.numElements === 0) {\n            this.instances = this.instances.filter(function(el) {\n                // eslint-disable-next-line no-eq-null, eqeqeq\n                return el != null;\n            });\n            this.callback(this.instances, this.elements);\n        }\n    };\n})(fabric.ElementsParser.prototype);\n(function(global) {\n    \"use strict\";\n    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */ var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Point) {\n        fabric.warn(\"fabric.Point is already defined\");\n        return;\n    }\n    fabric.Point = Point;\n    /**\n   * Point class\n   * @class fabric.Point\n   * @memberOf fabric\n   * @constructor\n   * @param {Number} x\n   * @param {Number} y\n   * @return {fabric.Point} thisArg\n   */ function Point(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    Point.prototype = /** @lends fabric.Point.prototype */ {\n        type: \"point\",\n        constructor: Point,\n        /**\n     * Adds another point to this one and returns another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} new Point instance with added values\n     */ add: function(that) {\n            return new Point(this.x + that.x, this.y + that.y);\n        },\n        /**\n     * Adds another point to this one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ addEquals: function(that) {\n            this.x += that.x;\n            this.y += that.y;\n            return this;\n        },\n        /**\n     * Adds value to this point and returns a new one\n     * @param {Number} scalar\n     * @return {fabric.Point} new Point with added value\n     */ scalarAdd: function(scalar) {\n            return new Point(this.x + scalar, this.y + scalar);\n        },\n        /**\n     * Adds value to this point\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ scalarAddEquals: function(scalar) {\n            this.x += scalar;\n            this.y += scalar;\n            return this;\n        },\n        /**\n     * Subtracts another point from this point and returns a new one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} new Point object with subtracted values\n     */ subtract: function(that) {\n            return new Point(this.x - that.x, this.y - that.y);\n        },\n        /**\n     * Subtracts another point from this point\n     * @param {fabric.Point} that\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ subtractEquals: function(that) {\n            this.x -= that.x;\n            this.y -= that.y;\n            return this;\n        },\n        /**\n     * Subtracts value from this point and returns a new one\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */ scalarSubtract: function(scalar) {\n            return new Point(this.x - scalar, this.y - scalar);\n        },\n        /**\n     * Subtracts value from this point\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ scalarSubtractEquals: function(scalar) {\n            this.x -= scalar;\n            this.y -= scalar;\n            return this;\n        },\n        /**\n     * Multiplies this point by a value and returns a new one\n     * TODO: rename in scalarMultiply in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */ multiply: function(scalar) {\n            return new Point(this.x * scalar, this.y * scalar);\n        },\n        /**\n     * Multiplies this point by a value\n     * TODO: rename in scalarMultiplyEquals in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ multiplyEquals: function(scalar) {\n            this.x *= scalar;\n            this.y *= scalar;\n            return this;\n        },\n        /**\n     * Divides this point by a value and returns a new one\n     * TODO: rename in scalarDivide in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */ divide: function(scalar) {\n            return new Point(this.x / scalar, this.y / scalar);\n        },\n        /**\n     * Divides this point by a value\n     * TODO: rename in scalarDivideEquals in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ divideEquals: function(scalar) {\n            this.x /= scalar;\n            this.y /= scalar;\n            return this;\n        },\n        /**\n     * Returns true if this point is equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ eq: function(that) {\n            return this.x === that.x && this.y === that.y;\n        },\n        /**\n     * Returns true if this point is less than another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ lt: function(that) {\n            return this.x < that.x && this.y < that.y;\n        },\n        /**\n     * Returns true if this point is less than or equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ lte: function(that) {\n            return this.x <= that.x && this.y <= that.y;\n        },\n        /**\n\n     * Returns true if this point is greater another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ gt: function(that) {\n            return this.x > that.x && this.y > that.y;\n        },\n        /**\n     * Returns true if this point is greater than or equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ gte: function(that) {\n            return this.x >= that.x && this.y >= that.y;\n        },\n        /**\n     * Returns new point which is the result of linear interpolation with this one and another one\n     * @param {fabric.Point} that\n     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5\n     * @return {fabric.Point}\n     */ lerp: function(that, t) {\n            if (typeof t === \"undefined\") {\n                t = 0.5;\n            }\n            t = Math.max(Math.min(1, t), 0);\n            return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);\n        },\n        /**\n     * Returns distance from this point and another one\n     * @param {fabric.Point} that\n     * @return {Number}\n     */ distanceFrom: function(that) {\n            var dx = this.x - that.x, dy = this.y - that.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        },\n        /**\n     * Returns the point between this point and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */ midPointFrom: function(that) {\n            return this.lerp(that);\n        },\n        /**\n     * Returns a new point which is the min of this and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */ min: function(that) {\n            return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));\n        },\n        /**\n     * Returns a new point which is the max of this and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */ max: function(that) {\n            return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));\n        },\n        /**\n     * Returns string representation of this point\n     * @return {String}\n     */ toString: function() {\n            return this.x + \",\" + this.y;\n        },\n        /**\n     * Sets x/y of this point\n     * @param {Number} x\n     * @param {Number} y\n     * @chainable\n     */ setXY: function(x, y) {\n            this.x = x;\n            this.y = y;\n            return this;\n        },\n        /**\n     * Sets x of this point\n     * @param {Number} x\n     * @chainable\n     */ setX: function(x) {\n            this.x = x;\n            return this;\n        },\n        /**\n     * Sets y of this point\n     * @param {Number} y\n     * @chainable\n     */ setY: function(y) {\n            this.y = y;\n            return this;\n        },\n        /**\n     * Sets x/y of this point from another point\n     * @param {fabric.Point} that\n     * @chainable\n     */ setFromPoint: function(that) {\n            this.x = that.x;\n            this.y = that.y;\n            return this;\n        },\n        /**\n     * Swaps x/y of this point and another point\n     * @param {fabric.Point} that\n     */ swap: function(that) {\n            var x = this.x, y = this.y;\n            this.x = that.x;\n            this.y = that.y;\n            that.x = x;\n            that.y = y;\n        },\n        /**\n     * return a cloned instance of the point\n     * @return {fabric.Point}\n     */ clone: function() {\n            return new Point(this.x, this.y);\n        }\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */ var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Intersection) {\n        fabric.warn(\"fabric.Intersection is already defined\");\n        return;\n    }\n    /**\n   * Intersection class\n   * @class fabric.Intersection\n   * @memberOf fabric\n   * @constructor\n   */ function Intersection(status) {\n        this.status = status;\n        this.points = [];\n    }\n    fabric.Intersection = Intersection;\n    fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {\n        constructor: Intersection,\n        /**\n     * Appends a point to intersection\n     * @param {fabric.Point} point\n     * @return {fabric.Intersection} thisArg\n     * @chainable\n     */ appendPoint: function(point) {\n            this.points.push(point);\n            return this;\n        },\n        /**\n     * Appends points to intersection\n     * @param {Array} points\n     * @return {fabric.Intersection} thisArg\n     * @chainable\n     */ appendPoints: function(points) {\n            this.points = this.points.concat(points);\n            return this;\n        }\n    };\n    /**\n   * Checks if one line intersects another\n   * TODO: rename in intersectSegmentSegment\n   * @static\n   * @param {fabric.Point} a1\n   * @param {fabric.Point} a2\n   * @param {fabric.Point} b1\n   * @param {fabric.Point} b2\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectLineLine = function(a1, a2, b1, b2) {\n        var result, uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x), ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x), uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n        if (uB !== 0) {\n            var ua = uaT / uB, ub = ubT / uB;\n            if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n                result = new Intersection(\"Intersection\");\n                result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));\n            } else {\n                result = new Intersection();\n            }\n        } else {\n            if (uaT === 0 || ubT === 0) {\n                result = new Intersection(\"Coincident\");\n            } else {\n                result = new Intersection(\"Parallel\");\n            }\n        }\n        return result;\n    };\n    /**\n   * Checks if line intersects polygon\n   * TODO: rename in intersectSegmentPolygon\n   * fix detection of coincident\n   * @static\n   * @param {fabric.Point} a1\n   * @param {fabric.Point} a2\n   * @param {Array} points\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {\n        var result = new Intersection(), length = points.length, b1, b2, inter, i;\n        for(i = 0; i < length; i++){\n            b1 = points[i];\n            b2 = points[(i + 1) % length];\n            inter = Intersection.intersectLineLine(a1, a2, b1, b2);\n            result.appendPoints(inter.points);\n        }\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        return result;\n    };\n    /**\n   * Checks if polygon intersects another polygon\n   * @static\n   * @param {Array} points1\n   * @param {Array} points2\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectPolygonPolygon = function(points1, points2) {\n        var result = new Intersection(), length = points1.length, i;\n        for(i = 0; i < length; i++){\n            var a1 = points1[i], a2 = points1[(i + 1) % length], inter = Intersection.intersectLinePolygon(a1, a2, points2);\n            result.appendPoints(inter.points);\n        }\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        return result;\n    };\n    /**\n   * Checks if polygon intersects rectangle\n   * @static\n   * @param {Array} points\n   * @param {fabric.Point} r1\n   * @param {fabric.Point} r2\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectPolygonRectangle = function(points, r1, r2) {\n        var min = r1.min(r2), max = r1.max(r2), topRight = new fabric.Point(max.x, min.y), bottomLeft = new fabric.Point(min.x, max.y), inter1 = Intersection.intersectLinePolygon(min, topRight, points), inter2 = Intersection.intersectLinePolygon(topRight, max, points), inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points), inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points), result = new Intersection();\n        result.appendPoints(inter1.points);\n        result.appendPoints(inter2.points);\n        result.appendPoints(inter3.points);\n        result.appendPoints(inter4.points);\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        return result;\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Color) {\n        fabric.warn(\"fabric.Color is already defined.\");\n        return;\n    }\n    /**\n   * Color class\n   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;\n   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.\n   *\n   * @class fabric.Color\n   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list\n   * @return {fabric.Color} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}\n   */ function Color(color) {\n        if (!color) {\n            this.setSource([\n                0,\n                0,\n                0,\n                1\n            ]);\n        } else {\n            this._tryParsingColor(color);\n        }\n    }\n    fabric.Color = Color;\n    fabric.Color.prototype = /** @lends fabric.Color.prototype */ {\n        /**\n     * @private\n     * @param {String|Array} color Color value to parse\n     */ _tryParsingColor: function(color) {\n            var source;\n            if (color in Color.colorNameMap) {\n                color = Color.colorNameMap[color];\n            }\n            if (color === \"transparent\") {\n                source = [\n                    255,\n                    255,\n                    255,\n                    0\n                ];\n            }\n            if (!source) {\n                source = Color.sourceFromHex(color);\n            }\n            if (!source) {\n                source = Color.sourceFromRgb(color);\n            }\n            if (!source) {\n                source = Color.sourceFromHsl(color);\n            }\n            if (!source) {\n                //if color is not recognize let's make black as canvas does\n                source = [\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n            }\n            if (source) {\n                this.setSource(source);\n            }\n        },\n        /**\n     * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\n     * @private\n     * @param {Number} r Red color value\n     * @param {Number} g Green color value\n     * @param {Number} b Blue color value\n     * @return {Array} Hsl color\n     */ _rgbToHsl: function(r, g, b) {\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            var h, s, l, max = fabric.util.array.max([\n                r,\n                g,\n                b\n            ]), min = fabric.util.array.min([\n                r,\n                g,\n                b\n            ]);\n            l = (max + min) / 2;\n            if (max === min) {\n                h = s = 0; // achromatic\n            } else {\n                var d = max - min;\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                switch(max){\n                    case r:\n                        h = (g - b) / d + (g < b ? 6 : 0);\n                        break;\n                    case g:\n                        h = (b - r) / d + 2;\n                        break;\n                    case b:\n                        h = (r - g) / d + 4;\n                        break;\n                }\n                h /= 6;\n            }\n            return [\n                Math.round(h * 360),\n                Math.round(s * 100),\n                Math.round(l * 100)\n            ];\n        },\n        /**\n     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])\n     * @return {Array}\n     */ getSource: function() {\n            return this._source;\n        },\n        /**\n     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])\n     * @param {Array} source\n     */ setSource: function(source) {\n            this._source = source;\n        },\n        /**\n     * Returns color representation in RGB format\n     * @return {String} ex: rgb(0-255,0-255,0-255)\n     */ toRgb: function() {\n            var source = this.getSource();\n            return \"rgb(\" + source[0] + \",\" + source[1] + \",\" + source[2] + \")\";\n        },\n        /**\n     * Returns color representation in RGBA format\n     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)\n     */ toRgba: function() {\n            var source = this.getSource();\n            return \"rgba(\" + source[0] + \",\" + source[1] + \",\" + source[2] + \",\" + source[3] + \")\";\n        },\n        /**\n     * Returns color representation in HSL format\n     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)\n     */ toHsl: function() {\n            var source = this.getSource(), hsl = this._rgbToHsl(source[0], source[1], source[2]);\n            return \"hsl(\" + hsl[0] + \",\" + hsl[1] + \"%,\" + hsl[2] + \"%)\";\n        },\n        /**\n     * Returns color representation in HSLA format\n     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)\n     */ toHsla: function() {\n            var source = this.getSource(), hsl = this._rgbToHsl(source[0], source[1], source[2]);\n            return \"hsla(\" + hsl[0] + \",\" + hsl[1] + \"%,\" + hsl[2] + \"%,\" + source[3] + \")\";\n        },\n        /**\n     * Returns color representation in HEX format\n     * @return {String} ex: FF5555\n     */ toHex: function() {\n            var source = this.getSource(), r, g, b;\n            r = source[0].toString(16);\n            r = r.length === 1 ? \"0\" + r : r;\n            g = source[1].toString(16);\n            g = g.length === 1 ? \"0\" + g : g;\n            b = source[2].toString(16);\n            b = b.length === 1 ? \"0\" + b : b;\n            return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();\n        },\n        /**\n     * Returns color representation in HEXA format\n     * @return {String} ex: FF5555CC\n     */ toHexa: function() {\n            var source = this.getSource(), a;\n            a = Math.round(source[3] * 255);\n            a = a.toString(16);\n            a = a.length === 1 ? \"0\" + a : a;\n            return this.toHex() + a.toUpperCase();\n        },\n        /**\n     * Gets value of alpha channel for this color\n     * @return {Number} 0-1\n     */ getAlpha: function() {\n            return this.getSource()[3];\n        },\n        /**\n     * Sets value of alpha channel for this color\n     * @param {Number} alpha Alpha value 0-1\n     * @return {fabric.Color} thisArg\n     */ setAlpha: function(alpha) {\n            var source = this.getSource();\n            source[3] = alpha;\n            this.setSource(source);\n            return this;\n        },\n        /**\n     * Transforms color to its grayscale representation\n     * @return {fabric.Color} thisArg\n     */ toGrayscale: function() {\n            var source = this.getSource(), average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10), currentAlpha = source[3];\n            this.setSource([\n                average,\n                average,\n                average,\n                currentAlpha\n            ]);\n            return this;\n        },\n        /**\n     * Transforms color to its black and white representation\n     * @param {Number} threshold\n     * @return {fabric.Color} thisArg\n     */ toBlackWhite: function(threshold) {\n            var source = this.getSource(), average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), currentAlpha = source[3];\n            threshold = threshold || 127;\n            average = Number(average) < Number(threshold) ? 0 : 255;\n            this.setSource([\n                average,\n                average,\n                average,\n                currentAlpha\n            ]);\n            return this;\n        },\n        /**\n     * Overlays color with another color\n     * @param {String|fabric.Color} otherColor\n     * @return {fabric.Color} thisArg\n     */ overlayWith: function(otherColor) {\n            if (!(otherColor instanceof Color)) {\n                otherColor = new Color(otherColor);\n            }\n            var result = [], alpha = this.getAlpha(), otherAlpha = 0.5, source = this.getSource(), otherSource = otherColor.getSource(), i;\n            for(i = 0; i < 3; i++){\n                result.push(Math.round(source[i] * (1 - otherAlpha) + otherSource[i] * otherAlpha));\n            }\n            result[3] = alpha;\n            this.setSource(result);\n            return this;\n        }\n    };\n    /**\n   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ // eslint-disable-next-line max-len\n    fabric.Color.reRGBa = /^rgba?\\(\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*(?:\\s*,\\s*((?:\\d*\\.?\\d+)?)\\s*)?\\)$/i;\n    /**\n   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ fabric.Color.reHSLa = /^hsla?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}\\%)\\s*,\\s*(\\d{1,3}\\%)\\s*(?:\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*)?\\)$/i;\n    /**\n   * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;\n    /**\n   * Map of the 148 color names with HEX code\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   * @see: https://www.w3.org/TR/css3-color/#svg-color\n   */ fabric.Color.colorNameMap = {\n        aliceblue: \"#F0F8FF\",\n        antiquewhite: \"#FAEBD7\",\n        aqua: \"#00FFFF\",\n        aquamarine: \"#7FFFD4\",\n        azure: \"#F0FFFF\",\n        beige: \"#F5F5DC\",\n        bisque: \"#FFE4C4\",\n        black: \"#000000\",\n        blanchedalmond: \"#FFEBCD\",\n        blue: \"#0000FF\",\n        blueviolet: \"#8A2BE2\",\n        brown: \"#A52A2A\",\n        burlywood: \"#DEB887\",\n        cadetblue: \"#5F9EA0\",\n        chartreuse: \"#7FFF00\",\n        chocolate: \"#D2691E\",\n        coral: \"#FF7F50\",\n        cornflowerblue: \"#6495ED\",\n        cornsilk: \"#FFF8DC\",\n        crimson: \"#DC143C\",\n        cyan: \"#00FFFF\",\n        darkblue: \"#00008B\",\n        darkcyan: \"#008B8B\",\n        darkgoldenrod: \"#B8860B\",\n        darkgray: \"#A9A9A9\",\n        darkgrey: \"#A9A9A9\",\n        darkgreen: \"#006400\",\n        darkkhaki: \"#BDB76B\",\n        darkmagenta: \"#8B008B\",\n        darkolivegreen: \"#556B2F\",\n        darkorange: \"#FF8C00\",\n        darkorchid: \"#9932CC\",\n        darkred: \"#8B0000\",\n        darksalmon: \"#E9967A\",\n        darkseagreen: \"#8FBC8F\",\n        darkslateblue: \"#483D8B\",\n        darkslategray: \"#2F4F4F\",\n        darkslategrey: \"#2F4F4F\",\n        darkturquoise: \"#00CED1\",\n        darkviolet: \"#9400D3\",\n        deeppink: \"#FF1493\",\n        deepskyblue: \"#00BFFF\",\n        dimgray: \"#696969\",\n        dimgrey: \"#696969\",\n        dodgerblue: \"#1E90FF\",\n        firebrick: \"#B22222\",\n        floralwhite: \"#FFFAF0\",\n        forestgreen: \"#228B22\",\n        fuchsia: \"#FF00FF\",\n        gainsboro: \"#DCDCDC\",\n        ghostwhite: \"#F8F8FF\",\n        gold: \"#FFD700\",\n        goldenrod: \"#DAA520\",\n        gray: \"#808080\",\n        grey: \"#808080\",\n        green: \"#008000\",\n        greenyellow: \"#ADFF2F\",\n        honeydew: \"#F0FFF0\",\n        hotpink: \"#FF69B4\",\n        indianred: \"#CD5C5C\",\n        indigo: \"#4B0082\",\n        ivory: \"#FFFFF0\",\n        khaki: \"#F0E68C\",\n        lavender: \"#E6E6FA\",\n        lavenderblush: \"#FFF0F5\",\n        lawngreen: \"#7CFC00\",\n        lemonchiffon: \"#FFFACD\",\n        lightblue: \"#ADD8E6\",\n        lightcoral: \"#F08080\",\n        lightcyan: \"#E0FFFF\",\n        lightgoldenrodyellow: \"#FAFAD2\",\n        lightgray: \"#D3D3D3\",\n        lightgrey: \"#D3D3D3\",\n        lightgreen: \"#90EE90\",\n        lightpink: \"#FFB6C1\",\n        lightsalmon: \"#FFA07A\",\n        lightseagreen: \"#20B2AA\",\n        lightskyblue: \"#87CEFA\",\n        lightslategray: \"#778899\",\n        lightslategrey: \"#778899\",\n        lightsteelblue: \"#B0C4DE\",\n        lightyellow: \"#FFFFE0\",\n        lime: \"#00FF00\",\n        limegreen: \"#32CD32\",\n        linen: \"#FAF0E6\",\n        magenta: \"#FF00FF\",\n        maroon: \"#800000\",\n        mediumaquamarine: \"#66CDAA\",\n        mediumblue: \"#0000CD\",\n        mediumorchid: \"#BA55D3\",\n        mediumpurple: \"#9370DB\",\n        mediumseagreen: \"#3CB371\",\n        mediumslateblue: \"#7B68EE\",\n        mediumspringgreen: \"#00FA9A\",\n        mediumturquoise: \"#48D1CC\",\n        mediumvioletred: \"#C71585\",\n        midnightblue: \"#191970\",\n        mintcream: \"#F5FFFA\",\n        mistyrose: \"#FFE4E1\",\n        moccasin: \"#FFE4B5\",\n        navajowhite: \"#FFDEAD\",\n        navy: \"#000080\",\n        oldlace: \"#FDF5E6\",\n        olive: \"#808000\",\n        olivedrab: \"#6B8E23\",\n        orange: \"#FFA500\",\n        orangered: \"#FF4500\",\n        orchid: \"#DA70D6\",\n        palegoldenrod: \"#EEE8AA\",\n        palegreen: \"#98FB98\",\n        paleturquoise: \"#AFEEEE\",\n        palevioletred: \"#DB7093\",\n        papayawhip: \"#FFEFD5\",\n        peachpuff: \"#FFDAB9\",\n        peru: \"#CD853F\",\n        pink: \"#FFC0CB\",\n        plum: \"#DDA0DD\",\n        powderblue: \"#B0E0E6\",\n        purple: \"#800080\",\n        rebeccapurple: \"#663399\",\n        red: \"#FF0000\",\n        rosybrown: \"#BC8F8F\",\n        royalblue: \"#4169E1\",\n        saddlebrown: \"#8B4513\",\n        salmon: \"#FA8072\",\n        sandybrown: \"#F4A460\",\n        seagreen: \"#2E8B57\",\n        seashell: \"#FFF5EE\",\n        sienna: \"#A0522D\",\n        silver: \"#C0C0C0\",\n        skyblue: \"#87CEEB\",\n        slateblue: \"#6A5ACD\",\n        slategray: \"#708090\",\n        slategrey: \"#708090\",\n        snow: \"#FFFAFA\",\n        springgreen: \"#00FF7F\",\n        steelblue: \"#4682B4\",\n        tan: \"#D2B48C\",\n        teal: \"#008080\",\n        thistle: \"#D8BFD8\",\n        tomato: \"#FF6347\",\n        turquoise: \"#40E0D0\",\n        violet: \"#EE82EE\",\n        wheat: \"#F5DEB3\",\n        white: \"#FFFFFF\",\n        whitesmoke: \"#F5F5F5\",\n        yellow: \"#FFFF00\",\n        yellowgreen: \"#9ACD32\"\n    };\n    /**\n   * @private\n   * @param {Number} p\n   * @param {Number} q\n   * @param {Number} t\n   * @return {Number}\n   */ function hue2rgb(p, q, t) {\n        if (t < 0) {\n            t += 1;\n        }\n        if (t > 1) {\n            t -= 1;\n        }\n        if (t < 1 / 6) {\n            return p + (q - p) * 6 * t;\n        }\n        if (t < 1 / 2) {\n            return q;\n        }\n        if (t < 2 / 3) {\n            return p + (q - p) * (2 / 3 - t) * 6;\n        }\n        return p;\n    }\n    /**\n   * Returns new color object, when given a color in RGB format\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)\n   * @return {fabric.Color}\n   */ fabric.Color.fromRgb = function(color) {\n        return Color.fromSource(Color.sourceFromRgb(color));\n    };\n    /**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)\n   * @return {Array} source\n   */ fabric.Color.sourceFromRgb = function(color) {\n        var match = color.match(Color.reRGBa);\n        if (match) {\n            var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1), g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1), b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);\n            return [\n                parseInt(r, 10),\n                parseInt(g, 10),\n                parseInt(b, 10),\n                match[4] ? parseFloat(match[4]) : 1\n            ];\n        }\n    };\n    /**\n   * Returns new color object, when given a color in RGBA format\n   * @static\n   * @function\n   * @memberOf fabric.Color\n   * @param {String} color\n   * @return {fabric.Color}\n   */ fabric.Color.fromRgba = Color.fromRgb;\n    /**\n   * Returns new color object, when given a color in HSL format\n   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)\n   * @memberOf fabric.Color\n   * @return {fabric.Color}\n   */ fabric.Color.fromHsl = function(color) {\n        return Color.fromSource(Color.sourceFromHsl(color));\n    };\n    /**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.\n   * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)\n   * @return {Array} source\n   * @see http://http://www.w3.org/TR/css3-color/#hsl-color\n   */ fabric.Color.sourceFromHsl = function(color) {\n        var match = color.match(Color.reHSLa);\n        if (!match) {\n            return;\n        }\n        var h = (parseFloat(match[1]) % 360 + 360) % 360 / 360, s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1), l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1), r, g, b;\n        if (s === 0) {\n            r = g = b = l;\n        } else {\n            var q = l <= 0.5 ? l * (s + 1) : l + s - l * s, p = l * 2 - q;\n            r = hue2rgb(p, q, h + 1 / 3);\n            g = hue2rgb(p, q, h);\n            b = hue2rgb(p, q, h - 1 / 3);\n        }\n        return [\n            Math.round(r * 255),\n            Math.round(g * 255),\n            Math.round(b * 255),\n            match[4] ? parseFloat(match[4]) : 1\n        ];\n    };\n    /**\n   * Returns new color object, when given a color in HSLA format\n   * @static\n   * @function\n   * @memberOf fabric.Color\n   * @param {String} color\n   * @return {fabric.Color}\n   */ fabric.Color.fromHsla = Color.fromHsl;\n    /**\n   * Returns new color object, when given a color in HEX format\n   * @static\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: FF5555\n   * @return {fabric.Color}\n   */ fabric.Color.fromHex = function(color) {\n        return Color.fromSource(Color.sourceFromHex(color));\n    };\n    /**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format\n   * @static\n   * @memberOf fabric.Color\n   * @param {String} color ex: FF5555 or FF5544CC (RGBa)\n   * @return {Array} source\n   */ fabric.Color.sourceFromHex = function(color) {\n        if (color.match(Color.reHex)) {\n            var value = color.slice(color.indexOf(\"#\") + 1), isShortNotation = value.length === 3 || value.length === 4, isRGBa = value.length === 8 || value.length === 4, r = isShortNotation ? value.charAt(0) + value.charAt(0) : value.substring(0, 2), g = isShortNotation ? value.charAt(1) + value.charAt(1) : value.substring(2, 4), b = isShortNotation ? value.charAt(2) + value.charAt(2) : value.substring(4, 6), a = isRGBa ? isShortNotation ? value.charAt(3) + value.charAt(3) : value.substring(6, 8) : \"FF\";\n            return [\n                parseInt(r, 16),\n                parseInt(g, 16),\n                parseInt(b, 16),\n                parseFloat((parseInt(a, 16) / 255).toFixed(2))\n            ];\n        }\n    };\n    /**\n   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])\n   * @static\n   * @memberOf fabric.Color\n   * @param {Array} source\n   * @return {fabric.Color}\n   */ fabric.Color.fromSource = function(source) {\n        var oColor = new Color();\n        oColor.setSource(source);\n        return oColor;\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), scaleMap = [\n        \"e\",\n        \"se\",\n        \"s\",\n        \"sw\",\n        \"w\",\n        \"nw\",\n        \"n\",\n        \"ne\",\n        \"e\"\n    ], skewMap = [\n        \"ns\",\n        \"nesw\",\n        \"ew\",\n        \"nwse\"\n    ], controls = {}, LEFT = \"left\", TOP = \"top\", RIGHT = \"right\", BOTTOM = \"bottom\", CENTER = \"center\", opposite = {\n        top: BOTTOM,\n        bottom: TOP,\n        left: RIGHT,\n        right: LEFT,\n        center: CENTER\n    }, radiansToDegrees = fabric.util.radiansToDegrees, sign = Math.sign || function(x) {\n        return (x > 0) - (x < 0) || +x;\n    };\n    /**\n   * Combine control position and object angle to find the control direction compared\n   * to the object center.\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   * @param {fabric.Control} control the control class\n   * @return {Number} 0 - 7 a quadrant number\n   */ function findCornerQuadrant(fabricObject, control) {\n        var cornerAngle = fabricObject.angle + radiansToDegrees(Math.atan2(control.y, control.x)) + 360;\n        return Math.round(cornerAngle % 360 / 45);\n    }\n    function fireEvent(eventName, options) {\n        var target = options.transform.target, canvas = target.canvas, canvasOptions = fabric.util.object.clone(options);\n        canvasOptions.target = target;\n        canvas && canvas.fire(\"object:\" + eventName, canvasOptions);\n        target.fire(eventName, options);\n    }\n    /**\n   * Inspect event and fabricObject properties to understand if the scaling action\n   * @param {Event} eventData from the user action\n   * @param {fabric.Object} fabricObject the fabric object about to scale\n   * @return {Boolean} true if scale is proportional\n   */ function scaleIsProportional(eventData, fabricObject) {\n        var canvas = fabricObject.canvas, uniScaleKey = canvas.uniScaleKey, uniformIsToggled = eventData[uniScaleKey];\n        return canvas.uniformScaling && !uniformIsToggled || !canvas.uniformScaling && uniformIsToggled;\n    }\n    /**\n   * Checks if transform is centered\n   * @param {Object} transform transform data\n   * @return {Boolean} true if transform is centered\n   */ function isTransformCentered(transform) {\n        return transform.originX === CENTER && transform.originY === CENTER;\n    }\n    /**\n   * Inspect fabricObject to understand if the current scaling action is allowed\n   * @param {fabric.Object} fabricObject the fabric object about to scale\n   * @param {String} by 'x' or 'y' or ''\n   * @param {Boolean} scaleProportionally true if we are trying to scale proportionally\n   * @return {Boolean} true if scaling is not allowed at current conditions\n   */ function scalingIsForbidden(fabricObject, by, scaleProportionally) {\n        var lockX = fabricObject.lockScalingX, lockY = fabricObject.lockScalingY;\n        if (lockX && lockY) {\n            return true;\n        }\n        if (!by && (lockX || lockY) && scaleProportionally) {\n            return true;\n        }\n        if (lockX && by === \"x\") {\n            return true;\n        }\n        if (lockY && by === \"y\") {\n            return true;\n        }\n        return false;\n    }\n    /**\n   * return the correct cursor style for the scale action\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function scaleCursorStyleHandler(eventData, control, fabricObject) {\n        var notAllowed = \"not-allowed\", scaleProportionally = scaleIsProportional(eventData, fabricObject), by = \"\";\n        if (control.x !== 0 && control.y === 0) {\n            by = \"x\";\n        } else if (control.x === 0 && control.y !== 0) {\n            by = \"y\";\n        }\n        if (scalingIsForbidden(fabricObject, by, scaleProportionally)) {\n            return notAllowed;\n        }\n        var n = findCornerQuadrant(fabricObject, control);\n        return scaleMap[n] + \"-resize\";\n    }\n    /**\n   * return the correct cursor style for the skew action\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function skewCursorStyleHandler(eventData, control, fabricObject) {\n        var notAllowed = \"not-allowed\";\n        if (control.x !== 0 && fabricObject.lockSkewingY) {\n            return notAllowed;\n        }\n        if (control.y !== 0 && fabricObject.lockSkewingX) {\n            return notAllowed;\n        }\n        var n = findCornerQuadrant(fabricObject, control) % 4;\n        return skewMap[n] + \"-resize\";\n    }\n    /**\n   * Combine skew and scale style handlers to cover fabric standard use case\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function scaleSkewCursorStyleHandler(eventData, control, fabricObject) {\n        if (eventData[fabricObject.canvas.altActionKey]) {\n            return controls.skewCursorStyleHandler(eventData, control, fabricObject);\n        }\n        return controls.scaleCursorStyleHandler(eventData, control, fabricObject);\n    }\n    /**\n   * Inspect event, control and fabricObject to return the correct action name\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} an action name\n   */ function scaleOrSkewActionName(eventData, control, fabricObject) {\n        var isAlternative = eventData[fabricObject.canvas.altActionKey];\n        if (control.x === 0) {\n            // then is scaleY or skewX\n            return isAlternative ? \"skewX\" : \"scaleY\";\n        }\n        if (control.y === 0) {\n            // then is scaleY or skewX\n            return isAlternative ? \"skewY\" : \"scaleX\";\n        }\n    }\n    /**\n   * Find the correct style for the control that is used for rotation.\n   * this function is very simple and it just take care of not-allowed or standard cursor\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function rotationStyleHandler(eventData, control, fabricObject) {\n        if (fabricObject.lockRotation) {\n            return \"not-allowed\";\n        }\n        return control.cursorStyle;\n    }\n    function commonEventInfo(eventData, transform, x, y) {\n        return {\n            e: eventData,\n            transform: transform,\n            pointer: {\n                x: x,\n                y: y\n            }\n        };\n    }\n    /**\n   * Wrap an action handler with saving/restoring object position on the transform.\n   * this is the code that permits to objects to keep their position while transforming.\n   * @param {Function} actionHandler the function to wrap\n   * @return {Function} a function with an action handler signature\n   */ function wrapWithFixedAnchor(actionHandler) {\n        return function(eventData, transform, x, y) {\n            var target = transform.target, centerPoint = target.getCenterPoint(), constraint = target.translateToOriginPoint(centerPoint, transform.originX, transform.originY), actionPerformed = actionHandler(eventData, transform, x, y);\n            target.setPositionByOrigin(constraint, transform.originX, transform.originY);\n            return actionPerformed;\n        };\n    }\n    /**\n   * Wrap an action handler with firing an event if the action is performed\n   * @param {Function} actionHandler the function to wrap\n   * @return {Function} a function with an action handler signature\n   */ function wrapWithFireEvent(eventName, actionHandler) {\n        return function(eventData, transform, x, y) {\n            var actionPerformed = actionHandler(eventData, transform, x, y);\n            if (actionPerformed) {\n                fireEvent(eventName, commonEventInfo(eventData, transform, x, y));\n            }\n            return actionPerformed;\n        };\n    }\n    /**\n   * Transforms a point described by x and y in a distance from the top left corner of the object\n   * bounding box.\n   * @param {Object} transform\n   * @param {String} originX\n   * @param {String} originY\n   * @param {number} x\n   * @param {number} y\n   * @return {Fabric.Point} the normalized point\n   */ function getLocalPoint(transform, originX, originY, x, y) {\n        var target = transform.target, control = target.controls[transform.corner], zoom = target.canvas.getZoom(), padding = target.padding / zoom, localPoint = target.toLocalPoint(new fabric.Point(x, y), originX, originY);\n        if (localPoint.x >= padding) {\n            localPoint.x -= padding;\n        }\n        if (localPoint.x <= -padding) {\n            localPoint.x += padding;\n        }\n        if (localPoint.y >= padding) {\n            localPoint.y -= padding;\n        }\n        if (localPoint.y <= padding) {\n            localPoint.y += padding;\n        }\n        localPoint.x -= control.offsetX;\n        localPoint.y -= control.offsetY;\n        return localPoint;\n    }\n    /**\n   * Detect if the fabric object is flipped on one side.\n   * @param {fabric.Object} target\n   * @return {Boolean} true if one flip, but not two.\n   */ function targetHasOneFlip(target) {\n        return target.flipX !== target.flipY;\n    }\n    /**\n   * Utility function to compensate the scale factor when skew is applied on both axes\n   * @private\n   */ function compensateScaleForSkew(target, oppositeSkew, scaleToCompensate, axis, reference) {\n        if (target[oppositeSkew] !== 0) {\n            var newDim = target._getTransformedDimensions()[axis];\n            var newValue = reference / newDim * target[scaleToCompensate];\n            target.set(scaleToCompensate, newValue);\n        }\n    }\n    /**\n   * Action handler for skewing on the X axis\n   * @private\n   */ function skewObjectX(eventData, transform, x, y) {\n        var target = transform.target, // find how big the object would be, if there was no skewX. takes in account scaling\n        dimNoSkew = target._getTransformedDimensions(0, target.skewY), localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y), // the mouse is in the center of the object, and we want it to stay there.\n        // so the object will grow twice as much as the mouse.\n        // this makes the skew growth to localPoint * 2 - dimNoSkew.\n        totalSkewSize = Math.abs(localPoint.x * 2) - dimNoSkew.x, currentSkew = target.skewX, newSkew;\n        if (totalSkewSize < 2) {\n            // let's make it easy to go back to position 0.\n            newSkew = 0;\n        } else {\n            newSkew = radiansToDegrees(Math.atan2(totalSkewSize / target.scaleX, dimNoSkew.y / target.scaleY));\n            // now we have to find the sign of the skew.\n            // it mostly depend on the origin of transformation.\n            if (transform.originX === LEFT && transform.originY === BOTTOM) {\n                newSkew = -newSkew;\n            }\n            if (transform.originX === RIGHT && transform.originY === TOP) {\n                newSkew = -newSkew;\n            }\n            if (targetHasOneFlip(target)) {\n                newSkew = -newSkew;\n            }\n        }\n        var hasSkewed = currentSkew !== newSkew;\n        if (hasSkewed) {\n            var dimBeforeSkewing = target._getTransformedDimensions().y;\n            target.set(\"skewX\", newSkew);\n            compensateScaleForSkew(target, \"skewY\", \"scaleY\", \"y\", dimBeforeSkewing);\n        }\n        return hasSkewed;\n    }\n    /**\n   * Action handler for skewing on the Y axis\n   * @private\n   */ function skewObjectY(eventData, transform, x, y) {\n        var target = transform.target, // find how big the object would be, if there was no skewX. takes in account scaling\n        dimNoSkew = target._getTransformedDimensions(target.skewX, 0), localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y), // the mouse is in the center of the object, and we want it to stay there.\n        // so the object will grow twice as much as the mouse.\n        // this makes the skew growth to localPoint * 2 - dimNoSkew.\n        totalSkewSize = Math.abs(localPoint.y * 2) - dimNoSkew.y, currentSkew = target.skewY, newSkew;\n        if (totalSkewSize < 2) {\n            // let's make it easy to go back to position 0.\n            newSkew = 0;\n        } else {\n            newSkew = radiansToDegrees(Math.atan2(totalSkewSize / target.scaleY, dimNoSkew.x / target.scaleX));\n            // now we have to find the sign of the skew.\n            // it mostly depend on the origin of transformation.\n            if (transform.originX === LEFT && transform.originY === BOTTOM) {\n                newSkew = -newSkew;\n            }\n            if (transform.originX === RIGHT && transform.originY === TOP) {\n                newSkew = -newSkew;\n            }\n            if (targetHasOneFlip(target)) {\n                newSkew = -newSkew;\n            }\n        }\n        var hasSkewed = currentSkew !== newSkew;\n        if (hasSkewed) {\n            var dimBeforeSkewing = target._getTransformedDimensions().x;\n            target.set(\"skewY\", newSkew);\n            compensateScaleForSkew(target, \"skewX\", \"scaleX\", \"x\", dimBeforeSkewing);\n        }\n        return hasSkewed;\n    }\n    /**\n   * Wrapped Action handler for skewing on the Y axis, takes care of the\n   * skew direction and determine the correct transform origin for the anchor point\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function skewHandlerX(eventData, transform, x, y) {\n        // step1 figure out and change transform origin.\n        // if skewX > 0 and originY bottom we anchor on right\n        // if skewX > 0 and originY top we anchor on left\n        // if skewX < 0 and originY bottom we anchor on left\n        // if skewX < 0 and originY top we anchor on right\n        // if skewX is 0, we look for mouse position to understand where are we going.\n        var target = transform.target, currentSkew = target.skewX, originX, originY = transform.originY;\n        if (target.lockSkewingX) {\n            return false;\n        }\n        if (currentSkew === 0) {\n            var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);\n            if (localPointFromCenter.x > 0) {\n                // we are pulling right, anchor left;\n                originX = LEFT;\n            } else {\n                // we are pulling right, anchor right\n                originX = RIGHT;\n            }\n        } else {\n            if (currentSkew > 0) {\n                originX = originY === TOP ? LEFT : RIGHT;\n            }\n            if (currentSkew < 0) {\n                originX = originY === TOP ? RIGHT : LEFT;\n            }\n            // is the object flipped on one side only? swap the origin.\n            if (targetHasOneFlip(target)) {\n                originX = originX === LEFT ? RIGHT : LEFT;\n            }\n        }\n        // once we have the origin, we find the anchor point\n        transform.originX = originX;\n        var finalHandler = wrapWithFireEvent(\"skewing\", wrapWithFixedAnchor(skewObjectX));\n        return finalHandler(eventData, transform, x, y);\n    }\n    /**\n   * Wrapped Action handler for skewing on the Y axis, takes care of the\n   * skew direction and determine the correct transform origin for the anchor point\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function skewHandlerY(eventData, transform, x, y) {\n        // step1 figure out and change transform origin.\n        // if skewY > 0 and originX left we anchor on top\n        // if skewY > 0 and originX right we anchor on bottom\n        // if skewY < 0 and originX left we anchor on bottom\n        // if skewY < 0 and originX right we anchor on top\n        // if skewY is 0, we look for mouse position to understand where are we going.\n        var target = transform.target, currentSkew = target.skewY, originY, originX = transform.originX;\n        if (target.lockSkewingY) {\n            return false;\n        }\n        if (currentSkew === 0) {\n            var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);\n            if (localPointFromCenter.y > 0) {\n                // we are pulling down, anchor up;\n                originY = TOP;\n            } else {\n                // we are pulling up, anchor down\n                originY = BOTTOM;\n            }\n        } else {\n            if (currentSkew > 0) {\n                originY = originX === LEFT ? TOP : BOTTOM;\n            }\n            if (currentSkew < 0) {\n                originY = originX === LEFT ? BOTTOM : TOP;\n            }\n            // is the object flipped on one side only? swap the origin.\n            if (targetHasOneFlip(target)) {\n                originY = originY === TOP ? BOTTOM : TOP;\n            }\n        }\n        // once we have the origin, we find the anchor point\n        transform.originY = originY;\n        var finalHandler = wrapWithFireEvent(\"skewing\", wrapWithFixedAnchor(skewObjectY));\n        return finalHandler(eventData, transform, x, y);\n    }\n    /**\n   * Action handler for rotation and snapping, without anchor point.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   * @private\n   */ function rotationWithSnapping(eventData, transform, x, y) {\n        var t = transform, target = t.target, pivotPoint = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY);\n        if (target.lockRotation) {\n            return false;\n        }\n        var lastAngle = Math.atan2(t.ey - pivotPoint.y, t.ex - pivotPoint.x), curAngle = Math.atan2(y - pivotPoint.y, x - pivotPoint.x), angle = radiansToDegrees(curAngle - lastAngle + t.theta), hasRotated = true;\n        if (target.snapAngle > 0) {\n            var snapAngle = target.snapAngle, snapThreshold = target.snapThreshold || snapAngle, rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle, leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;\n            if (Math.abs(angle - leftAngleLocked) < snapThreshold) {\n                angle = leftAngleLocked;\n            } else if (Math.abs(angle - rightAngleLocked) < snapThreshold) {\n                angle = rightAngleLocked;\n            }\n        }\n        // normalize angle to positive value\n        if (angle < 0) {\n            angle = 360 + angle;\n        }\n        angle %= 360;\n        hasRotated = target.angle !== angle;\n        target.angle = angle;\n        return hasRotated;\n    }\n    /**\n   * Basic scaling logic, reused with different constrain for scaling X,Y, freely or equally.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @param {Object} options additional information for scaling\n   * @param {String} options.by 'x', 'y', 'equally' or '' to indicate type of scaling\n   * @return {Boolean} true if some change happened\n   * @private\n   */ function scaleObject(eventData, transform, x, y, options) {\n        options = options || {};\n        var target = transform.target, lockScalingX = target.lockScalingX, lockScalingY = target.lockScalingY, by = options.by, newPoint, scaleX, scaleY, dim, scaleProportionally = scaleIsProportional(eventData, target), forbidScaling = scalingIsForbidden(target, by, scaleProportionally), signX, signY, gestureScale = transform.gestureScale;\n        if (forbidScaling) {\n            return false;\n        }\n        if (gestureScale) {\n            scaleX = transform.scaleX * gestureScale;\n            scaleY = transform.scaleY * gestureScale;\n        } else {\n            newPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y);\n            // use of sign: We use sign to detect change of direction of an action. sign usually change when\n            // we cross the origin point with the mouse. So a scale flip for example. There is an issue when scaling\n            // by center and scaling using one middle control ( default: mr, mt, ml, mb), the mouse movement can easily\n            // cross many time the origin point and flip the object. so we need a way to filter out the noise.\n            // This ternary here should be ok to filter out X scaling when we want Y only and vice versa.\n            signX = by !== \"y\" ? sign(newPoint.x) : 1;\n            signY = by !== \"x\" ? sign(newPoint.y) : 1;\n            if (!transform.signX) {\n                transform.signX = signX;\n            }\n            if (!transform.signY) {\n                transform.signY = signY;\n            }\n            if (target.lockScalingFlip && (transform.signX !== signX || transform.signY !== signY)) {\n                return false;\n            }\n            dim = target._getTransformedDimensions();\n            // missing detection of flip and logic to switch the origin\n            if (scaleProportionally && !by) {\n                // uniform scaling\n                var distance = Math.abs(newPoint.x) + Math.abs(newPoint.y), original = transform.original, originalDistance = Math.abs(dim.x * original.scaleX / target.scaleX) + Math.abs(dim.y * original.scaleY / target.scaleY), scale = distance / originalDistance;\n                scaleX = original.scaleX * scale;\n                scaleY = original.scaleY * scale;\n            } else {\n                scaleX = Math.abs(newPoint.x * target.scaleX / dim.x);\n                scaleY = Math.abs(newPoint.y * target.scaleY / dim.y);\n            }\n            // if we are scaling by center, we need to double the scale\n            if (isTransformCentered(transform)) {\n                scaleX *= 2;\n                scaleY *= 2;\n            }\n            if (transform.signX !== signX && by !== \"y\") {\n                transform.originX = opposite[transform.originX];\n                scaleX *= -1;\n                transform.signX = signX;\n            }\n            if (transform.signY !== signY && by !== \"x\") {\n                transform.originY = opposite[transform.originY];\n                scaleY *= -1;\n                transform.signY = signY;\n            }\n        }\n        // minScale is taken are in the setter.\n        var oldScaleX = target.scaleX, oldScaleY = target.scaleY;\n        if (!by) {\n            !lockScalingX && target.set(\"scaleX\", scaleX);\n            !lockScalingY && target.set(\"scaleY\", scaleY);\n        } else {\n            // forbidden cases already handled on top here.\n            by === \"x\" && target.set(\"scaleX\", scaleX);\n            by === \"y\" && target.set(\"scaleY\", scaleY);\n        }\n        return oldScaleX !== target.scaleX || oldScaleY !== target.scaleY;\n    }\n    /**\n   * Generic scaling logic, to scale from corners either equally or freely.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scaleObjectFromCorner(eventData, transform, x, y) {\n        return scaleObject(eventData, transform, x, y);\n    }\n    /**\n   * Scaling logic for the X axis.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scaleObjectX(eventData, transform, x, y) {\n        return scaleObject(eventData, transform, x, y, {\n            by: \"x\"\n        });\n    }\n    /**\n   * Scaling logic for the Y axis.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scaleObjectY(eventData, transform, x, y) {\n        return scaleObject(eventData, transform, x, y, {\n            by: \"y\"\n        });\n    }\n    /**\n   * Composed action handler to either scale Y or skew X\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scalingYOrSkewingX(eventData, transform, x, y) {\n        // ok some safety needed here.\n        if (eventData[transform.target.canvas.altActionKey]) {\n            return controls.skewHandlerX(eventData, transform, x, y);\n        }\n        return controls.scalingY(eventData, transform, x, y);\n    }\n    /**\n   * Composed action handler to either scale X or skew Y\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scalingXOrSkewingY(eventData, transform, x, y) {\n        // ok some safety needed here.\n        if (eventData[transform.target.canvas.altActionKey]) {\n            return controls.skewHandlerY(eventData, transform, x, y);\n        }\n        return controls.scalingX(eventData, transform, x, y);\n    }\n    /**\n   * Action handler to change textbox width\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function changeWidth(eventData, transform, x, y) {\n        var target = transform.target, localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y), strokePadding = target.strokeWidth / (target.strokeUniform ? target.scaleX : 1), multiplier = isTransformCentered(transform) ? 2 : 1, oldWidth = target.width, newWidth = Math.abs(localPoint.x * multiplier / target.scaleX) - strokePadding;\n        target.set(\"width\", Math.max(newWidth, 0));\n        return oldWidth !== newWidth;\n    }\n    /**\n   * Action handler\n   * @private\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if the translation occurred\n   */ function dragHandler(eventData, transform, x, y) {\n        var target = transform.target, newLeft = x - transform.offsetX, newTop = y - transform.offsetY, moveX = !target.get(\"lockMovementX\") && target.left !== newLeft, moveY = !target.get(\"lockMovementY\") && target.top !== newTop;\n        moveX && target.set(\"left\", newLeft);\n        moveY && target.set(\"top\", newTop);\n        if (moveX || moveY) {\n            fireEvent(\"moving\", commonEventInfo(eventData, transform, x, y));\n        }\n        return moveX || moveY;\n    }\n    controls.scaleCursorStyleHandler = scaleCursorStyleHandler;\n    controls.skewCursorStyleHandler = skewCursorStyleHandler;\n    controls.scaleSkewCursorStyleHandler = scaleSkewCursorStyleHandler;\n    controls.rotationWithSnapping = wrapWithFireEvent(\"rotating\", wrapWithFixedAnchor(rotationWithSnapping));\n    controls.scalingEqually = wrapWithFireEvent(\"scaling\", wrapWithFixedAnchor(scaleObjectFromCorner));\n    controls.scalingX = wrapWithFireEvent(\"scaling\", wrapWithFixedAnchor(scaleObjectX));\n    controls.scalingY = wrapWithFireEvent(\"scaling\", wrapWithFixedAnchor(scaleObjectY));\n    controls.scalingYOrSkewingX = scalingYOrSkewingX;\n    controls.scalingXOrSkewingY = scalingXOrSkewingY;\n    controls.changeWidth = wrapWithFireEvent(\"resizing\", wrapWithFixedAnchor(changeWidth));\n    controls.skewHandlerX = skewHandlerX;\n    controls.skewHandlerY = skewHandlerY;\n    controls.dragHandler = dragHandler;\n    controls.scaleOrSkewActionName = scaleOrSkewActionName;\n    controls.rotationStyleHandler = rotationStyleHandler;\n    controls.fireEvent = fireEvent;\n    controls.wrapWithFixedAnchor = wrapWithFixedAnchor;\n    controls.wrapWithFireEvent = wrapWithFireEvent;\n    controls.getLocalPoint = getLocalPoint;\n    fabric.controlsUtils = controls;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), degreesToRadians = fabric.util.degreesToRadians, controls = fabric.controlsUtils;\n    /**\n   * Render a round control, as per fabric features.\n   * This function is written to respect object properties like transparentCorners, cornerSize\n   * cornerColor, cornerStrokeColor\n   * plus the addition of offsetY and offsetX.\n   * @param {CanvasRenderingContext2D} ctx context to render on\n   * @param {Number} left x coordinate where the control center should be\n   * @param {Number} top y coordinate where the control center should be\n   * @param {Object} styleOverride override for fabric.Object controls style\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   */ function renderCircleControl(ctx, left, top, styleOverride, fabricObject) {\n        styleOverride = styleOverride || {};\n        var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize, ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize, transparentCorners = typeof styleOverride.transparentCorners !== \"undefined\" ? styleOverride.transparentCorners : fabricObject.transparentCorners, methodName = transparentCorners ? \"stroke\" : \"fill\", stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor), myLeft = left, myTop = top, size;\n        ctx.save();\n        ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;\n        ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;\n        // as soon as fabric react v5, remove ie11, use proper ellipse code.\n        if (xSize > ySize) {\n            size = xSize;\n            ctx.scale(1.0, ySize / xSize);\n            myTop = top * xSize / ySize;\n        } else if (ySize > xSize) {\n            size = ySize;\n            ctx.scale(xSize / ySize, 1.0);\n            myLeft = left * ySize / xSize;\n        } else {\n            size = xSize;\n        }\n        // this is still wrong\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.arc(myLeft, myTop, size / 2, 0, 2 * Math.PI, false);\n        ctx[methodName]();\n        if (stroke) {\n            ctx.stroke();\n        }\n        ctx.restore();\n    }\n    /**\n   * Render a square control, as per fabric features.\n   * This function is written to respect object properties like transparentCorners, cornerSize\n   * cornerColor, cornerStrokeColor\n   * plus the addition of offsetY and offsetX.\n   * @param {CanvasRenderingContext2D} ctx context to render on\n   * @param {Number} left x coordinate where the control center should be\n   * @param {Number} top y coordinate where the control center should be\n   * @param {Object} styleOverride override for fabric.Object controls style\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   */ function renderSquareControl(ctx, left, top, styleOverride, fabricObject) {\n        styleOverride = styleOverride || {};\n        var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize, ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize, transparentCorners = typeof styleOverride.transparentCorners !== \"undefined\" ? styleOverride.transparentCorners : fabricObject.transparentCorners, methodName = transparentCorners ? \"stroke\" : \"fill\", stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor), xSizeBy2 = xSize / 2, ySizeBy2 = ySize / 2;\n        ctx.save();\n        ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;\n        ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;\n        // this is still wrong\n        ctx.lineWidth = 1;\n        ctx.translate(left, top);\n        ctx.rotate(degreesToRadians(fabricObject.angle));\n        // this does not work, and fixed with ( && ) does not make sense.\n        // to have real transparent corners we need the controls on upperCanvas\n        // transparentCorners || ctx.clearRect(-xSizeBy2, -ySizeBy2, xSize, ySize);\n        ctx[methodName + \"Rect\"](-xSizeBy2, -ySizeBy2, xSize, ySize);\n        if (stroke) {\n            ctx.strokeRect(-xSizeBy2, -ySizeBy2, xSize, ySize);\n        }\n        ctx.restore();\n    }\n    controls.renderCircleControl = renderCircleControl;\n    controls.renderSquareControl = renderSquareControl;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    function Control(options) {\n        for(var i in options){\n            this[i] = options[i];\n        }\n    }\n    fabric.Control = Control;\n    fabric.Control.prototype = /** @lends fabric.Control.prototype */ {\n        /**\n     * keep track of control visibility.\n     * mainly for backward compatibility.\n     * if you do not want to see a control, you can remove it\n     * from the controlset.\n     * @type {Boolean}\n     * @default true\n     */ visible: true,\n        /**\n     * Name of the action that the control will likely execute.\n     * This is optional. FabricJS uses to identify what the user is doing for some\n     * extra optimizations. If you are writing a custom control and you want to know\n     * somewhere else in the code what is going on, you can use this string here.\n     * you can also provide a custom getActionName if your control run multiple actions\n     * depending on some external state.\n     * default to scale since is the most common, used on 4 corners by default\n     * @type {String}\n     * @default 'scale'\n     */ actionName: \"scale\",\n        /**\n     * Drawing angle of the control.\n     * NOT used for now, but name marked as needed for internal logic\n     * example: to reuse the same drawing function for different rotated controls\n     * @type {Number}\n     * @default 0\n     */ angle: 0,\n        /**\n     * Relative position of the control. X\n     * 0,0 is the center of the Object, while -0.5 (left) or 0.5 (right) are the extremities\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */ x: 0,\n        /**\n     * Relative position of the control. Y\n     * 0,0 is the center of the Object, while -0.5 (top) or 0.5 (bottom) are the extremities\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */ y: 0,\n        /**\n     * Horizontal offset of the control from the defined position. In pixels\n     * Positive offset moves the control to the right, negative to the left.\n     * It used when you want to have position of control that does not scale with\n     * the bounding box. Example: rotation control is placed at x:0, y: 0.5 on\n     * the boundindbox, with an offset of 30 pixels vertically. Those 30 pixels will\n     * stay 30 pixels no matter how the object is big. Another example is having 2\n     * controls in the corner, that stay in the same position when the object scale.\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */ offsetX: 0,\n        /**\n     * Vertical offset of the control from the defined position. In pixels\n     * Positive offset moves the control to the bottom, negative to the top.\n     * @type {Number}\n     * @default 0\n     */ offsetY: 0,\n        /**\n     * Sets the length of the control. If null, defaults to object's cornerSize.\n     * Expects both sizeX and sizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ sizeX: null,\n        /**\n     * Sets the height of the control. If null, defaults to object's cornerSize.\n     * Expects both sizeX and sizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ sizeY: null,\n        /**\n     * Sets the length of the touch area of the control. If null, defaults to object's touchCornerSize.\n     * Expects both touchSizeX and touchSizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ touchSizeX: null,\n        /**\n     * Sets the height of the touch area of the control. If null, defaults to object's touchCornerSize.\n     * Expects both touchSizeX and touchSizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ touchSizeY: null,\n        /**\n     * Css cursor style to display when the control is hovered.\n     * if the method `cursorStyleHandler` is provided, this property is ignored.\n     * @type {String}\n     * @default 'crosshair'\n     */ cursorStyle: \"crosshair\",\n        /**\n     * If controls has an offsetY or offsetX, draw a line that connects\n     * the control to the bounding box\n     * @type {Boolean}\n     * @default false\n     */ withConnection: false,\n        /**\n     * The control actionHandler, provide one to handle action ( control being moved )\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */ actionHandler: function() {},\n        /**\n     * The control handler for mouse down, provide one to handle mouse down on control\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */ mouseDownHandler: function() {},\n        /**\n     * The control mouseUpHandler, provide one to handle an effect on mouse up.\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */ mouseUpHandler: function() {},\n        /**\n     * Returns control actionHandler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */ getActionHandler: function() {\n            return this.actionHandler;\n        },\n        /**\n     * Returns control mouseDown handler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */ getMouseDownHandler: function() {\n            return this.mouseDownHandler;\n        },\n        /**\n     * Returns control mouseUp handler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */ getMouseUpHandler: function() {\n            return this.mouseUpHandler;\n        },\n        /**\n     * Returns control cursorStyle for css using cursorStyle. If you need a more elaborate\n     * function you can pass one in the constructor\n     * the cursorStyle property\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Control} control the current control ( likely this)\n     * @param {fabric.Object} object on which the control is displayed\n     * @return {String}\n     */ cursorStyleHandler: function(eventData, control /* fabricObject */ ) {\n            return control.cursorStyle;\n        },\n        /**\n     * Returns the action name. The basic implementation just return the actionName property.\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Control} control the current control ( likely this)\n     * @param {fabric.Object} object on which the control is displayed\n     * @return {String}\n     */ getActionName: function(eventData, control /* fabricObject */ ) {\n            return control.actionName;\n        },\n        /**\n     * Returns controls visibility\n     * @param {fabric.Object} object on which the control is displayed\n     * @param {String} controlKey key where the control is memorized on the\n     * @return {Boolean}\n     */ getVisibility: function(fabricObject, controlKey) {\n            var objectVisibility = fabricObject._controlsVisibility;\n            if (objectVisibility && typeof objectVisibility[controlKey] !== \"undefined\") {\n                return objectVisibility[controlKey];\n            }\n            return this.visible;\n        },\n        /**\n     * Sets controls visibility\n     * @param {Boolean} visibility for the object\n     * @return {Void}\n     */ setVisibility: function(visibility /* name, fabricObject */ ) {\n            this.visible = visibility;\n        },\n        positionHandler: function(dim, finalMatrix /*, fabricObject, currentControl */ ) {\n            var point = fabric.util.transformPoint({\n                x: this.x * dim.x + this.offsetX,\n                y: this.y * dim.y + this.offsetY\n            }, finalMatrix);\n            return point;\n        },\n        /**\n     * Returns the coords for this control based on object values.\n     * @param {Number} objectAngle angle from the fabric object holding the control\n     * @param {Number} objectCornerSize cornerSize from the fabric object holding the control (or touchCornerSize if\n     *   isTouch is true)\n     * @param {Number} centerX x coordinate where the control center should be\n     * @param {Number} centerY y coordinate where the control center should be\n     * @param {boolean} isTouch true if touch corner, false if normal corner\n     */ calcCornerCoords: function(objectAngle, objectCornerSize, centerX, centerY, isTouch) {\n            var cosHalfOffset, sinHalfOffset, cosHalfOffsetComp, sinHalfOffsetComp, xSize = isTouch ? this.touchSizeX : this.sizeX, ySize = isTouch ? this.touchSizeY : this.sizeY;\n            if (xSize && ySize && xSize !== ySize) {\n                // handle rectangular corners\n                var controlTriangleAngle = Math.atan2(ySize, xSize);\n                var cornerHypotenuse = Math.sqrt(xSize * xSize + ySize * ySize) / 2;\n                var newTheta = controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);\n                var newThetaComp = Math.PI / 2 - controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);\n                cosHalfOffset = cornerHypotenuse * fabric.util.cos(newTheta);\n                sinHalfOffset = cornerHypotenuse * fabric.util.sin(newTheta);\n                // use complementary angle for two corners\n                cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newThetaComp);\n                sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newThetaComp);\n            } else {\n                // handle square corners\n                // use default object corner size unless size is defined\n                var cornerSize = xSize && ySize ? xSize : objectCornerSize;\n                /* 0.7071067812 stands for sqrt(2)/2 */ cornerHypotenuse = cornerSize * 0.7071067812;\n                // complementary angles are equal since they're both 45 degrees\n                var newTheta = fabric.util.degreesToRadians(45 - objectAngle);\n                cosHalfOffset = cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newTheta);\n                sinHalfOffset = sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newTheta);\n            }\n            return {\n                tl: {\n                    x: centerX - sinHalfOffsetComp,\n                    y: centerY - cosHalfOffsetComp\n                },\n                tr: {\n                    x: centerX + cosHalfOffset,\n                    y: centerY - sinHalfOffset\n                },\n                bl: {\n                    x: centerX - cosHalfOffset,\n                    y: centerY + sinHalfOffset\n                },\n                br: {\n                    x: centerX + sinHalfOffsetComp,\n                    y: centerY + cosHalfOffsetComp\n                }\n            };\n        },\n        /**\n    * Render function for the control.\n    * When this function runs the context is unscaled. unrotate. Just retina scaled.\n    * all the functions will have to translate to the point left,top before starting Drawing\n    * if they want to draw a control where the position is detected.\n    * left and top are the result of the positionHandler function\n    * @param {RenderingContext2D} ctx the context where the control will be drawn\n    * @param {Number} left position of the canvas where we are about to render the control.\n    * @param {Number} top position of the canvas where we are about to render the control.\n    * @param {Object} styleOverride\n    * @param {fabric.Object} fabricObject the object where the control is about to be rendered\n    */ render: function(ctx, left, top, styleOverride, fabricObject) {\n            styleOverride = styleOverride || {};\n            switch(styleOverride.cornerStyle || fabricObject.cornerStyle){\n                case \"circle\":\n                    fabric.controlsUtils.renderCircleControl.call(this, ctx, left, top, styleOverride, fabricObject);\n                    break;\n                default:\n                    fabric.controlsUtils.renderSquareControl.call(this, ctx, left, top, styleOverride, fabricObject);\n            }\n        }\n    };\n})( true ? exports : 0);\n(function() {\n    /* _FROM_SVG_START_ */ function getColorStop(el, multiplier) {\n        var style = el.getAttribute(\"style\"), offset = el.getAttribute(\"offset\") || 0, color, colorAlpha, opacity, i;\n        // convert percents to absolute values\n        offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);\n        offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;\n        if (style) {\n            var keyValuePairs = style.split(/\\s*;\\s*/);\n            if (keyValuePairs[keyValuePairs.length - 1] === \"\") {\n                keyValuePairs.pop();\n            }\n            for(i = keyValuePairs.length; i--;){\n                var split = keyValuePairs[i].split(/\\s*:\\s*/), key = split[0].trim(), value = split[1].trim();\n                if (key === \"stop-color\") {\n                    color = value;\n                } else if (key === \"stop-opacity\") {\n                    opacity = value;\n                }\n            }\n        }\n        if (!color) {\n            color = el.getAttribute(\"stop-color\") || \"rgb(0,0,0)\";\n        }\n        if (!opacity) {\n            opacity = el.getAttribute(\"stop-opacity\");\n        }\n        color = new fabric.Color(color);\n        colorAlpha = color.getAlpha();\n        opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);\n        opacity *= colorAlpha * multiplier;\n        return {\n            offset: offset,\n            color: color.toRgb(),\n            opacity: opacity\n        };\n    }\n    function getLinearCoords(el) {\n        return {\n            x1: el.getAttribute(\"x1\") || 0,\n            y1: el.getAttribute(\"y1\") || 0,\n            x2: el.getAttribute(\"x2\") || \"100%\",\n            y2: el.getAttribute(\"y2\") || 0\n        };\n    }\n    function getRadialCoords(el) {\n        return {\n            x1: el.getAttribute(\"fx\") || el.getAttribute(\"cx\") || \"50%\",\n            y1: el.getAttribute(\"fy\") || el.getAttribute(\"cy\") || \"50%\",\n            r1: 0,\n            x2: el.getAttribute(\"cx\") || \"50%\",\n            y2: el.getAttribute(\"cy\") || \"50%\",\n            r2: el.getAttribute(\"r\") || \"50%\"\n        };\n    }\n    /* _FROM_SVG_END_ */ var clone = fabric.util.object.clone;\n    /**\n   * Gradient class\n   * @class fabric.Gradient\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}\n   * @see {@link fabric.Gradient#initialize} for constructor definition\n   */ fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {\n        /**\n     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups\n     * @type Number\n     * @default 0\n     */ offsetX: 0,\n        /**\n     * Vertical offset for aligning gradients coming from SVG when outside pathgroups\n     * @type Number\n     * @default 0\n     */ offsetY: 0,\n        /**\n     * A transform matrix to apply to the gradient before painting.\n     * Imported from svg gradients, is not applied with the current transform in the center.\n     * Before this transform is applied, the origin point is at the top left corner of the object\n     * plus the addition of offsetY and offsetX.\n     * @type Number[]\n     * @default null\n     */ gradientTransform: null,\n        /**\n     * coordinates units for coords.\n     * If `pixels`, the number of coords are in the same unit of width / height.\n     * If set as `percentage` the coords are still a number, but 1 means 100% of width\n     * for the X and 100% of the height for the y. It can be bigger than 1 and negative.\n     * allowed values pixels or percentage.\n     * @type String\n     * @default 'pixels'\n     */ gradientUnits: \"pixels\",\n        /**\n     * Gradient type linear or radial\n     * @type String\n     * @default 'pixels'\n     */ type: \"linear\",\n        /**\n     * Constructor\n     * @param {Object} options Options object with type, coords, gradientUnits and colorStops\n     * @param {Object} [options.type] gradient type linear or radial\n     * @param {Object} [options.gradientUnits] gradient units\n     * @param {Object} [options.offsetX] SVG import compatibility\n     * @param {Object} [options.offsetY] SVG import compatibility\n     * @param {Object[]} options.colorStops contains the colorstops.\n     * @param {Object} options.coords contains the coords of the gradient\n     * @param {Number} [options.coords.x1] X coordiante of the first point for linear or of the focal point for radial\n     * @param {Number} [options.coords.y1] Y coordiante of the first point for linear or of the focal point for radial\n     * @param {Number} [options.coords.x2] X coordiante of the second point for linear or of the center point for radial\n     * @param {Number} [options.coords.y2] Y coordiante of the second point for linear or of the center point for radial\n     * @param {Number} [options.coords.r1] only for radial gradient, radius of the inner circle\n     * @param {Number} [options.coords.r2] only for radial gradient, radius of the external circle\n     * @return {fabric.Gradient} thisArg\n     */ initialize: function(options) {\n            options || (options = {});\n            options.coords || (options.coords = {});\n            var coords, _this = this;\n            // sets everything, then coords and colorstops get sets again\n            Object.keys(options).forEach(function(option) {\n                _this[option] = options[option];\n            });\n            if (this.id) {\n                this.id += \"_\" + fabric.Object.__uid++;\n            } else {\n                this.id = fabric.Object.__uid++;\n            }\n            coords = {\n                x1: options.coords.x1 || 0,\n                y1: options.coords.y1 || 0,\n                x2: options.coords.x2 || 0,\n                y2: options.coords.y2 || 0\n            };\n            if (this.type === \"radial\") {\n                coords.r1 = options.coords.r1 || 0;\n                coords.r2 = options.coords.r2 || 0;\n            }\n            this.coords = coords;\n            this.colorStops = options.colorStops.slice();\n        },\n        /**\n     * Adds another colorStop\n     * @param {Object} colorStop Object with offset and color\n     * @return {fabric.Gradient} thisArg\n     */ addColorStop: function(colorStops) {\n            for(var position in colorStops){\n                var color = new fabric.Color(colorStops[position]);\n                this.colorStops.push({\n                    offset: parseFloat(position),\n                    color: color.toRgb(),\n                    opacity: color.getAlpha()\n                });\n            }\n            return this;\n        },\n        /**\n     * Returns object representation of a gradient\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object}\n     */ toObject: function(propertiesToInclude) {\n            var object = {\n                type: this.type,\n                coords: this.coords,\n                colorStops: this.colorStops,\n                offsetX: this.offsetX,\n                offsetY: this.offsetY,\n                gradientUnits: this.gradientUnits,\n                gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform\n            };\n            fabric.util.populateWithProperties(this, object, propertiesToInclude);\n            return object;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns SVG representation of an gradient\n     * @param {Object} object Object to create a gradient for\n     * @return {String} SVG representation of an gradient (linear/radial)\n     */ toSVG: function(object, options) {\n            var coords = clone(this.coords, true), i, len, options = options || {}, markup, commonAttributes, colorStops = clone(this.colorStops, true), needsSwap = coords.r1 > coords.r2, transform = this.gradientTransform ? this.gradientTransform.concat() : fabric.iMatrix.concat(), offsetX = -this.offsetX, offsetY = -this.offsetY, withViewport = !!options.additionalTransform, gradientUnits = this.gradientUnits === \"pixels\" ? \"userSpaceOnUse\" : \"objectBoundingBox\";\n            // colorStops must be sorted ascending\n            colorStops.sort(function(a, b) {\n                return a.offset - b.offset;\n            });\n            if (gradientUnits === \"objectBoundingBox\") {\n                offsetX /= object.width;\n                offsetY /= object.height;\n            } else {\n                offsetX += object.width / 2;\n                offsetY += object.height / 2;\n            }\n            if (object.type === \"path\" && this.gradientUnits !== \"percentage\") {\n                offsetX -= object.pathOffset.x;\n                offsetY -= object.pathOffset.y;\n            }\n            transform[4] -= offsetX;\n            transform[5] -= offsetY;\n            commonAttributes = 'id=\"SVGID_' + this.id + '\" gradientUnits=\"' + gradientUnits + '\"';\n            commonAttributes += ' gradientTransform=\"' + (withViewport ? options.additionalTransform + \" \" : \"\") + fabric.util.matrixToSVG(transform) + '\" ';\n            if (this.type === \"linear\") {\n                markup = [\n                    \"<linearGradient \",\n                    commonAttributes,\n                    ' x1=\"',\n                    coords.x1,\n                    '\" y1=\"',\n                    coords.y1,\n                    '\" x2=\"',\n                    coords.x2,\n                    '\" y2=\"',\n                    coords.y2,\n                    '\">\\n'\n                ];\n            } else if (this.type === \"radial\") {\n                // svg radial gradient has just 1 radius. the biggest.\n                markup = [\n                    \"<radialGradient \",\n                    commonAttributes,\n                    ' cx=\"',\n                    needsSwap ? coords.x1 : coords.x2,\n                    '\" cy=\"',\n                    needsSwap ? coords.y1 : coords.y2,\n                    '\" r=\"',\n                    needsSwap ? coords.r1 : coords.r2,\n                    '\" fx=\"',\n                    needsSwap ? coords.x2 : coords.x1,\n                    '\" fy=\"',\n                    needsSwap ? coords.y2 : coords.y1,\n                    '\">\\n'\n                ];\n            }\n            if (this.type === \"radial\") {\n                if (needsSwap) {\n                    // svg goes from internal to external radius. if radius are inverted, swap color stops.\n                    colorStops = colorStops.concat();\n                    colorStops.reverse();\n                    for(i = 0, len = colorStops.length; i < len; i++){\n                        colorStops[i].offset = 1 - colorStops[i].offset;\n                    }\n                }\n                var minRadius = Math.min(coords.r1, coords.r2);\n                if (minRadius > 0) {\n                    // i have to shift all colorStops and add new one in 0.\n                    var maxRadius = Math.max(coords.r1, coords.r2), percentageShift = minRadius / maxRadius;\n                    for(i = 0, len = colorStops.length; i < len; i++){\n                        colorStops[i].offset += percentageShift * (1 - colorStops[i].offset);\n                    }\n                }\n            }\n            for(i = 0, len = colorStops.length; i < len; i++){\n                var colorStop = colorStops[i];\n                markup.push(\"<stop \", 'offset=\"', colorStop.offset * 100 + \"%\", '\" style=\"stop-color:', colorStop.color, typeof colorStop.opacity !== \"undefined\" ? \";stop-opacity: \" + colorStop.opacity : \";\", '\"/>\\n');\n            }\n            markup.push(this.type === \"linear\" ? \"</linearGradient>\\n\" : \"</radialGradient>\\n\");\n            return markup.join(\"\");\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns an instance of CanvasGradient\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @return {CanvasGradient}\n     */ toLive: function(ctx) {\n            var gradient, coords = fabric.util.object.clone(this.coords), i, len;\n            if (!this.type) {\n                return;\n            }\n            if (this.type === \"linear\") {\n                gradient = ctx.createLinearGradient(coords.x1, coords.y1, coords.x2, coords.y2);\n            } else if (this.type === \"radial\") {\n                gradient = ctx.createRadialGradient(coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);\n            }\n            for(i = 0, len = this.colorStops.length; i < len; i++){\n                var color = this.colorStops[i].color, opacity = this.colorStops[i].opacity, offset = this.colorStops[i].offset;\n                if (typeof opacity !== \"undefined\") {\n                    color = new fabric.Color(color).setAlpha(opacity).toRgba();\n                }\n                gradient.addColorStop(offset, color);\n            }\n            return gradient;\n        }\n    });\n    fabric.util.object.extend(fabric.Gradient, {\n        /* _FROM_SVG_START_ */ /**\n     * Returns {@link fabric.Gradient} instance from an SVG element\n     * @static\n     * @memberOf fabric.Gradient\n     * @param {SVGGradientElement} el SVG gradient element\n     * @param {fabric.Object} instance\n     * @param {String} opacityAttr A fill-opacity or stroke-opacity attribute to multiply to each stop's opacity.\n     * @param {Object} svgOptions an object containing the size of the SVG in order to parse correctly gradients\n     * that uses gradientUnits as 'userSpaceOnUse' and percentages.\n     * @param {Object.number} viewBoxWidth width part of the viewBox attribute on svg\n     * @param {Object.number} viewBoxHeight height part of the viewBox attribute on svg\n     * @param {Object.number} width width part of the svg tag if viewBox is not specified\n     * @param {Object.number} height height part of the svg tag if viewBox is not specified\n     * @return {fabric.Gradient} Gradient instance\n     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement\n     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement\n     */ fromElement: function(el, instance, opacityAttr, svgOptions) {\n            /**\n       *  @example:\n       *\n       *  <linearGradient id=\"linearGrad1\">\n       *    <stop offset=\"0%\" stop-color=\"white\"/>\n       *    <stop offset=\"100%\" stop-color=\"black\"/>\n       *  </linearGradient>\n       *\n       *  OR\n       *\n       *  <linearGradient id=\"linearGrad2\">\n       *    <stop offset=\"0\" style=\"stop-color:rgb(255,255,255)\"/>\n       *    <stop offset=\"1\" style=\"stop-color:rgb(0,0,0)\"/>\n       *  </linearGradient>\n       *\n       *  OR\n       *\n       *  <radialGradient id=\"radialGrad1\">\n       *    <stop offset=\"0%\" stop-color=\"white\" stop-opacity=\"1\" />\n       *    <stop offset=\"50%\" stop-color=\"black\" stop-opacity=\"0.5\" />\n       *    <stop offset=\"100%\" stop-color=\"white\" stop-opacity=\"1\" />\n       *  </radialGradient>\n       *\n       *  OR\n       *\n       *  <radialGradient id=\"radialGrad2\">\n       *    <stop offset=\"0\" stop-color=\"rgb(255,255,255)\" />\n       *    <stop offset=\"0.5\" stop-color=\"rgb(0,0,0)\" />\n       *    <stop offset=\"1\" stop-color=\"rgb(255,255,255)\" />\n       *  </radialGradient>\n       *\n       */ var multiplier = parseFloat(opacityAttr) / (/%$/.test(opacityAttr) ? 100 : 1);\n            multiplier = multiplier < 0 ? 0 : multiplier > 1 ? 1 : multiplier;\n            if (isNaN(multiplier)) {\n                multiplier = 1;\n            }\n            var colorStopEls = el.getElementsByTagName(\"stop\"), type, gradientUnits = el.getAttribute(\"gradientUnits\") === \"userSpaceOnUse\" ? \"pixels\" : \"percentage\", gradientTransform = el.getAttribute(\"gradientTransform\") || \"\", colorStops = [], coords, i, offsetX = 0, offsetY = 0, transformMatrix;\n            if (el.nodeName === \"linearGradient\" || el.nodeName === \"LINEARGRADIENT\") {\n                type = \"linear\";\n                coords = getLinearCoords(el);\n            } else {\n                type = \"radial\";\n                coords = getRadialCoords(el);\n            }\n            for(i = colorStopEls.length; i--;){\n                colorStops.push(getColorStop(colorStopEls[i], multiplier));\n            }\n            transformMatrix = fabric.parseTransformAttribute(gradientTransform);\n            __convertPercentUnitsToValues(instance, coords, svgOptions, gradientUnits);\n            if (gradientUnits === \"pixels\") {\n                offsetX = -instance.left;\n                offsetY = -instance.top;\n            }\n            var gradient = new fabric.Gradient({\n                id: el.getAttribute(\"id\"),\n                type: type,\n                coords: coords,\n                colorStops: colorStops,\n                gradientUnits: gradientUnits,\n                gradientTransform: transformMatrix,\n                offsetX: offsetX,\n                offsetY: offsetY\n            });\n            return gradient;\n        }\n    });\n    /**\n   * @private\n   */ function __convertPercentUnitsToValues(instance, options, svgOptions, gradientUnits) {\n        var propValue, finalValue;\n        Object.keys(options).forEach(function(prop) {\n            propValue = options[prop];\n            if (propValue === \"Infinity\") {\n                finalValue = 1;\n            } else if (propValue === \"-Infinity\") {\n                finalValue = 0;\n            } else {\n                finalValue = parseFloat(options[prop], 10);\n                if (typeof propValue === \"string\" && /^(\\d+\\.\\d+)%|(\\d+)%$/.test(propValue)) {\n                    finalValue *= 0.01;\n                    if (gradientUnits === \"pixels\") {\n                        // then we need to fix those percentages here in svg parsing\n                        if (prop === \"x1\" || prop === \"x2\" || prop === \"r2\") {\n                            finalValue *= svgOptions.viewBoxWidth || svgOptions.width;\n                        }\n                        if (prop === \"y1\" || prop === \"y2\") {\n                            finalValue *= svgOptions.viewBoxHeight || svgOptions.height;\n                        }\n                    }\n                }\n            }\n            options[prop] = finalValue;\n        });\n    }\n})();\n(function() {\n    \"use strict\";\n    var toFixed = fabric.util.toFixed;\n    /**\n   * Pattern class\n   * @class fabric.Pattern\n   * @see {@link http://fabricjs.com/patterns|Pattern demo}\n   * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}\n   * @see {@link fabric.Pattern#initialize} for constructor definition\n   */ fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {\n        /**\n     * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)\n     * @type String\n     * @default\n     */ repeat: \"repeat\",\n        /**\n     * Pattern horizontal offset from object's left/top corner\n     * @type Number\n     * @default\n     */ offsetX: 0,\n        /**\n     * Pattern vertical offset from object's left/top corner\n     * @type Number\n     * @default\n     */ offsetY: 0,\n        /**\n     * crossOrigin value (one of \"\", \"anonymous\", \"use-credentials\")\n     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes\n     * @type String\n     * @default\n     */ crossOrigin: \"\",\n        /**\n     * transform matrix to change the pattern, imported from svgs.\n     * @type Array\n     * @default\n     */ patternTransform: null,\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @param {Function} [callback] function to invoke after callback init.\n     * @return {fabric.Pattern} thisArg\n     */ initialize: function(options, callback) {\n            options || (options = {});\n            this.id = fabric.Object.__uid++;\n            this.setOptions(options);\n            if (!options.source || options.source && typeof options.source !== \"string\") {\n                callback && callback(this);\n                return;\n            } else {\n                // img src string\n                var _this = this;\n                this.source = fabric.util.createImage();\n                fabric.util.loadImage(options.source, function(img, isError) {\n                    _this.source = img;\n                    callback && callback(_this, isError);\n                }, null, this.crossOrigin);\n            }\n        },\n        /**\n     * Returns object representation of a pattern\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of a pattern instance\n     */ toObject: function(propertiesToInclude) {\n            var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, source, object;\n            // <img> element\n            if (typeof this.source.src === \"string\") {\n                source = this.source.src;\n            } else if (typeof this.source === \"object\" && this.source.toDataURL) {\n                source = this.source.toDataURL();\n            }\n            object = {\n                type: \"pattern\",\n                source: source,\n                repeat: this.repeat,\n                crossOrigin: this.crossOrigin,\n                offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),\n                offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),\n                patternTransform: this.patternTransform ? this.patternTransform.concat() : null\n            };\n            fabric.util.populateWithProperties(this, object, propertiesToInclude);\n            return object;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns SVG representation of a pattern\n     * @param {fabric.Object} object\n     * @return {String} SVG representation of a pattern\n     */ toSVG: function(object) {\n            var patternSource = typeof this.source === \"function\" ? this.source() : this.source, patternWidth = patternSource.width / object.width, patternHeight = patternSource.height / object.height, patternOffsetX = this.offsetX / object.width, patternOffsetY = this.offsetY / object.height, patternImgSrc = \"\";\n            if (this.repeat === \"repeat-x\" || this.repeat === \"no-repeat\") {\n                patternHeight = 1;\n                if (patternOffsetY) {\n                    patternHeight += Math.abs(patternOffsetY);\n                }\n            }\n            if (this.repeat === \"repeat-y\" || this.repeat === \"no-repeat\") {\n                patternWidth = 1;\n                if (patternOffsetX) {\n                    patternWidth += Math.abs(patternOffsetX);\n                }\n            }\n            if (patternSource.src) {\n                patternImgSrc = patternSource.src;\n            } else if (patternSource.toDataURL) {\n                patternImgSrc = patternSource.toDataURL();\n            }\n            return '<pattern id=\"SVGID_' + this.id + '\" x=\"' + patternOffsetX + '\" y=\"' + patternOffsetY + '\" width=\"' + patternWidth + '\" height=\"' + patternHeight + '\">\\n' + '<image x=\"0\" y=\"0\"' + ' width=\"' + patternSource.width + '\" height=\"' + patternSource.height + '\" xlink:href=\"' + patternImgSrc + '\"></image>\\n' + \"</pattern>\\n\";\n        },\n        /* _TO_SVG_END_ */ setOptions: function(options) {\n            for(var prop in options){\n                this[prop] = options[prop];\n            }\n        },\n        /**\n     * Returns an instance of CanvasPattern\n     * @param {CanvasRenderingContext2D} ctx Context to create pattern\n     * @return {CanvasPattern}\n     */ toLive: function(ctx) {\n            var source = this.source;\n            // if the image failed to load, return, and allow rest to continue loading\n            if (!source) {\n                return \"\";\n            }\n            // if an image\n            if (typeof source.src !== \"undefined\") {\n                if (!source.complete) {\n                    return \"\";\n                }\n                if (source.naturalWidth === 0 || source.naturalHeight === 0) {\n                    return \"\";\n                }\n            }\n            return ctx.createPattern(source, this.repeat);\n        }\n    });\n})();\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), toFixed = fabric.util.toFixed;\n    if (fabric.Shadow) {\n        fabric.warn(\"fabric.Shadow is already defined.\");\n        return;\n    }\n    /**\n   * Shadow class\n   * @class fabric.Shadow\n   * @see {@link http://fabricjs.com/shadows|Shadow demo}\n   * @see {@link fabric.Shadow#initialize} for constructor definition\n   */ fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {\n        /**\n     * Shadow color\n     * @type String\n     * @default\n     */ color: \"rgb(0,0,0)\",\n        /**\n     * Shadow blur\n     * @type Number\n     */ blur: 0,\n        /**\n     * Shadow horizontal offset\n     * @type Number\n     * @default\n     */ offsetX: 0,\n        /**\n     * Shadow vertical offset\n     * @type Number\n     * @default\n     */ offsetY: 0,\n        /**\n     * Whether the shadow should affect stroke operations\n     * @type Boolean\n     * @default\n     */ affectStroke: false,\n        /**\n     * Indicates whether toObject should include default values\n     * @type Boolean\n     * @default\n     */ includeDefaultValues: true,\n        /**\n     * When `false`, the shadow will scale with the object.\n     * When `true`, the shadow's offsetX, offsetY, and blur will not be affected by the object's scale.\n     * default to false\n     * @type Boolean\n     * @default\n     */ nonScaling: false,\n        /**\n     * Constructor\n     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. \"rgba(0,0,0,0.2) 2px 2px 10px\")\n     * @return {fabric.Shadow} thisArg\n     */ initialize: function(options) {\n            if (typeof options === \"string\") {\n                options = this._parseShadow(options);\n            }\n            for(var prop in options){\n                this[prop] = options[prop];\n            }\n            this.id = fabric.Object.__uid++;\n        },\n        /**\n     * @private\n     * @param {String} shadow Shadow value to parse\n     * @return {Object} Shadow object with color, offsetX, offsetY and blur\n     */ _parseShadow: function(shadow) {\n            var shadowStr = shadow.trim(), offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [], color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, \"\") || \"rgb(0,0,0)\";\n            return {\n                color: color.trim(),\n                offsetX: parseFloat(offsetsAndBlur[1], 10) || 0,\n                offsetY: parseFloat(offsetsAndBlur[2], 10) || 0,\n                blur: parseFloat(offsetsAndBlur[3], 10) || 0\n            };\n        },\n        /**\n     * Returns a string representation of an instance\n     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow\n     * @return {String} Returns CSS3 text-shadow declaration\n     */ toString: function() {\n            return [\n                this.offsetX,\n                this.offsetY,\n                this.blur,\n                this.color\n            ].join(\"px \");\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns SVG representation of a shadow\n     * @param {fabric.Object} object\n     * @return {String} SVG representation of a shadow\n     */ toSVG: function(object) {\n            var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, offset = fabric.util.rotateVector({\n                x: this.offsetX,\n                y: this.offsetY\n            }, fabric.util.degreesToRadians(-object.angle)), BLUR_BOX = 20, color = new fabric.Color(this.color);\n            if (object.width && object.height) {\n                //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion\n                // we add some extra space to filter box to contain the blur ( 20 )\n                fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;\n                fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;\n            }\n            if (object.flipX) {\n                offset.x *= -1;\n            }\n            if (object.flipY) {\n                offset.y *= -1;\n            }\n            return '<filter id=\"SVGID_' + this.id + '\" y=\"-' + fBoxY + '%\" height=\"' + (100 + 2 * fBoxY) + '%\" ' + 'x=\"-' + fBoxX + '%\" width=\"' + (100 + 2 * fBoxX) + '%\" ' + \">\\n\" + '\t<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"' + toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '\"></feGaussianBlur>\\n' + '\t<feOffset dx=\"' + toFixed(offset.x, NUM_FRACTION_DIGITS) + '\" dy=\"' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '\" result=\"oBlur\" ></feOffset>\\n' + '\t<feFlood flood-color=\"' + color.toRgb() + '\" flood-opacity=\"' + color.getAlpha() + '\"/>\\n' + '\t<feComposite in2=\"oBlur\" operator=\"in\" />\\n' + \"\t<feMerge>\\n\" + \"\t\t<feMergeNode></feMergeNode>\\n\" + '\t\t<feMergeNode in=\"SourceGraphic\"></feMergeNode>\\n' + \"\t</feMerge>\\n\" + \"</filter>\\n\";\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns object representation of a shadow\n     * @return {Object} Object representation of a shadow instance\n     */ toObject: function() {\n            if (this.includeDefaultValues) {\n                return {\n                    color: this.color,\n                    blur: this.blur,\n                    offsetX: this.offsetX,\n                    offsetY: this.offsetY,\n                    affectStroke: this.affectStroke,\n                    nonScaling: this.nonScaling\n                };\n            }\n            var obj = {}, proto = fabric.Shadow.prototype;\n            [\n                \"color\",\n                \"blur\",\n                \"offsetX\",\n                \"offsetY\",\n                \"affectStroke\",\n                \"nonScaling\"\n            ].forEach(function(prop) {\n                if (this[prop] !== proto[prop]) {\n                    obj[prop] = this[prop];\n                }\n            }, this);\n            return obj;\n        }\n    });\n    /**\n   * Regex matching shadow offsetX, offsetY and blur (ex: \"2px 2px 10px rgba(0,0,0,0.2)\", \"rgb(0,255,0) 2px 2px\")\n   * @static\n   * @field\n   * @memberOf fabric.Shadow\n   */ // eslint-disable-next-line max-len\n    fabric.Shadow.reOffsetsAndBlur = /(?:\\s|^)(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?(\\d+(?:\\.\\d*)?(?:px)?)?(?:\\s?|$)(?:$|\\s)/;\n})( true ? exports : 0);\n(function() {\n    \"use strict\";\n    if (fabric.StaticCanvas) {\n        fabric.warn(\"fabric.StaticCanvas is already defined.\");\n        return;\n    }\n    // aliases for faster resolution\n    var extend = fabric.util.object.extend, getElementOffset = fabric.util.getElementOffset, removeFromArray = fabric.util.removeFromArray, toFixed = fabric.util.toFixed, transformPoint = fabric.util.transformPoint, invertTransform = fabric.util.invertTransform, getNodeCanvas = fabric.util.getNodeCanvas, createCanvasElement = fabric.util.createCanvasElement, CANVAS_INIT_ERROR = new Error(\"Could not initialize `canvas` element\");\n    /**\n   * Static canvas class\n   * @class fabric.StaticCanvas\n   * @mixes fabric.Collection\n   * @mixes fabric.Observable\n   * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}\n   * @see {@link fabric.StaticCanvas#initialize} for constructor definition\n   * @fires before:render\n   * @fires after:render\n   * @fires canvas:cleared\n   * @fires object:added\n   * @fires object:removed\n   */ fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.StaticCanvas.prototype */ {\n        /**\n     * Constructor\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(el, options) {\n            options || (options = {});\n            this.renderAndResetBound = this.renderAndReset.bind(this);\n            this.requestRenderAllBound = this.requestRenderAll.bind(this);\n            this._initStatic(el, options);\n        },\n        /**\n     * Background color of canvas instance.\n     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.\n     * @type {(String|fabric.Pattern)}\n     * @default\n     */ backgroundColor: \"\",\n        /**\n     * Background image of canvas instance.\n     * since 2.4.0 image caching is active, please when putting an image as background, add to the\n     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom\n     * vale. As an alternative you can disable image objectCaching\n     * @type fabric.Image\n     * @default\n     */ backgroundImage: null,\n        /**\n     * Overlay color of canvas instance.\n     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}\n     * @since 1.3.9\n     * @type {(String|fabric.Pattern)}\n     * @default\n     */ overlayColor: \"\",\n        /**\n     * Overlay image of canvas instance.\n     * since 2.4.0 image caching is active, please when putting an image as overlay, add to the\n     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom\n     * vale. As an alternative you can disable image objectCaching\n     * @type fabric.Image\n     * @default\n     */ overlayImage: null,\n        /**\n     * Indicates whether toObject/toDatalessObject should include default values\n     * if set to false, takes precedence over the object value.\n     * @type Boolean\n     * @default\n     */ includeDefaultValues: true,\n        /**\n     * Indicates whether objects' state should be saved\n     * @type Boolean\n     * @default\n     */ stateful: false,\n        /**\n     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},\n     * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.\n     * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once\n     * since the renders are quequed and executed one per frame.\n     * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )\n     * Left default to true to do not break documentation and old app, fiddles.\n     * @type Boolean\n     * @default\n     */ renderOnAddRemove: true,\n        /**\n     * Indicates whether object controls (borders/controls) are rendered above overlay image\n     * @type Boolean\n     * @default\n     */ controlsAboveOverlay: false,\n        /**\n     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas\n     * @type Boolean\n     * @default\n     */ allowTouchScrolling: false,\n        /**\n     * Indicates whether this canvas will use image smoothing, this is on by default in browsers\n     * @type Boolean\n     * @default\n     */ imageSmoothingEnabled: true,\n        /**\n     * The transformation (a Canvas 2D API transform matrix) which focuses the viewport\n     * @type Array\n     * @example <caption>Default transform</caption>\n     * canvas.viewportTransform = [1, 0, 0, 1, 0, 0];\n     * @example <caption>Scale by 70% and translate toward bottom-right by 50, without skewing</caption>\n     * canvas.viewportTransform = [0.7, 0, 0, 0.7, 50, 50];\n     * @default\n     */ viewportTransform: fabric.iMatrix.concat(),\n        /**\n     * if set to false background image is not affected by viewport transform\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */ backgroundVpt: true,\n        /**\n     * if set to false overlya image is not affected by viewport transform\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */ overlayVpt: true,\n        /**\n     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens\n     * @type Boolean\n     * @default\n     */ enableRetinaScaling: true,\n        /**\n     * Describe canvas element extension over design\n     * properties are tl,tr,bl,br.\n     * if canvas is not zoomed/panned those points are the four corner of canvas\n     * if canvas is viewportTransformed you those points indicate the extension\n     * of canvas element in plain untrasformed coordinates\n     * The coordinates get updated with @method calcViewportBoundaries.\n     * @memberOf fabric.StaticCanvas.prototype\n     */ vptCoords: {},\n        /**\n     * Based on vptCoords and object.aCoords, skip rendering of objects that\n     * are not included in current viewport.\n     * May greatly help in applications with crowded canvas and use of zoom/pan\n     * If One of the corner of the bounding box of the object is on the canvas\n     * the objects get rendered.\n     * @memberOf fabric.StaticCanvas.prototype\n     * @type Boolean\n     * @default\n     */ skipOffscreen: true,\n        /**\n     * a fabricObject that, without stroke define a clipping area with their shape. filled in black\n     * the clipPath object gets used when the canvas has rendered, and the context is placed in the\n     * top left corner of the canvas.\n     * clipPath will clip away controls, if you do not want this to happen use controlsAboveOverlay = true\n     * @type fabric.Object\n     */ clipPath: undefined,\n        /**\n     * @private\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     */ _initStatic: function(el, options) {\n            var cb = this.requestRenderAllBound;\n            this._objects = [];\n            this._createLowerCanvas(el);\n            this._initOptions(options);\n            // only initialize retina scaling once\n            if (!this.interactive) {\n                this._initRetinaScaling();\n            }\n            if (options.overlayImage) {\n                this.setOverlayImage(options.overlayImage, cb);\n            }\n            if (options.backgroundImage) {\n                this.setBackgroundImage(options.backgroundImage, cb);\n            }\n            if (options.backgroundColor) {\n                this.setBackgroundColor(options.backgroundColor, cb);\n            }\n            if (options.overlayColor) {\n                this.setOverlayColor(options.overlayColor, cb);\n            }\n            this.calcOffset();\n        },\n        /**\n     * @private\n     */ _isRetinaScaling: function() {\n            return fabric.devicePixelRatio > 1 && this.enableRetinaScaling;\n        },\n        /**\n     * @private\n     * @return {Number} retinaScaling if applied, otherwise 1;\n     */ getRetinaScaling: function() {\n            return this._isRetinaScaling() ? Math.max(1, fabric.devicePixelRatio) : 1;\n        },\n        /**\n     * @private\n     */ _initRetinaScaling: function() {\n            if (!this._isRetinaScaling()) {\n                return;\n            }\n            var scaleRatio = fabric.devicePixelRatio;\n            this.__initRetinaScaling(scaleRatio, this.lowerCanvasEl, this.contextContainer);\n            if (this.upperCanvasEl) {\n                this.__initRetinaScaling(scaleRatio, this.upperCanvasEl, this.contextTop);\n            }\n        },\n        __initRetinaScaling: function(scaleRatio, canvas, context) {\n            canvas.setAttribute(\"width\", this.width * scaleRatio);\n            canvas.setAttribute(\"height\", this.height * scaleRatio);\n            context.scale(scaleRatio, scaleRatio);\n        },\n        /**\n     * Calculates canvas element offset relative to the document\n     * This method is also attached as \"resize\" event handler of window\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ calcOffset: function() {\n            this._offset = getElementOffset(this.lowerCanvasEl);\n            return this;\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to\n     * @param {Function} callback callback to invoke when image is loaded and set as an overlay\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}\n     * @example <caption>Normal overlayImage with left/top = 0</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   // Needed to position overlayImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>overlayImage with different properties</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>\n     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img, isError) {\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\n     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));\n     * });\n     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   width: canvas.width,\n     *   height: canvas.height,\n     *   // Needed to position overlayImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>overlayImage loaded from cross-origin</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top',\n     *   crossOrigin: 'anonymous'\n     * });\n     */ setOverlayImage: function(image, callback, options) {\n            return this.__setBgOverlayImage(\"overlayImage\", image, callback, options);\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to\n     * @param {Function} callback Callback to invoke when image is loaded and set as background\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/djnr8o7a/28/|jsFiddle demo}\n     * @example <caption>Normal backgroundImage with left/top = 0</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   // Needed to position backgroundImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>backgroundImage with different properties</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>\n     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img, isError) {\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\n     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));\n     * });\n     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   width: canvas.width,\n     *   height: canvas.height,\n     *   // Needed to position backgroundImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>backgroundImage loaded from cross-origin</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top',\n     *   crossOrigin: 'anonymous'\n     * });\n     */ // TODO: fix stretched examples\n        setBackgroundImage: function(image, callback, options) {\n            return this.__setBgOverlayImage(\"backgroundImage\", image, callback, options);\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas\n     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to\n     * @param {Function} callback Callback to invoke when foreground color is set\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}\n     * @example <caption>Normal overlayColor - color value</caption>\n     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as overlayColor</caption>\n     * canvas.setOverlayColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\n     * }, canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>\n     * canvas.setOverlayColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\n     *   repeat: 'repeat',\n     *   offsetX: 200,\n     *   offsetY: 100\n     * }, canvas.renderAll.bind(canvas));\n     */ setOverlayColor: function(overlayColor, callback) {\n            return this.__setBgOverlayColor(\"overlayColor\", overlayColor, callback);\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas\n     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to\n     * @param {Function} callback Callback to invoke when background color is set\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}\n     * @example <caption>Normal backgroundColor - color value</caption>\n     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as backgroundColor</caption>\n     * canvas.setBackgroundColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\n     * }, canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>\n     * canvas.setBackgroundColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\n     *   repeat: 'repeat',\n     *   offsetX: 200,\n     *   offsetY: 100\n     * }, canvas.renderAll.bind(canvas));\n     */ setBackgroundColor: function(backgroundColor, callback) {\n            return this.__setBgOverlayColor(\"backgroundColor\", backgroundColor, callback);\n        },\n        /**\n     * @private\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}\n     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})\n     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to\n     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay. The first argument is the created image, the second argument is a flag indicating whether an error occurred or not.\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.\n     */ __setBgOverlayImage: function(property, image, callback, options) {\n            if (typeof image === \"string\") {\n                fabric.util.loadImage(image, function(img, isError) {\n                    if (img) {\n                        var instance = new fabric.Image(img, options);\n                        this[property] = instance;\n                        instance.canvas = this;\n                    }\n                    callback && callback(img, isError);\n                }, this, options && options.crossOrigin);\n            } else {\n                options && image.setOptions(options);\n                this[property] = image;\n                image && (image.canvas = this);\n                callback && callback(image, false);\n            }\n            return this;\n        },\n        /**\n     * @private\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}\n     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})\n     * @param {(Object|String|null)} color Object with pattern information, color value or null\n     * @param {Function} [callback] Callback is invoked when color is set\n     */ __setBgOverlayColor: function(property, color, callback) {\n            this[property] = color;\n            this._initGradient(color, property);\n            this._initPattern(color, property, callback);\n            return this;\n        },\n        /**\n     * @private\n     */ _createCanvasElement: function() {\n            var element = createCanvasElement();\n            if (!element) {\n                throw CANVAS_INIT_ERROR;\n            }\n            if (!element.style) {\n                element.style = {};\n            }\n            if (typeof element.getContext === \"undefined\") {\n                throw CANVAS_INIT_ERROR;\n            }\n            return element;\n        },\n        /**\n     * @private\n     * @param {Object} [options] Options object\n     */ _initOptions: function(options) {\n            var lowerCanvasEl = this.lowerCanvasEl;\n            this._setOptions(options);\n            this.width = this.width || parseInt(lowerCanvasEl.width, 10) || 0;\n            this.height = this.height || parseInt(lowerCanvasEl.height, 10) || 0;\n            if (!this.lowerCanvasEl.style) {\n                return;\n            }\n            lowerCanvasEl.width = this.width;\n            lowerCanvasEl.height = this.height;\n            lowerCanvasEl.style.width = this.width + \"px\";\n            lowerCanvasEl.style.height = this.height + \"px\";\n            this.viewportTransform = this.viewportTransform.slice();\n        },\n        /**\n     * Creates a bottom canvas\n     * @private\n     * @param {HTMLElement} [canvasEl]\n     */ _createLowerCanvas: function(canvasEl) {\n            // canvasEl === 'HTMLCanvasElement' does not work on jsdom/node\n            if (canvasEl && canvasEl.getContext) {\n                this.lowerCanvasEl = canvasEl;\n            } else {\n                this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();\n            }\n            fabric.util.addClass(this.lowerCanvasEl, \"lower-canvas\");\n            this._originalCanvasStyle = this.lowerCanvasEl.style;\n            if (this.interactive) {\n                this._applyCanvasStyle(this.lowerCanvasEl);\n            }\n            this.contextContainer = this.lowerCanvasEl.getContext(\"2d\");\n        },\n        /**\n     * Returns canvas width (in px)\n     * @return {Number}\n     */ getWidth: function() {\n            return this.width;\n        },\n        /**\n     * Returns canvas height (in px)\n     * @return {Number}\n     */ getHeight: function() {\n            return this.height;\n        },\n        /**\n     * Sets width of this canvas instance\n     * @param {Number|String} value                         Value to set width to\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setWidth: function(value, options) {\n            return this.setDimensions({\n                width: value\n            }, options);\n        },\n        /**\n     * Sets height of this canvas instance\n     * @param {Number|String} value                         Value to set height to\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setHeight: function(value, options) {\n            return this.setDimensions({\n                height: value\n            }, options);\n        },\n        /**\n     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)\n     * @param {Object}        dimensions                    Object with width/height properties\n     * @param {Number|String} [dimensions.width]            Width of canvas element\n     * @param {Number|String} [dimensions.height]           Height of canvas element\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ setDimensions: function(dimensions, options) {\n            var cssValue;\n            options = options || {};\n            for(var prop in dimensions){\n                cssValue = dimensions[prop];\n                if (!options.cssOnly) {\n                    this._setBackstoreDimension(prop, dimensions[prop]);\n                    cssValue += \"px\";\n                    this.hasLostContext = true;\n                }\n                if (!options.backstoreOnly) {\n                    this._setCssDimension(prop, cssValue);\n                }\n            }\n            if (this._isCurrentlyDrawing) {\n                this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);\n            }\n            this._initRetinaScaling();\n            this.calcOffset();\n            if (!options.cssOnly) {\n                this.requestRenderAll();\n            }\n            return this;\n        },\n        /**\n     * Helper for setting width/height\n     * @private\n     * @param {String} prop property (width|height)\n     * @param {Number} value value to set property to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ _setBackstoreDimension: function(prop, value) {\n            this.lowerCanvasEl[prop] = value;\n            if (this.upperCanvasEl) {\n                this.upperCanvasEl[prop] = value;\n            }\n            if (this.cacheCanvasEl) {\n                this.cacheCanvasEl[prop] = value;\n            }\n            this[prop] = value;\n            return this;\n        },\n        /**\n     * Helper for setting css width/height\n     * @private\n     * @param {String} prop property (width|height)\n     * @param {String} value value to set property to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ _setCssDimension: function(prop, value) {\n            this.lowerCanvasEl.style[prop] = value;\n            if (this.upperCanvasEl) {\n                this.upperCanvasEl.style[prop] = value;\n            }\n            if (this.wrapperEl) {\n                this.wrapperEl.style[prop] = value;\n            }\n            return this;\n        },\n        /**\n     * Returns canvas zoom level\n     * @return {Number}\n     */ getZoom: function() {\n            return this.viewportTransform[0];\n        },\n        /**\n     * Sets viewport transformation of this canvas instance\n     * @param {Array} vpt a Canvas 2D API transform matrix\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setViewportTransform: function(vpt) {\n            var activeObject = this._activeObject, backgroundObject = this.backgroundImage, overlayObject = this.overlayImage, object, i, len;\n            this.viewportTransform = vpt;\n            for(i = 0, len = this._objects.length; i < len; i++){\n                object = this._objects[i];\n                object.group || object.setCoords(true);\n            }\n            if (activeObject) {\n                activeObject.setCoords();\n            }\n            if (backgroundObject) {\n                backgroundObject.setCoords(true);\n            }\n            if (overlayObject) {\n                overlayObject.setCoords(true);\n            }\n            this.calcViewportBoundaries();\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Sets zoom level of this canvas instance, the zoom centered around point\n     * meaning that following zoom to point with the same point will have the visual\n     * effect of the zoom originating from that point. The point won't move.\n     * It has nothing to do with canvas center or visual center of the viewport.\n     * @param {fabric.Point} point to zoom with respect to\n     * @param {Number} value to set zoom to, less than 1 zooms out\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ zoomToPoint: function(point, value) {\n            // TODO: just change the scale, preserve other transformations\n            var before = point, vpt = this.viewportTransform.slice(0);\n            point = transformPoint(point, invertTransform(this.viewportTransform));\n            vpt[0] = value;\n            vpt[3] = value;\n            var after = transformPoint(point, vpt);\n            vpt[4] += before.x - after.x;\n            vpt[5] += before.y - after.y;\n            return this.setViewportTransform(vpt);\n        },\n        /**\n     * Sets zoom level of this canvas instance\n     * @param {Number} value to set zoom to, less than 1 zooms out\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setZoom: function(value) {\n            this.zoomToPoint(new fabric.Point(0, 0), value);\n            return this;\n        },\n        /**\n     * Pan viewport so as to place point at top left corner of canvas\n     * @param {fabric.Point} point to move to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ absolutePan: function(point) {\n            var vpt = this.viewportTransform.slice(0);\n            vpt[4] = -point.x;\n            vpt[5] = -point.y;\n            return this.setViewportTransform(vpt);\n        },\n        /**\n     * Pans viewpoint relatively\n     * @param {fabric.Point} point (position vector) to move by\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ relativePan: function(point) {\n            return this.absolutePan(new fabric.Point(-point.x - this.viewportTransform[4], -point.y - this.viewportTransform[5]));\n        },\n        /**\n     * Returns &lt;canvas> element corresponding to this instance\n     * @return {HTMLCanvasElement}\n     */ getElement: function() {\n            return this.lowerCanvasEl;\n        },\n        /**\n     * @private\n     * @param {fabric.Object} obj Object that was added\n     */ _onObjectAdded: function(obj) {\n            this.stateful && obj.setupState();\n            obj._set(\"canvas\", this);\n            obj.setCoords();\n            this.fire(\"object:added\", {\n                target: obj\n            });\n            obj.fire(\"added\");\n        },\n        /**\n     * @private\n     * @param {fabric.Object} obj Object that was removed\n     */ _onObjectRemoved: function(obj) {\n            this.fire(\"object:removed\", {\n                target: obj\n            });\n            obj.fire(\"removed\");\n            delete obj.canvas;\n        },\n        /**\n     * Clears specified context of canvas element\n     * @param {CanvasRenderingContext2D} ctx Context to clear\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ clearContext: function(ctx) {\n            ctx.clearRect(0, 0, this.width, this.height);\n            return this;\n        },\n        /**\n     * Returns context of canvas where objects are drawn\n     * @return {CanvasRenderingContext2D}\n     */ getContext: function() {\n            return this.contextContainer;\n        },\n        /**\n     * Clears all contexts (background, main, top) of an instance\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ clear: function() {\n            this.remove.apply(this, this.getObjects());\n            this.backgroundImage = null;\n            this.overlayImage = null;\n            this.backgroundColor = \"\";\n            this.overlayColor = \"\";\n            if (this._hasITextHandlers) {\n                this.off(\"mouse:up\", this._mouseUpITextHandler);\n                this._iTextInstances = null;\n                this._hasITextHandlers = false;\n            }\n            this.clearContext(this.contextContainer);\n            this.fire(\"canvas:cleared\");\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Renders the canvas\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderAll: function() {\n            var canvasToDrawOn = this.contextContainer;\n            this.renderCanvas(canvasToDrawOn, this._objects);\n            return this;\n        },\n        /**\n     * Function created to be instance bound at initialization\n     * used in requestAnimationFrame rendering\n     * Let the fabricJS call it. If you call it manually you could have more\n     * animationFrame stacking on to of each other\n     * for an imperative rendering, use canvas.renderAll\n     * @private\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderAndReset: function() {\n            this.isRendering = 0;\n            this.renderAll();\n        },\n        /**\n     * Append a renderAll request to next animation frame.\n     * unless one is already in progress, in that case nothing is done\n     * a boolean flag will avoid appending more.\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ requestRenderAll: function() {\n            if (!this.isRendering) {\n                this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound);\n            }\n            return this;\n        },\n        /**\n     * Calculate the position of the 4 corner of canvas with current viewportTransform.\n     * helps to determinate when an object is in the current rendering viewport using\n     * object absolute coordinates ( aCoords )\n     * @return {Object} points.tl\n     * @chainable\n     */ calcViewportBoundaries: function() {\n            var points = {}, width = this.width, height = this.height, iVpt = invertTransform(this.viewportTransform);\n            points.tl = transformPoint({\n                x: 0,\n                y: 0\n            }, iVpt);\n            points.br = transformPoint({\n                x: width,\n                y: height\n            }, iVpt);\n            points.tr = new fabric.Point(points.br.x, points.tl.y);\n            points.bl = new fabric.Point(points.tl.x, points.br.y);\n            this.vptCoords = points;\n            return points;\n        },\n        cancelRequestedRender: function() {\n            if (this.isRendering) {\n                fabric.util.cancelAnimFrame(this.isRendering);\n                this.isRendering = 0;\n            }\n        },\n        /**\n     * Renders background, objects, overlay and controls.\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Array} objects to render\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderCanvas: function(ctx, objects) {\n            var v = this.viewportTransform, path = this.clipPath;\n            this.cancelRequestedRender();\n            this.calcViewportBoundaries();\n            this.clearContext(ctx);\n            fabric.util.setImageSmoothing(ctx, this.imageSmoothingEnabled);\n            this.fire(\"before:render\", {\n                ctx: ctx\n            });\n            this._renderBackground(ctx);\n            ctx.save();\n            //apply viewport transform once for all rendering process\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            this._renderObjects(ctx, objects);\n            ctx.restore();\n            if (!this.controlsAboveOverlay && this.interactive) {\n                this.drawControls(ctx);\n            }\n            if (path) {\n                path.canvas = this;\n                // needed to setup a couple of variables\n                path.shouldCache();\n                path._transformDone = true;\n                path.renderCache({\n                    forClipping: true\n                });\n                this.drawClipPathOnCanvas(ctx);\n            }\n            this._renderOverlay(ctx);\n            if (this.controlsAboveOverlay && this.interactive) {\n                this.drawControls(ctx);\n            }\n            this.fire(\"after:render\", {\n                ctx: ctx\n            });\n        },\n        /**\n     * Paint the cached clipPath on the lowerCanvasEl\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawClipPathOnCanvas: function(ctx) {\n            var v = this.viewportTransform, path = this.clipPath;\n            ctx.save();\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            // DEBUG: uncomment this line, comment the following\n            // ctx.globalAlpha = 0.4;\n            ctx.globalCompositeOperation = \"destination-in\";\n            path.transform(ctx);\n            ctx.scale(1 / path.zoomX, 1 / path.zoomY);\n            ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Array} objects to render\n     */ _renderObjects: function(ctx, objects) {\n            var i, len;\n            for(i = 0, len = objects.length; i < len; ++i){\n                objects[i] && objects[i].render(ctx);\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {string} property 'background' or 'overlay'\n     */ _renderBackgroundOrOverlay: function(ctx, property) {\n            var fill = this[property + \"Color\"], object = this[property + \"Image\"], v = this.viewportTransform, needsVpt = this[property + \"Vpt\"];\n            if (!fill && !object) {\n                return;\n            }\n            if (fill) {\n                ctx.save();\n                ctx.beginPath();\n                ctx.moveTo(0, 0);\n                ctx.lineTo(this.width, 0);\n                ctx.lineTo(this.width, this.height);\n                ctx.lineTo(0, this.height);\n                ctx.closePath();\n                ctx.fillStyle = fill.toLive ? fill.toLive(ctx, this) : fill;\n                if (needsVpt) {\n                    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n                }\n                ctx.transform(1, 0, 0, 1, fill.offsetX || 0, fill.offsetY || 0);\n                var m = fill.gradientTransform || fill.patternTransform;\n                m && ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n                ctx.fill();\n                ctx.restore();\n            }\n            if (object) {\n                ctx.save();\n                if (needsVpt) {\n                    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n                }\n                object.render(ctx);\n                ctx.restore();\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderBackground: function(ctx) {\n            this._renderBackgroundOrOverlay(ctx, \"background\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderOverlay: function(ctx) {\n            this._renderBackgroundOrOverlay(ctx, \"overlay\");\n        },\n        /**\n     * Returns coordinates of a center of canvas.\n     * Returned value is an object with top and left properties\n     * @return {Object} object with \"top\" and \"left\" number values\n     * @deprecated migrate to `getCenterPoint`\n     */ getCenter: function() {\n            return {\n                top: this.height / 2,\n                left: this.width / 2\n            };\n        },\n        /**\n     * Returns coordinates of a center of canvas.\n     * @return {fabric.Point} \n     */ getCenterPoint: function() {\n            return new fabric.Point(this.width / 2, this.height / 2);\n        },\n        /**\n     * Centers object horizontally in the canvas\n     * @param {fabric.Object} object Object to center horizontally\n     * @return {fabric.Canvas} thisArg\n     */ centerObjectH: function(object) {\n            return this._centerObject(object, new fabric.Point(this.getCenterPoint().x, object.getCenterPoint().y));\n        },\n        /**\n     * Centers object vertically in the canvas\n     * @param {fabric.Object} object Object to center vertically\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ centerObjectV: function(object) {\n            return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenterPoint().y));\n        },\n        /**\n     * Centers object vertically and horizontally in the canvas\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ centerObject: function(object) {\n            var center = this.getCenterPoint();\n            return this._centerObject(object, center);\n        },\n        /**\n     * Centers object vertically and horizontally in the viewport\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ viewportCenterObject: function(object) {\n            var vpCenter = this.getVpCenter();\n            return this._centerObject(object, vpCenter);\n        },\n        /**\n     * Centers object horizontally in the viewport, object.top is unchanged\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ viewportCenterObjectH: function(object) {\n            var vpCenter = this.getVpCenter();\n            this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));\n            return this;\n        },\n        /**\n     * Centers object Vertically in the viewport, object.top is unchanged\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ viewportCenterObjectV: function(object) {\n            var vpCenter = this.getVpCenter();\n            return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));\n        },\n        /**\n     * Calculate the point in canvas that correspond to the center of actual viewport.\n     * @return {fabric.Point} vpCenter, viewport center\n     * @chainable\n     */ getVpCenter: function() {\n            var center = this.getCenterPoint(), iVpt = invertTransform(this.viewportTransform);\n            return transformPoint(center, iVpt);\n        },\n        /**\n     * @private\n     * @param {fabric.Object} object Object to center\n     * @param {fabric.Point} center Center point\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ _centerObject: function(object, center) {\n            object.setPositionByOrigin(center, \"center\", \"center\");\n            object.setCoords();\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Returns dataless JSON representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {String} json string\n     */ toDatalessJSON: function(propertiesToInclude) {\n            return this.toDatalessObject(propertiesToInclude);\n        },\n        /**\n     * Returns object representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this._toObjectMethod(\"toObject\", propertiesToInclude);\n        },\n        /**\n     * Returns dataless object representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            return this._toObjectMethod(\"toDatalessObject\", propertiesToInclude);\n        },\n        /**\n     * @private\n     */ _toObjectMethod: function(methodName, propertiesToInclude) {\n            var clipPath = this.clipPath, data = {\n                version: fabric.version,\n                objects: this._toObjects(methodName, propertiesToInclude)\n            };\n            if (clipPath && !clipPath.excludeFromExport) {\n                data.clipPath = this._toObject(this.clipPath, methodName, propertiesToInclude);\n            }\n            extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));\n            fabric.util.populateWithProperties(this, data, propertiesToInclude);\n            return data;\n        },\n        /**\n     * @private\n     */ _toObjects: function(methodName, propertiesToInclude) {\n            return this._objects.filter(function(object) {\n                return !object.excludeFromExport;\n            }).map(function(instance) {\n                return this._toObject(instance, methodName, propertiesToInclude);\n            }, this);\n        },\n        /**\n     * @private\n     */ _toObject: function(instance, methodName, propertiesToInclude) {\n            var originalValue;\n            if (!this.includeDefaultValues) {\n                originalValue = instance.includeDefaultValues;\n                instance.includeDefaultValues = false;\n            }\n            var object = instance[methodName](propertiesToInclude);\n            if (!this.includeDefaultValues) {\n                instance.includeDefaultValues = originalValue;\n            }\n            return object;\n        },\n        /**\n     * @private\n     */ __serializeBgOverlay: function(methodName, propertiesToInclude) {\n            var data = {}, bgImage = this.backgroundImage, overlayImage = this.overlayImage, bgColor = this.backgroundColor, overlayColor = this.overlayColor;\n            if (bgColor && bgColor.toObject) {\n                if (!bgColor.excludeFromExport) {\n                    data.background = bgColor.toObject(propertiesToInclude);\n                }\n            } else if (bgColor) {\n                data.background = bgColor;\n            }\n            if (overlayColor && overlayColor.toObject) {\n                if (!overlayColor.excludeFromExport) {\n                    data.overlay = overlayColor.toObject(propertiesToInclude);\n                }\n            } else if (overlayColor) {\n                data.overlay = overlayColor;\n            }\n            if (bgImage && !bgImage.excludeFromExport) {\n                data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);\n            }\n            if (overlayImage && !overlayImage.excludeFromExport) {\n                data.overlayImage = this._toObject(overlayImage, methodName, propertiesToInclude);\n            }\n            return data;\n        },\n        /* _TO_SVG_START_ */ /**\n     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,\n     * a zoomed canvas will then produce zoomed SVG output.\n     * @type Boolean\n     * @default\n     */ svgViewportTransformation: true,\n        /**\n     * Returns SVG representation of canvas\n     * @function\n     * @param {Object} [options] Options object for SVG output\n     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included\n     * @param {Object} [options.viewBox] SVG viewbox object\n     * @param {Number} [options.viewBox.x] x-coordinate of viewbox\n     * @param {Number} [options.viewBox.y] y-coordinate of viewbox\n     * @param {Number} [options.viewBox.width] Width of viewbox\n     * @param {Number} [options.viewBox.height] Height of viewbox\n     * @param {String} [options.encoding=UTF-8] Encoding of SVG output\n     * @param {String} [options.width] desired width of svg with or without units\n     * @param {String} [options.height] desired height of svg with or without units\n     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.\n     * @return {String} SVG string\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}\n     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}\n     * @example <caption>Normal SVG output</caption>\n     * var svg = canvas.toSVG();\n     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>\n     * var svg = canvas.toSVG({suppressPreamble: true});\n     * @example <caption>SVG output with viewBox attribute</caption>\n     * var svg = canvas.toSVG({\n     *   viewBox: {\n     *     x: 100,\n     *     y: 100,\n     *     width: 200,\n     *     height: 300\n     *   }\n     * });\n     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>\n     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});\n     * @example <caption>Modify SVG output with reviver function</caption>\n     * var svg = canvas.toSVG(null, function(svg) {\n     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');\n     * });\n     */ toSVG: function(options, reviver) {\n            options || (options = {});\n            options.reviver = reviver;\n            var markup = [];\n            this._setSVGPreamble(markup, options);\n            this._setSVGHeader(markup, options);\n            if (this.clipPath) {\n                markup.push('<g clip-path=\"url(#' + this.clipPath.clipPathId + ')\" >\\n');\n            }\n            this._setSVGBgOverlayColor(markup, \"background\");\n            this._setSVGBgOverlayImage(markup, \"backgroundImage\", reviver);\n            this._setSVGObjects(markup, reviver);\n            if (this.clipPath) {\n                markup.push(\"</g>\\n\");\n            }\n            this._setSVGBgOverlayColor(markup, \"overlay\");\n            this._setSVGBgOverlayImage(markup, \"overlayImage\", reviver);\n            markup.push(\"</svg>\");\n            return markup.join(\"\");\n        },\n        /**\n     * @private\n     */ _setSVGPreamble: function(markup, options) {\n            if (options.suppressPreamble) {\n                return;\n            }\n            markup.push('<?xml version=\"1.0\" encoding=\"', options.encoding || \"UTF-8\", '\" standalone=\"no\" ?>\\n', '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" ', '\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n');\n        },\n        /**\n     * @private\n     */ _setSVGHeader: function(markup, options) {\n            var width = options.width || this.width, height = options.height || this.height, vpt, viewBox = 'viewBox=\"0 0 ' + this.width + \" \" + this.height + '\" ', NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            if (options.viewBox) {\n                viewBox = 'viewBox=\"' + options.viewBox.x + \" \" + options.viewBox.y + \" \" + options.viewBox.width + \" \" + options.viewBox.height + '\" ';\n            } else {\n                if (this.svgViewportTransformation) {\n                    vpt = this.viewportTransform;\n                    viewBox = 'viewBox=\"' + toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + \" \" + toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + \" \" + toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + \" \" + toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '\" ';\n                }\n            }\n            markup.push(\"<svg \", 'xmlns=\"http://www.w3.org/2000/svg\" ', 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ', 'version=\"1.1\" ', 'width=\"', width, '\" ', 'height=\"', height, '\" ', viewBox, 'xml:space=\"preserve\">\\n', \"<desc>Created with Fabric.js \", fabric.version, \"</desc>\\n\", \"<defs>\\n\", this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(options), \"</defs>\\n\");\n        },\n        createSVGClipPathMarkup: function(options) {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                clipPath.clipPathId = \"CLIPPATH_\" + fabric.Object.__uid++;\n                return '<clipPath id=\"' + clipPath.clipPathId + '\" >\\n' + this.clipPath.toClipPathSVG(options.reviver) + \"</clipPath>\\n\";\n            }\n            return \"\";\n        },\n        /**\n     * Creates markup containing SVG referenced elements like patterns, gradients etc.\n     * @return {String}\n     */ createSVGRefElementsMarkup: function() {\n            var _this = this, markup = [\n                \"background\",\n                \"overlay\"\n            ].map(function(prop) {\n                var fill = _this[prop + \"Color\"];\n                if (fill && fill.toLive) {\n                    var shouldTransform = _this[prop + \"Vpt\"], vpt = _this.viewportTransform, object = {\n                        width: _this.width / (shouldTransform ? vpt[0] : 1),\n                        height: _this.height / (shouldTransform ? vpt[3] : 1)\n                    };\n                    return fill.toSVG(object, {\n                        additionalTransform: shouldTransform ? fabric.util.matrixToSVG(vpt) : \"\"\n                    });\n                }\n            });\n            return markup.join(\"\");\n        },\n        /**\n     * Creates markup containing SVG font faces,\n     * font URLs for font faces must be collected by developers\n     * and are not extracted from the DOM by fabricjs\n     * @param {Array} objects Array of fabric objects\n     * @return {String}\n     */ createSVGFontFacesMarkup: function() {\n            var markup = \"\", fontList = {}, obj, fontFamily, style, row, rowIndex, _char, charIndex, i, len, fontPaths = fabric.fontPaths, objects = [];\n            this._objects.forEach(function add(object) {\n                objects.push(object);\n                if (object._objects) {\n                    object._objects.forEach(add);\n                }\n            });\n            for(i = 0, len = objects.length; i < len; i++){\n                obj = objects[i];\n                fontFamily = obj.fontFamily;\n                if (obj.type.indexOf(\"text\") === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {\n                    continue;\n                }\n                fontList[fontFamily] = true;\n                if (!obj.styles) {\n                    continue;\n                }\n                style = obj.styles;\n                for(rowIndex in style){\n                    row = style[rowIndex];\n                    for(charIndex in row){\n                        _char = row[charIndex];\n                        fontFamily = _char.fontFamily;\n                        if (!fontList[fontFamily] && fontPaths[fontFamily]) {\n                            fontList[fontFamily] = true;\n                        }\n                    }\n                }\n            }\n            for(var j in fontList){\n                markup += [\n                    \"\t\t@font-face {\\n\",\n                    \"\t\t\tfont-family: '\",\n                    j,\n                    \"';\\n\",\n                    \"\t\t\tsrc: url('\",\n                    fontPaths[j],\n                    \"');\\n\",\n                    \"\t\t}\\n\"\n                ].join(\"\");\n            }\n            if (markup) {\n                markup = [\n                    '\t<style type=\"text/css\">',\n                    \"<![CDATA[\\n\",\n                    markup,\n                    \"]]>\",\n                    \"</style>\\n\"\n                ].join(\"\");\n            }\n            return markup;\n        },\n        /**\n     * @private\n     */ _setSVGObjects: function(markup, reviver) {\n            var instance, i, len, objects = this._objects;\n            for(i = 0, len = objects.length; i < len; i++){\n                instance = objects[i];\n                if (instance.excludeFromExport) {\n                    continue;\n                }\n                this._setSVGObject(markup, instance, reviver);\n            }\n        },\n        /**\n     * @private\n     */ _setSVGObject: function(markup, instance, reviver) {\n            markup.push(instance.toSVG(reviver));\n        },\n        /**\n     * @private\n     */ _setSVGBgOverlayImage: function(markup, property, reviver) {\n            if (this[property] && !this[property].excludeFromExport && this[property].toSVG) {\n                markup.push(this[property].toSVG(reviver));\n            }\n        },\n        /**\n     * @private\n     */ _setSVGBgOverlayColor: function(markup, property) {\n            var filler = this[property + \"Color\"], vpt = this.viewportTransform, finalWidth = this.width, finalHeight = this.height;\n            if (!filler) {\n                return;\n            }\n            if (filler.toLive) {\n                var repeat = filler.repeat, iVpt = fabric.util.invertTransform(vpt), shouldInvert = this[property + \"Vpt\"], additionalTransform = shouldInvert ? fabric.util.matrixToSVG(iVpt) : \"\";\n                markup.push('<rect transform=\"' + additionalTransform + \" translate(\", finalWidth / 2, \",\", finalHeight / 2, ')\"', ' x=\"', filler.offsetX - finalWidth / 2, '\" y=\"', filler.offsetY - finalHeight / 2, '\" ', 'width=\"', repeat === \"repeat-y\" || repeat === \"no-repeat\" ? filler.source.width : finalWidth, '\" height=\"', repeat === \"repeat-x\" || repeat === \"no-repeat\" ? filler.source.height : finalHeight, '\" fill=\"url(#SVGID_' + filler.id + ')\"', \"></rect>\\n\");\n            } else {\n                markup.push('<rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" ', 'fill=\"', filler, '\"', \"></rect>\\n\");\n            }\n        },\n        /* _TO_SVG_END_ */ /**\n     * Moves an object or the objects of a multiple selection\n     * to the bottom of the stack of drawn objects\n     * @param {fabric.Object} object Object to send to back\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ sendToBack: function(object) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, objs;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = objs.length; i--;){\n                    obj = objs[i];\n                    removeFromArray(this._objects, obj);\n                    this._objects.unshift(obj);\n                }\n            } else {\n                removeFromArray(this._objects, object);\n                this._objects.unshift(object);\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Moves an object or the objects of a multiple selection\n     * to the top of the stack of drawn objects\n     * @param {fabric.Object} object Object to send\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ bringToFront: function(object) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, objs;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = 0; i < objs.length; i++){\n                    obj = objs[i];\n                    removeFromArray(this._objects, obj);\n                    this._objects.push(obj);\n                }\n            } else {\n                removeFromArray(this._objects, object);\n                this._objects.push(object);\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Moves an object or a selection down in stack of drawn objects\n     * An optional parameter, intersecting allows to move the object in behind\n     * the first intersecting object. Where intersection is calculated with\n     * bounding box. If no intersection is found, there will not be change in the\n     * stack.\n     * @param {fabric.Object} object Object to send\n     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ sendBackwards: function(object, intersecting) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, idx, newIdx, objs, objsMoved = 0;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = 0; i < objs.length; i++){\n                    obj = objs[i];\n                    idx = this._objects.indexOf(obj);\n                    if (idx > 0 + objsMoved) {\n                        newIdx = idx - 1;\n                        removeFromArray(this._objects, obj);\n                        this._objects.splice(newIdx, 0, obj);\n                    }\n                    objsMoved++;\n                }\n            } else {\n                idx = this._objects.indexOf(object);\n                if (idx !== 0) {\n                    // if object is not on the bottom of stack\n                    newIdx = this._findNewLowerIndex(object, idx, intersecting);\n                    removeFromArray(this._objects, object);\n                    this._objects.splice(newIdx, 0, object);\n                }\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * @private\n     */ _findNewLowerIndex: function(object, idx, intersecting) {\n            var newIdx, i;\n            if (intersecting) {\n                newIdx = idx;\n                // traverse down the stack looking for the nearest intersecting object\n                for(i = idx - 1; i >= 0; --i){\n                    var isIntersecting = object.intersectsWithObject(this._objects[i]) || object.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(object);\n                    if (isIntersecting) {\n                        newIdx = i;\n                        break;\n                    }\n                }\n            } else {\n                newIdx = idx - 1;\n            }\n            return newIdx;\n        },\n        /**\n     * Moves an object or a selection up in stack of drawn objects\n     * An optional parameter, intersecting allows to move the object in front\n     * of the first intersecting object. Where intersection is calculated with\n     * bounding box. If no intersection is found, there will not be change in the\n     * stack.\n     * @param {fabric.Object} object Object to send\n     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ bringForward: function(object, intersecting) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, idx, newIdx, objs, objsMoved = 0;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = objs.length; i--;){\n                    obj = objs[i];\n                    idx = this._objects.indexOf(obj);\n                    if (idx < this._objects.length - 1 - objsMoved) {\n                        newIdx = idx + 1;\n                        removeFromArray(this._objects, obj);\n                        this._objects.splice(newIdx, 0, obj);\n                    }\n                    objsMoved++;\n                }\n            } else {\n                idx = this._objects.indexOf(object);\n                if (idx !== this._objects.length - 1) {\n                    // if object is not on top of stack (last item in an array)\n                    newIdx = this._findNewUpperIndex(object, idx, intersecting);\n                    removeFromArray(this._objects, object);\n                    this._objects.splice(newIdx, 0, object);\n                }\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * @private\n     */ _findNewUpperIndex: function(object, idx, intersecting) {\n            var newIdx, i, len;\n            if (intersecting) {\n                newIdx = idx;\n                // traverse up the stack looking for the nearest intersecting object\n                for(i = idx + 1, len = this._objects.length; i < len; ++i){\n                    var isIntersecting = object.intersectsWithObject(this._objects[i]) || object.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(object);\n                    if (isIntersecting) {\n                        newIdx = i;\n                        break;\n                    }\n                }\n            } else {\n                newIdx = idx + 1;\n            }\n            return newIdx;\n        },\n        /**\n     * Moves an object to specified level in stack of drawn objects\n     * @param {fabric.Object} object Object to send\n     * @param {Number} index Position to move to\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ moveTo: function(object, index) {\n            removeFromArray(this._objects, object);\n            this._objects.splice(index, 0, object);\n            return this.renderOnAddRemove && this.requestRenderAll();\n        },\n        /**\n     * Clears a canvas element and dispose objects\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ dispose: function() {\n            // cancel eventually ongoing renders\n            if (this.isRendering) {\n                fabric.util.cancelAnimFrame(this.isRendering);\n                this.isRendering = 0;\n            }\n            this.forEachObject(function(object) {\n                object.dispose && object.dispose();\n            });\n            this._objects = [];\n            if (this.backgroundImage && this.backgroundImage.dispose) {\n                this.backgroundImage.dispose();\n            }\n            this.backgroundImage = null;\n            if (this.overlayImage && this.overlayImage.dispose) {\n                this.overlayImage.dispose();\n            }\n            this.overlayImage = null;\n            this._iTextInstances = null;\n            this.contextContainer = null;\n            // restore canvas style\n            this.lowerCanvasEl.classList.remove(\"lower-canvas\");\n            fabric.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle);\n            delete this._originalCanvasStyle;\n            // restore canvas size to original size in case retina scaling was applied\n            this.lowerCanvasEl.setAttribute(\"width\", this.width);\n            this.lowerCanvasEl.setAttribute(\"height\", this.height);\n            fabric.util.cleanUpJsdomNode(this.lowerCanvasEl);\n            this.lowerCanvasEl = undefined;\n            return this;\n        },\n        /**\n     * Returns a string representation of an instance\n     * @return {String} string representation of an instance\n     */ toString: function() {\n            return \"#<fabric.Canvas (\" + this.complexity() + \"): \" + \"{ objects: \" + this._objects.length + \" }>\";\n        }\n    });\n    extend(fabric.StaticCanvas.prototype, fabric.Observable);\n    extend(fabric.StaticCanvas.prototype, fabric.Collection);\n    extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);\n    extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {\n        /**\n     * @static\n     * @type String\n     * @default\n     */ EMPTY_JSON: '{\"objects\": [], \"background\": \"white\"}',\n        /**\n     * Provides a way to check support of some of the canvas methods\n     * (either those of HTMLCanvasElement itself, or rendering context)\n     *\n     * @param {String} methodName Method to check support for;\n     *                            Could be one of \"setLineDash\"\n     * @return {Boolean | null} `true` if method is supported (or at least exists),\n     *                          `null` if canvas element or context can not be initialized\n     */ supports: function(methodName) {\n            var el = createCanvasElement();\n            if (!el || !el.getContext) {\n                return null;\n            }\n            var ctx = el.getContext(\"2d\");\n            if (!ctx) {\n                return null;\n            }\n            switch(methodName){\n                case \"setLineDash\":\n                    return typeof ctx.setLineDash !== \"undefined\";\n                default:\n                    return null;\n            }\n        }\n    });\n    /**\n   * Returns Object representation of canvas\n   * this alias is provided because if you call JSON.stringify on an instance,\n   * the toJSON object will be invoked if it exists.\n   * Having a toJSON method means you can do JSON.stringify(myCanvas)\n   * @function\n   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @return {Object} JSON compatible object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}\n   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}\n   * @example <caption>JSON without additional properties</caption>\n   * var json = canvas.toJSON();\n   * @example <caption>JSON with additional properties included</caption>\n   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY']);\n   * @example <caption>JSON without default values</caption>\n   * canvas.includeDefaultValues = false;\n   * var json = canvas.toJSON();\n   */ fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;\n    if (fabric.isLikelyNode) {\n        fabric.StaticCanvas.prototype.createPNGStream = function() {\n            var impl = getNodeCanvas(this.lowerCanvasEl);\n            return impl && impl.createPNGStream();\n        };\n        fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {\n            var impl = getNodeCanvas(this.lowerCanvasEl);\n            return impl && impl.createJPEGStream(opts);\n        };\n    }\n})();\n/**\n * BaseBrush class\n * @class fabric.BaseBrush\n * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}\n */ fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {\n    /**\n   * Color of a brush\n   * @type String\n   * @default\n   */ color: \"rgb(0, 0, 0)\",\n    /**\n   * Width of a brush, has to be a Number, no string literals\n   * @type Number\n   * @default\n   */ width: 1,\n    /**\n   * Shadow object representing shadow of this shape.\n   * <b>Backwards incompatibility note:</b> This property replaces \"shadowColor\" (String), \"shadowOffsetX\" (Number),\n   * \"shadowOffsetY\" (Number) and \"shadowBlur\" (Number) since v1.2.12\n   * @type fabric.Shadow\n   * @default\n   */ shadow: null,\n    /**\n   * Line endings style of a brush (one of \"butt\", \"round\", \"square\")\n   * @type String\n   * @default\n   */ strokeLineCap: \"round\",\n    /**\n   * Corner style of a brush (one of \"bevel\", \"round\", \"miter\")\n   * @type String\n   * @default\n   */ strokeLineJoin: \"round\",\n    /**\n   * Maximum miter length (used for strokeLineJoin = \"miter\") of a brush's\n   * @type Number\n   * @default\n   */ strokeMiterLimit: 10,\n    /**\n   * Stroke Dash Array.\n   * @type Array\n   * @default\n   */ strokeDashArray: null,\n    /**\n   * When `true`, the free drawing is limited to the whiteboard size. Default to false.\n   * @type Boolean\n   * @default false\n  */ limitedToCanvasSize: false,\n    /**\n   * Sets brush styles\n   * @private\n   * @param {CanvasRenderingContext2D} ctx\n   */ _setBrushStyles: function(ctx) {\n        ctx.strokeStyle = this.color;\n        ctx.lineWidth = this.width;\n        ctx.lineCap = this.strokeLineCap;\n        ctx.miterLimit = this.strokeMiterLimit;\n        ctx.lineJoin = this.strokeLineJoin;\n        ctx.setLineDash(this.strokeDashArray || []);\n    },\n    /**\n   * Sets the transformation on given context\n   * @param {RenderingContext2d} ctx context to render on\n   * @private\n   */ _saveAndTransform: function(ctx) {\n        var v = this.canvas.viewportTransform;\n        ctx.save();\n        ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n    },\n    /**\n   * Sets brush shadow styles\n   * @private\n   */ _setShadow: function() {\n        if (!this.shadow) {\n            return;\n        }\n        var canvas = this.canvas, shadow = this.shadow, ctx = canvas.contextTop, zoom = canvas.getZoom();\n        if (canvas && canvas._isRetinaScaling()) {\n            zoom *= fabric.devicePixelRatio;\n        }\n        ctx.shadowColor = shadow.color;\n        ctx.shadowBlur = shadow.blur * zoom;\n        ctx.shadowOffsetX = shadow.offsetX * zoom;\n        ctx.shadowOffsetY = shadow.offsetY * zoom;\n    },\n    needsFullRender: function() {\n        var color = new fabric.Color(this.color);\n        return color.getAlpha() < 1 || !!this.shadow;\n    },\n    /**\n   * Removes brush shadow styles\n   * @private\n   */ _resetShadow: function() {\n        var ctx = this.canvas.contextTop;\n        ctx.shadowColor = \"\";\n        ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\n    },\n    /**\n   * Check is pointer is outside canvas boundaries\n   * @param {Object} pointer\n   * @private\n  */ _isOutSideCanvas: function(pointer) {\n        return pointer.x < 0 || pointer.x > this.canvas.getWidth() || pointer.y < 0 || pointer.y > this.canvas.getHeight();\n    }\n});\n(function() {\n    /**\n   * PencilBrush class\n   * @class fabric.PencilBrush\n   * @extends fabric.BaseBrush\n   */ fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {\n        /**\n     * Discard points that are less than `decimate` pixel distant from each other\n     * @type Number\n     * @default 0.4\n     */ decimate: 0.4,\n        /**\n     * Draws a straight line between last recorded point to current pointer\n     * Used for `shift` functionality\n     *\n     * @type boolean\n     * @default false\n     */ drawStraightLine: false,\n        /**\n     * The event modifier key that makes the brush draw a straight line.\n     * If `null` or 'none' or any other string that is not a modifier key the feature is disabled.\n     * @type {'altKey' | 'shiftKey' | 'ctrlKey' | 'none' | undefined | null}\n     */ straightLineKey: \"shiftKey\",\n        /**\n     * Constructor\n     * @param {fabric.Canvas} canvas\n     * @return {fabric.PencilBrush} Instance of a pencil brush\n     */ initialize: function(canvas) {\n            this.canvas = canvas;\n            this._points = [];\n        },\n        needsFullRender: function() {\n            return this.callSuper(\"needsFullRender\") || this._hasStraightLine;\n        },\n        /**\n     * Invoked inside on mouse down and mouse move\n     * @param {Object} pointer\n     */ _drawSegment: function(ctx, p1, p2) {\n            var midPoint = p1.midPointFrom(p2);\n            ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\n            return midPoint;\n        },\n        /**\n     * Invoked on mouse down\n     * @param {Object} pointer\n     */ onMouseDown: function(pointer, options) {\n            if (!this.canvas._isMainEvent(options.e)) {\n                return;\n            }\n            this.drawStraightLine = options.e[this.straightLineKey];\n            this._prepareForDrawing(pointer);\n            // capture coordinates immediately\n            // this allows to draw dots (when movement never occurs)\n            this._captureDrawingPath(pointer);\n            this._render();\n        },\n        /**\n     * Invoked on mouse move\n     * @param {Object} pointer\n     */ onMouseMove: function(pointer, options) {\n            if (!this.canvas._isMainEvent(options.e)) {\n                return;\n            }\n            this.drawStraightLine = options.e[this.straightLineKey];\n            if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {\n                return;\n            }\n            if (this._captureDrawingPath(pointer) && this._points.length > 1) {\n                if (this.needsFullRender()) {\n                    // redraw curve\n                    // clear top canvas\n                    this.canvas.clearContext(this.canvas.contextTop);\n                    this._render();\n                } else {\n                    var points = this._points, length = points.length, ctx = this.canvas.contextTop;\n                    // draw the curve update\n                    this._saveAndTransform(ctx);\n                    if (this.oldEnd) {\n                        ctx.beginPath();\n                        ctx.moveTo(this.oldEnd.x, this.oldEnd.y);\n                    }\n                    this.oldEnd = this._drawSegment(ctx, points[length - 2], points[length - 1], true);\n                    ctx.stroke();\n                    ctx.restore();\n                }\n            }\n        },\n        /**\n     * Invoked on mouse up\n     */ onMouseUp: function(options) {\n            if (!this.canvas._isMainEvent(options.e)) {\n                return true;\n            }\n            this.drawStraightLine = false;\n            this.oldEnd = undefined;\n            this._finalizeAndAddPath();\n            return false;\n        },\n        /**\n     * @private\n     * @param {Object} pointer Actual mouse position related to the canvas.\n     */ _prepareForDrawing: function(pointer) {\n            var p = new fabric.Point(pointer.x, pointer.y);\n            this._reset();\n            this._addPoint(p);\n            this.canvas.contextTop.moveTo(p.x, p.y);\n        },\n        /**\n     * @private\n     * @param {fabric.Point} point Point to be added to points array\n     */ _addPoint: function(point) {\n            if (this._points.length > 1 && point.eq(this._points[this._points.length - 1])) {\n                return false;\n            }\n            if (this.drawStraightLine && this._points.length > 1) {\n                this._hasStraightLine = true;\n                this._points.pop();\n            }\n            this._points.push(point);\n            return true;\n        },\n        /**\n     * Clear points array and set contextTop canvas style.\n     * @private\n     */ _reset: function() {\n            this._points = [];\n            this._setBrushStyles(this.canvas.contextTop);\n            this._setShadow();\n            this._hasStraightLine = false;\n        },\n        /**\n     * @private\n     * @param {Object} pointer Actual mouse position related to the canvas.\n     */ _captureDrawingPath: function(pointer) {\n            var pointerPoint = new fabric.Point(pointer.x, pointer.y);\n            return this._addPoint(pointerPoint);\n        },\n        /**\n     * Draw a smooth path on the topCanvas using quadraticCurveTo\n     * @private\n     * @param {CanvasRenderingContext2D} [ctx]\n     */ _render: function(ctx) {\n            var i, len, p1 = this._points[0], p2 = this._points[1];\n            ctx = ctx || this.canvas.contextTop;\n            this._saveAndTransform(ctx);\n            ctx.beginPath();\n            //if we only have 2 points in the path and they are the same\n            //it means that the user only clicked the canvas without moving the mouse\n            //then we should be drawing a dot. A path isn't drawn between two identical dots\n            //that's why we set them apart a bit\n            if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {\n                var width = this.width / 1000;\n                p1 = new fabric.Point(p1.x, p1.y);\n                p2 = new fabric.Point(p2.x, p2.y);\n                p1.x -= width;\n                p2.x += width;\n            }\n            ctx.moveTo(p1.x, p1.y);\n            for(i = 1, len = this._points.length; i < len; i++){\n                // we pick the point between pi + 1 & pi + 2 as the\n                // end point and p1 as our control point.\n                this._drawSegment(ctx, p1, p2);\n                p1 = this._points[i];\n                p2 = this._points[i + 1];\n            }\n            // Draw last line as a straight line while\n            // we wait for the next point to be able to calculate\n            // the bezier control point\n            ctx.lineTo(p1.x, p1.y);\n            ctx.stroke();\n            ctx.restore();\n        },\n        /**\n     * Converts points to SVG path\n     * @param {Array} points Array of points\n     * @return {(string|number)[][]} SVG path commands\n     */ convertPointsToSVGPath: function(points) {\n            var correction = this.width / 1000;\n            return fabric.util.getSmoothPathFromPoints(points, correction);\n        },\n        /**\n     * @private\n     * @param {(string|number)[][]} pathData SVG path commands\n     * @returns {boolean}\n     */ _isEmptySVGPath: function(pathData) {\n            var pathString = fabric.util.joinPath(pathData);\n            return pathString === \"M 0 0 Q 0 0 0 0 L 0 0\";\n        },\n        /**\n     * Creates fabric.Path object to add on canvas\n     * @param {(string|number)[][]} pathData Path data\n     * @return {fabric.Path} Path to add on canvas\n     */ createPath: function(pathData) {\n            var path = new fabric.Path(pathData, {\n                fill: null,\n                stroke: this.color,\n                strokeWidth: this.width,\n                strokeLineCap: this.strokeLineCap,\n                strokeMiterLimit: this.strokeMiterLimit,\n                strokeLineJoin: this.strokeLineJoin,\n                strokeDashArray: this.strokeDashArray\n            });\n            if (this.shadow) {\n                this.shadow.affectStroke = true;\n                path.shadow = new fabric.Shadow(this.shadow);\n            }\n            return path;\n        },\n        /**\n     * Decimate points array with the decimate value\n     */ decimatePoints: function(points, distance) {\n            if (points.length <= 2) {\n                return points;\n            }\n            var zoom = this.canvas.getZoom(), adjustedDistance = Math.pow(distance / zoom, 2), i, l = points.length - 1, lastPoint = points[0], newPoints = [\n                lastPoint\n            ], cDistance;\n            for(i = 1; i < l - 1; i++){\n                cDistance = Math.pow(lastPoint.x - points[i].x, 2) + Math.pow(lastPoint.y - points[i].y, 2);\n                if (cDistance >= adjustedDistance) {\n                    lastPoint = points[i];\n                    newPoints.push(lastPoint);\n                }\n            }\n            /**\n       * Add the last point from the original line to the end of the array.\n       * This ensures decimate doesn't delete the last point on the line, and ensures the line is > 1 point.\n       */ newPoints.push(points[l]);\n            return newPoints;\n        },\n        /**\n     * On mouseup after drawing the path on contextTop canvas\n     * we use the points captured to create an new fabric path object\n     * and add it to the fabric canvas.\n     */ _finalizeAndAddPath: function() {\n            var ctx = this.canvas.contextTop;\n            ctx.closePath();\n            if (this.decimate) {\n                this._points = this.decimatePoints(this._points, this.decimate);\n            }\n            var pathData = this.convertPointsToSVGPath(this._points);\n            if (this._isEmptySVGPath(pathData)) {\n                // do not create 0 width/height paths, as they are\n                // rendered inconsistently across browsers\n                // Firefox 4, for example, renders a dot,\n                // whereas Chrome 10 renders nothing\n                this.canvas.requestRenderAll();\n                return;\n            }\n            var path = this.createPath(pathData);\n            this.canvas.clearContext(this.canvas.contextTop);\n            this.canvas.fire(\"before:path:created\", {\n                path: path\n            });\n            this.canvas.add(path);\n            this.canvas.requestRenderAll();\n            path.setCoords();\n            this._resetShadow();\n            // fire event 'path' created\n            this.canvas.fire(\"path:created\", {\n                path: path\n            });\n        }\n    });\n})();\n/**\n * CircleBrush class\n * @class fabric.CircleBrush\n */ fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {\n    /**\n   * Width of a brush\n   * @type Number\n   * @default\n   */ width: 10,\n    /**\n   * Constructor\n   * @param {fabric.Canvas} canvas\n   * @return {fabric.CircleBrush} Instance of a circle brush\n   */ initialize: function(canvas) {\n        this.canvas = canvas;\n        this.points = [];\n    },\n    /**\n   * Invoked inside on mouse down and mouse move\n   * @param {Object} pointer\n   */ drawDot: function(pointer) {\n        var point = this.addPoint(pointer), ctx = this.canvas.contextTop;\n        this._saveAndTransform(ctx);\n        this.dot(ctx, point);\n        ctx.restore();\n    },\n    dot: function(ctx, point) {\n        ctx.fillStyle = point.fill;\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);\n        ctx.closePath();\n        ctx.fill();\n    },\n    /**\n   * Invoked on mouse down\n   */ onMouseDown: function(pointer) {\n        this.points.length = 0;\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._setShadow();\n        this.drawDot(pointer);\n    },\n    /**\n   * Render the full state of the brush\n   * @private\n   */ _render: function() {\n        var ctx = this.canvas.contextTop, i, len, points = this.points;\n        this._saveAndTransform(ctx);\n        for(i = 0, len = points.length; i < len; i++){\n            this.dot(ctx, points[i]);\n        }\n        ctx.restore();\n    },\n    /**\n   * Invoked on mouse move\n   * @param {Object} pointer\n   */ onMouseMove: function(pointer) {\n        if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {\n            return;\n        }\n        if (this.needsFullRender()) {\n            this.canvas.clearContext(this.canvas.contextTop);\n            this.addPoint(pointer);\n            this._render();\n        } else {\n            this.drawDot(pointer);\n        }\n    },\n    /**\n   * Invoked on mouse up\n   */ onMouseUp: function() {\n        var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i, len;\n        this.canvas.renderOnAddRemove = false;\n        var circles = [];\n        for(i = 0, len = this.points.length; i < len; i++){\n            var point = this.points[i], circle = new fabric.Circle({\n                radius: point.radius,\n                left: point.x,\n                top: point.y,\n                originX: \"center\",\n                originY: \"center\",\n                fill: point.fill\n            });\n            this.shadow && (circle.shadow = new fabric.Shadow(this.shadow));\n            circles.push(circle);\n        }\n        var group = new fabric.Group(circles);\n        group.canvas = this.canvas;\n        this.canvas.fire(\"before:path:created\", {\n            path: group\n        });\n        this.canvas.add(group);\n        this.canvas.fire(\"path:created\", {\n            path: group\n        });\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._resetShadow();\n        this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\n        this.canvas.requestRenderAll();\n    },\n    /**\n   * @param {Object} pointer\n   * @return {fabric.Point} Just added pointer point\n   */ addPoint: function(pointer) {\n        var pointerPoint = new fabric.Point(pointer.x, pointer.y), circleRadius = fabric.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) / 2, circleColor = new fabric.Color(this.color).setAlpha(fabric.util.getRandomInt(0, 100) / 100).toRgba();\n        pointerPoint.radius = circleRadius;\n        pointerPoint.fill = circleColor;\n        this.points.push(pointerPoint);\n        return pointerPoint;\n    }\n});\n/**\n * SprayBrush class\n * @class fabric.SprayBrush\n */ fabric.SprayBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {\n    /**\n   * Width of a spray\n   * @type Number\n   * @default\n   */ width: 10,\n    /**\n   * Density of a spray (number of dots per chunk)\n   * @type Number\n   * @default\n   */ density: 20,\n    /**\n   * Width of spray dots\n   * @type Number\n   * @default\n   */ dotWidth: 1,\n    /**\n   * Width variance of spray dots\n   * @type Number\n   * @default\n   */ dotWidthVariance: 1,\n    /**\n   * Whether opacity of a dot should be random\n   * @type Boolean\n   * @default\n   */ randomOpacity: false,\n    /**\n   * Whether overlapping dots (rectangles) should be removed (for performance reasons)\n   * @type Boolean\n   * @default\n   */ optimizeOverlapping: true,\n    /**\n   * Constructor\n   * @param {fabric.Canvas} canvas\n   * @return {fabric.SprayBrush} Instance of a spray brush\n   */ initialize: function(canvas) {\n        this.canvas = canvas;\n        this.sprayChunks = [];\n    },\n    /**\n   * Invoked on mouse down\n   * @param {Object} pointer\n   */ onMouseDown: function(pointer) {\n        this.sprayChunks.length = 0;\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._setShadow();\n        this.addSprayChunk(pointer);\n        this.render(this.sprayChunkPoints);\n    },\n    /**\n   * Invoked on mouse move\n   * @param {Object} pointer\n   */ onMouseMove: function(pointer) {\n        if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {\n            return;\n        }\n        this.addSprayChunk(pointer);\n        this.render(this.sprayChunkPoints);\n    },\n    /**\n   * Invoked on mouse up\n   */ onMouseUp: function() {\n        var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;\n        this.canvas.renderOnAddRemove = false;\n        var rects = [];\n        for(var i = 0, ilen = this.sprayChunks.length; i < ilen; i++){\n            var sprayChunk = this.sprayChunks[i];\n            for(var j = 0, jlen = sprayChunk.length; j < jlen; j++){\n                var rect = new fabric.Rect({\n                    width: sprayChunk[j].width,\n                    height: sprayChunk[j].width,\n                    left: sprayChunk[j].x + 1,\n                    top: sprayChunk[j].y + 1,\n                    originX: \"center\",\n                    originY: \"center\",\n                    fill: this.color\n                });\n                rects.push(rect);\n            }\n        }\n        if (this.optimizeOverlapping) {\n            rects = this._getOptimizedRects(rects);\n        }\n        var group = new fabric.Group(rects);\n        this.shadow && group.set(\"shadow\", new fabric.Shadow(this.shadow));\n        this.canvas.fire(\"before:path:created\", {\n            path: group\n        });\n        this.canvas.add(group);\n        this.canvas.fire(\"path:created\", {\n            path: group\n        });\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._resetShadow();\n        this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\n        this.canvas.requestRenderAll();\n    },\n    /**\n   * @private\n   * @param {Array} rects\n   */ _getOptimizedRects: function(rects) {\n        // avoid creating duplicate rects at the same coordinates\n        var uniqueRects = {}, key, i, len;\n        for(i = 0, len = rects.length; i < len; i++){\n            key = rects[i].left + \"\" + rects[i].top;\n            if (!uniqueRects[key]) {\n                uniqueRects[key] = rects[i];\n            }\n        }\n        var uniqueRectsArray = [];\n        for(key in uniqueRects){\n            uniqueRectsArray.push(uniqueRects[key]);\n        }\n        return uniqueRectsArray;\n    },\n    /**\n   * Render new chunk of spray brush\n   */ render: function(sprayChunk) {\n        var ctx = this.canvas.contextTop, i, len;\n        ctx.fillStyle = this.color;\n        this._saveAndTransform(ctx);\n        for(i = 0, len = sprayChunk.length; i < len; i++){\n            var point = sprayChunk[i];\n            if (typeof point.opacity !== \"undefined\") {\n                ctx.globalAlpha = point.opacity;\n            }\n            ctx.fillRect(point.x, point.y, point.width, point.width);\n        }\n        ctx.restore();\n    },\n    /**\n   * Render all spray chunks\n   */ _render: function() {\n        var ctx = this.canvas.contextTop, i, ilen;\n        ctx.fillStyle = this.color;\n        this._saveAndTransform(ctx);\n        for(i = 0, ilen = this.sprayChunks.length; i < ilen; i++){\n            this.render(this.sprayChunks[i]);\n        }\n        ctx.restore();\n    },\n    /**\n   * @param {Object} pointer\n   */ addSprayChunk: function(pointer) {\n        this.sprayChunkPoints = [];\n        var x, y, width, radius = this.width / 2, i;\n        for(i = 0; i < this.density; i++){\n            x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);\n            y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);\n            if (this.dotWidthVariance) {\n                width = fabric.util.getRandomInt(// bottom clamp width to 1\n                Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance);\n            } else {\n                width = this.dotWidth;\n            }\n            var point = new fabric.Point(x, y);\n            point.width = width;\n            if (this.randomOpacity) {\n                point.opacity = fabric.util.getRandomInt(0, 100) / 100;\n            }\n            this.sprayChunkPoints.push(point);\n        }\n        this.sprayChunks.push(this.sprayChunkPoints);\n    }\n});\n/**\n * PatternBrush class\n * @class fabric.PatternBrush\n * @extends fabric.BaseBrush\n */ fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {\n    getPatternSrc: function() {\n        var dotWidth = 20, dotDistance = 5, patternCanvas = fabric.util.createCanvasElement(), patternCtx = patternCanvas.getContext(\"2d\");\n        patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;\n        patternCtx.fillStyle = this.color;\n        patternCtx.beginPath();\n        patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);\n        patternCtx.closePath();\n        patternCtx.fill();\n        return patternCanvas;\n    },\n    getPatternSrcFunction: function() {\n        return String(this.getPatternSrc).replace(\"this.color\", '\"' + this.color + '\"');\n    },\n    /**\n   * Creates \"pattern\" instance property\n   * @param {CanvasRenderingContext2D} ctx\n   */ getPattern: function(ctx) {\n        return ctx.createPattern(this.source || this.getPatternSrc(), \"repeat\");\n    },\n    /**\n   * Sets brush styles\n   * @param {CanvasRenderingContext2D} ctx\n   */ _setBrushStyles: function(ctx) {\n        this.callSuper(\"_setBrushStyles\", ctx);\n        ctx.strokeStyle = this.getPattern(ctx);\n    },\n    /**\n   * Creates path\n   */ createPath: function(pathData) {\n        var path = this.callSuper(\"createPath\", pathData), topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);\n        path.stroke = new fabric.Pattern({\n            source: this.source || this.getPatternSrcFunction(),\n            offsetX: -topLeft.x,\n            offsetY: -topLeft.y\n        });\n        return path;\n    }\n});\n(function() {\n    var getPointer = fabric.util.getPointer, degreesToRadians = fabric.util.degreesToRadians, isTouchEvent = fabric.util.isTouchEvent;\n    /**\n   * Canvas class\n   * @class fabric.Canvas\n   * @extends fabric.StaticCanvas\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}\n   * @see {@link fabric.Canvas#initialize} for constructor definition\n   *\n   * @fires object:modified at the end of a transform or any change when statefull is true\n   * @fires object:rotating while an object is being rotated from the control\n   * @fires object:scaling while an object is being scaled by controls\n   * @fires object:moving while an object is being dragged\n   * @fires object:skewing while an object is being skewed from the controls\n   *\n   * @fires before:transform before a transform is is started\n   * @fires before:selection:cleared\n   * @fires selection:cleared\n   * @fires selection:updated\n   * @fires selection:created\n   *\n   * @fires path:created after a drawing operation ends and the path is added\n   * @fires mouse:down\n   * @fires mouse:move\n   * @fires mouse:up\n   * @fires mouse:down:before  on mouse down, before the inner fabric logic runs\n   * @fires mouse:move:before on mouse move, before the inner fabric logic runs\n   * @fires mouse:up:before on mouse up, before the inner fabric logic runs\n   * @fires mouse:over\n   * @fires mouse:out\n   * @fires mouse:dblclick whenever a native dbl click event fires on the canvas.\n   *\n   * @fires dragover\n   * @fires dragenter\n   * @fires dragleave\n   * @fires drop:before before drop event. same native event. This is added to handle edge cases\n   * @fires drop\n   * @fires after:render at the end of the render process, receives the context in the callback\n   * @fires before:render at start the render process, receives the context in the callback\n   *\n   */ fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {\n        /**\n     * Constructor\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(el, options) {\n            options || (options = {});\n            this.renderAndResetBound = this.renderAndReset.bind(this);\n            this.requestRenderAllBound = this.requestRenderAll.bind(this);\n            this._initStatic(el, options);\n            this._initInteractive();\n            this._createCacheCanvas();\n        },\n        /**\n     * When true, objects can be transformed by one side (unproportionally)\n     * when dragged on the corners that normally would not do that.\n     * @type Boolean\n     * @default\n     * @since fabric 4.0 // changed name and default value\n     */ uniformScaling: true,\n        /**\n     * Indicates which key switches uniform scaling.\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled.\n     * totally wrong named. this sounds like `uniform scaling`\n     * if Canvas.uniformScaling is true, pressing this will set it to false\n     * and viceversa.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ uniScaleKey: \"shiftKey\",\n        /**\n     * When true, objects use center point as the origin of scale transformation.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredScaling: false,\n        /**\n     * When true, objects use center point as the origin of rotate transformation.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredRotation: false,\n        /**\n     * Indicates which key enable centered Transform\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled feature disabled.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ centeredKey: \"altKey\",\n        /**\n     * Indicates which key enable alternate action on corner\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled feature disabled.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ altActionKey: \"shiftKey\",\n        /**\n     * Indicates that canvas is interactive. This property should not be changed.\n     * @type Boolean\n     * @default\n     */ interactive: true,\n        /**\n     * Indicates whether group selection should be enabled\n     * @type Boolean\n     * @default\n     */ selection: true,\n        /**\n     * Indicates which key or keys enable multiple click selection\n     * Pass value as a string or array of strings\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or empty or containing any other string that is not a modifier key\n     * feature is disabled.\n     * @since 1.6.2\n     * @type String|Array\n     * @default\n     */ selectionKey: \"shiftKey\",\n        /**\n     * Indicates which key enable alternative selection\n     * in case of target overlapping with active object\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * For a series of reason that come from the general expectations on how\n     * things should work, this feature works only for preserveObjectStacking true.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled.\n     * @since 1.6.5\n     * @type null|String\n     * @default\n     */ altSelectionKey: null,\n        /**\n     * Color of selection\n     * @type String\n     * @default\n     */ selectionColor: \"rgba(100, 100, 255, 0.3)\",\n        /**\n     * Default dash array pattern\n     * If not empty the selection border is dashed\n     * @type Array\n     */ selectionDashArray: [],\n        /**\n     * Color of the border of selection (usually slightly darker than color of selection itself)\n     * @type String\n     * @default\n     */ selectionBorderColor: \"rgba(255, 255, 255, 0.3)\",\n        /**\n     * Width of a line used in object/group selection\n     * @type Number\n     * @default\n     */ selectionLineWidth: 1,\n        /**\n     * Select only shapes that are fully contained in the dragged selection rectangle.\n     * @type Boolean\n     * @default\n     */ selectionFullyContained: false,\n        /**\n     * Default cursor value used when hovering over an object on canvas\n     * @type String\n     * @default\n     */ hoverCursor: \"move\",\n        /**\n     * Default cursor value used when moving an object on canvas\n     * @type String\n     * @default\n     */ moveCursor: \"move\",\n        /**\n     * Default cursor value used for the entire canvas\n     * @type String\n     * @default\n     */ defaultCursor: \"default\",\n        /**\n     * Cursor value used during free drawing\n     * @type String\n     * @default\n     */ freeDrawingCursor: \"crosshair\",\n        /**\n     * Cursor value used for disabled elements ( corners with disabled action )\n     * @type String\n     * @since 2.0.0\n     * @default\n     */ notAllowedCursor: \"not-allowed\",\n        /**\n     * Default element class that's given to wrapper (div) element of canvas\n     * @type String\n     * @default\n     */ containerClass: \"canvas-container\",\n        /**\n     * When true, object detection happens on per-pixel basis rather than on per-bounding-box\n     * @type Boolean\n     * @default\n     */ perPixelTargetFind: false,\n        /**\n     * Number of pixels around target pixel to tolerate (consider active) during object detection\n     * @type Number\n     * @default\n     */ targetFindTolerance: 0,\n        /**\n     * When true, target detection is skipped. Target detection will return always undefined.\n     * click selection won't work anymore, events will fire with no targets.\n     * if something is selected before setting it to true, it will be deselected at the first click.\n     * area selection will still work. check the `selection` property too.\n     * if you deactivate both, you should look into staticCanvas.\n     * @type Boolean\n     * @default\n     */ skipTargetFind: false,\n        /**\n     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.\n     * After mousedown, mousemove creates a shape,\n     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}\n     * @type Boolean\n     * @default\n     */ isDrawingMode: false,\n        /**\n     * Indicates whether objects should remain in current stack position when selected.\n     * When false objects are brought to top and rendered as part of the selection group\n     * @type Boolean\n     * @default\n     */ preserveObjectStacking: false,\n        /**\n     * Indicates the angle that an object will lock to while rotating.\n     * @type Number\n     * @since 1.6.7\n     * @default\n     */ snapAngle: 0,\n        /**\n     * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.\n     * When `null`, the snapThreshold will default to the snapAngle.\n     * @type null|Number\n     * @since 1.6.7\n     * @default\n     */ snapThreshold: null,\n        /**\n     * Indicates if the right click on canvas can output the context menu or not\n     * @type Boolean\n     * @since 1.6.5\n     * @default\n     */ stopContextMenu: false,\n        /**\n     * Indicates if the canvas can fire right click events\n     * @type Boolean\n     * @since 1.6.5\n     * @default\n     */ fireRightClick: false,\n        /**\n     * Indicates if the canvas can fire middle click events\n     * @type Boolean\n     * @since 1.7.8\n     * @default\n     */ fireMiddleClick: false,\n        /**\n     * Keep track of the subTargets for Mouse Events\n     * @type fabric.Object[]\n     */ targets: [],\n        /**\n     * When the option is enabled, PointerEvent is used instead of MouseEvent.\n     * @type Boolean\n     * @default\n     */ enablePointerEvents: false,\n        /**\n     * Keep track of the hovered target\n     * @type fabric.Object\n     * @private\n     */ _hoveredTarget: null,\n        /**\n     * hold the list of nested targets hovered\n     * @type fabric.Object[]\n     * @private\n     */ _hoveredTargets: [],\n        /**\n     * @private\n     */ _initInteractive: function() {\n            this._currentTransform = null;\n            this._groupSelector = null;\n            this._initWrapperElement();\n            this._createUpperCanvas();\n            this._initEventListeners();\n            this._initRetinaScaling();\n            this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);\n            this.calcOffset();\n        },\n        /**\n     * Divides objects in two groups, one to render immediately\n     * and one to render as activeGroup.\n     * @return {Array} objects to render immediately and pushes the other in the activeGroup.\n     */ _chooseObjectsToRender: function() {\n            var activeObjects = this.getActiveObjects(), object, objsToRender, activeGroupObjects;\n            if (activeObjects.length > 0 && !this.preserveObjectStacking) {\n                objsToRender = [];\n                activeGroupObjects = [];\n                for(var i = 0, length = this._objects.length; i < length; i++){\n                    object = this._objects[i];\n                    if (activeObjects.indexOf(object) === -1) {\n                        objsToRender.push(object);\n                    } else {\n                        activeGroupObjects.push(object);\n                    }\n                }\n                if (activeObjects.length > 1) {\n                    this._activeObject._objects = activeGroupObjects;\n                }\n                objsToRender.push.apply(objsToRender, activeGroupObjects);\n            } else {\n                objsToRender = this._objects;\n            }\n            return objsToRender;\n        },\n        /**\n     * Renders both the top canvas and the secondary container canvas.\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderAll: function() {\n            if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {\n                this.clearContext(this.contextTop);\n                this.contextTopDirty = false;\n            }\n            if (this.hasLostContext) {\n                this.renderTopLayer(this.contextTop);\n                this.hasLostContext = false;\n            }\n            var canvasToDrawOn = this.contextContainer;\n            this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());\n            return this;\n        },\n        renderTopLayer: function(ctx) {\n            ctx.save();\n            if (this.isDrawingMode && this._isCurrentlyDrawing) {\n                this.freeDrawingBrush && this.freeDrawingBrush._render();\n                this.contextTopDirty = true;\n            }\n            // we render the top context - last object\n            if (this.selection && this._groupSelector) {\n                this._drawSelection(ctx);\n                this.contextTopDirty = true;\n            }\n            ctx.restore();\n        },\n        /**\n     * Method to render only the top canvas.\n     * Also used to render the group selection box.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ renderTop: function() {\n            var ctx = this.contextTop;\n            this.clearContext(ctx);\n            this.renderTopLayer(ctx);\n            this.fire(\"after:render\");\n            return this;\n        },\n        /**\n     * @private\n     */ _normalizePointer: function(object, pointer) {\n            var m = object.calcTransformMatrix(), invertedM = fabric.util.invertTransform(m), vptPointer = this.restorePointerVpt(pointer);\n            return fabric.util.transformPoint(vptPointer, invertedM);\n        },\n        /**\n     * Returns true if object is transparent at a certain location\n     * @param {fabric.Object} target Object to check\n     * @param {Number} x Left coordinate\n     * @param {Number} y Top coordinate\n     * @return {Boolean}\n     */ isTargetTransparent: function(target, x, y) {\n            // in case the target is the activeObject, we cannot execute this optimization\n            // because we need to draw controls too.\n            if (target.shouldCache() && target._cacheCanvas && target !== this._activeObject) {\n                var normalizedPointer = this._normalizePointer(target, {\n                    x: x,\n                    y: y\n                }), targetRelativeX = Math.max(target.cacheTranslationX + normalizedPointer.x * target.zoomX, 0), targetRelativeY = Math.max(target.cacheTranslationY + normalizedPointer.y * target.zoomY, 0);\n                var isTransparent = fabric.util.isTransparent(target._cacheContext, Math.round(targetRelativeX), Math.round(targetRelativeY), this.targetFindTolerance);\n                return isTransparent;\n            }\n            var ctx = this.contextCache, originalColor = target.selectionBackgroundColor, v = this.viewportTransform;\n            target.selectionBackgroundColor = \"\";\n            this.clearContext(ctx);\n            ctx.save();\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            target.render(ctx);\n            ctx.restore();\n            target.selectionBackgroundColor = originalColor;\n            var isTransparent = fabric.util.isTransparent(ctx, x, y, this.targetFindTolerance);\n            return isTransparent;\n        },\n        /**\n     * takes an event and determines if selection key has been pressed\n     * @private\n     * @param {Event} e Event object\n     */ _isSelectionKeyPressed: function(e) {\n            var selectionKeyPressed = false;\n            if (Array.isArray(this.selectionKey)) {\n                selectionKeyPressed = !!this.selectionKey.find(function(key) {\n                    return e[key] === true;\n                });\n            } else {\n                selectionKeyPressed = e[this.selectionKey];\n            }\n            return selectionKeyPressed;\n        },\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */ _shouldClearSelection: function(e, target) {\n            var activeObjects = this.getActiveObjects(), activeObject = this._activeObject;\n            return !target || target && activeObject && activeObjects.length > 1 && activeObjects.indexOf(target) === -1 && activeObject !== target && !this._isSelectionKeyPressed(e) || target && !target.evented || target && !target.selectable && activeObject && activeObject !== target;\n        },\n        /**\n     * centeredScaling from object can't override centeredScaling from canvas.\n     * this should be fixed, since object setting should take precedence over canvas.\n     * also this should be something that will be migrated in the control properties.\n     * as ability to define the origin of the transformation that the control provide.\n     * @private\n     * @param {fabric.Object} target\n     * @param {String} action\n     * @param {Boolean} altKey\n     */ _shouldCenterTransform: function(target, action, altKey) {\n            if (!target) {\n                return;\n            }\n            var centerTransform;\n            if (action === \"scale\" || action === \"scaleX\" || action === \"scaleY\" || action === \"resizing\") {\n                centerTransform = this.centeredScaling || target.centeredScaling;\n            } else if (action === \"rotate\") {\n                centerTransform = this.centeredRotation || target.centeredRotation;\n            }\n            return centerTransform ? !altKey : altKey;\n        },\n        /**\n     * should disappear before release 4.0\n     * @private\n     */ _getOriginFromCorner: function(target, corner) {\n            var origin = {\n                x: target.originX,\n                y: target.originY\n            };\n            if (corner === \"ml\" || corner === \"tl\" || corner === \"bl\") {\n                origin.x = \"right\";\n            } else if (corner === \"mr\" || corner === \"tr\" || corner === \"br\") {\n                origin.x = \"left\";\n            }\n            if (corner === \"tl\" || corner === \"mt\" || corner === \"tr\") {\n                origin.y = \"bottom\";\n            } else if (corner === \"bl\" || corner === \"mb\" || corner === \"br\") {\n                origin.y = \"top\";\n            }\n            return origin;\n        },\n        /**\n     * @private\n     * @param {Boolean} alreadySelected true if target is already selected\n     * @param {String} corner a string representing the corner ml, mr, tl ...\n     * @param {Event} e Event object\n     * @param {fabric.Object} [target] inserted back to help overriding. Unused\n     */ _getActionFromCorner: function(alreadySelected, corner, e, target) {\n            if (!corner || !alreadySelected) {\n                return \"drag\";\n            }\n            var control = target.controls[corner];\n            return control.getActionName(e, control, target);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */ _setupCurrentTransform: function(e, target, alreadySelected) {\n            if (!target) {\n                return;\n            }\n            var pointer = this.getPointer(e), corner = target.__corner, control = target.controls[corner], actionHandler = alreadySelected && corner ? control.getActionHandler(e, target, control) : fabric.controlsUtils.dragHandler, action = this._getActionFromCorner(alreadySelected, corner, e, target), origin = this._getOriginFromCorner(target, corner), altKey = e[this.centeredKey], transform = {\n                target: target,\n                action: action,\n                actionHandler: actionHandler,\n                corner: corner,\n                scaleX: target.scaleX,\n                scaleY: target.scaleY,\n                skewX: target.skewX,\n                skewY: target.skewY,\n                // used by transation\n                offsetX: pointer.x - target.left,\n                offsetY: pointer.y - target.top,\n                originX: origin.x,\n                originY: origin.y,\n                ex: pointer.x,\n                ey: pointer.y,\n                lastX: pointer.x,\n                lastY: pointer.y,\n                // unsure they are useful anymore.\n                // left: target.left,\n                // top: target.top,\n                theta: degreesToRadians(target.angle),\n                // end of unsure\n                width: target.width * target.scaleX,\n                shiftKey: e.shiftKey,\n                altKey: altKey,\n                original: fabric.util.saveObjectTransform(target)\n            };\n            if (this._shouldCenterTransform(target, action, altKey)) {\n                transform.originX = \"center\";\n                transform.originY = \"center\";\n            }\n            transform.original.originX = origin.x;\n            transform.original.originY = origin.y;\n            this._currentTransform = transform;\n            this._beforeTransform(e);\n        },\n        /**\n     * Set the cursor type of the canvas element\n     * @param {String} value Cursor type of the canvas element.\n     * @see http://www.w3.org/TR/css3-ui/#cursor\n     */ setCursor: function(value) {\n            this.upperCanvasEl.style.cursor = value;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx to draw the selection on\n     */ _drawSelection: function(ctx) {\n            var selector = this._groupSelector, viewportStart = new fabric.Point(selector.ex, selector.ey), start = fabric.util.transformPoint(viewportStart, this.viewportTransform), viewportExtent = new fabric.Point(selector.ex + selector.left, selector.ey + selector.top), extent = fabric.util.transformPoint(viewportExtent, this.viewportTransform), minX = Math.min(start.x, extent.x), minY = Math.min(start.y, extent.y), maxX = Math.max(start.x, extent.x), maxY = Math.max(start.y, extent.y), strokeOffset = this.selectionLineWidth / 2;\n            if (this.selectionColor) {\n                ctx.fillStyle = this.selectionColor;\n                ctx.fillRect(minX, minY, maxX - minX, maxY - minY);\n            }\n            if (!this.selectionLineWidth || !this.selectionBorderColor) {\n                return;\n            }\n            ctx.lineWidth = this.selectionLineWidth;\n            ctx.strokeStyle = this.selectionBorderColor;\n            minX += strokeOffset;\n            minY += strokeOffset;\n            maxX -= strokeOffset;\n            maxY -= strokeOffset;\n            // selection border\n            fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);\n            ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);\n        },\n        /**\n     * Method that determines what object we are clicking on\n     * the skipGroup parameter is for internal use, is needed for shift+click action\n     * 11/09/2018 TODO: would be cool if findTarget could discern between being a full target\n     * or the outside part of the corner.\n     * @param {Event} e mouse event\n     * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through\n     * @return {fabric.Object} the target found\n     */ findTarget: function(e, skipGroup) {\n            if (this.skipTargetFind) {\n                return;\n            }\n            var ignoreZoom = true, pointer = this.getPointer(e, ignoreZoom), activeObject = this._activeObject, aObjects = this.getActiveObjects(), activeTarget, activeTargetSubs, isTouch = isTouchEvent(e), shouldLookForActive = aObjects.length > 1 && !skipGroup || aObjects.length === 1;\n            // first check current group (if one exists)\n            // active group does not check sub targets like normal groups.\n            // if active group just exits.\n            this.targets = [];\n            // if we hit the corner of an activeObject, let's return that.\n            if (shouldLookForActive && activeObject._findTargetCorner(pointer, isTouch)) {\n                return activeObject;\n            }\n            if (aObjects.length > 1 && !skipGroup && activeObject === this._searchPossibleTargets([\n                activeObject\n            ], pointer)) {\n                return activeObject;\n            }\n            if (aObjects.length === 1 && activeObject === this._searchPossibleTargets([\n                activeObject\n            ], pointer)) {\n                if (!this.preserveObjectStacking) {\n                    return activeObject;\n                } else {\n                    activeTarget = activeObject;\n                    activeTargetSubs = this.targets;\n                    this.targets = [];\n                }\n            }\n            var target = this._searchPossibleTargets(this._objects, pointer);\n            if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {\n                target = activeTarget;\n                this.targets = activeTargetSubs;\n            }\n            return target;\n        },\n        /**\n     * Checks point is inside the object.\n     * @param {Object} [pointer] x,y object of point coordinates we want to check.\n     * @param {fabric.Object} obj Object to test against\n     * @param {Object} [globalPointer] x,y object of point coordinates relative to canvas used to search per pixel target.\n     * @return {Boolean} true if point is contained within an area of given object\n     * @private\n     */ _checkTarget: function(pointer, obj, globalPointer) {\n            if (obj && obj.visible && obj.evented && // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html\n            // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html\n            obj.containsPoint(pointer)) {\n                if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {\n                    var isTransparent = this.isTargetTransparent(obj, globalPointer.x, globalPointer.y);\n                    if (!isTransparent) {\n                        return true;\n                    }\n                } else {\n                    return true;\n                }\n            }\n        },\n        /**\n     * Function used to search inside objects an object that contains pointer in bounding box or that contains pointerOnCanvas when painted\n     * @param {Array} [objects] objects array to look into\n     * @param {Object} [pointer] x,y object of point coordinates we want to check.\n     * @return {fabric.Object} object that contains pointer\n     * @private\n     */ _searchPossibleTargets: function(objects, pointer) {\n            // Cache all targets where their bounding box contains point.\n            var target, i = objects.length, subTarget;\n            // Do not check for currently grouped objects, since we check the parent group itself.\n            // until we call this function specifically to search inside the activeGroup\n            while(i--){\n                var objToCheck = objects[i];\n                var pointerToUse = objToCheck.group ? this._normalizePointer(objToCheck.group, pointer) : pointer;\n                if (this._checkTarget(pointerToUse, objToCheck, pointer)) {\n                    target = objects[i];\n                    if (target.subTargetCheck && target instanceof fabric.Group) {\n                        subTarget = this._searchPossibleTargets(target._objects, pointer);\n                        subTarget && this.targets.push(subTarget);\n                    }\n                    break;\n                }\n            }\n            return target;\n        },\n        /**\n     * Returns pointer coordinates without the effect of the viewport\n     * @param {Object} pointer with \"x\" and \"y\" number values\n     * @return {Object} object with \"x\" and \"y\" number values\n     */ restorePointerVpt: function(pointer) {\n            return fabric.util.transformPoint(pointer, fabric.util.invertTransform(this.viewportTransform));\n        },\n        /**\n     * Returns pointer coordinates relative to canvas.\n     * Can return coordinates with or without viewportTransform.\n     * ignoreZoom false gives back coordinates that represent\n     * the point clicked on canvas element.\n     * ignoreZoom true gives back coordinates after being processed\n     * by the viewportTransform ( sort of coordinates of what is displayed\n     * on the canvas where you are clicking.\n     * ignoreZoom true = HTMLElement coordinates relative to top,left\n     * ignoreZoom false, default = fabric space coordinates, the same used for shape position\n     * To interact with your shapes top and left you want to use ignoreZoom true\n     * most of the time, while ignoreZoom false will give you coordinates\n     * compatible with the object.oCoords system.\n     * of the time.\n     * @param {Event} e\n     * @param {Boolean} ignoreZoom\n     * @return {Object} object with \"x\" and \"y\" number values\n     */ getPointer: function(e, ignoreZoom) {\n            // return cached values if we are in the event processing chain\n            if (this._absolutePointer && !ignoreZoom) {\n                return this._absolutePointer;\n            }\n            if (this._pointer && ignoreZoom) {\n                return this._pointer;\n            }\n            var pointer = getPointer(e), upperCanvasEl = this.upperCanvasEl, bounds = upperCanvasEl.getBoundingClientRect(), boundsWidth = bounds.width || 0, boundsHeight = bounds.height || 0, cssScale;\n            if (!boundsWidth || !boundsHeight) {\n                if (\"top\" in bounds && \"bottom\" in bounds) {\n                    boundsHeight = Math.abs(bounds.top - bounds.bottom);\n                }\n                if (\"right\" in bounds && \"left\" in bounds) {\n                    boundsWidth = Math.abs(bounds.right - bounds.left);\n                }\n            }\n            this.calcOffset();\n            pointer.x = pointer.x - this._offset.left;\n            pointer.y = pointer.y - this._offset.top;\n            if (!ignoreZoom) {\n                pointer = this.restorePointerVpt(pointer);\n            }\n            var retinaScaling = this.getRetinaScaling();\n            if (retinaScaling !== 1) {\n                pointer.x /= retinaScaling;\n                pointer.y /= retinaScaling;\n            }\n            if (boundsWidth === 0 || boundsHeight === 0) {\n                // If bounds are not available (i.e. not visible), do not apply scale.\n                cssScale = {\n                    width: 1,\n                    height: 1\n                };\n            } else {\n                cssScale = {\n                    width: upperCanvasEl.width / boundsWidth,\n                    height: upperCanvasEl.height / boundsHeight\n                };\n            }\n            return {\n                x: pointer.x * cssScale.width,\n                y: pointer.y * cssScale.height\n            };\n        },\n        /**\n     * @private\n     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized\n     */ _createUpperCanvas: function() {\n            var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\\s*lower-canvas\\s*/, \"\"), lowerCanvasEl = this.lowerCanvasEl, upperCanvasEl = this.upperCanvasEl;\n            // there is no need to create a new upperCanvas element if we have already one.\n            if (upperCanvasEl) {\n                upperCanvasEl.className = \"\";\n            } else {\n                upperCanvasEl = this._createCanvasElement();\n                this.upperCanvasEl = upperCanvasEl;\n            }\n            fabric.util.addClass(upperCanvasEl, \"upper-canvas \" + lowerCanvasClass);\n            this.wrapperEl.appendChild(upperCanvasEl);\n            this._copyCanvasStyle(lowerCanvasEl, upperCanvasEl);\n            this._applyCanvasStyle(upperCanvasEl);\n            this.contextTop = upperCanvasEl.getContext(\"2d\");\n        },\n        /**\n     * Returns context of top canvas where interactions are drawn\n     * @returns {CanvasRenderingContext2D}\n     */ getTopContext: function() {\n            return this.contextTop;\n        },\n        /**\n     * @private\n     */ _createCacheCanvas: function() {\n            this.cacheCanvasEl = this._createCanvasElement();\n            this.cacheCanvasEl.setAttribute(\"width\", this.width);\n            this.cacheCanvasEl.setAttribute(\"height\", this.height);\n            this.contextCache = this.cacheCanvasEl.getContext(\"2d\");\n        },\n        /**\n     * @private\n     */ _initWrapperElement: function() {\n            this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, \"div\", {\n                \"class\": this.containerClass\n            });\n            fabric.util.setStyle(this.wrapperEl, {\n                width: this.width + \"px\",\n                height: this.height + \"px\",\n                position: \"relative\"\n            });\n            fabric.util.makeElementUnselectable(this.wrapperEl);\n        },\n        /**\n     * @private\n     * @param {HTMLElement} element canvas element to apply styles on\n     */ _applyCanvasStyle: function(element) {\n            var width = this.width || element.width, height = this.height || element.height;\n            fabric.util.setStyle(element, {\n                position: \"absolute\",\n                width: width + \"px\",\n                height: height + \"px\",\n                left: 0,\n                top: 0,\n                \"touch-action\": this.allowTouchScrolling ? \"manipulation\" : \"none\",\n                \"-ms-touch-action\": this.allowTouchScrolling ? \"manipulation\" : \"none\"\n            });\n            element.width = width;\n            element.height = height;\n            fabric.util.makeElementUnselectable(element);\n        },\n        /**\n     * Copy the entire inline style from one element (fromEl) to another (toEl)\n     * @private\n     * @param {Element} fromEl Element style is copied from\n     * @param {Element} toEl Element copied style is applied to\n     */ _copyCanvasStyle: function(fromEl, toEl) {\n            toEl.style.cssText = fromEl.style.cssText;\n        },\n        /**\n     * Returns context of canvas where object selection is drawn\n     * @return {CanvasRenderingContext2D}\n     */ getSelectionContext: function() {\n            return this.contextTop;\n        },\n        /**\n     * Returns &lt;canvas> element on which object selection is drawn\n     * @return {HTMLCanvasElement}\n     */ getSelectionElement: function() {\n            return this.upperCanvasEl;\n        },\n        /**\n     * Returns currently active object\n     * @return {fabric.Object} active object\n     */ getActiveObject: function() {\n            return this._activeObject;\n        },\n        /**\n     * Returns an array with the current selected objects\n     * @return {fabric.Object} active object\n     */ getActiveObjects: function() {\n            var active = this._activeObject;\n            if (active) {\n                if (active.type === \"activeSelection\" && active._objects) {\n                    return active._objects.slice(0);\n                } else {\n                    return [\n                        active\n                    ];\n                }\n            }\n            return [];\n        },\n        /**\n     * @private\n     * @param {fabric.Object} obj Object that was removed\n     */ _onObjectRemoved: function(obj) {\n            // removing active object should fire \"selection:cleared\" events\n            if (obj === this._activeObject) {\n                this.fire(\"before:selection:cleared\", {\n                    target: obj\n                });\n                this._discardActiveObject();\n                this.fire(\"selection:cleared\", {\n                    target: obj\n                });\n                obj.fire(\"deselected\");\n            }\n            if (obj === this._hoveredTarget) {\n                this._hoveredTarget = null;\n                this._hoveredTargets = [];\n            }\n            this.callSuper(\"_onObjectRemoved\", obj);\n        },\n        /**\n     * @private\n     * Compares the old activeObject with the current one and fires correct events\n     * @param {fabric.Object} obj old activeObject\n     */ _fireSelectionEvents: function(oldObjects, e) {\n            var somethingChanged = false, objects = this.getActiveObjects(), added = [], removed = [];\n            oldObjects.forEach(function(oldObject) {\n                if (objects.indexOf(oldObject) === -1) {\n                    somethingChanged = true;\n                    oldObject.fire(\"deselected\", {\n                        e: e,\n                        target: oldObject\n                    });\n                    removed.push(oldObject);\n                }\n            });\n            objects.forEach(function(object) {\n                if (oldObjects.indexOf(object) === -1) {\n                    somethingChanged = true;\n                    object.fire(\"selected\", {\n                        e: e,\n                        target: object\n                    });\n                    added.push(object);\n                }\n            });\n            if (oldObjects.length > 0 && objects.length > 0) {\n                somethingChanged && this.fire(\"selection:updated\", {\n                    e: e,\n                    selected: added,\n                    deselected: removed\n                });\n            } else if (objects.length > 0) {\n                this.fire(\"selection:created\", {\n                    e: e,\n                    selected: added\n                });\n            } else if (oldObjects.length > 0) {\n                this.fire(\"selection:cleared\", {\n                    e: e,\n                    deselected: removed\n                });\n            }\n        },\n        /**\n     * Sets given object as the only active object on canvas\n     * @param {fabric.Object} object Object to set as an active one\n     * @param {Event} [e] Event (passed along when firing \"object:selected\")\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ setActiveObject: function(object, e) {\n            var currentActives = this.getActiveObjects();\n            this._setActiveObject(object, e);\n            this._fireSelectionEvents(currentActives, e);\n            return this;\n        },\n        /**\n     * This is a private method for now.\n     * This is supposed to be equivalent to setActiveObject but without firing\n     * any event. There is commitment to have this stay this way.\n     * This is the functional part of setActiveObject.\n     * @private\n     * @param {Object} object to set as active\n     * @param {Event} [e] Event (passed along when firing \"object:selected\")\n     * @return {Boolean} true if the selection happened\n     */ _setActiveObject: function(object, e) {\n            if (this._activeObject === object) {\n                return false;\n            }\n            if (!this._discardActiveObject(e, object)) {\n                return false;\n            }\n            if (object.onSelect({\n                e: e\n            })) {\n                return false;\n            }\n            this._activeObject = object;\n            return true;\n        },\n        /**\n     * This is a private method for now.\n     * This is supposed to be equivalent to discardActiveObject but without firing\n     * any events. There is commitment to have this stay this way.\n     * This is the functional part of discardActiveObject.\n     * @param {Event} [e] Event (passed along when firing \"object:deselected\")\n     * @param {Object} object to set as active\n     * @return {Boolean} true if the selection happened\n     * @private\n     */ _discardActiveObject: function(e, object) {\n            var obj = this._activeObject;\n            if (obj) {\n                // onDeselect return TRUE to cancel selection;\n                if (obj.onDeselect({\n                    e: e,\n                    object: object\n                })) {\n                    return false;\n                }\n                this._activeObject = null;\n            }\n            return true;\n        },\n        /**\n     * Discards currently active object and fire events. If the function is called by fabric\n     * as a consequence of a mouse event, the event is passed as a parameter and\n     * sent to the fire function for the custom events. When used as a method the\n     * e param does not have any application.\n     * @param {event} e\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ discardActiveObject: function(e) {\n            var currentActives = this.getActiveObjects(), activeObject = this.getActiveObject();\n            if (currentActives.length) {\n                this.fire(\"before:selection:cleared\", {\n                    target: activeObject,\n                    e: e\n                });\n            }\n            this._discardActiveObject(e);\n            this._fireSelectionEvents(currentActives, e);\n            return this;\n        },\n        /**\n     * Clears a canvas element and removes all event listeners\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ dispose: function() {\n            var wrapper = this.wrapperEl;\n            this.removeListeners();\n            wrapper.removeChild(this.upperCanvasEl);\n            wrapper.removeChild(this.lowerCanvasEl);\n            this.contextCache = null;\n            this.contextTop = null;\n            [\n                \"upperCanvasEl\",\n                \"cacheCanvasEl\"\n            ].forEach((function(element) {\n                fabric.util.cleanUpJsdomNode(this[element]);\n                this[element] = undefined;\n            }).bind(this));\n            if (wrapper.parentNode) {\n                wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);\n            }\n            delete this.wrapperEl;\n            fabric.StaticCanvas.prototype.dispose.call(this);\n            return this;\n        },\n        /**\n     * Clears all contexts (background, main, top) of an instance\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ clear: function() {\n            // this.discardActiveGroup();\n            this.discardActiveObject();\n            this.clearContext(this.contextTop);\n            return this.callSuper(\"clear\");\n        },\n        /**\n     * Draws objects' controls (borders/controls)\n     * @param {CanvasRenderingContext2D} ctx Context to render controls on\n     */ drawControls: function(ctx) {\n            var activeObject = this._activeObject;\n            if (activeObject) {\n                activeObject._renderControls(ctx);\n            }\n        },\n        /**\n     * @private\n     */ _toObject: function(instance, methodName, propertiesToInclude) {\n            //If the object is part of the current selection group, it should\n            //be transformed appropriately\n            //i.e. it should be serialised as it would appear if the selection group\n            //were to be destroyed.\n            var originalProperties = this._realizeGroupTransformOnObject(instance), object = this.callSuper(\"_toObject\", instance, methodName, propertiesToInclude);\n            //Undo the damage we did by changing all of its properties\n            this._unwindGroupTransformOnObject(instance, originalProperties);\n            return object;\n        },\n        /**\n     * Realises an object's group transformation on it\n     * @private\n     * @param {fabric.Object} [instance] the object to transform (gets mutated)\n     * @returns the original values of instance which were changed\n     */ _realizeGroupTransformOnObject: function(instance) {\n            if (instance.group && instance.group.type === \"activeSelection\" && this._activeObject === instance.group) {\n                var layoutProps = [\n                    \"angle\",\n                    \"flipX\",\n                    \"flipY\",\n                    \"left\",\n                    \"scaleX\",\n                    \"scaleY\",\n                    \"skewX\",\n                    \"skewY\",\n                    \"top\"\n                ];\n                //Copy all the positionally relevant properties across now\n                var originalValues = {};\n                layoutProps.forEach(function(prop) {\n                    originalValues[prop] = instance[prop];\n                });\n                fabric.util.addTransformToObject(instance, this._activeObject.calcOwnMatrix());\n                return originalValues;\n            } else {\n                return null;\n            }\n        },\n        /**\n     * Restores the changed properties of instance\n     * @private\n     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)\n     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject\n     */ _unwindGroupTransformOnObject: function(instance, originalValues) {\n            if (originalValues) {\n                instance.set(originalValues);\n            }\n        },\n        /**\n     * @private\n     */ _setSVGObject: function(markup, instance, reviver) {\n            //If the object is in a selection group, simulate what would happen to that\n            //object when the group is deselected\n            var originalProperties = this._realizeGroupTransformOnObject(instance);\n            this.callSuper(\"_setSVGObject\", markup, instance, reviver);\n            this._unwindGroupTransformOnObject(instance, originalProperties);\n        },\n        setViewportTransform: function(vpt) {\n            if (this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing) {\n                this._activeObject.clearContextTop();\n            }\n            fabric.StaticCanvas.prototype.setViewportTransform.call(this, vpt);\n        }\n    });\n    // copying static properties manually to work around Opera's bug,\n    // where \"prototype\" property is enumerable and overrides existing prototype\n    for(var prop in fabric.StaticCanvas){\n        if (prop !== \"prototype\") {\n            fabric.Canvas[prop] = fabric.StaticCanvas[prop];\n        }\n    }\n})();\n(function() {\n    var addListener = fabric.util.addListener, removeListener = fabric.util.removeListener, RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1, addEventOptions = {\n        passive: false\n    };\n    function checkClick(e, value) {\n        return e.button && e.button === value - 1;\n    }\n    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\n        /**\n     * Contains the id of the touch event that owns the fabric transform\n     * @type Number\n     * @private\n     */ mainTouchId: null,\n        /**\n     * Adds mouse listeners to canvas\n     * @private\n     */ _initEventListeners: function() {\n            // in case we initialized the class twice. This should not happen normally\n            // but in some kind of applications where the canvas element may be changed\n            // this is a workaround to having double listeners.\n            this.removeListeners();\n            this._bindEvents();\n            this.addOrRemove(addListener, \"add\");\n        },\n        /**\n     * return an event prefix pointer or mouse.\n     * @private\n     */ _getEventPrefix: function() {\n            return this.enablePointerEvents ? \"pointer\" : \"mouse\";\n        },\n        addOrRemove: function(functor, eventjsFunctor) {\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            functor(fabric.window, \"resize\", this._onResize);\n            functor(canvasElement, eventTypePrefix + \"down\", this._onMouseDown);\n            functor(canvasElement, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            functor(canvasElement, eventTypePrefix + \"out\", this._onMouseOut);\n            functor(canvasElement, eventTypePrefix + \"enter\", this._onMouseEnter);\n            functor(canvasElement, \"wheel\", this._onMouseWheel);\n            functor(canvasElement, \"contextmenu\", this._onContextMenu);\n            functor(canvasElement, \"dblclick\", this._onDoubleClick);\n            functor(canvasElement, \"dragover\", this._onDragOver);\n            functor(canvasElement, \"dragenter\", this._onDragEnter);\n            functor(canvasElement, \"dragleave\", this._onDragLeave);\n            functor(canvasElement, \"drop\", this._onDrop);\n            if (!this.enablePointerEvents) {\n                functor(canvasElement, \"touchstart\", this._onTouchStart, addEventOptions);\n            }\n            if (typeof eventjs !== \"undefined\" && eventjsFunctor in eventjs) {\n                eventjs[eventjsFunctor](canvasElement, \"gesture\", this._onGesture);\n                eventjs[eventjsFunctor](canvasElement, \"drag\", this._onDrag);\n                eventjs[eventjsFunctor](canvasElement, \"orientation\", this._onOrientationChange);\n                eventjs[eventjsFunctor](canvasElement, \"shake\", this._onShake);\n                eventjs[eventjsFunctor](canvasElement, \"longpress\", this._onLongPress);\n            }\n        },\n        /**\n     * Removes all event listeners\n     */ removeListeners: function() {\n            this.addOrRemove(removeListener, \"remove\");\n            // if you dispose on a mouseDown, before mouse up, you need to clean document to...\n            var eventTypePrefix = this._getEventPrefix();\n            removeListener(fabric.document, eventTypePrefix + \"up\", this._onMouseUp);\n            removeListener(fabric.document, \"touchend\", this._onTouchEnd, addEventOptions);\n            removeListener(fabric.document, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            removeListener(fabric.document, \"touchmove\", this._onMouseMove, addEventOptions);\n        },\n        /**\n     * @private\n     */ _bindEvents: function() {\n            if (this.eventsBound) {\n                // for any reason we pass here twice we do not want to bind events twice.\n                return;\n            }\n            this._onMouseDown = this._onMouseDown.bind(this);\n            this._onTouchStart = this._onTouchStart.bind(this);\n            this._onMouseMove = this._onMouseMove.bind(this);\n            this._onMouseUp = this._onMouseUp.bind(this);\n            this._onTouchEnd = this._onTouchEnd.bind(this);\n            this._onResize = this._onResize.bind(this);\n            this._onGesture = this._onGesture.bind(this);\n            this._onDrag = this._onDrag.bind(this);\n            this._onShake = this._onShake.bind(this);\n            this._onLongPress = this._onLongPress.bind(this);\n            this._onOrientationChange = this._onOrientationChange.bind(this);\n            this._onMouseWheel = this._onMouseWheel.bind(this);\n            this._onMouseOut = this._onMouseOut.bind(this);\n            this._onMouseEnter = this._onMouseEnter.bind(this);\n            this._onContextMenu = this._onContextMenu.bind(this);\n            this._onDoubleClick = this._onDoubleClick.bind(this);\n            this._onDragOver = this._onDragOver.bind(this);\n            this._onDragEnter = this._simpleEventHandler.bind(this, \"dragenter\");\n            this._onDragLeave = this._simpleEventHandler.bind(this, \"dragleave\");\n            this._onDrop = this._onDrop.bind(this);\n            this.eventsBound = true;\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js gesture\n     * @param {Event} [self] Inner Event object\n     */ _onGesture: function(e, self) {\n            this.__onTransformGesture && this.__onTransformGesture(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js drag\n     * @param {Event} [self] Inner Event object\n     */ _onDrag: function(e, self) {\n            this.__onDrag && this.__onDrag(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on wheel event\n     */ _onMouseWheel: function(e) {\n            this.__onMouseWheel(e);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onMouseOut: function(e) {\n            var target = this._hoveredTarget;\n            this.fire(\"mouse:out\", {\n                target: target,\n                e: e\n            });\n            this._hoveredTarget = null;\n            target && target.fire(\"mouseout\", {\n                e: e\n            });\n            var _this = this;\n            this._hoveredTargets.forEach(function(_target) {\n                _this.fire(\"mouse:out\", {\n                    target: target,\n                    e: e\n                });\n                _target && target.fire(\"mouseout\", {\n                    e: e\n                });\n            });\n            this._hoveredTargets = [];\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mouseenter\n     */ _onMouseEnter: function(e) {\n            // This find target and consequent 'mouse:over' is used to\n            // clear old instances on hovered target.\n            // calling findTarget has the side effect of killing target.__corner.\n            // as a short term fix we are not firing this if we are currently transforming.\n            // as a long term fix we need to separate the action of finding a target with the\n            // side effects we added to it.\n            if (!this._currentTransform && !this.findTarget(e)) {\n                this.fire(\"mouse:over\", {\n                    target: null,\n                    e: e\n                });\n                this._hoveredTarget = null;\n                this._hoveredTargets = [];\n            }\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js orientation change\n     * @param {Event} [self] Inner Event object\n     */ _onOrientationChange: function(e, self) {\n            this.__onOrientationChange && this.__onOrientationChange(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     * @param {Event} [self] Inner Event object\n     */ _onShake: function(e, self) {\n            this.__onShake && this.__onShake(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     * @param {Event} [self] Inner Event object\n     */ _onLongPress: function(e, self) {\n            this.__onLongPress && this.__onLongPress(e, self);\n        },\n        /**\n     * prevent default to allow drop event to be fired\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     */ _onDragOver: function(e) {\n            e.preventDefault();\n            var target = this._simpleEventHandler(\"dragover\", e);\n            this._fireEnterLeaveEvents(target, e);\n        },\n        /**\n     * `drop:before` is a an event that allow you to schedule logic\n     * before the `drop` event. Prefer `drop` event always, but if you need\n     * to run some drop-disabling logic on an event, since there is no way\n     * to handle event handlers ordering, use `drop:before`\n     * @param {Event} e\n     */ _onDrop: function(e) {\n            this._simpleEventHandler(\"drop:before\", e);\n            return this._simpleEventHandler(\"drop\", e);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onContextMenu: function(e) {\n            if (this.stopContextMenu) {\n                e.stopPropagation();\n                e.preventDefault();\n            }\n            return false;\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onDoubleClick: function(e) {\n            this._cacheTransformEventData(e);\n            this._handleEvent(e, \"dblclick\");\n            this._resetTransformEventData(e);\n        },\n        /**\n     * Return a the id of an event.\n     * returns either the pointerId or the identifier or 0 for the mouse event\n     * @private\n     * @param {Event} evt Event object\n     */ getPointerId: function(evt) {\n            var changedTouches = evt.changedTouches;\n            if (changedTouches) {\n                return changedTouches[0] && changedTouches[0].identifier;\n            }\n            if (this.enablePointerEvents) {\n                return evt.pointerId;\n            }\n            return -1;\n        },\n        /**\n     * Determines if an event has the id of the event that is considered main\n     * @private\n     * @param {evt} event Event object\n     */ _isMainEvent: function(evt) {\n            if (evt.isPrimary === true) {\n                return true;\n            }\n            if (evt.isPrimary === false) {\n                return false;\n            }\n            if (evt.type === \"touchend\" && evt.touches.length === 0) {\n                return true;\n            }\n            if (evt.changedTouches) {\n                return evt.changedTouches[0].identifier === this.mainTouchId;\n            }\n            return true;\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onTouchStart: function(e) {\n            e.preventDefault();\n            if (this.mainTouchId === null) {\n                this.mainTouchId = this.getPointerId(e);\n            }\n            this.__onMouseDown(e);\n            this._resetTransformEventData();\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            addListener(fabric.document, \"touchend\", this._onTouchEnd, addEventOptions);\n            addListener(fabric.document, \"touchmove\", this._onMouseMove, addEventOptions);\n            // Unbind mousedown to prevent double triggers from touch devices\n            removeListener(canvasElement, eventTypePrefix + \"down\", this._onMouseDown);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onMouseDown: function(e) {\n            this.__onMouseDown(e);\n            this._resetTransformEventData();\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            removeListener(canvasElement, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            addListener(fabric.document, eventTypePrefix + \"up\", this._onMouseUp);\n            addListener(fabric.document, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onTouchEnd: function(e) {\n            if (e.touches.length > 0) {\n                // if there are still touches stop here\n                return;\n            }\n            this.__onMouseUp(e);\n            this._resetTransformEventData();\n            this.mainTouchId = null;\n            var eventTypePrefix = this._getEventPrefix();\n            removeListener(fabric.document, \"touchend\", this._onTouchEnd, addEventOptions);\n            removeListener(fabric.document, \"touchmove\", this._onMouseMove, addEventOptions);\n            var _this = this;\n            if (this._willAddMouseDown) {\n                clearTimeout(this._willAddMouseDown);\n            }\n            this._willAddMouseDown = setTimeout(function() {\n                // Wait 400ms before rebinding mousedown to prevent double triggers\n                // from touch devices\n                addListener(_this.upperCanvasEl, eventTypePrefix + \"down\", _this._onMouseDown);\n                _this._willAddMouseDown = 0;\n            }, 400);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */ _onMouseUp: function(e) {\n            this.__onMouseUp(e);\n            this._resetTransformEventData();\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            if (this._isMainEvent(e)) {\n                removeListener(fabric.document, eventTypePrefix + \"up\", this._onMouseUp);\n                removeListener(fabric.document, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n                addListener(canvasElement, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */ _onMouseMove: function(e) {\n            !this.allowTouchScrolling && e.preventDefault && e.preventDefault();\n            this.__onMouseMove(e);\n        },\n        /**\n     * @private\n     */ _onResize: function() {\n            this.calcOffset();\n        },\n        /**\n     * Decides whether the canvas should be redrawn in mouseup and mousedown events.\n     * @private\n     * @param {Object} target\n     */ _shouldRender: function(target) {\n            var activeObject = this._activeObject;\n            if (!!activeObject !== !!target || activeObject && target && activeObject !== target) {\n                // this covers: switch of target, from target to no target, selection of target\n                // multiSelection with key and mouse\n                return true;\n            } else if (activeObject && activeObject.isEditing) {\n                // if we mouse up/down over a editing textbox a cursor change,\n                // there is no need to re render\n                return false;\n            }\n            return false;\n        },\n        /**\n     * Method that defines the actions when mouse is released on canvas.\n     * The method resets the currentTransform parameters, store the image corner\n     * position in the image object and render the canvas on top.\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */ __onMouseUp: function(e) {\n            var target, transform = this._currentTransform, groupSelector = this._groupSelector, shouldRender = false, isClick = !groupSelector || groupSelector.left === 0 && groupSelector.top === 0;\n            this._cacheTransformEventData(e);\n            target = this._target;\n            this._handleEvent(e, \"up:before\");\n            // if right/middle click just fire events and return\n            // target undefined will make the _handleEvent search the target\n            if (checkClick(e, RIGHT_CLICK)) {\n                if (this.fireRightClick) {\n                    this._handleEvent(e, \"up\", RIGHT_CLICK, isClick);\n                }\n                return;\n            }\n            if (checkClick(e, MIDDLE_CLICK)) {\n                if (this.fireMiddleClick) {\n                    this._handleEvent(e, \"up\", MIDDLE_CLICK, isClick);\n                }\n                this._resetTransformEventData();\n                return;\n            }\n            if (this.isDrawingMode && this._isCurrentlyDrawing) {\n                this._onMouseUpInDrawingMode(e);\n                return;\n            }\n            if (!this._isMainEvent(e)) {\n                return;\n            }\n            if (transform) {\n                this._finalizeCurrentTransform(e);\n                shouldRender = transform.actionPerformed;\n            }\n            if (!isClick) {\n                var targetWasActive = target === this._activeObject;\n                this._maybeGroupObjects(e);\n                if (!shouldRender) {\n                    shouldRender = this._shouldRender(target) || !targetWasActive && target === this._activeObject;\n                }\n            }\n            var corner, pointer;\n            if (target) {\n                corner = target._findTargetCorner(this.getPointer(e, true), fabric.util.isTouchEvent(e));\n                if (target.selectable && target !== this._activeObject && target.activeOn === \"up\") {\n                    this.setActiveObject(target, e);\n                    shouldRender = true;\n                } else {\n                    var control = target.controls[corner], mouseUpHandler = control && control.getMouseUpHandler(e, target, control);\n                    if (mouseUpHandler) {\n                        pointer = this.getPointer(e);\n                        mouseUpHandler(e, transform, pointer.x, pointer.y);\n                    }\n                }\n                target.isMoving = false;\n            }\n            // if we are ending up a transform on a different control or a new object\n            // fire the original mouse up from the corner that started the transform\n            if (transform && (transform.target !== target || transform.corner !== corner)) {\n                var originalControl = transform.target && transform.target.controls[transform.corner], originalMouseUpHandler = originalControl && originalControl.getMouseUpHandler(e, target, control);\n                pointer = pointer || this.getPointer(e);\n                originalMouseUpHandler && originalMouseUpHandler(e, transform, pointer.x, pointer.y);\n            }\n            this._setCursorFromEvent(e, target);\n            this._handleEvent(e, \"up\", LEFT_CLICK, isClick);\n            this._groupSelector = null;\n            this._currentTransform = null;\n            // reset the target information about which corner is selected\n            target && (target.__corner = 0);\n            if (shouldRender) {\n                this.requestRenderAll();\n            } else if (!isClick) {\n                this.renderTop();\n            }\n        },\n        /**\n     * @private\n     * Handle event firing for target and subtargets\n     * @param {Event} e event from mouse\n     * @param {String} eventType event to fire (up, down or move)\n     * @return {Fabric.Object} target return the the target found, for internal reasons.\n     */ _simpleEventHandler: function(eventType, e) {\n            var target = this.findTarget(e), targets = this.targets, options = {\n                e: e,\n                target: target,\n                subTargets: targets\n            };\n            this.fire(eventType, options);\n            target && target.fire(eventType, options);\n            if (!targets) {\n                return target;\n            }\n            for(var i = 0; i < targets.length; i++){\n                targets[i].fire(eventType, options);\n            }\n            return target;\n        },\n        /**\n     * @private\n     * Handle event firing for target and subtargets\n     * @param {Event} e event from mouse\n     * @param {String} eventType event to fire (up, down or move)\n     * @param {fabric.Object} targetObj receiving event\n     * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right\n     * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.\n     */ _handleEvent: function(e, eventType, button, isClick) {\n            var target = this._target, targets = this.targets || [], options = {\n                e: e,\n                target: target,\n                subTargets: targets,\n                button: button || LEFT_CLICK,\n                isClick: isClick || false,\n                pointer: this._pointer,\n                absolutePointer: this._absolutePointer,\n                transform: this._currentTransform\n            };\n            if (eventType === \"up\") {\n                options.currentTarget = this.findTarget(e);\n                options.currentSubTargets = this.targets;\n            }\n            this.fire(\"mouse:\" + eventType, options);\n            target && target.fire(\"mouse\" + eventType, options);\n            for(var i = 0; i < targets.length; i++){\n                targets[i].fire(\"mouse\" + eventType, options);\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event\n     */ _finalizeCurrentTransform: function(e) {\n            var transform = this._currentTransform, target = transform.target, options = {\n                e: e,\n                target: target,\n                transform: transform,\n                action: transform.action\n            };\n            if (target._scaling) {\n                target._scaling = false;\n            }\n            target.setCoords();\n            if (transform.actionPerformed || this.stateful && target.hasStateChanged()) {\n                this._fire(\"modified\", options);\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onMouseDownInDrawingMode: function(e) {\n            this._isCurrentlyDrawing = true;\n            if (this.getActiveObject()) {\n                this.discardActiveObject(e).requestRenderAll();\n            }\n            var pointer = this.getPointer(e);\n            this.freeDrawingBrush.onMouseDown(pointer, {\n                e: e,\n                pointer: pointer\n            });\n            this._handleEvent(e, \"down\");\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */ _onMouseMoveInDrawingMode: function(e) {\n            if (this._isCurrentlyDrawing) {\n                var pointer = this.getPointer(e);\n                this.freeDrawingBrush.onMouseMove(pointer, {\n                    e: e,\n                    pointer: pointer\n                });\n            }\n            this.setCursor(this.freeDrawingCursor);\n            this._handleEvent(e, \"move\");\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */ _onMouseUpInDrawingMode: function(e) {\n            var pointer = this.getPointer(e);\n            this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({\n                e: e,\n                pointer: pointer\n            });\n            this._handleEvent(e, \"up\");\n        },\n        /**\n     * Method that defines the actions when mouse is clicked on canvas.\n     * The method inits the currentTransform parameters and renders all the\n     * canvas so the current image can be placed on the top canvas and the rest\n     * in on the container one.\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ __onMouseDown: function(e) {\n            this._cacheTransformEventData(e);\n            this._handleEvent(e, \"down:before\");\n            var target = this._target;\n            // if right click just fire events\n            if (checkClick(e, RIGHT_CLICK)) {\n                if (this.fireRightClick) {\n                    this._handleEvent(e, \"down\", RIGHT_CLICK);\n                }\n                return;\n            }\n            if (checkClick(e, MIDDLE_CLICK)) {\n                if (this.fireMiddleClick) {\n                    this._handleEvent(e, \"down\", MIDDLE_CLICK);\n                }\n                return;\n            }\n            if (this.isDrawingMode) {\n                this._onMouseDownInDrawingMode(e);\n                return;\n            }\n            if (!this._isMainEvent(e)) {\n                return;\n            }\n            // ignore if some object is being transformed at this moment\n            if (this._currentTransform) {\n                return;\n            }\n            var pointer = this._pointer;\n            // save pointer for check in __onMouseUp event\n            this._previousPointer = pointer;\n            var shouldRender = this._shouldRender(target), shouldGroup = this._shouldGroup(e, target);\n            if (this._shouldClearSelection(e, target)) {\n                this.discardActiveObject(e);\n            } else if (shouldGroup) {\n                this._handleGrouping(e, target);\n                target = this._activeObject;\n            }\n            if (this.selection && (!target || !target.selectable && !target.isEditing && target !== this._activeObject)) {\n                this._groupSelector = {\n                    ex: this._absolutePointer.x,\n                    ey: this._absolutePointer.y,\n                    top: 0,\n                    left: 0\n                };\n            }\n            if (target) {\n                var alreadySelected = target === this._activeObject;\n                if (target.selectable && target.activeOn === \"down\") {\n                    this.setActiveObject(target, e);\n                }\n                var corner = target._findTargetCorner(this.getPointer(e, true), fabric.util.isTouchEvent(e));\n                target.__corner = corner;\n                if (target === this._activeObject && (corner || !shouldGroup)) {\n                    this._setupCurrentTransform(e, target, alreadySelected);\n                    var control = target.controls[corner], pointer = this.getPointer(e), mouseDownHandler = control && control.getMouseDownHandler(e, target, control);\n                    if (mouseDownHandler) {\n                        mouseDownHandler(e, this._currentTransform, pointer.x, pointer.y);\n                    }\n                }\n            }\n            this._handleEvent(e, \"down\");\n            // we must renderAll so that we update the visuals\n            (shouldRender || shouldGroup) && this.requestRenderAll();\n        },\n        /**\n     * reset cache form common information needed during event processing\n     * @private\n     */ _resetTransformEventData: function() {\n            this._target = null;\n            this._pointer = null;\n            this._absolutePointer = null;\n        },\n        /**\n     * Cache common information needed during event processing\n     * @private\n     * @param {Event} e Event object fired on event\n     */ _cacheTransformEventData: function(e) {\n            // reset in order to avoid stale caching\n            this._resetTransformEventData();\n            this._pointer = this.getPointer(e, true);\n            this._absolutePointer = this.restorePointerVpt(this._pointer);\n            this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e) || null;\n        },\n        /**\n     * @private\n     */ _beforeTransform: function(e) {\n            var t = this._currentTransform;\n            this.stateful && t.target.saveState();\n            this.fire(\"before:transform\", {\n                e: e,\n                transform: t\n            });\n        },\n        /**\n     * Method that defines the actions when mouse is hovering the canvas.\n     * The currentTransform parameter will define whether the user is rotating/scaling/translating\n     * an image or neither of them (only hovering). A group selection is also possible and would cancel\n     * all any other type of action.\n     * In case of an image transformation only the top canvas will be rendered.\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */ __onMouseMove: function(e) {\n            this._handleEvent(e, \"move:before\");\n            this._cacheTransformEventData(e);\n            var target, pointer;\n            if (this.isDrawingMode) {\n                this._onMouseMoveInDrawingMode(e);\n                return;\n            }\n            if (!this._isMainEvent(e)) {\n                return;\n            }\n            var groupSelector = this._groupSelector;\n            // We initially clicked in an empty area, so we draw a box for multiple selection\n            if (groupSelector) {\n                pointer = this._absolutePointer;\n                groupSelector.left = pointer.x - groupSelector.ex;\n                groupSelector.top = pointer.y - groupSelector.ey;\n                this.renderTop();\n            } else if (!this._currentTransform) {\n                target = this.findTarget(e) || null;\n                this._setCursorFromEvent(e, target);\n                this._fireOverOutEvents(target, e);\n            } else {\n                this._transformObject(e);\n            }\n            this._handleEvent(e, \"move\");\n            this._resetTransformEventData();\n        },\n        /**\n     * Manage the mouseout, mouseover events for the fabric object on the canvas\n     * @param {Fabric.Object} target the target where the target from the mousemove event\n     * @param {Event} e Event object fired on mousemove\n     * @private\n     */ _fireOverOutEvents: function(target, e) {\n            var _hoveredTarget = this._hoveredTarget, _hoveredTargets = this._hoveredTargets, targets = this.targets, length = Math.max(_hoveredTargets.length, targets.length);\n            this.fireSyntheticInOutEvents(target, e, {\n                oldTarget: _hoveredTarget,\n                evtOut: \"mouseout\",\n                canvasEvtOut: \"mouse:out\",\n                evtIn: \"mouseover\",\n                canvasEvtIn: \"mouse:over\"\n            });\n            for(var i = 0; i < length; i++){\n                this.fireSyntheticInOutEvents(targets[i], e, {\n                    oldTarget: _hoveredTargets[i],\n                    evtOut: \"mouseout\",\n                    evtIn: \"mouseover\"\n                });\n            }\n            this._hoveredTarget = target;\n            this._hoveredTargets = this.targets.concat();\n        },\n        /**\n     * Manage the dragEnter, dragLeave events for the fabric objects on the canvas\n     * @param {Fabric.Object} target the target where the target from the onDrag event\n     * @param {Event} e Event object fired on ondrag\n     * @private\n     */ _fireEnterLeaveEvents: function(target, e) {\n            var _draggedoverTarget = this._draggedoverTarget, _hoveredTargets = this._hoveredTargets, targets = this.targets, length = Math.max(_hoveredTargets.length, targets.length);\n            this.fireSyntheticInOutEvents(target, e, {\n                oldTarget: _draggedoverTarget,\n                evtOut: \"dragleave\",\n                evtIn: \"dragenter\"\n            });\n            for(var i = 0; i < length; i++){\n                this.fireSyntheticInOutEvents(targets[i], e, {\n                    oldTarget: _hoveredTargets[i],\n                    evtOut: \"dragleave\",\n                    evtIn: \"dragenter\"\n                });\n            }\n            this._draggedoverTarget = target;\n        },\n        /**\n     * Manage the synthetic in/out events for the fabric objects on the canvas\n     * @param {Fabric.Object} target the target where the target from the supported events\n     * @param {Event} e Event object fired\n     * @param {Object} config configuration for the function to work\n     * @param {String} config.targetName property on the canvas where the old target is stored\n     * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out\n     * @param {String} config.evtOut name of the event to fire for out\n     * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in\n     * @param {String} config.evtIn name of the event to fire for in\n     * @private\n     */ fireSyntheticInOutEvents: function(target, e, config) {\n            var inOpt, outOpt, oldTarget = config.oldTarget, outFires, inFires, targetChanged = oldTarget !== target, canvasEvtIn = config.canvasEvtIn, canvasEvtOut = config.canvasEvtOut;\n            if (targetChanged) {\n                inOpt = {\n                    e: e,\n                    target: target,\n                    previousTarget: oldTarget\n                };\n                outOpt = {\n                    e: e,\n                    target: oldTarget,\n                    nextTarget: target\n                };\n            }\n            inFires = target && targetChanged;\n            outFires = oldTarget && targetChanged;\n            if (outFires) {\n                canvasEvtOut && this.fire(canvasEvtOut, outOpt);\n                oldTarget.fire(config.evtOut, outOpt);\n            }\n            if (inFires) {\n                canvasEvtIn && this.fire(canvasEvtIn, inOpt);\n                target.fire(config.evtIn, inOpt);\n            }\n        },\n        /**\n     * Method that defines actions when an Event Mouse Wheel\n     * @param {Event} e Event object fired on mouseup\n     */ __onMouseWheel: function(e) {\n            this._cacheTransformEventData(e);\n            this._handleEvent(e, \"wheel\");\n            this._resetTransformEventData();\n        },\n        /**\n     * @private\n     * @param {Event} e Event fired on mousemove\n     */ _transformObject: function(e) {\n            var pointer = this.getPointer(e), transform = this._currentTransform;\n            transform.reset = false;\n            transform.shiftKey = e.shiftKey;\n            transform.altKey = e[this.centeredKey];\n            this._performTransformAction(e, transform, pointer);\n            transform.actionPerformed && this.requestRenderAll();\n        },\n        /**\n     * @private\n     */ _performTransformAction: function(e, transform, pointer) {\n            var x = pointer.x, y = pointer.y, action = transform.action, actionPerformed = false, actionHandler = transform.actionHandler;\n            // this object could be created from the function in the control handlers\n            if (actionHandler) {\n                actionPerformed = actionHandler(e, transform, x, y);\n            }\n            if (action === \"drag\" && actionPerformed) {\n                transform.target.isMoving = true;\n                this.setCursor(transform.target.moveCursor || this.moveCursor);\n            }\n            transform.actionPerformed = transform.actionPerformed || actionPerformed;\n        },\n        /**\n     * @private\n     */ _fire: fabric.controlsUtils.fireEvent,\n        /**\n     * Sets the cursor depending on where the canvas is being hovered.\n     * Note: very buggy in Opera\n     * @param {Event} e Event object\n     * @param {Object} target Object that the mouse is hovering, if so.\n     */ _setCursorFromEvent: function(e, target) {\n            if (!target) {\n                this.setCursor(this.defaultCursor);\n                return false;\n            }\n            var hoverCursor = target.hoverCursor || this.hoverCursor, activeSelection = this._activeObject && this._activeObject.type === \"activeSelection\" ? this._activeObject : null, // only show proper corner when group selection is not active\n            corner = (!activeSelection || !activeSelection.contains(target)) && target._findTargetCorner(this.getPointer(e, true));\n            if (!corner) {\n                if (target.subTargetCheck) {\n                    // hoverCursor should come from top-most subTarget,\n                    // so we walk the array backwards\n                    this.targets.concat().reverse().map(function(_target) {\n                        hoverCursor = _target.hoverCursor || hoverCursor;\n                    });\n                }\n                this.setCursor(hoverCursor);\n            } else {\n                this.setCursor(this.getCornerCursor(corner, target, e));\n            }\n        },\n        /**\n     * @private\n     */ getCornerCursor: function(corner, target, e) {\n            var control = target.controls[corner];\n            return control.cursorStyleHandler(e, control, target);\n        }\n    });\n})();\n(function() {\n    var min = Math.min, max = Math.max;\n    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     * @return {Boolean}\n     */ _shouldGroup: function(e, target) {\n            var activeObject = this._activeObject;\n            return activeObject && this._isSelectionKeyPressed(e) && target && target.selectable && this.selection && (activeObject !== target || activeObject.type === \"activeSelection\") && !target.onSelect({\n                e: e\n            });\n        },\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */ _handleGrouping: function(e, target) {\n            var activeObject = this._activeObject;\n            // avoid multi select when shift click on a corner\n            if (activeObject.__corner) {\n                return;\n            }\n            if (target === activeObject) {\n                // if it's a group, find target again, using activeGroup objects\n                target = this.findTarget(e, true);\n                // if even object is not found or we are on activeObjectCorner, bail out\n                if (!target || !target.selectable) {\n                    return;\n                }\n            }\n            if (activeObject && activeObject.type === \"activeSelection\") {\n                this._updateActiveSelection(target, e);\n            } else {\n                this._createActiveSelection(target, e);\n            }\n        },\n        /**\n     * @private\n     */ _updateActiveSelection: function(target, e) {\n            var activeSelection = this._activeObject, currentActiveObjects = activeSelection._objects.slice(0);\n            if (activeSelection.contains(target)) {\n                activeSelection.removeWithUpdate(target);\n                this._hoveredTarget = target;\n                this._hoveredTargets = this.targets.concat();\n                if (activeSelection.size() === 1) {\n                    // activate last remaining object\n                    this._setActiveObject(activeSelection.item(0), e);\n                }\n            } else {\n                activeSelection.addWithUpdate(target);\n                this._hoveredTarget = activeSelection;\n                this._hoveredTargets = this.targets.concat();\n            }\n            this._fireSelectionEvents(currentActiveObjects, e);\n        },\n        /**\n     * @private\n     */ _createActiveSelection: function(target, e) {\n            var currentActives = this.getActiveObjects(), group = this._createGroup(target);\n            this._hoveredTarget = group;\n            // ISSUE 4115: should we consider subTargets here?\n            // this._hoveredTargets = [];\n            // this._hoveredTargets = this.targets.concat();\n            this._setActiveObject(group, e);\n            this._fireSelectionEvents(currentActives, e);\n        },\n        /**\n     * @private\n     * @param {Object} target\n     */ _createGroup: function(target) {\n            var objects = this._objects, isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target), groupObjects = isActiveLower ? [\n                this._activeObject,\n                target\n            ] : [\n                target,\n                this._activeObject\n            ];\n            this._activeObject.isEditing && this._activeObject.exitEditing();\n            return new fabric.ActiveSelection(groupObjects, {\n                canvas: this\n            });\n        },\n        /**\n     * @private\n     * @param {Event} e mouse event\n     */ _groupSelectedObjects: function(e) {\n            var group = this._collectObjects(e), aGroup;\n            // do not create group for 1 element only\n            if (group.length === 1) {\n                this.setActiveObject(group[0], e);\n            } else if (group.length > 1) {\n                aGroup = new fabric.ActiveSelection(group.reverse(), {\n                    canvas: this\n                });\n                this.setActiveObject(aGroup, e);\n            }\n        },\n        /**\n     * @private\n     */ _collectObjects: function(e) {\n            var group = [], currentObject, x1 = this._groupSelector.ex, y1 = this._groupSelector.ey, x2 = x1 + this._groupSelector.left, y2 = y1 + this._groupSelector.top, selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)), selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)), allowIntersect = !this.selectionFullyContained, isClick = x1 === x2 && y1 === y2;\n            // we iterate reverse order to collect top first in case of click.\n            for(var i = this._objects.length; i--;){\n                currentObject = this._objects[i];\n                if (!currentObject || !currentObject.selectable || !currentObject.visible) {\n                    continue;\n                }\n                if (allowIntersect && currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2, true) || currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2, true) || allowIntersect && currentObject.containsPoint(selectionX1Y1, null, true) || allowIntersect && currentObject.containsPoint(selectionX2Y2, null, true)) {\n                    group.push(currentObject);\n                    // only add one object if it's a click\n                    if (isClick) {\n                        break;\n                    }\n                }\n            }\n            if (group.length > 1) {\n                group = group.filter(function(object) {\n                    return !object.onSelect({\n                        e: e\n                    });\n                });\n            }\n            return group;\n        },\n        /**\n     * @private\n     */ _maybeGroupObjects: function(e) {\n            if (this.selection && this._groupSelector) {\n                this._groupSelectedObjects(e);\n            }\n            this.setCursor(this.defaultCursor);\n            // clear selection and current transformation\n            this._groupSelector = null;\n        }\n    });\n})();\n(function() {\n    fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n        /**\n     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately\n     * @param {Object} [options] Options object\n     * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\n     * @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\n     * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}\n     * @example <caption>Generate jpeg dataURL with lower quality</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'jpeg',\n     *   quality: 0.8\n     * });\n     * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'png',\n     *   left: 100,\n     *   top: 100,\n     *   width: 200,\n     *   height: 200\n     * });\n     * @example <caption>Generate double scaled png dataURL</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'png',\n     *   multiplier: 2\n     * });\n     */ toDataURL: function(options) {\n            options || (options = {});\n            var format = options.format || \"png\", quality = options.quality || 1, multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? this.getRetinaScaling() : 1), canvasEl = this.toCanvasElement(multiplier, options);\n            return fabric.util.toDataURL(canvasEl, format, quality);\n        },\n        /**\n     * Create a new HTMLCanvas element painted with the current canvas content.\n     * No need to resize the actual one or repaint it.\n     * Will transfer object ownership to a new canvas, paint it, and set everything back.\n     * This is an intermediary step used to get to a dataUrl but also it is useful to\n     * create quick image copies of a canvas without passing for the dataUrl string\n     * @param {Number} [multiplier] a zoom factor.\n     * @param {Object} [cropping] Cropping informations\n     * @param {Number} [cropping.left] Cropping left offset.\n     * @param {Number} [cropping.top] Cropping top offset.\n     * @param {Number} [cropping.width] Cropping width.\n     * @param {Number} [cropping.height] Cropping height.\n     */ toCanvasElement: function(multiplier, cropping) {\n            multiplier = multiplier || 1;\n            cropping = cropping || {};\n            var scaledWidth = (cropping.width || this.width) * multiplier, scaledHeight = (cropping.height || this.height) * multiplier, zoom = this.getZoom(), originalWidth = this.width, originalHeight = this.height, newZoom = zoom * multiplier, vp = this.viewportTransform, translateX = (vp[4] - (cropping.left || 0)) * multiplier, translateY = (vp[5] - (cropping.top || 0)) * multiplier, originalInteractive = this.interactive, newVp = [\n                newZoom,\n                0,\n                0,\n                newZoom,\n                translateX,\n                translateY\n            ], originalRetina = this.enableRetinaScaling, canvasEl = fabric.util.createCanvasElement(), originalContextTop = this.contextTop;\n            canvasEl.width = scaledWidth;\n            canvasEl.height = scaledHeight;\n            this.contextTop = null;\n            this.enableRetinaScaling = false;\n            this.interactive = false;\n            this.viewportTransform = newVp;\n            this.width = scaledWidth;\n            this.height = scaledHeight;\n            this.calcViewportBoundaries();\n            this.renderCanvas(canvasEl.getContext(\"2d\"), this._objects);\n            this.viewportTransform = vp;\n            this.width = originalWidth;\n            this.height = originalHeight;\n            this.calcViewportBoundaries();\n            this.interactive = originalInteractive;\n            this.enableRetinaScaling = originalRetina;\n            this.contextTop = originalContextTop;\n            return canvasEl;\n        }\n    });\n})();\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n    /**\n   * Populates canvas with data from the specified JSON.\n   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}\n   * @param {String|Object} json JSON string or object\n   * @param {Function} callback Callback, invoked when json is parsed\n   *                            and corresponding objects (e.g: {@link fabric.Image})\n   *                            are initialized\n   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.\n   * @return {fabric.Canvas} instance\n   * @chainable\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}\n   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}\n   * @example <caption>loadFromJSON</caption>\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));\n   * @example <caption>loadFromJSON with reviver</caption>\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {\n   *   // `o` = json object\n   *   // `object` = fabric.Object instance\n   *   // ... do some stuff ...\n   * });\n   */ loadFromJSON: function(json, callback, reviver) {\n        if (!json) {\n            return;\n        }\n        // serialize if it wasn't already\n        var serialized = typeof json === \"string\" ? JSON.parse(json) : fabric.util.object.clone(json);\n        var _this = this, clipPath = serialized.clipPath, renderOnAddRemove = this.renderOnAddRemove;\n        this.renderOnAddRemove = false;\n        delete serialized.clipPath;\n        this._enlivenObjects(serialized.objects, function(enlivenedObjects) {\n            _this.clear();\n            _this._setBgOverlay(serialized, function() {\n                if (clipPath) {\n                    _this._enlivenObjects([\n                        clipPath\n                    ], function(enlivenedCanvasClip) {\n                        _this.clipPath = enlivenedCanvasClip[0];\n                        _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);\n                    });\n                } else {\n                    _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);\n                }\n            });\n        }, reviver);\n        return this;\n    },\n    /**\n   * @private\n   * @param {Object} serialized Object with background and overlay information\n   * @param {Array} restored canvas objects\n   * @param {Function} cached renderOnAddRemove callback\n   * @param {Function} callback Invoked after all background and overlay images/patterns loaded\n   */ __setupCanvas: function(serialized, enlivenedObjects, renderOnAddRemove, callback) {\n        var _this = this;\n        enlivenedObjects.forEach(function(obj, index) {\n            // we splice the array just in case some custom classes restored from JSON\n            // will add more object to canvas at canvas init.\n            _this.insertAt(obj, index);\n        });\n        this.renderOnAddRemove = renderOnAddRemove;\n        // remove parts i cannot set as options\n        delete serialized.objects;\n        delete serialized.backgroundImage;\n        delete serialized.overlayImage;\n        delete serialized.background;\n        delete serialized.overlay;\n        // this._initOptions does too many things to just\n        // call it. Normally loading an Object from JSON\n        // create the Object instance. Here the Canvas is\n        // already an instance and we are just loading things over it\n        this._setOptions(serialized);\n        this.renderAll();\n        callback && callback();\n    },\n    /**\n   * @private\n   * @param {Object} serialized Object with background and overlay information\n   * @param {Function} callback Invoked after all background and overlay images/patterns loaded\n   */ _setBgOverlay: function(serialized, callback) {\n        var loaded = {\n            backgroundColor: false,\n            overlayColor: false,\n            backgroundImage: false,\n            overlayImage: false\n        };\n        if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {\n            callback && callback();\n            return;\n        }\n        var cbIfLoaded = function() {\n            if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {\n                callback && callback();\n            }\n        };\n        this.__setBgOverlay(\"backgroundImage\", serialized.backgroundImage, loaded, cbIfLoaded);\n        this.__setBgOverlay(\"overlayImage\", serialized.overlayImage, loaded, cbIfLoaded);\n        this.__setBgOverlay(\"backgroundColor\", serialized.background, loaded, cbIfLoaded);\n        this.__setBgOverlay(\"overlayColor\", serialized.overlay, loaded, cbIfLoaded);\n    },\n    /**\n   * @private\n   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)\n   * @param {(Object|String)} value Value to set\n   * @param {Object} loaded Set loaded property to true if property is set\n   * @param {Object} callback Callback function to invoke after property is set\n   */ __setBgOverlay: function(property, value, loaded, callback) {\n        var _this = this;\n        if (!value) {\n            loaded[property] = true;\n            callback && callback();\n            return;\n        }\n        if (property === \"backgroundImage\" || property === \"overlayImage\") {\n            fabric.util.enlivenObjects([\n                value\n            ], function(enlivedObject) {\n                _this[property] = enlivedObject[0];\n                loaded[property] = true;\n                callback && callback();\n            });\n        } else {\n            this[\"set\" + fabric.util.string.capitalize(property, true)](value, function() {\n                loaded[property] = true;\n                callback && callback();\n            });\n        }\n    },\n    /**\n   * @private\n   * @param {Array} objects\n   * @param {Function} callback\n   * @param {Function} [reviver]\n   */ _enlivenObjects: function(objects, callback, reviver) {\n        if (!objects || objects.length === 0) {\n            callback && callback([]);\n            return;\n        }\n        fabric.util.enlivenObjects(objects, function(enlivenedObjects) {\n            callback && callback(enlivenedObjects);\n        }, null, reviver);\n    },\n    /**\n   * @private\n   * @param {String} format\n   * @param {Function} callback\n   */ _toDataURL: function(format, callback) {\n        this.clone(function(clone) {\n            callback(clone.toDataURL(format));\n        });\n    },\n    /**\n   * @private\n   * @param {String} format\n   * @param {Number} multiplier\n   * @param {Function} callback\n   */ _toDataURLWithMultiplier: function(format, multiplier, callback) {\n        this.clone(function(clone) {\n            callback(clone.toDataURLWithMultiplier(format, multiplier));\n        });\n    },\n    /**\n   * Clones canvas instance\n   * @param {Object} [callback] Receives cloned instance as a first argument\n   * @param {Array} [properties] Array of properties to include in the cloned canvas and children\n   */ clone: function(callback, properties) {\n        var data = JSON.stringify(this.toJSON(properties));\n        this.cloneWithoutData(function(clone) {\n            clone.loadFromJSON(data, function() {\n                callback && callback(clone);\n            });\n        });\n    },\n    /**\n   * Clones canvas instance without cloning existing data.\n   * This essentially copies canvas dimensions, clipping properties, etc.\n   * but leaves data empty (so that you can populate it with your own)\n   * @param {Object} [callback] Receives cloned instance as a first argument\n   */ cloneWithoutData: function(callback) {\n        var el = fabric.util.createCanvasElement();\n        el.width = this.width;\n        el.height = this.height;\n        var clone = new fabric.Canvas(el);\n        if (this.backgroundImage) {\n            clone.setBackgroundImage(this.backgroundImage.src, function() {\n                clone.renderAll();\n                callback && callback(clone);\n            });\n            clone.backgroundImageOpacity = this.backgroundImageOpacity;\n            clone.backgroundImageStretch = this.backgroundImageStretch;\n        } else {\n            callback && callback(clone);\n        }\n    }\n});\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, clone = fabric.util.object.clone, toFixed = fabric.util.toFixed, capitalize = fabric.util.string.capitalize, degreesToRadians = fabric.util.degreesToRadians, objectCaching = !fabric.isLikelyNode, ALIASING_LIMIT = 2;\n    if (fabric.Object) {\n        return;\n    }\n    /**\n   * Root object class from which all 2d shape classes inherit from\n   * @class fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}\n   * @see {@link fabric.Object#initialize} for constructor definition\n   *\n   * @fires added\n   * @fires removed\n   *\n   * @fires selected\n   * @fires deselected\n   * @fires modified\n   * @fires modified\n   * @fires moved\n   * @fires scaled\n   * @fires rotated\n   * @fires skewed\n   *\n   * @fires rotating\n   * @fires scaling\n   * @fires moving\n   * @fires skewing\n   *\n   * @fires mousedown\n   * @fires mouseup\n   * @fires mouseover\n   * @fires mouseout\n   * @fires mousewheel\n   * @fires mousedblclick\n   *\n   * @fires dragover\n   * @fires dragenter\n   * @fires dragleave\n   * @fires drop\n   */ fabric.Object = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.Object.prototype */ {\n        /**\n     * Type of an object (rect, circle, path, etc.).\n     * Note that this property is meant to be read-only and not meant to be modified.\n     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.\n     * @type String\n     * @default\n     */ type: \"object\",\n        /**\n     * Horizontal origin of transformation of an object (one of \"left\", \"right\", \"center\")\n     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups\n     * @type String\n     * @default\n     */ originX: \"left\",\n        /**\n     * Vertical origin of transformation of an object (one of \"top\", \"bottom\", \"center\")\n     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups\n     * @type String\n     * @default\n     */ originY: \"top\",\n        /**\n     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}\n     * @type Number\n     * @default\n     */ top: 0,\n        /**\n     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}\n     * @type Number\n     * @default\n     */ left: 0,\n        /**\n     * Object width\n     * @type Number\n     * @default\n     */ width: 0,\n        /**\n     * Object height\n     * @type Number\n     * @default\n     */ height: 0,\n        /**\n     * Object scale factor (horizontal)\n     * @type Number\n     * @default\n     */ scaleX: 1,\n        /**\n     * Object scale factor (vertical)\n     * @type Number\n     * @default\n     */ scaleY: 1,\n        /**\n     * When true, an object is rendered as flipped horizontally\n     * @type Boolean\n     * @default\n     */ flipX: false,\n        /**\n     * When true, an object is rendered as flipped vertically\n     * @type Boolean\n     * @default\n     */ flipY: false,\n        /**\n     * Opacity of an object\n     * @type Number\n     * @default\n     */ opacity: 1,\n        /**\n     * Angle of rotation of an object (in degrees)\n     * @type Number\n     * @default\n     */ angle: 0,\n        /**\n     * Angle of skew on x axes of an object (in degrees)\n     * @type Number\n     * @default\n     */ skewX: 0,\n        /**\n     * Angle of skew on y axes of an object (in degrees)\n     * @type Number\n     * @default\n     */ skewY: 0,\n        /**\n     * Size of object's controlling corners (in pixels)\n     * @type Number\n     * @default\n     */ cornerSize: 13,\n        /**\n     * Size of object's controlling corners when touch interaction is detected\n     * @type Number\n     * @default\n     */ touchCornerSize: 24,\n        /**\n     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)\n     * @type Boolean\n     * @default\n     */ transparentCorners: true,\n        /**\n     * Default cursor value used when hovering over this object on canvas\n     * @type String\n     * @default\n     */ hoverCursor: null,\n        /**\n     * Default cursor value used when moving this object on canvas\n     * @type String\n     * @default\n     */ moveCursor: null,\n        /**\n     * Padding between object and its controlling borders (in pixels)\n     * @type Number\n     * @default\n     */ padding: 0,\n        /**\n     * Color of controlling borders of an object (when it's active)\n     * @type String\n     * @default\n     */ borderColor: \"rgb(178,204,255)\",\n        /**\n     * Array specifying dash pattern of an object's borders (hasBorder must be true)\n     * @since 1.6.2\n     * @type Array\n     */ borderDashArray: null,\n        /**\n     * Color of controlling corners of an object (when it's active)\n     * @type String\n     * @default\n     */ cornerColor: \"rgb(178,204,255)\",\n        /**\n     * Color of controlling corners of an object (when it's active and transparentCorners false)\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ cornerStrokeColor: null,\n        /**\n     * Specify style of control, 'rect' or 'circle'\n     * @since 1.6.2\n     * @type String\n     */ cornerStyle: \"rect\",\n        /**\n     * Array specifying dash pattern of an object's control (hasBorder must be true)\n     * @since 1.6.2\n     * @type Array\n     */ cornerDashArray: null,\n        /**\n     * When true, this object will use center point as the origin of transformation\n     * when being scaled via the controls.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredScaling: false,\n        /**\n     * When true, this object will use center point as the origin of transformation\n     * when being rotated via the controls.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredRotation: true,\n        /**\n     * Color of object's fill\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */ fill: \"rgb(0,0,0)\",\n        /**\n     * Fill rule used to fill an object\n     * accepted values are nonzero, evenodd\n     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)\n     * @type String\n     * @default\n     */ fillRule: \"nonzero\",\n        /**\n     * Composite rule used for canvas globalCompositeOperation\n     * @type String\n     * @default\n     */ globalCompositeOperation: \"source-over\",\n        /**\n     * Background color of an object.\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */ backgroundColor: \"\",\n        /**\n     * Selection Background color of an object. colored layer behind the object when it is active.\n     * does not mix good with globalCompositeOperation methods.\n     * @type String\n     * @default\n     */ selectionBackgroundColor: \"\",\n        /**\n     * When defined, an object is rendered via stroke and this property specifies its color\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */ stroke: null,\n        /**\n     * Width of a stroke used to render this object\n     * @type Number\n     * @default\n     */ strokeWidth: 1,\n        /**\n     * Array specifying dash pattern of an object's stroke (stroke must be defined)\n     * @type Array\n     */ strokeDashArray: null,\n        /**\n     * Line offset of an object's stroke\n     * @type Number\n     * @default\n     */ strokeDashOffset: 0,\n        /**\n     * Line endings style of an object's stroke (one of \"butt\", \"round\", \"square\")\n     * @type String\n     * @default\n     */ strokeLineCap: \"butt\",\n        /**\n     * Corner style of an object's stroke (one of \"bevel\", \"round\", \"miter\")\n     * @type String\n     * @default\n     */ strokeLineJoin: \"miter\",\n        /**\n     * Maximum miter length (used for strokeLineJoin = \"miter\") of an object's stroke\n     * @type Number\n     * @default\n     */ strokeMiterLimit: 4,\n        /**\n     * Shadow object representing shadow of this shape\n     * @type fabric.Shadow\n     * @default\n     */ shadow: null,\n        /**\n     * Opacity of object's controlling borders when object is active and moving\n     * @type Number\n     * @default\n     */ borderOpacityWhenMoving: 0.4,\n        /**\n     * Scale factor of object's controlling borders\n     * bigger number will make a thicker border\n     * border is 1, so this is basically a border thickness\n     * since there is no way to change the border itself.\n     * @type Number\n     * @default\n     */ borderScaleFactor: 1,\n        /**\n     * Minimum allowed scale value of an object\n     * @type Number\n     * @default\n     */ minScaleLimit: 0,\n        /**\n     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).\n     * But events still fire on it.\n     * @type Boolean\n     * @default\n     */ selectable: true,\n        /**\n     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4\n     * @type Boolean\n     * @default\n     */ evented: true,\n        /**\n     * When set to `false`, an object is not rendered on canvas\n     * @type Boolean\n     * @default\n     */ visible: true,\n        /**\n     * When set to `false`, object's controls are not displayed and can not be used to manipulate object\n     * @type Boolean\n     * @default\n     */ hasControls: true,\n        /**\n     * When set to `false`, object's controlling borders are not rendered\n     * @type Boolean\n     * @default\n     */ hasBorders: true,\n        /**\n     * When set to `true`, objects are \"found\" on canvas on per-pixel basis rather than according to bounding box\n     * @type Boolean\n     * @default\n     */ perPixelTargetFind: false,\n        /**\n     * When `false`, default object's values are not included in its serialization\n     * @type Boolean\n     * @default\n     */ includeDefaultValues: true,\n        /**\n     * When `true`, object horizontal movement is locked\n     * @type Boolean\n     * @default\n     */ lockMovementX: false,\n        /**\n     * When `true`, object vertical movement is locked\n     * @type Boolean\n     * @default\n     */ lockMovementY: false,\n        /**\n     * When `true`, object rotation is locked\n     * @type Boolean\n     * @default\n     */ lockRotation: false,\n        /**\n     * When `true`, object horizontal scaling is locked\n     * @type Boolean\n     * @default\n     */ lockScalingX: false,\n        /**\n     * When `true`, object vertical scaling is locked\n     * @type Boolean\n     * @default\n     */ lockScalingY: false,\n        /**\n     * When `true`, object horizontal skewing is locked\n     * @type Boolean\n     * @default\n     */ lockSkewingX: false,\n        /**\n     * When `true`, object vertical skewing is locked\n     * @type Boolean\n     * @default\n     */ lockSkewingY: false,\n        /**\n     * When `true`, object cannot be flipped by scaling into negative values\n     * @type Boolean\n     * @default\n     */ lockScalingFlip: false,\n        /**\n     * When `true`, object is not exported in OBJECT/JSON\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */ excludeFromExport: false,\n        /**\n     * When `true`, object is cached on an additional canvas.\n     * When `false`, object is not cached unless necessary ( clipPath )\n     * default to true\n     * @since 1.7.0\n     * @type Boolean\n     * @default true\n     */ objectCaching: objectCaching,\n        /**\n     * When `true`, object properties are checked for cache invalidation. In some particular\n     * situation you may want this to be disabled ( spray brush, very big, groups)\n     * or if your application does not allow you to modify properties for groups child you want\n     * to disable it for groups.\n     * default to false\n     * since 1.7.0\n     * @type Boolean\n     * @default false\n     */ statefullCache: false,\n        /**\n     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled\n     * too much and will be redrawn with correct details at the end of scaling.\n     * this setting is performance and application dependant.\n     * default to true\n     * since 1.7.0\n     * @type Boolean\n     * @default true\n     */ noScaleCache: true,\n        /**\n     * When `false`, the stoke width will scale with the object.\n     * When `true`, the stroke will always match the exact pixel size entered for stroke width.\n     * this Property does not work on Text classes or drawing call that uses strokeText,fillText methods\n     * default to false\n     * @since 2.6.0\n     * @type Boolean\n     * @default false\n     * @type Boolean\n     * @default false\n     */ strokeUniform: false,\n        /**\n     * When set to `true`, object's cache will be rerendered next render call.\n     * since 1.7.0\n     * @type Boolean\n     * @default true\n     */ dirty: true,\n        /**\n     * keeps the value of the last hovered corner during mouse move.\n     * 0 is no corner, or 'mt', 'ml', 'mtr' etc..\n     * It should be private, but there is no harm in using it as\n     * a read-only property.\n     * @type number|string|any\n     * @default 0\n     */ __corner: 0,\n        /**\n     * Determines if the fill or the stroke is drawn first (one of \"fill\" or \"stroke\")\n     * @type String\n     * @default\n     */ paintFirst: \"fill\",\n        /**\n     * When 'down', object is set to active on mousedown/touchstart\n     * When 'up', object is set to active on mouseup/touchend\n     * Experimental. Let's see if this breaks anything before supporting officially\n     * @private\n     * since 4.4.0\n     * @type String\n     * @default 'down'\n     */ activeOn: \"down\",\n        /**\n     * List of properties to consider when checking if state\n     * of an object is changed (fabric.Object#hasStateChanged)\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: (\"top left width height scaleX scaleY flipX flipY originX originY transformMatrix \" + \"stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit \" + \"angle opacity fill globalCompositeOperation shadow visible backgroundColor \" + \"skewX skewY fillRule paintFirst clipPath strokeUniform\").split(\" \"),\n        /**\n     * List of properties to consider when checking if cache needs refresh\n     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single\n     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty\n     * and refreshed at the next render\n     * @type Array\n     */ cacheProperties: (\"fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform\" + \" strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath\").split(\" \"),\n        /**\n     * List of properties to consider for animating colors.\n     * @type Array\n     */ colorProperties: \"fill stroke backgroundColor\".split(\" \"),\n        /**\n     * a fabricObject that, without stroke define a clipping area with their shape. filled in black\n     * the clipPath object gets used when the object has rendered, and the context is placed in the center\n     * of the object cacheCanvas.\n     * If you want 0,0 of a clipPath to align with an object center, use clipPath.originX/Y to 'center'\n     * @type fabric.Object\n     */ clipPath: undefined,\n        /**\n     * Meaningful ONLY when the object is used as clipPath.\n     * if true, the clipPath will make the object clip to the outside of the clipPath\n     * since 2.4.0\n     * @type boolean\n     * @default false\n     */ inverted: false,\n        /**\n     * Meaningful ONLY when the object is used as clipPath.\n     * if true, the clipPath will have its top and left relative to canvas, and will\n     * not be influenced by the object transform. This will make the clipPath relative\n     * to the canvas, but clipping just a particular object.\n     * WARNING this is beta, this feature may change or be renamed.\n     * since 2.4.0\n     * @type boolean\n     * @default false\n     */ absolutePositioned: false,\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            if (options) {\n                this.setOptions(options);\n            }\n        },\n        /**\n     * Create a the canvas used to keep the cached copy of the object\n     * @private\n     */ _createCacheCanvas: function() {\n            this._cacheProperties = {};\n            this._cacheCanvas = fabric.util.createCanvasElement();\n            this._cacheContext = this._cacheCanvas.getContext(\"2d\");\n            this._updateCacheCanvas();\n            // if canvas gets created, is empty, so dirty.\n            this.dirty = true;\n        },\n        /**\n     * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal\n     * and each side do not cross fabric.cacheSideLimit\n     * those numbers are configurable so that you can get as much detail as you want\n     * making bargain with performances.\n     * @param {Object} dims\n     * @param {Object} dims.width width of canvas\n     * @param {Object} dims.height height of canvas\n     * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */ _limitCacheSize: function(dims) {\n            var perfLimitSizeTotal = fabric.perfLimitSizeTotal, width = dims.width, height = dims.height, max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit;\n            if (width <= max && height <= max && width * height <= perfLimitSizeTotal) {\n                if (width < min) {\n                    dims.width = min;\n                }\n                if (height < min) {\n                    dims.height = min;\n                }\n                return dims;\n            }\n            var ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal), capValue = fabric.util.capValue, x = capValue(min, limitedDims.x, max), y = capValue(min, limitedDims.y, max);\n            if (width > x) {\n                dims.zoomX /= width / x;\n                dims.width = x;\n                dims.capped = true;\n            }\n            if (height > y) {\n                dims.zoomY /= height / y;\n                dims.height = y;\n                dims.capped = true;\n            }\n            return dims;\n        },\n        /**\n     * Return the dimension and the zoom level needed to create a cache canvas\n     * big enough to host the object to be cached.\n     * @private\n     * @return {Object}.x width of object to be cached\n     * @return {Object}.y height of object to be cached\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */ _getCacheCanvasDimensions: function() {\n            var objectScale = this.getTotalObjectScaling(), // caculate dimensions without skewing\n            dim = this._getTransformedDimensions(0, 0), neededX = dim.x * objectScale.scaleX / this.scaleX, neededY = dim.y * objectScale.scaleY / this.scaleY;\n            return {\n                // for sure this ALIASING_LIMIT is slightly creating problem\n                // in situation in which the cache canvas gets an upper limit\n                // also objectScale contains already scaleX and scaleY\n                width: neededX + ALIASING_LIMIT,\n                height: neededY + ALIASING_LIMIT,\n                zoomX: objectScale.scaleX,\n                zoomY: objectScale.scaleY,\n                x: neededX,\n                y: neededY\n            };\n        },\n        /**\n     * Update width and height of the canvas for cache\n     * returns true or false if canvas needed resize.\n     * @private\n     * @return {Boolean} true if the canvas has been resized\n     */ _updateCacheCanvas: function() {\n            var targetCanvas = this.canvas;\n            if (this.noScaleCache && targetCanvas && targetCanvas._currentTransform) {\n                var target = targetCanvas._currentTransform.target, action = targetCanvas._currentTransform.action;\n                if (this === target && action.slice && action.slice(0, 5) === \"scale\") {\n                    return false;\n                }\n            }\n            var canvas = this._cacheCanvas, dims = this._limitCacheSize(this._getCacheCanvasDimensions()), minCacheSize = fabric.minCacheSideLimit, width = dims.width, height = dims.height, drawingWidth, drawingHeight, zoomX = dims.zoomX, zoomY = dims.zoomY, dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight, zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY, shouldRedraw = dimensionsChanged || zoomChanged, additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;\n            if (dimensionsChanged) {\n                var canvasWidth = this._cacheCanvas.width, canvasHeight = this._cacheCanvas.height, sizeGrowing = width > canvasWidth || height > canvasHeight, sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) && canvasWidth > minCacheSize && canvasHeight > minCacheSize;\n                shouldResizeCanvas = sizeGrowing || sizeShrinking;\n                if (sizeGrowing && !dims.capped && (width > minCacheSize || height > minCacheSize)) {\n                    additionalWidth = width * 0.1;\n                    additionalHeight = height * 0.1;\n                }\n            }\n            if (this instanceof fabric.Text && this.path) {\n                shouldRedraw = true;\n                shouldResizeCanvas = true;\n                additionalWidth += this.getHeightOfLine(0) * this.zoomX;\n                additionalHeight += this.getHeightOfLine(0) * this.zoomY;\n            }\n            if (shouldRedraw) {\n                if (shouldResizeCanvas) {\n                    canvas.width = Math.ceil(width + additionalWidth);\n                    canvas.height = Math.ceil(height + additionalHeight);\n                } else {\n                    this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);\n                    this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);\n                }\n                drawingWidth = dims.x / 2;\n                drawingHeight = dims.y / 2;\n                this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;\n                this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;\n                this.cacheWidth = width;\n                this.cacheHeight = height;\n                this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);\n                this._cacheContext.scale(zoomX, zoomY);\n                this.zoomX = zoomX;\n                this.zoomY = zoomY;\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Sets object's properties from options\n     * @param {Object} [options] Options object\n     */ setOptions: function(options) {\n            this._setOptions(options);\n            this._initGradient(options.fill, \"fill\");\n            this._initGradient(options.stroke, \"stroke\");\n            this._initPattern(options.fill, \"fill\");\n            this._initPattern(options.stroke, \"stroke\");\n        },\n        /**\n     * Transforms context when rendering an object\n     * @param {CanvasRenderingContext2D} ctx Context\n     */ transform: function(ctx) {\n            var needFullTransform = this.group && !this.group._transformDone || this.group && this.canvas && ctx === this.canvas.contextTop;\n            var m = this.calcTransformMatrix(!needFullTransform);\n            ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n        },\n        /**\n     * Returns an object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, object = {\n                type: this.type,\n                version: fabric.version,\n                originX: this.originX,\n                originY: this.originY,\n                left: toFixed(this.left, NUM_FRACTION_DIGITS),\n                top: toFixed(this.top, NUM_FRACTION_DIGITS),\n                width: toFixed(this.width, NUM_FRACTION_DIGITS),\n                height: toFixed(this.height, NUM_FRACTION_DIGITS),\n                fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill,\n                stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke,\n                strokeWidth: toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),\n                strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,\n                strokeLineCap: this.strokeLineCap,\n                strokeDashOffset: this.strokeDashOffset,\n                strokeLineJoin: this.strokeLineJoin,\n                strokeUniform: this.strokeUniform,\n                strokeMiterLimit: toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),\n                scaleX: toFixed(this.scaleX, NUM_FRACTION_DIGITS),\n                scaleY: toFixed(this.scaleY, NUM_FRACTION_DIGITS),\n                angle: toFixed(this.angle, NUM_FRACTION_DIGITS),\n                flipX: this.flipX,\n                flipY: this.flipY,\n                opacity: toFixed(this.opacity, NUM_FRACTION_DIGITS),\n                shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow,\n                visible: this.visible,\n                backgroundColor: this.backgroundColor,\n                fillRule: this.fillRule,\n                paintFirst: this.paintFirst,\n                globalCompositeOperation: this.globalCompositeOperation,\n                skewX: toFixed(this.skewX, NUM_FRACTION_DIGITS),\n                skewY: toFixed(this.skewY, NUM_FRACTION_DIGITS)\n            };\n            if (this.clipPath && !this.clipPath.excludeFromExport) {\n                object.clipPath = this.clipPath.toObject(propertiesToInclude);\n                object.clipPath.inverted = this.clipPath.inverted;\n                object.clipPath.absolutePositioned = this.clipPath.absolutePositioned;\n            }\n            fabric.util.populateWithProperties(this, object, propertiesToInclude);\n            if (!this.includeDefaultValues) {\n                object = this._removeDefaultValues(object);\n            }\n            return object;\n        },\n        /**\n     * Returns (dataless) object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            // will be overwritten by subclasses\n            return this.toObject(propertiesToInclude);\n        },\n        /**\n     * @private\n     * @param {Object} object\n     */ _removeDefaultValues: function(object) {\n            var prototype = fabric.util.getKlass(object.type).prototype, stateProperties = prototype.stateProperties;\n            stateProperties.forEach(function(prop) {\n                if (prop === \"left\" || prop === \"top\") {\n                    return;\n                }\n                if (object[prop] === prototype[prop]) {\n                    delete object[prop];\n                }\n                // basically a check for [] === []\n                if (Array.isArray(object[prop]) && Array.isArray(prototype[prop]) && object[prop].length === 0 && prototype[prop].length === 0) {\n                    delete object[prop];\n                }\n            });\n            return object;\n        },\n        /**\n     * Returns a string representation of an instance\n     * @return {String}\n     */ toString: function() {\n            return \"#<fabric.\" + capitalize(this.type) + \">\";\n        },\n        /**\n     * Return the object scale factor counting also the group scaling\n     * @return {Object} object with scaleX and scaleY properties\n     */ getObjectScaling: function() {\n            // if the object is a top level one, on the canvas, we go for simple aritmetic\n            // otherwise the complex method with angles will return approximations and decimals\n            // and will likely kill the cache when not needed\n            // https://github.com/fabricjs/fabric.js/issues/7157\n            if (!this.group) {\n                return {\n                    scaleX: this.scaleX,\n                    scaleY: this.scaleY\n                };\n            }\n            // if we are inside a group total zoom calculation is complex, we defer to generic matrices\n            var options = fabric.util.qrDecompose(this.calcTransformMatrix());\n            return {\n                scaleX: Math.abs(options.scaleX),\n                scaleY: Math.abs(options.scaleY)\n            };\n        },\n        /**\n     * Return the object scale factor counting also the group scaling, zoom and retina\n     * @return {Object} object with scaleX and scaleY properties\n     */ getTotalObjectScaling: function() {\n            var scale = this.getObjectScaling(), scaleX = scale.scaleX, scaleY = scale.scaleY;\n            if (this.canvas) {\n                var zoom = this.canvas.getZoom();\n                var retina = this.canvas.getRetinaScaling();\n                scaleX *= zoom * retina;\n                scaleY *= zoom * retina;\n            }\n            return {\n                scaleX: scaleX,\n                scaleY: scaleY\n            };\n        },\n        /**\n     * Return the object opacity counting also the group property\n     * @return {Number}\n     */ getObjectOpacity: function() {\n            var opacity = this.opacity;\n            if (this.group) {\n                opacity *= this.group.getObjectOpacity();\n            }\n            return opacity;\n        },\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Object} thisArg\n     */ _set: function(key, value) {\n            var shouldConstrainValue = key === \"scaleX\" || key === \"scaleY\", isChanged = this[key] !== value, groupNeedsUpdate = false;\n            if (shouldConstrainValue) {\n                value = this._constrainScale(value);\n            }\n            if (key === \"scaleX\" && value < 0) {\n                this.flipX = !this.flipX;\n                value *= -1;\n            } else if (key === \"scaleY\" && value < 0) {\n                this.flipY = !this.flipY;\n                value *= -1;\n            } else if (key === \"shadow\" && value && !(value instanceof fabric.Shadow)) {\n                value = new fabric.Shadow(value);\n            } else if (key === \"dirty\" && this.group) {\n                this.group.set(\"dirty\", value);\n            }\n            this[key] = value;\n            if (isChanged) {\n                groupNeedsUpdate = this.group && this.group.isOnACache();\n                if (this.cacheProperties.indexOf(key) > -1) {\n                    this.dirty = true;\n                    groupNeedsUpdate && this.group.set(\"dirty\", true);\n                } else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {\n                    this.group.set(\"dirty\", true);\n                }\n            }\n            return this;\n        },\n        /**\n     * This callback function is called by the parent group of an object every\n     * time a non-delegated property changes on the group. It is passed the key\n     * and value as parameters. Not adding in this function's signature to avoid\n     * Travis build error about unused variables.\n     */ setOnGroup: function() {\n        // implemented by sub-classes, as needed.\n        },\n        /**\n     * Retrieves viewportTransform from Object's canvas if possible\n     * @method getViewportTransform\n     * @memberOf fabric.Object.prototype\n     * @return {Array}\n     */ getViewportTransform: function() {\n            if (this.canvas && this.canvas.viewportTransform) {\n                return this.canvas.viewportTransform;\n            }\n            return fabric.iMatrix.concat();\n        },\n        /*\n     * @private\n     * return if the object would be visible in rendering\n     * @memberOf fabric.Object.prototype\n     * @return {Boolean}\n     */ isNotVisible: function() {\n            return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;\n        },\n        /**\n     * Renders an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ render: function(ctx) {\n            // do not render if width/height are zeros or object is not visible\n            if (this.isNotVisible()) {\n                return;\n            }\n            if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {\n                return;\n            }\n            ctx.save();\n            this._setupCompositeOperation(ctx);\n            this.drawSelectionBackground(ctx);\n            this.transform(ctx);\n            this._setOpacity(ctx);\n            this._setShadow(ctx, this);\n            if (this.shouldCache()) {\n                this.renderCache();\n                this.drawCacheOnCanvas(ctx);\n            } else {\n                this._removeCacheCanvas();\n                this.dirty = false;\n                this.drawObject(ctx);\n                if (this.objectCaching && this.statefullCache) {\n                    this.saveState({\n                        propertySet: \"cacheProperties\"\n                    });\n                }\n            }\n            ctx.restore();\n        },\n        renderCache: function(options) {\n            options = options || {};\n            if (!this._cacheCanvas || !this._cacheContext) {\n                this._createCacheCanvas();\n            }\n            if (this.isCacheDirty()) {\n                this.statefullCache && this.saveState({\n                    propertySet: \"cacheProperties\"\n                });\n                this.drawObject(this._cacheContext, options.forClipping);\n                this.dirty = false;\n            }\n        },\n        /**\n     * Remove cacheCanvas and its dimensions from the objects\n     */ _removeCacheCanvas: function() {\n            this._cacheCanvas = null;\n            this._cacheContext = null;\n            this.cacheWidth = 0;\n            this.cacheHeight = 0;\n        },\n        /**\n     * return true if the object will draw a stroke\n     * Does not consider text styles. This is just a shortcut used at rendering time\n     * We want it to be an approximation and be fast.\n     * wrote to avoid extra caching, it has to return true when stroke happens,\n     * can guess when it will not happen at 100% chance, does not matter if it misses\n     * some use case where the stroke is invisible.\n     * @since 3.0.0\n     * @returns Boolean\n     */ hasStroke: function() {\n            return this.stroke && this.stroke !== \"transparent\" && this.strokeWidth !== 0;\n        },\n        /**\n     * return true if the object will draw a fill\n     * Does not consider text styles. This is just a shortcut used at rendering time\n     * We want it to be an approximation and be fast.\n     * wrote to avoid extra caching, it has to return true when fill happens,\n     * can guess when it will not happen at 100% chance, does not matter if it misses\n     * some use case where the fill is invisible.\n     * @since 3.0.0\n     * @returns Boolean\n     */ hasFill: function() {\n            return this.fill && this.fill !== \"transparent\";\n        },\n        /**\n     * When set to `true`, force the object to have its own cache, even if it is inside a group\n     * it may be needed when your object behave in a particular way on the cache and always needs\n     * its own isolated canvas to render correctly.\n     * Created to be overridden\n     * since 1.7.12\n     * @returns Boolean\n     */ needsItsOwnCache: function() {\n            if (this.paintFirst === \"stroke\" && this.hasFill() && this.hasStroke() && typeof this.shadow === \"object\") {\n                return true;\n            }\n            if (this.clipPath) {\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * objectCaching is a global flag, wins over everything\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * Read as: cache if is needed, or if the feature is enabled but we are not already caching.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.group || !this.group.isOnACache());\n            return this.ownCaching;\n        },\n        /**\n     * Check if this object or a child object will cast a shadow\n     * used by Group.shouldCache to know if child has a shadow recursively\n     * @return {Boolean}\n     */ willDrawShadow: function() {\n            return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);\n        },\n        /**\n     * Execute the drawing operation for an object clipPath\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {fabric.Object} clipPath\n     */ drawClipPathOnCache: function(ctx, clipPath) {\n            ctx.save();\n            // DEBUG: uncomment this line, comment the following\n            // ctx.globalAlpha = 0.4\n            if (clipPath.inverted) {\n                ctx.globalCompositeOperation = \"destination-out\";\n            } else {\n                ctx.globalCompositeOperation = \"destination-in\";\n            }\n            //ctx.scale(1 / 2, 1 / 2);\n            if (clipPath.absolutePositioned) {\n                var m = fabric.util.invertTransform(this.calcTransformMatrix());\n                ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            }\n            clipPath.transform(ctx);\n            ctx.scale(1 / clipPath.zoomX, 1 / clipPath.zoomY);\n            ctx.drawImage(clipPath._cacheCanvas, -clipPath.cacheTranslationX, -clipPath.cacheTranslationY);\n            ctx.restore();\n        },\n        /**\n     * Execute the drawing operation for an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawObject: function(ctx, forClipping) {\n            var originalFill = this.fill, originalStroke = this.stroke;\n            if (forClipping) {\n                this.fill = \"black\";\n                this.stroke = \"\";\n                this._setClippingProperties(ctx);\n            } else {\n                this._renderBackground(ctx);\n            }\n            this._render(ctx);\n            this._drawClipPath(ctx, this.clipPath);\n            this.fill = originalFill;\n            this.stroke = originalStroke;\n        },\n        /**\n     * Prepare clipPath state and cache and draw it on instance's cache\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {fabric.Object} clipPath\n     */ _drawClipPath: function(ctx, clipPath) {\n            if (!clipPath) {\n                return;\n            }\n            // needed to setup a couple of variables\n            // path canvas gets overridden with this one.\n            // TODO find a better solution?\n            clipPath.canvas = this.canvas;\n            clipPath.shouldCache();\n            clipPath._transformDone = true;\n            clipPath.renderCache({\n                forClipping: true\n            });\n            this.drawClipPathOnCache(ctx, clipPath);\n        },\n        /**\n     * Paint the cached copy of the object on the target context.\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawCacheOnCanvas: function(ctx) {\n            ctx.scale(1 / this.zoomX, 1 / this.zoomY);\n            ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);\n        },\n        /**\n     * Check if cache is dirty\n     * @param {Boolean} skipCanvas skip canvas checks because this object is painted\n     * on parent canvas.\n     */ isCacheDirty: function(skipCanvas) {\n            if (this.isNotVisible()) {\n                return false;\n            }\n            if (this._cacheCanvas && this._cacheContext && !skipCanvas && this._updateCacheCanvas()) {\n                // in this case the context is already cleared.\n                return true;\n            } else {\n                if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged(\"cacheProperties\")) {\n                    if (this._cacheCanvas && this._cacheContext && !skipCanvas) {\n                        var width = this.cacheWidth / this.zoomX;\n                        var height = this.cacheHeight / this.zoomY;\n                        this._cacheContext.clearRect(-width / 2, -height / 2, width, height);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Draws a background for the object big as its untransformed dimensions\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderBackground: function(ctx) {\n            if (!this.backgroundColor) {\n                return;\n            }\n            var dim = this._getNonTransformedDimensions();\n            ctx.fillStyle = this.backgroundColor;\n            ctx.fillRect(-dim.x / 2, -dim.y / 2, dim.x, dim.y);\n            // if there is background color no other shadows\n            // should be casted\n            this._removeShadow(ctx);\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _setOpacity: function(ctx) {\n            if (this.group && !this.group._transformDone) {\n                ctx.globalAlpha = this.getObjectOpacity();\n            } else {\n                ctx.globalAlpha *= this.opacity;\n            }\n        },\n        _setStrokeStyles: function(ctx, decl) {\n            var stroke = decl.stroke;\n            if (stroke) {\n                ctx.lineWidth = decl.strokeWidth;\n                ctx.lineCap = decl.strokeLineCap;\n                ctx.lineDashOffset = decl.strokeDashOffset;\n                ctx.lineJoin = decl.strokeLineJoin;\n                ctx.miterLimit = decl.strokeMiterLimit;\n                if (stroke.toLive) {\n                    if (stroke.gradientUnits === \"percentage\" || stroke.gradientTransform || stroke.patternTransform) {\n                        // need to transform gradient in a pattern.\n                        // this is a slow process. If you are hitting this codepath, and the object\n                        // is not using caching, you should consider switching it on.\n                        // we need a canvas as big as the current object caching canvas.\n                        this._applyPatternForTransformedGradient(ctx, stroke);\n                    } else {\n                        // is a simple gradient or pattern\n                        ctx.strokeStyle = stroke.toLive(ctx, this);\n                        this._applyPatternGradientTransform(ctx, stroke);\n                    }\n                } else {\n                    // is a color\n                    ctx.strokeStyle = decl.stroke;\n                }\n            }\n        },\n        _setFillStyles: function(ctx, decl) {\n            var fill = decl.fill;\n            if (fill) {\n                if (fill.toLive) {\n                    ctx.fillStyle = fill.toLive(ctx, this);\n                    this._applyPatternGradientTransform(ctx, decl.fill);\n                } else {\n                    ctx.fillStyle = fill;\n                }\n            }\n        },\n        _setClippingProperties: function(ctx) {\n            ctx.globalAlpha = 1;\n            ctx.strokeStyle = \"transparent\";\n            ctx.fillStyle = \"#000000\";\n        },\n        /**\n     * @private\n     * Sets line dash\n     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on\n     * @param {Array} dashArray array representing dashes\n     */ _setLineDash: function(ctx, dashArray) {\n            if (!dashArray || dashArray.length === 0) {\n                return;\n            }\n            // Spec requires the concatenation of two copies the dash list when the number of elements is odd\n            if (1 & dashArray.length) {\n                dashArray.push.apply(dashArray, dashArray);\n            }\n            ctx.setLineDash(dashArray);\n        },\n        /**\n     * Renders controls and borders for the object\n     * the context here is not transformed\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [styleOverride] properties to override the object style\n     */ _renderControls: function(ctx, styleOverride) {\n            var vpt = this.getViewportTransform(), matrix = this.calcTransformMatrix(), options, drawBorders, drawControls;\n            styleOverride = styleOverride || {};\n            drawBorders = typeof styleOverride.hasBorders !== \"undefined\" ? styleOverride.hasBorders : this.hasBorders;\n            drawControls = typeof styleOverride.hasControls !== \"undefined\" ? styleOverride.hasControls : this.hasControls;\n            matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);\n            options = fabric.util.qrDecompose(matrix);\n            ctx.save();\n            ctx.translate(options.translateX, options.translateY);\n            ctx.lineWidth = 1 * this.borderScaleFactor;\n            if (!this.group) {\n                ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\n            }\n            if (this.flipX) {\n                options.angle -= 180;\n            }\n            ctx.rotate(degreesToRadians(this.group ? options.angle : this.angle));\n            if (styleOverride.forActiveSelection || this.group) {\n                drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);\n            } else {\n                drawBorders && this.drawBorders(ctx, styleOverride);\n            }\n            drawControls && this.drawControls(ctx, styleOverride);\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _setShadow: function(ctx) {\n            if (!this.shadow) {\n                return;\n            }\n            var shadow = this.shadow, canvas = this.canvas, scaling, multX = canvas && canvas.viewportTransform[0] || 1, multY = canvas && canvas.viewportTransform[3] || 1;\n            if (shadow.nonScaling) {\n                scaling = {\n                    scaleX: 1,\n                    scaleY: 1\n                };\n            } else {\n                scaling = this.getObjectScaling();\n            }\n            if (canvas && canvas._isRetinaScaling()) {\n                multX *= fabric.devicePixelRatio;\n                multY *= fabric.devicePixelRatio;\n            }\n            ctx.shadowColor = shadow.color;\n            ctx.shadowBlur = shadow.blur * fabric.browserShadowBlurConstant * (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;\n            ctx.shadowOffsetX = shadow.offsetX * multX * scaling.scaleX;\n            ctx.shadowOffsetY = shadow.offsetY * multY * scaling.scaleY;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _removeShadow: function(ctx) {\n            if (!this.shadow) {\n                return;\n            }\n            ctx.shadowColor = \"\";\n            ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} filler fabric.Pattern or fabric.Gradient\n     * @return {Object} offset.offsetX offset for text rendering\n     * @return {Object} offset.offsetY offset for text rendering\n     */ _applyPatternGradientTransform: function(ctx, filler) {\n            if (!filler || !filler.toLive) {\n                return {\n                    offsetX: 0,\n                    offsetY: 0\n                };\n            }\n            var t = filler.gradientTransform || filler.patternTransform;\n            var offsetX = -this.width / 2 + filler.offsetX || 0, offsetY = -this.height / 2 + filler.offsetY || 0;\n            if (filler.gradientUnits === \"percentage\") {\n                ctx.transform(this.width, 0, 0, this.height, offsetX, offsetY);\n            } else {\n                ctx.transform(1, 0, 0, 1, offsetX, offsetY);\n            }\n            if (t) {\n                ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);\n            }\n            return {\n                offsetX: offsetX,\n                offsetY: offsetY\n            };\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderPaintInOrder: function(ctx) {\n            if (this.paintFirst === \"stroke\") {\n                this._renderStroke(ctx);\n                this._renderFill(ctx);\n            } else {\n                this._renderFill(ctx);\n                this._renderStroke(ctx);\n            }\n        },\n        /**\n     * @private\n     * function that actually render something on the context.\n     * empty here to allow Obects to work on tests to benchmark fabric functionalites\n     * not related to rendering\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function() {},\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderFill: function(ctx) {\n            if (!this.fill) {\n                return;\n            }\n            ctx.save();\n            this._setFillStyles(ctx, this);\n            if (this.fillRule === \"evenodd\") {\n                ctx.fill(\"evenodd\");\n            } else {\n                ctx.fill();\n            }\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderStroke: function(ctx) {\n            if (!this.stroke || this.strokeWidth === 0) {\n                return;\n            }\n            if (this.shadow && !this.shadow.affectStroke) {\n                this._removeShadow(ctx);\n            }\n            ctx.save();\n            if (this.strokeUniform && this.group) {\n                var scaling = this.getObjectScaling();\n                ctx.scale(1 / scaling.scaleX, 1 / scaling.scaleY);\n            } else if (this.strokeUniform) {\n                ctx.scale(1 / this.scaleX, 1 / this.scaleY);\n            }\n            this._setLineDash(ctx, this.strokeDashArray);\n            this._setStrokeStyles(ctx, this);\n            ctx.stroke();\n            ctx.restore();\n        },\n        /**\n     * This function try to patch the missing gradientTransform on canvas gradients.\n     * transforming a context to transform the gradient, is going to transform the stroke too.\n     * we want to transform the gradient but not the stroke operation, so we create\n     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.\n     * this method has drwabacks: is slow, is in low resolution, needs a patch for when the size\n     * is limited.\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {fabric.Gradient} filler a fabric gradient instance\n     */ _applyPatternForTransformedGradient: function(ctx, filler) {\n            var dims = this._limitCacheSize(this._getCacheCanvasDimensions()), pCanvas = fabric.util.createCanvasElement(), pCtx, retinaScaling = this.canvas.getRetinaScaling(), width = dims.x / this.scaleX / retinaScaling, height = dims.y / this.scaleY / retinaScaling;\n            pCanvas.width = width;\n            pCanvas.height = height;\n            pCtx = pCanvas.getContext(\"2d\");\n            pCtx.beginPath();\n            pCtx.moveTo(0, 0);\n            pCtx.lineTo(width, 0);\n            pCtx.lineTo(width, height);\n            pCtx.lineTo(0, height);\n            pCtx.closePath();\n            pCtx.translate(width / 2, height / 2);\n            pCtx.scale(dims.zoomX / this.scaleX / retinaScaling, dims.zoomY / this.scaleY / retinaScaling);\n            this._applyPatternGradientTransform(pCtx, filler);\n            pCtx.fillStyle = filler.toLive(ctx);\n            pCtx.fill();\n            ctx.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2);\n            ctx.scale(retinaScaling * this.scaleX / dims.zoomX, retinaScaling * this.scaleY / dims.zoomY);\n            ctx.strokeStyle = pCtx.createPattern(pCanvas, \"no-repeat\");\n        },\n        /**\n     * This function is an helper for svg import. it returns the center of the object in the svg\n     * untransformed coordinates\n     * @private\n     * @return {Object} center point from element coordinates\n     */ _findCenterFromElement: function() {\n            return {\n                x: this.left + this.width / 2,\n                y: this.top + this.height / 2\n            };\n        },\n        /**\n     * This function is an helper for svg import. it decompose the transformMatrix\n     * and assign properties to object.\n     * untransformed coordinates\n     * @private\n     * @chainable\n     */ _assignTransformMatrixProps: function() {\n            if (this.transformMatrix) {\n                var options = fabric.util.qrDecompose(this.transformMatrix);\n                this.flipX = false;\n                this.flipY = false;\n                this.set(\"scaleX\", options.scaleX);\n                this.set(\"scaleY\", options.scaleY);\n                this.angle = options.angle;\n                this.skewX = options.skewX;\n                this.skewY = 0;\n            }\n        },\n        /**\n     * This function is an helper for svg import. it removes the transform matrix\n     * and set to object properties that fabricjs can handle\n     * @private\n     * @param {Object} preserveAspectRatioOptions\n     * @return {thisArg}\n     */ _removeTransformMatrix: function(preserveAspectRatioOptions) {\n            var center = this._findCenterFromElement();\n            if (this.transformMatrix) {\n                this._assignTransformMatrixProps();\n                center = fabric.util.transformPoint(center, this.transformMatrix);\n            }\n            this.transformMatrix = null;\n            if (preserveAspectRatioOptions) {\n                this.scaleX *= preserveAspectRatioOptions.scaleX;\n                this.scaleY *= preserveAspectRatioOptions.scaleY;\n                this.cropX = preserveAspectRatioOptions.cropX;\n                this.cropY = preserveAspectRatioOptions.cropY;\n                center.x += preserveAspectRatioOptions.offsetLeft;\n                center.y += preserveAspectRatioOptions.offsetTop;\n                this.width = preserveAspectRatioOptions.width;\n                this.height = preserveAspectRatioOptions.height;\n            }\n            this.setPositionByOrigin(center, \"center\", \"center\");\n        },\n        /**\n     * Clones an instance, using a callback method will work for every object.\n     * @param {Function} callback Callback is invoked with a clone as a first argument\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     */ clone: function(callback, propertiesToInclude) {\n            var objectForm = this.toObject(propertiesToInclude);\n            if (this.constructor.fromObject) {\n                this.constructor.fromObject(objectForm, callback);\n            } else {\n                fabric.Object._fromObject(\"Object\", objectForm, callback);\n            }\n        },\n        /**\n     * Creates an instance of fabric.Image out of an object\n     * makes use of toCanvasElement.\n     * Once this method was based on toDataUrl and loadImage, so it also had a quality\n     * and format option. toCanvasElement is faster and produce no loss of quality.\n     * If you need to get a real Jpeg or Png from an object, using toDataURL is the right way to do it.\n     * toCanvasElement and then toBlob from the obtained canvas is also a good option.\n     * This method is sync now, but still support the callback because we did not want to break.\n     * When fabricJS 5.0 will be planned, this will probably be changed to not have a callback.\n     * @param {Function} callback callback, invoked with an instance as a first argument\n     * @param {Object} [options] for clone as image, passed to toDataURL\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {fabric.Object} thisArg\n     */ cloneAsImage: function(callback, options) {\n            var canvasEl = this.toCanvasElement(options);\n            if (callback) {\n                callback(new fabric.Image(canvasEl));\n            }\n            return this;\n        },\n        /**\n     * Converts an object into a HTMLCanvas element\n     * @param {Object} options Options object\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {HTMLCanvasElement} Returns DOM element <canvas> with the fabric.Object\n     */ toCanvasElement: function(options) {\n            options || (options = {});\n            var utils = fabric.util, origParams = utils.saveObjectTransform(this), originalGroup = this.group, originalShadow = this.shadow, abs = Math.abs, multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? fabric.devicePixelRatio : 1);\n            delete this.group;\n            if (options.withoutTransform) {\n                utils.resetObjectTransform(this);\n            }\n            if (options.withoutShadow) {\n                this.shadow = null;\n            }\n            var el = fabric.util.createCanvasElement(), // skip canvas zoom and calculate with setCoords now.\n            boundingRect = this.getBoundingRect(true, true), shadow = this.shadow, scaling, shadowOffset = {\n                x: 0,\n                y: 0\n            }, shadowBlur, width, height;\n            if (shadow) {\n                shadowBlur = shadow.blur;\n                if (shadow.nonScaling) {\n                    scaling = {\n                        scaleX: 1,\n                        scaleY: 1\n                    };\n                } else {\n                    scaling = this.getObjectScaling();\n                }\n                // consider non scaling shadow.\n                shadowOffset.x = 2 * Math.round(abs(shadow.offsetX) + shadowBlur) * abs(scaling.scaleX);\n                shadowOffset.y = 2 * Math.round(abs(shadow.offsetY) + shadowBlur) * abs(scaling.scaleY);\n            }\n            width = boundingRect.width + shadowOffset.x;\n            height = boundingRect.height + shadowOffset.y;\n            // if the current width/height is not an integer\n            // we need to make it so.\n            el.width = Math.ceil(width);\n            el.height = Math.ceil(height);\n            var canvas = new fabric.StaticCanvas(el, {\n                enableRetinaScaling: false,\n                renderOnAddRemove: false,\n                skipOffscreen: false\n            });\n            if (options.format === \"jpeg\") {\n                canvas.backgroundColor = \"#fff\";\n            }\n            this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), \"center\", \"center\");\n            var originalCanvas = this.canvas;\n            canvas.add(this);\n            var canvasEl = canvas.toCanvasElement(multiplier || 1, options);\n            this.shadow = originalShadow;\n            this.set(\"canvas\", originalCanvas);\n            if (originalGroup) {\n                this.group = originalGroup;\n            }\n            this.set(origParams).setCoords();\n            // canvas.dispose will call image.dispose that will nullify the elements\n            // since this canvas is a simple element for the process, we remove references\n            // to objects in this way in order to avoid object trashing.\n            canvas._objects = [];\n            canvas.dispose();\n            canvas = null;\n            return canvasEl;\n        },\n        /**\n     * Converts an object into a data-url-like string\n     * @param {Object} options Options object\n     * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\n     */ toDataURL: function(options) {\n            options || (options = {});\n            return fabric.util.toDataURL(this.toCanvasElement(options), options.format || \"png\", options.quality || 1);\n        },\n        /**\n     * Returns true if specified type is identical to the type of an instance\n     * @param {String} type Type to check against\n     * @return {Boolean}\n     */ isType: function(type) {\n            return arguments.length > 1 ? Array.from(arguments).includes(this.type) : this.type === type;\n        },\n        /**\n     * Returns complexity of an instance\n     * @return {Number} complexity of this instance (is 1 unless subclassed)\n     */ complexity: function() {\n            return 1;\n        },\n        /**\n     * Returns a JSON representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} JSON\n     */ toJSON: function(propertiesToInclude) {\n            // delegate, not alias\n            return this.toObject(propertiesToInclude);\n        },\n        /**\n     * Sets \"angle\" of an instance with centered rotation\n     * @param {Number} angle Angle value (in degrees)\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ rotate: function(angle) {\n            var shouldCenterOrigin = (this.originX !== \"center\" || this.originY !== \"center\") && this.centeredRotation;\n            if (shouldCenterOrigin) {\n                this._setOriginToCenter();\n            }\n            this.set(\"angle\", angle);\n            if (shouldCenterOrigin) {\n                this._resetOrigin();\n            }\n            return this;\n        },\n        /**\n     * Centers object horizontally on canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ centerH: function() {\n            this.canvas && this.canvas.centerObjectH(this);\n            return this;\n        },\n        /**\n     * Centers object horizontally on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ viewportCenterH: function() {\n            this.canvas && this.canvas.viewportCenterObjectH(this);\n            return this;\n        },\n        /**\n     * Centers object vertically on canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ centerV: function() {\n            this.canvas && this.canvas.centerObjectV(this);\n            return this;\n        },\n        /**\n     * Centers object vertically on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ viewportCenterV: function() {\n            this.canvas && this.canvas.viewportCenterObjectV(this);\n            return this;\n        },\n        /**\n     * Centers object vertically and horizontally on canvas to which is was added last\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ center: function() {\n            this.canvas && this.canvas.centerObject(this);\n            return this;\n        },\n        /**\n     * Centers object on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ viewportCenter: function() {\n            this.canvas && this.canvas.viewportCenterObject(this);\n            return this;\n        },\n        /**\n     * Returns coordinates of a pointer relative to an object\n     * @param {Event} e Event to operate upon\n     * @param {Object} [pointer] Pointer to operate upon (instead of event)\n     * @return {Object} Coordinates of a pointer (x, y)\n     */ getLocalPointer: function(e, pointer) {\n            pointer = pointer || this.canvas.getPointer(e);\n            var pClicked = new fabric.Point(pointer.x, pointer.y), objectLeftTop = this._getLeftTopCoords();\n            if (this.angle) {\n                pClicked = fabric.util.rotatePoint(pClicked, objectLeftTop, degreesToRadians(-this.angle));\n            }\n            return {\n                x: pClicked.x - objectLeftTop.x,\n                y: pClicked.y - objectLeftTop.y\n            };\n        },\n        /**\n     * Sets canvas globalCompositeOperation for specific object\n     * custom composition operation for the particular object can be specified using globalCompositeOperation property\n     * @param {CanvasRenderingContext2D} ctx Rendering canvas context\n     */ _setupCompositeOperation: function(ctx) {\n            if (this.globalCompositeOperation) {\n                ctx.globalCompositeOperation = this.globalCompositeOperation;\n            }\n        },\n        /**\n     * cancel instance's running animations\n     * override if necessary to dispose artifacts such as `clipPath`\n     */ dispose: function() {\n            if (fabric.runningAnimations) {\n                fabric.runningAnimations.cancelByTarget(this);\n            }\n        }\n    });\n    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Object);\n    extend(fabric.Object.prototype, fabric.Observable);\n    /**\n   * Defines the number of fraction digits to use when serializing object values.\n   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.\n   * @static\n   * @memberOf fabric.Object\n   * @constant\n   * @type Number\n   */ fabric.Object.NUM_FRACTION_DIGITS = 2;\n    /**\n   * Defines which properties should be enlivened from the object passed to {@link fabric.Object._fromObject}\n   * @static\n   * @memberOf fabric.Object\n   * @constant\n   * @type string[]\n   */ fabric.Object.ENLIVEN_PROPS = [\n        \"clipPath\"\n    ];\n    fabric.Object._fromObject = function(className, object, callback, extraParam) {\n        var klass = fabric[className];\n        object = clone(object, true);\n        fabric.util.enlivenPatterns([\n            object.fill,\n            object.stroke\n        ], function(patterns) {\n            if (typeof patterns[0] !== \"undefined\") {\n                object.fill = patterns[0];\n            }\n            if (typeof patterns[1] !== \"undefined\") {\n                object.stroke = patterns[1];\n            }\n            fabric.util.enlivenObjectEnlivables(object, object, function() {\n                var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);\n                callback && callback(instance);\n            });\n        });\n    };\n    /**\n   * Unique id used internally when creating SVG elements\n   * @static\n   * @memberOf fabric.Object\n   * @type Number\n   */ fabric.Object.__uid = 0;\n})( true ? exports : 0);\n(function() {\n    var degreesToRadians = fabric.util.degreesToRadians, originXOffset = {\n        left: -0.5,\n        center: 0,\n        right: 0.5\n    }, originYOffset = {\n        top: -0.5,\n        center: 0,\n        bottom: 0.5\n    };\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Translates the coordinates from a set of origin to another (based on the object's dimensions)\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'\n     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {\n            var x = point.x, y = point.y, offsetX, offsetY, dim;\n            if (typeof fromOriginX === \"string\") {\n                fromOriginX = originXOffset[fromOriginX];\n            } else {\n                fromOriginX -= 0.5;\n            }\n            if (typeof toOriginX === \"string\") {\n                toOriginX = originXOffset[toOriginX];\n            } else {\n                toOriginX -= 0.5;\n            }\n            offsetX = toOriginX - fromOriginX;\n            if (typeof fromOriginY === \"string\") {\n                fromOriginY = originYOffset[fromOriginY];\n            } else {\n                fromOriginY -= 0.5;\n            }\n            if (typeof toOriginY === \"string\") {\n                toOriginY = originYOffset[toOriginY];\n            } else {\n                toOriginY -= 0.5;\n            }\n            offsetY = toOriginY - fromOriginY;\n            if (offsetX || offsetY) {\n                dim = this._getTransformedDimensions();\n                x = point.x + offsetX * dim.x;\n                y = point.y + offsetY * dim.y;\n            }\n            return new fabric.Point(x, y);\n        },\n        /**\n     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ translateToCenterPoint: function(point, originX, originY) {\n            var p = this.translateToGivenOrigin(point, originX, originY, \"center\", \"center\");\n            if (this.angle) {\n                return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));\n            }\n            return p;\n        },\n        /**\n     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)\n     * @param {fabric.Point} center The point which corresponds to center of the object\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ translateToOriginPoint: function(center, originX, originY) {\n            var p = this.translateToGivenOrigin(center, \"center\", \"center\", originX, originY);\n            if (this.angle) {\n                return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));\n            }\n            return p;\n        },\n        /**\n     * Returns the real center coordinates of the object\n     * @return {fabric.Point}\n     */ getCenterPoint: function() {\n            var leftTop = new fabric.Point(this.left, this.top);\n            return this.translateToCenterPoint(leftTop, this.originX, this.originY);\n        },\n        /**\n     * Returns the coordinates of the object based on center coordinates\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @return {fabric.Point}\n     */ // getOriginPoint: function(center) {\n        //   return this.translateToOriginPoint(center, this.originX, this.originY);\n        // },\n        /**\n     * Returns the coordinates of the object as if it has a different origin\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ getPointByOrigin: function(originX, originY) {\n            var center = this.getCenterPoint();\n            return this.translateToOriginPoint(center, originX, originY);\n        },\n        /**\n     * Returns the point in local coordinates\n     * @param {fabric.Point} point The point relative to the global coordinate system\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ toLocalPoint: function(point, originX, originY) {\n            var center = this.getCenterPoint(), p, p2;\n            if (typeof originX !== \"undefined\" && typeof originY !== \"undefined\") {\n                p = this.translateToGivenOrigin(center, \"center\", \"center\", originX, originY);\n            } else {\n                p = new fabric.Point(this.left, this.top);\n            }\n            p2 = new fabric.Point(point.x, point.y);\n            if (this.angle) {\n                p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));\n            }\n            return p2.subtractEquals(p);\n        },\n        /**\n     * Returns the point in global coordinates\n     * @param {fabric.Point} The point relative to the local coordinate system\n     * @return {fabric.Point}\n     */ // toGlobalPoint: function(point) {\n        //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));\n        // },\n        /**\n     * Sets the position of the object taking into consideration the object's origin\n     * @param {fabric.Point} pos The new position of the object\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {void}\n     */ setPositionByOrigin: function(pos, originX, originY) {\n            var center = this.translateToCenterPoint(pos, originX, originY), position = this.translateToOriginPoint(center, this.originX, this.originY);\n            this.set(\"left\", position.x);\n            this.set(\"top\", position.y);\n        },\n        /**\n     * @param {String} to One of 'left', 'center', 'right'\n     */ adjustPosition: function(to) {\n            var angle = degreesToRadians(this.angle), hypotFull = this.getScaledWidth(), xFull = fabric.util.cos(angle) * hypotFull, yFull = fabric.util.sin(angle) * hypotFull, offsetFrom, offsetTo;\n            //TODO: this function does not consider mixed situation like top, center.\n            if (typeof this.originX === \"string\") {\n                offsetFrom = originXOffset[this.originX];\n            } else {\n                offsetFrom = this.originX - 0.5;\n            }\n            if (typeof to === \"string\") {\n                offsetTo = originXOffset[to];\n            } else {\n                offsetTo = to - 0.5;\n            }\n            this.left += xFull * (offsetTo - offsetFrom);\n            this.top += yFull * (offsetTo - offsetFrom);\n            this.setCoords();\n            this.originX = to;\n        },\n        /**\n     * Sets the origin/position of the object to it's center point\n     * @private\n     * @return {void}\n     */ _setOriginToCenter: function() {\n            this._originalOriginX = this.originX;\n            this._originalOriginY = this.originY;\n            var center = this.getCenterPoint();\n            this.originX = \"center\";\n            this.originY = \"center\";\n            this.left = center.x;\n            this.top = center.y;\n        },\n        /**\n     * Resets the origin/position of the object to it's original origin\n     * @private\n     * @return {void}\n     */ _resetOrigin: function() {\n            var originPoint = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY);\n            this.originX = this._originalOriginX;\n            this.originY = this._originalOriginY;\n            this.left = originPoint.x;\n            this.top = originPoint.y;\n            this._originalOriginX = null;\n            this._originalOriginY = null;\n        },\n        /**\n     * @private\n     */ _getLeftTopCoords: function() {\n            return this.translateToOriginPoint(this.getCenterPoint(), \"left\", \"top\");\n        }\n    });\n})();\n(function() {\n    function arrayFromCoords(coords) {\n        return [\n            new fabric.Point(coords.tl.x, coords.tl.y),\n            new fabric.Point(coords.tr.x, coords.tr.y),\n            new fabric.Point(coords.br.x, coords.br.y),\n            new fabric.Point(coords.bl.x, coords.bl.y)\n        ];\n    }\n    var util = fabric.util, degreesToRadians = util.degreesToRadians, multiplyMatrices = util.multiplyTransformMatrices, transformPoint = util.transformPoint;\n    util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Describe object's corner position in canvas element coordinates.\n     * properties are depending on control keys and padding the main controls.\n     * each property is an object with x, y and corner.\n     * The `corner` property contains in a similar manner the 4 points of the\n     * interactive area of the corner.\n     * The coordinates depends from the controls positionHandler and are used\n     * to draw and locate controls\n     * @memberOf fabric.Object.prototype\n     */ oCoords: null,\n        /**\n     * Describe object's corner position in canvas object absolute coordinates\n     * properties are tl,tr,bl,br and describe the four main corner.\n     * each property is an object with x, y, instance of Fabric.Point.\n     * The coordinates depends from this properties: width, height, scaleX, scaleY\n     * skewX, skewY, angle, strokeWidth, top, left.\n     * Those coordinates are useful to understand where an object is. They get updated\n     * with oCoords but they do not need to be updated when zoom or panning change.\n     * The coordinates get updated with @method setCoords.\n     * You can calculate them without updating with @method calcACoords();\n     * @memberOf fabric.Object.prototype\n     */ aCoords: null,\n        /**\n     * Describe object's corner position in canvas element coordinates.\n     * includes padding. Used of object detection.\n     * set and refreshed with setCoords.\n     * @memberOf fabric.Object.prototype\n     */ lineCoords: null,\n        /**\n     * storage for object transform matrix\n     */ ownMatrixCache: null,\n        /**\n     * storage for object full transform matrix\n     */ matrixCache: null,\n        /**\n     * custom controls interface\n     * controls are added by default_controls.js\n     */ controls: {},\n        /**\n     * return correct set of coordinates for intersection\n     * this will return either aCoords or lineCoords.\n     * @param {Boolean} absolute will return aCoords if true or lineCoords\n     * @return {Object} {tl, tr, br, bl} points\n     */ _getCoords: function(absolute, calculate) {\n            if (calculate) {\n                return absolute ? this.calcACoords() : this.calcLineCoords();\n            }\n            if (!this.aCoords || !this.lineCoords) {\n                this.setCoords(true);\n            }\n            return absolute ? this.aCoords : this.lineCoords;\n        },\n        /**\n     * return correct set of coordinates for intersection\n     * this will return either aCoords or lineCoords.\n     * The coords are returned in an array.\n     * @return {Array} [tl, tr, br, bl] of points\n     */ getCoords: function(absolute, calculate) {\n            return arrayFromCoords(this._getCoords(absolute, calculate));\n        },\n        /**\n     * Checks if object intersects with an area formed by 2 points\n     * @param {Object} pointTL top-left point of area\n     * @param {Object} pointBR bottom-right point of area\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object intersects with an area formed by 2 points\n     */ intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {\n            var coords = this.getCoords(absolute, calculate), intersection = fabric.Intersection.intersectPolygonRectangle(coords, pointTL, pointBR);\n            return intersection.status === \"Intersection\";\n        },\n        /**\n     * Checks if object intersects with another object\n     * @param {Object} other Object to test\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object intersects with another object\n     */ intersectsWithObject: function(other, absolute, calculate) {\n            var intersection = fabric.Intersection.intersectPolygonPolygon(this.getCoords(absolute, calculate), other.getCoords(absolute, calculate));\n            return intersection.status === \"Intersection\" || other.isContainedWithinObject(this, absolute, calculate) || this.isContainedWithinObject(other, absolute, calculate);\n        },\n        /**\n     * Checks if object is fully contained within area of another object\n     * @param {Object} other Object to test\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is fully contained within area of another object\n     */ isContainedWithinObject: function(other, absolute, calculate) {\n            var points = this.getCoords(absolute, calculate), otherCoords = absolute ? other.aCoords : other.lineCoords, i = 0, lines = other._getImageLines(otherCoords);\n            for(; i < 4; i++){\n                if (!other.containsPoint(points[i], lines)) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        /**\n     * Checks if object is fully contained within area formed by 2 points\n     * @param {Object} pointTL top-left point of area\n     * @param {Object} pointBR bottom-right point of area\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is fully contained within area formed by 2 points\n     */ isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {\n            var boundingRect = this.getBoundingRect(absolute, calculate);\n            return boundingRect.left >= pointTL.x && boundingRect.left + boundingRect.width <= pointBR.x && boundingRect.top >= pointTL.y && boundingRect.top + boundingRect.height <= pointBR.y;\n        },\n        /**\n     * Checks if point is inside the object\n     * @param {fabric.Point} point Point to check against\n     * @param {Object} [lines] object returned from @method _getImageLines\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if point is inside the object\n     */ containsPoint: function(point, lines, absolute, calculate) {\n            var coords = this._getCoords(absolute, calculate), lines = lines || this._getImageLines(coords), xPoints = this._findCrossPoints(point, lines);\n            // if xPoints is odd then point is inside the object\n            return xPoints !== 0 && xPoints % 2 === 1;\n        },\n        /**\n     * Checks if object is contained within the canvas with current viewportTransform\n     * the check is done stopping at first point that appears on screen\n     * @param {Boolean} [calculate] use coordinates of current position instead of .aCoords\n     * @return {Boolean} true if object is fully or partially contained within canvas\n     */ isOnScreen: function(calculate) {\n            if (!this.canvas) {\n                return false;\n            }\n            var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;\n            var points = this.getCoords(true, calculate);\n            // if some point is on screen, the object is on screen.\n            if (points.some(function(point) {\n                return point.x <= pointBR.x && point.x >= pointTL.x && point.y <= pointBR.y && point.y >= pointTL.y;\n            })) {\n                return true;\n            }\n            // no points on screen, check intersection with absolute coordinates\n            if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {\n                return true;\n            }\n            return this._containsCenterOfCanvas(pointTL, pointBR, calculate);\n        },\n        /**\n     * Checks if the object contains the midpoint between canvas extremities\n     * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen\n     * @private\n     * @param {Fabric.Point} pointTL Top Left point\n     * @param {Fabric.Point} pointBR Top Right point\n     * @param {Boolean} calculate use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if the object contains the point\n     */ _containsCenterOfCanvas: function(pointTL, pointBR, calculate) {\n            // worst case scenario the object is so big that contains the screen\n            var centerPoint = {\n                x: (pointTL.x + pointBR.x) / 2,\n                y: (pointTL.y + pointBR.y) / 2\n            };\n            if (this.containsPoint(centerPoint, null, true, calculate)) {\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Checks if object is partially contained within the canvas with current viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is partially contained within canvas\n     */ isPartiallyOnScreen: function(calculate) {\n            if (!this.canvas) {\n                return false;\n            }\n            var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;\n            if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {\n                return true;\n            }\n            var allPointsAreOutside = this.getCoords(true, calculate).every(function(point) {\n                return (point.x >= pointBR.x || point.x <= pointTL.x) && (point.y >= pointBR.y || point.y <= pointTL.y);\n            });\n            return allPointsAreOutside && this._containsCenterOfCanvas(pointTL, pointBR, calculate);\n        },\n        /**\n     * Method that returns an object with the object edges in it, given the coordinates of the corners\n     * @private\n     * @param {Object} oCoords Coordinates of the object corners\n     */ _getImageLines: function(oCoords) {\n            var lines = {\n                topline: {\n                    o: oCoords.tl,\n                    d: oCoords.tr\n                },\n                rightline: {\n                    o: oCoords.tr,\n                    d: oCoords.br\n                },\n                bottomline: {\n                    o: oCoords.br,\n                    d: oCoords.bl\n                },\n                leftline: {\n                    o: oCoords.bl,\n                    d: oCoords.tl\n                }\n            };\n            // // debugging\n            // if (this.canvas.contextTop) {\n            //   this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);\n            //\n            //   this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);\n            //\n            //   this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);\n            //\n            //   this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);\n            // }\n            return lines;\n        },\n        /**\n     * Helper method to determine how many cross points are between the 4 object edges\n     * and the horizontal line determined by a point on canvas\n     * @private\n     * @param {fabric.Point} point Point to check\n     * @param {Object} lines Coordinates of the object being evaluated\n     */ // remove yi, not used but left code here just in case.\n        _findCrossPoints: function(point, lines) {\n            var b1, b2, a1, a2, xi, xcount = 0, iLine;\n            for(var lineKey in lines){\n                iLine = lines[lineKey];\n                // optimisation 1: line below point. no cross\n                if (iLine.o.y < point.y && iLine.d.y < point.y) {\n                    continue;\n                }\n                // optimisation 2: line above point. no cross\n                if (iLine.o.y >= point.y && iLine.d.y >= point.y) {\n                    continue;\n                }\n                // optimisation 3: vertical line case\n                if (iLine.o.x === iLine.d.x && iLine.o.x >= point.x) {\n                    xi = iLine.o.x;\n                // yi = point.y;\n                } else {\n                    b1 = 0;\n                    b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);\n                    a1 = point.y - b1 * point.x;\n                    a2 = iLine.o.y - b2 * iLine.o.x;\n                    xi = -(a1 - a2) / (b1 - b2);\n                // yi = a1 + b1 * xi;\n                }\n                // dont count xi < point.x cases\n                if (xi >= point.x) {\n                    xcount += 1;\n                }\n                // optimisation 4: specific for square images\n                if (xcount === 2) {\n                    break;\n                }\n            }\n            return xcount;\n        },\n        /**\n     * Returns coordinates of object's bounding rectangle (left, top, width, height)\n     * the box is intended as aligned to axis of canvas.\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords\n     * @return {Object} Object with left, top, width, height properties\n     */ getBoundingRect: function(absolute, calculate) {\n            var coords = this.getCoords(absolute, calculate);\n            return util.makeBoundingBoxFromPoints(coords);\n        },\n        /**\n     * Returns width of an object's bounding box counting transformations\n     * before 2.0 it was named getWidth();\n     * @return {Number} width value\n     */ getScaledWidth: function() {\n            return this._getTransformedDimensions().x;\n        },\n        /**\n     * Returns height of an object bounding box counting transformations\n     * before 2.0 it was named getHeight();\n     * @return {Number} height value\n     */ getScaledHeight: function() {\n            return this._getTransformedDimensions().y;\n        },\n        /**\n     * Makes sure the scale is valid and modifies it if necessary\n     * @private\n     * @param {Number} value\n     * @return {Number}\n     */ _constrainScale: function(value) {\n            if (Math.abs(value) < this.minScaleLimit) {\n                if (value < 0) {\n                    return -this.minScaleLimit;\n                } else {\n                    return this.minScaleLimit;\n                }\n            } else if (value === 0) {\n                return 0.0001;\n            }\n            return value;\n        },\n        /**\n     * Scales an object (equally by x and y)\n     * @param {Number} value Scale factor\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ scale: function(value) {\n            this._set(\"scaleX\", value);\n            this._set(\"scaleY\", value);\n            return this.setCoords();\n        },\n        /**\n     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)\n     * @param {Number} value New width value\n     * @param {Boolean} absolute ignore viewport\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ scaleToWidth: function(value, absolute) {\n            // adjust to bounding rect factor so that rotated shapes would fit as well\n            var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();\n            return this.scale(value / this.width / boundingRectFactor);\n        },\n        /**\n     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)\n     * @param {Number} value New height value\n     * @param {Boolean} absolute ignore viewport\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ scaleToHeight: function(value, absolute) {\n            // adjust to bounding rect factor so that rotated shapes would fit as well\n            var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();\n            return this.scale(value / this.height / boundingRectFactor);\n        },\n        calcLineCoords: function() {\n            var vpt = this.getViewportTransform(), padding = this.padding, angle = degreesToRadians(this.angle), cos = util.cos(angle), sin = util.sin(angle), cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP, cosPMinusSinP = cosP - sinP, aCoords = this.calcACoords();\n            var lineCoords = {\n                tl: transformPoint(aCoords.tl, vpt),\n                tr: transformPoint(aCoords.tr, vpt),\n                bl: transformPoint(aCoords.bl, vpt),\n                br: transformPoint(aCoords.br, vpt)\n            };\n            if (padding) {\n                lineCoords.tl.x -= cosPMinusSinP;\n                lineCoords.tl.y -= cosPSinP;\n                lineCoords.tr.x += cosPSinP;\n                lineCoords.tr.y -= cosPMinusSinP;\n                lineCoords.bl.x -= cosPSinP;\n                lineCoords.bl.y += cosPMinusSinP;\n                lineCoords.br.x += cosPMinusSinP;\n                lineCoords.br.y += cosPSinP;\n            }\n            return lineCoords;\n        },\n        calcOCoords: function() {\n            var rotateMatrix = this._calcRotateMatrix(), translateMatrix = this._calcTranslateMatrix(), vpt = this.getViewportTransform(), startMatrix = multiplyMatrices(vpt, translateMatrix), finalMatrix = multiplyMatrices(startMatrix, rotateMatrix), finalMatrix = multiplyMatrices(finalMatrix, [\n                1 / vpt[0],\n                0,\n                0,\n                1 / vpt[3],\n                0,\n                0\n            ]), dim = this._calculateCurrentDimensions(), coords = {};\n            this.forEachControl(function(control, key, fabricObject) {\n                coords[key] = control.positionHandler(dim, finalMatrix, fabricObject);\n            });\n            // debug code\n            // var canvas = this.canvas;\n            // setTimeout(function() {\n            //   canvas.contextTop.clearRect(0, 0, 700, 700);\n            //   canvas.contextTop.fillStyle = 'green';\n            //   Object.keys(coords).forEach(function(key) {\n            //     var control = coords[key];\n            //     canvas.contextTop.fillRect(control.x, control.y, 3, 3);\n            //   });\n            // }, 50);\n            return coords;\n        },\n        calcACoords: function() {\n            var rotateMatrix = this._calcRotateMatrix(), translateMatrix = this._calcTranslateMatrix(), finalMatrix = multiplyMatrices(translateMatrix, rotateMatrix), dim = this._getTransformedDimensions(), w = dim.x / 2, h = dim.y / 2;\n            return {\n                // corners\n                tl: transformPoint({\n                    x: -w,\n                    y: -h\n                }, finalMatrix),\n                tr: transformPoint({\n                    x: w,\n                    y: -h\n                }, finalMatrix),\n                bl: transformPoint({\n                    x: -w,\n                    y: h\n                }, finalMatrix),\n                br: transformPoint({\n                    x: w,\n                    y: h\n                }, finalMatrix)\n            };\n        },\n        /**\n     * Sets corner and controls position coordinates based on current angle, width and height, left and top.\n     * oCoords are used to find the corners\n     * aCoords are used to quickly find an object on the canvas\n     * lineCoords are used to quickly find object during pointer events.\n     * See {@link https://github.com/fabricjs/fabric.js/wiki/When-to-call-setCoords} and {@link http://fabricjs.com/fabric-gotchas}\n     *\n     * @param {Boolean} [skipCorners] skip calculation of oCoords.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ setCoords: function(skipCorners) {\n            this.aCoords = this.calcACoords();\n            // in case we are in a group, for how the inner group target check works,\n            // lineCoords are exactly aCoords. Since the vpt gets absorbed by the normalized pointer.\n            this.lineCoords = this.group ? this.aCoords : this.calcLineCoords();\n            if (skipCorners) {\n                return this;\n            }\n            // set coordinates of the draggable boxes in the corners used to scale/rotate the image\n            this.oCoords = this.calcOCoords();\n            this._setCornerCoords && this._setCornerCoords();\n            return this;\n        },\n        /**\n     * calculate rotation matrix of an object\n     * @return {Array} rotation matrix for the object\n     */ _calcRotateMatrix: function() {\n            return util.calcRotateMatrix(this);\n        },\n        /**\n     * calculate the translation matrix for an object transform\n     * @return {Array} rotation matrix for the object\n     */ _calcTranslateMatrix: function() {\n            var center = this.getCenterPoint();\n            return [\n                1,\n                0,\n                0,\n                1,\n                center.x,\n                center.y\n            ];\n        },\n        transformMatrixKey: function(skipGroup) {\n            var sep = \"_\", prefix = \"\";\n            if (!skipGroup && this.group) {\n                prefix = this.group.transformMatrixKey(skipGroup) + sep;\n            }\n            ;\n            return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY + sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY + sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;\n        },\n        /**\n     * calculate transform matrix that represents the current transformations from the\n     * object's properties.\n     * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations\n     * There are some situation in which this is useful to avoid the fake rotation.\n     * @return {Array} transform matrix for the object\n     */ calcTransformMatrix: function(skipGroup) {\n            var matrix = this.calcOwnMatrix();\n            if (skipGroup || !this.group) {\n                return matrix;\n            }\n            var key = this.transformMatrixKey(skipGroup), cache = this.matrixCache || (this.matrixCache = {});\n            if (cache.key === key) {\n                return cache.value;\n            }\n            if (this.group) {\n                matrix = multiplyMatrices(this.group.calcTransformMatrix(false), matrix);\n            }\n            cache.key = key;\n            cache.value = matrix;\n            return matrix;\n        },\n        /**\n     * calculate transform matrix that represents the current transformations from the\n     * object's properties, this matrix does not include the group transformation\n     * @return {Array} transform matrix for the object\n     */ calcOwnMatrix: function() {\n            var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});\n            if (cache.key === key) {\n                return cache.value;\n            }\n            var tMatrix = this._calcTranslateMatrix(), options = {\n                angle: this.angle,\n                translateX: tMatrix[4],\n                translateY: tMatrix[5],\n                scaleX: this.scaleX,\n                scaleY: this.scaleY,\n                skewX: this.skewX,\n                skewY: this.skewY,\n                flipX: this.flipX,\n                flipY: this.flipY\n            };\n            cache.key = key;\n            cache.value = util.composeMatrix(options);\n            return cache.value;\n        },\n        /*\n     * Calculate object dimensions from its properties\n     * @private\n     * @return {Object} .x width dimension\n     * @return {Object} .y height dimension\n     */ _getNonTransformedDimensions: function() {\n            var strokeWidth = this.strokeWidth, w = this.width + strokeWidth, h = this.height + strokeWidth;\n            return {\n                x: w,\n                y: h\n            };\n        },\n        /*\n     * Calculate object bounding box dimensions from its properties scale, skew.\n     * @param {Number} skewX, a value to override current skewX\n     * @param {Number} skewY, a value to override current skewY\n     * @private\n     * @return {Object} .x width dimension\n     * @return {Object} .y height dimension\n     */ _getTransformedDimensions: function(skewX, skewY) {\n            if (typeof skewX === \"undefined\") {\n                skewX = this.skewX;\n            }\n            if (typeof skewY === \"undefined\") {\n                skewY = this.skewY;\n            }\n            var dimensions, dimX, dimY, noSkew = skewX === 0 && skewY === 0;\n            if (this.strokeUniform) {\n                dimX = this.width;\n                dimY = this.height;\n            } else {\n                dimensions = this._getNonTransformedDimensions();\n                dimX = dimensions.x;\n                dimY = dimensions.y;\n            }\n            if (noSkew) {\n                return this._finalizeDimensions(dimX * this.scaleX, dimY * this.scaleY);\n            }\n            var bbox = util.sizeAfterTransform(dimX, dimY, {\n                scaleX: this.scaleX,\n                scaleY: this.scaleY,\n                skewX: skewX,\n                skewY: skewY\n            });\n            return this._finalizeDimensions(bbox.x, bbox.y);\n        },\n        /*\n     * Calculate object bounding box dimensions from its properties scale, skew.\n     * @param Number width width of the bbox\n     * @param Number height height of the bbox\n     * @private\n     * @return {Object} .x finalized width dimension\n     * @return {Object} .y finalized height dimension\n     */ _finalizeDimensions: function(width, height) {\n            return this.strokeUniform ? {\n                x: width + this.strokeWidth,\n                y: height + this.strokeWidth\n            } : {\n                x: width,\n                y: height\n            };\n        },\n        /*\n     * Calculate object dimensions for controls box, including padding and canvas zoom.\n     * and active selection\n     * private\n     */ _calculateCurrentDimensions: function() {\n            var vpt = this.getViewportTransform(), dim = this._getTransformedDimensions(), p = transformPoint(dim, vpt, true);\n            return p.scalarAdd(2 * this.padding);\n        }\n    });\n})();\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n    /**\n   * Moves an object to the bottom of the stack of drawn objects\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ sendToBack: function() {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);\n        } else if (this.canvas) {\n            this.canvas.sendToBack(this);\n        }\n        return this;\n    },\n    /**\n   * Moves an object to the top of the stack of drawn objects\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ bringToFront: function() {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);\n        } else if (this.canvas) {\n            this.canvas.bringToFront(this);\n        }\n        return this;\n    },\n    /**\n   * Moves an object down in stack of drawn objects\n   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ sendBackwards: function(intersecting) {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);\n        } else if (this.canvas) {\n            this.canvas.sendBackwards(this, intersecting);\n        }\n        return this;\n    },\n    /**\n   * Moves an object up in stack of drawn objects\n   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ bringForward: function(intersecting) {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);\n        } else if (this.canvas) {\n            this.canvas.bringForward(this, intersecting);\n        }\n        return this;\n    },\n    /**\n   * Moves an object to specified level in stack of drawn objects\n   * @param {Number} index New position of object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ moveTo: function(index) {\n        if (this.group && this.group.type !== \"activeSelection\") {\n            fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);\n        } else if (this.canvas) {\n            this.canvas.moveTo(this, index);\n        }\n        return this;\n    }\n});\n/* _TO_SVG_START_ */ (function() {\n    function getSvgColorString(prop, value) {\n        if (!value) {\n            return prop + \": none; \";\n        } else if (value.toLive) {\n            return prop + \": url(#SVGID_\" + value.id + \"); \";\n        } else {\n            var color = new fabric.Color(value), str = prop + \": \" + color.toRgb() + \"; \", opacity = color.getAlpha();\n            if (opacity !== 1) {\n                //change the color in rgb + opacity\n                str += prop + \"-opacity: \" + opacity.toString() + \"; \";\n            }\n            return str;\n        }\n    }\n    var toFixed = fabric.util.toFixed;\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Returns styles-string for svg-export\n     * @param {Boolean} skipShadow a boolean to skip shadow filter output\n     * @return {String}\n     */ getSvgStyles: function(skipShadow) {\n            var fillRule = this.fillRule ? this.fillRule : \"nonzero\", strokeWidth = this.strokeWidth ? this.strokeWidth : \"0\", strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(\" \") : \"none\", strokeDashOffset = this.strokeDashOffset ? this.strokeDashOffset : \"0\", strokeLineCap = this.strokeLineCap ? this.strokeLineCap : \"butt\", strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : \"miter\", strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : \"4\", opacity = typeof this.opacity !== \"undefined\" ? this.opacity : \"1\", visibility = this.visible ? \"\" : \" visibility: hidden;\", filter = skipShadow ? \"\" : this.getSvgFilter(), fill = getSvgColorString(\"fill\", this.fill), stroke = getSvgColorString(\"stroke\", this.stroke);\n            return [\n                stroke,\n                \"stroke-width: \",\n                strokeWidth,\n                \"; \",\n                \"stroke-dasharray: \",\n                strokeDashArray,\n                \"; \",\n                \"stroke-linecap: \",\n                strokeLineCap,\n                \"; \",\n                \"stroke-dashoffset: \",\n                strokeDashOffset,\n                \"; \",\n                \"stroke-linejoin: \",\n                strokeLineJoin,\n                \"; \",\n                \"stroke-miterlimit: \",\n                strokeMiterLimit,\n                \"; \",\n                fill,\n                \"fill-rule: \",\n                fillRule,\n                \"; \",\n                \"opacity: \",\n                opacity,\n                \";\",\n                filter,\n                visibility\n            ].join(\"\");\n        },\n        /**\n     * Returns styles-string for svg-export\n     * @param {Object} style the object from which to retrieve style properties\n     * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.\n     * @return {String}\n     */ getSvgSpanStyles: function(style, useWhiteSpace) {\n            var term = \"; \";\n            var fontFamily = style.fontFamily ? \"font-family: \" + (style.fontFamily.indexOf(\"'\") === -1 && style.fontFamily.indexOf('\"') === -1 ? \"'\" + style.fontFamily + \"'\" : style.fontFamily) + term : \"\";\n            var strokeWidth = style.strokeWidth ? \"stroke-width: \" + style.strokeWidth + term : \"\", fontFamily = fontFamily, fontSize = style.fontSize ? \"font-size: \" + style.fontSize + \"px\" + term : \"\", fontStyle = style.fontStyle ? \"font-style: \" + style.fontStyle + term : \"\", fontWeight = style.fontWeight ? \"font-weight: \" + style.fontWeight + term : \"\", fill = style.fill ? getSvgColorString(\"fill\", style.fill) : \"\", stroke = style.stroke ? getSvgColorString(\"stroke\", style.stroke) : \"\", textDecoration = this.getSvgTextDecoration(style), deltaY = style.deltaY ? \"baseline-shift: \" + -style.deltaY + \"; \" : \"\";\n            if (textDecoration) {\n                textDecoration = \"text-decoration: \" + textDecoration + term;\n            }\n            return [\n                stroke,\n                strokeWidth,\n                fontFamily,\n                fontSize,\n                fontStyle,\n                fontWeight,\n                textDecoration,\n                fill,\n                deltaY,\n                useWhiteSpace ? \"white-space: pre; \" : \"\"\n            ].join(\"\");\n        },\n        /**\n     * Returns text-decoration property for svg-export\n     * @param {Object} style the object from which to retrieve style properties\n     * @return {String}\n     */ getSvgTextDecoration: function(style) {\n            return [\n                \"overline\",\n                \"underline\",\n                \"line-through\"\n            ].filter(function(decoration) {\n                return style[decoration.replace(\"-\", \"\")];\n            }).join(\" \");\n        },\n        /**\n     * Returns filter for svg shadow\n     * @return {String}\n     */ getSvgFilter: function() {\n            return this.shadow ? \"filter: url(#SVGID_\" + this.shadow.id + \");\" : \"\";\n        },\n        /**\n     * Returns id attribute for svg output\n     * @return {String}\n     */ getSvgCommons: function() {\n            return [\n                this.id ? 'id=\"' + this.id + '\" ' : \"\",\n                this.clipPath ? 'clip-path=\"url(#' + this.clipPath.clipPathId + ')\" ' : \"\"\n            ].join(\"\");\n        },\n        /**\n     * Returns transform-string for svg-export\n     * @param {Boolean} use the full transform or the single object one.\n     * @return {String}\n     */ getSvgTransform: function(full, additionalTransform) {\n            var transform = full ? this.calcTransformMatrix() : this.calcOwnMatrix(), svgTransform = 'transform=\"' + fabric.util.matrixToSVG(transform);\n            return svgTransform + (additionalTransform || \"\") + '\" ';\n        },\n        _setSVGBg: function(textBgRects) {\n            if (this.backgroundColor) {\n                var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n                textBgRects.push(\"\t\t<rect \", this._getFillAttributes(this.backgroundColor), ' x=\"', toFixed(-this.width / 2, NUM_FRACTION_DIGITS), '\" y=\"', toFixed(-this.height / 2, NUM_FRACTION_DIGITS), '\" width=\"', toFixed(this.width, NUM_FRACTION_DIGITS), '\" height=\"', toFixed(this.height, NUM_FRACTION_DIGITS), '\"></rect>\\n');\n            }\n        },\n        /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toSVG: function(reviver) {\n            return this._createBaseSVGMarkup(this._toSVG(reviver), {\n                reviver: reviver\n            });\n        },\n        /**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toClipPathSVG: function(reviver) {\n            return \"\t\" + this._createBaseClipPathSVGMarkup(this._toSVG(reviver), {\n                reviver: reviver\n            });\n        },\n        /**\n     * @private\n     */ _createBaseClipPathSVGMarkup: function(objectMarkup, options) {\n            options = options || {};\n            var reviver = options.reviver, additionalTransform = options.additionalTransform || \"\", commonPieces = [\n                this.getSvgTransform(true, additionalTransform),\n                this.getSvgCommons()\n            ].join(\"\"), // insert commons in the markup, style and svgCommons\n            index = objectMarkup.indexOf(\"COMMON_PARTS\");\n            objectMarkup[index] = commonPieces;\n            return reviver ? reviver(objectMarkup.join(\"\")) : objectMarkup.join(\"\");\n        },\n        /**\n     * @private\n     */ _createBaseSVGMarkup: function(objectMarkup, options) {\n            options = options || {};\n            var noStyle = options.noStyle, reviver = options.reviver, styleInfo = noStyle ? \"\" : 'style=\"' + this.getSvgStyles() + '\" ', shadowInfo = options.withShadow ? 'style=\"' + this.getSvgFilter() + '\" ' : \"\", clipPath = this.clipPath, vectorEffect = this.strokeUniform ? 'vector-effect=\"non-scaling-stroke\" ' : \"\", absoluteClipPath = clipPath && clipPath.absolutePositioned, stroke = this.stroke, fill = this.fill, shadow = this.shadow, commonPieces, markup = [], clipPathMarkup, // insert commons in the markup, style and svgCommons\n            index = objectMarkup.indexOf(\"COMMON_PARTS\"), additionalTransform = options.additionalTransform;\n            if (clipPath) {\n                clipPath.clipPathId = \"CLIPPATH_\" + fabric.Object.__uid++;\n                clipPathMarkup = '<clipPath id=\"' + clipPath.clipPathId + '\" >\\n' + clipPath.toClipPathSVG(reviver) + \"</clipPath>\\n\";\n            }\n            if (absoluteClipPath) {\n                markup.push(\"<g \", shadowInfo, this.getSvgCommons(), \" >\\n\");\n            }\n            markup.push(\"<g \", this.getSvgTransform(false), !absoluteClipPath ? shadowInfo + this.getSvgCommons() : \"\", \" >\\n\");\n            commonPieces = [\n                styleInfo,\n                vectorEffect,\n                noStyle ? \"\" : this.addPaintOrder(),\n                \" \",\n                additionalTransform ? 'transform=\"' + additionalTransform + '\" ' : \"\"\n            ].join(\"\");\n            objectMarkup[index] = commonPieces;\n            if (fill && fill.toLive) {\n                markup.push(fill.toSVG(this));\n            }\n            if (stroke && stroke.toLive) {\n                markup.push(stroke.toSVG(this));\n            }\n            if (shadow) {\n                markup.push(shadow.toSVG(this));\n            }\n            if (clipPath) {\n                markup.push(clipPathMarkup);\n            }\n            markup.push(objectMarkup.join(\"\"));\n            markup.push(\"</g>\\n\");\n            absoluteClipPath && markup.push(\"</g>\\n\");\n            return reviver ? reviver(markup.join(\"\")) : markup.join(\"\");\n        },\n        addPaintOrder: function() {\n            return this.paintFirst !== \"fill\" ? ' paint-order=\"' + this.paintFirst + '\" ' : \"\";\n        }\n    });\n})();\n/* _TO_SVG_END_ */ (function() {\n    var extend = fabric.util.object.extend, originalSet = \"stateProperties\";\n    /*\n    Depends on `stateProperties`\n  */ function saveProps(origin, destination, props) {\n        var tmpObj = {}, deep = true;\n        props.forEach(function(prop) {\n            tmpObj[prop] = origin[prop];\n        });\n        extend(origin[destination], tmpObj, deep);\n    }\n    function _isEqual(origValue, currentValue, firstPass) {\n        if (origValue === currentValue) {\n            // if the objects are identical, return\n            return true;\n        } else if (Array.isArray(origValue)) {\n            if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {\n                return false;\n            }\n            for(var i = 0, len = origValue.length; i < len; i++){\n                if (!_isEqual(origValue[i], currentValue[i])) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (origValue && typeof origValue === \"object\") {\n            var keys = Object.keys(origValue), key;\n            if (!currentValue || typeof currentValue !== \"object\" || !firstPass && keys.length !== Object.keys(currentValue).length) {\n                return false;\n            }\n            for(var i = 0, len = keys.length; i < len; i++){\n                key = keys[i];\n                // since clipPath is in the statefull cache list and the clipPath objects\n                // would be iterated as an object, this would lead to possible infinite recursion\n                // we do not want to compare those.\n                if (key === \"canvas\" || key === \"group\") {\n                    continue;\n                }\n                if (!_isEqual(origValue[key], currentValue[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Returns true if object state (one of its state properties) was changed\n     * @param {String} [propertySet] optional name for the set of property we want to save\n     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called\n     */ hasStateChanged: function(propertySet) {\n            propertySet = propertySet || originalSet;\n            var dashedPropertySet = \"_\" + propertySet;\n            if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {\n                return true;\n            }\n            return !_isEqual(this[dashedPropertySet], this, true);\n        },\n        /**\n     * Saves state of an object\n     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\n     * @return {fabric.Object} thisArg\n     */ saveState: function(options) {\n            var propertySet = options && options.propertySet || originalSet, destination = \"_\" + propertySet;\n            if (!this[destination]) {\n                return this.setupState(options);\n            }\n            saveProps(this, destination, this[propertySet]);\n            if (options && options.stateProperties) {\n                saveProps(this, destination, options.stateProperties);\n            }\n            return this;\n        },\n        /**\n     * Setups state of an object\n     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\n     * @return {fabric.Object} thisArg\n     */ setupState: function(options) {\n            options = options || {};\n            var propertySet = options.propertySet || originalSet;\n            options.propertySet = propertySet;\n            this[\"_\" + propertySet] = {};\n            this.saveState(options);\n            return this;\n        }\n    });\n})();\n(function() {\n    var degreesToRadians = fabric.util.degreesToRadians;\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Determines which corner has been clicked\n     * @private\n     * @param {Object} pointer The pointer indicating the mouse position\n     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found\n     */ _findTargetCorner: function(pointer, forTouch) {\n            // objects in group, anykind, are not self modificable,\n            // must not return an hovered corner.\n            if (!this.hasControls || this.group || !this.canvas || this.canvas._activeObject !== this) {\n                return false;\n            }\n            var ex = pointer.x, ey = pointer.y, xPoints, lines, keys = Object.keys(this.oCoords), j = keys.length - 1, i;\n            this.__corner = 0;\n            // cycle in reverse order so we pick first the one on top\n            for(; j >= 0; j--){\n                i = keys[j];\n                if (!this.isControlVisible(i)) {\n                    continue;\n                }\n                lines = this._getImageLines(forTouch ? this.oCoords[i].touchCorner : this.oCoords[i].corner);\n                // // debugging\n                //\n                // this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);\n                //\n                // this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);\n                //\n                // this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);\n                //\n                // this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);\n                xPoints = this._findCrossPoints({\n                    x: ex,\n                    y: ey\n                }, lines);\n                if (xPoints !== 0 && xPoints % 2 === 1) {\n                    this.__corner = i;\n                    return i;\n                }\n            }\n            return false;\n        },\n        /**\n     * Calls a function for each control. The function gets called,\n     * with the control, the object that is calling the iterator and the control's key\n     * @param {Function} fn function to iterate over the controls over\n     */ forEachControl: function(fn) {\n            for(var i in this.controls){\n                fn(this.controls[i], i, this);\n            }\n            ;\n        },\n        /**\n     * Sets the coordinates of the draggable boxes in the corners of\n     * the image used to scale/rotate it.\n     * note: if we would switch to ROUND corner area, all of this would disappear.\n     * everything would resolve to a single point and a pythagorean theorem for the distance\n     * @private\n     */ _setCornerCoords: function() {\n            var coords = this.oCoords;\n            for(var control in coords){\n                var controlObject = this.controls[control];\n                coords[control].corner = controlObject.calcCornerCoords(this.angle, this.cornerSize, coords[control].x, coords[control].y, false);\n                coords[control].touchCorner = controlObject.calcCornerCoords(this.angle, this.touchCornerSize, coords[control].x, coords[control].y, true);\n            }\n        },\n        /**\n     * Draws a colored layer behind the object, inside its selection borders.\n     * Requires public options: padding, selectionBackgroundColor\n     * this function is called when the context is transformed\n     * has checks to be skipped when the object is on a staticCanvas\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawSelectionBackground: function(ctx) {\n            if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this) {\n                return this;\n            }\n            ctx.save();\n            var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(), vpt = this.canvas.viewportTransform;\n            ctx.translate(center.x, center.y);\n            ctx.scale(1 / vpt[0], 1 / vpt[3]);\n            ctx.rotate(degreesToRadians(this.angle));\n            ctx.fillStyle = this.selectionBackgroundColor;\n            ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Draws borders of an object's bounding box.\n     * Requires public properties: width, height\n     * Requires public options: padding, borderColor\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawBorders: function(ctx, styleOverride) {\n            styleOverride = styleOverride || {};\n            var wh = this._calculateCurrentDimensions(), strokeWidth = this.borderScaleFactor, width = wh.x + strokeWidth, height = wh.y + strokeWidth, hasControls = typeof styleOverride.hasControls !== \"undefined\" ? styleOverride.hasControls : this.hasControls, shouldStroke = false;\n            ctx.save();\n            ctx.strokeStyle = styleOverride.borderColor || this.borderColor;\n            this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);\n            ctx.strokeRect(-width / 2, -height / 2, width, height);\n            if (hasControls) {\n                ctx.beginPath();\n                this.forEachControl(function(control, key, fabricObject) {\n                    // in this moment, the ctx is centered on the object.\n                    // width and height of the above function are the size of the bbox.\n                    if (control.withConnection && control.getVisibility(fabricObject, key)) {\n                        // reset movement for each control\n                        shouldStroke = true;\n                        ctx.moveTo(control.x * width, control.y * height);\n                        ctx.lineTo(control.x * width + control.offsetX, control.y * height + control.offsetY);\n                    }\n                });\n                if (shouldStroke) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Draws borders of an object's bounding box when it is inside a group.\n     * Requires public properties: width, height\n     * Requires public options: padding, borderColor\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {object} options object representing current object parameters\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawBordersInGroup: function(ctx, options, styleOverride) {\n            styleOverride = styleOverride || {};\n            var bbox = fabric.util.sizeAfterTransform(this.width, this.height, options), strokeWidth = this.strokeWidth, strokeUniform = this.strokeUniform, borderScaleFactor = this.borderScaleFactor, width = bbox.x + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleX) + borderScaleFactor, height = bbox.y + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleY) + borderScaleFactor;\n            ctx.save();\n            this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);\n            ctx.strokeStyle = styleOverride.borderColor || this.borderColor;\n            ctx.strokeRect(-width / 2, -height / 2, width, height);\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Draws corners of an object's bounding box.\n     * Requires public properties: width, height\n     * Requires public options: cornerSize, padding\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawControls: function(ctx, styleOverride) {\n            styleOverride = styleOverride || {};\n            ctx.save();\n            var retinaScaling = this.canvas.getRetinaScaling(), matrix, p;\n            ctx.setTransform(retinaScaling, 0, 0, retinaScaling, 0, 0);\n            ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;\n            if (!this.transparentCorners) {\n                ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;\n            }\n            this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray);\n            this.setCoords();\n            if (this.group) {\n                // fabricJS does not really support drawing controls inside groups,\n                // this piece of code here helps having at least the control in places.\n                // If an application needs to show some objects as selected because of some UI state\n                // can still call Object._renderControls() on any object they desire, independently of groups.\n                // using no padding, circular controls and hiding the rotating cursor is higly suggested,\n                matrix = this.group.calcTransformMatrix();\n            }\n            this.forEachControl(function(control, key, fabricObject) {\n                p = fabricObject.oCoords[key];\n                if (control.getVisibility(fabricObject, key)) {\n                    if (matrix) {\n                        p = fabric.util.transformPoint(p, matrix);\n                    }\n                    control.render(ctx, p.x, p.y, styleOverride, fabricObject);\n                }\n            });\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Returns true if the specified control is visible, false otherwise.\n     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\n     * @returns {Boolean} true if the specified control is visible, false otherwise\n     */ isControlVisible: function(controlKey) {\n            return this.controls[controlKey] && this.controls[controlKey].getVisibility(this, controlKey);\n        },\n        /**\n     * Sets the visibility of the specified control.\n     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\n     * @param {Boolean} visible true to set the specified control visible, false otherwise\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ setControlVisible: function(controlKey, visible) {\n            if (!this._controlsVisibility) {\n                this._controlsVisibility = {};\n            }\n            this._controlsVisibility[controlKey] = visible;\n            return this;\n        },\n        /**\n     * Sets the visibility state of object controls.\n     * @param {Object} [options] Options object\n     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it\n     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it\n     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it\n     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it\n     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it\n     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it\n     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it\n     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it\n     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ setControlsVisibility: function(options) {\n            options || (options = {});\n            for(var p in options){\n                this.setControlVisible(p, options[p]);\n            }\n            return this;\n        },\n        /**\n     * This callback function is called every time _discardActiveObject or _setActiveObject\n     * try to to deselect this object. If the function returns true, the process is cancelled\n     * @param {Object} [options] options sent from the upper functions\n     * @param {Event} [options.e] event if the process is generated by an event\n     */ onDeselect: function() {\n        // implemented by sub-classes, as needed.\n        },\n        /**\n     * This callback function is called every time _discardActiveObject or _setActiveObject\n     * try to to select this object. If the function returns true, the process is cancelled\n     * @param {Object} [options] options sent from the upper functions\n     * @param {Event} [options.e] event if the process is generated by an event\n     */ onSelect: function() {\n        // implemented by sub-classes, as needed.\n        }\n    });\n})();\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n    /**\n   * Animation duration (in ms) for fx* methods\n   * @type Number\n   * @default\n   */ FX_DURATION: 500,\n    /**\n   * Centers object horizontally with animation.\n   * @param {fabric.Object} object Object to center\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.AnimationContext} context\n   */ fxCenterObjectH: function(object, callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: object.left,\n            endValue: this.getCenterPoint().x,\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                object.set(\"left\", value);\n                _this.requestRenderAll();\n                onChange();\n            },\n            onComplete: function() {\n                object.setCoords();\n                onComplete();\n            }\n        });\n    },\n    /**\n   * Centers object vertically with animation.\n   * @param {fabric.Object} object Object to center\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.AnimationContext} context\n   */ fxCenterObjectV: function(object, callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: object.top,\n            endValue: this.getCenterPoint().y,\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                object.set(\"top\", value);\n                _this.requestRenderAll();\n                onChange();\n            },\n            onComplete: function() {\n                object.setCoords();\n                onComplete();\n            }\n        });\n    },\n    /**\n   * Same as `fabric.Canvas#remove` but animated\n   * @param {fabric.Object} object Object to remove\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.AnimationContext} context\n   */ fxRemove: function(object, callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: object.opacity,\n            endValue: 0,\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                object.set(\"opacity\", value);\n                _this.requestRenderAll();\n                onChange();\n            },\n            onComplete: function() {\n                _this.remove(object);\n                onComplete();\n            }\n        });\n    }\n});\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n    /**\n   * Animates object's properties\n   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)\n   * @param {Number|Object} value Value to animate property to (if string was given first) or options object\n   * @return {fabric.Object} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}\n   * @return {fabric.AnimationContext | fabric.AnimationContext[]} animation context (or an array if passed multiple properties)\n   *\n   * As object  multiple properties\n   *\n   * object.animate({ left: ..., top: ... });\n   * object.animate({ left: ..., top: ... }, { duration: ... });\n   *\n   * As string  one property\n   *\n   * object.animate('left', ...);\n   * object.animate('left', { duration: ... });\n   *\n   */ animate: function() {\n        if (arguments[0] && typeof arguments[0] === \"object\") {\n            var propsToAnimate = [], prop, skipCallbacks, out = [];\n            for(prop in arguments[0]){\n                propsToAnimate.push(prop);\n            }\n            for(var i = 0, len = propsToAnimate.length; i < len; i++){\n                prop = propsToAnimate[i];\n                skipCallbacks = i !== len - 1;\n                out.push(this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks));\n            }\n            return out;\n        } else {\n            return this._animate.apply(this, arguments);\n        }\n    },\n    /**\n   * @private\n   * @param {String} property Property to animate\n   * @param {String} to Value to animate to\n   * @param {Object} [options] Options object\n   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked\n   */ _animate: function(property, to, options, skipCallbacks) {\n        var _this = this, propPair;\n        to = to.toString();\n        if (!options) {\n            options = {};\n        } else {\n            options = fabric.util.object.clone(options);\n        }\n        if (~property.indexOf(\".\")) {\n            propPair = property.split(\".\");\n        }\n        var propIsColor = _this.colorProperties.indexOf(property) > -1 || propPair && _this.colorProperties.indexOf(propPair[1]) > -1;\n        var currentValue = propPair ? this.get(propPair[0])[propPair[1]] : this.get(property);\n        if (!(\"from\" in options)) {\n            options.from = currentValue;\n        }\n        if (!propIsColor) {\n            if (~to.indexOf(\"=\")) {\n                to = currentValue + parseFloat(to.replace(\"=\", \"\"));\n            } else {\n                to = parseFloat(to);\n            }\n        }\n        var _options = {\n            target: this,\n            startValue: options.from,\n            endValue: to,\n            byValue: options.by,\n            easing: options.easing,\n            duration: options.duration,\n            abort: options.abort && function(value, valueProgress, timeProgress) {\n                return options.abort.call(_this, value, valueProgress, timeProgress);\n            },\n            onChange: function(value, valueProgress, timeProgress) {\n                if (propPair) {\n                    _this[propPair[0]][propPair[1]] = value;\n                } else {\n                    _this.set(property, value);\n                }\n                if (skipCallbacks) {\n                    return;\n                }\n                options.onChange && options.onChange(value, valueProgress, timeProgress);\n            },\n            onComplete: function(value, valueProgress, timeProgress) {\n                if (skipCallbacks) {\n                    return;\n                }\n                _this.setCoords();\n                options.onComplete && options.onComplete(value, valueProgress, timeProgress);\n            }\n        };\n        if (propIsColor) {\n            return fabric.util.animateColor(_options.startValue, _options.endValue, _options.duration, _options);\n        } else {\n            return fabric.util.animate(_options);\n        }\n    }\n});\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, clone = fabric.util.object.clone, coordProps = {\n        x1: 1,\n        x2: 1,\n        y1: 1,\n        y2: 1\n    };\n    if (fabric.Line) {\n        fabric.warn(\"fabric.Line is already defined\");\n        return;\n    }\n    /**\n   * Line class\n   * @class fabric.Line\n   * @extends fabric.Object\n   * @see {@link fabric.Line#initialize} for constructor definition\n   */ fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"line\",\n        /**\n     * x value or first line edge\n     * @type Number\n     * @default\n     */ x1: 0,\n        /**\n     * y value or first line edge\n     * @type Number\n     * @default\n     */ y1: 0,\n        /**\n     * x value or second line edge\n     * @type Number\n     * @default\n     */ x2: 0,\n        /**\n     * y value or second line edge\n     * @type Number\n     * @default\n     */ y2: 0,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"x1\", \"x2\", \"y1\", \"y2\"),\n        /**\n     * Constructor\n     * @param {Array} [points] Array of points\n     * @param {Object} [options] Options object\n     * @return {fabric.Line} thisArg\n     */ initialize: function(points, options) {\n            if (!points) {\n                points = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n            }\n            this.callSuper(\"initialize\", options);\n            this.set(\"x1\", points[0]);\n            this.set(\"y1\", points[1]);\n            this.set(\"x2\", points[2]);\n            this.set(\"y2\", points[3]);\n            this._setWidthHeight(options);\n        },\n        /**\n     * @private\n     * @param {Object} [options] Options\n     */ _setWidthHeight: function(options) {\n            options || (options = {});\n            this.width = Math.abs(this.x2 - this.x1);\n            this.height = Math.abs(this.y2 - this.y1);\n            this.left = \"left\" in options ? options.left : this._getLeftToOriginX();\n            this.top = \"top\" in options ? options.top : this._getTopToOriginY();\n        },\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     */ _set: function(key, value) {\n            this.callSuper(\"_set\", key, value);\n            if (typeof coordProps[key] !== \"undefined\") {\n                this._setWidthHeight();\n            }\n            return this;\n        },\n        /**\n     * @private\n     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.\n     */ _getLeftToOriginX: makeEdgeToOriginGetter({\n            origin: \"originX\",\n            axis1: \"x1\",\n            axis2: \"x2\",\n            dimension: \"width\"\n        }, {\n            nearest: \"left\",\n            center: \"center\",\n            farthest: \"right\"\n        }),\n        /**\n     * @private\n     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.\n     */ _getTopToOriginY: makeEdgeToOriginGetter({\n            origin: \"originY\",\n            axis1: \"y1\",\n            axis2: \"y2\",\n            dimension: \"height\"\n        }, {\n            nearest: \"top\",\n            center: \"center\",\n            farthest: \"bottom\"\n        }),\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            ctx.beginPath();\n            var p = this.calcLinePoints();\n            ctx.moveTo(p.x1, p.y1);\n            ctx.lineTo(p.x2, p.y2);\n            ctx.lineWidth = this.strokeWidth;\n            // TODO: test this\n            // make sure setting \"fill\" changes color of a line\n            // (by copying fillStyle to strokeStyle, since line is stroked, not filled)\n            var origStrokeStyle = ctx.strokeStyle;\n            ctx.strokeStyle = this.stroke || ctx.fillStyle;\n            this.stroke && this._renderStroke(ctx);\n            ctx.strokeStyle = origStrokeStyle;\n        },\n        /**\n     * This function is an helper for svg import. it returns the center of the object in the svg\n     * untransformed coordinates\n     * @private\n     * @return {Object} center point from element coordinates\n     */ _findCenterFromElement: function() {\n            return {\n                x: (this.x1 + this.x2) / 2,\n                y: (this.y1 + this.y2) / 2\n            };\n        },\n        /**\n     * Returns object representation of an instance\n     * @method toObject\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return extend(this.callSuper(\"toObject\", propertiesToInclude), this.calcLinePoints());\n        },\n        /*\n     * Calculate object dimensions from its properties\n     * @private\n     */ _getNonTransformedDimensions: function() {\n            var dim = this.callSuper(\"_getNonTransformedDimensions\");\n            if (this.strokeLineCap === \"butt\") {\n                if (this.width === 0) {\n                    dim.y -= this.strokeWidth;\n                }\n                if (this.height === 0) {\n                    dim.x -= this.strokeWidth;\n                }\n            }\n            return dim;\n        },\n        /**\n     * Recalculates line points given width and height\n     * @private\n     */ calcLinePoints: function() {\n            var xMult = this.x1 <= this.x2 ? -1 : 1, yMult = this.y1 <= this.y2 ? -1 : 1, x1 = xMult * this.width * 0.5, y1 = yMult * this.height * 0.5, x2 = xMult * this.width * -0.5, y2 = yMult * this.height * -0.5;\n            return {\n                x1: x1,\n                x2: x2,\n                y1: y1,\n                y2: y2\n            };\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var p = this.calcLinePoints();\n            return [\n                \"<line \",\n                \"COMMON_PARTS\",\n                'x1=\"',\n                p.x1,\n                '\" y1=\"',\n                p.y1,\n                '\" x2=\"',\n                p.x2,\n                '\" y2=\"',\n                p.y2,\n                '\" />\\n'\n            ];\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})\n   * @static\n   * @memberOf fabric.Line\n   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement\n   */ fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x1 y1 x2 y2\".split(\" \"));\n    /**\n   * Returns fabric.Line instance from an SVG element\n   * @static\n   * @memberOf fabric.Line\n   * @param {SVGElement} element Element to parse\n   * @param {Object} [options] Options object\n   * @param {Function} [callback] callback function invoked after parsing\n   */ fabric.Line.fromElement = function(element, callback, options) {\n        options = options || {};\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES), points = [\n            parsedAttributes.x1 || 0,\n            parsedAttributes.y1 || 0,\n            parsedAttributes.x2 || 0,\n            parsedAttributes.y2 || 0\n        ];\n        callback(new fabric.Line(points, extend(parsedAttributes, options)));\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Line instance from an object representation\n   * @static\n   * @memberOf fabric.Line\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   */ fabric.Line.fromObject = function(object, callback) {\n        function _callback(instance) {\n            delete instance.points;\n            callback && callback(instance);\n        }\n        ;\n        var options = clone(object, true);\n        options.points = [\n            object.x1,\n            object.y1,\n            object.x2,\n            object.y2\n        ];\n        fabric.Object._fromObject(\"Line\", options, _callback, \"points\");\n    };\n    /**\n   * Produces a function that calculates distance from canvas edge to Line origin.\n   */ function makeEdgeToOriginGetter(propertyNames, originValues) {\n        var origin = propertyNames.origin, axis1 = propertyNames.axis1, axis2 = propertyNames.axis2, dimension = propertyNames.dimension, nearest = originValues.nearest, center = originValues.center, farthest = originValues.farthest;\n        return function() {\n            switch(this.get(origin)){\n                case nearest:\n                    return Math.min(this.get(axis1), this.get(axis2));\n                case center:\n                    return Math.min(this.get(axis1), this.get(axis2)) + 0.5 * this.get(dimension);\n                case farthest:\n                    return Math.max(this.get(axis1), this.get(axis2));\n            }\n        };\n    }\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), degreesToRadians = fabric.util.degreesToRadians;\n    if (fabric.Circle) {\n        fabric.warn(\"fabric.Circle is already defined.\");\n        return;\n    }\n    /**\n   * Circle class\n   * @class fabric.Circle\n   * @extends fabric.Object\n   * @see {@link fabric.Circle#initialize} for constructor definition\n   */ fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"circle\",\n        /**\n     * Radius of this circle\n     * @type Number\n     * @default\n     */ radius: 0,\n        /**\n     * degrees of start of the circle.\n     * probably will change to degrees in next major version\n     * @type Number 0 - 359\n     * @default 0\n     */ startAngle: 0,\n        /**\n     * End angle of the circle\n     * probably will change to degrees in next major version\n     * @type Number 1 - 360\n     * @default 360\n     */ endAngle: 360,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"radius\", \"startAngle\", \"endAngle\"),\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Circle} thisArg\n     */ _set: function(key, value) {\n            this.callSuper(\"_set\", key, value);\n            if (key === \"radius\") {\n                this.setRadius(value);\n            }\n            return this;\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"radius\",\n                \"startAngle\",\n                \"endAngle\"\n            ].concat(propertiesToInclude));\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var svgString, x = 0, y = 0, angle = (this.endAngle - this.startAngle) % 360;\n            if (angle === 0) {\n                svgString = [\n                    \"<circle \",\n                    \"COMMON_PARTS\",\n                    'cx=\"' + x + '\" cy=\"' + y + '\" ',\n                    'r=\"',\n                    this.radius,\n                    '\" />\\n'\n                ];\n            } else {\n                var start = degreesToRadians(this.startAngle), end = degreesToRadians(this.endAngle), radius = this.radius, startX = fabric.util.cos(start) * radius, startY = fabric.util.sin(start) * radius, endX = fabric.util.cos(end) * radius, endY = fabric.util.sin(end) * radius, largeFlag = angle > 180 ? \"1\" : \"0\";\n                svgString = [\n                    '<path d=\"M ' + startX + \" \" + startY,\n                    \" A \" + radius + \" \" + radius,\n                    \" 0 \",\n                    +largeFlag + \" 1\",\n                    \" \" + endX + \" \" + endY,\n                    '\" ',\n                    \"COMMON_PARTS\",\n                    \" />\\n\"\n                ];\n            }\n            return svgString;\n        },\n        /* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render on\n     */ _render: function(ctx) {\n            ctx.beginPath();\n            ctx.arc(0, 0, this.radius, degreesToRadians(this.startAngle), degreesToRadians(this.endAngle), false);\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns horizontal radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRadiusX: function() {\n            return this.get(\"radius\") * this.get(\"scaleX\");\n        },\n        /**\n     * Returns vertical radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRadiusY: function() {\n            return this.get(\"radius\") * this.get(\"scaleY\");\n        },\n        /**\n     * Sets radius of an object (and updates width accordingly)\n     * @return {fabric.Circle} thisArg\n     */ setRadius: function(value) {\n            this.radius = value;\n            return this.set(\"width\", value * 2).set(\"height\", value * 2);\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})\n   * @static\n   * @memberOf fabric.Circle\n   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement\n   */ fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"cx cy r\".split(\" \"));\n    /**\n   * Returns {@link fabric.Circle} instance from an SVG element\n   * @static\n   * @memberOf fabric.Circle\n   * @param {SVGElement} element Element to parse\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   * @param {Object} [options] Options object\n   * @throws {Error} If value of `r` attribute is missing or invalid\n   */ fabric.Circle.fromElement = function(element, callback) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);\n        if (!isValidRadius(parsedAttributes)) {\n            throw new Error(\"value of `r` attribute is required and can not be negative\");\n        }\n        parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;\n        parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;\n        callback(new fabric.Circle(parsedAttributes));\n    };\n    /**\n   * @private\n   */ function isValidRadius(attributes) {\n        return \"radius\" in attributes && attributes.radius >= 0;\n    }\n    /* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Circle} instance from an object representation\n   * @static\n   * @memberOf fabric.Circle\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   * @return {void}\n   */ fabric.Circle.fromObject = function(object, callback) {\n        fabric.Object._fromObject(\"Circle\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Triangle) {\n        fabric.warn(\"fabric.Triangle is already defined\");\n        return;\n    }\n    /**\n   * Triangle class\n   * @class fabric.Triangle\n   * @extends fabric.Object\n   * @return {fabric.Triangle} thisArg\n   * @see {@link fabric.Triangle#initialize} for constructor definition\n   */ fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"triangle\",\n        /**\n     * Width is set to 100 to compensate the old initialize code that was setting it to 100\n     * @type Number\n     * @default\n     */ width: 100,\n        /**\n     * Height is set to 100 to compensate the old initialize code that was setting it to 100\n     * @type Number\n     * @default\n     */ height: 100,\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            var widthBy2 = this.width / 2, heightBy2 = this.height / 2;\n            ctx.beginPath();\n            ctx.moveTo(-widthBy2, heightBy2);\n            ctx.lineTo(0, -heightBy2);\n            ctx.lineTo(widthBy2, heightBy2);\n            ctx.closePath();\n            this._renderPaintInOrder(ctx);\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var widthBy2 = this.width / 2, heightBy2 = this.height / 2, points = [\n                -widthBy2 + \" \" + heightBy2,\n                \"0 \" + -heightBy2,\n                widthBy2 + \" \" + heightBy2\n            ].join(\",\");\n            return [\n                \"<polygon \",\n                \"COMMON_PARTS\",\n                'points=\"',\n                points,\n                '\" />'\n            ];\n        }\n    });\n    /**\n   * Returns {@link fabric.Triangle} instance from an object representation\n   * @static\n   * @memberOf fabric.Triangle\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   */ fabric.Triangle.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Triangle\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), piBy2 = Math.PI * 2;\n    if (fabric.Ellipse) {\n        fabric.warn(\"fabric.Ellipse is already defined.\");\n        return;\n    }\n    /**\n   * Ellipse class\n   * @class fabric.Ellipse\n   * @extends fabric.Object\n   * @return {fabric.Ellipse} thisArg\n   * @see {@link fabric.Ellipse#initialize} for constructor definition\n   */ fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"ellipse\",\n        /**\n     * Horizontal radius\n     * @type Number\n     * @default\n     */ rx: 0,\n        /**\n     * Vertical radius\n     * @type Number\n     * @default\n     */ ry: 0,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"rx\", \"ry\"),\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @return {fabric.Ellipse} thisArg\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            this.set(\"rx\", options && options.rx || 0);\n            this.set(\"ry\", options && options.ry || 0);\n        },\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Ellipse} thisArg\n     */ _set: function(key, value) {\n            this.callSuper(\"_set\", key, value);\n            switch(key){\n                case \"rx\":\n                    this.rx = value;\n                    this.set(\"width\", value * 2);\n                    break;\n                case \"ry\":\n                    this.ry = value;\n                    this.set(\"height\", value * 2);\n                    break;\n            }\n            return this;\n        },\n        /**\n     * Returns horizontal radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRx: function() {\n            return this.get(\"rx\") * this.get(\"scaleX\");\n        },\n        /**\n     * Returns Vertical radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRy: function() {\n            return this.get(\"ry\") * this.get(\"scaleY\");\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"rx\",\n                \"ry\"\n            ].concat(propertiesToInclude));\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            return [\n                \"<ellipse \",\n                \"COMMON_PARTS\",\n                'cx=\"0\" cy=\"0\" ',\n                'rx=\"',\n                this.rx,\n                '\" ry=\"',\n                this.ry,\n                '\" />\\n'\n            ];\n        },\n        /* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render on\n     */ _render: function(ctx) {\n            ctx.beginPath();\n            ctx.save();\n            ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);\n            ctx.arc(0, 0, this.rx, 0, piBy2, false);\n            ctx.restore();\n            this._renderPaintInOrder(ctx);\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})\n   * @static\n   * @memberOf fabric.Ellipse\n   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement\n   */ fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"cx cy rx ry\".split(\" \"));\n    /**\n   * Returns {@link fabric.Ellipse} instance from an SVG element\n   * @static\n   * @memberOf fabric.Ellipse\n   * @param {SVGElement} element Element to parse\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   * @return {fabric.Ellipse}\n   */ fabric.Ellipse.fromElement = function(element, callback) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);\n        parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;\n        parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;\n        callback(new fabric.Ellipse(parsedAttributes));\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Ellipse} instance from an object representation\n   * @static\n   * @memberOf fabric.Ellipse\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   * @return {void}\n   */ fabric.Ellipse.fromObject = function(object, callback) {\n        fabric.Object._fromObject(\"Ellipse\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend;\n    if (fabric.Rect) {\n        fabric.warn(\"fabric.Rect is already defined\");\n        return;\n    }\n    /**\n   * Rectangle class\n   * @class fabric.Rect\n   * @extends fabric.Object\n   * @return {fabric.Rect} thisArg\n   * @see {@link fabric.Rect#initialize} for constructor definition\n   */ fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {\n        /**\n     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: fabric.Object.prototype.stateProperties.concat(\"rx\", \"ry\"),\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"rect\",\n        /**\n     * Horizontal border radius\n     * @type Number\n     * @default\n     */ rx: 0,\n        /**\n     * Vertical border radius\n     * @type Number\n     * @default\n     */ ry: 0,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"rx\", \"ry\"),\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            this._initRxRy();\n        },\n        /**\n     * Initializes rx/ry attributes\n     * @private\n     */ _initRxRy: function() {\n            if (this.rx && !this.ry) {\n                this.ry = this.rx;\n            } else if (this.ry && !this.rx) {\n                this.rx = this.ry;\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            // 1x1 case (used in spray brush) optimization was removed because\n            // with caching and higher zoom level this makes more damage than help\n            var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0, ry = this.ry ? Math.min(this.ry, this.height / 2) : 0, w = this.width, h = this.height, x = -this.width / 2, y = -this.height / 2, isRounded = rx !== 0 || ry !== 0, /* \"magic number\" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */ k = 1 - 0.5522847498;\n            ctx.beginPath();\n            ctx.moveTo(x + rx, y);\n            ctx.lineTo(x + w - rx, y);\n            isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);\n            ctx.lineTo(x + w, y + h - ry);\n            isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);\n            ctx.lineTo(x + rx, y + h);\n            isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);\n            ctx.lineTo(x, y + ry);\n            isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);\n            ctx.closePath();\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"rx\",\n                \"ry\"\n            ].concat(propertiesToInclude));\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var x = -this.width / 2, y = -this.height / 2;\n            return [\n                \"<rect \",\n                \"COMMON_PARTS\",\n                'x=\"',\n                x,\n                '\" y=\"',\n                y,\n                '\" rx=\"',\n                this.rx,\n                '\" ry=\"',\n                this.ry,\n                '\" width=\"',\n                this.width,\n                '\" height=\"',\n                this.height,\n                '\" />\\n'\n            ];\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)\n   * @static\n   * @memberOf fabric.Rect\n   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement\n   */ fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x y rx ry width height\".split(\" \"));\n    /**\n   * Returns {@link fabric.Rect} instance from an SVG element\n   * @static\n   * @memberOf fabric.Rect\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Rect.fromElement = function(element, callback, options) {\n        if (!element) {\n            return callback(null);\n        }\n        options = options || {};\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);\n        parsedAttributes.left = parsedAttributes.left || 0;\n        parsedAttributes.top = parsedAttributes.top || 0;\n        parsedAttributes.height = parsedAttributes.height || 0;\n        parsedAttributes.width = parsedAttributes.width || 0;\n        var rect = new fabric.Rect(extend(options ? fabric.util.object.clone(options) : {}, parsedAttributes));\n        rect.visible = rect.visible && rect.width > 0 && rect.height > 0;\n        callback(rect);\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Rect} instance from an object representation\n   * @static\n   * @memberOf fabric.Rect\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created\n   */ fabric.Rect.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Rect\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, min = fabric.util.array.min, max = fabric.util.array.max, toFixed = fabric.util.toFixed, projectStrokeOnPoints = fabric.util.projectStrokeOnPoints;\n    if (fabric.Polyline) {\n        fabric.warn(\"fabric.Polyline is already defined\");\n        return;\n    }\n    /**\n   * Polyline class\n   * @class fabric.Polyline\n   * @extends fabric.Object\n   * @see {@link fabric.Polyline#initialize} for constructor definition\n   */ fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"polyline\",\n        /**\n     * Points array\n     * @type Array\n     * @default\n     */ points: null,\n        /**\n     * WARNING: Feature in progress\n     * Calculate the exact bounding box taking in account strokeWidth on acute angles\n     * this will be turned to true by default on fabric 6.0\n     * maybe will be left in as an optimization since calculations may be slow\n     * @deprecated\n     * @type Boolean\n     * @default false\n     */ exactBoundingBox: false,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"points\"),\n        /**\n     * Constructor\n     * @param {Array} points Array of points (where each point is an object with x and y)\n     * @param {Object} [options] Options object\n     * @return {fabric.Polyline} thisArg\n     * @example\n     * var poly = new fabric.Polyline([\n     *     { x: 10, y: 10 },\n     *     { x: 50, y: 30 },\n     *     { x: 40, y: 70 },\n     *     { x: 60, y: 50 },\n     *     { x: 100, y: 150 },\n     *     { x: 40, y: 100 }\n     *   ], {\n     *   stroke: 'red',\n     *   left: 100,\n     *   top: 100\n     * });\n     */ initialize: function(points, options) {\n            options = options || {};\n            this.points = points || [];\n            this.callSuper(\"initialize\", options);\n            this._setPositionDimensions(options);\n        },\n        /**\n     * @private\n     */ _projectStrokeOnPoints: function() {\n            return projectStrokeOnPoints(this.points, this, true);\n        },\n        _setPositionDimensions: function(options) {\n            var calcDim = this._calcDimensions(options), correctLeftTop, correctSize = this.exactBoundingBox ? this.strokeWidth : 0;\n            this.width = calcDim.width - correctSize;\n            this.height = calcDim.height - correctSize;\n            if (!options.fromSVG) {\n                correctLeftTop = this.translateToGivenOrigin({\n                    // this looks bad, but is one way to keep it optional for now.\n                    x: calcDim.left - this.strokeWidth / 2 + correctSize / 2,\n                    y: calcDim.top - this.strokeWidth / 2 + correctSize / 2\n                }, \"left\", \"top\", this.originX, this.originY);\n            }\n            if (typeof options.left === \"undefined\") {\n                this.left = options.fromSVG ? calcDim.left : correctLeftTop.x;\n            }\n            if (typeof options.top === \"undefined\") {\n                this.top = options.fromSVG ? calcDim.top : correctLeftTop.y;\n            }\n            this.pathOffset = {\n                x: calcDim.left + this.width / 2 + correctSize / 2,\n                y: calcDim.top + this.height / 2 + correctSize / 2\n            };\n        },\n        /**\n     * Calculate the polygon min and max point from points array,\n     * returning an object with left, top, width, height to measure the\n     * polygon size\n     * @return {Object} object.left X coordinate of the polygon leftmost point\n     * @return {Object} object.top Y coordinate of the polygon topmost point\n     * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point\n     * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point\n     * @private\n     */ _calcDimensions: function() {\n            var points = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points, minX = min(points, \"x\") || 0, minY = min(points, \"y\") || 0, maxX = max(points, \"x\") || 0, maxY = max(points, \"y\") || 0, width = maxX - minX, height = maxY - minY;\n            return {\n                left: minX,\n                top: minY,\n                width: width,\n                height: height\n            };\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return extend(this.callSuper(\"toObject\", propertiesToInclude), {\n                points: this.points.concat()\n            });\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            for(var i = 0, len = this.points.length; i < len; i++){\n                points.push(toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), \",\", toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), \" \");\n            }\n            return [\n                \"<\" + this.type + \" \",\n                \"COMMON_PARTS\",\n                'points=\"',\n                points.join(\"\"),\n                '\" />\\n'\n            ];\n        },\n        /* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ commonRender: function(ctx) {\n            var point, len = this.points.length, x = this.pathOffset.x, y = this.pathOffset.y;\n            if (!len || isNaN(this.points[len - 1].y)) {\n                // do not draw if no points or odd points\n                // NaN comes from parseFloat of a empty string in parser\n                return false;\n            }\n            ctx.beginPath();\n            ctx.moveTo(this.points[0].x - x, this.points[0].y - y);\n            for(var i = 0; i < len; i++){\n                point = this.points[i];\n                ctx.lineTo(point.x - x, point.y - y);\n            }\n            return true;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            if (!this.commonRender(ctx)) {\n                return;\n            }\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns complexity of an instance\n     * @return {Number} complexity of this instance\n     */ complexity: function() {\n            return this.get(\"points\").length;\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})\n   * @static\n   * @memberOf fabric.Polyline\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement\n   */ fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\n    /**\n   * Returns fabric.Polyline instance from an SVG element\n   * @static\n   * @memberOf fabric.Polyline\n   * @param {SVGElement} element Element to parser\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Polyline.fromElementGenerator = function(_class) {\n        return function(element, callback, options) {\n            if (!element) {\n                return callback(null);\n            }\n            options || (options = {});\n            var points = fabric.parsePointsAttribute(element.getAttribute(\"points\")), parsedAttributes = fabric.parseAttributes(element, fabric[_class].ATTRIBUTE_NAMES);\n            parsedAttributes.fromSVG = true;\n            callback(new fabric[_class](points, extend(parsedAttributes, options)));\n        };\n    };\n    fabric.Polyline.fromElement = fabric.Polyline.fromElementGenerator(\"Polyline\");\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Polyline instance from an object representation\n   * @static\n   * @memberOf fabric.Polyline\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   */ fabric.Polyline.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Polyline\", object, callback, \"points\");\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), projectStrokeOnPoints = fabric.util.projectStrokeOnPoints;\n    if (fabric.Polygon) {\n        fabric.warn(\"fabric.Polygon is already defined\");\n        return;\n    }\n    /**\n   * Polygon class\n   * @class fabric.Polygon\n   * @extends fabric.Polyline\n   * @see {@link fabric.Polygon#initialize} for constructor definition\n   */ fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"polygon\",\n        /**\n     * @private\n     */ _projectStrokeOnPoints: function() {\n            return projectStrokeOnPoints(this.points, this);\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            if (!this.commonRender(ctx)) {\n                return;\n            }\n            ctx.closePath();\n            this._renderPaintInOrder(ctx);\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)\n   * @static\n   * @memberOf fabric.Polygon\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement\n   */ fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\n    /**\n   * Returns {@link fabric.Polygon} instance from an SVG element\n   * @static\n   * @memberOf fabric.Polygon\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Polygon.fromElement = fabric.Polyline.fromElementGenerator(\"Polygon\");\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Polygon instance from an object representation\n   * @static\n   * @memberOf fabric.Polygon\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   * @return {void}\n   */ fabric.Polygon.fromObject = function(object, callback) {\n        fabric.Object._fromObject(\"Polygon\", object, callback, \"points\");\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), min = fabric.util.array.min, max = fabric.util.array.max, extend = fabric.util.object.extend, clone = fabric.util.object.clone, toFixed = fabric.util.toFixed;\n    if (fabric.Path) {\n        fabric.warn(\"fabric.Path is already defined\");\n        return;\n    }\n    /**\n   * Path class\n   * @class fabric.Path\n   * @extends fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}\n   * @see {@link fabric.Path#initialize} for constructor definition\n   */ fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"path\",\n        /**\n     * Array of path points\n     * @type Array\n     * @default\n     */ path: null,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"path\", \"fillRule\"),\n        stateProperties: fabric.Object.prototype.stateProperties.concat(\"path\"),\n        /**\n     * Constructor\n     * @param {Array|String} path Path data (sequence of coordinates and corresponding \"command\" tokens)\n     * @param {Object} [options] Options object\n     * @return {fabric.Path} thisArg\n     */ initialize: function(path, options) {\n            options = clone(options || {});\n            delete options.path;\n            this.callSuper(\"initialize\", options);\n            this._setPath(path || [], options);\n        },\n        /**\n    * @private\n    * @param {Array|String} path Path data (sequence of coordinates and corresponding \"command\" tokens)\n    * @param {Object} [options] Options object\n    */ _setPath: function(path, options) {\n            this.path = fabric.util.makePathSimpler(Array.isArray(path) ? path : fabric.util.parsePath(path));\n            fabric.Polyline.prototype._setPositionDimensions.call(this, options || {});\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render path on\n     */ _renderPathCommands: function(ctx) {\n            var current, subpathStartX = 0, subpathStartY = 0, x = 0, y = 0, controlX = 0, controlY = 0, l = -this.pathOffset.x, t = -this.pathOffset.y;\n            ctx.beginPath();\n            for(var i = 0, len = this.path.length; i < len; ++i){\n                current = this.path[i];\n                switch(current[0]){\n                    case \"L\":\n                        x = current[1];\n                        y = current[2];\n                        ctx.lineTo(x + l, y + t);\n                        break;\n                    case \"M\":\n                        x = current[1];\n                        y = current[2];\n                        subpathStartX = x;\n                        subpathStartY = y;\n                        ctx.moveTo(x + l, y + t);\n                        break;\n                    case \"C\":\n                        x = current[5];\n                        y = current[6];\n                        controlX = current[3];\n                        controlY = current[4];\n                        ctx.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);\n                        break;\n                    case \"Q\":\n                        ctx.quadraticCurveTo(current[1] + l, current[2] + t, current[3] + l, current[4] + t);\n                        x = current[3];\n                        y = current[4];\n                        controlX = current[1];\n                        controlY = current[2];\n                        break;\n                    case \"z\":\n                    case \"Z\":\n                        x = subpathStartX;\n                        y = subpathStartY;\n                        ctx.closePath();\n                        break;\n                }\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render path on\n     */ _render: function(ctx) {\n            this._renderPathCommands(ctx);\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns string representation of an instance\n     * @return {String} string representation of an instance\n     */ toString: function() {\n            return \"#<fabric.Path (\" + this.complexity() + '): { \"top\": ' + this.top + ', \"left\": ' + this.left + \" }>\";\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return extend(this.callSuper(\"toObject\", propertiesToInclude), {\n                path: this.path.map(function(item) {\n                    return item.slice();\n                })\n            });\n        },\n        /**\n     * Returns dataless object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            var o = this.toObject([\n                \"sourcePath\"\n            ].concat(propertiesToInclude));\n            if (o.sourcePath) {\n                delete o.path;\n            }\n            return o;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var path = fabric.util.joinPath(this.path);\n            return [\n                \"<path \",\n                \"COMMON_PARTS\",\n                'd=\"',\n                path,\n                '\" stroke-linecap=\"round\" ',\n                \"/>\\n\"\n            ];\n        },\n        _getOffsetTransform: function() {\n            var digits = fabric.Object.NUM_FRACTION_DIGITS;\n            return \" translate(\" + toFixed(-this.pathOffset.x, digits) + \", \" + toFixed(-this.pathOffset.y, digits) + \")\";\n        },\n        /**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toClipPathSVG: function(reviver) {\n            var additionalTransform = this._getOffsetTransform();\n            return \"\t\" + this._createBaseClipPathSVGMarkup(this._toSVG(), {\n                reviver: reviver,\n                additionalTransform: additionalTransform\n            });\n        },\n        /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toSVG: function(reviver) {\n            var additionalTransform = this._getOffsetTransform();\n            return this._createBaseSVGMarkup(this._toSVG(), {\n                reviver: reviver,\n                additionalTransform: additionalTransform\n            });\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns number representation of an instance complexity\n     * @return {Number} complexity of this instance\n     */ complexity: function() {\n            return this.path.length;\n        },\n        /**\n     * @private\n     */ _calcDimensions: function() {\n            var aX = [], aY = [], current, subpathStartX = 0, subpathStartY = 0, x = 0, y = 0, bounds;\n            for(var i = 0, len = this.path.length; i < len; ++i){\n                current = this.path[i];\n                switch(current[0]){\n                    case \"L\":\n                        x = current[1];\n                        y = current[2];\n                        bounds = [];\n                        break;\n                    case \"M\":\n                        x = current[1];\n                        y = current[2];\n                        subpathStartX = x;\n                        subpathStartY = y;\n                        bounds = [];\n                        break;\n                    case \"C\":\n                        bounds = fabric.util.getBoundsOfCurve(x, y, current[1], current[2], current[3], current[4], current[5], current[6]);\n                        x = current[5];\n                        y = current[6];\n                        break;\n                    case \"Q\":\n                        bounds = fabric.util.getBoundsOfCurve(x, y, current[1], current[2], current[1], current[2], current[3], current[4]);\n                        x = current[3];\n                        y = current[4];\n                        break;\n                    case \"z\":\n                    case \"Z\":\n                        x = subpathStartX;\n                        y = subpathStartY;\n                        break;\n                }\n                bounds.forEach(function(point) {\n                    aX.push(point.x);\n                    aY.push(point.y);\n                });\n                aX.push(x);\n                aY.push(y);\n            }\n            var minX = min(aX) || 0, minY = min(aY) || 0, maxX = max(aX) || 0, maxY = max(aY) || 0, deltaX = maxX - minX, deltaY = maxY - minY;\n            return {\n                left: minX,\n                top: minY,\n                width: deltaX,\n                height: deltaY\n            };\n        }\n    });\n    /**\n   * Creates an instance of fabric.Path from an object\n   * @static\n   * @memberOf fabric.Path\n   * @param {Object} object\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   */ fabric.Path.fromObject = function(object, callback) {\n        if (typeof object.sourcePath === \"string\") {\n            var pathUrl = object.sourcePath;\n            fabric.loadSVGFromURL(pathUrl, function(elements) {\n                var path = elements[0];\n                path.setOptions(object);\n                if (object.clipPath) {\n                    fabric.util.enlivenObjects([\n                        object.clipPath\n                    ], function(elivenedObjects) {\n                        path.clipPath = elivenedObjects[0];\n                        callback && callback(path);\n                    });\n                } else {\n                    callback && callback(path);\n                }\n            });\n        } else {\n            fabric.Object._fromObject(\"Path\", object, callback, \"path\");\n        }\n    };\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)\n   * @static\n   * @memberOf fabric.Path\n   * @see http://www.w3.org/TR/SVG/paths.html#PathElement\n   */ fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat([\n        \"d\"\n    ]);\n    /**\n   * Creates an instance of fabric.Path from an SVG <path> element\n   * @static\n   * @memberOf fabric.Path\n   * @param {SVGElement} element to parse\n   * @param {Function} callback Callback to invoke when an fabric.Path instance is created\n   * @param {Object} [options] Options object\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   */ fabric.Path.fromElement = function(element, callback, options) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);\n        parsedAttributes.fromSVG = true;\n        callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));\n    };\n/* _FROM_SVG_END_ */ })( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), min = fabric.util.array.min, max = fabric.util.array.max;\n    if (fabric.Group) {\n        return;\n    }\n    /**\n   * Group class\n   * @class fabric.Group\n   * @extends fabric.Object\n   * @mixes fabric.Collection\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}\n   * @see {@link fabric.Group#initialize} for constructor definition\n   */ fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"group\",\n        /**\n     * Width of stroke\n     * @type Number\n     * @default\n     */ strokeWidth: 0,\n        /**\n     * Indicates if click, mouseover, mouseout events & hoverCursor should also check for subtargets\n     * @type Boolean\n     * @default\n     */ subTargetCheck: false,\n        /**\n     * Groups are container, do not render anything on theyr own, ence no cache properties\n     * @type Array\n     * @default\n     */ cacheProperties: [],\n        /**\n     * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still\n     * available setting this boolean to true.\n     * @type Boolean\n     * @since 2.0.0\n     * @default\n     */ useSetOnGroup: false,\n        /**\n     * Constructor\n     * @param {Object} objects Group objects\n     * @param {Object} [options] Options object\n     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.\n     * @return {Object} thisArg\n     */ initialize: function(objects, options, isAlreadyGrouped) {\n            options = options || {};\n            this._objects = [];\n            // if objects enclosed in a group have been grouped already,\n            // we cannot change properties of objects.\n            // Thus we need to set options to group without objects,\n            isAlreadyGrouped && this.callSuper(\"initialize\", options);\n            this._objects = objects || [];\n            for(var i = this._objects.length; i--;){\n                this._objects[i].group = this;\n            }\n            if (!isAlreadyGrouped) {\n                var center = options && options.centerPoint;\n                // we want to set origins before calculating the bounding box.\n                // so that the topleft can be set with that in mind.\n                // if specific top and left are passed, are overwritten later\n                // with the callSuper('initialize', options)\n                if (options.originX !== undefined) {\n                    this.originX = options.originX;\n                }\n                if (options.originY !== undefined) {\n                    this.originY = options.originY;\n                }\n                // if coming from svg i do not want to calc bounds.\n                // i assume width and height are passed along options\n                center || this._calcBounds();\n                this._updateObjectsCoords(center);\n                delete options.centerPoint;\n                this.callSuper(\"initialize\", options);\n            } else {\n                this._updateObjectsACoords();\n            }\n            this.setCoords();\n        },\n        /**\n     * @private\n     */ _updateObjectsACoords: function() {\n            var skipControls = true;\n            for(var i = this._objects.length; i--;){\n                this._objects[i].setCoords(skipControls);\n            }\n        },\n        /**\n     * @private\n     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change\n     */ _updateObjectsCoords: function(center) {\n            var center = center || this.getCenterPoint();\n            for(var i = this._objects.length; i--;){\n                this._updateObjectCoords(this._objects[i], center);\n            }\n        },\n        /**\n     * @private\n     * @param {Object} object\n     * @param {fabric.Point} center, current center of group.\n     */ _updateObjectCoords: function(object, center) {\n            var objectLeft = object.left, objectTop = object.top, skipControls = true;\n            object.set({\n                left: objectLeft - center.x,\n                top: objectTop - center.y\n            });\n            object.group = this;\n            object.setCoords(skipControls);\n        },\n        /**\n     * Returns string represenation of a group\n     * @return {String}\n     */ toString: function() {\n            return \"#<fabric.Group: (\" + this.complexity() + \")>\";\n        },\n        /**\n     * Adds an object to a group; Then recalculates group's dimension, position.\n     * @param {Object} object\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ addWithUpdate: function(object) {\n            var nested = !!this.group;\n            this._restoreObjectsState();\n            fabric.util.resetObjectTransform(this);\n            if (object) {\n                if (nested) {\n                    // if this group is inside another group, we need to pre transform the object\n                    fabric.util.removeTransformFromObject(object, this.group.calcTransformMatrix());\n                }\n                this._objects.push(object);\n                object.group = this;\n                object._set(\"canvas\", this.canvas);\n            }\n            this._calcBounds();\n            this._updateObjectsCoords();\n            this.dirty = true;\n            if (nested) {\n                this.group.addWithUpdate();\n            } else {\n                this.setCoords();\n            }\n            return this;\n        },\n        /**\n     * Removes an object from a group; Then recalculates group's dimension, position.\n     * @param {Object} object\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ removeWithUpdate: function(object) {\n            this._restoreObjectsState();\n            fabric.util.resetObjectTransform(this);\n            this.remove(object);\n            this._calcBounds();\n            this._updateObjectsCoords();\n            this.setCoords();\n            this.dirty = true;\n            return this;\n        },\n        /**\n     * @private\n     */ _onObjectAdded: function(object) {\n            this.dirty = true;\n            object.group = this;\n            object._set(\"canvas\", this.canvas);\n        },\n        /**\n     * @private\n     */ _onObjectRemoved: function(object) {\n            this.dirty = true;\n            delete object.group;\n        },\n        /**\n     * @private\n     */ _set: function(key, value) {\n            var i = this._objects.length;\n            if (this.useSetOnGroup) {\n                while(i--){\n                    this._objects[i].setOnGroup(key, value);\n                }\n            }\n            if (key === \"canvas\") {\n                while(i--){\n                    this._objects[i]._set(key, value);\n                }\n            }\n            fabric.Object.prototype._set.call(this, key, value);\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var _includeDefaultValues = this.includeDefaultValues;\n            var objsToObject = this._objects.filter(function(obj) {\n                return !obj.excludeFromExport;\n            }).map(function(obj) {\n                var originalDefaults = obj.includeDefaultValues;\n                obj.includeDefaultValues = _includeDefaultValues;\n                var _obj = obj.toObject(propertiesToInclude);\n                obj.includeDefaultValues = originalDefaults;\n                return _obj;\n            });\n            var obj = fabric.Object.prototype.toObject.call(this, propertiesToInclude);\n            obj.objects = objsToObject;\n            return obj;\n        },\n        /**\n     * Returns object representation of an instance, in dataless mode.\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            var objsToObject, sourcePath = this.sourcePath;\n            if (sourcePath) {\n                objsToObject = sourcePath;\n            } else {\n                var _includeDefaultValues = this.includeDefaultValues;\n                objsToObject = this._objects.map(function(obj) {\n                    var originalDefaults = obj.includeDefaultValues;\n                    obj.includeDefaultValues = _includeDefaultValues;\n                    var _obj = obj.toDatalessObject(propertiesToInclude);\n                    obj.includeDefaultValues = originalDefaults;\n                    return _obj;\n                });\n            }\n            var obj = fabric.Object.prototype.toDatalessObject.call(this, propertiesToInclude);\n            obj.objects = objsToObject;\n            return obj;\n        },\n        /**\n     * Renders instance on a given context\n     * @param {CanvasRenderingContext2D} ctx context to render instance on\n     */ render: function(ctx) {\n            this._transformDone = true;\n            this.callSuper(\"render\", ctx);\n            this._transformDone = false;\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group is already cached.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            var ownCache = fabric.Object.prototype.shouldCache.call(this);\n            if (ownCache) {\n                for(var i = 0, len = this._objects.length; i < len; i++){\n                    if (this._objects[i].willDrawShadow()) {\n                        this.ownCaching = false;\n                        return false;\n                    }\n                }\n            }\n            return ownCache;\n        },\n        /**\n     * Check if this object or a child object will cast a shadow\n     * @return {Boolean}\n     */ willDrawShadow: function() {\n            if (fabric.Object.prototype.willDrawShadow.call(this)) {\n                return true;\n            }\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                if (this._objects[i].willDrawShadow()) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Check if this group or its parent group are caching, recursively up\n     * @return {Boolean}\n     */ isOnACache: function() {\n            return this.ownCaching || this.group && this.group.isOnACache();\n        },\n        /**\n     * Execute the drawing operation for an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawObject: function(ctx) {\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                this._objects[i].render(ctx);\n            }\n            this._drawClipPath(ctx, this.clipPath);\n        },\n        /**\n     * Check if cache is dirty\n     */ isCacheDirty: function(skipCanvas) {\n            if (this.callSuper(\"isCacheDirty\", skipCanvas)) {\n                return true;\n            }\n            if (!this.statefullCache) {\n                return false;\n            }\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                if (this._objects[i].isCacheDirty(true)) {\n                    if (this._cacheCanvas) {\n                        // if this group has not a cache canvas there is nothing to clean\n                        var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;\n                        this._cacheContext.clearRect(-x / 2, -y / 2, x, y);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Restores original state of each of group objects (original state is that which was before group was created).\n     * if the nested boolean is true, the original state will be restored just for the\n     * first group and not for all the group chain\n     * @private\n     * @param {Boolean} nested tell the function to restore object state up to the parent group and not more\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ _restoreObjectsState: function() {\n            var groupMatrix = this.calcOwnMatrix();\n            this._objects.forEach(function(object) {\n                // instead of using _this = this;\n                fabric.util.addTransformToObject(object, groupMatrix);\n                delete object.group;\n                object.setCoords();\n            });\n            return this;\n        },\n        /**\n     * Destroys a group (restoring state of its objects)\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ destroy: function() {\n            // when group is destroyed objects needs to get a repaint to be eventually\n            // displayed on canvas.\n            this._objects.forEach(function(object) {\n                object.set(\"dirty\", true);\n            });\n            return this._restoreObjectsState();\n        },\n        dispose: function() {\n            this.callSuper(\"dispose\");\n            this.forEachObject(function(object) {\n                object.dispose && object.dispose();\n            });\n            this._objects = [];\n        },\n        /**\n     * make a group an active selection, remove the group from canvas\n     * the group has to be on canvas for this to work.\n     * @return {fabric.ActiveSelection} thisArg\n     * @chainable\n     */ toActiveSelection: function() {\n            if (!this.canvas) {\n                return;\n            }\n            var objects = this._objects, canvas = this.canvas;\n            this._objects = [];\n            var options = this.toObject();\n            delete options.objects;\n            var activeSelection = new fabric.ActiveSelection([]);\n            activeSelection.set(options);\n            activeSelection.type = \"activeSelection\";\n            canvas.remove(this);\n            objects.forEach(function(object) {\n                object.group = activeSelection;\n                object.dirty = true;\n                canvas.add(object);\n            });\n            activeSelection.canvas = canvas;\n            activeSelection._objects = objects;\n            canvas._activeObject = activeSelection;\n            activeSelection.setCoords();\n            return activeSelection;\n        },\n        /**\n     * Destroys a group (restoring state of its objects)\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ ungroupOnCanvas: function() {\n            return this._restoreObjectsState();\n        },\n        /**\n     * Sets coordinates of all objects inside group\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ setObjectsCoords: function() {\n            var skipControls = true;\n            this.forEachObject(function(object) {\n                object.setCoords(skipControls);\n            });\n            return this;\n        },\n        /**\n     * @private\n     */ _calcBounds: function(onlyWidthHeight) {\n            var aX = [], aY = [], o, prop, coords, props = [\n                \"tr\",\n                \"br\",\n                \"bl\",\n                \"tl\"\n            ], i = 0, iLen = this._objects.length, j, jLen = props.length;\n            for(; i < iLen; ++i){\n                o = this._objects[i];\n                coords = o.calcACoords();\n                for(j = 0; j < jLen; j++){\n                    prop = props[j];\n                    aX.push(coords[prop].x);\n                    aY.push(coords[prop].y);\n                }\n                o.aCoords = coords;\n            }\n            this._getBounds(aX, aY, onlyWidthHeight);\n        },\n        /**\n     * @private\n     */ _getBounds: function(aX, aY, onlyWidthHeight) {\n            var minXY = new fabric.Point(min(aX), min(aY)), maxXY = new fabric.Point(max(aX), max(aY)), top = minXY.y || 0, left = minXY.x || 0, width = maxXY.x - minXY.x || 0, height = maxXY.y - minXY.y || 0;\n            this.width = width;\n            this.height = height;\n            if (!onlyWidthHeight) {\n                // the bounding box always finds the topleft most corner.\n                // whatever is the group origin, we set up here the left/top position.\n                this.setPositionByOrigin({\n                    x: left,\n                    y: top\n                }, \"left\", \"top\");\n            }\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ _toSVG: function(reviver) {\n            var svgString = [\n                \"<g \",\n                \"COMMON_PARTS\",\n                \" >\\n\"\n            ];\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                svgString.push(\"\t\t\", this._objects[i].toSVG(reviver));\n            }\n            svgString.push(\"</g>\\n\");\n            return svgString;\n        },\n        /**\n     * Returns styles-string for svg-export, specific version for group\n     * @return {String}\n     */ getSvgStyles: function() {\n            var opacity = typeof this.opacity !== \"undefined\" && this.opacity !== 1 ? \"opacity: \" + this.opacity + \";\" : \"\", visibility = this.visible ? \"\" : \" visibility: hidden;\";\n            return [\n                opacity,\n                this.getSvgFilter(),\n                visibility\n            ].join(\"\");\n        },\n        /**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toClipPathSVG: function(reviver) {\n            var svgString = [];\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                svgString.push(\"\t\", this._objects[i].toClipPathSVG(reviver));\n            }\n            return this._createBaseClipPathSVGMarkup(svgString, {\n                reviver: reviver\n            });\n        }\n    });\n    /**\n   * Returns {@link fabric.Group} instance from an object representation\n   * @static\n   * @memberOf fabric.Group\n   * @param {Object} object Object to create a group from\n   * @param {Function} [callback] Callback to invoke when an group instance is created\n   */ fabric.Group.fromObject = function(object, callback) {\n        var objects = object.objects, options = fabric.util.object.clone(object, true);\n        delete options.objects;\n        if (typeof objects === \"string\") {\n            // it has to be an url or something went wrong.\n            fabric.loadSVGFromURL(objects, function(elements) {\n                var group = fabric.util.groupSVGElements(elements, object, objects);\n                var clipPath = options.clipPath;\n                delete options.clipPath;\n                group.set(options);\n                if (clipPath) {\n                    fabric.util.enlivenObjects([\n                        clipPath\n                    ], function(elivenedObjects) {\n                        group.clipPath = elivenedObjects[0];\n                        callback && callback(group);\n                    });\n                } else {\n                    callback && callback(group);\n                }\n            });\n            return;\n        }\n        fabric.util.enlivenObjects(objects, function(enlivenedObjects) {\n            fabric.util.enlivenObjectEnlivables(object, options, function() {\n                callback && callback(new fabric.Group(enlivenedObjects, options, true));\n            });\n        });\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    if (fabric.ActiveSelection) {\n        return;\n    }\n    /**\n   * Group class\n   * @class fabric.ActiveSelection\n   * @extends fabric.Group\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}\n   * @see {@link fabric.ActiveSelection#initialize} for constructor definition\n   */ fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"activeSelection\",\n        /**\n     * Constructor\n     * @param {Object} objects ActiveSelection objects\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(objects, options) {\n            options = options || {};\n            this._objects = objects || [];\n            for(var i = this._objects.length; i--;){\n                this._objects[i].group = this;\n            }\n            if (options.originX) {\n                this.originX = options.originX;\n            }\n            if (options.originY) {\n                this.originY = options.originY;\n            }\n            this._calcBounds();\n            this._updateObjectsCoords();\n            fabric.Object.prototype.initialize.call(this, options);\n            this.setCoords();\n        },\n        /**\n     * Change te activeSelection to a normal group,\n     * High level function that automatically adds it to canvas as\n     * active object. no events fired.\n     * @since 2.0.0\n     * @return {fabric.Group}\n     */ toGroup: function() {\n            var objects = this._objects.concat();\n            this._objects = [];\n            var options = fabric.Object.prototype.toObject.call(this);\n            var newGroup = new fabric.Group([]);\n            delete options.type;\n            newGroup.set(options);\n            objects.forEach(function(object) {\n                object.canvas.remove(object);\n                object.group = newGroup;\n            });\n            newGroup._objects = objects;\n            if (!this.canvas) {\n                return newGroup;\n            }\n            var canvas = this.canvas;\n            canvas.add(newGroup);\n            canvas._activeObject = newGroup;\n            newGroup.setCoords();\n            return newGroup;\n        },\n        /**\n     * If returns true, deselection is cancelled.\n     * @since 2.0.0\n     * @return {Boolean} [cancel]\n     */ onDeselect: function() {\n            this.destroy();\n            return false;\n        },\n        /**\n     * Returns string representation of a group\n     * @return {String}\n     */ toString: function() {\n            return \"#<fabric.ActiveSelection: (\" + this.complexity() + \")>\";\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * objectCaching is a global flag, wins over everything\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            return false;\n        },\n        /**\n     * Check if this group or its parent group are caching, recursively up\n     * @return {Boolean}\n     */ isOnACache: function() {\n            return false;\n        },\n        /**\n     * Renders controls and borders for the object\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [styleOverride] properties to override the object style\n     * @param {Object} [childrenOverride] properties to override the children overrides\n     */ _renderControls: function(ctx, styleOverride, childrenOverride) {\n            ctx.save();\n            ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\n            this.callSuper(\"_renderControls\", ctx, styleOverride);\n            childrenOverride = childrenOverride || {};\n            if (typeof childrenOverride.hasControls === \"undefined\") {\n                childrenOverride.hasControls = false;\n            }\n            childrenOverride.forActiveSelection = true;\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                this._objects[i]._renderControls(ctx, childrenOverride);\n            }\n            ctx.restore();\n        }\n    });\n    /**\n   * Returns {@link fabric.ActiveSelection} instance from an object representation\n   * @static\n   * @memberOf fabric.ActiveSelection\n   * @param {Object} object Object to create a group from\n   * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created\n   */ fabric.ActiveSelection.fromObject = function(object, callback) {\n        fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {\n            delete object.objects;\n            callback && callback(new fabric.ActiveSelection(enlivenedObjects, object, true));\n        });\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var extend = fabric.util.object.extend;\n    if (!global.fabric) {\n        global.fabric = {};\n    }\n    if (global.fabric.Image) {\n        fabric.warn(\"fabric.Image is already defined.\");\n        return;\n    }\n    /**\n   * Image class\n   * @class fabric.Image\n   * @extends fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}\n   * @see {@link fabric.Image#initialize} for constructor definition\n   */ fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"image\",\n        /**\n     * Width of a stroke.\n     * For image quality a stroke multiple of 2 gives better results.\n     * @type Number\n     * @default\n     */ strokeWidth: 0,\n        /**\n     * When calling {@link fabric.Image.getSrc}, return value from element src with `element.getAttribute('src')`.\n     * This allows for relative urls as image src.\n     * @since 2.7.0\n     * @type Boolean\n     * @default\n     */ srcFromAttribute: false,\n        /**\n     * private\n     * contains last value of scaleX to detect\n     * if the Image got resized after the last Render\n     * @type Number\n     */ _lastScaleX: 1,\n        /**\n     * private\n     * contains last value of scaleY to detect\n     * if the Image got resized after the last Render\n     * @type Number\n     */ _lastScaleY: 1,\n        /**\n     * private\n     * contains last value of scaling applied by the apply filter chain\n     * @type Number\n     */ _filterScalingX: 1,\n        /**\n     * private\n     * contains last value of scaling applied by the apply filter chain\n     * @type Number\n     */ _filterScalingY: 1,\n        /**\n     * minimum scale factor under which any resizeFilter is triggered to resize the image\n     * 0 will disable the automatic resize. 1 will trigger automatically always.\n     * number bigger than 1 are not implemented yet.\n     * @type Number\n     */ minimumScaleTrigger: 0.5,\n        /**\n     * List of properties to consider when checking if\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: fabric.Object.prototype.stateProperties.concat(\"cropX\", \"cropY\"),\n        /**\n     * List of properties to consider when checking if cache needs refresh\n     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single\n     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty\n     * and refreshed at the next render\n     * @type Array\n     */ cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"cropX\", \"cropY\"),\n        /**\n     * key used to retrieve the texture representing this image\n     * @since 2.0.0\n     * @type String\n     * @default\n     */ cacheKey: \"\",\n        /**\n     * Image crop in pixels from original image size.\n     * @since 2.0.0\n     * @type Number\n     * @default\n     */ cropX: 0,\n        /**\n     * Image crop in pixels from original image size.\n     * @since 2.0.0\n     * @type Number\n     * @default\n     */ cropY: 0,\n        /**\n     * Indicates whether this canvas will use image smoothing when painting this image.\n     * Also influence if the cacheCanvas for this image uses imageSmoothing\n     * @since 4.0.0-beta.11\n     * @type Boolean\n     * @default\n     */ imageSmoothing: true,\n        /**\n     * Constructor\n     * Image can be initialized with any canvas drawable or a string.\n     * The string should be a url and will be loaded as an image.\n     * Canvas and Image element work out of the box, while videos require extra code to work.\n     * Please check video element events for seeking.\n     * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} element Image element\n     * @param {Object} [options] Options object\n     * @param {function} [callback] callback function to call after eventual filters applied.\n     * @return {fabric.Image} thisArg\n     */ initialize: function(element, options) {\n            options || (options = {});\n            this.filters = [];\n            this.cacheKey = \"texture\" + fabric.Object.__uid++;\n            this.callSuper(\"initialize\", options);\n            this._initElement(element, options);\n        },\n        /**\n     * Returns image element which this instance if based on\n     * @return {HTMLImageElement} Image element\n     */ getElement: function() {\n            return this._element || {};\n        },\n        /**\n     * Sets image element for this instance to a specified one.\n     * If filters defined they are applied to new image.\n     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.\n     * @param {HTMLImageElement} element\n     * @param {Object} [options] Options object\n     * @return {fabric.Image} thisArg\n     * @chainable\n     */ setElement: function(element, options) {\n            this.removeTexture(this.cacheKey);\n            this.removeTexture(this.cacheKey + \"_filtered\");\n            this._element = element;\n            this._originalElement = element;\n            this._initConfig(options);\n            if (this.filters.length !== 0) {\n                this.applyFilters();\n            }\n            // resizeFilters work on the already filtered copy.\n            // we need to apply resizeFilters AFTER normal filters.\n            // applyResizeFilters is run more often than normal filters\n            // and is triggered by user interactions rather than dev code\n            if (this.resizeFilter) {\n                this.applyResizeFilters();\n            }\n            return this;\n        },\n        /**\n     * Delete a single texture if in webgl mode\n     */ removeTexture: function(key) {\n            var backend = fabric.filterBackend;\n            if (backend && backend.evictCachesForKey) {\n                backend.evictCachesForKey(key);\n            }\n        },\n        /**\n     * Delete textures, reference to elements and eventually JSDOM cleanup\n     */ dispose: function() {\n            this.callSuper(\"dispose\");\n            this.removeTexture(this.cacheKey);\n            this.removeTexture(this.cacheKey + \"_filtered\");\n            this._cacheContext = undefined;\n            [\n                \"_originalElement\",\n                \"_element\",\n                \"_filteredEl\",\n                \"_cacheCanvas\"\n            ].forEach((function(element) {\n                fabric.util.cleanUpJsdomNode(this[element]);\n                this[element] = undefined;\n            }).bind(this));\n        },\n        /**\n     * Get the crossOrigin value (of the corresponding image element)\n     */ getCrossOrigin: function() {\n            return this._originalElement && (this._originalElement.crossOrigin || null);\n        },\n        /**\n     * Returns original size of an image\n     * @return {Object} Object with \"width\" and \"height\" properties\n     */ getOriginalSize: function() {\n            var element = this.getElement();\n            return {\n                width: element.naturalWidth || element.width,\n                height: element.naturalHeight || element.height\n            };\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _stroke: function(ctx) {\n            if (!this.stroke || this.strokeWidth === 0) {\n                return;\n            }\n            var w = this.width / 2, h = this.height / 2;\n            ctx.beginPath();\n            ctx.moveTo(-w, -h);\n            ctx.lineTo(w, -h);\n            ctx.lineTo(w, h);\n            ctx.lineTo(-w, h);\n            ctx.lineTo(-w, -h);\n            ctx.closePath();\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var filters = [];\n            this.filters.forEach(function(filterObj) {\n                if (filterObj) {\n                    filters.push(filterObj.toObject());\n                }\n            });\n            var object = extend(this.callSuper(\"toObject\", [\n                \"cropX\",\n                \"cropY\"\n            ].concat(propertiesToInclude)), {\n                src: this.getSrc(),\n                crossOrigin: this.getCrossOrigin(),\n                filters: filters\n            });\n            if (this.resizeFilter) {\n                object.resizeFilter = this.resizeFilter.toObject();\n            }\n            return object;\n        },\n        /**\n     * Returns true if an image has crop applied, inspecting values of cropX,cropY,width,height.\n     * @return {Boolean}\n     */ hasCrop: function() {\n            return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var svgString = [], imageMarkup = [], strokeSvg, element = this._element, x = -this.width / 2, y = -this.height / 2, clipPath = \"\", imageRendering = \"\";\n            if (!element) {\n                return [];\n            }\n            if (this.hasCrop()) {\n                var clipPathId = fabric.Object.__uid++;\n                svgString.push('<clipPath id=\"imageCrop_' + clipPathId + '\">\\n', '\t<rect x=\"' + x + '\" y=\"' + y + '\" width=\"' + this.width + '\" height=\"' + this.height + '\" />\\n', \"</clipPath>\\n\");\n                clipPath = ' clip-path=\"url(#imageCrop_' + clipPathId + ')\" ';\n            }\n            if (!this.imageSmoothing) {\n                imageRendering = '\" image-rendering=\"optimizeSpeed';\n            }\n            imageMarkup.push(\"\t<image \", \"COMMON_PARTS\", 'xlink:href=\"', this.getSvgSrc(true), '\" x=\"', x - this.cropX, '\" y=\"', y - this.cropY, // we're essentially moving origin of transformation from top/left corner to the center of the shape\n            // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left\n            // so that object's center aligns with container's left/top\n            '\" width=\"', element.width || element.naturalWidth, '\" height=\"', element.height || element.height, imageRendering, '\"', clipPath, \"></image>\\n\");\n            if (this.stroke || this.strokeDashArray) {\n                var origFill = this.fill;\n                this.fill = null;\n                strokeSvg = [\n                    \"\t<rect \",\n                    'x=\"',\n                    x,\n                    '\" y=\"',\n                    y,\n                    '\" width=\"',\n                    this.width,\n                    '\" height=\"',\n                    this.height,\n                    '\" style=\"',\n                    this.getSvgStyles(),\n                    '\"/>\\n'\n                ];\n                this.fill = origFill;\n            }\n            if (this.paintFirst !== \"fill\") {\n                svgString = svgString.concat(strokeSvg, imageMarkup);\n            } else {\n                svgString = svgString.concat(imageMarkup, strokeSvg);\n            }\n            return svgString;\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns source of an image\n     * @param {Boolean} filtered indicates if the src is needed for svg\n     * @return {String} Source of an image\n     */ getSrc: function(filtered) {\n            var element = filtered ? this._element : this._originalElement;\n            if (element) {\n                if (element.toDataURL) {\n                    return element.toDataURL();\n                }\n                if (this.srcFromAttribute) {\n                    return element.getAttribute(\"src\");\n                } else {\n                    return element.src;\n                }\n            } else {\n                return this.src || \"\";\n            }\n        },\n        /**\n     * Sets source of an image\n     * @param {String} src Source string (URL)\n     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)\n     * @param {Object} [options] Options object\n     * @param {String} [options.crossOrigin] crossOrigin value (one of \"\", \"anonymous\", \"use-credentials\")\n     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes\n     * @return {fabric.Image} thisArg\n     * @chainable\n     */ setSrc: function(src, callback, options) {\n            fabric.util.loadImage(src, function(img, isError) {\n                this.setElement(img, options);\n                this._setWidthHeight();\n                callback && callback(this, isError);\n            }, this, options && options.crossOrigin);\n            return this;\n        },\n        /**\n     * Returns string representation of an instance\n     * @return {String} String representation of an instance\n     */ toString: function() {\n            return '#<fabric.Image: { src: \"' + this.getSrc() + '\" }>';\n        },\n        applyResizeFilters: function() {\n            var filter = this.resizeFilter, minimumScale = this.minimumScaleTrigger, objectScale = this.getTotalObjectScaling(), scaleX = objectScale.scaleX, scaleY = objectScale.scaleY, elementToFilter = this._filteredEl || this._originalElement;\n            if (this.group) {\n                this.set(\"dirty\", true);\n            }\n            if (!filter || scaleX > minimumScale && scaleY > minimumScale) {\n                this._element = elementToFilter;\n                this._filterScalingX = 1;\n                this._filterScalingY = 1;\n                this._lastScaleX = scaleX;\n                this._lastScaleY = scaleY;\n                return;\n            }\n            if (!fabric.filterBackend) {\n                fabric.filterBackend = fabric.initFilterBackend();\n            }\n            var canvasEl = fabric.util.createCanvasElement(), cacheKey = this._filteredEl ? this.cacheKey + \"_filtered\" : this.cacheKey, sourceWidth = elementToFilter.width, sourceHeight = elementToFilter.height;\n            canvasEl.width = sourceWidth;\n            canvasEl.height = sourceHeight;\n            this._element = canvasEl;\n            this._lastScaleX = filter.scaleX = scaleX;\n            this._lastScaleY = filter.scaleY = scaleY;\n            fabric.filterBackend.applyFilters([\n                filter\n            ], elementToFilter, sourceWidth, sourceHeight, this._element, cacheKey);\n            this._filterScalingX = canvasEl.width / this._originalElement.width;\n            this._filterScalingY = canvasEl.height / this._originalElement.height;\n        },\n        /**\n     * Applies filters assigned to this image (from \"filters\" array) or from filter param\n     * @method applyFilters\n     * @param {Array} filters to be applied\n     * @param {Boolean} forResizing specify if the filter operation is a resize operation\n     * @return {thisArg} return the fabric.Image object\n     * @chainable\n     */ applyFilters: function(filters) {\n            filters = filters || this.filters || [];\n            filters = filters.filter(function(filter) {\n                return filter && !filter.isNeutralState();\n            });\n            this.set(\"dirty\", true);\n            // needs to clear out or WEBGL will not resize correctly\n            this.removeTexture(this.cacheKey + \"_filtered\");\n            if (filters.length === 0) {\n                this._element = this._originalElement;\n                this._filteredEl = null;\n                this._filterScalingX = 1;\n                this._filterScalingY = 1;\n                return this;\n            }\n            var imgElement = this._originalElement, sourceWidth = imgElement.naturalWidth || imgElement.width, sourceHeight = imgElement.naturalHeight || imgElement.height;\n            if (this._element === this._originalElement) {\n                // if the element is the same we need to create a new element\n                var canvasEl = fabric.util.createCanvasElement();\n                canvasEl.width = sourceWidth;\n                canvasEl.height = sourceHeight;\n                this._element = canvasEl;\n                this._filteredEl = canvasEl;\n            } else {\n                // clear the existing element to get new filter data\n                // also dereference the eventual resized _element\n                this._element = this._filteredEl;\n                this._filteredEl.getContext(\"2d\").clearRect(0, 0, sourceWidth, sourceHeight);\n                // we also need to resize again at next renderAll, so remove saved _lastScaleX/Y\n                this._lastScaleX = 1;\n                this._lastScaleY = 1;\n            }\n            if (!fabric.filterBackend) {\n                fabric.filterBackend = fabric.initFilterBackend();\n            }\n            fabric.filterBackend.applyFilters(filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey);\n            if (this._originalElement.width !== this._element.width || this._originalElement.height !== this._element.height) {\n                this._filterScalingX = this._element.width / this._originalElement.width;\n                this._filterScalingY = this._element.height / this._originalElement.height;\n            }\n            return this;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            fabric.util.setImageSmoothing(ctx, this.imageSmoothing);\n            if (this.isMoving !== true && this.resizeFilter && this._needsResize()) {\n                this.applyResizeFilters();\n            }\n            this._stroke(ctx);\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Paint the cached copy of the object on the target context.\n     * it will set the imageSmoothing for the draw operation\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawCacheOnCanvas: function(ctx) {\n            fabric.util.setImageSmoothing(ctx, this.imageSmoothing);\n            fabric.Object.prototype.drawCacheOnCanvas.call(this, ctx);\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * This is the special image version where we would like to avoid caching where possible.\n     * Essentially images do not benefit from caching. They may require caching, and in that\n     * case we do it. Also caching an image usually ends in a loss of details.\n     * A full performance audit should be done.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            return this.needsItsOwnCache();\n        },\n        _renderFill: function(ctx) {\n            var elementToDraw = this._element;\n            if (!elementToDraw) {\n                return;\n            }\n            var scaleX = this._filterScalingX, scaleY = this._filterScalingY, w = this.width, h = this.height, min = Math.min, max = Math.max, // crop values cannot be lesser than 0.\n            cropX = max(this.cropX, 0), cropY = max(this.cropY, 0), elWidth = elementToDraw.naturalWidth || elementToDraw.width, elHeight = elementToDraw.naturalHeight || elementToDraw.height, sX = cropX * scaleX, sY = cropY * scaleY, // the width height cannot exceed element width/height, starting from the crop offset.\n            sW = min(w * scaleX, elWidth - sX), sH = min(h * scaleY, elHeight - sY), x = -w / 2, y = -h / 2, maxDestW = min(w, elWidth / scaleX - cropX), maxDestH = min(h, elHeight / scaleY - cropY);\n            elementToDraw && ctx.drawImage(elementToDraw, sX, sY, sW, sH, x, y, maxDestW, maxDestH);\n        },\n        /**\n     * needed to check if image needs resize\n     * @private\n     */ _needsResize: function() {\n            var scale = this.getTotalObjectScaling();\n            return scale.scaleX !== this._lastScaleX || scale.scaleY !== this._lastScaleY;\n        },\n        /**\n     * @private\n     */ _resetWidthHeight: function() {\n            this.set(this.getOriginalSize());\n        },\n        /**\n     * The Image class's initialization method. This method is automatically\n     * called by the constructor.\n     * @private\n     * @param {HTMLImageElement|String} element The element representing the image\n     * @param {Object} [options] Options object\n     */ _initElement: function(element, options) {\n            this.setElement(fabric.util.getById(element), options);\n            fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);\n        },\n        /**\n     * @private\n     * @param {Object} [options] Options object\n     */ _initConfig: function(options) {\n            options || (options = {});\n            this.setOptions(options);\n            this._setWidthHeight(options);\n        },\n        /**\n     * @private\n     * @param {Array} filters to be initialized\n     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created\n     */ _initFilters: function(filters, callback) {\n            if (filters && filters.length) {\n                fabric.util.enlivenObjects(filters, function(enlivenedObjects) {\n                    callback && callback(enlivenedObjects);\n                }, \"fabric.Image.filters\");\n            } else {\n                callback && callback();\n            }\n        },\n        /**\n     * @private\n     * Set the width and the height of the image object, using the element or the\n     * options.\n     * @param {Object} [options] Object with width/height properties\n     */ _setWidthHeight: function(options) {\n            options || (options = {});\n            var el = this.getElement();\n            this.width = options.width || el.naturalWidth || el.width || 0;\n            this.height = options.height || el.naturalHeight || el.height || 0;\n        },\n        /**\n     * Calculate offset for center and scale factor for the image in order to respect\n     * the preserveAspectRatio attribute\n     * @private\n     * @return {Object}\n     */ parsePreserveAspectRatioAttribute: function() {\n            var pAR = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || \"\"), rWidth = this._element.width, rHeight = this._element.height, scaleX = 1, scaleY = 1, offsetLeft = 0, offsetTop = 0, cropX = 0, cropY = 0, offset, pWidth = this.width, pHeight = this.height, parsedAttributes = {\n                width: pWidth,\n                height: pHeight\n            };\n            if (pAR && (pAR.alignX !== \"none\" || pAR.alignY !== \"none\")) {\n                if (pAR.meetOrSlice === \"meet\") {\n                    scaleX = scaleY = fabric.util.findScaleToFit(this._element, parsedAttributes);\n                    offset = (pWidth - rWidth * scaleX) / 2;\n                    if (pAR.alignX === \"Min\") {\n                        offsetLeft = -offset;\n                    }\n                    if (pAR.alignX === \"Max\") {\n                        offsetLeft = offset;\n                    }\n                    offset = (pHeight - rHeight * scaleY) / 2;\n                    if (pAR.alignY === \"Min\") {\n                        offsetTop = -offset;\n                    }\n                    if (pAR.alignY === \"Max\") {\n                        offsetTop = offset;\n                    }\n                }\n                if (pAR.meetOrSlice === \"slice\") {\n                    scaleX = scaleY = fabric.util.findScaleToCover(this._element, parsedAttributes);\n                    offset = rWidth - pWidth / scaleX;\n                    if (pAR.alignX === \"Mid\") {\n                        cropX = offset / 2;\n                    }\n                    if (pAR.alignX === \"Max\") {\n                        cropX = offset;\n                    }\n                    offset = rHeight - pHeight / scaleY;\n                    if (pAR.alignY === \"Mid\") {\n                        cropY = offset / 2;\n                    }\n                    if (pAR.alignY === \"Max\") {\n                        cropY = offset;\n                    }\n                    rWidth = pWidth / scaleX;\n                    rHeight = pHeight / scaleY;\n                }\n            } else {\n                scaleX = pWidth / rWidth;\n                scaleY = pHeight / rHeight;\n            }\n            return {\n                width: rWidth,\n                height: rHeight,\n                scaleX: scaleX,\n                scaleY: scaleY,\n                offsetLeft: offsetLeft,\n                offsetTop: offsetTop,\n                cropX: cropX,\n                cropY: cropY\n            };\n        }\n    });\n    /**\n   * Default CSS class name for canvas\n   * @static\n   * @type String\n   * @default\n   */ fabric.Image.CSS_CANVAS = \"canvas-img\";\n    /**\n   * Alias for getSrc\n   * @static\n   */ fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;\n    /**\n   * Creates an instance of fabric.Image from its object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} callback Callback to invoke when an image instance is created\n   */ fabric.Image.fromObject = function(_object, callback) {\n        var object = fabric.util.object.clone(_object);\n        fabric.util.loadImage(object.src, function(img, isError) {\n            if (isError) {\n                callback && callback(null, true);\n                return;\n            }\n            fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {\n                object.filters = filters || [];\n                fabric.Image.prototype._initFilters.call(object, [\n                    object.resizeFilter\n                ], function(resizeFilters) {\n                    object.resizeFilter = resizeFilters[0];\n                    fabric.util.enlivenObjectEnlivables(object, object, function() {\n                        var image = new fabric.Image(img, object);\n                        callback(image, false);\n                    });\n                });\n            });\n        }, null, object.crossOrigin);\n    };\n    /**\n   * Creates an instance of fabric.Image from an URL string\n   * @static\n   * @param {String} url URL to create an image from\n   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument). Second argument is a boolean indicating if an error occurred or not.\n   * @param {Object} [imgOptions] Options object\n   */ fabric.Image.fromURL = function(url, callback, imgOptions) {\n        fabric.util.loadImage(url, function(img, isError) {\n            callback && callback(new fabric.Image(img, imgOptions), isError);\n        }, null, imgOptions && imgOptions.crossOrigin);\n    };\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})\n   * @static\n   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}\n   */ fabric.Image.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x y width height preserveAspectRatio xlink:href crossOrigin image-rendering\".split(\" \"));\n    /**\n   * Returns {@link fabric.Image} instance from an SVG element\n   * @static\n   * @param {SVGElement} element Element to parse\n   * @param {Object} [options] Options object\n   * @param {Function} callback Callback to execute when fabric.Image object is created\n   * @return {fabric.Image} Instance of fabric.Image\n   */ fabric.Image.fromElement = function(element, callback, options) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);\n        fabric.Image.fromURL(parsedAttributes[\"xlink:href\"], callback, extend(options ? fabric.util.object.clone(options) : {}, parsedAttributes));\n    };\n/* _FROM_SVG_END_ */ })( true ? exports : 0);\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n    /**\n   * @private\n   * @return {Number} angle value\n   */ _getAngleValueForStraighten: function() {\n        var angle = this.angle % 360;\n        if (angle > 0) {\n            return Math.round((angle - 1) / 90) * 90;\n        }\n        return Math.round(angle / 90) * 90;\n    },\n    /**\n   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ straighten: function() {\n        return this.rotate(this._getAngleValueForStraighten());\n    },\n    /**\n   * Same as {@link fabric.Object.prototype.straighten} but with animation\n   * @param {Object} callbacks Object with callback functions\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.Object} thisArg\n   */ fxStraighten: function(callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: this.get(\"angle\"),\n            endValue: this._getAngleValueForStraighten(),\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                _this.rotate(value);\n                onChange();\n            },\n            onComplete: function() {\n                _this.setCoords();\n                onComplete();\n            }\n        });\n    }\n});\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n    /**\n   * Straightens object, then rerenders canvas\n   * @param {fabric.Object} object Object to straighten\n   * @return {fabric.Canvas} thisArg\n   * @chainable\n   */ straightenObject: function(object) {\n        object.straighten();\n        this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated\n   * @param {fabric.Object} object Object to straighten\n   * @return {fabric.Canvas} thisArg\n   */ fxStraightenObject: function(object) {\n        return object.fxStraighten({\n            onChange: this.requestRenderAllBound\n        });\n    }\n});\n(function() {\n    \"use strict\";\n    /**\n   * Tests if webgl supports certain precision\n   * @param {WebGL} Canvas WebGL context to test on\n   * @param {String} Precision to test can be any of following: 'lowp', 'mediump', 'highp'\n   * @returns {Boolean} Whether the user's browser WebGL supports given precision.\n   */ function testPrecision(gl, precision) {\n        var fragmentSource = \"precision \" + precision + \" float;\\nvoid main(){}\";\n        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, fragmentSource);\n        gl.compileShader(fragmentShader);\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n   * Indicate whether this filtering backend is supported by the user's browser.\n   * @param {Number} tileSize check if the tileSize is supported\n   * @returns {Boolean} Whether the user's browser supports WebGL.\n   */ fabric.isWebglSupported = function(tileSize) {\n        if (fabric.isLikelyNode) {\n            return false;\n        }\n        tileSize = tileSize || fabric.WebglFilterBackend.prototype.tileSize;\n        var canvas = document.createElement(\"canvas\");\n        var gl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\n        var isSupported = false;\n        // eslint-disable-next-line\n        if (gl) {\n            fabric.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n            isSupported = fabric.maxTextureSize >= tileSize;\n            var precisions = [\n                \"highp\",\n                \"mediump\",\n                \"lowp\"\n            ];\n            for(var i = 0; i < 3; i++){\n                if (testPrecision(gl, precisions[i])) {\n                    fabric.webGlPrecision = precisions[i];\n                    break;\n                }\n                ;\n            }\n        }\n        this.isSupported = isSupported;\n        return isSupported;\n    };\n    fabric.WebglFilterBackend = WebglFilterBackend;\n    /**\n   * WebGL filter backend.\n   */ function WebglFilterBackend(options) {\n        if (options && options.tileSize) {\n            this.tileSize = options.tileSize;\n        }\n        this.setupGLContext(this.tileSize, this.tileSize);\n        this.captureGPUInfo();\n    }\n    ;\n    WebglFilterBackend.prototype = /** @lends fabric.WebglFilterBackend.prototype */ {\n        tileSize: 2048,\n        /**\n     * Experimental. This object is a sort of repository of help layers used to avoid\n     * of recreating them during frequent filtering. If you are previewing a filter with\n     * a slider you probably do not want to create help layers every filter step.\n     * in this object there will be appended some canvases, created once, resized sometimes\n     * cleared never. Clearing is left to the developer.\n     **/ resources: {},\n        /**\n     * Setup a WebGL context suitable for filtering, and bind any needed event handlers.\n     */ setupGLContext: function(width, height) {\n            this.dispose();\n            this.createWebGLCanvas(width, height);\n            // eslint-disable-next-line\n            this.aPosition = new Float32Array([\n                0,\n                0,\n                0,\n                1,\n                1,\n                0,\n                1,\n                1\n            ]);\n            this.chooseFastestCopyGLTo2DMethod(width, height);\n        },\n        /**\n     * Pick a method to copy data from GL context to 2d canvas.  In some browsers using\n     * putImageData is faster than drawImage for that specific operation.\n     */ chooseFastestCopyGLTo2DMethod: function(width, height) {\n            var canMeasurePerf = typeof window.performance !== \"undefined\", canUseImageData;\n            try {\n                new ImageData(1, 1);\n                canUseImageData = true;\n            } catch (e) {\n                canUseImageData = false;\n            }\n            // eslint-disable-next-line no-undef\n            var canUseArrayBuffer = typeof ArrayBuffer !== \"undefined\";\n            // eslint-disable-next-line no-undef\n            var canUseUint8Clamped = typeof Uint8ClampedArray !== \"undefined\";\n            if (!(canMeasurePerf && canUseImageData && canUseArrayBuffer && canUseUint8Clamped)) {\n                return;\n            }\n            var targetCanvas = fabric.util.createCanvasElement();\n            // eslint-disable-next-line no-undef\n            var imageBuffer = new ArrayBuffer(width * height * 4);\n            if (fabric.forceGLPutImageData) {\n                this.imageBuffer = imageBuffer;\n                this.copyGLTo2D = copyGLTo2DPutImageData;\n                return;\n            }\n            var testContext = {\n                imageBuffer: imageBuffer,\n                destinationWidth: width,\n                destinationHeight: height,\n                targetCanvas: targetCanvas\n            };\n            var startTime, drawImageTime, putImageDataTime;\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            startTime = window.performance.now();\n            copyGLTo2DDrawImage.call(testContext, this.gl, testContext);\n            drawImageTime = window.performance.now() - startTime;\n            startTime = window.performance.now();\n            copyGLTo2DPutImageData.call(testContext, this.gl, testContext);\n            putImageDataTime = window.performance.now() - startTime;\n            if (drawImageTime > putImageDataTime) {\n                this.imageBuffer = imageBuffer;\n                this.copyGLTo2D = copyGLTo2DPutImageData;\n            } else {\n                this.copyGLTo2D = copyGLTo2DDrawImage;\n            }\n        },\n        /**\n     * Create a canvas element and associated WebGL context and attaches them as\n     * class properties to the GLFilterBackend class.\n     */ createWebGLCanvas: function(width, height) {\n            var canvas = fabric.util.createCanvasElement();\n            canvas.width = width;\n            canvas.height = height;\n            var glOptions = {\n                alpha: true,\n                premultipliedAlpha: false,\n                depth: false,\n                stencil: false,\n                antialias: false\n            }, gl = canvas.getContext(\"webgl\", glOptions);\n            if (!gl) {\n                gl = canvas.getContext(\"experimental-webgl\", glOptions);\n            }\n            if (!gl) {\n                return;\n            }\n            gl.clearColor(0, 0, 0, 0);\n            // this canvas can fire webglcontextlost and webglcontextrestored\n            this.canvas = canvas;\n            this.gl = gl;\n        },\n        /**\n     * Attempts to apply the requested filters to the source provided, drawing the filtered output\n     * to the provided target canvas.\n     *\n     * @param {Array} filters The filters to apply.\n     * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.\n     * @param {Number} width The width of the source input.\n     * @param {Number} height The height of the source input.\n     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.\n     * @param {String|undefined} cacheKey A key used to cache resources related to the source. If\n     * omitted, caching will be skipped.\n     */ applyFilters: function(filters, source, width, height, targetCanvas, cacheKey) {\n            var gl = this.gl;\n            var cachedTexture;\n            if (cacheKey) {\n                cachedTexture = this.getCachedTexture(cacheKey, source);\n            }\n            var pipelineState = {\n                originalWidth: source.width || source.originalWidth,\n                originalHeight: source.height || source.originalHeight,\n                sourceWidth: width,\n                sourceHeight: height,\n                destinationWidth: width,\n                destinationHeight: height,\n                context: gl,\n                sourceTexture: this.createTexture(gl, width, height, !cachedTexture && source),\n                targetTexture: this.createTexture(gl, width, height),\n                originalTexture: cachedTexture || this.createTexture(gl, width, height, !cachedTexture && source),\n                passes: filters.length,\n                webgl: true,\n                aPosition: this.aPosition,\n                programCache: this.programCache,\n                pass: 0,\n                filterBackend: this,\n                targetCanvas: targetCanvas\n            };\n            var tempFbo = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);\n            filters.forEach(function(filter) {\n                filter && filter.applyTo(pipelineState);\n            });\n            resizeCanvasIfNeeded(pipelineState);\n            this.copyGLTo2D(gl, pipelineState);\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            gl.deleteTexture(pipelineState.sourceTexture);\n            gl.deleteTexture(pipelineState.targetTexture);\n            gl.deleteFramebuffer(tempFbo);\n            targetCanvas.getContext(\"2d\").setTransform(1, 0, 0, 1, 0, 0);\n            return pipelineState;\n        },\n        /**\n     * Detach event listeners, remove references, and clean up caches.\n     */ dispose: function() {\n            if (this.canvas) {\n                this.canvas = null;\n                this.gl = null;\n            }\n            this.clearWebGLCaches();\n        },\n        /**\n     * Wipe out WebGL-related caches.\n     */ clearWebGLCaches: function() {\n            this.programCache = {};\n            this.textureCache = {};\n        },\n        /**\n     * Create a WebGL texture object.\n     *\n     * Accepts specific dimensions to initialize the texture to or a source image.\n     *\n     * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.\n     * @param {Number} width The width to initialize the texture at.\n     * @param {Number} height The height to initialize the texture.\n     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.\n     * @param {Number} filterType gl.NEAREST or gl.LINEAR usually, webgl numeri constants\n     * @returns {WebGLTexture}\n     */ createTexture: function(gl, width, height, textureImageSource, filterType) {\n            var texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterType || gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterType || gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            if (textureImageSource) {\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);\n            } else {\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n            }\n            return texture;\n        },\n        /**\n     * Can be optionally used to get a texture from the cache array\n     *\n     * If an existing texture is not found, a new texture is created and cached.\n     *\n     * @param {String} uniqueId A cache key to use to find an existing texture.\n     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the\n     * texture cache entry if one does not already exist.\n     */ getCachedTexture: function(uniqueId, textureImageSource) {\n            if (this.textureCache[uniqueId]) {\n                return this.textureCache[uniqueId];\n            } else {\n                var texture = this.createTexture(this.gl, textureImageSource.width, textureImageSource.height, textureImageSource);\n                this.textureCache[uniqueId] = texture;\n                return texture;\n            }\n        },\n        /**\n     * Clear out cached resources related to a source image that has been\n     * filtered previously.\n     *\n     * @param {String} cacheKey The cache key provided when the source image was filtered.\n     */ evictCachesForKey: function(cacheKey) {\n            if (this.textureCache[cacheKey]) {\n                this.gl.deleteTexture(this.textureCache[cacheKey]);\n                delete this.textureCache[cacheKey];\n            }\n        },\n        copyGLTo2D: copyGLTo2DDrawImage,\n        /**\n     * Attempt to extract GPU information strings from a WebGL context.\n     *\n     * Useful information when debugging or blacklisting specific GPUs.\n     *\n     * @returns {Object} A GPU info object with renderer and vendor strings.\n     */ captureGPUInfo: function() {\n            if (this.gpuInfo) {\n                return this.gpuInfo;\n            }\n            var gl = this.gl, gpuInfo = {\n                renderer: \"\",\n                vendor: \"\"\n            };\n            if (!gl) {\n                return gpuInfo;\n            }\n            var ext = gl.getExtension(\"WEBGL_debug_renderer_info\");\n            if (ext) {\n                var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);\n                var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);\n                if (renderer) {\n                    gpuInfo.renderer = renderer.toLowerCase();\n                }\n                if (vendor) {\n                    gpuInfo.vendor = vendor.toLowerCase();\n                }\n            }\n            this.gpuInfo = gpuInfo;\n            return gpuInfo;\n        }\n    };\n})();\nfunction resizeCanvasIfNeeded(pipelineState) {\n    var targetCanvas = pipelineState.targetCanvas, width = targetCanvas.width, height = targetCanvas.height, dWidth = pipelineState.destinationWidth, dHeight = pipelineState.destinationHeight;\n    if (width !== dWidth || height !== dHeight) {\n        targetCanvas.width = dWidth;\n        targetCanvas.height = dHeight;\n    }\n}\n/**\n * Copy an input WebGL canvas on to an output 2D canvas.\n *\n * The WebGL canvas is assumed to be upside down, with the top-left pixel of the\n * desired output image appearing in the bottom-left corner of the WebGL canvas.\n *\n * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.\n * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.\n * @param {Object} pipelineState The 2D target canvas to copy on to.\n */ function copyGLTo2DDrawImage(gl, pipelineState) {\n    var glCanvas = gl.canvas, targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext(\"2d\");\n    ctx.translate(0, targetCanvas.height); // move it down again\n    ctx.scale(1, -1); // vertical flip\n    // where is my image on the big glcanvas?\n    var sourceY = glCanvas.height - targetCanvas.height;\n    ctx.drawImage(glCanvas, 0, sourceY, targetCanvas.width, targetCanvas.height, 0, 0, targetCanvas.width, targetCanvas.height);\n}\n/**\n * Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData\n * API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra).\n *\n * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.\n * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.\n * @param {Object} pipelineState The 2D target canvas to copy on to.\n */ function copyGLTo2DPutImageData(gl, pipelineState) {\n    var targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext(\"2d\"), dWidth = pipelineState.destinationWidth, dHeight = pipelineState.destinationHeight, numBytes = dWidth * dHeight * 4;\n    // eslint-disable-next-line no-undef\n    var u8 = new Uint8Array(this.imageBuffer, 0, numBytes);\n    // eslint-disable-next-line no-undef\n    var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);\n    gl.readPixels(0, 0, dWidth, dHeight, gl.RGBA, gl.UNSIGNED_BYTE, u8);\n    var imgData = new ImageData(u8Clamped, dWidth, dHeight);\n    ctx.putImageData(imgData, 0, 0);\n}\n(function() {\n    \"use strict\";\n    var noop = function() {};\n    fabric.Canvas2dFilterBackend = Canvas2dFilterBackend;\n    /**\n   * Canvas 2D filter backend.\n   */ function Canvas2dFilterBackend() {}\n    ;\n    Canvas2dFilterBackend.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */ {\n        evictCachesForKey: noop,\n        dispose: noop,\n        clearWebGLCaches: noop,\n        /**\n     * Experimental. This object is a sort of repository of help layers used to avoid\n     * of recreating them during frequent filtering. If you are previewing a filter with\n     * a slider you probably do not want to create help layers every filter step.\n     * in this object there will be appended some canvases, created once, resized sometimes\n     * cleared never. Clearing is left to the developer.\n     **/ resources: {},\n        /**\n     * Apply a set of filters against a source image and draw the filtered output\n     * to the provided destination canvas.\n     *\n     * @param {EnhancedFilter} filters The filter to apply.\n     * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.\n     * @param {Number} sourceWidth The width of the source input.\n     * @param {Number} sourceHeight The height of the source input.\n     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.\n     */ applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {\n            var ctx = targetCanvas.getContext(\"2d\");\n            ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);\n            var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);\n            var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);\n            var pipelineState = {\n                sourceWidth: sourceWidth,\n                sourceHeight: sourceHeight,\n                imageData: imageData,\n                originalEl: sourceElement,\n                originalImageData: originalImageData,\n                canvasEl: targetCanvas,\n                ctx: ctx,\n                filterBackend: this\n            };\n            filters.forEach(function(filter) {\n                filter.applyTo(pipelineState);\n            });\n            if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {\n                targetCanvas.width = pipelineState.imageData.width;\n                targetCanvas.height = pipelineState.imageData.height;\n            }\n            ctx.putImageData(pipelineState.imageData, 0, 0);\n            return pipelineState;\n        }\n    };\n})();\n/**\n * @namespace fabric.Image.filters\n * @memberOf fabric.Image\n * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}\n * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n */ fabric.Image = fabric.Image || {};\nfabric.Image.filters = fabric.Image.filters || {};\n/**\n * Root filter class from which all filter classes inherit from\n * @class fabric.Image.filters.BaseFilter\n * @memberOf fabric.Image.filters\n */ fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {\n    /**\n   * Filter type\n   * @param {String} type\n   * @default\n   */ type: \"BaseFilter\",\n    /**\n   * Array of attributes to send with buffers. do not modify\n   * @private\n   */ vertexSource: \"attribute vec2 aPosition;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vTexCoord = aPosition;\\n\" + \"gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\\n\" + \"}\",\n    fragmentSource: \"precision highp float;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"void main() {\\n\" + \"gl_FragColor = texture2D(uTexture, vTexCoord);\\n\" + \"}\",\n    /**\n   * Constructor\n   * @param {Object} [options] Options object\n   */ initialize: function(options) {\n        if (options) {\n            this.setOptions(options);\n        }\n    },\n    /**\n   * Sets filter's properties from options\n   * @param {Object} [options] Options object\n   */ setOptions: function(options) {\n        for(var prop in options){\n            this[prop] = options[prop];\n        }\n    },\n    /**\n   * Compile this filter's shader program.\n   *\n   * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.\n   * @param {String} fragmentSource fragmentShader source for compilation\n   * @param {String} vertexSource vertexShader source for compilation\n   */ createProgram: function(gl, fragmentSource, vertexSource) {\n        fragmentSource = fragmentSource || this.fragmentSource;\n        vertexSource = vertexSource || this.vertexSource;\n        if (fabric.webGlPrecision !== \"highp\") {\n            fragmentSource = fragmentSource.replace(/precision highp float/g, \"precision \" + fabric.webGlPrecision + \" float\");\n        }\n        var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vertexShader, vertexSource);\n        gl.compileShader(vertexShader);\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n            throw new Error(// eslint-disable-next-line prefer-template\n            \"Vertex shader compile error for \" + this.type + \": \" + gl.getShaderInfoLog(vertexShader));\n        }\n        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, fragmentSource);\n        gl.compileShader(fragmentShader);\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n            throw new Error(// eslint-disable-next-line prefer-template\n            \"Fragment shader compile error for \" + this.type + \": \" + gl.getShaderInfoLog(fragmentShader));\n        }\n        var program = gl.createProgram();\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.linkProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            throw new Error(// eslint-disable-next-line prefer-template\n            'Shader link error for \"${this.type}\" ' + gl.getProgramInfoLog(program));\n        }\n        var attributeLocations = this.getAttributeLocations(gl, program);\n        var uniformLocations = this.getUniformLocations(gl, program) || {};\n        uniformLocations.uStepW = gl.getUniformLocation(program, \"uStepW\");\n        uniformLocations.uStepH = gl.getUniformLocation(program, \"uStepH\");\n        return {\n            program: program,\n            attributeLocations: attributeLocations,\n            uniformLocations: uniformLocations\n        };\n    },\n    /**\n   * Return a map of attribute names to WebGLAttributeLocation objects.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.\n   * @returns {Object} A map of attribute names to attribute locations.\n   */ getAttributeLocations: function(gl, program) {\n        return {\n            aPosition: gl.getAttribLocation(program, \"aPosition\")\n        };\n    },\n    /**\n   * Return a map of uniform names to WebGLUniformLocation objects.\n   *\n   * Intended to be overridden by subclasses.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.\n   * @returns {Object} A map of uniform names to uniform locations.\n   */ getUniformLocations: function() {\n        // in case i do not need any special uniform i need to return an empty object\n        return {};\n    },\n    /**\n   * Send attribute data from this filter to its shader program on the GPU.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {Object} attributeLocations A map of shader attribute names to their locations.\n   */ sendAttributeData: function(gl, attributeLocations, aPositionData) {\n        var attributeLocation = attributeLocations.aPosition;\n        var buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.enableVertexAttribArray(attributeLocation);\n        gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);\n        gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);\n    },\n    _setupFrameBuffer: function(options) {\n        var gl = options.context, width, height;\n        if (options.passes > 1) {\n            width = options.destinationWidth;\n            height = options.destinationHeight;\n            if (options.sourceWidth !== width || options.sourceHeight !== height) {\n                gl.deleteTexture(options.targetTexture);\n                options.targetTexture = options.filterBackend.createTexture(gl, width, height);\n            }\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, options.targetTexture, 0);\n        } else {\n            // draw last filter on canvas and not to framebuffer.\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            gl.finish();\n        }\n    },\n    _swapTextures: function(options) {\n        options.passes--;\n        options.pass++;\n        var temp = options.targetTexture;\n        options.targetTexture = options.sourceTexture;\n        options.sourceTexture = temp;\n    },\n    /**\n   * Generic isNeutral implementation for one parameter based filters.\n   * Used only in image applyFilters to discard filters that will not have an effect\n   * on the image\n   * Other filters may need their own version ( ColorMatrix, HueRotation, gamma, ComposedFilter )\n   * @param {Object} options\n   **/ isNeutralState: function() {\n        var main = this.mainParameter, _class = fabric.Image.filters[this.type].prototype;\n        if (main) {\n            if (Array.isArray(_class[main])) {\n                for(var i = _class[main].length; i--;){\n                    if (this[main][i] !== _class[main][i]) {\n                        return false;\n                    }\n                }\n                return true;\n            } else {\n                return _class[main] === this[main];\n            }\n        } else {\n            return false;\n        }\n    },\n    /**\n   * Apply this filter to the input image data provided.\n   *\n   * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be executed\n   * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */ applyTo: function(options) {\n        if (options.webgl) {\n            this._setupFrameBuffer(options);\n            this.applyToWebGL(options);\n            this._swapTextures(options);\n        } else {\n            this.applyTo2d(options);\n        }\n    },\n    /**\n   * Retrieves the cached shader.\n   * @param {Object} options\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */ retrieveShader: function(options) {\n        if (!options.programCache.hasOwnProperty(this.type)) {\n            options.programCache[this.type] = this.createProgram(options.context);\n        }\n        return options.programCache[this.type];\n    },\n    /**\n   * Apply this filter using webgl.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be executed\n   * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n   * @param {WebGLTexture} options.originalTexture The texture of the original input image.\n   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */ applyToWebGL: function(options) {\n        var gl = options.context;\n        var shader = this.retrieveShader(options);\n        if (options.pass === 0 && options.originalTexture) {\n            gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);\n        } else {\n            gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);\n        }\n        gl.useProgram(shader.program);\n        this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);\n        gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);\n        gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);\n        this.sendUniformData(gl, shader.uniformLocations);\n        gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    },\n    bindAdditionalTexture: function(gl, texture, textureUnit) {\n        gl.activeTexture(textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        // reset active texture to 0 as usual\n        gl.activeTexture(gl.TEXTURE0);\n    },\n    unbindAdditionalTexture: function(gl, textureUnit) {\n        gl.activeTexture(textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.activeTexture(gl.TEXTURE0);\n    },\n    getMainParameter: function() {\n        return this[this.mainParameter];\n    },\n    setMainParameter: function(value) {\n        this[this.mainParameter] = value;\n    },\n    /**\n   * Send uniform data from this filter to its shader program on the GPU.\n   *\n   * Intended to be overridden by subclasses.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {Object} uniformLocations A map of shader uniform names to their locations.\n   */ sendUniformData: function() {\n    // Intentionally left blank.  Override me in subclasses.\n    },\n    /**\n   * If needed by a 2d filter, this functions can create an helper canvas to be used\n   * remember that options.targetCanvas is available for use till end of chain.\n   */ createHelpLayer: function(options) {\n        if (!options.helpLayer) {\n            var helpLayer = document.createElement(\"canvas\");\n            helpLayer.width = options.sourceWidth;\n            helpLayer.height = options.sourceHeight;\n            options.helpLayer = helpLayer;\n        }\n    },\n    /**\n   * Returns object representation of an instance\n   * @return {Object} Object representation of an instance\n   */ toObject: function() {\n        var object = {\n            type: this.type\n        }, mainP = this.mainParameter;\n        if (mainP) {\n            object[mainP] = this[mainP];\n        }\n        return object;\n    },\n    /**\n   * Returns a JSON representation of an instance\n   * @return {Object} JSON\n   */ toJSON: function() {\n        // delegate, not alias\n        return this.toObject();\n    }\n});\nfabric.Image.filters.BaseFilter.fromObject = function(object, callback) {\n    var filter = new fabric.Image.filters[object.type](object);\n    callback && callback(filter);\n    return filter;\n};\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Color Matrix filter class\n   * @class fabric.Image.filters.ColorMatrix\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}\n   * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}\n   * @example <caption>Kodachrome filter</caption>\n   * var filter = new fabric.Image.filters.ColorMatrix({\n   *  matrix: [\n       1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,\n       -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,\n       -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,\n       0, 0, 0, 1, 0\n      ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"ColorMatrix\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"uniform mat4 uColorMatrix;\\n\" + \"uniform vec4 uConstants;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"color *= uColorMatrix;\\n\" + \"color += uConstants;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Colormatrix for pixels.\n     * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning\n     * outside the -1, 1 range.\n     * 0.0039215686 is the part of 1 that get translated to 1 in 2d\n     * @param {Array} matrix array of 20 numbers.\n     * @default\n     */ matrix: [\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        mainParameter: \"matrix\",\n        /**\n     * Lock the colormatrix on the color part, skipping alpha, mainly for non webgl scenario\n     * to save some calculation\n     * @type Boolean\n     * @default true\n     */ colorsOnly: true,\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            // create a new array instead mutating the prototype with push\n            this.matrix = this.matrix.slice(0);\n        },\n        /**\n     * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, iLen = data.length, m = this.matrix, r, g, b, a, i, colorsOnly = this.colorsOnly;\n            for(i = 0; i < iLen; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                if (colorsOnly) {\n                    data[i] = r * m[0] + g * m[1] + b * m[2] + m[4] * 255;\n                    data[i + 1] = r * m[5] + g * m[6] + b * m[7] + m[9] * 255;\n                    data[i + 2] = r * m[10] + g * m[11] + b * m[12] + m[14] * 255;\n                } else {\n                    a = data[i + 3];\n                    data[i] = r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[4] * 255;\n                    data[i + 1] = r * m[5] + g * m[6] + b * m[7] + a * m[8] + m[9] * 255;\n                    data[i + 2] = r * m[10] + g * m[11] + b * m[12] + a * m[13] + m[14] * 255;\n                    data[i + 3] = r * m[15] + g * m[16] + b * m[17] + a * m[18] + m[19] * 255;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uColorMatrix: gl.getUniformLocation(program, \"uColorMatrix\"),\n                uConstants: gl.getUniformLocation(program, \"uConstants\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var m = this.matrix, matrix = [\n                m[0],\n                m[1],\n                m[2],\n                m[3],\n                m[5],\n                m[6],\n                m[7],\n                m[8],\n                m[10],\n                m[11],\n                m[12],\n                m[13],\n                m[15],\n                m[16],\n                m[17],\n                m[18]\n            ], constants = [\n                m[4],\n                m[9],\n                m[14],\n                m[19]\n            ];\n            gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix);\n            gl.uniform4fv(uniformLocations.uConstants, constants);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] function to invoke after filter creation\n   * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix\n   */ fabric.Image.filters.ColorMatrix.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Brightness filter class\n   * @class fabric.Image.filters.Brightness\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Brightness({\n   *   brightness: 0.05\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Brightness\",\n        /**\n     * Fragment source for the brightness program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uBrightness;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"color.rgb += uBrightness;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Brightness value, from -1 to 1.\n     * translated to -255 to 255 for 2d\n     * 0.0039215686 is the part of 1 that get translated to 1 in 2d\n     * @param {Number} brightness\n     * @default\n     */ brightness: 0,\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"brightness\",\n        /**\n    * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n    *\n    * @param {Object} options\n    * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n    */ applyTo2d: function(options) {\n            if (this.brightness === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, i, len = data.length, brightness = Math.round(this.brightness * 255);\n            for(i = 0; i < len; i += 4){\n                data[i] = data[i] + brightness;\n                data[i + 1] = data[i + 1] + brightness;\n                data[i + 2] = data[i + 2] + brightness;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uBrightness: gl.getUniformLocation(program, \"uBrightness\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uBrightness, this.brightness);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness\n   */ fabric.Image.filters.Brightness.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Adapted from <a href=\"http://www.html5rocks.com/en/tutorials/canvas/imagefilters/\">html5rocks article</a>\n   * @class fabric.Image.filters.Convolute\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example <caption>Sharpen filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 0, -1,  0,\n   *            -1,  5, -1,\n   *             0, -1,  0 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Blur filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 1/9, 1/9, 1/9,\n   *             1/9, 1/9, 1/9,\n   *             1/9, 1/9, 1/9 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Emboss filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 1,   1,  1,\n   *             1, 0.7, -1,\n   *            -1,  -1, -1 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Emboss filter with opaqueness</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   opaque: true,\n   *   matrix: [ 1,   1,  1,\n   *             1, 0.7, -1,\n   *            -1,  -1, -1 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Convolute\",\n        /*\n     * Opaque value (true/false)\n     */ opaque: false,\n        /*\n     * matrix for the filter, max 9x9\n     */ matrix: [\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0\n        ],\n        /**\n     * Fragment source for the brightness program\n     */ fragmentSource: {\n            Convolute_3_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[9];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 3.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 3.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_3_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[9];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 3.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 3.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\",\n            Convolute_5_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[25];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 5.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 5.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_5_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[25];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 5.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 5.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\",\n            Convolute_7_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[49];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 7.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 7.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_7_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[49];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 7.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 7.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\",\n            Convolute_9_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[81];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 9.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 9.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_9_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[81];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 9.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 9.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\"\n        },\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Convolute.prototype\n     * @param {Object} [options] Options object\n     * @param {Boolean} [options.opaque=false] Opaque value (true/false)\n     * @param {Array} [options.matrix] Filter matrix\n     */ /**\n    * Retrieves the cached shader.\n    * @param {Object} options\n    * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n    * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n    */ retrieveShader: function(options) {\n            var size = Math.sqrt(this.matrix.length);\n            var cacheKey = this.type + \"_\" + size + \"_\" + (this.opaque ? 1 : 0);\n            var shaderSource = this.fragmentSource[cacheKey];\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        /**\n     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, weights = this.matrix, side = Math.round(Math.sqrt(weights.length)), halfSide = Math.floor(side / 2), sw = imageData.width, sh = imageData.height, output = options.ctx.createImageData(sw, sh), dst = output.data, // go through the destination image pixels\n            alphaFac = this.opaque ? 1 : 0, r, g, b, a, dstOff, scx, scy, srcOff, wt, x, y, cx, cy;\n            for(y = 0; y < sh; y++){\n                for(x = 0; x < sw; x++){\n                    dstOff = (y * sw + x) * 4;\n                    // calculate the weighed sum of the source image pixels that\n                    // fall under the convolution matrix\n                    r = 0;\n                    g = 0;\n                    b = 0;\n                    a = 0;\n                    for(cy = 0; cy < side; cy++){\n                        for(cx = 0; cx < side; cx++){\n                            scy = y + cy - halfSide;\n                            scx = x + cx - halfSide;\n                            // eslint-disable-next-line max-depth\n                            if (scy < 0 || scy >= sh || scx < 0 || scx >= sw) {\n                                continue;\n                            }\n                            srcOff = (scy * sw + scx) * 4;\n                            wt = weights[cy * side + cx];\n                            r += data[srcOff] * wt;\n                            g += data[srcOff + 1] * wt;\n                            b += data[srcOff + 2] * wt;\n                            // eslint-disable-next-line max-depth\n                            if (!alphaFac) {\n                                a += data[srcOff + 3] * wt;\n                            }\n                        }\n                    }\n                    dst[dstOff] = r;\n                    dst[dstOff + 1] = g;\n                    dst[dstOff + 2] = b;\n                    if (!alphaFac) {\n                        dst[dstOff + 3] = a;\n                    } else {\n                        dst[dstOff + 3] = data[dstOff + 3];\n                    }\n                }\n            }\n            options.imageData = output;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uMatrix: gl.getUniformLocation(program, \"uMatrix\"),\n                uOpaque: gl.getUniformLocation(program, \"uOpaque\"),\n                uHalfSize: gl.getUniformLocation(program, \"uHalfSize\"),\n                uSize: gl.getUniformLocation(program, \"uSize\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1fv(uniformLocations.uMatrix, this.matrix);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return extend(this.callSuper(\"toObject\"), {\n                opaque: this.opaque,\n                matrix: this.matrix\n            });\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute\n   */ fabric.Image.filters.Convolute.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Grayscale image filter class\n   * @class fabric.Image.filters.Grayscale\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Grayscale();\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Grayscale\",\n        fragmentSource: {\n            average: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float average = (color.r + color.b + color.g) / 3.0;\\n\" + \"gl_FragColor = vec4(average, average, average, color.a);\\n\" + \"}\",\n            lightness: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform int uMode;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 col = texture2D(uTexture, vTexCoord);\\n\" + \"float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\\n\" + \"gl_FragColor = vec4(average, average, average, col.a);\\n\" + \"}\",\n            luminosity: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform int uMode;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 col = texture2D(uTexture, vTexCoord);\\n\" + \"float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\\n\" + \"gl_FragColor = vec4(average, average, average, col.a);\\n\" + \"}\"\n        },\n        /**\n     * Grayscale mode, between 'average', 'lightness', 'luminosity'\n     * @param {String} type\n     * @default\n     */ mode: \"average\",\n        mainParameter: \"mode\",\n        /**\n     * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, i, len = data.length, value, mode = this.mode;\n            for(i = 0; i < len; i += 4){\n                if (mode === \"average\") {\n                    value = (data[i] + data[i + 1] + data[i + 2]) / 3;\n                } else if (mode === \"lightness\") {\n                    value = (Math.min(data[i], data[i + 1], data[i + 2]) + Math.max(data[i], data[i + 1], data[i + 2])) / 2;\n                } else if (mode === \"luminosity\") {\n                    value = 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];\n                }\n                data[i] = value;\n                data[i + 1] = value;\n                data[i + 2] = value;\n            }\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var cacheKey = this.type + \"_\" + this.mode;\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                var shaderSource = this.fragmentSource[this.mode];\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uMode: gl.getUniformLocation(program, \"uMode\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            // default average mode.\n            var mode = 1;\n            gl.uniform1i(uniformLocations.uMode, mode);\n        },\n        /**\n     * Grayscale filter isNeutralState implementation\n     * The filter is never neutral\n     * on the image\n     **/ isNeutralState: function() {\n            return false;\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale\n   */ fabric.Image.filters.Grayscale.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Invert filter class\n   * @class fabric.Image.filters.Invert\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Invert();\n   * object.filters.push(filter);\n   * object.applyFilters(canvas.renderAll.bind(canvas));\n   */ filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Invert\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform int uInvert;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"if (uInvert == 1) {\\n\" + \"gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\\n\" + \"} else {\\n\" + \"gl_FragColor = color;\\n\" + \"}\\n\" + \"}\",\n        /**\n     * Filter invert. if false, does nothing\n     * @param {Boolean} invert\n     * @default\n     */ invert: true,\n        mainParameter: \"invert\",\n        /**\n     * Apply the Invert operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, i, len = data.length;\n            for(i = 0; i < len; i += 4){\n                data[i] = 255 - data[i];\n                data[i + 1] = 255 - data[i + 1];\n                data[i + 2] = 255 - data[i + 2];\n            }\n        },\n        /**\n     * Invert filter isNeutralState implementation\n     * Used only in image applyFilters to discard filters that will not have an effect\n     * on the image\n     * @param {Object} options\n     **/ isNeutralState: function() {\n            return !this.invert;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uInvert: gl.getUniformLocation(program, \"uInvert\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1i(uniformLocations.uInvert, this.invert);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert\n   */ fabric.Image.filters.Invert.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Noise filter class\n   * @class fabric.Image.filters.Noise\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Noise({\n   *   noise: 700\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Noise\",\n        /**\n     * Fragment source for the noise program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uStepH;\\n\" + \"uniform float uNoise;\\n\" + \"uniform float uSeed;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"float rand(vec2 co, float seed, float vScale) {\\n\" + \"return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\\n\" + \"}\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"noise\",\n        /**\n     * Noise value, from\n     * @param {Number} noise\n     * @default\n     */ noise: 0,\n        /**\n     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            if (this.noise === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, i, len = data.length, noise = this.noise, rand;\n            for(i = 0, len = data.length; i < len; i += 4){\n                rand = (0.5 - Math.random()) * noise;\n                data[i] += rand;\n                data[i + 1] += rand;\n                data[i + 2] += rand;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uNoise: gl.getUniformLocation(program, \"uNoise\"),\n                uSeed: gl.getUniformLocation(program, \"uSeed\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uNoise, this.noise / 255);\n            gl.uniform1f(uniformLocations.uSeed, Math.random());\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return extend(this.callSuper(\"toObject\"), {\n                noise: this.noise\n            });\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise\n   */ fabric.Image.filters.Noise.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Pixelate filter class\n   * @class fabric.Image.filters.Pixelate\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Pixelate({\n   *   blocksize: 8\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Pixelate\",\n        blocksize: 4,\n        mainParameter: \"blocksize\",\n        /**\n     * Fragment source for the Pixelate program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uBlocksize;\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"float blockW = uBlocksize * uStepW;\\n\" + \"float blockH = uBlocksize * uStepW;\\n\" + \"int posX = int(vTexCoord.x / blockW);\\n\" + \"int posY = int(vTexCoord.y / blockH);\\n\" + \"float fposX = float(posX);\\n\" + \"float fposY = float(posY);\\n\" + \"vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\\n\" + \"vec4 color = texture2D(uTexture, squareCoords);\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, iLen = imageData.height, jLen = imageData.width, index, i, j, r, g, b, a, _i, _j, _iLen, _jLen;\n            for(i = 0; i < iLen; i += this.blocksize){\n                for(j = 0; j < jLen; j += this.blocksize){\n                    index = i * 4 * jLen + j * 4;\n                    r = data[index];\n                    g = data[index + 1];\n                    b = data[index + 2];\n                    a = data[index + 3];\n                    _iLen = Math.min(i + this.blocksize, iLen);\n                    _jLen = Math.min(j + this.blocksize, jLen);\n                    for(_i = i; _i < _iLen; _i++){\n                        for(_j = j; _j < _jLen; _j++){\n                            index = _i * 4 * jLen + _j * 4;\n                            data[index] = r;\n                            data[index + 1] = g;\n                            data[index + 2] = b;\n                            data[index + 3] = a;\n                        }\n                    }\n                }\n            }\n        },\n        /**\n     * Indicate when the filter is not gonna apply changes to the image\n     **/ isNeutralState: function() {\n            return this.blocksize === 1;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uBlocksize: gl.getUniformLocation(program, \"uBlocksize\"),\n                uStepW: gl.getUniformLocation(program, \"uStepW\"),\n                uStepH: gl.getUniformLocation(program, \"uStepH\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate\n   */ fabric.Image.filters.Pixelate.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Remove white filter class\n   * @class fabric.Image.filters.RemoveColor\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.RemoveColor#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.RemoveColor({\n   *   threshold: 0.2,\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.RemoveColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveColor.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"RemoveColor\",\n        /**\n     * Color to remove, in any format understood by fabric.Color.\n     * @param {String} type\n     * @default\n     */ color: \"#FFFFFF\",\n        /**\n     * Fragment source for the brightness program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec4 uLow;\\n\" + \"uniform vec4 uHigh;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"gl_FragColor = texture2D(uTexture, vTexCoord);\\n\" + \"if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\\n\" + \"gl_FragColor.a = 0.0;\\n\" + \"}\\n\" + \"}\",\n        /**\n     * distance to actual color, as value up or down from each r,g,b\n     * between 0 and 1\n     **/ distance: 0.02,\n        /**\n     * For color to remove inside distance, use alpha channel for a smoother deletion\n     * NOT IMPLEMENTED YET\n     **/ useAlpha: false,\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.RemoveWhite.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.color=#RRGGBB] Threshold value\n     * @param {Number} [options.distance=10] Distance value\n     */ /**\n     * Applies filter to canvas element\n     * @param {Object} canvasEl Canvas element to apply filter to\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, i, distance = this.distance * 255, r, g, b, source = new fabric.Color(this.color).getSource(), lowC = [\n                source[0] - distance,\n                source[1] - distance,\n                source[2] - distance\n            ], highC = [\n                source[0] + distance,\n                source[1] + distance,\n                source[2] + distance\n            ];\n            for(i = 0; i < data.length; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                if (r > lowC[0] && g > lowC[1] && b > lowC[2] && r < highC[0] && g < highC[1] && b < highC[2]) {\n                    data[i + 3] = 0;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uLow: gl.getUniformLocation(program, \"uLow\"),\n                uHigh: gl.getUniformLocation(program, \"uHigh\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var source = new fabric.Color(this.color).getSource(), distance = parseFloat(this.distance), lowC = [\n                0 + source[0] / 255 - distance,\n                0 + source[1] / 255 - distance,\n                0 + source[2] / 255 - distance,\n                1\n            ], highC = [\n                source[0] / 255 + distance,\n                source[1] / 255 + distance,\n                source[2] / 255 + distance,\n                1\n            ];\n            gl.uniform4fv(uniformLocations.uLow, lowC);\n            gl.uniform4fv(uniformLocations.uHigh, highC);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return extend(this.callSuper(\"toObject\"), {\n                color: this.color,\n                distance: this.distance\n            });\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.RemoveColor} Instance of fabric.Image.filters.RemoveWhite\n   */ fabric.Image.filters.RemoveColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    var matrices = {\n        Brownie: [\n            0.59970,\n            0.34553,\n            -0.27082,\n            0,\n            0.186,\n            -0.03770,\n            0.86095,\n            0.15059,\n            0,\n            -0.1449,\n            0.24113,\n            -0.07441,\n            0.44972,\n            0,\n            -0.02965,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Vintage: [\n            0.62793,\n            0.32021,\n            -0.03965,\n            0,\n            0.03784,\n            0.02578,\n            0.64411,\n            0.03259,\n            0,\n            0.02926,\n            0.04660,\n            -0.08512,\n            0.52416,\n            0,\n            0.02023,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Kodachrome: [\n            1.12855,\n            -0.39673,\n            -0.03992,\n            0,\n            0.24991,\n            -0.16404,\n            1.08352,\n            -0.05498,\n            0,\n            0.09698,\n            -0.16786,\n            -0.56034,\n            1.60148,\n            0,\n            0.13972,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Technicolor: [\n            1.91252,\n            -0.85453,\n            -0.09155,\n            0,\n            0.04624,\n            -0.30878,\n            1.76589,\n            -0.10601,\n            0,\n            -0.27589,\n            -0.23110,\n            -0.75018,\n            1.84759,\n            0,\n            0.12137,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Polaroid: [\n            1.438,\n            -0.062,\n            -0.062,\n            0,\n            0,\n            -0.122,\n            1.378,\n            -0.122,\n            0,\n            0,\n            -0.016,\n            -0.016,\n            1.483,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Sepia: [\n            0.393,\n            0.769,\n            0.189,\n            0,\n            0,\n            0.349,\n            0.686,\n            0.168,\n            0,\n            0,\n            0.272,\n            0.534,\n            0.131,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        BlackWhite: [\n            1.5,\n            1.5,\n            1.5,\n            0,\n            -1,\n            1.5,\n            1.5,\n            1.5,\n            0,\n            -1,\n            1.5,\n            1.5,\n            1.5,\n            0,\n            -1,\n            0,\n            0,\n            0,\n            1,\n            0\n        ]\n    };\n    for(var key in matrices){\n        filters[key] = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.Sepia.prototype */ {\n            /**\n       * Filter type\n       * @param {String} type\n       * @default\n       */ type: key,\n            /**\n       * Colormatrix for the effect\n       * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning\n       * outside the -1, 1 range.\n       * @param {Array} matrix array of 20 numbers.\n       * @default\n       */ matrix: matrices[key],\n            /**\n       * Lock the matrix export for this kind of static, parameter less filters.\n       */ mainParameter: false,\n            /**\n       * Lock the colormatrix on the color part, skipping alpha\n       */ colorsOnly: true\n        });\n        fabric.Image.filters[key].fromObject = fabric.Image.filters.BaseFilter.fromObject;\n    }\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Color Blend filter class\n   * @class fabric.Image.filter.BlendColor\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @example\n   * var filter = new fabric.Image.filters.BlendColor({\n   *  color: '#000',\n   *  mode: 'multiply'\n   * });\n   *\n   * var filter = new fabric.Image.filters.BlendImage({\n   *  image: fabricImageObject,\n   *  mode: 'multiply',\n   *  alpha: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.BlendColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {\n        type: \"BlendColor\",\n        /**\n     * Color to make the blend operation with. default to a reddish color since black or white\n     * gives always strong result.\n     * @type String\n     * @default\n     **/ color: \"#F95C63\",\n        /**\n     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,\n     * darken, lighten, overlay, exclusion, tint.\n     * @type String\n     * @default\n     **/ mode: \"multiply\",\n        /**\n     * alpha value. represent the strength of the blend color operation.\n     * @type Number\n     * @default\n     **/ alpha: 1,\n        /**\n     * Fragment source for the Multiply program\n     */ fragmentSource: {\n            multiply: \"gl_FragColor.rgb *= uColor.rgb;\\n\",\n            screen: \"gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\\n\",\n            add: \"gl_FragColor.rgb += uColor.rgb;\\n\",\n            diff: \"gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\\n\",\n            subtract: \"gl_FragColor.rgb -= uColor.rgb;\\n\",\n            lighten: \"gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\\n\",\n            darken: \"gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\\n\",\n            exclusion: \"gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\\n\",\n            overlay: \"if (uColor.r < 0.5) {\\n\" + \"gl_FragColor.r *= 2.0 * uColor.r;\\n\" + \"} else {\\n\" + \"gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\\n\" + \"}\\n\" + \"if (uColor.g < 0.5) {\\n\" + \"gl_FragColor.g *= 2.0 * uColor.g;\\n\" + \"} else {\\n\" + \"gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\\n\" + \"}\\n\" + \"if (uColor.b < 0.5) {\\n\" + \"gl_FragColor.b *= 2.0 * uColor.b;\\n\" + \"} else {\\n\" + \"gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\\n\" + \"}\\n\",\n            tint: \"gl_FragColor.rgb *= (1.0 - uColor.a);\\n\" + \"gl_FragColor.rgb += uColor.rgb;\\n\"\n        },\n        /**\n     * build the fragment source for the filters, joining the common part with\n     * the specific one.\n     * @param {String} mode the mode of the filter, a key of this.fragmentSource\n     * @return {String} the source to be compiled\n     * @private\n     */ buildSource: function(mode) {\n            return \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec4 uColor;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"gl_FragColor = color;\\n\" + \"if (color.a > 0.0) {\\n\" + this.fragmentSource[mode] + \"}\\n\" + \"}\";\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var cacheKey = this.type + \"_\" + this.mode, shaderSource;\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                shaderSource = this.buildSource(this.mode);\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        /**\n     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, iLen = data.length, tr, tg, tb, r, g, b, source, alpha1 = 1 - this.alpha;\n            source = new fabric.Color(this.color).getSource();\n            tr = source[0] * this.alpha;\n            tg = source[1] * this.alpha;\n            tb = source[2] * this.alpha;\n            for(var i = 0; i < iLen; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                switch(this.mode){\n                    case \"multiply\":\n                        data[i] = r * tr / 255;\n                        data[i + 1] = g * tg / 255;\n                        data[i + 2] = b * tb / 255;\n                        break;\n                    case \"screen\":\n                        data[i] = 255 - (255 - r) * (255 - tr) / 255;\n                        data[i + 1] = 255 - (255 - g) * (255 - tg) / 255;\n                        data[i + 2] = 255 - (255 - b) * (255 - tb) / 255;\n                        break;\n                    case \"add\":\n                        data[i] = r + tr;\n                        data[i + 1] = g + tg;\n                        data[i + 2] = b + tb;\n                        break;\n                    case \"diff\":\n                    case \"difference\":\n                        data[i] = Math.abs(r - tr);\n                        data[i + 1] = Math.abs(g - tg);\n                        data[i + 2] = Math.abs(b - tb);\n                        break;\n                    case \"subtract\":\n                        data[i] = r - tr;\n                        data[i + 1] = g - tg;\n                        data[i + 2] = b - tb;\n                        break;\n                    case \"darken\":\n                        data[i] = Math.min(r, tr);\n                        data[i + 1] = Math.min(g, tg);\n                        data[i + 2] = Math.min(b, tb);\n                        break;\n                    case \"lighten\":\n                        data[i] = Math.max(r, tr);\n                        data[i + 1] = Math.max(g, tg);\n                        data[i + 2] = Math.max(b, tb);\n                        break;\n                    case \"overlay\":\n                        data[i] = tr < 128 ? 2 * r * tr / 255 : 255 - 2 * (255 - r) * (255 - tr) / 255;\n                        data[i + 1] = tg < 128 ? 2 * g * tg / 255 : 255 - 2 * (255 - g) * (255 - tg) / 255;\n                        data[i + 2] = tb < 128 ? 2 * b * tb / 255 : 255 - 2 * (255 - b) * (255 - tb) / 255;\n                        break;\n                    case \"exclusion\":\n                        data[i] = tr + r - 2 * tr * r / 255;\n                        data[i + 1] = tg + g - 2 * tg * g / 255;\n                        data[i + 2] = tb + b - 2 * tb * b / 255;\n                        break;\n                    case \"tint\":\n                        data[i] = tr + r * alpha1;\n                        data[i + 1] = tg + g * alpha1;\n                        data[i + 2] = tb + b * alpha1;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uColor: gl.getUniformLocation(program, \"uColor\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var source = new fabric.Color(this.color).getSource();\n            source[0] = this.alpha * source[0] / 255;\n            source[1] = this.alpha * source[1] / 255;\n            source[2] = this.alpha * source[2] / 255;\n            source[3] = this.alpha;\n            gl.uniform4fv(uniformLocations.uColor, source);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return {\n                type: this.type,\n                color: this.color,\n                mode: this.mode,\n                alpha: this.alpha\n            };\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.BlendColor} Instance of fabric.Image.filters.BlendColor\n   */ fabric.Image.filters.BlendColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Image Blend filter class\n   * @class fabric.Image.filter.BlendImage\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @example\n   * var filter = new fabric.Image.filters.BlendColor({\n   *  color: '#000',\n   *  mode: 'multiply'\n   * });\n   *\n   * var filter = new fabric.Image.filters.BlendImage({\n   *  image: fabricImageObject,\n   *  mode: 'multiply',\n   *  alpha: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.BlendImage = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.BlendImage.prototype */ {\n        type: \"BlendImage\",\n        /**\n     * Color to make the blend operation with. default to a reddish color since black or white\n     * gives always strong result.\n     **/ image: null,\n        /**\n     * Blend mode for the filter (one of \"multiply\", \"mask\")\n     * @type String\n     * @default\n     **/ mode: \"multiply\",\n        /**\n     * alpha value. represent the strength of the blend image operation.\n     * not implemented.\n     **/ alpha: 1,\n        vertexSource: \"attribute vec2 aPosition;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"varying vec2 vTexCoord2;\\n\" + \"uniform mat3 uTransformMatrix;\\n\" + \"void main() {\\n\" + \"vTexCoord = aPosition;\\n\" + \"vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\\n\" + \"gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\\n\" + \"}\",\n        /**\n     * Fragment source for the Multiply program\n     */ fragmentSource: {\n            multiply: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform sampler2D uImage;\\n\" + \"uniform vec4 uColor;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"varying vec2 vTexCoord2;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"vec4 color2 = texture2D(uImage, vTexCoord2);\\n\" + \"color.rgba *= color2.rgba;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            mask: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform sampler2D uImage;\\n\" + \"uniform vec4 uColor;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"varying vec2 vTexCoord2;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"vec4 color2 = texture2D(uImage, vTexCoord2);\\n\" + \"color.a = color2.a;\\n\" + \"gl_FragColor = color;\\n\" + \"}\"\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var cacheKey = this.type + \"_\" + this.mode;\n            var shaderSource = this.fragmentSource[this.mode];\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        applyToWebGL: function(options) {\n            // load texture to blend.\n            var gl = options.context, texture = this.createTexture(options.filterBackend, this.image);\n            this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);\n            this.callSuper(\"applyToWebGL\", options);\n            this.unbindAdditionalTexture(gl, gl.TEXTURE1);\n        },\n        createTexture: function(backend, image) {\n            return backend.getCachedTexture(image.cacheKey, image._element);\n        },\n        /**\n     * Calculate a transformMatrix to adapt the image to blend over\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ calculateMatrix: function() {\n            var image = this.image, width = image._element.width, height = image._element.height;\n            return [\n                1 / image.scaleX,\n                0,\n                0,\n                0,\n                1 / image.scaleY,\n                0,\n                -image.left / width,\n                -image.top / height,\n                1\n            ];\n        },\n        /**\n     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, resources = options.filterBackend.resources, data = imageData.data, iLen = data.length, width = imageData.width, height = imageData.height, tr, tg, tb, ta, r, g, b, a, canvas1, context, image = this.image, blendData;\n            if (!resources.blendImage) {\n                resources.blendImage = fabric.util.createCanvasElement();\n            }\n            canvas1 = resources.blendImage;\n            context = canvas1.getContext(\"2d\");\n            if (canvas1.width !== width || canvas1.height !== height) {\n                canvas1.width = width;\n                canvas1.height = height;\n            } else {\n                context.clearRect(0, 0, width, height);\n            }\n            context.setTransform(image.scaleX, 0, 0, image.scaleY, image.left, image.top);\n            context.drawImage(image._element, 0, 0, width, height);\n            blendData = context.getImageData(0, 0, width, height).data;\n            for(var i = 0; i < iLen; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                a = data[i + 3];\n                tr = blendData[i];\n                tg = blendData[i + 1];\n                tb = blendData[i + 2];\n                ta = blendData[i + 3];\n                switch(this.mode){\n                    case \"multiply\":\n                        data[i] = r * tr / 255;\n                        data[i + 1] = g * tg / 255;\n                        data[i + 2] = b * tb / 255;\n                        data[i + 3] = a * ta / 255;\n                        break;\n                    case \"mask\":\n                        data[i + 3] = ta;\n                        break;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uTransformMatrix: gl.getUniformLocation(program, \"uTransformMatrix\"),\n                uImage: gl.getUniformLocation(program, \"uImage\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var matrix = this.calculateMatrix();\n            gl.uniform1i(uniformLocations.uImage, 1); // texture unit 1.\n            gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return {\n                type: this.type,\n                image: this.image && this.image.toObject(),\n                mode: this.mode,\n                alpha: this.alpha\n            };\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} callback to be invoked after filter creation\n   * @return {fabric.Image.filters.BlendImage} Instance of fabric.Image.filters.BlendImage\n   */ fabric.Image.filters.BlendImage.fromObject = function(object, callback) {\n        fabric.Image.fromObject(object.image, function(image) {\n            var options = fabric.util.object.clone(object);\n            options.image = image;\n            callback(new fabric.Image.filters.BlendImage(options));\n        });\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), pow = Math.pow, floor = Math.floor, sqrt = Math.sqrt, abs = Math.abs, round = Math.round, sin = Math.sin, ceil = Math.ceil, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Resize image filter class\n   * @class fabric.Image.filters.Resize\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Resize();\n   * object.filters.push(filter);\n   * object.applyFilters(canvas.renderAll.bind(canvas));\n   */ filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Resize\",\n        /**\n     * Resize type\n     * for webgl resizeType is just lanczos, for canvas2d can be:\n     * bilinear, hermite, sliceHack, lanczos.\n     * @param {String} resizeType\n     * @default\n     */ resizeType: \"hermite\",\n        /**\n     * Scale factor for resizing, x axis\n     * @param {Number} scaleX\n     * @default\n     */ scaleX: 1,\n        /**\n     * Scale factor for resizing, y axis\n     * @param {Number} scaleY\n     * @default\n     */ scaleY: 1,\n        /**\n     * LanczosLobes parameter for lanczos filter, valid for resizeType lanczos\n     * @param {Number} lanczosLobes\n     * @default\n     */ lanczosLobes: 3,\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uDelta: gl.getUniformLocation(program, \"uDelta\"),\n                uTaps: gl.getUniformLocation(program, \"uTaps\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform2fv(uniformLocations.uDelta, this.horizontal ? [\n                1 / this.width,\n                0\n            ] : [\n                0,\n                1 / this.height\n            ]);\n            gl.uniform1fv(uniformLocations.uTaps, this.taps);\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var filterWindow = this.getFilterWindow(), cacheKey = this.type + \"_\" + filterWindow;\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                var fragmentShader = this.generateShader(filterWindow);\n                options.programCache[cacheKey] = this.createProgram(options.context, fragmentShader);\n            }\n            return options.programCache[cacheKey];\n        },\n        getFilterWindow: function() {\n            var scale = this.tempScale;\n            return Math.ceil(this.lanczosLobes / scale);\n        },\n        getTaps: function() {\n            var lobeFunction = this.lanczosCreate(this.lanczosLobes), scale = this.tempScale, filterWindow = this.getFilterWindow(), taps = new Array(filterWindow);\n            for(var i = 1; i <= filterWindow; i++){\n                taps[i - 1] = lobeFunction(i * scale);\n            }\n            return taps;\n        },\n        /**\n     * Generate vertex and shader sources from the necessary steps numbers\n     * @param {Number} filterWindow\n     */ generateShader: function(filterWindow) {\n            var offsets = new Array(filterWindow), fragmentShader = this.fragmentSourceTOP, filterWindow;\n            for(var i = 1; i <= filterWindow; i++){\n                offsets[i - 1] = i + \".0 * uDelta\";\n            }\n            fragmentShader += \"uniform float uTaps[\" + filterWindow + \"];\\n\";\n            fragmentShader += \"void main() {\\n\";\n            fragmentShader += \"  vec4 color = texture2D(uTexture, vTexCoord);\\n\";\n            fragmentShader += \"  float sum = 1.0;\\n\";\n            offsets.forEach(function(offset, i) {\n                fragmentShader += \"  color += texture2D(uTexture, vTexCoord + \" + offset + \") * uTaps[\" + i + \"];\\n\";\n                fragmentShader += \"  color += texture2D(uTexture, vTexCoord - \" + offset + \") * uTaps[\" + i + \"];\\n\";\n                fragmentShader += \"  sum += 2.0 * uTaps[\" + i + \"];\\n\";\n            });\n            fragmentShader += \"  gl_FragColor = color / sum;\\n\";\n            fragmentShader += \"}\";\n            return fragmentShader;\n        },\n        fragmentSourceTOP: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec2 uDelta;\\n\" + \"varying vec2 vTexCoord;\\n\",\n        /**\n     * Apply the resize filter to the image\n     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be executed\n     * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ applyTo: function(options) {\n            if (options.webgl) {\n                options.passes++;\n                this.width = options.sourceWidth;\n                this.horizontal = true;\n                this.dW = Math.round(this.width * this.scaleX);\n                this.dH = options.sourceHeight;\n                this.tempScale = this.dW / this.width;\n                this.taps = this.getTaps();\n                options.destinationWidth = this.dW;\n                this._setupFrameBuffer(options);\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n                options.sourceWidth = options.destinationWidth;\n                this.height = options.sourceHeight;\n                this.horizontal = false;\n                this.dH = Math.round(this.height * this.scaleY);\n                this.tempScale = this.dH / this.height;\n                this.taps = this.getTaps();\n                options.destinationHeight = this.dH;\n                this._setupFrameBuffer(options);\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n                options.sourceHeight = options.destinationHeight;\n            } else {\n                this.applyTo2d(options);\n            }\n        },\n        isNeutralState: function() {\n            return this.scaleX === 1 && this.scaleY === 1;\n        },\n        lanczosCreate: function(lobes) {\n            return function(x) {\n                if (x >= lobes || x <= -lobes) {\n                    return 0.0;\n                }\n                if (x < 1.19209290E-07 && x > -1.19209290E-07) {\n                    return 1.0;\n                }\n                x *= Math.PI;\n                var xx = x / lobes;\n                return sin(x) / x * sin(xx) / xx;\n            };\n        },\n        /**\n     * Applies filter to canvas element\n     * @memberOf fabric.Image.filters.Resize.prototype\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} scaleX\n     * @param {Number} scaleY\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, scaleX = this.scaleX, scaleY = this.scaleY;\n            this.rcpScaleX = 1 / scaleX;\n            this.rcpScaleY = 1 / scaleY;\n            var oW = imageData.width, oH = imageData.height, dW = round(oW * scaleX), dH = round(oH * scaleY), newData;\n            if (this.resizeType === \"sliceHack\") {\n                newData = this.sliceByTwo(options, oW, oH, dW, dH);\n            } else if (this.resizeType === \"hermite\") {\n                newData = this.hermiteFastResize(options, oW, oH, dW, dH);\n            } else if (this.resizeType === \"bilinear\") {\n                newData = this.bilinearFiltering(options, oW, oH, dW, dH);\n            } else if (this.resizeType === \"lanczos\") {\n                newData = this.lanczosResize(options, oW, oH, dW, dH);\n            }\n            options.imageData = newData;\n        },\n        /**\n     * Filter sliceByTwo\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ sliceByTwo: function(options, oW, oH, dW, dH) {\n            var imageData = options.imageData, mult = 0.5, doneW = false, doneH = false, stepW = oW * mult, stepH = oH * mult, resources = fabric.filterBackend.resources, tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;\n            if (!resources.sliceByTwo) {\n                resources.sliceByTwo = document.createElement(\"canvas\");\n            }\n            tmpCanvas = resources.sliceByTwo;\n            if (tmpCanvas.width < oW * 1.5 || tmpCanvas.height < oH) {\n                tmpCanvas.width = oW * 1.5;\n                tmpCanvas.height = oH;\n            }\n            ctx = tmpCanvas.getContext(\"2d\");\n            ctx.clearRect(0, 0, oW * 1.5, oH);\n            ctx.putImageData(imageData, 0, 0);\n            dW = floor(dW);\n            dH = floor(dH);\n            while(!doneW || !doneH){\n                oW = stepW;\n                oH = stepH;\n                if (dW < floor(stepW * mult)) {\n                    stepW = floor(stepW * mult);\n                } else {\n                    stepW = dW;\n                    doneW = true;\n                }\n                if (dH < floor(stepH * mult)) {\n                    stepH = floor(stepH * mult);\n                } else {\n                    stepH = dH;\n                    doneH = true;\n                }\n                ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);\n                sX = dX;\n                sY = dY;\n                dY += stepH;\n            }\n            return ctx.getImageData(sX, sY, dW, dH);\n        },\n        /**\n     * Filter lanczosResize\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ lanczosResize: function(options, oW, oH, dW, dH) {\n            function process(u) {\n                var v, i, weight, idx, a, red, green, blue, alpha, fX, fY;\n                center.x = (u + 0.5) * ratioX;\n                icenter.x = floor(center.x);\n                for(v = 0; v < dH; v++){\n                    center.y = (v + 0.5) * ratioY;\n                    icenter.y = floor(center.y);\n                    a = 0;\n                    red = 0;\n                    green = 0;\n                    blue = 0;\n                    alpha = 0;\n                    for(i = icenter.x - range2X; i <= icenter.x + range2X; i++){\n                        if (i < 0 || i >= oW) {\n                            continue;\n                        }\n                        fX = floor(1000 * abs(i - center.x));\n                        if (!cacheLanc[fX]) {\n                            cacheLanc[fX] = {};\n                        }\n                        for(var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++){\n                            if (j < 0 || j >= oH) {\n                                continue;\n                            }\n                            fY = floor(1000 * abs(j - center.y));\n                            if (!cacheLanc[fX][fY]) {\n                                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);\n                            }\n                            weight = cacheLanc[fX][fY];\n                            if (weight > 0) {\n                                idx = (j * oW + i) * 4;\n                                a += weight;\n                                red += weight * srcData[idx];\n                                green += weight * srcData[idx + 1];\n                                blue += weight * srcData[idx + 2];\n                                alpha += weight * srcData[idx + 3];\n                            }\n                        }\n                    }\n                    idx = (v * dW + u) * 4;\n                    destData[idx] = red / a;\n                    destData[idx + 1] = green / a;\n                    destData[idx + 2] = blue / a;\n                    destData[idx + 3] = alpha / a;\n                }\n                if (++u < dW) {\n                    return process(u);\n                } else {\n                    return destImg;\n                }\n            }\n            var srcData = options.imageData.data, destImg = options.ctx.createImageData(dW, dH), destData = destImg.data, lanczos = this.lanczosCreate(this.lanczosLobes), ratioX = this.rcpScaleX, ratioY = this.rcpScaleY, rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY, range2X = ceil(ratioX * this.lanczosLobes / 2), range2Y = ceil(ratioY * this.lanczosLobes / 2), cacheLanc = {}, center = {}, icenter = {};\n            return process(0);\n        },\n        /**\n     * bilinearFiltering\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ bilinearFiltering: function(options, oW, oH, dW, dH) {\n            var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl, color, offset = 0, origPix, ratioX = this.rcpScaleX, ratioY = this.rcpScaleY, w4 = 4 * (oW - 1), img = options.imageData, pixels = img.data, destImage = options.ctx.createImageData(dW, dH), destPixels = destImage.data;\n            for(i = 0; i < dH; i++){\n                for(j = 0; j < dW; j++){\n                    x = floor(ratioX * j);\n                    y = floor(ratioY * i);\n                    xDiff = ratioX * j - x;\n                    yDiff = ratioY * i - y;\n                    origPix = 4 * (y * oW + x);\n                    for(chnl = 0; chnl < 4; chnl++){\n                        a = pixels[origPix + chnl];\n                        b = pixels[origPix + 4 + chnl];\n                        c = pixels[origPix + w4 + chnl];\n                        d = pixels[origPix + w4 + 4 + chnl];\n                        color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) + c * yDiff * (1 - xDiff) + d * xDiff * yDiff;\n                        destPixels[offset++] = color;\n                    }\n                }\n            }\n            return destImage;\n        },\n        /**\n     * hermiteFastResize\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ hermiteFastResize: function(options, oW, oH, dW, dH) {\n            var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY, ratioWHalf = ceil(ratioW / 2), ratioHHalf = ceil(ratioH / 2), img = options.imageData, data = img.data, img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;\n            for(var j = 0; j < dH; j++){\n                for(var i = 0; i < dW; i++){\n                    var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0, gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;\n                    for(var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++){\n                        var dy = abs(centerY - (yy + 0.5)) / ratioHHalf, centerX = (i + 0.5) * ratioW, w0 = dy * dy;\n                        for(var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++){\n                            var dx = abs(centerX - (xx + 0.5)) / ratioWHalf, w = sqrt(w0 + dx * dx);\n                            /* eslint-disable max-depth */ if (w > 1 && w < -1) {\n                                continue;\n                            }\n                            //hermite filter\n                            weight = 2 * w * w * w - 3 * w * w + 1;\n                            if (weight > 0) {\n                                dx = 4 * (xx + yy * oW);\n                                //alpha\n                                gxA += weight * data[dx + 3];\n                                weightsAlpha += weight;\n                                //colors\n                                if (data[dx + 3] < 255) {\n                                    weight = weight * data[dx + 3] / 250;\n                                }\n                                gxR += weight * data[dx];\n                                gxG += weight * data[dx + 1];\n                                gxB += weight * data[dx + 2];\n                                weights += weight;\n                            }\n                        /* eslint-enable max-depth */ }\n                    }\n                    data2[x2] = gxR / weights;\n                    data2[x2 + 1] = gxG / weights;\n                    data2[x2 + 2] = gxB / weights;\n                    data2[x2 + 3] = gxA / weightsAlpha;\n                }\n            }\n            return img2;\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return {\n                type: this.type,\n                scaleX: this.scaleX,\n                scaleY: this.scaleY,\n                resizeType: this.resizeType,\n                lanczosLobes: this.lanczosLobes\n            };\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize\n   */ fabric.Image.filters.Resize.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Contrast filter class\n   * @class fabric.Image.filters.Contrast\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Contrast({\n   *   contrast: 0.25\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Contrast\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uContrast;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\\n\" + \"color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * contrast value, range from -1 to 1.\n     * @param {Number} contrast\n     * @default 0\n     */ contrast: 0,\n        mainParameter: \"contrast\",\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Contrast.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)\n     */ /**\n      * Apply the Contrast operation to a Uint8Array representing the pixels of an image.\n      *\n      * @param {Object} options\n      * @param {ImageData} options.imageData The Uint8Array to be filtered.\n      */ applyTo2d: function(options) {\n            if (this.contrast === 0) {\n                return;\n            }\n            var imageData = options.imageData, i, len, data = imageData.data, len = data.length, contrast = Math.floor(this.contrast * 255), contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));\n            for(i = 0; i < len; i += 4){\n                data[i] = contrastF * (data[i] - 128) + 128;\n                data[i + 1] = contrastF * (data[i + 1] - 128) + 128;\n                data[i + 2] = contrastF * (data[i + 2] - 128) + 128;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uContrast: gl.getUniformLocation(program, \"uContrast\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uContrast, this.contrast);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast\n   */ fabric.Image.filters.Contrast.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Saturate filter class\n   * @class fabric.Image.filters.Saturation\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Saturation#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Saturation({\n   *   saturation: 1\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Saturation = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturation.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Saturation\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uSaturation;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float rgMax = max(color.r, color.g);\\n\" + \"float rgbMax = max(rgMax, color.b);\\n\" + \"color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\\n\" + \"color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\\n\" + \"color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Saturation value, from -1 to 1.\n     * Increases/decreases the color saturation.\n     * A value of 0 has no effect.\n     * \n     * @param {Number} saturation\n     * @default\n     */ saturation: 0,\n        mainParameter: \"saturation\",\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Saturate.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)\n     */ /**\n     * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            if (this.saturation === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, len = data.length, adjust = -this.saturation, i, max;\n            for(i = 0; i < len; i += 4){\n                max = Math.max(data[i], data[i + 1], data[i + 2]);\n                data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;\n                data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;\n                data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uSaturation: gl.getUniformLocation(program, \"uSaturation\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uSaturation, -this.saturation);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Saturation} Instance of fabric.Image.filters.Saturate\n   */ fabric.Image.filters.Saturation.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Vibrance filter class\n   * @class fabric.Image.filters.Vibrance\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Vibrance#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Vibrance({\n   *   vibrance: 1\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Vibrance = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Vibrance.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Vibrance\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uVibrance;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float max = max(color.r, max(color.g, color.b));\\n\" + \"float avg = (color.r + color.g + color.b) / 3.0;\\n\" + \"float amt = (abs(max - avg) * 2.0) * uVibrance;\\n\" + \"color.r += max != color.r ? (max - color.r) * amt : 0.00;\\n\" + \"color.g += max != color.g ? (max - color.g) * amt : 0.00;\\n\" + \"color.b += max != color.b ? (max - color.b) * amt : 0.00;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Vibrance value, from -1 to 1.\n     * Increases/decreases the saturation of more muted colors with less effect on saturated colors.\n     * A value of 0 has no effect.\n     * \n     * @param {Number} vibrance\n     * @default\n     */ vibrance: 0,\n        mainParameter: \"vibrance\",\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Vibrance.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.vibrance=0] Vibrance value for the image (between -1 and 1)\n     */ /**\n     * Apply the Vibrance operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            if (this.vibrance === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, len = data.length, adjust = -this.vibrance, i, max, avg, amt;\n            for(i = 0; i < len; i += 4){\n                max = Math.max(data[i], data[i + 1], data[i + 2]);\n                avg = (data[i] + data[i + 1] + data[i + 2]) / 3;\n                amt = Math.abs(max - avg) * 2 / 255 * adjust;\n                data[i] += max !== data[i] ? (max - data[i]) * amt : 0;\n                data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * amt : 0;\n                data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * amt : 0;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uVibrance: gl.getUniformLocation(program, \"uVibrance\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uVibrance, -this.vibrance);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Vibrance} Instance of fabric.Image.filters.Vibrance\n   */ fabric.Image.filters.Vibrance.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Blur filter class\n   * @class fabric.Image.filters.Blur\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Blur#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Blur({\n   *   blur: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.Blur = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blur.prototype */ {\n        type: \"Blur\",\n        /*\n'gl_FragColor = vec4(0.0);',\n'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',\n'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',\n'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',\n'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',\n'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',\n'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',\n'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',\n'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',\n'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',\n'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',\n'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',\n'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',\n'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',\n'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',\n'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',\n*/ /* eslint-disable max-len */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec2 uDelta;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"const float nSamples = 15.0;\\n\" + \"vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\\n\" + \"float random(vec3 scale) {\\n\" + /* use the fragment position for a different seed per-pixel */ \"return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\\n\" + \"}\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0.0);\\n\" + \"float total = 0.0;\\n\" + \"float offset = random(v3offset);\\n\" + \"for (float t = -nSamples; t <= nSamples; t++) {\\n\" + \"float percent = (t + offset - 0.5) / nSamples;\\n\" + \"float weight = 1.0 - abs(percent);\\n\" + \"color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\\n\" + \"total += weight;\\n\" + \"}\\n\" + \"gl_FragColor = color / total;\\n\" + \"}\",\n        /* eslint-enable max-len */ /**\n     * blur value, in percentage of image dimensions.\n     * specific to keep the image blur constant at different resolutions\n     * range between 0 and 1.\n     * @type Number\n     * @default\n     */ blur: 0,\n        mainParameter: \"blur\",\n        applyTo: function(options) {\n            if (options.webgl) {\n                // this aspectRatio is used to give the same blur to vertical and horizontal\n                this.aspectRatio = options.sourceWidth / options.sourceHeight;\n                options.passes++;\n                this._setupFrameBuffer(options);\n                this.horizontal = true;\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n                this._setupFrameBuffer(options);\n                this.horizontal = false;\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n            } else {\n                this.applyTo2d(options);\n            }\n        },\n        applyTo2d: function(options) {\n            // paint canvasEl with current image data.\n            //options.ctx.putImageData(options.imageData, 0, 0);\n            options.imageData = this.simpleBlur(options);\n        },\n        simpleBlur: function(options) {\n            var resources = options.filterBackend.resources, canvas1, canvas2, width = options.imageData.width, height = options.imageData.height;\n            if (!resources.blurLayer1) {\n                resources.blurLayer1 = fabric.util.createCanvasElement();\n                resources.blurLayer2 = fabric.util.createCanvasElement();\n            }\n            canvas1 = resources.blurLayer1;\n            canvas2 = resources.blurLayer2;\n            if (canvas1.width !== width || canvas1.height !== height) {\n                canvas2.width = canvas1.width = width;\n                canvas2.height = canvas1.height = height;\n            }\n            var ctx1 = canvas1.getContext(\"2d\"), ctx2 = canvas2.getContext(\"2d\"), nSamples = 15, random, percent, j, i, blur = this.blur * 0.06 * 0.5;\n            // load first canvas\n            ctx1.putImageData(options.imageData, 0, 0);\n            ctx2.clearRect(0, 0, width, height);\n            for(i = -nSamples; i <= nSamples; i++){\n                random = (Math.random() - 0.5) / 4;\n                percent = i / nSamples;\n                j = blur * percent * width + random;\n                ctx2.globalAlpha = 1 - Math.abs(percent);\n                ctx2.drawImage(canvas1, j, random);\n                ctx1.drawImage(canvas2, 0, 0);\n                ctx2.globalAlpha = 1;\n                ctx2.clearRect(0, 0, canvas2.width, canvas2.height);\n            }\n            for(i = -nSamples; i <= nSamples; i++){\n                random = (Math.random() - 0.5) / 4;\n                percent = i / nSamples;\n                j = blur * percent * height + random;\n                ctx2.globalAlpha = 1 - Math.abs(percent);\n                ctx2.drawImage(canvas1, random, j);\n                ctx1.drawImage(canvas2, 0, 0);\n                ctx2.globalAlpha = 1;\n                ctx2.clearRect(0, 0, canvas2.width, canvas2.height);\n            }\n            options.ctx.drawImage(canvas1, 0, 0);\n            var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);\n            ctx1.globalAlpha = 1;\n            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);\n            return newImageData;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                delta: gl.getUniformLocation(program, \"uDelta\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var delta = this.chooseRightDelta();\n            gl.uniform2fv(uniformLocations.delta, delta);\n        },\n        /**\n     * choose right value of image percentage to blur with\n     * @returns {Array} a numeric array with delta values\n     */ chooseRightDelta: function() {\n            var blurScale = 1, delta = [\n                0,\n                0\n            ], blur;\n            if (this.horizontal) {\n                if (this.aspectRatio > 1) {\n                    // image is wide, i want to shrink radius horizontal\n                    blurScale = 1 / this.aspectRatio;\n                }\n            } else {\n                if (this.aspectRatio < 1) {\n                    // image is tall, i want to shrink radius vertical\n                    blurScale = this.aspectRatio;\n                }\n            }\n            blur = blurScale * this.blur * 0.12;\n            if (this.horizontal) {\n                delta[0] = blur;\n            } else {\n                delta[1] = blur;\n            }\n            return delta;\n        }\n    });\n    /**\n   * Deserialize a JSON definition of a BlurFilter into a concrete instance.\n   */ filters.Blur.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Gamma filter class\n   * @class fabric.Image.filters.Gamma\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Gamma#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Gamma({\n   *   gamma: [1, 0.5, 2.1]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Gamma = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Gamma.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Gamma\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec3 uGamma;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"vec3 correction = (1.0 / uGamma);\\n\" + \"color.r = pow(color.r, correction.r);\\n\" + \"color.g = pow(color.g, correction.g);\\n\" + \"color.b = pow(color.b, correction.b);\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.rgb *= color.a;\\n\" + \"}\",\n        /**\n     * Gamma array value, from 0.01 to 2.2.\n     * @param {Array} gamma\n     * @default\n     */ gamma: [\n            1,\n            1,\n            1\n        ],\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"gamma\",\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            this.gamma = [\n                1,\n                1,\n                1\n            ];\n            filters.BaseFilter.prototype.initialize.call(this, options);\n        },\n        /**\n     * Apply the Gamma operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, gamma = this.gamma, len = data.length, rInv = 1 / gamma[0], gInv = 1 / gamma[1], bInv = 1 / gamma[2], i;\n            if (!this.rVals) {\n                // eslint-disable-next-line\n                this.rVals = new Uint8Array(256);\n                // eslint-disable-next-line\n                this.gVals = new Uint8Array(256);\n                // eslint-disable-next-line\n                this.bVals = new Uint8Array(256);\n            }\n            // This is an optimization - pre-compute a look-up table for each color channel\n            // instead of performing these pow calls for each pixel in the image.\n            for(i = 0, len = 256; i < len; i++){\n                this.rVals[i] = Math.pow(i / 255, rInv) * 255;\n                this.gVals[i] = Math.pow(i / 255, gInv) * 255;\n                this.bVals[i] = Math.pow(i / 255, bInv) * 255;\n            }\n            for(i = 0, len = data.length; i < len; i += 4){\n                data[i] = this.rVals[data[i]];\n                data[i + 1] = this.gVals[data[i + 1]];\n                data[i + 2] = this.bVals[data[i + 2]];\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uGamma: gl.getUniformLocation(program, \"uGamma\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform3fv(uniformLocations.uGamma, this.gamma);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Gamma} Instance of fabric.Image.filters.Gamma\n   */ fabric.Image.filters.Gamma.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * A container class that knows how to apply a sequence of filters to an input image.\n   */ filters.Composed = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Composed.prototype */ {\n        type: \"Composed\",\n        /**\n     * A non sparse array of filters to apply\n     */ subFilters: [],\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            // create a new array instead mutating the prototype with push\n            this.subFilters = this.subFilters.slice(0);\n        },\n        /**\n     * Apply this container's filters to the input image provided.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be applied.\n     */ applyTo: function(options) {\n            options.passes += this.subFilters.length - 1;\n            this.subFilters.forEach(function(filter) {\n                filter.applyTo(options);\n            });\n        },\n        /**\n     * Serialize this filter into JSON.\n     *\n     * @returns {Object} A JSON representation of this filter.\n     */ toObject: function() {\n            return fabric.util.object.extend(this.callSuper(\"toObject\"), {\n                subFilters: this.subFilters.map(function(filter) {\n                    return filter.toObject();\n                })\n            });\n        },\n        isNeutralState: function() {\n            return !this.subFilters.some(function(filter) {\n                return !filter.isNeutralState();\n            });\n        }\n    });\n    /**\n   * Deserialize a JSON definition of a ComposedFilter into a concrete instance.\n   */ fabric.Image.filters.Composed.fromObject = function(object, callback) {\n        var filters = object.subFilters || [], subFilters = filters.map(function(filter) {\n            return new fabric.Image.filters[filter.type](filter);\n        }), instance = new fabric.Image.filters.Composed({\n            subFilters: subFilters\n        });\n        callback && callback(instance);\n        return instance;\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * HueRotation filter class\n   * @class fabric.Image.filters.HueRotation\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.HueRotation#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.HueRotation({\n   *   rotation: -0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.HueRotation = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.HueRotation.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"HueRotation\",\n        /**\n     * HueRotation value, from -1 to 1.\n     * the unit is radians\n     * @param {Number} myParameter\n     * @default\n     */ rotation: 0,\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"rotation\",\n        calculateMatrix: function() {\n            var rad = this.rotation * Math.PI, cos = fabric.util.cos(rad), sin = fabric.util.sin(rad), aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;\n            this.matrix = [\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0\n            ];\n            this.matrix[0] = cos + OneMinusCos / 3;\n            this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;\n            this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;\n            this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;\n            this.matrix[6] = cos + aThird * OneMinusCos;\n            this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;\n            this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;\n            this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;\n            this.matrix[12] = cos + aThird * OneMinusCos;\n        },\n        /**\n     * HueRotation isNeutralState implementation\n     * Used only in image applyFilters to discard filters that will not have an effect\n     * on the image\n     * @param {Object} options\n     **/ isNeutralState: function(options) {\n            this.calculateMatrix();\n            return filters.BaseFilter.prototype.isNeutralState.call(this, options);\n        },\n        /**\n     * Apply this filter to the input image data provided.\n     *\n     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be executed\n     * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ applyTo: function(options) {\n            this.calculateMatrix();\n            filters.BaseFilter.prototype.applyTo.call(this, options);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.HueRotation} Instance of fabric.Image.filters.HueRotation\n   */ fabric.Image.filters.HueRotation.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), clone = fabric.util.object.clone;\n    if (fabric.Text) {\n        fabric.warn(\"fabric.Text is already defined\");\n        return;\n    }\n    var additionalProps = (\"fontFamily fontWeight fontSize text underline overline linethrough\" + \" textAlign fontStyle lineHeight textBackgroundColor charSpacing styles\" + \" direction path pathStartOffset pathSide pathAlign\").split(\" \");\n    /**\n   * Text class\n   * @class fabric.Text\n   * @extends fabric.Object\n   * @return {fabric.Text} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}\n   * @see {@link fabric.Text#initialize} for constructor definition\n   */ fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {\n        /**\n     * Properties which when set cause object to change dimensions\n     * @type Array\n     * @private\n     */ _dimensionAffectingProps: [\n            \"fontSize\",\n            \"fontWeight\",\n            \"fontFamily\",\n            \"fontStyle\",\n            \"lineHeight\",\n            \"text\",\n            \"charSpacing\",\n            \"textAlign\",\n            \"styles\",\n            \"path\",\n            \"pathStartOffset\",\n            \"pathSide\",\n            \"pathAlign\"\n        ],\n        /**\n     * @private\n     */ _reNewline: /\\r?\\n/,\n        /**\n     * Use this regular expression to filter for whitespaces that is not a new line.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */ _reSpacesAndTabs: /[ \\t\\r]/g,\n        /**\n     * Use this regular expression to filter for whitespace that is not a new line.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */ _reSpaceAndTab: /[ \\t\\r]/,\n        /**\n     * Use this regular expression to filter consecutive groups of non spaces.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */ _reWords: /\\S+/g,\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"text\",\n        /**\n     * Font size (in pixels)\n     * @type Number\n     * @default\n     */ fontSize: 40,\n        /**\n     * Font weight (e.g. bold, normal, 400, 600, 800)\n     * @type {(Number|String)}\n     * @default\n     */ fontWeight: \"normal\",\n        /**\n     * Font family\n     * @type String\n     * @default\n     */ fontFamily: \"Times New Roman\",\n        /**\n     * Text decoration underline.\n     * @type Boolean\n     * @default\n     */ underline: false,\n        /**\n     * Text decoration overline.\n     * @type Boolean\n     * @default\n     */ overline: false,\n        /**\n     * Text decoration linethrough.\n     * @type Boolean\n     * @default\n     */ linethrough: false,\n        /**\n     * Text alignment. Possible values: \"left\", \"center\", \"right\", \"justify\",\n     * \"justify-left\", \"justify-center\" or \"justify-right\".\n     * @type String\n     * @default\n     */ textAlign: \"left\",\n        /**\n     * Font style . Possible values: \"\", \"normal\", \"italic\" or \"oblique\".\n     * @type String\n     * @default\n     */ fontStyle: \"normal\",\n        /**\n     * Line height\n     * @type Number\n     * @default\n     */ lineHeight: 1.16,\n        /**\n     * Superscript schema object (minimum overlap)\n     * @type {Object}\n     * @default\n     */ superscript: {\n            size: 0.60,\n            baseline: -0.35 // baseline-shift factor (upwards)\n        },\n        /**\n     * Subscript schema object (minimum overlap)\n     * @type {Object}\n     * @default\n     */ subscript: {\n            size: 0.60,\n            baseline: 0.11 // baseline-shift factor (downwards)\n        },\n        /**\n     * Background color of text lines\n     * @type String\n     * @default\n     */ textBackgroundColor: \"\",\n        /**\n     * List of properties to consider when checking if\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: fabric.Object.prototype.stateProperties.concat(additionalProps),\n        /**\n     * List of properties to consider when checking if cache needs refresh\n     * @type Array\n     */ cacheProperties: fabric.Object.prototype.cacheProperties.concat(additionalProps),\n        /**\n     * When defined, an object is rendered via stroke and this property specifies its color.\n     * <b>Backwards incompatibility note:</b> This property was named \"strokeStyle\" until v1.1.6\n     * @type String\n     * @default\n     */ stroke: null,\n        /**\n     * Shadow object representing shadow of this shape.\n     * <b>Backwards incompatibility note:</b> This property was named \"textShadow\" (String) until v1.2.11\n     * @type fabric.Shadow\n     * @default\n     */ shadow: null,\n        /**\n     * fabric.Path that the text should follow.\n     * since 4.6.0 the path will be drawn automatically.\n     * if you want to make the path visible, give it a stroke and strokeWidth or fill value\n     * if you want it to be hidden, assign visible = false to the path.\n     * This feature is in BETA, and SVG import/export is not yet supported.\n     * @type fabric.Path\n     * @example\n     * var textPath = new fabric.Text('Text on a path', {\n     *     top: 150,\n     *     left: 150,\n     *     textAlign: 'center',\n     *     charSpacing: -50,\n     *     path: new fabric.Path('M 0 0 C 50 -100 150 -100 200 0', {\n     *         strokeWidth: 1,\n     *         visible: false\n     *     }),\n     *     pathSide: 'left',\n     *     pathStartOffset: 0\n     * });\n     * @default\n     */ path: null,\n        /**\n     * Offset amount for text path starting position\n     * Only used when text has a path\n     * @type Number\n     * @default\n     */ pathStartOffset: 0,\n        /**\n     * Which side of the path the text should be drawn on.\n     * Only used when text has a path\n     * @type {String} 'left|right'\n     * @default\n     */ pathSide: \"left\",\n        /**\n     * How text is aligned to the path. This property determines\n     * the perpendicular position of each character relative to the path.\n     * (one of \"baseline\", \"center\", \"ascender\", \"descender\")\n     * This feature is in BETA, and its behavior may change\n     * @type String\n     * @default\n     */ pathAlign: \"baseline\",\n        /**\n     * @private\n     */ _fontSizeFraction: 0.222,\n        /**\n     * @private\n     */ offsets: {\n            underline: 0.10,\n            linethrough: -0.315,\n            overline: -0.88\n        },\n        /**\n     * Text Line proportion to font Size (in pixels)\n     * @type Number\n     * @default\n     */ _fontSizeMult: 1.13,\n        /**\n     * additional space between characters\n     * expressed in thousands of em unit\n     * @type Number\n     * @default\n     */ charSpacing: 0,\n        /**\n     * Object containing character styles - top-level properties -> line numbers,\n     * 2nd-level properties - character numbers\n     * @type Object\n     * @default\n     */ styles: null,\n        /**\n     * Reference to a context to measure text char or couple of chars\n     * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas\n     * once created it will be referenced on fabric._measuringContext to avoid creating a canvas for every\n     * text object created.\n     * @type {CanvasRenderingContext2D}\n     * @default\n     */ _measuringContext: null,\n        /**\n     * Baseline shift, styles only, keep at 0 for the main text object\n     * @type {Number}\n     * @default\n     */ deltaY: 0,\n        /**\n     * WARNING: EXPERIMENTAL. NOT SUPPORTED YET\n     * determine the direction of the text.\n     * This has to be set manually together with textAlign and originX for proper\n     * experience.\n     * some interesting link for the future\n     * https://www.w3.org/International/questions/qa-bidi-unicode-controls\n     * @since 4.5.0\n     * @type {String} 'ltr|rtl'\n     * @default\n     */ direction: \"ltr\",\n        /**\n     * Array of properties that define a style unit (of 'styles').\n     * @type {Array}\n     * @default\n     */ _styleProperties: [\n            \"stroke\",\n            \"strokeWidth\",\n            \"fill\",\n            \"fontFamily\",\n            \"fontSize\",\n            \"fontWeight\",\n            \"fontStyle\",\n            \"underline\",\n            \"overline\",\n            \"linethrough\",\n            \"deltaY\",\n            \"textBackgroundColor\"\n        ],\n        /**\n     * contains characters bounding boxes\n     */ __charBounds: [],\n        /**\n     * use this size when measuring text. To avoid IE11 rounding errors\n     * @type {Number}\n     * @default\n     * @readonly\n     * @private\n     */ CACHE_FONT_SIZE: 400,\n        /**\n     * contains the min text width to avoid getting 0\n     * @type {Number}\n     * @default\n     */ MIN_TEXT_WIDTH: 2,\n        /**\n     * Constructor\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.Text} thisArg\n     */ initialize: function(text, options) {\n            this.styles = options ? options.styles || {} : {};\n            this.text = text;\n            this.__skipDimension = true;\n            this.callSuper(\"initialize\", options);\n            if (this.path) {\n                this.setPathInfo();\n            }\n            this.__skipDimension = false;\n            this.initDimensions();\n            this.setCoords();\n            this.setupState({\n                propertySet: \"_dimensionAffectingProps\"\n            });\n        },\n        /**\n     * If text has a path, it will add the extra information needed\n     * for path and text calculations\n     * @return {fabric.Text} thisArg\n     */ setPathInfo: function() {\n            var path = this.path;\n            if (path) {\n                path.segmentsInfo = fabric.util.getPathSegmentsInfo(path.path);\n            }\n        },\n        /**\n     * Return a context for measurement of text string.\n     * if created it gets stored for reuse\n     * this is for internal use, please do not use it\n     * @private\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.Text} thisArg\n     */ getMeasuringContext: function() {\n            // if we did not return we have to measure something.\n            if (!fabric._measuringContext) {\n                fabric._measuringContext = this.canvas && this.canvas.contextCache || fabric.util.createCanvasElement().getContext(\"2d\");\n            }\n            return fabric._measuringContext;\n        },\n        /**\n     * @private\n     * Divides text into lines of text and lines of graphemes.\n     */ _splitText: function() {\n            var newLines = this._splitTextIntoLines(this.text);\n            this.textLines = newLines.lines;\n            this._textLines = newLines.graphemeLines;\n            this._unwrappedTextLines = newLines._unwrappedLines;\n            this._text = newLines.graphemeText;\n            return newLines;\n        },\n        /**\n     * Initialize or update text dimensions.\n     * Updates this.width and this.height with the proper values.\n     * Does not return dimensions.\n     */ initDimensions: function() {\n            if (this.__skipDimension) {\n                return;\n            }\n            this._splitText();\n            this._clearCache();\n            if (this.path) {\n                this.width = this.path.width;\n                this.height = this.path.height;\n            } else {\n                this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;\n                this.height = this.calcTextHeight();\n            }\n            if (this.textAlign.indexOf(\"justify\") !== -1) {\n                // once text is measured we need to make space fatter to make justified text.\n                this.enlargeSpaces();\n            }\n            this.saveState({\n                propertySet: \"_dimensionAffectingProps\"\n            });\n        },\n        /**\n     * Enlarge space boxes and shift the others\n     */ enlargeSpaces: function() {\n            var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                if (this.textAlign !== \"justify\" && (i === len - 1 || this.isEndOfWrapping(i))) {\n                    continue;\n                }\n                accumulatedSpace = 0;\n                line = this._textLines[i];\n                currentLineWidth = this.getLineWidth(i);\n                if (currentLineWidth < this.width && (spaces = this.textLines[i].match(this._reSpacesAndTabs))) {\n                    numberOfSpaces = spaces.length;\n                    diffSpace = (this.width - currentLineWidth) / numberOfSpaces;\n                    for(var j = 0, jlen = line.length; j <= jlen; j++){\n                        charBound = this.__charBounds[i][j];\n                        if (this._reSpaceAndTab.test(line[j])) {\n                            charBound.width += diffSpace;\n                            charBound.kernedWidth += diffSpace;\n                            charBound.left += accumulatedSpace;\n                            accumulatedSpace += diffSpace;\n                        } else {\n                            charBound.left += accumulatedSpace;\n                        }\n                    }\n                }\n            }\n        },\n        /**\n     * Detect if the text line is ended with an hard break\n     * text and itext do not have wrapping, return false\n     * @return {Boolean}\n     */ isEndOfWrapping: function(lineIndex) {\n            return lineIndex === this._textLines.length - 1;\n        },\n        /**\n     * Detect if a line has a linebreak and so we need to account for it when moving\n     * and counting style.\n     * It return always for text and Itext.\n     * @return Number\n     */ missingNewlineOffset: function() {\n            return 1;\n        },\n        /**\n     * Returns string representation of an instance\n     * @return {String} String representation of text object\n     */ toString: function() {\n            return \"#<fabric.Text (\" + this.complexity() + '): { \"text\": \"' + this.text + '\", \"fontFamily\": \"' + this.fontFamily + '\" }>';\n        },\n        /**\n     * Return the dimension and the zoom level needed to create a cache canvas\n     * big enough to host the object to be cached.\n     * @private\n     * @param {Object} dim.x width of object to be cached\n     * @param {Object} dim.y height of object to be cached\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */ _getCacheCanvasDimensions: function() {\n            var dims = this.callSuper(\"_getCacheCanvasDimensions\");\n            var fontSize = this.fontSize;\n            dims.width += fontSize * dims.zoomX;\n            dims.height += fontSize * dims.zoomY;\n            return dims;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            var path = this.path;\n            path && !path.isNotVisible() && path._render(ctx);\n            this._setTextStyles(ctx);\n            this._renderTextLinesBackground(ctx);\n            this._renderTextDecoration(ctx, \"underline\");\n            this._renderText(ctx);\n            this._renderTextDecoration(ctx, \"overline\");\n            this._renderTextDecoration(ctx, \"linethrough\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderText: function(ctx) {\n            if (this.paintFirst === \"stroke\") {\n                this._renderTextStroke(ctx);\n                this._renderTextFill(ctx);\n            } else {\n                this._renderTextFill(ctx);\n                this._renderTextStroke(ctx);\n            }\n        },\n        /**\n     * Set the font parameter of the context with the object properties or with charStyle\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [charStyle] object with font style properties\n     * @param {String} [charStyle.fontFamily] Font Family\n     * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )\n     * @param {String} [charStyle.fontWeight] Font weight\n     * @param {String} [charStyle.fontStyle] Font style (italic|normal)\n     */ _setTextStyles: function(ctx, charStyle, forMeasuring) {\n            ctx.textBaseline = \"alphabetical\";\n            if (this.path) {\n                switch(this.pathAlign){\n                    case \"center\":\n                        ctx.textBaseline = \"middle\";\n                        break;\n                    case \"ascender\":\n                        ctx.textBaseline = \"top\";\n                        break;\n                    case \"descender\":\n                        ctx.textBaseline = \"bottom\";\n                        break;\n                }\n            }\n            ctx.font = this._getFontDeclaration(charStyle, forMeasuring);\n        },\n        /**\n     * calculate and return the text Width measuring each line.\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @return {Number} Maximum width of fabric.Text object\n     */ calcTextWidth: function() {\n            var maxWidth = this.getLineWidth(0);\n            for(var i = 1, len = this._textLines.length; i < len; i++){\n                var currentLineWidth = this.getLineWidth(i);\n                if (currentLineWidth > maxWidth) {\n                    maxWidth = currentLineWidth;\n                }\n            }\n            return maxWidth;\n        },\n        /**\n     * @private\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {String} line Text to render\n     * @param {Number} left Left position of text\n     * @param {Number} top Top position of text\n     * @param {Number} lineIndex Index of a line in a text\n     */ _renderTextLine: function(method, ctx, line, left, top, lineIndex) {\n            this._renderChars(method, ctx, line, left, top, lineIndex);\n        },\n        /**\n     * Renders the text background for lines, taking care of style\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextLinesBackground: function(ctx) {\n            if (!this.textBackgroundColor && !this.styleHas(\"textBackgroundColor\")) {\n                return;\n            }\n            var heightOfLine, lineLeftOffset, originalFill = ctx.fillStyle, line, lastColor, leftOffset = this._getLeftOffset(), lineTopOffset = this._getTopOffset(), boxStart = 0, boxWidth = 0, charBox, currentColor, path = this.path, drawStart;\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                heightOfLine = this.getHeightOfLine(i);\n                if (!this.textBackgroundColor && !this.styleHas(\"textBackgroundColor\", i)) {\n                    lineTopOffset += heightOfLine;\n                    continue;\n                }\n                line = this._textLines[i];\n                lineLeftOffset = this._getLineLeftOffset(i);\n                boxWidth = 0;\n                boxStart = 0;\n                lastColor = this.getValueOfPropertyAt(i, 0, \"textBackgroundColor\");\n                for(var j = 0, jlen = line.length; j < jlen; j++){\n                    charBox = this.__charBounds[i][j];\n                    currentColor = this.getValueOfPropertyAt(i, j, \"textBackgroundColor\");\n                    if (path) {\n                        ctx.save();\n                        ctx.translate(charBox.renderLeft, charBox.renderTop);\n                        ctx.rotate(charBox.angle);\n                        ctx.fillStyle = currentColor;\n                        currentColor && ctx.fillRect(-charBox.width / 2, -heightOfLine / this.lineHeight * (1 - this._fontSizeFraction), charBox.width, heightOfLine / this.lineHeight);\n                        ctx.restore();\n                    } else if (currentColor !== lastColor) {\n                        drawStart = leftOffset + lineLeftOffset + boxStart;\n                        if (this.direction === \"rtl\") {\n                            drawStart = this.width - drawStart - boxWidth;\n                        }\n                        ctx.fillStyle = lastColor;\n                        lastColor && ctx.fillRect(drawStart, lineTopOffset, boxWidth, heightOfLine / this.lineHeight);\n                        boxStart = charBox.left;\n                        boxWidth = charBox.width;\n                        lastColor = currentColor;\n                    } else {\n                        boxWidth += charBox.kernedWidth;\n                    }\n                }\n                if (currentColor && !path) {\n                    drawStart = leftOffset + lineLeftOffset + boxStart;\n                    if (this.direction === \"rtl\") {\n                        drawStart = this.width - drawStart - boxWidth;\n                    }\n                    ctx.fillStyle = currentColor;\n                    ctx.fillRect(drawStart, lineTopOffset, boxWidth, heightOfLine / this.lineHeight);\n                }\n                lineTopOffset += heightOfLine;\n            }\n            ctx.fillStyle = originalFill;\n            // if there is text background color no\n            // other shadows should be casted\n            this._removeShadow(ctx);\n        },\n        /**\n     * @private\n     * @param {Object} decl style declaration for cache\n     * @param {String} decl.fontFamily fontFamily\n     * @param {String} decl.fontStyle fontStyle\n     * @param {String} decl.fontWeight fontWeight\n     * @return {Object} reference to cache\n     */ getFontCache: function(decl) {\n            var fontFamily = decl.fontFamily.toLowerCase();\n            if (!fabric.charWidthsCache[fontFamily]) {\n                fabric.charWidthsCache[fontFamily] = {};\n            }\n            var cache = fabric.charWidthsCache[fontFamily], cacheProp = decl.fontStyle.toLowerCase() + \"_\" + (decl.fontWeight + \"\").toLowerCase();\n            if (!cache[cacheProp]) {\n                cache[cacheProp] = {};\n            }\n            return cache[cacheProp];\n        },\n        /**\n     * measure and return the width of a single character.\n     * possibly overridden to accommodate different measure logic or\n     * to hook some external lib for character measurement\n     * @private\n     * @param {String} _char, char to be measured\n     * @param {Object} charStyle style of char to be measured\n     * @param {String} [previousChar] previous char\n     * @param {Object} [prevCharStyle] style of previous char\n     */ _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {\n            // first i try to return from cache\n            var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle), previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char, stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth, fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE, kernedWidth;\n            if (previousChar && fontCache[previousChar] !== undefined) {\n                previousWidth = fontCache[previousChar];\n            }\n            if (fontCache[_char] !== undefined) {\n                kernedWidth = width = fontCache[_char];\n            }\n            if (stylesAreEqual && fontCache[couple] !== undefined) {\n                coupleWidth = fontCache[couple];\n                kernedWidth = coupleWidth - previousWidth;\n            }\n            if (width === undefined || previousWidth === undefined || coupleWidth === undefined) {\n                var ctx = this.getMeasuringContext();\n                // send a TRUE to specify measuring font size CACHE_FONT_SIZE\n                this._setTextStyles(ctx, charStyle, true);\n            }\n            if (width === undefined) {\n                kernedWidth = width = ctx.measureText(_char).width;\n                fontCache[_char] = width;\n            }\n            if (previousWidth === undefined && stylesAreEqual && previousChar) {\n                previousWidth = ctx.measureText(previousChar).width;\n                fontCache[previousChar] = previousWidth;\n            }\n            if (stylesAreEqual && coupleWidth === undefined) {\n                // we can measure the kerning couple and subtract the width of the previous character\n                coupleWidth = ctx.measureText(couple).width;\n                fontCache[couple] = coupleWidth;\n                kernedWidth = coupleWidth - previousWidth;\n            }\n            return {\n                width: width * fontMultiplier,\n                kernedWidth: kernedWidth * fontMultiplier\n            };\n        },\n        /**\n     * Computes height of character at given position\n     * @param {Number} line the line index number\n     * @param {Number} _char the character index number\n     * @return {Number} fontSize of the character\n     */ getHeightOfChar: function(line, _char) {\n            return this.getValueOfPropertyAt(line, _char, \"fontSize\");\n        },\n        /**\n     * measure a text line measuring all characters.\n     * @param {Number} lineIndex line number\n     * @return {Number} Line width\n     */ measureLine: function(lineIndex) {\n            var lineInfo = this._measureLine(lineIndex);\n            if (this.charSpacing !== 0) {\n                lineInfo.width -= this._getWidthOfCharSpacing();\n            }\n            if (lineInfo.width < 0) {\n                lineInfo.width = 0;\n            }\n            return lineInfo;\n        },\n        /**\n     * measure every grapheme of a line, populating __charBounds\n     * @param {Number} lineIndex\n     * @return {Object} object.width total width of characters\n     * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs\n     */ _measureLine: function(lineIndex) {\n            var width = 0, i, grapheme, line = this._textLines[lineIndex], prevGrapheme, graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length), positionInPath = 0, startingPoint, totalPathLength, path = this.path, reverse = this.pathSide === \"right\";\n            this.__charBounds[lineIndex] = lineBounds;\n            for(i = 0; i < line.length; i++){\n                grapheme = line[i];\n                graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);\n                lineBounds[i] = graphemeInfo;\n                width += graphemeInfo.kernedWidth;\n                prevGrapheme = grapheme;\n            }\n            // this latest bound box represent the last character of the line\n            // to simplify cursor handling in interactive mode.\n            lineBounds[i] = {\n                left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,\n                width: 0,\n                kernedWidth: 0,\n                height: this.fontSize\n            };\n            if (path) {\n                totalPathLength = path.segmentsInfo[path.segmentsInfo.length - 1].length;\n                startingPoint = fabric.util.getPointOnPath(path.path, 0, path.segmentsInfo);\n                startingPoint.x += path.pathOffset.x;\n                startingPoint.y += path.pathOffset.y;\n                switch(this.textAlign){\n                    case \"left\":\n                        positionInPath = reverse ? totalPathLength - width : 0;\n                        break;\n                    case \"center\":\n                        positionInPath = (totalPathLength - width) / 2;\n                        break;\n                    case \"right\":\n                        positionInPath = reverse ? 0 : totalPathLength - width;\n                        break;\n                }\n                positionInPath += this.pathStartOffset * (reverse ? -1 : 1);\n                for(i = reverse ? line.length - 1 : 0; reverse ? i >= 0 : i < line.length; reverse ? i-- : i++){\n                    graphemeInfo = lineBounds[i];\n                    if (positionInPath > totalPathLength) {\n                        positionInPath %= totalPathLength;\n                    } else if (positionInPath < 0) {\n                        positionInPath += totalPathLength;\n                    }\n                    // it would probably much faster to send all the grapheme position for a line\n                    // and calculate path position/angle at once.\n                    this._setGraphemeOnPath(positionInPath, graphemeInfo, startingPoint);\n                    positionInPath += graphemeInfo.kernedWidth;\n                }\n            }\n            return {\n                width: width,\n                numOfSpaces: numOfSpaces\n            };\n        },\n        /**\n     * Calculate the angle  and the left,top position of the char that follow a path.\n     * It appends it to graphemeInfo to be reused later at rendering\n     * @private\n     * @param {Number} positionInPath to be measured\n     * @param {Object} graphemeInfo current grapheme box information\n     * @param {Object} startingPoint position of the point\n     */ _setGraphemeOnPath: function(positionInPath, graphemeInfo, startingPoint) {\n            var centerPosition = positionInPath + graphemeInfo.kernedWidth / 2, path = this.path;\n            // we are at currentPositionOnPath. we want to know what point on the path is.\n            var info = fabric.util.getPointOnPath(path.path, centerPosition, path.segmentsInfo);\n            graphemeInfo.renderLeft = info.x - startingPoint.x;\n            graphemeInfo.renderTop = info.y - startingPoint.y;\n            graphemeInfo.angle = info.angle + (this.pathSide === \"right\" ? Math.PI : 0);\n        },\n        /**\n     * Measure and return the info of a single grapheme.\n     * needs the the info of previous graphemes already filled\n     * @private\n     * @param {String} grapheme to be measured\n     * @param {Number} lineIndex index of the line where the char is\n     * @param {Number} charIndex position in the line\n     * @param {String} [prevGrapheme] character preceding the one to be measured\n     */ _getGraphemeBox: function(grapheme, lineIndex, charIndex, prevGrapheme, skipLeft) {\n            var style = this.getCompleteStyleDeclaration(lineIndex, charIndex), prevStyle = prevGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : {}, info = this._measureChar(grapheme, style, prevGrapheme, prevStyle), kernedWidth = info.kernedWidth, width = info.width, charSpacing;\n            if (this.charSpacing !== 0) {\n                charSpacing = this._getWidthOfCharSpacing();\n                width += charSpacing;\n                kernedWidth += charSpacing;\n            }\n            var box = {\n                width: width,\n                left: 0,\n                height: style.fontSize,\n                kernedWidth: kernedWidth,\n                deltaY: style.deltaY\n            };\n            if (charIndex > 0 && !skipLeft) {\n                var previousBox = this.__charBounds[lineIndex][charIndex - 1];\n                box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;\n            }\n            return box;\n        },\n        /**\n     * Calculate height of line at 'lineIndex'\n     * @param {Number} lineIndex index of line to calculate\n     * @return {Number}\n     */ getHeightOfLine: function(lineIndex) {\n            if (this.__lineHeights[lineIndex]) {\n                return this.__lineHeights[lineIndex];\n            }\n            var line = this._textLines[lineIndex], // char 0 is measured before the line cycle because it nneds to char\n            // emptylines\n            maxHeight = this.getHeightOfChar(lineIndex, 0);\n            for(var i = 1, len = line.length; i < len; i++){\n                maxHeight = Math.max(this.getHeightOfChar(lineIndex, i), maxHeight);\n            }\n            return this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;\n        },\n        /**\n     * Calculate text box height\n     */ calcTextHeight: function() {\n            var lineHeight, height = 0;\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                lineHeight = this.getHeightOfLine(i);\n                height += i === len - 1 ? lineHeight / this.lineHeight : lineHeight;\n            }\n            return height;\n        },\n        /**\n     * @private\n     * @return {Number} Left offset\n     */ _getLeftOffset: function() {\n            return this.direction === \"ltr\" ? -this.width / 2 : this.width / 2;\n        },\n        /**\n     * @private\n     * @return {Number} Top offset\n     */ _getTopOffset: function() {\n            return -this.height / 2;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\n     */ _renderTextCommon: function(ctx, method) {\n            ctx.save();\n            var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset();\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                var heightOfLine = this.getHeightOfLine(i), maxHeight = heightOfLine / this.lineHeight, leftOffset = this._getLineLeftOffset(i);\n                this._renderTextLine(method, ctx, this._textLines[i], left + leftOffset, top + lineHeights + maxHeight, i);\n                lineHeights += heightOfLine;\n            }\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextFill: function(ctx) {\n            if (!this.fill && !this.styleHas(\"fill\")) {\n                return;\n            }\n            this._renderTextCommon(ctx, \"fillText\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextStroke: function(ctx) {\n            if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {\n                return;\n            }\n            if (this.shadow && !this.shadow.affectStroke) {\n                this._removeShadow(ctx);\n            }\n            ctx.save();\n            this._setLineDash(ctx, this.strokeDashArray);\n            ctx.beginPath();\n            this._renderTextCommon(ctx, \"strokeText\");\n            ctx.closePath();\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {String} method fillText or strokeText.\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Array} line Content of the line, splitted in an array by grapheme\n     * @param {Number} left\n     * @param {Number} top\n     * @param {Number} lineIndex\n     */ _renderChars: function(method, ctx, line, left, top, lineIndex) {\n            // set proper line offset\n            var lineHeight = this.getHeightOfLine(lineIndex), isJustify = this.textAlign.indexOf(\"justify\") !== -1, actualStyle, nextStyle, charsToRender = \"\", charBox, boxWidth = 0, timeToRender, path = this.path, shortCut = !isJustify && this.charSpacing === 0 && this.isEmptyStyles(lineIndex) && !path, isLtr = this.direction === \"ltr\", sign = this.direction === \"ltr\" ? 1 : -1, drawingLeft, currentDirection = ctx.canvas.getAttribute(\"dir\");\n            ctx.save();\n            if (currentDirection !== this.direction) {\n                ctx.canvas.setAttribute(\"dir\", isLtr ? \"ltr\" : \"rtl\");\n                ctx.direction = isLtr ? \"ltr\" : \"rtl\";\n                ctx.textAlign = isLtr ? \"left\" : \"right\";\n            }\n            top -= lineHeight * this._fontSizeFraction / this.lineHeight;\n            if (shortCut) {\n                // render all the line in one pass without checking\n                // drawingLeft = isLtr ? left : left - this.getLineWidth(lineIndex);\n                this._renderChar(method, ctx, lineIndex, 0, line.join(\"\"), left, top, lineHeight);\n                ctx.restore();\n                return;\n            }\n            for(var i = 0, len = line.length - 1; i <= len; i++){\n                timeToRender = i === len || this.charSpacing || path;\n                charsToRender += line[i];\n                charBox = this.__charBounds[lineIndex][i];\n                if (boxWidth === 0) {\n                    left += sign * (charBox.kernedWidth - charBox.width);\n                    boxWidth += charBox.width;\n                } else {\n                    boxWidth += charBox.kernedWidth;\n                }\n                if (isJustify && !timeToRender) {\n                    if (this._reSpaceAndTab.test(line[i])) {\n                        timeToRender = true;\n                    }\n                }\n                if (!timeToRender) {\n                    // if we have charSpacing, we render char by char\n                    actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);\n                    nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);\n                    timeToRender = fabric.util.hasStyleChanged(actualStyle, nextStyle, false);\n                }\n                if (timeToRender) {\n                    if (path) {\n                        ctx.save();\n                        ctx.translate(charBox.renderLeft, charBox.renderTop);\n                        ctx.rotate(charBox.angle);\n                        this._renderChar(method, ctx, lineIndex, i, charsToRender, -boxWidth / 2, 0, lineHeight);\n                        ctx.restore();\n                    } else {\n                        drawingLeft = left;\n                        this._renderChar(method, ctx, lineIndex, i, charsToRender, drawingLeft, top, lineHeight);\n                    }\n                    charsToRender = \"\";\n                    actualStyle = nextStyle;\n                    left += sign * boxWidth;\n                    boxWidth = 0;\n                }\n            }\n            ctx.restore();\n        },\n        /**\n     * This function try to patch the missing gradientTransform on canvas gradients.\n     * transforming a context to transform the gradient, is going to transform the stroke too.\n     * we want to transform the gradient but not the stroke operation, so we create\n     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.\n     * this method has drawbacks: is slow, is in low resolution, needs a patch for when the size\n     * is limited.\n     * @private\n     * @param {fabric.Gradient} filler a fabric gradient instance\n     * @return {CanvasPattern} a pattern to use as fill/stroke style\n     */ _applyPatternGradientTransformText: function(filler) {\n            var pCanvas = fabric.util.createCanvasElement(), pCtx, // TODO: verify compatibility with strokeUniform\n            width = this.width + this.strokeWidth, height = this.height + this.strokeWidth;\n            pCanvas.width = width;\n            pCanvas.height = height;\n            pCtx = pCanvas.getContext(\"2d\");\n            pCtx.beginPath();\n            pCtx.moveTo(0, 0);\n            pCtx.lineTo(width, 0);\n            pCtx.lineTo(width, height);\n            pCtx.lineTo(0, height);\n            pCtx.closePath();\n            pCtx.translate(width / 2, height / 2);\n            pCtx.fillStyle = filler.toLive(pCtx);\n            this._applyPatternGradientTransform(pCtx, filler);\n            pCtx.fill();\n            return pCtx.createPattern(pCanvas, \"no-repeat\");\n        },\n        handleFiller: function(ctx, property, filler) {\n            var offsetX, offsetY;\n            if (filler.toLive) {\n                if (filler.gradientUnits === \"percentage\" || filler.gradientTransform || filler.patternTransform) {\n                    // need to transform gradient in a pattern.\n                    // this is a slow process. If you are hitting this codepath, and the object\n                    // is not using caching, you should consider switching it on.\n                    // we need a canvas as big as the current object caching canvas.\n                    offsetX = -this.width / 2;\n                    offsetY = -this.height / 2;\n                    ctx.translate(offsetX, offsetY);\n                    ctx[property] = this._applyPatternGradientTransformText(filler);\n                    return {\n                        offsetX: offsetX,\n                        offsetY: offsetY\n                    };\n                } else {\n                    // is a simple gradient or pattern\n                    ctx[property] = filler.toLive(ctx, this);\n                    return this._applyPatternGradientTransform(ctx, filler);\n                }\n            } else {\n                // is a color\n                ctx[property] = filler;\n            }\n            return {\n                offsetX: 0,\n                offsetY: 0\n            };\n        },\n        _setStrokeStyles: function(ctx, decl) {\n            ctx.lineWidth = decl.strokeWidth;\n            ctx.lineCap = this.strokeLineCap;\n            ctx.lineDashOffset = this.strokeDashOffset;\n            ctx.lineJoin = this.strokeLineJoin;\n            ctx.miterLimit = this.strokeMiterLimit;\n            return this.handleFiller(ctx, \"strokeStyle\", decl.stroke);\n        },\n        _setFillStyles: function(ctx, decl) {\n            return this.handleFiller(ctx, \"fillStyle\", decl.fill);\n        },\n        /**\n     * @private\n     * @param {String} method\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {String} _char\n     * @param {Number} left Left coordinate\n     * @param {Number} top Top coordinate\n     * @param {Number} lineHeight Height of the line\n     */ _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {\n            var decl = this._getStyleDeclaration(lineIndex, charIndex), fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex), shouldFill = method === \"fillText\" && fullDecl.fill, shouldStroke = method === \"strokeText\" && fullDecl.stroke && fullDecl.strokeWidth, fillOffsets, strokeOffsets;\n            if (!shouldStroke && !shouldFill) {\n                return;\n            }\n            ctx.save();\n            shouldFill && (fillOffsets = this._setFillStyles(ctx, fullDecl));\n            shouldStroke && (strokeOffsets = this._setStrokeStyles(ctx, fullDecl));\n            ctx.font = this._getFontDeclaration(fullDecl);\n            if (decl && decl.textBackgroundColor) {\n                this._removeShadow(ctx);\n            }\n            if (decl && decl.deltaY) {\n                top += decl.deltaY;\n            }\n            shouldFill && ctx.fillText(_char, left - fillOffsets.offsetX, top - fillOffsets.offsetY);\n            shouldStroke && ctx.strokeText(_char, left - strokeOffsets.offsetX, top - strokeOffsets.offsetY);\n            ctx.restore();\n        },\n        /**\n     * Turns the character into a 'superior figure' (i.e. 'superscript')\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */ setSuperscript: function(start, end) {\n            return this._setScript(start, end, this.superscript);\n        },\n        /**\n     * Turns the character into an 'inferior figure' (i.e. 'subscript')\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */ setSubscript: function(start, end) {\n            return this._setScript(start, end, this.subscript);\n        },\n        /**\n     * Applies 'schema' at given position\n     * @private\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @param {Number} schema\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */ _setScript: function(start, end, schema) {\n            var loc = this.get2DCursorLocation(start, true), fontSize = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, \"fontSize\"), dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, \"deltaY\"), style = {\n                fontSize: fontSize * schema.size,\n                deltaY: dy + fontSize * schema.baseline\n            };\n            this.setSelectionStyles(style, start, end);\n            return this;\n        },\n        /**\n     * @private\n     * @param {Number} lineIndex index text line\n     * @return {Number} Line left offset\n     */ _getLineLeftOffset: function(lineIndex) {\n            var lineWidth = this.getLineWidth(lineIndex), lineDiff = this.width - lineWidth, textAlign = this.textAlign, direction = this.direction, isEndOfWrapping, leftOffset = 0, isEndOfWrapping = this.isEndOfWrapping(lineIndex);\n            if (textAlign === \"justify\" || textAlign === \"justify-center\" && !isEndOfWrapping || textAlign === \"justify-right\" && !isEndOfWrapping || textAlign === \"justify-left\" && !isEndOfWrapping) {\n                return 0;\n            }\n            if (textAlign === \"center\") {\n                leftOffset = lineDiff / 2;\n            }\n            if (textAlign === \"right\") {\n                leftOffset = lineDiff;\n            }\n            if (textAlign === \"justify-center\") {\n                leftOffset = lineDiff / 2;\n            }\n            if (textAlign === \"justify-right\") {\n                leftOffset = lineDiff;\n            }\n            if (direction === \"rtl\") {\n                leftOffset -= lineDiff;\n            }\n            return leftOffset;\n        },\n        /**\n     * @private\n     */ _clearCache: function() {\n            this.__lineWidths = [];\n            this.__lineHeights = [];\n            this.__charBounds = [];\n        },\n        /**\n     * @private\n     */ _shouldClearDimensionCache: function() {\n            var shouldClear = this._forceClearCache;\n            shouldClear || (shouldClear = this.hasStateChanged(\"_dimensionAffectingProps\"));\n            if (shouldClear) {\n                this.dirty = true;\n                this._forceClearCache = false;\n            }\n            return shouldClear;\n        },\n        /**\n     * Measure a single line given its index. Used to calculate the initial\n     * text bounding box. The values are calculated and stored in __lineWidths cache.\n     * @private\n     * @param {Number} lineIndex line number\n     * @return {Number} Line width\n     */ getLineWidth: function(lineIndex) {\n            if (this.__lineWidths[lineIndex] !== undefined) {\n                return this.__lineWidths[lineIndex];\n            }\n            var lineInfo = this.measureLine(lineIndex);\n            var width = lineInfo.width;\n            this.__lineWidths[lineIndex] = width;\n            return width;\n        },\n        _getWidthOfCharSpacing: function() {\n            if (this.charSpacing !== 0) {\n                return this.fontSize * this.charSpacing / 1000;\n            }\n            return 0;\n        },\n        /**\n     * Retrieves the value of property at given character position\n     * @param {Number} lineIndex the line number\n     * @param {Number} charIndex the character number\n     * @param {String} property the property name\n     * @returns the value of 'property'\n     */ getValueOfPropertyAt: function(lineIndex, charIndex, property) {\n            var charStyle = this._getStyleDeclaration(lineIndex, charIndex);\n            if (charStyle && typeof charStyle[property] !== \"undefined\") {\n                return charStyle[property];\n            }\n            return this[property];\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextDecoration: function(ctx, type) {\n            if (!this[type] && !this.styleHas(type)) {\n                return;\n            }\n            var heightOfLine, size, _size, lineLeftOffset, dy, _dy, line, lastDecoration, leftOffset = this._getLeftOffset(), topOffset = this._getTopOffset(), top, boxStart, boxWidth, charBox, currentDecoration, maxHeight, currentFill, lastFill, path = this.path, charSpacing = this._getWidthOfCharSpacing(), offsetY = this.offsets[type];\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                heightOfLine = this.getHeightOfLine(i);\n                if (!this[type] && !this.styleHas(type, i)) {\n                    topOffset += heightOfLine;\n                    continue;\n                }\n                line = this._textLines[i];\n                maxHeight = heightOfLine / this.lineHeight;\n                lineLeftOffset = this._getLineLeftOffset(i);\n                boxStart = 0;\n                boxWidth = 0;\n                lastDecoration = this.getValueOfPropertyAt(i, 0, type);\n                lastFill = this.getValueOfPropertyAt(i, 0, \"fill\");\n                top = topOffset + maxHeight * (1 - this._fontSizeFraction);\n                size = this.getHeightOfChar(i, 0);\n                dy = this.getValueOfPropertyAt(i, 0, \"deltaY\");\n                for(var j = 0, jlen = line.length; j < jlen; j++){\n                    charBox = this.__charBounds[i][j];\n                    currentDecoration = this.getValueOfPropertyAt(i, j, type);\n                    currentFill = this.getValueOfPropertyAt(i, j, \"fill\");\n                    _size = this.getHeightOfChar(i, j);\n                    _dy = this.getValueOfPropertyAt(i, j, \"deltaY\");\n                    if (path && currentDecoration && currentFill) {\n                        ctx.save();\n                        ctx.fillStyle = lastFill;\n                        ctx.translate(charBox.renderLeft, charBox.renderTop);\n                        ctx.rotate(charBox.angle);\n                        ctx.fillRect(-charBox.kernedWidth / 2, offsetY * _size + _dy, charBox.kernedWidth, this.fontSize / 15);\n                        ctx.restore();\n                    } else if ((currentDecoration !== lastDecoration || currentFill !== lastFill || _size !== size || _dy !== dy) && boxWidth > 0) {\n                        var drawStart = leftOffset + lineLeftOffset + boxStart;\n                        if (this.direction === \"rtl\") {\n                            drawStart = this.width - drawStart - boxWidth;\n                        }\n                        if (lastDecoration && lastFill) {\n                            ctx.fillStyle = lastFill;\n                            ctx.fillRect(drawStart, top + offsetY * size + dy, boxWidth, this.fontSize / 15);\n                        }\n                        boxStart = charBox.left;\n                        boxWidth = charBox.width;\n                        lastDecoration = currentDecoration;\n                        lastFill = currentFill;\n                        size = _size;\n                        dy = _dy;\n                    } else {\n                        boxWidth += charBox.kernedWidth;\n                    }\n                }\n                var drawStart = leftOffset + lineLeftOffset + boxStart;\n                if (this.direction === \"rtl\") {\n                    drawStart = this.width - drawStart - boxWidth;\n                }\n                ctx.fillStyle = currentFill;\n                currentDecoration && currentFill && ctx.fillRect(drawStart, top + offsetY * size + dy, boxWidth - charSpacing, this.fontSize / 15);\n                topOffset += heightOfLine;\n            }\n            // if there is text background color no\n            // other shadows should be casted\n            this._removeShadow(ctx);\n        },\n        /**\n     * return font declaration string for canvas context\n     * @param {Object} [styleObject] object\n     * @returns {String} font declaration formatted for canvas context.\n     */ _getFontDeclaration: function(styleObject, forMeasuring) {\n            var style = styleObject || this, family = this.fontFamily, fontIsGeneric = fabric.Text.genericFonts.indexOf(family.toLowerCase()) > -1;\n            var fontFamily = family === undefined || family.indexOf(\"'\") > -1 || family.indexOf(\",\") > -1 || family.indexOf('\"') > -1 || fontIsGeneric ? style.fontFamily : '\"' + style.fontFamily + '\"';\n            return [\n                // node-canvas needs \"weight style\", while browsers need \"style weight\"\n                // verify if this can be fixed in JSDOM\n                fabric.isLikelyNode ? style.fontWeight : style.fontStyle,\n                fabric.isLikelyNode ? style.fontStyle : style.fontWeight,\n                forMeasuring ? this.CACHE_FONT_SIZE + \"px\" : style.fontSize + \"px\",\n                fontFamily\n            ].join(\" \");\n        },\n        /**\n     * Renders text instance on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ render: function(ctx) {\n            // do not render if object is not visible\n            if (!this.visible) {\n                return;\n            }\n            if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {\n                return;\n            }\n            if (this._shouldClearDimensionCache()) {\n                this.initDimensions();\n            }\n            this.callSuper(\"render\", ctx);\n        },\n        /**\n     * Returns the text as an array of lines.\n     * @param {String} text text to split\n     * @returns {Array} Lines in the text\n     */ _splitTextIntoLines: function(text) {\n            var lines = text.split(this._reNewline), newLines = new Array(lines.length), newLine = [\n                \"\\n\"\n            ], newText = [];\n            for(var i = 0; i < lines.length; i++){\n                newLines[i] = fabric.util.string.graphemeSplit(lines[i]);\n                newText = newText.concat(newLines[i], newLine);\n            }\n            newText.pop();\n            return {\n                _unwrappedLines: newLines,\n                lines: lines,\n                graphemeText: newText,\n                graphemeLines: newLines\n            };\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var allProperties = additionalProps.concat(propertiesToInclude);\n            var obj = this.callSuper(\"toObject\", allProperties);\n            obj.styles = fabric.util.stylesToArray(this.styles, this.text);\n            if (obj.path) {\n                obj.path = this.path.toObject();\n            }\n            return obj;\n        },\n        /**\n     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.\n     * @param {String|Object} key Property name or object (if object, iterate over the object properties)\n     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ set: function(key, value) {\n            this.callSuper(\"set\", key, value);\n            var needsDims = false;\n            var isAddingPath = false;\n            if (typeof key === \"object\") {\n                for(var _key in key){\n                    if (_key === \"path\") {\n                        this.setPathInfo();\n                    }\n                    needsDims = needsDims || this._dimensionAffectingProps.indexOf(_key) !== -1;\n                    isAddingPath = isAddingPath || _key === \"path\";\n                }\n            } else {\n                needsDims = this._dimensionAffectingProps.indexOf(key) !== -1;\n                isAddingPath = key === \"path\";\n            }\n            if (isAddingPath) {\n                this.setPathInfo();\n            }\n            if (needsDims) {\n                this.initDimensions();\n                this.setCoords();\n            }\n            return this;\n        },\n        /**\n     * Returns complexity of an instance\n     * @return {Number} complexity\n     */ complexity: function() {\n            return 1;\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})\n   * @static\n   * @memberOf fabric.Text\n   * @see: http://www.w3.org/TR/SVG/text.html#TextElement\n   */ fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor\".split(\" \"));\n    /**\n   * Default SVG font size\n   * @static\n   * @memberOf fabric.Text\n   */ fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;\n    /**\n   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)\n   * @static\n   * @memberOf fabric.Text\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Text.fromElement = function(element, callback, options) {\n        if (!element) {\n            return callback(null);\n        }\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES), parsedAnchor = parsedAttributes.textAnchor || \"left\";\n        options = fabric.util.object.extend(options ? clone(options) : {}, parsedAttributes);\n        options.top = options.top || 0;\n        options.left = options.left || 0;\n        if (parsedAttributes.textDecoration) {\n            var textDecoration = parsedAttributes.textDecoration;\n            if (textDecoration.indexOf(\"underline\") !== -1) {\n                options.underline = true;\n            }\n            if (textDecoration.indexOf(\"overline\") !== -1) {\n                options.overline = true;\n            }\n            if (textDecoration.indexOf(\"line-through\") !== -1) {\n                options.linethrough = true;\n            }\n            delete options.textDecoration;\n        }\n        if (\"dx\" in parsedAttributes) {\n            options.left += parsedAttributes.dx;\n        }\n        if (\"dy\" in parsedAttributes) {\n            options.top += parsedAttributes.dy;\n        }\n        if (!(\"fontSize\" in options)) {\n            options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\n        }\n        var textContent = \"\";\n        // The XML is not properly parsed in IE9 so a workaround to get\n        // textContent is through firstChild.data. Another workaround would be\n        // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)\n        if (!(\"textContent\" in element)) {\n            if (\"firstChild\" in element && element.firstChild !== null) {\n                if (\"data\" in element.firstChild && element.firstChild.data !== null) {\n                    textContent = element.firstChild.data;\n                }\n            }\n        } else {\n            textContent = element.textContent;\n        }\n        textContent = textContent.replace(/^\\s+|\\s+$|\\n+/g, \"\").replace(/\\s+/g, \" \");\n        var originalStrokeWidth = options.strokeWidth;\n        options.strokeWidth = 0;\n        var text = new fabric.Text(textContent, options), textHeightScaleFactor = text.getScaledHeight() / text.height, lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height, scaledDiff = lineHeightDiff * textHeightScaleFactor, textHeight = text.getScaledHeight() + scaledDiff, offX = 0;\n        /*\n      Adjust positioning:\n        x/y attributes in SVG correspond to the bottom-left corner of text bounding box\n        fabric output by default at top, left.\n    */ if (parsedAnchor === \"center\") {\n            offX = text.getScaledWidth() / 2;\n        }\n        if (parsedAnchor === \"right\") {\n            offX = text.getScaledWidth();\n        }\n        text.set({\n            left: text.left - offX,\n            top: text.top - (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) / text.lineHeight,\n            strokeWidth: typeof originalStrokeWidth !== \"undefined\" ? originalStrokeWidth : 1\n        });\n        callback(text);\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Text instance from an object representation\n   * @static\n   * @memberOf fabric.Text\n   * @param {Object} object plain js Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created\n   */ fabric.Text.fromObject = function(object, callback) {\n        var objectCopy = clone(object), path = object.path;\n        delete objectCopy.path;\n        return fabric.Object._fromObject(\"Text\", objectCopy, function(textInstance) {\n            textInstance.styles = fabric.util.stylesFromArray(object.styles, object.text);\n            if (path) {\n                fabric.Object._fromObject(\"Path\", path, function(pathInstance) {\n                    textInstance.set(\"path\", pathInstance);\n                    callback(textInstance);\n                }, \"path\");\n            } else {\n                callback(textInstance);\n            }\n        }, \"text\");\n    };\n    fabric.Text.genericFonts = [\n        \"sans-serif\",\n        \"serif\",\n        \"cursive\",\n        \"fantasy\",\n        \"monospace\"\n    ];\n    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Text);\n})( true ? exports : 0);\n(function() {\n    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {\n        /**\n     * Returns true if object has no styling or no styling in a line\n     * @param {Number} lineIndex , lineIndex is on wrapped lines.\n     * @return {Boolean}\n     */ isEmptyStyles: function(lineIndex) {\n            if (!this.styles) {\n                return true;\n            }\n            if (typeof lineIndex !== \"undefined\" && !this.styles[lineIndex]) {\n                return true;\n            }\n            var obj = typeof lineIndex === \"undefined\" ? this.styles : {\n                line: this.styles[lineIndex]\n            };\n            for(var p1 in obj){\n                for(var p2 in obj[p1]){\n                    // eslint-disable-next-line no-unused-vars\n                    for(var p3 in obj[p1][p2]){\n                        return false;\n                    }\n                }\n            }\n            return true;\n        },\n        /**\n     * Returns true if object has a style property or has it ina specified line\n     * This function is used to detect if a text will use a particular property or not.\n     * @param {String} property to check for\n     * @param {Number} lineIndex to check the style on\n     * @return {Boolean}\n     */ styleHas: function(property, lineIndex) {\n            if (!this.styles || !property || property === \"\") {\n                return false;\n            }\n            if (typeof lineIndex !== \"undefined\" && !this.styles[lineIndex]) {\n                return false;\n            }\n            var obj = typeof lineIndex === \"undefined\" ? this.styles : {\n                0: this.styles[lineIndex]\n            };\n            // eslint-disable-next-line\n            for(var p1 in obj){\n                // eslint-disable-next-line\n                for(var p2 in obj[p1]){\n                    if (typeof obj[p1][p2][property] !== \"undefined\") {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        /**\n     * Check if characters in a text have a value for a property\n     * whose value matches the textbox's value for that property.  If so,\n     * the character-level property is deleted.  If the character\n     * has no other properties, then it is also deleted.  Finally,\n     * if the line containing that character has no other characters\n     * then it also is deleted.\n     *\n     * @param {string} property The property to compare between characters and text.\n     */ cleanStyle: function(property) {\n            if (!this.styles || !property || property === \"\") {\n                return false;\n            }\n            var obj = this.styles, stylesCount = 0, letterCount, stylePropertyValue, allStyleObjectPropertiesMatch = true, graphemeCount = 0, styleObject;\n            // eslint-disable-next-line\n            for(var p1 in obj){\n                letterCount = 0;\n                // eslint-disable-next-line\n                for(var p2 in obj[p1]){\n                    var styleObject = obj[p1][p2], stylePropertyHasBeenSet = styleObject.hasOwnProperty(property);\n                    stylesCount++;\n                    if (stylePropertyHasBeenSet) {\n                        if (!stylePropertyValue) {\n                            stylePropertyValue = styleObject[property];\n                        } else if (styleObject[property] !== stylePropertyValue) {\n                            allStyleObjectPropertiesMatch = false;\n                        }\n                        if (styleObject[property] === this[property]) {\n                            delete styleObject[property];\n                        }\n                    } else {\n                        allStyleObjectPropertiesMatch = false;\n                    }\n                    if (Object.keys(styleObject).length !== 0) {\n                        letterCount++;\n                    } else {\n                        delete obj[p1][p2];\n                    }\n                }\n                if (letterCount === 0) {\n                    delete obj[p1];\n                }\n            }\n            // if every grapheme has the same style set then\n            // delete those styles and set it on the parent\n            for(var i = 0; i < this._textLines.length; i++){\n                graphemeCount += this._textLines[i].length;\n            }\n            if (allStyleObjectPropertiesMatch && stylesCount === graphemeCount) {\n                this[property] = stylePropertyValue;\n                this.removeStyle(property);\n            }\n        },\n        /**\n     * Remove a style property or properties from all individual character styles\n     * in a text object.  Deletes the character style object if it contains no other style\n     * props.  Deletes a line style object if it contains no other character styles.\n     *\n     * @param {String} props The property to remove from character styles.\n     */ removeStyle: function(property) {\n            if (!this.styles || !property || property === \"\") {\n                return;\n            }\n            var obj = this.styles, line, lineNum, charNum;\n            for(lineNum in obj){\n                line = obj[lineNum];\n                for(charNum in line){\n                    delete line[charNum][property];\n                    if (Object.keys(line[charNum]).length === 0) {\n                        delete line[charNum];\n                    }\n                }\n                if (Object.keys(line).length === 0) {\n                    delete obj[lineNum];\n                }\n            }\n        },\n        /**\n     * @private\n     */ _extendStyles: function(index, styles) {\n            var loc = this.get2DCursorLocation(index);\n            if (!this._getLineStyle(loc.lineIndex)) {\n                this._setLineStyle(loc.lineIndex);\n            }\n            if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {\n                this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});\n            }\n            fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);\n        },\n        /**\n     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)\n     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.\n     * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. useful to manage styles.\n     */ get2DCursorLocation: function(selectionStart, skipWrapping) {\n            if (typeof selectionStart === \"undefined\") {\n                selectionStart = this.selectionStart;\n            }\n            var lines = skipWrapping ? this._unwrappedTextLines : this._textLines, len = lines.length;\n            for(var i = 0; i < len; i++){\n                if (selectionStart <= lines[i].length) {\n                    return {\n                        lineIndex: i,\n                        charIndex: selectionStart\n                    };\n                }\n                selectionStart -= lines[i].length + this.missingNewlineOffset(i);\n            }\n            return {\n                lineIndex: i - 1,\n                charIndex: lines[i - 1].length < selectionStart ? lines[i - 1].length : selectionStart\n            };\n        },\n        /**\n     * Gets style of a current selection/cursor (at the start position)\n     * if startIndex or endIndex are not provided, selectionStart or selectionEnd will be used.\n     * @param {Number} [startIndex] Start index to get styles at\n     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1\n     * @param {Boolean} [complete] get full style or not\n     * @return {Array} styles an array with one, zero or more Style objects\n     */ getSelectionStyles: function(startIndex, endIndex, complete) {\n            if (typeof startIndex === \"undefined\") {\n                startIndex = this.selectionStart || 0;\n            }\n            if (typeof endIndex === \"undefined\") {\n                endIndex = this.selectionEnd || startIndex;\n            }\n            var styles = [];\n            for(var i = startIndex; i < endIndex; i++){\n                styles.push(this.getStyleAtPosition(i, complete));\n            }\n            return styles;\n        },\n        /**\n     * Gets style of a current selection/cursor position\n     * @param {Number} position  to get styles at\n     * @param {Boolean} [complete] full style if true\n     * @return {Object} style Style object at a specified index\n     * @private\n     */ getStyleAtPosition: function(position, complete) {\n            var loc = this.get2DCursorLocation(position), style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) : this._getStyleDeclaration(loc.lineIndex, loc.charIndex);\n            return style || {};\n        },\n        /**\n     * Sets style of a current selection, if no selection exist, do not set anything.\n     * @param {Object} [styles] Styles object\n     * @param {Number} [startIndex] Start index to get styles at\n     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ setSelectionStyles: function(styles, startIndex, endIndex) {\n            if (typeof startIndex === \"undefined\") {\n                startIndex = this.selectionStart || 0;\n            }\n            if (typeof endIndex === \"undefined\") {\n                endIndex = this.selectionEnd || startIndex;\n            }\n            for(var i = startIndex; i < endIndex; i++){\n                this._extendStyles(i, styles);\n            }\n            /* not included in _extendStyles to avoid clearing cache more than once */ this._forceClearCache = true;\n            return this;\n        },\n        /**\n     * get the reference, not a clone, of the style object for a given character\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @return {Object} style object\n     */ _getStyleDeclaration: function(lineIndex, charIndex) {\n            var lineStyle = this.styles && this.styles[lineIndex];\n            if (!lineStyle) {\n                return null;\n            }\n            return lineStyle[charIndex];\n        },\n        /**\n     * return a new object that contains all the style property for a character\n     * the object returned is newly created\n     * @param {Number} lineIndex of the line where the character is\n     * @param {Number} charIndex position of the character on the line\n     * @return {Object} style object\n     */ getCompleteStyleDeclaration: function(lineIndex, charIndex) {\n            var style = this._getStyleDeclaration(lineIndex, charIndex) || {}, styleObject = {}, prop;\n            for(var i = 0; i < this._styleProperties.length; i++){\n                prop = this._styleProperties[i];\n                styleObject[prop] = typeof style[prop] === \"undefined\" ? this[prop] : style[prop];\n            }\n            return styleObject;\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {Object} style\n     * @private\n     */ _setStyleDeclaration: function(lineIndex, charIndex, style) {\n            this.styles[lineIndex][charIndex] = style;\n        },\n        /**\n     *\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */ _deleteStyleDeclaration: function(lineIndex, charIndex) {\n            delete this.styles[lineIndex][charIndex];\n        },\n        /**\n     * @param {Number} lineIndex\n     * @return {Boolean} if the line exists or not\n     * @private\n     */ _getLineStyle: function(lineIndex) {\n            return !!this.styles[lineIndex];\n        },\n        /**\n     * Set the line style to an empty object so that is initialized\n     * @param {Number} lineIndex\n     * @private\n     */ _setLineStyle: function(lineIndex) {\n            this.styles[lineIndex] = {};\n        },\n        /**\n     * @param {Number} lineIndex\n     * @private\n     */ _deleteLineStyle: function(lineIndex) {\n            delete this.styles[lineIndex];\n        }\n    });\n})();\n(function() {\n    function parseDecoration(object) {\n        if (object.textDecoration) {\n            object.textDecoration.indexOf(\"underline\") > -1 && (object.underline = true);\n            object.textDecoration.indexOf(\"line-through\") > -1 && (object.linethrough = true);\n            object.textDecoration.indexOf(\"overline\") > -1 && (object.overline = true);\n            delete object.textDecoration;\n        }\n    }\n    /**\n   * IText class (introduced in <b>v1.4</b>) Events are also fired with \"text:\"\n   * prefix when observing canvas.\n   * @class fabric.IText\n   * @extends fabric.Text\n   * @mixes fabric.Observable\n   *\n   * @fires changed\n   * @fires selection:changed\n   * @fires editing:entered\n   * @fires editing:exited\n   *\n   * @return {fabric.IText} thisArg\n   * @see {@link fabric.IText#initialize} for constructor definition\n   *\n   * <p>Supported key combinations:</p>\n   * <pre>\n   *   Move cursor:                    left, right, up, down\n   *   Select character:               shift + left, shift + right\n   *   Select text vertically:         shift + up, shift + down\n   *   Move cursor by word:            alt + left, alt + right\n   *   Select words:                   shift + alt + left, shift + alt + right\n   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end\n   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end\n   *   Jump to start/end of text:      cmd + up, cmd + down\n   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown\n   *   Delete character:               backspace\n   *   Delete word:                    alt + backspace\n   *   Delete line:                    cmd + backspace\n   *   Forward delete:                 delete\n   *   Copy text:                      ctrl/cmd + c\n   *   Paste text:                     ctrl/cmd + v\n   *   Cut text:                       ctrl/cmd + x\n   *   Select entire text:             ctrl/cmd + a\n   *   Quit editing                    tab or esc\n   * </pre>\n   *\n   * <p>Supported mouse/touch combination</p>\n   * <pre>\n   *   Position cursor:                click/touch\n   *   Create selection:               click/touch & drag\n   *   Create selection:               click & shift + click\n   *   Select word:                    double click\n   *   Select line:                    triple click\n   * </pre>\n   */ fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"i-text\",\n        /**\n     * Index where text selection starts (or where cursor is when there is no selection)\n     * @type Number\n     * @default\n     */ selectionStart: 0,\n        /**\n     * Index where text selection ends\n     * @type Number\n     * @default\n     */ selectionEnd: 0,\n        /**\n     * Color of text selection\n     * @type String\n     * @default\n     */ selectionColor: \"rgba(17,119,255,0.3)\",\n        /**\n     * Indicates whether text is in editing mode\n     * @type Boolean\n     * @default\n     */ isEditing: false,\n        /**\n     * Indicates whether a text can be edited\n     * @type Boolean\n     * @default\n     */ editable: true,\n        /**\n     * Border color of text object while it's in editing mode\n     * @type String\n     * @default\n     */ editingBorderColor: \"rgba(102,153,255,0.25)\",\n        /**\n     * Width of cursor (in px)\n     * @type Number\n     * @default\n     */ cursorWidth: 2,\n        /**\n     * Color of text cursor color in editing mode.\n     * if not set (default) will take color from the text.\n     * if set to a color value that fabric can understand, it will\n     * be used instead of the color of the text at the current position.\n     * @type String\n     * @default\n     */ cursorColor: \"\",\n        /**\n     * Delay between cursor blink (in ms)\n     * @type Number\n     * @default\n     */ cursorDelay: 1000,\n        /**\n     * Duration of cursor fadein (in ms)\n     * @type Number\n     * @default\n     */ cursorDuration: 600,\n        /**\n     * Indicates whether internal text char widths can be cached\n     * @type Boolean\n     * @default\n     */ caching: true,\n        /**\n     * DOM container to append the hiddenTextarea.\n     * An alternative to attaching to the document.body.\n     * Useful to reduce laggish redraw of the full document.body tree and\n     * also with modals event capturing that won't let the textarea take focus.\n     * @type HTMLElement\n     * @default\n     */ hiddenTextareaContainer: null,\n        /**\n     * @private\n     */ _reSpace: /\\s|\\n/,\n        /**\n     * @private\n     */ _currentCursorOpacity: 0,\n        /**\n     * @private\n     */ _selectionDirection: null,\n        /**\n     * @private\n     */ _abortCursorAnimation: false,\n        /**\n     * @private\n     */ __widthOfSpace: [],\n        /**\n     * Helps determining when the text is in composition, so that the cursor\n     * rendering is altered.\n     */ inCompositionMode: false,\n        /**\n     * Constructor\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.IText} thisArg\n     */ initialize: function(text, options) {\n            this.callSuper(\"initialize\", text, options);\n            this.initBehavior();\n        },\n        /**\n     * Sets selection start (left boundary of a selection)\n     * @param {Number} index Index to set selection start to\n     */ setSelectionStart: function(index) {\n            index = Math.max(index, 0);\n            this._updateAndFire(\"selectionStart\", index);\n        },\n        /**\n     * Sets selection end (right boundary of a selection)\n     * @param {Number} index Index to set selection end to\n     */ setSelectionEnd: function(index) {\n            index = Math.min(index, this.text.length);\n            this._updateAndFire(\"selectionEnd\", index);\n        },\n        /**\n     * @private\n     * @param {String} property 'selectionStart' or 'selectionEnd'\n     * @param {Number} index new position of property\n     */ _updateAndFire: function(property, index) {\n            if (this[property] !== index) {\n                this._fireSelectionChanged();\n                this[property] = index;\n            }\n            this._updateTextarea();\n        },\n        /**\n     * Fires the even of selection changed\n     * @private\n     */ _fireSelectionChanged: function() {\n            this.fire(\"selection:changed\");\n            this.canvas && this.canvas.fire(\"text:selection:changed\", {\n                target: this\n            });\n        },\n        /**\n     * Initialize text dimensions. Render all text on given context\n     * or on a offscreen canvas to get the text width with measureText.\n     * Updates this.width and this.height with the proper values.\n     * Does not return dimensions.\n     * @private\n     */ initDimensions: function() {\n            this.isEditing && this.initDelayedCursor();\n            this.clearContextTop();\n            this.callSuper(\"initDimensions\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ render: function(ctx) {\n            this.clearContextTop();\n            this.callSuper(\"render\", ctx);\n            // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor\n            // the correct position but not at every cursor animation.\n            this.cursorOffsetCache = {};\n            this.renderCursorOrSelection();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            this.callSuper(\"_render\", ctx);\n        },\n        /**\n     * Prepare and clean the contextTop\n     */ clearContextTop: function(skipRestore) {\n            if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {\n                return;\n            }\n            var ctx = this.canvas.contextTop, v = this.canvas.viewportTransform;\n            ctx.save();\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            this.transform(ctx);\n            this._clearTextArea(ctx);\n            skipRestore || ctx.restore();\n        },\n        /**\n     * Renders cursor or selection (depending on what exists)\n     * it does on the contextTop. If contextTop is not available, do nothing.\n     */ renderCursorOrSelection: function() {\n            if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {\n                return;\n            }\n            var boundaries = this._getCursorBoundaries(), ctx = this.canvas.contextTop;\n            this.clearContextTop(true);\n            if (this.selectionStart === this.selectionEnd) {\n                this.renderCursor(boundaries, ctx);\n            } else {\n                this.renderSelection(boundaries, ctx);\n            }\n            ctx.restore();\n        },\n        _clearTextArea: function(ctx) {\n            // we add 4 pixel, to be sure to do not leave any pixel out\n            var width = this.width + 4, height = this.height + 4;\n            ctx.clearRect(-width / 2, -height / 2, width, height);\n        },\n        /**\n     * Returns cursor boundaries (left, top, leftOffset, topOffset)\n     * @private\n     * @param {Array} chars Array of characters\n     * @param {String} typeOfBoundaries\n     */ _getCursorBoundaries: function(position) {\n            // left/top are left/top of entire text box\n            // leftOffset/topOffset are offset from that left/top point of a text box\n            if (typeof position === \"undefined\") {\n                position = this.selectionStart;\n            }\n            var left = this._getLeftOffset(), top = this._getTopOffset(), offsets = this._getCursorBoundariesOffsets(position);\n            return {\n                left: left,\n                top: top,\n                leftOffset: offsets.left,\n                topOffset: offsets.top\n            };\n        },\n        /**\n     * @private\n     */ _getCursorBoundariesOffsets: function(position) {\n            if (this.cursorOffsetCache && \"top\" in this.cursorOffsetCache) {\n                return this.cursorOffsetCache;\n            }\n            var lineLeftOffset, lineIndex, charIndex, topOffset = 0, leftOffset = 0, boundaries, cursorPosition = this.get2DCursorLocation(position);\n            charIndex = cursorPosition.charIndex;\n            lineIndex = cursorPosition.lineIndex;\n            for(var i = 0; i < lineIndex; i++){\n                topOffset += this.getHeightOfLine(i);\n            }\n            lineLeftOffset = this._getLineLeftOffset(lineIndex);\n            var bound = this.__charBounds[lineIndex][charIndex];\n            bound && (leftOffset = bound.left);\n            if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {\n                leftOffset -= this._getWidthOfCharSpacing();\n            }\n            boundaries = {\n                top: topOffset,\n                left: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0)\n            };\n            if (this.direction === \"rtl\") {\n                boundaries.left *= -1;\n            }\n            this.cursorOffsetCache = boundaries;\n            return this.cursorOffsetCache;\n        },\n        /**\n     * Renders cursor\n     * @param {Object} boundaries\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\n     */ renderCursor: function(boundaries, ctx) {\n            var cursorLocation = this.get2DCursorLocation(), lineIndex = cursorLocation.lineIndex, charIndex = cursorLocation.charIndex > 0 ? cursorLocation.charIndex - 1 : 0, charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, \"fontSize\"), multiplier = this.scaleX * this.canvas.getZoom(), cursorWidth = this.cursorWidth / multiplier, topOffset = boundaries.topOffset, dy = this.getValueOfPropertyAt(lineIndex, charIndex, \"deltaY\");\n            topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight - charHeight * (1 - this._fontSizeFraction);\n            if (this.inCompositionMode) {\n                this.renderSelection(boundaries, ctx);\n            }\n            ctx.fillStyle = this.cursorColor || this.getValueOfPropertyAt(lineIndex, charIndex, \"fill\");\n            ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;\n            ctx.fillRect(boundaries.left + boundaries.leftOffset - cursorWidth / 2, topOffset + boundaries.top + dy, cursorWidth, charHeight);\n        },\n        /**\n     * Renders text selection\n     * @param {Object} boundaries Object with left/top/leftOffset/topOffset\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\n     */ renderSelection: function(boundaries, ctx) {\n            var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, isJustify = this.textAlign.indexOf(\"justify\") !== -1, start = this.get2DCursorLocation(selectionStart), end = this.get2DCursorLocation(selectionEnd), startLine = start.lineIndex, endLine = end.lineIndex, startChar = start.charIndex < 0 ? 0 : start.charIndex, endChar = end.charIndex < 0 ? 0 : end.charIndex;\n            for(var i = startLine; i <= endLine; i++){\n                var lineOffset = this._getLineLeftOffset(i) || 0, lineHeight = this.getHeightOfLine(i), realLineHeight = 0, boxStart = 0, boxEnd = 0;\n                if (i === startLine) {\n                    boxStart = this.__charBounds[startLine][startChar].left;\n                }\n                if (i >= startLine && i < endLine) {\n                    boxEnd = isJustify && !this.isEndOfWrapping(i) ? this.width : this.getLineWidth(i) || 5; // WTF is this 5?\n                } else if (i === endLine) {\n                    if (endChar === 0) {\n                        boxEnd = this.__charBounds[endLine][endChar].left;\n                    } else {\n                        var charSpacing = this._getWidthOfCharSpacing();\n                        boxEnd = this.__charBounds[endLine][endChar - 1].left + this.__charBounds[endLine][endChar - 1].width - charSpacing;\n                    }\n                }\n                realLineHeight = lineHeight;\n                if (this.lineHeight < 1 || i === endLine && this.lineHeight > 1) {\n                    lineHeight /= this.lineHeight;\n                }\n                var drawStart = boundaries.left + lineOffset + boxStart, drawWidth = boxEnd - boxStart, drawHeight = lineHeight, extraTop = 0;\n                if (this.inCompositionMode) {\n                    ctx.fillStyle = this.compositionColor || \"black\";\n                    drawHeight = 1;\n                    extraTop = lineHeight;\n                } else {\n                    ctx.fillStyle = this.selectionColor;\n                }\n                if (this.direction === \"rtl\") {\n                    drawStart = this.width - drawStart - drawWidth;\n                }\n                ctx.fillRect(drawStart, boundaries.top + boundaries.topOffset + extraTop, drawWidth, drawHeight);\n                boundaries.topOffset += realLineHeight;\n            }\n        },\n        /**\n     * High level function to know the height of the cursor.\n     * the currentChar is the one that precedes the cursor\n     * Returns fontSize of char at the current cursor\n     * Unused from the library, is for the end user\n     * @return {Number} Character font size\n     */ getCurrentCharFontSize: function() {\n            var cp = this._getCurrentCharIndex();\n            return this.getValueOfPropertyAt(cp.l, cp.c, \"fontSize\");\n        },\n        /**\n     * High level function to know the color of the cursor.\n     * the currentChar is the one that precedes the cursor\n     * Returns color (fill) of char at the current cursor\n     * if the text object has a pattern or gradient for filler, it will return that.\n     * Unused by the library, is for the end user\n     * @return {String | fabric.Gradient | fabric.Pattern} Character color (fill)\n     */ getCurrentCharColor: function() {\n            var cp = this._getCurrentCharIndex();\n            return this.getValueOfPropertyAt(cp.l, cp.c, \"fill\");\n        },\n        /**\n     * Returns the cursor position for the getCurrent.. functions\n     * @private\n     */ _getCurrentCharIndex: function() {\n            var cursorPosition = this.get2DCursorLocation(this.selectionStart, true), charIndex = cursorPosition.charIndex > 0 ? cursorPosition.charIndex - 1 : 0;\n            return {\n                l: cursorPosition.lineIndex,\n                c: charIndex\n            };\n        }\n    });\n    /**\n   * Returns fabric.IText instance from an object representation\n   * @static\n   * @memberOf fabric.IText\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as argument\n   */ fabric.IText.fromObject = function(object, callback) {\n        var styles = fabric.util.stylesFromArray(object.styles, object.text);\n        //copy object to prevent mutation\n        var objCopy = Object.assign({}, object, {\n            styles: styles\n        });\n        parseDecoration(objCopy);\n        if (objCopy.styles) {\n            for(var i in objCopy.styles){\n                for(var j in objCopy.styles[i]){\n                    parseDecoration(objCopy.styles[i][j]);\n                }\n            }\n        }\n        fabric.Object._fromObject(\"IText\", objCopy, callback, \"text\");\n    };\n})();\n(function() {\n    var clone = fabric.util.object.clone;\n    fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\n        /**\n     * Initializes all the interactive behavior of IText\n     */ initBehavior: function() {\n            this.initAddedHandler();\n            this.initRemovedHandler();\n            this.initCursorSelectionHandlers();\n            this.initDoubleClickSimulation();\n            this.mouseMoveHandler = this.mouseMoveHandler.bind(this);\n        },\n        onDeselect: function() {\n            this.isEditing && this.exitEditing();\n            this.selected = false;\n        },\n        /**\n     * Initializes \"added\" event handler\n     */ initAddedHandler: function() {\n            var _this = this;\n            this.on(\"added\", function() {\n                var canvas = _this.canvas;\n                if (canvas) {\n                    if (!canvas._hasITextHandlers) {\n                        canvas._hasITextHandlers = true;\n                        _this._initCanvasHandlers(canvas);\n                    }\n                    canvas._iTextInstances = canvas._iTextInstances || [];\n                    canvas._iTextInstances.push(_this);\n                }\n            });\n        },\n        initRemovedHandler: function() {\n            var _this = this;\n            this.on(\"removed\", function() {\n                var canvas = _this.canvas;\n                if (canvas) {\n                    canvas._iTextInstances = canvas._iTextInstances || [];\n                    fabric.util.removeFromArray(canvas._iTextInstances, _this);\n                    if (canvas._iTextInstances.length === 0) {\n                        canvas._hasITextHandlers = false;\n                        _this._removeCanvasHandlers(canvas);\n                    }\n                }\n            });\n        },\n        /**\n     * register canvas event to manage exiting on other instances\n     * @private\n     */ _initCanvasHandlers: function(canvas) {\n            canvas._mouseUpITextHandler = function() {\n                if (canvas._iTextInstances) {\n                    canvas._iTextInstances.forEach(function(obj) {\n                        obj.__isMousedown = false;\n                    });\n                }\n            };\n            canvas.on(\"mouse:up\", canvas._mouseUpITextHandler);\n        },\n        /**\n     * remove canvas event to manage exiting on other instances\n     * @private\n     */ _removeCanvasHandlers: function(canvas) {\n            canvas.off(\"mouse:up\", canvas._mouseUpITextHandler);\n        },\n        /**\n     * @private\n     */ _tick: function() {\n            this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, \"_onTickComplete\");\n        },\n        /**\n     * @private\n     */ _animateCursor: function(obj, targetOpacity, duration, completeMethod) {\n            var tickState;\n            tickState = {\n                isAborted: false,\n                abort: function() {\n                    this.isAborted = true;\n                }\n            };\n            obj.animate(\"_currentCursorOpacity\", targetOpacity, {\n                duration: duration,\n                onComplete: function() {\n                    if (!tickState.isAborted) {\n                        obj[completeMethod]();\n                    }\n                },\n                onChange: function() {\n                    // we do not want to animate a selection, only cursor\n                    if (obj.canvas && obj.selectionStart === obj.selectionEnd) {\n                        obj.renderCursorOrSelection();\n                    }\n                },\n                abort: function() {\n                    return tickState.isAborted;\n                }\n            });\n            return tickState;\n        },\n        /**\n     * @private\n     */ _onTickComplete: function() {\n            var _this = this;\n            if (this._cursorTimeout1) {\n                clearTimeout(this._cursorTimeout1);\n            }\n            this._cursorTimeout1 = setTimeout(function() {\n                _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, \"_tick\");\n            }, 100);\n        },\n        /**\n     * Initializes delayed cursor\n     */ initDelayedCursor: function(restart) {\n            var _this = this, delay = restart ? 0 : this.cursorDelay;\n            this.abortCursorAnimation();\n            this._currentCursorOpacity = 1;\n            this._cursorTimeout2 = setTimeout(function() {\n                _this._tick();\n            }, delay);\n        },\n        /**\n     * Aborts cursor animation and clears all timeouts\n     */ abortCursorAnimation: function() {\n            var shouldClear = this._currentTickState || this._currentTickCompleteState, canvas = this.canvas;\n            this._currentTickState && this._currentTickState.abort();\n            this._currentTickCompleteState && this._currentTickCompleteState.abort();\n            clearTimeout(this._cursorTimeout1);\n            clearTimeout(this._cursorTimeout2);\n            this._currentCursorOpacity = 0;\n            // to clear just itext area we need to transform the context\n            // it may not be worth it\n            if (shouldClear && canvas) {\n                canvas.clearContext(canvas.contextTop || canvas.contextContainer);\n            }\n        },\n        /**\n     * Selects entire text\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ selectAll: function() {\n            this.selectionStart = 0;\n            this.selectionEnd = this._text.length;\n            this._fireSelectionChanged();\n            this._updateTextarea();\n            return this;\n        },\n        /**\n     * Returns selected text\n     * @return {String}\n     */ getSelectedText: function() {\n            return this._text.slice(this.selectionStart, this.selectionEnd).join(\"\");\n        },\n        /**\n     * Find new selection index representing start of current word according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findWordBoundaryLeft: function(startFrom) {\n            var offset = 0, index = startFrom - 1;\n            // remove space before cursor first\n            if (this._reSpace.test(this._text[index])) {\n                while(this._reSpace.test(this._text[index])){\n                    offset++;\n                    index--;\n                }\n            }\n            while(/\\S/.test(this._text[index]) && index > -1){\n                offset++;\n                index--;\n            }\n            return startFrom - offset;\n        },\n        /**\n     * Find new selection index representing end of current word according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findWordBoundaryRight: function(startFrom) {\n            var offset = 0, index = startFrom;\n            // remove space after cursor first\n            if (this._reSpace.test(this._text[index])) {\n                while(this._reSpace.test(this._text[index])){\n                    offset++;\n                    index++;\n                }\n            }\n            while(/\\S/.test(this._text[index]) && index < this._text.length){\n                offset++;\n                index++;\n            }\n            return startFrom + offset;\n        },\n        /**\n     * Find new selection index representing start of current line according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findLineBoundaryLeft: function(startFrom) {\n            var offset = 0, index = startFrom - 1;\n            while(!/\\n/.test(this._text[index]) && index > -1){\n                offset++;\n                index--;\n            }\n            return startFrom - offset;\n        },\n        /**\n     * Find new selection index representing end of current line according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findLineBoundaryRight: function(startFrom) {\n            var offset = 0, index = startFrom;\n            while(!/\\n/.test(this._text[index]) && index < this._text.length){\n                offset++;\n                index++;\n            }\n            return startFrom + offset;\n        },\n        /**\n     * Finds index corresponding to beginning or end of a word\n     * @param {Number} selectionStart Index of a character\n     * @param {Number} direction 1 or -1\n     * @return {Number} Index of the beginning or end of a word\n     */ searchWordBoundary: function(selectionStart, direction) {\n            var text = this._text, index = this._reSpace.test(text[selectionStart]) ? selectionStart - 1 : selectionStart, _char = text[index], // wrong\n            reNonWord = fabric.reNonWord;\n            while(!reNonWord.test(_char) && index > 0 && index < text.length){\n                index += direction;\n                _char = text[index];\n            }\n            if (reNonWord.test(_char)) {\n                index += direction === 1 ? 0 : 1;\n            }\n            return index;\n        },\n        /**\n     * Selects a word based on the index\n     * @param {Number} selectionStart Index of a character\n     */ selectWord: function(selectionStart) {\n            selectionStart = selectionStart || this.selectionStart;\n            var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */ newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */ \n            this.selectionStart = newSelectionStart;\n            this.selectionEnd = newSelectionEnd;\n            this._fireSelectionChanged();\n            this._updateTextarea();\n            this.renderCursorOrSelection();\n        },\n        /**\n     * Selects a line based on the index\n     * @param {Number} selectionStart Index of a character\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ selectLine: function(selectionStart) {\n            selectionStart = selectionStart || this.selectionStart;\n            var newSelectionStart = this.findLineBoundaryLeft(selectionStart), newSelectionEnd = this.findLineBoundaryRight(selectionStart);\n            this.selectionStart = newSelectionStart;\n            this.selectionEnd = newSelectionEnd;\n            this._fireSelectionChanged();\n            this._updateTextarea();\n            return this;\n        },\n        /**\n     * Enters editing state\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ enterEditing: function(e) {\n            if (this.isEditing || !this.editable) {\n                return;\n            }\n            if (this.canvas) {\n                this.canvas.calcOffset();\n                this.exitEditingOnOthers(this.canvas);\n            }\n            this.isEditing = true;\n            this.initHiddenTextarea(e);\n            this.hiddenTextarea.focus();\n            this.hiddenTextarea.value = this.text;\n            this._updateTextarea();\n            this._saveEditingProps();\n            this._setEditingProps();\n            this._textBeforeEdit = this.text;\n            this._tick();\n            this.fire(\"editing:entered\");\n            this._fireSelectionChanged();\n            if (!this.canvas) {\n                return this;\n            }\n            this.canvas.fire(\"text:editing:entered\", {\n                target: this\n            });\n            this.initMouseMoveHandler();\n            this.canvas.requestRenderAll();\n            return this;\n        },\n        exitEditingOnOthers: function(canvas) {\n            if (canvas._iTextInstances) {\n                canvas._iTextInstances.forEach(function(obj) {\n                    obj.selected = false;\n                    if (obj.isEditing) {\n                        obj.exitEditing();\n                    }\n                });\n            }\n        },\n        /**\n     * Initializes \"mousemove\" event handler\n     */ initMouseMoveHandler: function() {\n            this.canvas.on(\"mouse:move\", this.mouseMoveHandler);\n        },\n        /**\n     * @private\n     */ mouseMoveHandler: function(options) {\n            if (!this.__isMousedown || !this.isEditing) {\n                return;\n            }\n            // regain focus\n            document.activeElement !== this.hiddenTextarea && this.hiddenTextarea.focus();\n            var newSelectionStart = this.getSelectionStartFromPointer(options.e), currentStart = this.selectionStart, currentEnd = this.selectionEnd;\n            if ((newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd) && (currentStart === newSelectionStart || currentEnd === newSelectionStart)) {\n                return;\n            }\n            if (newSelectionStart > this.__selectionStartOnMouseDown) {\n                this.selectionStart = this.__selectionStartOnMouseDown;\n                this.selectionEnd = newSelectionStart;\n            } else {\n                this.selectionStart = newSelectionStart;\n                this.selectionEnd = this.__selectionStartOnMouseDown;\n            }\n            if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {\n                this.restartCursorIfNeeded();\n                this._fireSelectionChanged();\n                this._updateTextarea();\n                this.renderCursorOrSelection();\n            }\n        },\n        /**\n     * @private\n     */ _setEditingProps: function() {\n            this.hoverCursor = \"text\";\n            if (this.canvas) {\n                this.canvas.defaultCursor = this.canvas.moveCursor = \"text\";\n            }\n            this.borderColor = this.editingBorderColor;\n            this.hasControls = this.selectable = false;\n            this.lockMovementX = this.lockMovementY = true;\n        },\n        /**\n     * convert from textarea to grapheme indexes\n     */ fromStringToGraphemeSelection: function(start, end, text) {\n            var smallerTextStart = text.slice(0, start), graphemeStart = fabric.util.string.graphemeSplit(smallerTextStart).length;\n            if (start === end) {\n                return {\n                    selectionStart: graphemeStart,\n                    selectionEnd: graphemeStart\n                };\n            }\n            var smallerTextEnd = text.slice(start, end), graphemeEnd = fabric.util.string.graphemeSplit(smallerTextEnd).length;\n            return {\n                selectionStart: graphemeStart,\n                selectionEnd: graphemeStart + graphemeEnd\n            };\n        },\n        /**\n     * convert from fabric to textarea values\n     */ fromGraphemeToStringSelection: function(start, end, _text) {\n            var smallerTextStart = _text.slice(0, start), graphemeStart = smallerTextStart.join(\"\").length;\n            if (start === end) {\n                return {\n                    selectionStart: graphemeStart,\n                    selectionEnd: graphemeStart\n                };\n            }\n            var smallerTextEnd = _text.slice(start, end), graphemeEnd = smallerTextEnd.join(\"\").length;\n            return {\n                selectionStart: graphemeStart,\n                selectionEnd: graphemeStart + graphemeEnd\n            };\n        },\n        /**\n     * @private\n     */ _updateTextarea: function() {\n            this.cursorOffsetCache = {};\n            if (!this.hiddenTextarea) {\n                return;\n            }\n            if (!this.inCompositionMode) {\n                var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);\n                this.hiddenTextarea.selectionStart = newSelection.selectionStart;\n                this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;\n            }\n            this.updateTextareaPosition();\n        },\n        /**\n     * @private\n     */ updateFromTextArea: function() {\n            if (!this.hiddenTextarea) {\n                return;\n            }\n            this.cursorOffsetCache = {};\n            this.text = this.hiddenTextarea.value;\n            if (this._shouldClearDimensionCache()) {\n                this.initDimensions();\n                this.setCoords();\n            }\n            var newSelection = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);\n            this.selectionEnd = this.selectionStart = newSelection.selectionEnd;\n            if (!this.inCompositionMode) {\n                this.selectionStart = newSelection.selectionStart;\n            }\n            this.updateTextareaPosition();\n        },\n        /**\n     * @private\n     */ updateTextareaPosition: function() {\n            if (this.selectionStart === this.selectionEnd) {\n                var style = this._calcTextareaPosition();\n                this.hiddenTextarea.style.left = style.left;\n                this.hiddenTextarea.style.top = style.top;\n            }\n        },\n        /**\n     * @private\n     * @return {Object} style contains style for hiddenTextarea\n     */ _calcTextareaPosition: function() {\n            if (!this.canvas) {\n                return {\n                    x: 1,\n                    y: 1\n                };\n            }\n            var desiredPosition = this.inCompositionMode ? this.compositionStart : this.selectionStart, boundaries = this._getCursorBoundaries(desiredPosition), cursorLocation = this.get2DCursorLocation(desiredPosition), lineIndex = cursorLocation.lineIndex, charIndex = cursorLocation.charIndex, charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, \"fontSize\") * this.lineHeight, leftOffset = boundaries.leftOffset, m = this.calcTransformMatrix(), p = {\n                x: boundaries.left + leftOffset,\n                y: boundaries.top + boundaries.topOffset + charHeight\n            }, retinaScaling = this.canvas.getRetinaScaling(), upperCanvas = this.canvas.upperCanvasEl, upperCanvasWidth = upperCanvas.width / retinaScaling, upperCanvasHeight = upperCanvas.height / retinaScaling, maxWidth = upperCanvasWidth - charHeight, maxHeight = upperCanvasHeight - charHeight, scaleX = upperCanvas.clientWidth / upperCanvasWidth, scaleY = upperCanvas.clientHeight / upperCanvasHeight;\n            p = fabric.util.transformPoint(p, m);\n            p = fabric.util.transformPoint(p, this.canvas.viewportTransform);\n            p.x *= scaleX;\n            p.y *= scaleY;\n            if (p.x < 0) {\n                p.x = 0;\n            }\n            if (p.x > maxWidth) {\n                p.x = maxWidth;\n            }\n            if (p.y < 0) {\n                p.y = 0;\n            }\n            if (p.y > maxHeight) {\n                p.y = maxHeight;\n            }\n            // add canvas offset on document\n            p.x += this.canvas._offset.left;\n            p.y += this.canvas._offset.top;\n            return {\n                left: p.x + \"px\",\n                top: p.y + \"px\",\n                fontSize: charHeight + \"px\",\n                charHeight: charHeight\n            };\n        },\n        /**\n     * @private\n     */ _saveEditingProps: function() {\n            this._savedProps = {\n                hasControls: this.hasControls,\n                borderColor: this.borderColor,\n                lockMovementX: this.lockMovementX,\n                lockMovementY: this.lockMovementY,\n                hoverCursor: this.hoverCursor,\n                selectable: this.selectable,\n                defaultCursor: this.canvas && this.canvas.defaultCursor,\n                moveCursor: this.canvas && this.canvas.moveCursor\n            };\n        },\n        /**\n     * @private\n     */ _restoreEditingProps: function() {\n            if (!this._savedProps) {\n                return;\n            }\n            this.hoverCursor = this._savedProps.hoverCursor;\n            this.hasControls = this._savedProps.hasControls;\n            this.borderColor = this._savedProps.borderColor;\n            this.selectable = this._savedProps.selectable;\n            this.lockMovementX = this._savedProps.lockMovementX;\n            this.lockMovementY = this._savedProps.lockMovementY;\n            if (this.canvas) {\n                this.canvas.defaultCursor = this._savedProps.defaultCursor;\n                this.canvas.moveCursor = this._savedProps.moveCursor;\n            }\n        },\n        /**\n     * Exits from editing state\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ exitEditing: function() {\n            var isTextChanged = this._textBeforeEdit !== this.text;\n            var hiddenTextarea = this.hiddenTextarea;\n            this.selected = false;\n            this.isEditing = false;\n            this.selectionEnd = this.selectionStart;\n            if (hiddenTextarea) {\n                hiddenTextarea.blur && hiddenTextarea.blur();\n                hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);\n            }\n            this.hiddenTextarea = null;\n            this.abortCursorAnimation();\n            this._restoreEditingProps();\n            this._currentCursorOpacity = 0;\n            if (this._shouldClearDimensionCache()) {\n                this.initDimensions();\n                this.setCoords();\n            }\n            this.fire(\"editing:exited\");\n            isTextChanged && this.fire(\"modified\");\n            if (this.canvas) {\n                this.canvas.off(\"mouse:move\", this.mouseMoveHandler);\n                this.canvas.fire(\"text:editing:exited\", {\n                    target: this\n                });\n                isTextChanged && this.canvas.fire(\"object:modified\", {\n                    target: this\n                });\n            }\n            return this;\n        },\n        /**\n     * @private\n     */ _removeExtraneousStyles: function() {\n            for(var prop in this.styles){\n                if (!this._textLines[prop]) {\n                    delete this.styles[prop];\n                }\n            }\n        },\n        /**\n     * remove and reflow a style block from start to end.\n     * @param {Number} start linear start position for removal (included in removal)\n     * @param {Number} end linear end position for removal ( excluded from removal )\n     */ removeStyleFromTo: function(start, end) {\n            var cursorStart = this.get2DCursorLocation(start, true), cursorEnd = this.get2DCursorLocation(end, true), lineStart = cursorStart.lineIndex, charStart = cursorStart.charIndex, lineEnd = cursorEnd.lineIndex, charEnd = cursorEnd.charIndex, i, styleObj;\n            if (lineStart !== lineEnd) {\n                // step1 remove the trailing of lineStart\n                if (this.styles[lineStart]) {\n                    for(i = charStart; i < this._unwrappedTextLines[lineStart].length; i++){\n                        delete this.styles[lineStart][i];\n                    }\n                }\n                // step2 move the trailing of lineEnd to lineStart if needed\n                if (this.styles[lineEnd]) {\n                    for(i = charEnd; i < this._unwrappedTextLines[lineEnd].length; i++){\n                        styleObj = this.styles[lineEnd][i];\n                        if (styleObj) {\n                            this.styles[lineStart] || (this.styles[lineStart] = {});\n                            this.styles[lineStart][charStart + i - charEnd] = styleObj;\n                        }\n                    }\n                }\n                // step3 detects lines will be completely removed.\n                for(i = lineStart + 1; i <= lineEnd; i++){\n                    delete this.styles[i];\n                }\n                // step4 shift remaining lines.\n                this.shiftLineStyles(lineEnd, lineStart - lineEnd);\n            } else {\n                // remove and shift left on the same line\n                if (this.styles[lineStart]) {\n                    styleObj = this.styles[lineStart];\n                    var diff = charEnd - charStart, numericChar, _char;\n                    for(i = charStart; i < charEnd; i++){\n                        delete styleObj[i];\n                    }\n                    for(_char in this.styles[lineStart]){\n                        numericChar = parseInt(_char, 10);\n                        if (numericChar >= charEnd) {\n                            styleObj[numericChar - diff] = styleObj[_char];\n                            delete styleObj[_char];\n                        }\n                    }\n                }\n            }\n        },\n        /**\n     * Shifts line styles up or down\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} offset Can any number?\n     */ shiftLineStyles: function(lineIndex, offset) {\n            // shift all line styles by offset upward or downward\n            // do not clone deep. we need new array, not new style objects\n            var clonedStyles = clone(this.styles);\n            for(var line in this.styles){\n                var numericLine = parseInt(line, 10);\n                if (numericLine > lineIndex) {\n                    this.styles[numericLine + offset] = clonedStyles[numericLine];\n                    if (!clonedStyles[numericLine - offset]) {\n                        delete this.styles[numericLine];\n                    }\n                }\n            }\n        },\n        restartCursorIfNeeded: function() {\n            if (!this._currentTickState || this._currentTickState.isAborted || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted) {\n                this.initDelayedCursor();\n            }\n        },\n        /**\n     * Handle insertion of more consecutive style lines for when one or more\n     * newlines gets added to the text. Since current style needs to be shifted\n     * first we shift the current style of the number lines needed, then we add\n     * new lines from the last to the first.\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} charIndex Index of a char\n     * @param {Number} qty number of lines to add\n     * @param {Array} copiedStyle Array of objects styles\n     */ insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {\n            var currentCharStyle, newLineStyles = {}, somethingAdded = false, isEndOfLine = this._unwrappedTextLines[lineIndex].length === charIndex;\n            qty || (qty = 1);\n            this.shiftLineStyles(lineIndex, qty);\n            if (this.styles[lineIndex]) {\n                currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];\n            }\n            // we clone styles of all chars\n            // after cursor onto the current line\n            for(var index in this.styles[lineIndex]){\n                var numIndex = parseInt(index, 10);\n                if (numIndex >= charIndex) {\n                    somethingAdded = true;\n                    newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index];\n                    // remove lines from the previous line since they're on a new line now\n                    if (!(isEndOfLine && charIndex === 0)) {\n                        delete this.styles[lineIndex][index];\n                    }\n                }\n            }\n            var styleCarriedOver = false;\n            if (somethingAdded && !isEndOfLine) {\n                // if is end of line, the extra style we copied\n                // is probably not something we want\n                this.styles[lineIndex + qty] = newLineStyles;\n                styleCarriedOver = true;\n            }\n            if (styleCarriedOver) {\n                // skip the last line of since we already prepared it.\n                qty--;\n            }\n            // for the all the lines or all the other lines\n            // we clone current char style onto the next (otherwise empty) line\n            while(qty > 0){\n                if (copiedStyle && copiedStyle[qty - 1]) {\n                    this.styles[lineIndex + qty] = {\n                        0: clone(copiedStyle[qty - 1])\n                    };\n                } else if (currentCharStyle) {\n                    this.styles[lineIndex + qty] = {\n                        0: clone(currentCharStyle)\n                    };\n                } else {\n                    delete this.styles[lineIndex + qty];\n                }\n                qty--;\n            }\n            this._forceClearCache = true;\n        },\n        /**\n     * Inserts style object for a given line/char index\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} charIndex Index of a char\n     * @param {Number} quantity number Style object to insert, if given\n     * @param {Array} copiedStyle array of style objects\n     */ insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {\n            if (!this.styles) {\n                this.styles = {};\n            }\n            var currentLineStyles = this.styles[lineIndex], currentLineStylesCloned = currentLineStyles ? clone(currentLineStyles) : {};\n            quantity || (quantity = 1);\n            // shift all char styles by quantity forward\n            // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4\n            for(var index in currentLineStylesCloned){\n                var numericIndex = parseInt(index, 10);\n                if (numericIndex >= charIndex) {\n                    currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];\n                    // only delete the style if there was nothing moved there\n                    if (!currentLineStylesCloned[numericIndex - quantity]) {\n                        delete currentLineStyles[numericIndex];\n                    }\n                }\n            }\n            this._forceClearCache = true;\n            if (copiedStyle) {\n                while(quantity--){\n                    if (!Object.keys(copiedStyle[quantity]).length) {\n                        continue;\n                    }\n                    if (!this.styles[lineIndex]) {\n                        this.styles[lineIndex] = {};\n                    }\n                    this.styles[lineIndex][charIndex + quantity] = clone(copiedStyle[quantity]);\n                }\n                return;\n            }\n            if (!currentLineStyles) {\n                return;\n            }\n            var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];\n            while(newStyle && quantity--){\n                this.styles[lineIndex][charIndex + quantity] = clone(newStyle);\n            }\n        },\n        /**\n     * Inserts style object(s)\n     * @param {Array} insertedText Characters at the location where style is inserted\n     * @param {Number} start cursor index for inserting style\n     * @param {Array} [copiedStyle] array of style objects to insert.\n     */ insertNewStyleBlock: function(insertedText, start, copiedStyle) {\n            var cursorLoc = this.get2DCursorLocation(start, true), addedLines = [\n                0\n            ], linesLength = 0;\n            // get an array of how many char per lines are being added.\n            for(var i = 0; i < insertedText.length; i++){\n                if (insertedText[i] === \"\\n\") {\n                    linesLength++;\n                    addedLines[linesLength] = 0;\n                } else {\n                    addedLines[linesLength]++;\n                }\n            }\n            // for the first line copy the style from the current char position.\n            if (addedLines[0] > 0) {\n                this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);\n                copiedStyle = copiedStyle && copiedStyle.slice(addedLines[0] + 1);\n            }\n            linesLength && this.insertNewlineStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex + addedLines[0], linesLength);\n            for(var i = 1; i < linesLength; i++){\n                if (addedLines[i] > 0) {\n                    this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);\n                } else if (copiedStyle) {\n                    // this test is required in order to close #6841\n                    // when a pasted buffer begins with a newline then\n                    // this.styles[cursorLoc.lineIndex + i] and copiedStyle[0]\n                    // may be undefined for some reason\n                    if (this.styles[cursorLoc.lineIndex + i] && copiedStyle[0]) {\n                        this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];\n                    }\n                }\n                copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i] + 1);\n            }\n            // we use i outside the loop to get it like linesLength\n            if (addedLines[i] > 0) {\n                this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);\n            }\n        },\n        /**\n     * Set the selectionStart and selectionEnd according to the new position of cursor\n     * mimic the key - mouse navigation when shift is pressed.\n     */ setSelectionStartEndWithShift: function(start, end, newSelection) {\n            if (newSelection <= start) {\n                if (end === start) {\n                    this._selectionDirection = \"left\";\n                } else if (this._selectionDirection === \"right\") {\n                    this._selectionDirection = \"left\";\n                    this.selectionEnd = start;\n                }\n                this.selectionStart = newSelection;\n            } else if (newSelection > start && newSelection < end) {\n                if (this._selectionDirection === \"right\") {\n                    this.selectionEnd = newSelection;\n                } else {\n                    this.selectionStart = newSelection;\n                }\n            } else {\n                // newSelection is > selection start and end\n                if (end === start) {\n                    this._selectionDirection = \"right\";\n                } else if (this._selectionDirection === \"left\") {\n                    this._selectionDirection = \"right\";\n                    this.selectionStart = end;\n                }\n                this.selectionEnd = newSelection;\n            }\n        },\n        setSelectionInBoundaries: function() {\n            var length = this.text.length;\n            if (this.selectionStart > length) {\n                this.selectionStart = length;\n            } else if (this.selectionStart < 0) {\n                this.selectionStart = 0;\n            }\n            if (this.selectionEnd > length) {\n                this.selectionEnd = length;\n            } else if (this.selectionEnd < 0) {\n                this.selectionEnd = 0;\n            }\n        }\n    });\n})();\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\n    /**\n   * Initializes \"dbclick\" event handler\n   */ initDoubleClickSimulation: function() {\n        // for double click\n        this.__lastClickTime = +new Date();\n        // for triple click\n        this.__lastLastClickTime = +new Date();\n        this.__lastPointer = {};\n        this.on(\"mousedown\", this.onMouseDown);\n    },\n    /**\n   * Default event handler to simulate triple click\n   * @private\n   */ onMouseDown: function(options) {\n        if (!this.canvas) {\n            return;\n        }\n        this.__newClickTime = +new Date();\n        var newPointer = options.pointer;\n        if (this.isTripleClick(newPointer)) {\n            this.fire(\"tripleclick\", options);\n            this._stopEvent(options.e);\n        }\n        this.__lastLastClickTime = this.__lastClickTime;\n        this.__lastClickTime = this.__newClickTime;\n        this.__lastPointer = newPointer;\n        this.__lastIsEditing = this.isEditing;\n        this.__lastSelected = this.selected;\n    },\n    isTripleClick: function(newPointer) {\n        return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === newPointer.x && this.__lastPointer.y === newPointer.y;\n    },\n    /**\n   * @private\n   */ _stopEvent: function(e) {\n        e.preventDefault && e.preventDefault();\n        e.stopPropagation && e.stopPropagation();\n    },\n    /**\n   * Initializes event handlers related to cursor or selection\n   */ initCursorSelectionHandlers: function() {\n        this.initMousedownHandler();\n        this.initMouseupHandler();\n        this.initClicks();\n    },\n    /**\n   * Default handler for double click, select a word\n   */ doubleClickHandler: function(options) {\n        if (!this.isEditing) {\n            return;\n        }\n        this.selectWord(this.getSelectionStartFromPointer(options.e));\n    },\n    /**\n   * Default handler for triple click, select a line\n   */ tripleClickHandler: function(options) {\n        if (!this.isEditing) {\n            return;\n        }\n        this.selectLine(this.getSelectionStartFromPointer(options.e));\n    },\n    /**\n   * Initializes double and triple click event handlers\n   */ initClicks: function() {\n        this.on(\"mousedblclick\", this.doubleClickHandler);\n        this.on(\"tripleclick\", this.tripleClickHandler);\n    },\n    /**\n   * Default event handler for the basic functionalities needed on _mouseDown\n   * can be overridden to do something different.\n   * Scope of this implementation is: find the click position, set selectionStart\n   * find selectionEnd, initialize the drawing of either cursor or selection area\n   * initializing a mousedDown on a text area will cancel fabricjs knowledge of\n   * current compositionMode. It will be set to false.\n   */ _mouseDownHandler: function(options) {\n        if (!this.canvas || !this.editable || options.e.button && options.e.button !== 1) {\n            return;\n        }\n        this.__isMousedown = true;\n        if (this.selected) {\n            this.inCompositionMode = false;\n            this.setCursorByClick(options.e);\n        }\n        if (this.isEditing) {\n            this.__selectionStartOnMouseDown = this.selectionStart;\n            if (this.selectionStart === this.selectionEnd) {\n                this.abortCursorAnimation();\n            }\n            this.renderCursorOrSelection();\n        }\n    },\n    /**\n   * Default event handler for the basic functionalities needed on mousedown:before\n   * can be overridden to do something different.\n   * Scope of this implementation is: verify the object is already selected when mousing down\n   */ _mouseDownHandlerBefore: function(options) {\n        if (!this.canvas || !this.editable || options.e.button && options.e.button !== 1) {\n            return;\n        }\n        // we want to avoid that an object that was selected and then becomes unselectable,\n        // may trigger editing mode in some way.\n        this.selected = this === this.canvas._activeObject;\n    },\n    /**\n   * Initializes \"mousedown\" event handler\n   */ initMousedownHandler: function() {\n        this.on(\"mousedown\", this._mouseDownHandler);\n        this.on(\"mousedown:before\", this._mouseDownHandlerBefore);\n    },\n    /**\n   * Initializes \"mouseup\" event handler\n   */ initMouseupHandler: function() {\n        this.on(\"mouseup\", this.mouseUpHandler);\n    },\n    /**\n   * standard handler for mouse up, overridable\n   * @private\n   */ mouseUpHandler: function(options) {\n        this.__isMousedown = false;\n        if (!this.editable || this.group || options.transform && options.transform.actionPerformed || options.e.button && options.e.button !== 1) {\n            return;\n        }\n        if (this.canvas) {\n            var currentActive = this.canvas._activeObject;\n            if (currentActive && currentActive !== this) {\n                // avoid running this logic when there is an active object\n                // this because is possible with shift click and fast clicks,\n                // to rapidly deselect and reselect this object and trigger an enterEdit\n                return;\n            }\n        }\n        if (this.__lastSelected && !this.__corner) {\n            this.selected = false;\n            this.__lastSelected = false;\n            this.enterEditing(options.e);\n            if (this.selectionStart === this.selectionEnd) {\n                this.initDelayedCursor(true);\n            } else {\n                this.renderCursorOrSelection();\n            }\n        } else {\n            this.selected = true;\n        }\n    },\n    /**\n   * Changes cursor location in a text depending on passed pointer (x/y) object\n   * @param {Event} e Event object\n   */ setCursorByClick: function(e) {\n        var newSelection = this.getSelectionStartFromPointer(e), start = this.selectionStart, end = this.selectionEnd;\n        if (e.shiftKey) {\n            this.setSelectionStartEndWithShift(start, end, newSelection);\n        } else {\n            this.selectionStart = newSelection;\n            this.selectionEnd = newSelection;\n        }\n        if (this.isEditing) {\n            this._fireSelectionChanged();\n            this._updateTextarea();\n        }\n    },\n    /**\n   * Returns index of a character corresponding to where an object was clicked\n   * @param {Event} e Event object\n   * @return {Number} Index of a character\n   */ getSelectionStartFromPointer: function(e) {\n        var mouseOffset = this.getLocalPointer(e), prevWidth = 0, width = 0, height = 0, charIndex = 0, lineIndex = 0, lineLeftOffset, line;\n        for(var i = 0, len = this._textLines.length; i < len; i++){\n            if (height <= mouseOffset.y) {\n                height += this.getHeightOfLine(i) * this.scaleY;\n                lineIndex = i;\n                if (i > 0) {\n                    charIndex += this._textLines[i - 1].length + this.missingNewlineOffset(i - 1);\n                }\n            } else {\n                break;\n            }\n        }\n        lineLeftOffset = this._getLineLeftOffset(lineIndex);\n        width = lineLeftOffset * this.scaleX;\n        line = this._textLines[lineIndex];\n        // handling of RTL: in order to get things work correctly,\n        // we assume RTL writing is mirrored compared to LTR writing.\n        // so in position detection we mirror the X offset, and when is time\n        // of rendering it, we mirror it again.\n        if (this.direction === \"rtl\") {\n            mouseOffset.x = this.width * this.scaleX - mouseOffset.x + width;\n        }\n        for(var j = 0, jlen = line.length; j < jlen; j++){\n            prevWidth = width;\n            // i removed something about flipX here, check.\n            width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;\n            if (width <= mouseOffset.x) {\n                charIndex++;\n            } else {\n                break;\n            }\n        }\n        return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);\n    },\n    /**\n   * @private\n   */ _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {\n        // we need Math.abs because when width is after the last char, the offset is given as 1, while is 0\n        var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth, distanceBtwNextCharAndCursor = width - mouseOffset.x, offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor || distanceBtwNextCharAndCursor < 0 ? 0 : 1, newSelectionStart = index + offset;\n        // if object is horizontally flipped, mirror cursor location from the end\n        if (this.flipX) {\n            newSelectionStart = jlen - newSelectionStart;\n        }\n        if (newSelectionStart > this._text.length) {\n            newSelectionStart = this._text.length;\n        }\n        return newSelectionStart;\n    }\n});\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\n    /**\n   * Initializes hidden textarea (needed to bring up keyboard in iOS)\n   */ initHiddenTextarea: function() {\n        this.hiddenTextarea = fabric.document.createElement(\"textarea\");\n        this.hiddenTextarea.setAttribute(\"autocapitalize\", \"off\");\n        this.hiddenTextarea.setAttribute(\"autocorrect\", \"off\");\n        this.hiddenTextarea.setAttribute(\"autocomplete\", \"off\");\n        this.hiddenTextarea.setAttribute(\"spellcheck\", \"false\");\n        this.hiddenTextarea.setAttribute(\"data-fabric-hiddentextarea\", \"\");\n        this.hiddenTextarea.setAttribute(\"wrap\", \"off\");\n        var style = this._calcTextareaPosition();\n        // line-height: 1px; was removed from the style to fix this:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=870966\n        this.hiddenTextarea.style.cssText = \"position: absolute; top: \" + style.top + \"; left: \" + style.left + \"; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;\" + \" padding-top: \" + style.fontSize + \";\";\n        if (this.hiddenTextareaContainer) {\n            this.hiddenTextareaContainer.appendChild(this.hiddenTextarea);\n        } else {\n            fabric.document.body.appendChild(this.hiddenTextarea);\n        }\n        fabric.util.addListener(this.hiddenTextarea, \"keydown\", this.onKeyDown.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"keyup\", this.onKeyUp.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"input\", this.onInput.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"copy\", this.copy.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"cut\", this.copy.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"paste\", this.paste.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"compositionstart\", this.onCompositionStart.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"compositionupdate\", this.onCompositionUpdate.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"compositionend\", this.onCompositionEnd.bind(this));\n        if (!this._clickHandlerInitialized && this.canvas) {\n            fabric.util.addListener(this.canvas.upperCanvasEl, \"click\", this.onClick.bind(this));\n            this._clickHandlerInitialized = true;\n        }\n    },\n    /**\n   * For functionalities on keyDown\n   * Map a special key to a function of the instance/prototype\n   * If you need different behaviour for ESC or TAB or arrows, you have to change\n   * this map setting the name of a function that you build on the fabric.Itext or\n   * your prototype.\n   * the map change will affect all Instances unless you need for only some text Instances\n   * in that case you have to clone this object and assign your Instance.\n   * this.keysMap = fabric.util.object.clone(this.keysMap);\n   * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]\n   */ keysMap: {\n        9: \"exitEditing\",\n        27: \"exitEditing\",\n        33: \"moveCursorUp\",\n        34: \"moveCursorDown\",\n        35: \"moveCursorRight\",\n        36: \"moveCursorLeft\",\n        37: \"moveCursorLeft\",\n        38: \"moveCursorUp\",\n        39: \"moveCursorRight\",\n        40: \"moveCursorDown\"\n    },\n    keysMapRtl: {\n        9: \"exitEditing\",\n        27: \"exitEditing\",\n        33: \"moveCursorUp\",\n        34: \"moveCursorDown\",\n        35: \"moveCursorLeft\",\n        36: \"moveCursorRight\",\n        37: \"moveCursorRight\",\n        38: \"moveCursorUp\",\n        39: \"moveCursorLeft\",\n        40: \"moveCursorDown\"\n    },\n    /**\n   * For functionalities on keyUp + ctrl || cmd\n   */ ctrlKeysMapUp: {\n        67: \"copy\",\n        88: \"cut\"\n    },\n    /**\n   * For functionalities on keyDown + ctrl || cmd\n   */ ctrlKeysMapDown: {\n        65: \"selectAll\"\n    },\n    onClick: function() {\n        // No need to trigger click event here, focus is enough to have the keyboard appear on Android\n        this.hiddenTextarea && this.hiddenTextarea.focus();\n    },\n    /**\n   * Handles keydown event\n   * only used for arrows and combination of modifier keys.\n   * @param {Event} e Event object\n   */ onKeyDown: function(e) {\n        if (!this.isEditing) {\n            return;\n        }\n        var keyMap = this.direction === \"rtl\" ? this.keysMapRtl : this.keysMap;\n        if (e.keyCode in keyMap) {\n            this[keyMap[e.keyCode]](e);\n        } else if (e.keyCode in this.ctrlKeysMapDown && (e.ctrlKey || e.metaKey)) {\n            this[this.ctrlKeysMapDown[e.keyCode]](e);\n        } else {\n            return;\n        }\n        e.stopImmediatePropagation();\n        e.preventDefault();\n        if (e.keyCode >= 33 && e.keyCode <= 40) {\n            // if i press an arrow key just update selection\n            this.inCompositionMode = false;\n            this.clearContextTop();\n            this.renderCursorOrSelection();\n        } else {\n            this.canvas && this.canvas.requestRenderAll();\n        }\n    },\n    /**\n   * Handles keyup event\n   * We handle KeyUp because ie11 and edge have difficulties copy/pasting\n   * if a copy/cut event fired, keyup is dismissed\n   * @param {Event} e Event object\n   */ onKeyUp: function(e) {\n        if (!this.isEditing || this._copyDone || this.inCompositionMode) {\n            this._copyDone = false;\n            return;\n        }\n        if (e.keyCode in this.ctrlKeysMapUp && (e.ctrlKey || e.metaKey)) {\n            this[this.ctrlKeysMapUp[e.keyCode]](e);\n        } else {\n            return;\n        }\n        e.stopImmediatePropagation();\n        e.preventDefault();\n        this.canvas && this.canvas.requestRenderAll();\n    },\n    /**\n   * Handles onInput event\n   * @param {Event} e Event object\n   */ onInput: function(e) {\n        var fromPaste = this.fromPaste;\n        this.fromPaste = false;\n        e && e.stopPropagation();\n        if (!this.isEditing) {\n            return;\n        }\n        // decisions about style changes.\n        var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, charCount = this._text.length, nextCharCount = nextText.length, removedText, insertedText, charDiff = nextCharCount - charCount, selectionStart = this.selectionStart, selectionEnd = this.selectionEnd, selection = selectionStart !== selectionEnd, copiedStyle, removeFrom, removeTo;\n        if (this.hiddenTextarea.value === \"\") {\n            this.styles = {};\n            this.updateFromTextArea();\n            this.fire(\"changed\");\n            if (this.canvas) {\n                this.canvas.fire(\"text:changed\", {\n                    target: this\n                });\n                this.canvas.requestRenderAll();\n            }\n            return;\n        }\n        var textareaSelection = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);\n        var backDelete = selectionStart > textareaSelection.selectionStart;\n        if (selection) {\n            removedText = this._text.slice(selectionStart, selectionEnd);\n            charDiff += selectionEnd - selectionStart;\n        } else if (nextCharCount < charCount) {\n            if (backDelete) {\n                removedText = this._text.slice(selectionEnd + charDiff, selectionEnd);\n            } else {\n                removedText = this._text.slice(selectionStart, selectionStart - charDiff);\n            }\n        }\n        insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);\n        if (removedText && removedText.length) {\n            if (insertedText.length) {\n                // let's copy some style before deleting.\n                // we want to copy the style before the cursor OR the style at the cursor if selection\n                // is bigger than 0.\n                copiedStyle = this.getSelectionStyles(selectionStart, selectionStart + 1, false);\n                // now duplicate the style one for each inserted text.\n                copiedStyle = insertedText.map(function() {\n                    // this return an array of references, but that is fine since we are\n                    // copying the style later.\n                    return copiedStyle[0];\n                });\n            }\n            if (selection) {\n                removeFrom = selectionStart;\n                removeTo = selectionEnd;\n            } else if (backDelete) {\n                // detect differences between forwardDelete and backDelete\n                removeFrom = selectionEnd - removedText.length;\n                removeTo = selectionEnd;\n            } else {\n                removeFrom = selectionEnd;\n                removeTo = selectionEnd + removedText.length;\n            }\n            this.removeStyleFromTo(removeFrom, removeTo);\n        }\n        if (insertedText.length) {\n            if (fromPaste && insertedText.join(\"\") === fabric.copiedText && !fabric.disableStyleCopyPaste) {\n                copiedStyle = fabric.copiedTextStyle;\n            }\n            this.insertNewStyleBlock(insertedText, selectionStart, copiedStyle);\n        }\n        this.updateFromTextArea();\n        this.fire(\"changed\");\n        if (this.canvas) {\n            this.canvas.fire(\"text:changed\", {\n                target: this\n            });\n            this.canvas.requestRenderAll();\n        }\n    },\n    /**\n   * Composition start\n   */ onCompositionStart: function() {\n        this.inCompositionMode = true;\n    },\n    /**\n   * Composition end\n   */ onCompositionEnd: function() {\n        this.inCompositionMode = false;\n    },\n    // /**\n    //  * Composition update\n    //  */\n    onCompositionUpdate: function(e) {\n        this.compositionStart = e.target.selectionStart;\n        this.compositionEnd = e.target.selectionEnd;\n        this.updateTextareaPosition();\n    },\n    /**\n   * Copies selected text\n   * @param {Event} e Event object\n   */ copy: function() {\n        if (this.selectionStart === this.selectionEnd) {\n            //do not cut-copy if no selection\n            return;\n        }\n        fabric.copiedText = this.getSelectedText();\n        if (!fabric.disableStyleCopyPaste) {\n            fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);\n        } else {\n            fabric.copiedTextStyle = null;\n        }\n        this._copyDone = true;\n    },\n    /**\n   * Pastes text\n   * @param {Event} e Event object\n   */ paste: function() {\n        this.fromPaste = true;\n    },\n    /**\n   * @private\n   * @param {Event} e Event object\n   * @return {Object} Clipboard data object\n   */ _getClipboardData: function(e) {\n        return e && e.clipboardData || fabric.window.clipboardData;\n    },\n    /**\n   * Finds the width in pixels before the cursor on the same line\n   * @private\n   * @param {Number} lineIndex\n   * @param {Number} charIndex\n   * @return {Number} widthBeforeCursor width before cursor\n   */ _getWidthBeforeCursor: function(lineIndex, charIndex) {\n        var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;\n        if (charIndex > 0) {\n            bound = this.__charBounds[lineIndex][charIndex - 1];\n            widthBeforeCursor += bound.left + bound.width;\n        }\n        return widthBeforeCursor;\n    },\n    /**\n   * Gets start offset of a selection\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */ getDownCursorOffset: function(e, isRight) {\n        var selectionProp = this._getSelectionForOffset(e, isRight), cursorLocation = this.get2DCursorLocation(selectionProp), lineIndex = cursorLocation.lineIndex;\n        // if on last line, down cursor goes to end of line\n        if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {\n            // move to the end of a text\n            return this._text.length - selectionProp;\n        }\n        var charIndex = cursorLocation.charIndex, widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex), indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor), textAfterCursor = this._textLines[lineIndex].slice(charIndex);\n        return textAfterCursor.length + indexOnOtherLine + 1 + this.missingNewlineOffset(lineIndex);\n    },\n    /**\n   * private\n   * Helps finding if the offset should be counted from Start or End\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */ _getSelectionForOffset: function(e, isRight) {\n        if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {\n            return this.selectionEnd;\n        } else {\n            return this.selectionStart;\n        }\n    },\n    /**\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */ getUpCursorOffset: function(e, isRight) {\n        var selectionProp = this._getSelectionForOffset(e, isRight), cursorLocation = this.get2DCursorLocation(selectionProp), lineIndex = cursorLocation.lineIndex;\n        if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {\n            // if on first line, up cursor goes to start of line\n            return -selectionProp;\n        }\n        var charIndex = cursorLocation.charIndex, widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex), indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor), textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex), missingNewlineOffset = this.missingNewlineOffset(lineIndex - 1);\n        // return a negative offset\n        return -this._textLines[lineIndex - 1].length + indexOnOtherLine - textBeforeCursor.length + (1 - missingNewlineOffset);\n    },\n    /**\n   * for a given width it founds the matching character.\n   * @private\n   */ _getIndexOnLine: function(lineIndex, width) {\n        var line = this._textLines[lineIndex], lineLeftOffset = this._getLineLeftOffset(lineIndex), widthOfCharsOnLine = lineLeftOffset, indexOnLine = 0, charWidth, foundMatch;\n        for(var j = 0, jlen = line.length; j < jlen; j++){\n            charWidth = this.__charBounds[lineIndex][j].width;\n            widthOfCharsOnLine += charWidth;\n            if (widthOfCharsOnLine > width) {\n                foundMatch = true;\n                var leftEdge = widthOfCharsOnLine - charWidth, rightEdge = widthOfCharsOnLine, offsetFromLeftEdge = Math.abs(leftEdge - width), offsetFromRightEdge = Math.abs(rightEdge - width);\n                indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : j - 1;\n                break;\n            }\n        }\n        // reached end\n        if (!foundMatch) {\n            indexOnLine = line.length - 1;\n        }\n        return indexOnLine;\n    },\n    /**\n   * Moves cursor down\n   * @param {Event} e Event object\n   */ moveCursorDown: function(e) {\n        if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {\n            return;\n        }\n        this._moveCursorUpOrDown(\"Down\", e);\n    },\n    /**\n   * Moves cursor up\n   * @param {Event} e Event object\n   */ moveCursorUp: function(e) {\n        if (this.selectionStart === 0 && this.selectionEnd === 0) {\n            return;\n        }\n        this._moveCursorUpOrDown(\"Up\", e);\n    },\n    /**\n   * Moves cursor up or down, fires the events\n   * @param {String} direction 'Up' or 'Down'\n   * @param {Event} e Event object\n   */ _moveCursorUpOrDown: function(direction, e) {\n        // getUpCursorOffset\n        // getDownCursorOffset\n        var action = \"get\" + direction + \"CursorOffset\", offset = this[action](e, this._selectionDirection === \"right\");\n        if (e.shiftKey) {\n            this.moveCursorWithShift(offset);\n        } else {\n            this.moveCursorWithoutShift(offset);\n        }\n        if (offset !== 0) {\n            this.setSelectionInBoundaries();\n            this.abortCursorAnimation();\n            this._currentCursorOpacity = 1;\n            this.initDelayedCursor();\n            this._fireSelectionChanged();\n            this._updateTextarea();\n        }\n    },\n    /**\n   * Moves cursor with shift\n   * @param {Number} offset\n   */ moveCursorWithShift: function(offset) {\n        var newSelection = this._selectionDirection === \"left\" ? this.selectionStart + offset : this.selectionEnd + offset;\n        this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);\n        return offset !== 0;\n    },\n    /**\n   * Moves cursor up without shift\n   * @param {Number} offset\n   */ moveCursorWithoutShift: function(offset) {\n        if (offset < 0) {\n            this.selectionStart += offset;\n            this.selectionEnd = this.selectionStart;\n        } else {\n            this.selectionEnd += offset;\n            this.selectionStart = this.selectionEnd;\n        }\n        return offset !== 0;\n    },\n    /**\n   * Moves cursor left\n   * @param {Event} e Event object\n   */ moveCursorLeft: function(e) {\n        if (this.selectionStart === 0 && this.selectionEnd === 0) {\n            return;\n        }\n        this._moveCursorLeftOrRight(\"Left\", e);\n    },\n    /**\n   * @private\n   * @return {Boolean} true if a change happened\n   */ _move: function(e, prop, direction) {\n        var newValue;\n        if (e.altKey) {\n            newValue = this[\"findWordBoundary\" + direction](this[prop]);\n        } else if (e.metaKey || e.keyCode === 35 || e.keyCode === 36) {\n            newValue = this[\"findLineBoundary\" + direction](this[prop]);\n        } else {\n            this[prop] += direction === \"Left\" ? -1 : 1;\n            return true;\n        }\n        if (typeof newValue !== \"undefined\" && this[prop] !== newValue) {\n            this[prop] = newValue;\n            return true;\n        }\n    },\n    /**\n   * @private\n   */ _moveLeft: function(e, prop) {\n        return this._move(e, prop, \"Left\");\n    },\n    /**\n   * @private\n   */ _moveRight: function(e, prop) {\n        return this._move(e, prop, \"Right\");\n    },\n    /**\n   * Moves cursor left without keeping selection\n   * @param {Event} e\n   */ moveCursorLeftWithoutShift: function(e) {\n        var change = true;\n        this._selectionDirection = \"left\";\n        // only move cursor when there is no selection,\n        // otherwise we discard it, and leave cursor on same place\n        if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {\n            change = this._moveLeft(e, \"selectionStart\");\n        }\n        this.selectionEnd = this.selectionStart;\n        return change;\n    },\n    /**\n   * Moves cursor left while keeping selection\n   * @param {Event} e\n   */ moveCursorLeftWithShift: function(e) {\n        if (this._selectionDirection === \"right\" && this.selectionStart !== this.selectionEnd) {\n            return this._moveLeft(e, \"selectionEnd\");\n        } else if (this.selectionStart !== 0) {\n            this._selectionDirection = \"left\";\n            return this._moveLeft(e, \"selectionStart\");\n        }\n    },\n    /**\n   * Moves cursor right\n   * @param {Event} e Event object\n   */ moveCursorRight: function(e) {\n        if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {\n            return;\n        }\n        this._moveCursorLeftOrRight(\"Right\", e);\n    },\n    /**\n   * Moves cursor right or Left, fires event\n   * @param {String} direction 'Left', 'Right'\n   * @param {Event} e Event object\n   */ _moveCursorLeftOrRight: function(direction, e) {\n        var actionName = \"moveCursor\" + direction + \"With\";\n        this._currentCursorOpacity = 1;\n        if (e.shiftKey) {\n            actionName += \"Shift\";\n        } else {\n            actionName += \"outShift\";\n        }\n        if (this[actionName](e)) {\n            this.abortCursorAnimation();\n            this.initDelayedCursor();\n            this._fireSelectionChanged();\n            this._updateTextarea();\n        }\n    },\n    /**\n   * Moves cursor right while keeping selection\n   * @param {Event} e\n   */ moveCursorRightWithShift: function(e) {\n        if (this._selectionDirection === \"left\" && this.selectionStart !== this.selectionEnd) {\n            return this._moveRight(e, \"selectionStart\");\n        } else if (this.selectionEnd !== this._text.length) {\n            this._selectionDirection = \"right\";\n            return this._moveRight(e, \"selectionEnd\");\n        }\n    },\n    /**\n   * Moves cursor right without keeping selection\n   * @param {Event} e Event object\n   */ moveCursorRightWithoutShift: function(e) {\n        var changed = true;\n        this._selectionDirection = \"right\";\n        if (this.selectionStart === this.selectionEnd) {\n            changed = this._moveRight(e, \"selectionStart\");\n            this.selectionEnd = this.selectionStart;\n        } else {\n            this.selectionStart = this.selectionEnd;\n        }\n        return changed;\n    },\n    /**\n   * Removes characters from start/end\n   * start/end ar per grapheme position in _text array.\n   *\n   * @param {Number} start\n   * @param {Number} end default to start + 1\n   */ removeChars: function(start, end) {\n        if (typeof end === \"undefined\") {\n            end = start + 1;\n        }\n        this.removeStyleFromTo(start, end);\n        this._text.splice(start, end - start);\n        this.text = this._text.join(\"\");\n        this.set(\"dirty\", true);\n        if (this._shouldClearDimensionCache()) {\n            this.initDimensions();\n            this.setCoords();\n        }\n        this._removeExtraneousStyles();\n    },\n    /**\n   * insert characters at start position, before start position.\n   * start  equal 1 it means the text get inserted between actual grapheme 0 and 1\n   * if style array is provided, it must be as the same length of text in graphemes\n   * if end is provided and is bigger than start, old text is replaced.\n   * start/end ar per grapheme position in _text array.\n   *\n   * @param {String} text text to insert\n   * @param {Array} style array of style objects\n   * @param {Number} start\n   * @param {Number} end default to start + 1\n   */ insertChars: function(text, style, start, end) {\n        if (typeof end === \"undefined\") {\n            end = start;\n        }\n        if (end > start) {\n            this.removeStyleFromTo(start, end);\n        }\n        var graphemes = fabric.util.string.graphemeSplit(text);\n        this.insertNewStyleBlock(graphemes, start, style);\n        this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));\n        this.text = this._text.join(\"\");\n        this.set(\"dirty\", true);\n        if (this._shouldClearDimensionCache()) {\n            this.initDimensions();\n            this.setCoords();\n        }\n        this._removeExtraneousStyles();\n    }\n});\n/* _TO_SVG_START_ */ (function() {\n    var toFixed = fabric.util.toFixed, multipleSpacesRegex = /  +/g;\n    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {\n        /**\n     * Returns SVG representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ _toSVG: function() {\n            var offsets = this._getSVGLeftTopOffsets(), textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);\n            return this._wrapSVGTextAndBg(textAndBg);\n        },\n        /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toSVG: function(reviver) {\n            return this._createBaseSVGMarkup(this._toSVG(), {\n                reviver: reviver,\n                noStyle: true,\n                withShadow: true\n            });\n        },\n        /**\n     * @private\n     */ _getSVGLeftTopOffsets: function() {\n            return {\n                textLeft: -this.width / 2,\n                textTop: -this.height / 2,\n                lineTop: this.getHeightOfLine(0)\n            };\n        },\n        /**\n     * @private\n     */ _wrapSVGTextAndBg: function(textAndBg) {\n            var noShadow = true, textDecoration = this.getSvgTextDecoration(this);\n            return [\n                textAndBg.textBgRects.join(\"\"),\n                '\t\t<text xml:space=\"preserve\" ',\n                this.fontFamily ? 'font-family=\"' + this.fontFamily.replace(/\"/g, \"'\") + '\" ' : \"\",\n                this.fontSize ? 'font-size=\"' + this.fontSize + '\" ' : \"\",\n                this.fontStyle ? 'font-style=\"' + this.fontStyle + '\" ' : \"\",\n                this.fontWeight ? 'font-weight=\"' + this.fontWeight + '\" ' : \"\",\n                textDecoration ? 'text-decoration=\"' + textDecoration + '\" ' : \"\",\n                'style=\"',\n                this.getSvgStyles(noShadow),\n                '\"',\n                this.addPaintOrder(),\n                \" >\",\n                textAndBg.textSpans.join(\"\"),\n                \"</text>\\n\"\n            ];\n        },\n        /**\n     * @private\n     * @param {Number} textTopOffset Text top offset\n     * @param {Number} textLeftOffset Text left offset\n     * @return {Object}\n     */ _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {\n            var textSpans = [], textBgRects = [], height = textTopOffset, lineOffset;\n            // bounding-box background\n            this._setSVGBg(textBgRects);\n            // text and text-background\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                lineOffset = this._getLineLeftOffset(i);\n                if (this.textBackgroundColor || this.styleHas(\"textBackgroundColor\", i)) {\n                    this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);\n                }\n                this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);\n                height += this.getHeightOfLine(i);\n            }\n            return {\n                textSpans: textSpans,\n                textBgRects: textBgRects\n            };\n        },\n        /**\n     * @private\n     */ _createTextCharSpan: function(_char, styleDecl, left, top) {\n            var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex), styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace), fillStyles = styleProps ? 'style=\"' + styleProps + '\"' : \"\", dy = styleDecl.deltaY, dySpan = \"\", NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            if (dy) {\n                dySpan = ' dy=\"' + toFixed(dy, NUM_FRACTION_DIGITS) + '\" ';\n            }\n            return [\n                '<tspan x=\"',\n                toFixed(left, NUM_FRACTION_DIGITS),\n                '\" y=\"',\n                toFixed(top, NUM_FRACTION_DIGITS),\n                '\" ',\n                dySpan,\n                fillStyles,\n                \">\",\n                fabric.util.string.escapeXml(_char),\n                \"</tspan>\"\n            ].join(\"\");\n        },\n        _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {\n            // set proper line offset\n            var lineHeight = this.getHeightOfLine(lineIndex), isJustify = this.textAlign.indexOf(\"justify\") !== -1, actualStyle, nextStyle, charsToRender = \"\", charBox, style, boxWidth = 0, line = this._textLines[lineIndex], timeToRender;\n            textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;\n            for(var i = 0, len = line.length - 1; i <= len; i++){\n                timeToRender = i === len || this.charSpacing;\n                charsToRender += line[i];\n                charBox = this.__charBounds[lineIndex][i];\n                if (boxWidth === 0) {\n                    textLeftOffset += charBox.kernedWidth - charBox.width;\n                    boxWidth += charBox.width;\n                } else {\n                    boxWidth += charBox.kernedWidth;\n                }\n                if (isJustify && !timeToRender) {\n                    if (this._reSpaceAndTab.test(line[i])) {\n                        timeToRender = true;\n                    }\n                }\n                if (!timeToRender) {\n                    // if we have charSpacing, we render char by char\n                    actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);\n                    nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);\n                    timeToRender = fabric.util.hasStyleChanged(actualStyle, nextStyle, true);\n                }\n                if (timeToRender) {\n                    style = this._getStyleDeclaration(lineIndex, i) || {};\n                    textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));\n                    charsToRender = \"\";\n                    actualStyle = nextStyle;\n                    textLeftOffset += boxWidth;\n                    boxWidth = 0;\n                }\n            }\n        },\n        _pushTextBgRect: function(textBgRects, color, left, top, width, height) {\n            var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            textBgRects.push(\"\t\t<rect \", this._getFillAttributes(color), ' x=\"', toFixed(left, NUM_FRACTION_DIGITS), '\" y=\"', toFixed(top, NUM_FRACTION_DIGITS), '\" width=\"', toFixed(width, NUM_FRACTION_DIGITS), '\" height=\"', toFixed(height, NUM_FRACTION_DIGITS), '\"></rect>\\n');\n        },\n        _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {\n            var line = this._textLines[i], heightOfLine = this.getHeightOfLine(i) / this.lineHeight, boxWidth = 0, boxStart = 0, charBox, currentColor, lastColor = this.getValueOfPropertyAt(i, 0, \"textBackgroundColor\");\n            for(var j = 0, jlen = line.length; j < jlen; j++){\n                charBox = this.__charBounds[i][j];\n                currentColor = this.getValueOfPropertyAt(i, j, \"textBackgroundColor\");\n                if (currentColor !== lastColor) {\n                    lastColor && this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart, textTopOffset, boxWidth, heightOfLine);\n                    boxStart = charBox.left;\n                    boxWidth = charBox.width;\n                    lastColor = currentColor;\n                } else {\n                    boxWidth += charBox.kernedWidth;\n                }\n            }\n            currentColor && this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart, textTopOffset, boxWidth, heightOfLine);\n        },\n        /**\n     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values\n     * we work around it by \"moving\" alpha channel into opacity attribute and setting fill's alpha to 1\n     *\n     * @private\n     * @param {*} value\n     * @return {String}\n     */ _getFillAttributes: function(value) {\n            var fillColor = value && typeof value === \"string\" ? new fabric.Color(value) : \"\";\n            if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {\n                return 'fill=\"' + value + '\"';\n            }\n            return 'opacity=\"' + fillColor.getAlpha() + '\" fill=\"' + fillColor.setAlpha(1).toRgb() + '\"';\n        },\n        /**\n     * @private\n     */ _getSVGLineTopOffset: function(lineIndex) {\n            var lineTopOffset = 0, lastHeight = 0;\n            for(var j = 0; j < lineIndex; j++){\n                lineTopOffset += this.getHeightOfLine(j);\n            }\n            lastHeight = this.getHeightOfLine(j);\n            return {\n                lineTop: lineTopOffset,\n                offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)\n            };\n        },\n        /**\n     * Returns styles-string for svg-export\n     * @param {Boolean} skipShadow a boolean to skip shadow filter output\n     * @return {String}\n     */ getSvgStyles: function(skipShadow) {\n            var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);\n            return svgStyle + \" white-space: pre;\";\n        }\n    });\n})();\n/* _TO_SVG_END_ */ (function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    /**\n   * Textbox class, based on IText, allows the user to resize the text rectangle\n   * and wraps lines automatically. Textboxes have their Y scaling locked, the\n   * user can only change width. Height is adjusted automatically based on the\n   * wrapping of lines.\n   * @class fabric.Textbox\n   * @extends fabric.IText\n   * @mixes fabric.Observable\n   * @return {fabric.Textbox} thisArg\n   * @see {@link fabric.Textbox#initialize} for constructor definition\n   */ fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"textbox\",\n        /**\n     * Minimum width of textbox, in pixels.\n     * @type Number\n     * @default\n     */ minWidth: 20,\n        /**\n     * Minimum calculated width of a textbox, in pixels.\n     * fixed to 2 so that an empty textbox cannot go to 0\n     * and is still selectable without text.\n     * @type Number\n     * @default\n     */ dynamicMinWidth: 2,\n        /**\n     * Cached array of text wrapping.\n     * @type Array\n     */ __cachedLines: null,\n        /**\n     * Override standard Object class values\n     */ lockScalingFlip: true,\n        /**\n     * Override standard Object class values\n     * Textbox needs this on false\n     */ noScaleCache: false,\n        /**\n     * Properties which when set cause object to change dimensions\n     * @type Object\n     * @private\n     */ _dimensionAffectingProps: fabric.Text.prototype._dimensionAffectingProps.concat(\"width\"),\n        /**\n     * Use this regular expression to split strings in breakable lines\n     * @private\n     */ _wordJoiners: /[ \\t\\r]/,\n        /**\n     * Use this boolean property in order to split strings that have no white space concept.\n     * this is a cheap way to help with chinese/japanese\n     * @type Boolean\n     * @since 2.6.0\n     */ splitByGrapheme: false,\n        /**\n     * Unlike superclass's version of this function, Textbox does not update\n     * its width.\n     * @private\n     * @override\n     */ initDimensions: function() {\n            if (this.__skipDimension) {\n                return;\n            }\n            this.isEditing && this.initDelayedCursor();\n            this.clearContextTop();\n            this._clearCache();\n            // clear dynamicMinWidth as it will be different after we re-wrap line\n            this.dynamicMinWidth = 0;\n            // wrap lines\n            this._styleMap = this._generateStyleMap(this._splitText());\n            // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap\n            if (this.dynamicMinWidth > this.width) {\n                this._set(\"width\", this.dynamicMinWidth);\n            }\n            if (this.textAlign.indexOf(\"justify\") !== -1) {\n                // once text is measured we need to make space fatter to make justified text.\n                this.enlargeSpaces();\n            }\n            // clear cache and re-calculate height\n            this.height = this.calcTextHeight();\n            this.saveState({\n                propertySet: \"_dimensionAffectingProps\"\n            });\n        },\n        /**\n     * Generate an object that translates the style object so that it is\n     * broken up by visual lines (new lines and automatic wrapping).\n     * The original text styles object is broken up by actual lines (new lines only),\n     * which is only sufficient for Text / IText\n     * @private\n     */ _generateStyleMap: function(textInfo) {\n            var realLineCount = 0, realLineCharCount = 0, charCount = 0, map = {};\n            for(var i = 0; i < textInfo.graphemeLines.length; i++){\n                if (textInfo.graphemeText[charCount] === \"\\n\" && i > 0) {\n                    realLineCharCount = 0;\n                    charCount++;\n                    realLineCount++;\n                } else if (!this.splitByGrapheme && this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {\n                    // this case deals with space's that are removed from end of lines when wrapping\n                    realLineCharCount++;\n                    charCount++;\n                }\n                map[i] = {\n                    line: realLineCount,\n                    offset: realLineCharCount\n                };\n                charCount += textInfo.graphemeLines[i].length;\n                realLineCharCount += textInfo.graphemeLines[i].length;\n            }\n            return map;\n        },\n        /**\n     * Returns true if object has a style property or has it on a specified line\n     * @param {Number} lineIndex\n     * @return {Boolean}\n     */ styleHas: function(property, lineIndex) {\n            if (this._styleMap && !this.isWrapping) {\n                var map = this._styleMap[lineIndex];\n                if (map) {\n                    lineIndex = map.line;\n                }\n            }\n            return fabric.Text.prototype.styleHas.call(this, property, lineIndex);\n        },\n        /**\n     * Returns true if object has no styling or no styling in a line\n     * @param {Number} lineIndex , lineIndex is on wrapped lines.\n     * @return {Boolean}\n     */ isEmptyStyles: function(lineIndex) {\n            if (!this.styles) {\n                return true;\n            }\n            var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false, map = this._styleMap[lineIndex], mapNextLine = this._styleMap[lineIndex + 1];\n            if (map) {\n                lineIndex = map.line;\n                offset = map.offset;\n            }\n            if (mapNextLine) {\n                nextLineIndex = mapNextLine.line;\n                shouldLimit = nextLineIndex === lineIndex;\n                nextOffset = mapNextLine.offset;\n            }\n            obj = typeof lineIndex === \"undefined\" ? this.styles : {\n                line: this.styles[lineIndex]\n            };\n            for(var p1 in obj){\n                for(var p2 in obj[p1]){\n                    if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {\n                        // eslint-disable-next-line no-unused-vars\n                        for(var p3 in obj[p1][p2]){\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */ _getStyleDeclaration: function(lineIndex, charIndex) {\n            if (this._styleMap && !this.isWrapping) {\n                var map = this._styleMap[lineIndex];\n                if (!map) {\n                    return null;\n                }\n                lineIndex = map.line;\n                charIndex = map.offset + charIndex;\n            }\n            return this.callSuper(\"_getStyleDeclaration\", lineIndex, charIndex);\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {Object} style\n     * @private\n     */ _setStyleDeclaration: function(lineIndex, charIndex, style) {\n            var map = this._styleMap[lineIndex];\n            lineIndex = map.line;\n            charIndex = map.offset + charIndex;\n            this.styles[lineIndex][charIndex] = style;\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */ _deleteStyleDeclaration: function(lineIndex, charIndex) {\n            var map = this._styleMap[lineIndex];\n            lineIndex = map.line;\n            charIndex = map.offset + charIndex;\n            delete this.styles[lineIndex][charIndex];\n        },\n        /**\n     * probably broken need a fix\n     * Returns the real style line that correspond to the wrapped lineIndex line\n     * Used just to verify if the line does exist or not.\n     * @param {Number} lineIndex\n     * @returns {Boolean} if the line exists or not\n     * @private\n     */ _getLineStyle: function(lineIndex) {\n            var map = this._styleMap[lineIndex];\n            return !!this.styles[map.line];\n        },\n        /**\n     * Set the line style to an empty object so that is initialized\n     * @param {Number} lineIndex\n     * @param {Object} style\n     * @private\n     */ _setLineStyle: function(lineIndex) {\n            var map = this._styleMap[lineIndex];\n            this.styles[map.line] = {};\n        },\n        /**\n     * Wraps text using the 'width' property of Textbox. First this function\n     * splits text on newlines, so we preserve newlines entered by the user.\n     * Then it wraps each line using the width of the Textbox by calling\n     * _wrapLine().\n     * @param {Array} lines The string array of text that is split into lines\n     * @param {Number} desiredWidth width you want to wrap to\n     * @returns {Array} Array of lines\n     */ _wrapText: function(lines, desiredWidth) {\n            var wrapped = [], i;\n            this.isWrapping = true;\n            for(i = 0; i < lines.length; i++){\n                wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));\n            }\n            this.isWrapping = false;\n            return wrapped;\n        },\n        /**\n     * Helper function to measure a string of text, given its lineIndex and charIndex offset\n     * it gets called when charBounds are not available yet.\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {String} text\n     * @param {number} lineIndex\n     * @param {number} charOffset\n     * @returns {number}\n     * @private\n     */ _measureWord: function(word, lineIndex, charOffset) {\n            var width = 0, prevGrapheme, skipLeft = true;\n            charOffset = charOffset || 0;\n            for(var i = 0, len = word.length; i < len; i++){\n                var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);\n                width += box.kernedWidth;\n                prevGrapheme = word[i];\n            }\n            return width;\n        },\n        /**\n     * Wraps a line of text using the width of the Textbox and a context.\n     * @param {Array} line The grapheme array that represent the line\n     * @param {Number} lineIndex\n     * @param {Number} desiredWidth width you want to wrap the line to\n     * @param {Number} reservedSpace space to remove from wrapping for custom functionalities\n     * @returns {Array} Array of line(s) into which the given text is wrapped\n     * to.\n     */ _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {\n            var lineWidth = 0, splitByGrapheme = this.splitByGrapheme, graphemeLines = [], line = [], // spaces in different languages?\n            words = splitByGrapheme ? fabric.util.string.graphemeSplit(_line) : _line.split(this._wordJoiners), word = \"\", offset = 0, infix = splitByGrapheme ? \"\" : \" \", wordWidth = 0, infixWidth = 0, largestWordWidth = 0, lineJustStarted = true, additionalSpace = this._getWidthOfCharSpacing(), reservedSpace = reservedSpace || 0;\n            // fix a difference between split and graphemeSplit\n            if (words.length === 0) {\n                words.push([]);\n            }\n            desiredWidth -= reservedSpace;\n            for(var i = 0; i < words.length; i++){\n                // if using splitByGrapheme words are already in graphemes.\n                word = splitByGrapheme ? words[i] : fabric.util.string.graphemeSplit(words[i]);\n                wordWidth = this._measureWord(word, lineIndex, offset);\n                offset += word.length;\n                lineWidth += infixWidth + wordWidth - additionalSpace;\n                if (lineWidth > desiredWidth && !lineJustStarted) {\n                    graphemeLines.push(line);\n                    line = [];\n                    lineWidth = wordWidth;\n                    lineJustStarted = true;\n                } else {\n                    lineWidth += additionalSpace;\n                }\n                if (!lineJustStarted && !splitByGrapheme) {\n                    line.push(infix);\n                }\n                line = line.concat(word);\n                infixWidth = splitByGrapheme ? 0 : this._measureWord([\n                    infix\n                ], lineIndex, offset);\n                offset++;\n                lineJustStarted = false;\n                // keep track of largest word\n                if (wordWidth > largestWordWidth) {\n                    largestWordWidth = wordWidth;\n                }\n            }\n            i && graphemeLines.push(line);\n            if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {\n                this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;\n            }\n            return graphemeLines;\n        },\n        /**\n     * Detect if the text line is ended with an hard break\n     * text and itext do not have wrapping, return false\n     * @param {Number} lineIndex text to split\n     * @return {Boolean}\n     */ isEndOfWrapping: function(lineIndex) {\n            if (!this._styleMap[lineIndex + 1]) {\n                // is last line, return true;\n                return true;\n            }\n            if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {\n                // this is last line before a line break, return true;\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Detect if a line has a linebreak and so we need to account for it when moving\n     * and counting style.\n     * @return Number\n     */ missingNewlineOffset: function(lineIndex) {\n            if (this.splitByGrapheme) {\n                return this.isEndOfWrapping(lineIndex) ? 1 : 0;\n            }\n            return 1;\n        },\n        /**\n    * Gets lines of text to render in the Textbox. This function calculates\n    * text wrapping on the fly every time it is called.\n    * @param {String} text text to split\n    * @returns {Array} Array of lines in the Textbox.\n    * @override\n    */ _splitTextIntoLines: function(text) {\n            var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text), graphemeLines = this._wrapText(newText.lines, this.width), lines = new Array(graphemeLines.length);\n            for(var i = 0; i < graphemeLines.length; i++){\n                lines[i] = graphemeLines[i].join(\"\");\n            }\n            newText.lines = lines;\n            newText.graphemeLines = graphemeLines;\n            return newText;\n        },\n        getMinWidth: function() {\n            return Math.max(this.minWidth, this.dynamicMinWidth);\n        },\n        _removeExtraneousStyles: function() {\n            var linesToKeep = {};\n            for(var prop in this._styleMap){\n                if (this._textLines[prop]) {\n                    linesToKeep[this._styleMap[prop].line] = 1;\n                }\n            }\n            for(var prop in this.styles){\n                if (!linesToKeep[prop]) {\n                    delete this.styles[prop];\n                }\n            }\n        },\n        /**\n     * Returns object representation of an instance\n     * @method toObject\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"minWidth\",\n                \"splitByGrapheme\"\n            ].concat(propertiesToInclude));\n        }\n    });\n    /**\n   * Returns fabric.Textbox instance from an object representation\n   * @static\n   * @memberOf fabric.Textbox\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created\n   */ fabric.Textbox.fromObject = function(object, callback) {\n        var styles = fabric.util.stylesFromArray(object.styles, object.text);\n        //copy object to prevent mutation\n        var objCopy = Object.assign({}, object, {\n            styles: styles\n        });\n        return fabric.Object._fromObject(\"Textbox\", objCopy, callback, \"text\");\n    };\n})( true ? exports : 0);\n(function() {\n    var controlsUtils = fabric.controlsUtils, scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler, scaleStyleHandler = controlsUtils.scaleCursorStyleHandler, scalingEqually = controlsUtils.scalingEqually, scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX, scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY, scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName, objectControls = fabric.Object.prototype.controls;\n    objectControls.ml = new fabric.Control({\n        x: -0.5,\n        y: 0,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingXOrSkewingY,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.mr = new fabric.Control({\n        x: 0.5,\n        y: 0,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingXOrSkewingY,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.mb = new fabric.Control({\n        x: 0,\n        y: 0.5,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingYOrSkewingX,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.mt = new fabric.Control({\n        x: 0,\n        y: -0.5,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingYOrSkewingX,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.tl = new fabric.Control({\n        x: -0.5,\n        y: -0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.tr = new fabric.Control({\n        x: 0.5,\n        y: -0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.bl = new fabric.Control({\n        x: -0.5,\n        y: 0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.br = new fabric.Control({\n        x: 0.5,\n        y: 0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.mtr = new fabric.Control({\n        x: 0,\n        y: -0.5,\n        actionHandler: controlsUtils.rotationWithSnapping,\n        cursorStyleHandler: controlsUtils.rotationStyleHandler,\n        offsetY: -40,\n        withConnection: true,\n        actionName: \"rotate\"\n    });\n    if (fabric.Textbox) {\n        // this is breaking the prototype inheritance, no time / ideas to fix it.\n        // is important to document that if you want to have all objects to have a\n        // specific custom control, you have to add it to Object prototype and to Textbox\n        // prototype. The controls are shared as references. So changes to control `tr`\n        // can still apply to all objects if needed.\n        var textBoxControls = fabric.Textbox.prototype.controls = {};\n        textBoxControls.mtr = objectControls.mtr;\n        textBoxControls.tr = objectControls.tr;\n        textBoxControls.br = objectControls.br;\n        textBoxControls.tl = objectControls.tl;\n        textBoxControls.bl = objectControls.bl;\n        textBoxControls.mt = objectControls.mt;\n        textBoxControls.mb = objectControls.mb;\n        textBoxControls.mr = new fabric.Control({\n            x: 0.5,\n            y: 0,\n            actionHandler: controlsUtils.changeWidth,\n            cursorStyleHandler: scaleSkewStyleHandler,\n            actionName: \"resizing\"\n        });\n        textBoxControls.ml = new fabric.Control({\n            x: -0.5,\n            y: 0,\n            actionHandler: controlsUtils.changeWidth,\n            cursorStyleHandler: scaleSkewStyleHandler,\n            actionName: \"resizing\"\n        });\n    }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFicmljL2Rpc3QvZmFicmljLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFHQUFxRyxHQUNyRywyRUFBMkUsR0FFM0UsSUFBSUEsU0FBU0EsVUFBVTtJQUFFQyxTQUFTO0FBQVE7QUFDMUMsSUFBSSxJQUFtQixFQUFhO0lBQ2xDQyxjQUFjLEdBQUdGO0FBQ25CLE9BRUssRUFFSjtBQUNELGFBQWEsR0FDYixJQUFJLE9BQU9LLGFBQWEsZUFBZSxnQkFBa0IsYUFBYSxFQVFyRSxNQUNJO0lBQ0gsMEVBQTBFO0lBQzFFLElBQUlNLFFBQVFDLG1CQUFPQSxDQUFDO0lBQ3BCLElBQUlDLGdCQUFnQixJQUFJRixNQUFNRyxLQUFLLENBQ2pDQyxtQkFBbUIsK0ZBQ25CO1FBQ0VDLFVBQVU7WUFDUkMsd0JBQXdCO2dCQUFDO2FBQU07UUFDakM7UUFDQUMsV0FBVztJQUNiLEdBQUdSLE1BQU07SUFDWFYsT0FBT0ssUUFBUSxHQUFHUSxjQUFjUixRQUFRO0lBQ3hDTCxPQUFPbUIsbUJBQW1CLEdBQUdQLHdKQUFnRTtJQUM3RlosT0FBT3FCLFVBQVUsR0FBR1QsOEdBQXVDO0lBQzNEWixPQUFPVSxNQUFNLEdBQUdHO0lBQ2hCVSxZQUFZdkIsT0FBT1UsTUFBTSxDQUFDYSxTQUFTO0FBQ3JDO0FBRUE7OztDQUdDLEdBQ0R2QixPQUFPd0IsZ0JBQWdCLEdBQUcsa0JBQWtCeEIsT0FBT1UsTUFBTSxJQUFJLGtCQUFrQlYsT0FBT0ssUUFBUSxJQUMzRkwsT0FBT1UsTUFBTSxJQUFJVixPQUFPVSxNQUFNLENBQUNlLFNBQVMsSUFBSXpCLE9BQU9VLE1BQU0sQ0FBQ2UsU0FBUyxDQUFDQyxjQUFjLEdBQUc7QUFFeEY7OztDQUdDLEdBQ0QxQixPQUFPMkIsWUFBWSxHQUFHLE9BQU9DLFdBQVcsZUFDbEIsZ0JBQWtCO0FBRXhDLG9CQUFvQixHQUNwQjs7O0NBR0MsR0FDRDVCLE9BQU82QixpQkFBaUIsR0FBRztJQUN6QjtJQUNBO0lBQ0E7SUFBUTtJQUFn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LFNBQXNCO1FBQ3RCQyxNQUFzQjtRQUN0QkMsVUFBc0I7UUFDdEJDLFVBQXNCO1FBQ3RCQyxlQUFzQjtRQUN0QkMsVUFBc0I7UUFDdEJDLFVBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLGFBQXNCO1FBQ3RCQyxnQkFBc0I7UUFDdEJDLFlBQXNCO1FBQ3RCQyxZQUFzQjtRQUN0QkMsU0FBc0I7UUFDdEJDLFlBQXNCO1FBQ3RCQyxjQUFzQjtRQUN0QkMsZUFBc0I7UUFDdEJDLGVBQXNCO1FBQ3RCQyxlQUFzQjtRQUN0QkMsZUFBc0I7UUFDdEJDLFlBQXNCO1FBQ3RCQyxVQUFzQjtRQUN0QkMsYUFBc0I7UUFDdEJDLFNBQXNCO1FBQ3RCQyxTQUFzQjtRQUN0QkMsWUFBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxhQUFzQjtRQUN0QkMsYUFBc0I7UUFDdEJDLFNBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsWUFBc0I7UUFDdEJDLE1BQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsTUFBc0I7UUFDdEJDLE1BQXNCO1FBQ3RCQyxPQUFzQjtRQUN0QkMsYUFBc0I7UUFDdEJDLFVBQXNCO1FBQ3RCQyxTQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLFFBQXNCO1FBQ3RCQyxPQUFzQjtRQUN0QkMsT0FBc0I7UUFDdEJDLFVBQXNCO1FBQ3RCQyxlQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLGNBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsWUFBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxzQkFBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsWUFBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxhQUFzQjtRQUN0QkMsZUFBc0I7UUFDdEJDLGNBQXNCO1FBQ3RCQyxnQkFBc0I7UUFDdEJDLGdCQUFzQjtRQUN0QkMsZ0JBQXNCO1FBQ3RCQyxhQUFzQjtRQUN0QkMsTUFBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxPQUFzQjtRQUN0QkMsU0FBc0I7UUFDdEJDLFFBQXNCO1FBQ3RCQyxrQkFBc0I7UUFD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aUZBQWlGO1FBQ2pGLCtFQUErRTtRQUMvRSw0Q0FBNEM7UUFDNUMsSUFBSXlDLGtCQUFrQi8xRyxPQUFPc3pHLE9BQU8sQ0FBQ3A1RixTQUFTLENBQUMwMUIsUUFBUSxHQUFHLENBQUU7UUFFNURtbUUsZ0JBQWdCRCxHQUFHLEdBQUdKLGVBQWVJLEdBQUc7UUFDeENDLGdCQUFnQi82RCxFQUFFLEdBQUcwNkQsZUFBZTE2RCxFQUFFO1FBQ3RDKzZELGdCQUFnQjc2RCxFQUFFLEdBQUd3NkQsZUFBZXg2RCxFQUFFO1FBQ3RDNjZELGdCQUFnQmg3RCxFQUFFLEdBQUcyNkQsZUFBZTM2RCxFQUFFO1FBQ3RDZzdELGdCQUFnQjk2RCxFQUFFLEdBQUd5NkQsZUFBZXo2RCxFQUFFO1FBQ3RDODZELGdCQUFnQm4zRixFQUFFLEdBQUc4MkYsZUFBZTkyRixFQUFFO1FBQ3RDbTNGLGdCQUFnQkYsRUFBRSxHQUFHSCxlQUFlRyxFQUFFO1FBRXRDRSxnQkFBZ0JILEVBQUUsR0FBRyxJQUFJNTFHLE9BQU84NEMsT0FBTyxDQUFDO1lBQ3RDdHVDLEdBQUc7WUFDSEMsR0FBRztZQUNIa29DLGVBQWUyRSxjQUFjWCxXQUFXO1lBQ3hDNkMsb0JBQW9CZzhEO1lBQ3BCejhELFlBQVk7UUFDZDtRQUVBZzlELGdCQUFnQkosRUFBRSxHQUFHLElBQUkzMUcsT0FBTzg0QyxPQUFPLENBQUM7WUFDdEN0dUMsR0FBRyxDQUFDO1lBQ0pDLEdBQUc7WUFDSGtvQyxlQUFlMkUsY0FBY1gsV0FBVztZQUN4QzZDLG9CQUFvQmc4RDtZQUNwQno4RCxZQUFZO1FBQ2Q7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGNvdmVyLWNyYWZ0L3dlYi8uL25vZGVfbW9kdWxlcy9mYWJyaWMvZGlzdC9mYWJyaWMuanM/Yjk3MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBidWlsZDogYG5vZGUgYnVpbGQuanMgbW9kdWxlcz1BTEwgZXhjbHVkZT1nZXN0dXJlcyxhY2Nlc3NvcnMsZXJhc2luZyByZXF1aXJlanMgbWluaWZpZXI9dWdsaWZ5anNgICovXG4vKiEgRmFicmljLmpzIENvcHlyaWdodCAyMDA4LTIwMTUsIFByaW50aW8gKEp1cml5IFpheXRzZXYsIE1heGltIENoZXJueWFrKSAqL1xuXG52YXIgZmFicmljID0gZmFicmljIHx8IHsgdmVyc2lvbjogJzUuMy4wJyB9O1xuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBleHBvcnRzLmZhYnJpYyA9IGZhYnJpYztcbn1cbi8qIF9BTURfU1RBUlRfICovXG5lbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhYnJpYzsgfSk7XG59XG4vKiBfQU1EX0VORF8gKi9cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGlmIChkb2N1bWVudCBpbnN0YW5jZW9mICh0eXBlb2YgSFRNTERvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IEhUTUxEb2N1bWVudCA6IERvY3VtZW50KSkge1xuICAgIGZhYnJpYy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICB9XG4gIGVsc2Uge1xuICAgIGZhYnJpYy5kb2N1bWVudCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgnJyk7XG4gIH1cbiAgZmFicmljLndpbmRvdyA9IHdpbmRvdztcbn1cbmVsc2Uge1xuICAvLyBhc3N1bWUgd2UncmUgcnVubmluZyB1bmRlciBub2RlLmpzIHdoZW4gZG9jdW1lbnQvd2luZG93IGFyZSBub3QgcHJlc2VudFxuICB2YXIganNkb20gPSByZXF1aXJlKCdqc2RvbScpO1xuICB2YXIgdmlydHVhbFdpbmRvdyA9IG5ldyBqc2RvbS5KU0RPTShcbiAgICBkZWNvZGVVUklDb21wb25lbnQoJyUzQyFET0NUWVBFJTIwaHRtbCUzRSUzQ2h0bWwlM0UlM0NoZWFkJTNFJTNDJTJGaGVhZCUzRSUzQ2JvZHklM0UlM0MlMkZib2R5JTNFJTNDJTJGaHRtbCUzRScpLFxuICAgIHtcbiAgICAgIGZlYXR1cmVzOiB7XG4gICAgICAgIEZldGNoRXh0ZXJuYWxSZXNvdXJjZXM6IFsnaW1nJ11cbiAgICAgIH0sXG4gICAgICByZXNvdXJjZXM6ICd1c2FibGUnXG4gICAgfSkud2luZG93O1xuICBmYWJyaWMuZG9jdW1lbnQgPSB2aXJ0dWFsV2luZG93LmRvY3VtZW50O1xuICBmYWJyaWMuanNkb21JbXBsRm9yV3JhcHBlciA9IHJlcXVpcmUoJ2pzZG9tL2xpYi9qc2RvbS9saXZpbmcvZ2VuZXJhdGVkL3V0aWxzJykuaW1wbEZvcldyYXBwZXI7XG4gIGZhYnJpYy5ub2RlQ2FudmFzID0gcmVxdWlyZSgnanNkb20vbGliL2pzZG9tL3V0aWxzJykuQ2FudmFzO1xuICBmYWJyaWMud2luZG93ID0gdmlydHVhbFdpbmRvdztcbiAgRE9NUGFyc2VyID0gZmFicmljLndpbmRvdy5ET01QYXJzZXI7XG59XG5cbi8qKlxuICogVHJ1ZSB3aGVuIGluIGVudmlyb25tZW50IHRoYXQgc3VwcG9ydHMgdG91Y2ggZXZlbnRzXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbmZhYnJpYy5pc1RvdWNoU3VwcG9ydGVkID0gJ29udG91Y2hzdGFydCcgaW4gZmFicmljLndpbmRvdyB8fCAnb250b3VjaHN0YXJ0JyBpbiBmYWJyaWMuZG9jdW1lbnQgfHxcbiAgKGZhYnJpYy53aW5kb3cgJiYgZmFicmljLndpbmRvdy5uYXZpZ2F0b3IgJiYgZmFicmljLndpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwKTtcblxuLyoqXG4gKiBUcnVlIHdoZW4gaW4gZW52aXJvbm1lbnQgdGhhdCdzIHByb2JhYmx5IE5vZGUuanNcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xuZmFicmljLmlzTGlrZWx5Tm9kZSA9IHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5cbi8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbi8qKlxuICogQXR0cmlidXRlcyBwYXJzZWQgZnJvbSBhbGwgU1ZHIGVsZW1lbnRzXG4gKiBAdHlwZSBhcnJheVxuICovXG5mYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMgPSBbXG4gICdkaXNwbGF5JyxcbiAgJ3RyYW5zZm9ybScsXG4gICdmaWxsJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLFxuICAnb3BhY2l0eScsXG4gICdzdHJva2UnLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtZGFzaG9mZnNldCcsXG4gICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJyxcbiAgJ2lkJywgJ3BhaW50LW9yZGVyJywgJ3ZlY3Rvci1lZmZlY3QnLFxuICAnaW5zdGFudGlhdGVkX2J5X3VzZScsICdjbGlwLXBhdGgnLFxuXTtcbi8qIF9GUk9NX1NWR19FTkRfICovXG5cbi8qKlxuICogUGl4ZWwgcGVyIEluY2ggYXMgYSBkZWZhdWx0IHZhbHVlIHNldCB0byA5Ni4gQ2FuIGJlIGNoYW5nZWQgZm9yIG1vcmUgcmVhbGlzdGljIGNvbnZlcnNpb24uXG4gKi9cbmZhYnJpYy5EUEkgPSA5NjtcbmZhYnJpYy5yZU51bSA9ICcoPzpbLStdPyg/OlxcXFxkK3xcXFxcZCpcXFxcLlxcXFxkKykoPzpbZUVdWy0rXT9cXFxcZCspPyknO1xuZmFicmljLmNvbW1hV3NwID0gJyg/OlxcXFxzKyw/XFxcXHMqfCxcXFxccyopJztcbmZhYnJpYy5yZVBhdGhDb21tYW5kID0gLyhbLStdPygoXFxkK1xcLlxcZCspfCgoXFxkKyl8KFxcLlxcZCspKSkoPzpbZUVdWy0rXT9cXGQrKT8pL2lnO1xuZmFicmljLnJlTm9uV29yZCA9IC9bIFxcblxcLiw7IVxcP1xcLV0vO1xuZmFicmljLmZvbnRQYXRocyA9IHsgfTtcbmZhYnJpYy5pTWF0cml4ID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuZmFicmljLnN2Z05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxuLyoqXG4gKiBQaXhlbCBsaW1pdCBmb3IgY2FjaGUgY2FudmFzZXMuIDFNcHggLCA0TXB4IHNob3VsZCBiZSBmaW5lLlxuICogQHNpbmNlIDEuNy4xNFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMucGVyZkxpbWl0U2l6ZVRvdGFsID0gMjA5NzE1MjtcblxuLyoqXG4gKiBQaXhlbCBsaW1pdCBmb3IgY2FjaGUgY2FudmFzZXMgd2lkdGggb3IgaGVpZ2h0LiBJRSBmaXhlcyB0aGUgbWF4aW11bSBhdCA1MDAwXG4gKiBAc2luY2UgMS43LjE0XG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBkZWZhdWx0XG4gKi9cbmZhYnJpYy5tYXhDYWNoZVNpZGVMaW1pdCA9IDQwOTY7XG5cbi8qKlxuICogTG93ZXN0IHBpeGVsIGxpbWl0IGZvciBjYWNoZSBjYW52YXNlcywgc2V0IGF0IDI1NlBYXG4gKiBAc2luY2UgMS43LjE0XG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBkZWZhdWx0XG4gKi9cbmZhYnJpYy5taW5DYWNoZVNpZGVMaW1pdCA9IDI1NjtcblxuLyoqXG4gKiBDYWNoZSBPYmplY3QgZm9yIHdpZHRocyBvZiBjaGFycyBpbiB0ZXh0IHJlbmRlcmluZy5cbiAqL1xuZmFicmljLmNoYXJXaWR0aHNDYWNoZSA9IHsgfTtcblxuLyoqXG4gKiBpZiB3ZWJnbCBpcyBlbmFibGVkIGFuZCBhdmFpbGFibGUsIHRleHR1cmVTaXplIHdpbGwgZGV0ZXJtaW5lIHRoZSBzaXplXG4gKiBvZiB0aGUgY2FudmFzIGJhY2tlbmRcbiAqIEBzaW5jZSAyLjAuMFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMudGV4dHVyZVNpemUgPSAyMDQ4O1xuXG4vKipcbiAqIFdoZW4gJ3RydWUnLCBzdHlsZSBpbmZvcm1hdGlvbiBpcyBub3QgcmV0YWluZWQgd2hlbiBjb3B5L3Bhc3RpbmcgdGV4dCwgbWFraW5nXG4gKiBwYXN0ZWQgdGV4dCB1c2UgZGVzdGluYXRpb24gc3R5bGUuXG4gKiBEZWZhdWx0cyB0byAnZmFsc2UnLlxuICogQHR5cGUgQm9vbGVhblxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLmRpc2FibGVTdHlsZUNvcHlQYXN0ZSA9IGZhbHNlO1xuXG4vKipcbiAqIEVuYWJsZSB3ZWJnbCBmb3IgZmlsdGVyaW5nIHBpY3R1cmUgaXMgYXZhaWxhYmxlXG4gKiBBIGZpbHRlcmluZyBiYWNrZW5kIHdpbGwgYmUgaW5pdGlhbGl6ZWQsIHRoaXMgd2lsbCBib3RoIHRha2UgbWVtb3J5IGFuZFxuICogdGltZSBzaW5jZSBhIGRlZmF1bHQgMjA0OHgyMDQ4IGNhbnZhcyB3aWxsIGJlIGNyZWF0ZWQgZm9yIHRoZSBnbCBjb250ZXh0XG4gKiBAc2luY2UgMi4wLjBcbiAqIEB0eXBlIEJvb2xlYW5cbiAqIEBkZWZhdWx0XG4gKi9cbmZhYnJpYy5lbmFibGVHTEZpbHRlcmluZyA9IHRydWU7XG5cbi8qKlxuICogRGV2aWNlIFBpeGVsIFJhdGlvXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L3NhZmFyaS9kb2N1bWVudGF0aW9uL0F1ZGlvVmlkZW8vQ29uY2VwdHVhbC9IVE1MLWNhbnZhcy1ndWlkZS9TZXR0aW5nVXB0aGVDYW52YXMvU2V0dGluZ1VwdGhlQ2FudmFzLmh0bWxcbiAqL1xuZmFicmljLmRldmljZVBpeGVsUmF0aW8gPSBmYWJyaWMud2luZG93LmRldmljZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmFicmljLndpbmRvdy53ZWJraXREZXZpY2VQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cubW96RGV2aWNlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAxO1xuLyoqXG4gKiBCcm93c2VyLXNwZWNpZmljIGNvbnN0YW50IHRvIGFkanVzdCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQuc2hhZG93Qmx1ciB2YWx1ZSxcbiAqIHdoaWNoIGlzIHVuaXRsZXNzIGFuZCBub3QgcmVuZGVyZWQgZXF1YWxseSBhY3Jvc3MgYnJvd3NlcnMuXG4gKlxuICogVmFsdWVzIHRoYXQgd29yayBxdWl0ZSB3ZWxsIChhcyBvZiBPY3RvYmVyIDIwMTcpIGFyZTpcbiAqIC0gQ2hyb21lOiAxLjVcbiAqIC0gRWRnZTogMS43NVxuICogLSBGaXJlZm94OiAwLjlcbiAqIC0gU2FmYXJpOiAwLjk1XG4gKlxuICogQHNpbmNlIDIuMC4wXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBkZWZhdWx0IDFcbiAqL1xuZmFicmljLmJyb3dzZXJTaGFkb3dCbHVyQ29uc3RhbnQgPSAxO1xuXG4vKipcbiAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgYXJjIHRvIGJlemllciBjb252ZXJzaW9uIGZvciBmYXN0ZXIgcmV0cmlldmluZyBpZiB0aGUgc2FtZSBhcmMgbmVlZHMgdG8gYmUgY29udmVydGVkIGFnYWluLlxuICogSXQgd2FzIGFuIGludGVybmFsIHZhcmlhYmxlLCBpcyBhY2Nlc3NpYmxlIHNpbmNlIHZlcnNpb24gMi4zLjRcbiAqL1xuZmFicmljLmFyY1RvU2VnbWVudHNDYWNoZSA9IHsgfTtcblxuLyoqXG4gKiBUaGlzIG9iamVjdCBrZWVwcyB0aGUgcmVzdWx0cyBvZiB0aGUgYm91bmRzT2ZDdXJ2ZSBjYWxjdWxhdGlvbiBtYXBwZWQgYnkgdGhlIGpvaW5lZCBhcmd1bWVudHMgbmVjZXNzYXJ5IHRvIGNhbGN1bGF0ZSBpdC5cbiAqIEl0IGRvZXMgc3BlZWQgdXAgY2FsY3VsYXRpb24sIGlmIHlvdSBwYXJzZSBhbmQgYWRkIGFsd2F5cyB0aGUgc2FtZSBwYXRocywgYnV0IGluIGNhc2Ugb2YgaGVhdnkgdXNhZ2Ugb2YgZnJlZWRyYXdpbmdcbiAqIHlvdSBkbyBub3QgZ2V0IGFueSBzcGVlZCBiZW5lZml0IGFuZCB5b3UgZ2V0IGEgYmlnIG9iamVjdCBpbiBtZW1vcnkuXG4gKiBUaGUgb2JqZWN0IHdhcyBhIHByaXZhdGUgdmFyaWFibGUgYmVmb3JlLCB3aGlsZSBub3cgaXMgYXBwZW5kZWQgdG8gdGhlIGxpYiBzbyB0aGF0IHlvdSBoYXZlIGFjY2VzcyB0byBpdCBhbmQgeW91XG4gKiBjYW4gZXZlbnR1YWxseSBjbGVhciBpdC5cbiAqIEl0IHdhcyBhbiBpbnRlcm5hbCB2YXJpYWJsZSwgaXMgYWNjZXNzaWJsZSBzaW5jZSB2ZXJzaW9uIDIuMy40XG4gKi9cbmZhYnJpYy5ib3VuZHNPZkN1cnZlQ2FjaGUgPSB7IH07XG5cbi8qKlxuICogSWYgZGlzYWJsZWQgYm91bmRzT2ZDdXJ2ZUNhY2hlIGlzIG5vdCB1c2VkLiBGb3IgYXBwcyB0aGF0IG1ha2UgaGVhdnkgdXNhZ2Ugb2YgcGVuY2lsIGRyYXdpbmcgcHJvYmFibHkgZGlzYWJsaW5nIGl0IGlzIGJldHRlclxuICogQGRlZmF1bHQgdHJ1ZVxuICovXG5mYWJyaWMuY2FjaGVzQm91bmRzT2ZDdXJ2ZSA9IHRydWU7XG5cbi8qKlxuICogU2tpcCBwZXJmb3JtYW5jZSB0ZXN0aW5nIG9mIHNldHVwR0xDb250ZXh0IGFuZCBmb3JjZSB0aGUgdXNlIG9mIHB1dEltYWdlRGF0YSB0aGF0IHNlZW1zIHRvIGJlIHRoZSBvbmUgdGhhdCB3b3JrcyBiZXN0IG9uXG4gKiBDaHJvbWUgKyBvbGQgaGFyZHdhcmUuIGlmIHlvdXIgdXNlcnMgYXJlIGV4cGVyaWVuY2luZyBlbXB0eSBpbWFnZXMgYWZ0ZXIgZmlsdGVyaW5nIHlvdSBtYXkgdHJ5IHRvIGZvcmNlIHRoaXMgdG8gdHJ1ZVxuICogdGhpcyBoYXMgdG8gYmUgc2V0IGJlZm9yZSBpbnN0YW50aWF0aW5nIHRoZSBmaWx0ZXJpbmcgYmFja2VuZCAoIGJlZm9yZSBmaWx0ZXJpbmcgdGhlIGZpcnN0IGltYWdlIClcbiAqIEB0eXBlIEJvb2xlYW5cbiAqIEBkZWZhdWx0IGZhbHNlXG4gKi9cbmZhYnJpYy5mb3JjZUdMUHV0SW1hZ2VEYXRhID0gZmFsc2U7XG5cbmZhYnJpYy5pbml0RmlsdGVyQmFja2VuZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoZmFicmljLmVuYWJsZUdMRmlsdGVyaW5nICYmIGZhYnJpYy5pc1dlYmdsU3VwcG9ydGVkICYmIGZhYnJpYy5pc1dlYmdsU3VwcG9ydGVkKGZhYnJpYy50ZXh0dXJlU2l6ZSkpIHtcbiAgICBjb25zb2xlLmxvZygnbWF4IHRleHR1cmUgc2l6ZTogJyArIGZhYnJpYy5tYXhUZXh0dXJlU2l6ZSk7XG4gICAgcmV0dXJuIChuZXcgZmFicmljLldlYmdsRmlsdGVyQmFja2VuZCh7IHRpbGVTaXplOiBmYWJyaWMudGV4dHVyZVNpemUgfSkpO1xuICB9XG4gIGVsc2UgaWYgKGZhYnJpYy5DYW52YXMyZEZpbHRlckJhY2tlbmQpIHtcbiAgICByZXR1cm4gKG5ldyBmYWJyaWMuQ2FudmFzMmRGaWx0ZXJCYWNrZW5kKCkpO1xuICB9XG59O1xuXG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIGVuc3VyZSBnbG9iYWxpdHkgZXZlbiBpZiBlbnRpcmUgbGlicmFyeSB3ZXJlIGZ1bmN0aW9uIHdyYXBwZWQgKGFzIGluIE1ldGVvci5qcyBwYWNrYWdpbmcgc3lzdGVtKVxuICB3aW5kb3cuZmFicmljID0gZmFicmljO1xufVxuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBfcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBldmVudExpc3RlbmVyID0gdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGV2ZW50TGlzdGVuZXJbZXZlbnRMaXN0ZW5lci5pbmRleE9mKGhhbmRsZXIpXSA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZhYnJpYy51dGlsLmFycmF5LmZpbGwoZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlcyBzcGVjaWZpZWQgZXZlbnRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBhbGlhcyBvblxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50TmFtZSBFdmVudCBuYW1lIChlZy4gJ2FmdGVyOnJlbmRlcicpIG9yIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyAoZWcuIHsnYWZ0ZXI6cmVuZGVyJzogaGFuZGxlciwgJ3NlbGVjdGlvbjpjbGVhcmVkJzogaGFuZGxlcn0pXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzID0geyB9O1xuICAgIH1cbiAgICAvLyBvbmUgb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIHdhcyBwYXNzZWRcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgdGhpcy5vbihwcm9wLCBldmVudE5hbWVbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gX29uY2UoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgdmFyIF9oYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5vZmYoZXZlbnROYW1lLCBfaGFuZGxlcik7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub24oZXZlbnROYW1lLCBfaGFuZGxlcik7XG4gIH1cblxuICBmdW5jdGlvbiBvbmNlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIC8vIG9uZSBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgd2FzIHBhc3NlZFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGV2ZW50TmFtZSkge1xuICAgICAgICBfb25jZS5jYWxsKHRoaXMsIHByb3AsIGV2ZW50TmFtZVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgX29uY2UuY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBldmVudCBvYnNlcnZpbmcgZm9yIGEgcGFydGljdWxhciBldmVudCBoYW5kbGVyLiBDYWxsaW5nIHRoaXMgbWV0aG9kXG4gICAqIHdpdGhvdXQgYXJndW1lbnRzIHJlbW92ZXMgYWxsIGhhbmRsZXJzIGZvciBhbGwgZXZlbnRzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAYWxpYXMgb2ZmXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXZlbnROYW1lIEV2ZW50IG5hbWUgKGVnLiAnYWZ0ZXI6cmVuZGVyJykgb3Igb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIChlZy4geydhZnRlcjpyZW5kZXInOiBoYW5kbGVyLCAnc2VsZWN0aW9uOmNsZWFyZWQnOiBoYW5kbGVyfSlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBGdW5jdGlvbiB0byBiZSBkZWxldGVkIGZyb20gRXZlbnRMaXN0ZW5lcnNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmdW5jdGlvbiBvZmYoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbGwga2V5L3ZhbHVlIHBhaXJzIChldmVudCBuYW1lIC0+IGV2ZW50IGhhbmRsZXIpXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGZvciAoZXZlbnROYW1lIGluIHRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9uZSBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgd2FzIHBhc3NlZFxuICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIF9yZW1vdmVFdmVudExpc3RlbmVyLmNhbGwodGhpcywgcHJvcCwgZXZlbnROYW1lW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIGV2ZW50IHdpdGggYW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3RcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgRXZlbnQgbmFtZSB0byBmaXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmdW5jdGlvbiBmaXJlKGV2ZW50TmFtZSwgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzRm9yRXZlbnQgPSB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICBpZiAoIWxpc3RlbmVyc0ZvckV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzRm9yRXZlbnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc0ZvckV2ZW50W2ldICYmIGxpc3RlbmVyc0ZvckV2ZW50W2ldLmNhbGwodGhpcywgb3B0aW9ucyB8fCB7IH0pO1xuICAgIH1cbiAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSA9IGxpc3RlbmVyc0ZvckV2ZW50LmZpbHRlcihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2V2ZW50c31cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9ldmVudHN8RXZlbnRzIGRlbW99XG4gICAqL1xuICBmYWJyaWMuT2JzZXJ2YWJsZSA9IHtcbiAgICBmaXJlOiBmaXJlLFxuICAgIG9uOiBvbixcbiAgICBvbmNlOiBvbmNlLFxuICAgIG9mZjogb2ZmLFxuICB9O1xufSkoKTtcblxuXG4vKipcbiAqIEBuYW1lc3BhY2UgZmFicmljLkNvbGxlY3Rpb25cbiAqL1xuZmFicmljLkNvbGxlY3Rpb24gPSB7XG5cbiAgX29iamVjdHM6IFtdLFxuXG4gIC8qKlxuICAgKiBBZGRzIG9iamVjdHMgdG8gY29sbGVjdGlvbiwgQ2FudmFzIG9yIEdyb3VwLCB0aGVuIHJlbmRlcnMgY2FudmFzXG4gICAqIChpZiBgcmVuZGVyT25BZGRSZW1vdmVgIGlzIG5vdCBgZmFsc2VgKS5cbiAgICogaW4gY2FzZSBvZiBHcm91cCBubyBjaGFuZ2VzIHRvIGJvdW5kaW5nIGJveCBhcmUgbWFkZS5cbiAgICogT2JqZWN0cyBzaG91bGQgYmUgaW5zdGFuY2VzIG9mIChvciBpbmhlcml0IGZyb20pIGZhYnJpYy5PYmplY3RcbiAgICogVXNlIG9mIHRoaXMgZnVuY3Rpb24gaXMgaGlnaGx5IGRpc2NvdXJhZ2VkIGZvciBncm91cHMuXG4gICAqIHlvdSBjYW4gYWRkIGEgYnVuY2ggb2Ygb2JqZWN0cyB3aXRoIHRoZSBhZGQgbWV0aG9kIGJ1dCB0aGVuIHlvdSBORUVEXG4gICAqIHRvIHJ1biBhIGFkZFdpdGhVcGRhdGUgY2FsbCBmb3IgdGhlIEdyb3VwIGNsYXNzIG9yIHBvc2l0aW9uL2Jib3ggd2lsbCBiZSB3cm9uZy5cbiAgICogQHBhcmFtIHsuLi5mYWJyaWMuT2JqZWN0fSBvYmplY3QgWmVybyBvciBtb3JlIGZhYnJpYyBpbnN0YW5jZXNcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBhZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9vYmplY3RzLnB1c2guYXBwbHkodGhpcy5fb2JqZWN0cywgYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5fb25PYmplY3RBZGRlZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9vbk9iamVjdEFkZGVkKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluc2VydHMgYW4gb2JqZWN0IGludG8gY29sbGVjdGlvbiBhdCBzcGVjaWZpZWQgaW5kZXgsIHRoZW4gcmVuZGVycyBjYW52YXMgKGlmIGByZW5kZXJPbkFkZFJlbW92ZWAgaXMgbm90IGBmYWxzZWApXG4gICAqIEFuIG9iamVjdCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgKG9yIGluaGVyaXQgZnJvbSkgZmFicmljLk9iamVjdFxuICAgKiBVc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyBoaWdobHkgZGlzY291cmFnZWQgZm9yIGdyb3Vwcy5cbiAgICogeW91IGNhbiBhZGQgYSBidW5jaCBvZiBvYmplY3RzIHdpdGggdGhlIGluc2VydEF0IG1ldGhvZCBidXQgdGhlbiB5b3UgTkVFRFxuICAgKiB0byBydW4gYSBhZGRXaXRoVXBkYXRlIGNhbGwgZm9yIHRoZSBHcm91cCBjbGFzcyBvciBwb3NpdGlvbi9iYm94IHdpbGwgYmUgd3JvbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGluc2VydFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gaW5zZXJ0IG9iamVjdCBhdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5vblNwbGljaW5nIFdoZW4gYHRydWVgLCBubyBzcGxpY2luZyAoc2hpZnRpbmcpIG9mIG9iamVjdHMgb2NjdXJzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgaW5zZXJ0QXQ6IGZ1bmN0aW9uIChvYmplY3QsIGluZGV4LCBub25TcGxpY2luZykge1xuICAgIHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cztcbiAgICBpZiAobm9uU3BsaWNpbmcpIHtcbiAgICAgIG9iamVjdHNbaW5kZXhdID0gb2JqZWN0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG9iamVjdHMuc3BsaWNlKGluZGV4LCAwLCBvYmplY3QpO1xuICAgIH1cbiAgICB0aGlzLl9vbk9iamVjdEFkZGVkICYmIHRoaXMuX29uT2JqZWN0QWRkZWQob2JqZWN0KTtcbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIG9iamVjdHMgZnJvbSBhIGNvbGxlY3Rpb24sIHRoZW4gcmVuZGVycyBjYW52YXMgKGlmIGByZW5kZXJPbkFkZFJlbW92ZWAgaXMgbm90IGBmYWxzZWApXG4gICAqIEBwYXJhbSB7Li4uZmFicmljLk9iamVjdH0gb2JqZWN0IFplcm8gb3IgbW9yZSBmYWJyaWMgaW5zdGFuY2VzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG4gICAgICAgIGluZGV4LCBzb21ldGhpbmdSZW1vdmVkID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpbmRleCA9IG9iamVjdHMuaW5kZXhPZihhcmd1bWVudHNbaV0pO1xuXG4gICAgICAvLyBvbmx5IGNhbGwgb25PYmplY3RSZW1vdmVkIGlmIGFuIG9iamVjdCB3YXMgYWN0dWFsbHkgcmVtb3ZlZFxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBzb21ldGhpbmdSZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgb2JqZWN0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLl9vbk9iamVjdFJlbW92ZWQgJiYgdGhpcy5fb25PYmplY3RSZW1vdmVkKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiBzb21ldGhpbmdSZW1vdmVkICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBvYmplY3QgaW4gdGhpcyBncm91cFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiAgICAgICAgICAgICAgICAgICBDYWxsYmFjayBpbnZva2VkIHdpdGggY3VycmVudCBvYmplY3QgYXMgZmlyc3QgYXJndW1lbnQsXG4gICAqICAgICAgICAgICAgICAgICAgIGluZGV4IC0gYXMgc2Vjb25kIGFuZCBhbiBhcnJheSBvZiBhbGwgb2JqZWN0cyAtIGFzIHRoaXJkLlxuICAgKiAgICAgICAgICAgICAgICAgICBDYWxsYmFjayBpcyBpbnZva2VkIGluIGEgY29udGV4dCBvZiBHbG9iYWwgT2JqZWN0IChlLmcuIGB3aW5kb3dgKVxuICAgKiAgICAgICAgICAgICAgICAgICB3aGVuIG5vIGBjb250ZXh0YCBhcmd1bWVudCBpcyBnaXZlblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBDb250ZXh0IChha2EgdGhpc09iamVjdClcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBmb3JFYWNoT2JqZWN0OiBmdW5jdGlvbihjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHZhciBvYmplY3RzID0gdGhpcy5nZXRPYmplY3RzKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgb2JqZWN0c1tpXSwgaSwgb2JqZWN0cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNoaWxkcmVuIG9iamVjdHMgb2YgdGhpcyBpbnN0YW5jZVxuICAgKiBUeXBlIHBhcmFtZXRlciBpbnRyb2R1Y2VkIGluIDEuMy4xMFxuICAgKiBzaW5jZSAyLjMuNSB0aGlzIG1ldGhvZCByZXR1cm4gYWx3YXlzIGEgQ09QWSBvZiB0aGUgYXJyYXk7XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gV2hlbiBzcGVjaWZpZWQsIG9ubHkgb2JqZWN0cyBvZiB0aGlzIHR5cGUgYXJlIHJldHVybmVkXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZ2V0T2JqZWN0czogZnVuY3Rpb24odHlwZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmNvbmNhdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5maWx0ZXIoZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuIG8udHlwZSA9PT0gdHlwZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBvYmplY3QgYXQgc3BlY2lmaWVkIGluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqL1xuICBpdGVtOiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0c1tpbmRleF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjb2xsZWN0aW9uIGNvbnRhaW5zIG5vIG9iamVjdHNcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBjb2xsZWN0aW9uIGlzIGVtcHR5XG4gICAqL1xuICBpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMubGVuZ3RoID09PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2l6ZSBvZiBhIGNvbGxlY3Rpb24gKGkuZTogbGVuZ3RoIG9mIGFuIGFycmF5IGNvbnRhaW5pbmcgaXRzIG9iamVjdHMpXG4gICAqIEByZXR1cm4ge051bWJlcn0gQ29sbGVjdGlvbiBzaXplXG4gICAqL1xuICBzaXplOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjb2xsZWN0aW9uIGNvbnRhaW5zIGFuIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjaGVjayBhZ2FpbnN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlZXA9ZmFsc2VdIGB0cnVlYCB0byBjaGVjayBhbGwgZGVzY2VuZGFudHMsIGBmYWxzZWAgdG8gY2hlY2sgb25seSBgX29iamVjdHNgXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBjb2xsZWN0aW9uIGNvbnRhaW5zIGFuIG9iamVjdFxuICAgKi9cbiAgY29udGFpbnM6IGZ1bmN0aW9uIChvYmplY3QsIGRlZXApIHtcbiAgICBpZiAodGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iamVjdCkgPiAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZXApIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmplY3RzLnNvbWUoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iai5jb250YWlucyA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29udGFpbnMob2JqZWN0LCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgbnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIGEgY29sbGVjdGlvbiBjb21wbGV4aXR5XG4gICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eVxuICAgKi9cbiAgY29tcGxleGl0eTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3RzLnJlZHVjZShmdW5jdGlvbiAobWVtbywgY3VycmVudCkge1xuICAgICAgbWVtbyArPSBjdXJyZW50LmNvbXBsZXhpdHkgPyBjdXJyZW50LmNvbXBsZXhpdHkoKSA6IDA7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCAwKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBuYW1lc3BhY2UgZmFicmljLkNvbW1vbk1ldGhvZHNcbiAqL1xuZmFicmljLkNvbW1vbk1ldGhvZHMgPSB7XG5cbiAgLyoqXG4gICAqIFNldHMgb2JqZWN0J3MgcHJvcGVydGllcyBmcm9tIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgX3NldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2V0KHByb3AsIG9wdGlvbnNbcHJvcF0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtmaWxsZXJdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIHByb3BlcnR5IHRvIHNldCB0aGUgR3JhZGllbnQgdG9cbiAgICovXG4gIF9pbml0R3JhZGllbnQ6IGZ1bmN0aW9uKGZpbGxlciwgcHJvcGVydHkpIHtcbiAgICBpZiAoZmlsbGVyICYmIGZpbGxlci5jb2xvclN0b3BzICYmICEoZmlsbGVyIGluc3RhbmNlb2YgZmFicmljLkdyYWRpZW50KSkge1xuICAgICAgdGhpcy5zZXQocHJvcGVydHksIG5ldyBmYWJyaWMuR3JhZGllbnQoZmlsbGVyKSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2ZpbGxlcl0gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gcHJvcGVydHkgdG8gc2V0IHRoZSBQYXR0ZXJuIHRvXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgdG8gaW52b2tlIGFmdGVyIHBhdHRlcm4gbG9hZFxuICAgKi9cbiAgX2luaXRQYXR0ZXJuOiBmdW5jdGlvbihmaWxsZXIsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgIGlmIChmaWxsZXIgJiYgZmlsbGVyLnNvdXJjZSAmJiAhKGZpbGxlciBpbnN0YW5jZW9mIGZhYnJpYy5QYXR0ZXJuKSkge1xuICAgICAgdGhpcy5zZXQocHJvcGVydHksIG5ldyBmYWJyaWMuUGF0dGVybihmaWxsZXIsIGNhbGxiYWNrKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0T2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgdGhpcy5fc2V0KHByb3AsIG9ialtwcm9wXSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHByb3BlcnR5IHRvIGEgZ2l2ZW4gdmFsdWUuIFdoZW4gY2hhbmdpbmcgcG9zaXRpb24vZGltZW5zaW9uIC1yZWxhdGVkIHByb3BlcnRpZXMgKGxlZnQsIHRvcCwgc2NhbGUsIGFuZ2xlLCBldGMuKSBgc2V0YCBkb2VzIG5vdCB1cGRhdGUgcG9zaXRpb24gb2Ygb2JqZWN0J3MgYm9yZGVycy9jb250cm9scy4gSWYgeW91IG5lZWQgdG8gdXBkYXRlIHRob3NlLCBjYWxsIGBzZXRDb29yZHMoKWAuXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ga2V5IFByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IChpZiBvYmplY3QsIGl0ZXJhdGUgb3ZlciB0aGUgb2JqZWN0IHByb3BlcnRpZXMpXG4gICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSAoaWYgZnVuY3Rpb24sIHRoZSB2YWx1ZSBpcyBwYXNzZWQgaW50byBpdCBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyB1c2VkIGFzIGEgbmV3IG9uZSlcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuX3NldE9iamVjdChrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3NldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHNwZWNpZmllZCBwcm9wZXJ0eSBmcm9tIGB0cnVlYCB0byBgZmFsc2VgIG9yIGZyb20gYGZhbHNlYCB0byBgdHJ1ZWBcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHRvZ2dsZVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHRvZ2dsZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChwcm9wZXJ0eSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aGlzLnNldChwcm9wZXJ0eSwgIXZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJhc2ljIGdldHRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgKiBAcmV0dXJuIHsqfSB2YWx1ZSBvZiBhIHByb3BlcnR5XG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHRoaXNbcHJvcGVydHldO1xuICB9XG59O1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICB2YXIgc3FydCA9IE1hdGguc3FydCxcbiAgICAgIGF0YW4yID0gTWF0aC5hdGFuMixcbiAgICAgIHBvdyA9IE1hdGgucG93LFxuICAgICAgUGlCeTE4MCA9IE1hdGguUEkgLyAxODAsXG4gICAgICBQaUJ5MiA9IE1hdGguUEkgLyAyO1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsXG4gICAqL1xuICBmYWJyaWMudXRpbCA9IHtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgY29zIG9mIGFuIGFuZ2xlLCBhdm9pZGluZyByZXR1cm5pbmcgZmxvYXRzIGZvciBrbm93biByZXN1bHRzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSB0aGUgYW5nbGUgaW4gcmFkaWFucyBvciBpbiBkZWdyZWVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgY29zOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7IHJldHVybiAxOyB9XG4gICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgIC8vIGNvcyhhKSA9IGNvcygtYSlcbiAgICAgICAgYW5nbGUgPSAtYW5nbGU7XG4gICAgICB9XG4gICAgICB2YXIgYW5nbGVTbGljZSA9IGFuZ2xlIC8gUGlCeTI7XG4gICAgICBzd2l0Y2ggKGFuZ2xlU2xpY2UpIHtcbiAgICAgICAgY2FzZSAxOiBjYXNlIDM6IHJldHVybiAwO1xuICAgICAgICBjYXNlIDI6IHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgc2luIG9mIGFuIGFuZ2xlLCBhdm9pZGluZyByZXR1cm5pbmcgZmxvYXRzIGZvciBrbm93biByZXN1bHRzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSB0aGUgYW5nbGUgaW4gcmFkaWFucyBvciBpbiBkZWdyZWVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgc2luOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7IHJldHVybiAwOyB9XG4gICAgICB2YXIgYW5nbGVTbGljZSA9IGFuZ2xlIC8gUGlCeTIsIHNpZ24gPSAxO1xuICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAvLyBzaW4oLWEpID0gLXNpbihhKVxuICAgICAgICBzaWduID0gLTE7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGFuZ2xlU2xpY2UpIHtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gc2lnbjtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gMDtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gLXNpZ247XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5zaW4oYW5nbGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHZhbHVlIGZyb20gYW4gYXJyYXkuXG4gICAgICogUHJlc2VuY2Ugb2YgdmFsdWUgKGFuZCBpdHMgcG9zaXRpb24gaW4gYW4gYXJyYXkpIGlzIGRldGVybWluZWQgdmlhIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmBcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7QXJyYXl9IG9yaWdpbmFsIGFycmF5XG4gICAgICovXG4gICAgcmVtb3ZlRnJvbUFycmF5OiBmdW5jdGlvbihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBpZHggPSBhcnJheS5pbmRleE9mKHZhbHVlKTtcbiAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIGFycmF5LnNwbGljZShpZHgsIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHJhbmRvbSBudW1iZXIgYmV0d2VlbiAyIHNwZWNpZmllZCBvbmVzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluIGxvd2VyIGxpbWl0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heCB1cHBlciBsaW1pdFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gcmFuZG9tIHZhbHVlIChiZXR3ZWVuIG1pbiBhbmQgbWF4KVxuICAgICAqL1xuICAgIGdldFJhbmRvbUludDogZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGRlZ3JlZXMgdG8gcmFkaWFucy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlZ3JlZXMgdmFsdWUgaW4gZGVncmVlc1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gdmFsdWUgaW4gcmFkaWFuc1xuICAgICAqL1xuICAgIGRlZ3JlZXNUb1JhZGlhbnM6IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcbiAgICAgIHJldHVybiBkZWdyZWVzICogUGlCeTE4MDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyByYWRpYW5zIHRvIGRlZ3JlZXMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpYW5zIHZhbHVlIGluIHJhZGlhbnNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHZhbHVlIGluIGRlZ3JlZXNcbiAgICAgKi9cbiAgICByYWRpYW5zVG9EZWdyZWVzOiBmdW5jdGlvbihyYWRpYW5zKSB7XG4gICAgICByZXR1cm4gcmFkaWFucyAvIFBpQnkxODA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgYHBvaW50YCBhcm91bmQgYG9yaWdpbmAgd2l0aCBgcmFkaWFuc2BcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB0byByb3RhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gb3JpZ2luIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGlhbnMgVGhlIHJhZGlhbnMgb2YgdGhlIGFuZ2xlIGZvciB0aGUgcm90YXRpb25cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IFRoZSBuZXcgcm90YXRlZCBwb2ludFxuICAgICAqL1xuICAgIHJvdGF0ZVBvaW50OiBmdW5jdGlvbihwb2ludCwgb3JpZ2luLCByYWRpYW5zKSB7XG4gICAgICB2YXIgbmV3UG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50LnggLSBvcmlnaW4ueCwgcG9pbnQueSAtIG9yaWdpbi55KSxcbiAgICAgICAgICB2ID0gZmFicmljLnV0aWwucm90YXRlVmVjdG9yKG5ld1BvaW50LCByYWRpYW5zKTtcbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KHYueCwgdi55KS5hZGRFcXVhbHMob3JpZ2luKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyBgdmVjdG9yYCB3aXRoIGByYWRpYW5zYFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmVjdG9yIFRoZSB2ZWN0b3IgdG8gcm90YXRlICh4IGFuZCB5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpYW5zIFRoZSByYWRpYW5zIG9mIHRoZSBhbmdsZSBmb3IgdGhlIHJvdGF0aW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IHJvdGF0ZWQgcG9pbnRcbiAgICAgKi9cbiAgICByb3RhdGVWZWN0b3I6IGZ1bmN0aW9uKHZlY3RvciwgcmFkaWFucykge1xuICAgICAgdmFyIHNpbiA9IGZhYnJpYy51dGlsLnNpbihyYWRpYW5zKSxcbiAgICAgICAgICBjb3MgPSBmYWJyaWMudXRpbC5jb3MocmFkaWFucyksXG4gICAgICAgICAgcnggPSB2ZWN0b3IueCAqIGNvcyAtIHZlY3Rvci55ICogc2luLFxuICAgICAgICAgIHJ5ID0gdmVjdG9yLnggKiBzaW4gKyB2ZWN0b3IueSAqIGNvcztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJ4LFxuICAgICAgICB5OiByeVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHZldG9yIGZyb20gcG9pbnRzIHJlcHJlc2VudGVkIGFzIGEgcG9pbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICpcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBQb2ludFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGZyb21cbiAgICAgKiBAcGFyYW0ge1BvaW50fSB0b1xuICAgICAqIEByZXR1cm5zIHtQb2ludH0gdmVjdG9yXG4gICAgICovXG4gICAgY3JlYXRlVmVjdG9yOiBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KHRvLnggLSBmcm9tLngsIHRvLnkgLSBmcm9tLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGFuZ2xlIGJldHdlZW4gMiB2ZWN0b3JzIHVzaW5nIGRvdCBwcm9kdWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGFcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBiXG4gICAgICogQHJldHVybnMgdGhlIGFuZ2xlIGluIHJhZGlhbiBiZXR3ZWVuIHRoZSB2ZWN0b3JzXG4gICAgICovXG4gICAgY2FsY0FuZ2xlQmV0d2VlblZlY3RvcnM6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gTWF0aC5hY29zKChhLnggKiBiLnggKyBhLnkgKiBiLnkpIC8gKE1hdGguaHlwb3QoYS54LCBhLnkpICogTWF0aC5oeXBvdChiLngsIGIueSkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHZcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIHVuaXQgdmVjdG9yIG9mIHBvaW50aW5nIHRvIHRoZSBkaXJlY3Rpb24gb2YgYHZgXG4gICAgICovXG4gICAgZ2V0SGF0VmVjdG9yOiBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQodi54LCB2LnkpLm11bHRpcGx5KDEgLyBNYXRoLmh5cG90KHYueCwgdi55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBBXG4gICAgICogQHBhcmFtIHtQb2ludH0gQlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IENcbiAgICAgKiBAcmV0dXJucyB7eyB2ZWN0b3I6IFBvaW50LCBhbmdsZTogbnVtYmVyIH19IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGJpc2VjdG9yIG9mIEEgYW5kIEEncyBhbmdsZVxuICAgICAqL1xuICAgIGdldEJpc2VjdG9yOiBmdW5jdGlvbiAoQSwgQiwgQykge1xuICAgICAgdmFyIEFCID0gZmFicmljLnV0aWwuY3JlYXRlVmVjdG9yKEEsIEIpLCBBQyA9IGZhYnJpYy51dGlsLmNyZWF0ZVZlY3RvcihBLCBDKTtcbiAgICAgIHZhciBhbHBoYSA9IGZhYnJpYy51dGlsLmNhbGNBbmdsZUJldHdlZW5WZWN0b3JzKEFCLCBBQyk7XG4gICAgICAvLyAgY2hlY2sgaWYgYWxwaGEgaXMgcmVsYXRpdmUgdG8gQUItPkJDXG4gICAgICB2YXIgcm8gPSBmYWJyaWMudXRpbC5jYWxjQW5nbGVCZXR3ZWVuVmVjdG9ycyhmYWJyaWMudXRpbC5yb3RhdGVWZWN0b3IoQUIsIGFscGhhKSwgQUMpO1xuICAgICAgdmFyIHBoaSA9IGFscGhhICogKHJvID09PSAwID8gMSA6IC0xKSAvIDI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZWN0b3I6IGZhYnJpYy51dGlsLmdldEhhdFZlY3RvcihmYWJyaWMudXRpbC5yb3RhdGVWZWN0b3IoQUIsIHBoaSkpLFxuICAgICAgICBhbmdsZTogYWxwaGFcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2plY3Qgc3Ryb2tlIHdpZHRoIG9uIHBvaW50cyByZXR1cm5pbmcgMiBwcm9qZWN0aW9ucyBmb3IgZWFjaCBwb2ludCBhcyBmb2xsb3dzOlxuICAgICAqIC0gYG1pdGVyYDogMiBwb2ludHMgY29ycmVzcG9uZGluZyB0byB0aGUgb3V0ZXIgYm91bmRhcnkgYW5kIHRoZSBpbm5lciBib3VuZGFyeSBvZiBzdHJva2UuXG4gICAgICogLSBgYmV2ZWxgOiAyIHBvaW50cyBjb3JyZXNwb25kaW5nIHRvIHRoZSBiZXZlbCBib3VuZGFyaWVzLCB0YW5nZW50IHRvIHRoZSBiaXNlY3Rvci5cbiAgICAgKiAtIGByb3VuZGA6IHNhbWUgYXMgYGJldmVsYFxuICAgICAqIFVzZWQgdG8gY2FsY3VsYXRlIG9iamVjdCdzIGJvdW5kaW5nIGJveFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1BvaW50W119IHBvaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc3Ryb2tlV2lkdGhcbiAgICAgKiBAcGFyYW0geydtaXRlcid8J2JldmVsJ3wncm91bmQnfSBvcHRpb25zLnN0cm9rZUxpbmVKb2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc3Ryb2tlTWl0ZXJMaW1pdCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1taXRlcmxpbWl0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnN0cm9rZVVuaWZvcm1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zY2FsZVhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5zY2FsZVlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcGVuUGF0aF0gd2hldGhlciB0aGUgc2hhcGUgaXMgb3BlbiBvciBub3QsIGFmZmVjdHMgdGhlIGNhbGN1bGF0aW9ucyBvZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzXG4gICAgICogQHJldHVybnMge2ZhYnJpYy5Qb2ludFtdfSBhcnJheSBvZiBzaXplIDJuLzRuIG9mIGFsbCBzdXNwZWN0ZWQgcG9pbnRzXG4gICAgICovXG4gICAgcHJvamVjdFN0cm9rZU9uUG9pbnRzOiBmdW5jdGlvbiAocG9pbnRzLCBvcHRpb25zLCBvcGVuUGF0aCkge1xuICAgICAgdmFyIGNvb3JkcyA9IFtdLCBzID0gb3B0aW9ucy5zdHJva2VXaWR0aCAvIDIsXG4gICAgICAgICAgc3Ryb2tlVW5pZm9ybVNjYWxhciA9IG9wdGlvbnMuc3Ryb2tlVW5pZm9ybSA/XG4gICAgICAgICAgICBuZXcgZmFicmljLlBvaW50KDEgLyBvcHRpb25zLnNjYWxlWCwgMSAvIG9wdGlvbnMuc2NhbGVZKSA6IG5ldyBmYWJyaWMuUG9pbnQoMSwgMSksXG4gICAgICAgICAgZ2V0U3Ryb2tlSGF0VmVjdG9yID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhciBzY2FsYXIgPSBzIC8gKE1hdGguaHlwb3Qodi54LCB2LnkpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KHYueCAqIHNjYWxhciAqIHN0cm9rZVVuaWZvcm1TY2FsYXIueCwgdi55ICogc2NhbGFyICogc3Ryb2tlVW5pZm9ybVNjYWxhci55KTtcbiAgICAgICAgICB9O1xuICAgICAgaWYgKHBvaW50cy5sZW5ndGggPD0gMSkge3JldHVybiBjb29yZHM7fVxuICAgICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHAsIGluZGV4KSB7XG4gICAgICAgIHZhciBBID0gbmV3IGZhYnJpYy5Qb2ludChwLngsIHAueSksIEIsIEM7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIEMgPSBwb2ludHNbaW5kZXggKyAxXTtcbiAgICAgICAgICBCID0gb3BlblBhdGggPyBnZXRTdHJva2VIYXRWZWN0b3IoZmFicmljLnV0aWwuY3JlYXRlVmVjdG9yKEMsIEEpKS5hZGRFcXVhbHMoQSkgOiBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIEIgPSBwb2ludHNbaW5kZXggLSAxXTtcbiAgICAgICAgICBDID0gb3BlblBhdGggPyBnZXRTdHJva2VIYXRWZWN0b3IoZmFicmljLnV0aWwuY3JlYXRlVmVjdG9yKEIsIEEpKS5hZGRFcXVhbHMoQSkgOiBwb2ludHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgQiA9IHBvaW50c1tpbmRleCAtIDFdO1xuICAgICAgICAgIEMgPSBwb2ludHNbaW5kZXggKyAxXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmlzZWN0b3IgPSBmYWJyaWMudXRpbC5nZXRCaXNlY3RvcihBLCBCLCBDKSxcbiAgICAgICAgICAgIGJpc2VjdG9yVmVjdG9yID0gYmlzZWN0b3IudmVjdG9yLFxuICAgICAgICAgICAgYWxwaGEgPSBiaXNlY3Rvci5hbmdsZSxcbiAgICAgICAgICAgIHNjYWxhcixcbiAgICAgICAgICAgIG1pdGVyVmVjdG9yO1xuICAgICAgICBpZiAob3B0aW9ucy5zdHJva2VMaW5lSm9pbiA9PT0gJ21pdGVyJykge1xuICAgICAgICAgIHNjYWxhciA9IC1zIC8gTWF0aC5zaW4oYWxwaGEgLyAyKTtcbiAgICAgICAgICBtaXRlclZlY3RvciA9IG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgICAgICBiaXNlY3RvclZlY3Rvci54ICogc2NhbGFyICogc3Ryb2tlVW5pZm9ybVNjYWxhci54LFxuICAgICAgICAgICAgYmlzZWN0b3JWZWN0b3IueSAqIHNjYWxhciAqIHN0cm9rZVVuaWZvcm1TY2FsYXIueVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKE1hdGguaHlwb3QobWl0ZXJWZWN0b3IueCwgbWl0ZXJWZWN0b3IueSkgLyBzIDw9IG9wdGlvbnMuc3Ryb2tlTWl0ZXJMaW1pdCkge1xuICAgICAgICAgICAgY29vcmRzLnB1c2goQS5hZGQobWl0ZXJWZWN0b3IpKTtcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKEEuc3VidHJhY3QobWl0ZXJWZWN0b3IpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2NhbGFyID0gLXMgKiBNYXRoLlNRUlQyO1xuICAgICAgICBtaXRlclZlY3RvciA9IG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgICAgYmlzZWN0b3JWZWN0b3IueCAqIHNjYWxhciAqIHN0cm9rZVVuaWZvcm1TY2FsYXIueCxcbiAgICAgICAgICBiaXNlY3RvclZlY3Rvci55ICogc2NhbGFyICogc3Ryb2tlVW5pZm9ybVNjYWxhci55XG4gICAgICAgICk7XG4gICAgICAgIGNvb3Jkcy5wdXNoKEEuYWRkKG1pdGVyVmVjdG9yKSk7XG4gICAgICAgIGNvb3Jkcy5wdXNoKEEuc3VidHJhY3QobWl0ZXJWZWN0b3IpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdHJhbnNmb3JtIHQgdG8gcG9pbnQgcFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtmYWJyaWMuUG9pbnR9IHAgVGhlIHBvaW50IHRvIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSAge0FycmF5fSB0IFRoZSB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbaWdub3JlT2Zmc2V0XSBJbmRpY2F0ZXMgdGhhdCB0aGUgb2Zmc2V0IHNob3VsZCBub3QgYmUgYXBwbGllZFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gVGhlIHRyYW5zZm9ybWVkIHBvaW50XG4gICAgICovXG4gICAgdHJhbnNmb3JtUG9pbnQ6IGZ1bmN0aW9uKHAsIHQsIGlnbm9yZU9mZnNldCkge1xuICAgICAgaWYgKGlnbm9yZU9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludChcbiAgICAgICAgICB0WzBdICogcC54ICsgdFsyXSAqIHAueSxcbiAgICAgICAgICB0WzFdICogcC54ICsgdFszXSAqIHAueVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgIHRbMF0gKiBwLnggKyB0WzJdICogcC55ICsgdFs0XSxcbiAgICAgICAgdFsxXSAqIHAueCArIHRbM10gKiBwLnkgKyB0WzVdXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIHBvaW50cydzIGJvdW5kaW5nIHJlY3RhbmdsZSAobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyA0IHBvaW50cyBhcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt0cmFuc2Zvcm1dIGFuIGFycmF5IG9mIDYgbnVtYmVycyByZXByZXNlbnRpbmcgYSAyeDMgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBtYWtlQm91bmRpbmdCb3hGcm9tUG9pbnRzOiBmdW5jdGlvbihwb2ludHMsIHRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBvaW50c1tpXSA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHBvaW50c1tpXSwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHhQb2ludHMgPSBbcG9pbnRzWzBdLngsIHBvaW50c1sxXS54LCBwb2ludHNbMl0ueCwgcG9pbnRzWzNdLnhdLFxuICAgICAgICAgIG1pblggPSBmYWJyaWMudXRpbC5hcnJheS5taW4oeFBvaW50cyksXG4gICAgICAgICAgbWF4WCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heCh4UG9pbnRzKSxcbiAgICAgICAgICB3aWR0aCA9IG1heFggLSBtaW5YLFxuICAgICAgICAgIHlQb2ludHMgPSBbcG9pbnRzWzBdLnksIHBvaW50c1sxXS55LCBwb2ludHNbMl0ueSwgcG9pbnRzWzNdLnldLFxuICAgICAgICAgIG1pblkgPSBmYWJyaWMudXRpbC5hcnJheS5taW4oeVBvaW50cyksXG4gICAgICAgICAgbWF4WSA9IGZhYnJpYy51dGlsLmFycmF5Lm1heCh5UG9pbnRzKSxcbiAgICAgICAgICBoZWlnaHQgPSBtYXhZIC0gbWluWTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbWluWCxcbiAgICAgICAgdG9wOiBtaW5ZLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZlcnQgdHJhbnNmb3JtYXRpb24gdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0IFRoZSB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGludmVydGVkIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIGludmVydFRyYW5zZm9ybTogZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGEgPSAxIC8gKHRbMF0gKiB0WzNdIC0gdFsxXSAqIHRbMl0pLFxuICAgICAgICAgIHIgPSBbYSAqIHRbM10sIC1hICogdFsxXSwgLWEgKiB0WzJdLCBhICogdFswXV0sXG4gICAgICAgICAgbyA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHsgeDogdFs0XSwgeTogdFs1XSB9LCByLCB0cnVlKTtcbiAgICAgIHJbNF0gPSAtby54O1xuICAgICAgcls1XSA9IC1vLnk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB3cmFwcGVyIGFyb3VuZCBOdW1iZXIjdG9GaXhlZCwgd2hpY2ggY29udHJhcnkgdG8gbmF0aXZlIG1ldGhvZCByZXR1cm5zIG51bWJlciwgbm90IHN0cmluZy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBudW1iZXIgbnVtYmVyIHRvIG9wZXJhdGUgb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZnJhY3Rpb25EaWdpdHMgbnVtYmVyIG9mIGZyYWN0aW9uIGRpZ2l0cyB0byBcImxlYXZlXCJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdG9GaXhlZDogZnVuY3Rpb24obnVtYmVyLCBmcmFjdGlvbkRpZ2l0cykge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoTnVtYmVyKG51bWJlcikudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBmcm9tIGF0dHJpYnV0ZSB2YWx1ZSB0byBwaXhlbCB2YWx1ZSBpZiBhcHBsaWNhYmxlLlxuICAgICAqIFJldHVybnMgY29udmVydGVkIHBpeGVscyBvciBvcmlnaW5hbCB2YWx1ZSBub3QgY29udmVydGVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUgbnVtYmVyIHRvIG9wZXJhdGUgb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZm9udFNpemVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfVxuICAgICAqL1xuICAgIHBhcnNlVW5pdDogZnVuY3Rpb24odmFsdWUsIGZvbnRTaXplKSB7XG4gICAgICB2YXIgdW5pdCA9IC9cXER7MCwyfSQvLmV4ZWModmFsdWUpLFxuICAgICAgICAgIG51bWJlciA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgaWYgKCFmb250U2l6ZSkge1xuICAgICAgICBmb250U2l6ZSA9IGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodW5pdFswXSkge1xuICAgICAgICBjYXNlICdtbSc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEkgLyAyNS40O1xuXG4gICAgICAgIGNhc2UgJ2NtJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDIuNTQ7XG5cbiAgICAgICAgY2FzZSAnaW4nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJO1xuXG4gICAgICAgIGNhc2UgJ3B0JzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDcyOyAvLyBvciAqIDQgLyAzXG5cbiAgICAgICAgY2FzZSAncGMnOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gNzIgKiAxMjsgLy8gb3IgKiAxNlxuXG4gICAgICAgIGNhc2UgJ2VtJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZm9udFNpemU7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZhbHNlRnVuY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGtsYXNzIFwiQ2xhc3NcIiBvYmplY3Qgb2YgZ2l2ZW4gbmFtZXNwYWNlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvZiBvYmplY3QgKGVnLiAnY2lyY2xlJylcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIE5hbWVzcGFjZSB0byBnZXQga2xhc3MgXCJDbGFzc1wiIG9iamVjdCBmcm9tXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBrbGFzcyBcIkNsYXNzXCJcbiAgICAgKi9cbiAgICBnZXRLbGFzczogZnVuY3Rpb24odHlwZSwgbmFtZXNwYWNlKSB7XG4gICAgICAvLyBjYXBpdGFsaXplIGZpcnN0IGxldHRlciBvbmx5XG4gICAgICB0eXBlID0gZmFicmljLnV0aWwuc3RyaW5nLmNhbWVsaXplKHR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0eXBlLnNsaWNlKDEpKTtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5yZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZSlbdHlwZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYXJyYXkgb2YgYXR0cmlidXRlcyBmb3IgZ2l2ZW4gc3ZnIHRoYXQgZmFicmljIHBhcnNlc1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2Ygc3ZnIGVsZW1lbnQgKGVnLiAnY2lyY2xlJylcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gc3RyaW5nIG5hbWVzIG9mIHN1cHBvcnRlZCBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgZ2V0U3ZnQXR0cmlidXRlczogZnVuY3Rpb24odHlwZSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBbXG4gICAgICAgICdpbnN0YW50aWF0ZWRfYnlfdXNlJyxcbiAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgJ2lkJyxcbiAgICAgICAgJ2NsYXNzJ1xuICAgICAgXTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdsaW5lYXJHcmFkaWVudCc6XG4gICAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuY29uY2F0KFsneDEnLCAneTEnLCAneDInLCAneTInLCAnZ3JhZGllbnRVbml0cycsICdncmFkaWVudFRyYW5zZm9ybSddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmFkaWFsR3JhZGllbnQnOlxuICAgICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmNvbmNhdChbJ2dyYWRpZW50VW5pdHMnLCAnZ3JhZGllbnRUcmFuc2Zvcm0nLCAnY3gnLCAnY3knLCAncicsICdmeCcsICdmeScsICdmciddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RvcCc6XG4gICAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuY29uY2F0KFsnb2Zmc2V0JywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5J10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IG9mIGdpdmVuIG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgTmFtZXNwYWNlIHN0cmluZyBlLmcuICdmYWJyaWMuSW1hZ2UuZmlsdGVyJyBvciAnZmFicmljJ1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGZvciBnaXZlbiBuYW1lc3BhY2UgKGRlZmF1bHQgZmFicmljKVxuICAgICAqL1xuICAgIHJlc29sdmVOYW1lc3BhY2U6IGZ1bmN0aW9uKG5hbWVzcGFjZSkge1xuICAgICAgaWYgKCFuYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYztcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnRzID0gbmFtZXNwYWNlLnNwbGl0KCcuJyksXG4gICAgICAgICAgbGVuID0gcGFydHMubGVuZ3RoLCBpLFxuICAgICAgICAgIG9iaiA9IGdsb2JhbCB8fCBmYWJyaWMud2luZG93O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgb2JqID0gb2JqW3BhcnRzW2ldXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgaW1hZ2UgZWxlbWVudCBmcm9tIGdpdmVuIHVybCBhbmQgcGFzc2VzIGl0IHRvIGEgY2FsbGJhY2tcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCByZXByZXNlbnRpbmcgYW4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjazsgaW52b2tlZCB3aXRoIGxvYWRlZCBpbWFnZVxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIENvbnRleHQgdG8gaW52b2tlIGNhbGxiYWNrIGluXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gdmFsdWUgdG8gc2V0IGltYWdlIGVsZW1lbnQgdG9cbiAgICAgKi9cbiAgICBsb2FkSW1hZ2U6IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIGNvbnRleHQsIGNyb3NzT3JpZ2luKSB7XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHVybCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGltZyA9IGZhYnJpYy51dGlsLmNyZWF0ZUltYWdlKCk7XG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICB2YXIgb25Mb2FkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgaW1nLCBmYWxzZSk7XG4gICAgICAgIGltZyA9IGltZy5vbmxvYWQgPSBpbWcub25lcnJvciA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBpbWcub25sb2FkID0gb25Mb2FkQ2FsbGJhY2s7XG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZmFicmljLmxvZygnRXJyb3IgbG9hZGluZyAnICsgaW1nLnNyYyk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIGltZyA9IGltZy5vbmxvYWQgPSBpbWcub25lcnJvciA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICAvLyBkYXRhLXVybHMgYXBwZWFyIHRvIGJlIGJ1Z2d5IHdpdGggY3Jvc3NPcmlnaW5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rYW5nYXgvZmFicmljLmpzL2NvbW1pdC9kMGFiYjkwZjFjZDVjNWVmOWQyYTk0ZDNmYjIxYTIyMzMwZGEzZTBhI2NvbW1pdGNvbW1lbnQtNDUxMzc2N1xuICAgICAgLy8gc2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zMTUxNTJcbiAgICAgIC8vICAgICBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05MzUwNjlcbiAgICAgIC8vIGNyb3NzT3JpZ2luIG51bGwgaXMgdGhlIHNhbWUgYXMgbm90IHNldC5cbiAgICAgIGlmICh1cmwuaW5kZXhPZignZGF0YScpICE9PSAwICYmXG4gICAgICAgIGNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgY3Jvc3NPcmlnaW4gIT09IG51bGwpIHtcbiAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG4gICAgICB9XG5cbiAgICAgIC8vIElFMTAgLyBJRTExLUZpeDogU1ZHIGNvbnRlbnRzIGZyb20gZGF0YTogVVJJXG4gICAgICAvLyB3aWxsIG9ubHkgYmUgYXZhaWxhYmxlIGlmIHRoZSBJTUcgaXMgcHJlc2VudFxuICAgICAgLy8gaW4gdGhlIERPTSAoYW5kIHZpc2libGUpXG4gICAgICBpZiAodXJsLnN1YnN0cmluZygwLDE0KSA9PT0gJ2RhdGE6aW1hZ2Uvc3ZnJykge1xuICAgICAgICBpbWcub25sb2FkID0gbnVsbDtcbiAgICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlSW5Eb20oaW1nLCBvbkxvYWRDYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIFNWRyBpbWFnZSB3aXRoIGRhdGE6IFVSTCB0byB0aGUgZG9tXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltZyBJbWFnZSBvYmplY3Qgd2l0aCBkYXRhOmltYWdlL3N2ZyBzcmNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjazsgaW52b2tlZCB3aXRoIGxvYWRlZCBpbWFnZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gRE9NIGVsZW1lbnQgKGRpdiBjb250YWluaW5nIHRoZSBTVkcgaW1hZ2UpXG4gICAgICovXG4gICAgbG9hZEltYWdlSW5Eb206IGZ1bmN0aW9uKGltZywgb25Mb2FkQ2FsbGJhY2spIHtcbiAgICAgIHZhciBkaXYgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuc3R5bGUud2lkdGggPSBkaXYuc3R5bGUuaGVpZ2h0ID0gJzFweCc7XG4gICAgICBkaXYuc3R5bGUubGVmdCA9IGRpdi5zdHlsZS50b3AgPSAnLTEwMCUnO1xuICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgZmFicmljLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwIGluIGZ1bmN0aW9uIHRvOlxuICAgICAgICogICAxLiBDYWxsIGV4aXN0aW5nIGNhbGxiYWNrXG4gICAgICAgKiAgIDIuIENsZWFudXAgRE9NXG4gICAgICAgKi9cbiAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uTG9hZENhbGxiYWNrKCk7XG4gICAgICAgIGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgIGRpdiA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGNvcnJlc3BvbmRpbmcgZmFicmljIGluc3RhbmNlcyBmcm9tIHRoZWlyIG9iamVjdCByZXByZXNlbnRhdGlvbnNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyBPYmplY3RzIHRvIGVubGl2ZW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgb2JqZWN0cyBhcmUgY3JlYXRlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgTmFtZXNwYWNlIHRvIGdldCBrbGFzcyBcIkNsYXNzXCIgb2JqZWN0IGZyb21cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXZpdmVyIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIG9iamVjdCBlbGVtZW50cyxcbiAgICAgKiBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICovXG4gICAgZW5saXZlbk9iamVjdHM6IGZ1bmN0aW9uKG9iamVjdHMsIGNhbGxiYWNrLCBuYW1lc3BhY2UsIHJldml2ZXIpIHtcbiAgICAgIG9iamVjdHMgPSBvYmplY3RzIHx8IFtdO1xuXG4gICAgICB2YXIgZW5saXZlbmVkT2JqZWN0cyA9IFtdLFxuICAgICAgICAgIG51bUxvYWRlZE9iamVjdHMgPSAwLFxuICAgICAgICAgIG51bVRvdGFsT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiBvbkxvYWRlZCgpIHtcbiAgICAgICAgaWYgKCsrbnVtTG9hZGVkT2JqZWN0cyA9PT0gbnVtVG90YWxPYmplY3RzKSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkT2JqZWN0cy5maWx0ZXIoZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IHVuZGVmaW5lZCBvYmplY3RzIChvYmplY3RzIHRoYXQgZ2F2ZSBlcnJvcilcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbnVtVG90YWxPYmplY3RzKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZE9iamVjdHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAobywgaW5kZXgpIHtcbiAgICAgICAgLy8gaWYgc3BhcnNlIGFycmF5XG4gICAgICAgIGlmICghbyB8fCAhby50eXBlKSB7XG4gICAgICAgICAgb25Mb2FkZWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtsYXNzID0gZmFicmljLnV0aWwuZ2V0S2xhc3Moby50eXBlLCBuYW1lc3BhY2UpO1xuICAgICAgICBrbGFzcy5mcm9tT2JqZWN0KG8sIGZ1bmN0aW9uIChvYmosIGVycm9yKSB7XG4gICAgICAgICAgZXJyb3IgfHwgKGVubGl2ZW5lZE9iamVjdHNbaW5kZXhdID0gb2JqKTtcbiAgICAgICAgICByZXZpdmVyICYmIHJldml2ZXIobywgb2JqLCBlcnJvcik7XG4gICAgICAgICAgb25Mb2FkZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjb3JyZXNwb25kaW5nIGZhYnJpYyBpbnN0YW5jZXMgcmVzaWRpbmcgaW4gYW4gb2JqZWN0LCBlLmcuIGBjbGlwUGF0aGBcbiAgICAgKiBAc2VlIHtAbGluayBmYWJyaWMuT2JqZWN0LkVOTElWRU5fUFJPUFN9XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gYXNzaWduIGVubGl2ZWQgcHJvcHMgdG8gdGhpcyBvYmplY3QgKHBhc3MgbnVsbCB0byBza2lwIHRoaXMpXG4gICAgICogQHBhcmFtIHsob2JqZWN0czpmYWJyaWMuT2JqZWN0W10pID0+IHZvaWR9IGNhbGxiYWNrXG4gICAgICovXG4gICAgZW5saXZlbk9iamVjdEVubGl2YWJsZXM6IGZ1bmN0aW9uIChvYmplY3QsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZW5saXZlblByb3BzID0gZmFicmljLk9iamVjdC5FTkxJVkVOX1BST1BTLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAhIW9iamVjdFtrZXldOyB9KTtcbiAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKGVubGl2ZW5Qcm9wcy5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gb2JqZWN0W2tleV07IH0pLCBmdW5jdGlvbiAoZW5saXZlZFByb3BzKSB7XG4gICAgICAgIHZhciBvYmplY3RzID0ge307XG4gICAgICAgIGVubGl2ZW5Qcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG4gICAgICAgICAgb2JqZWN0c1trZXldID0gZW5saXZlZFByb3BzW2luZGV4XTtcbiAgICAgICAgICBjb250ZXh0ICYmIChjb250ZXh0W2tleV0gPSBlbmxpdmVkUHJvcHNbaW5kZXhdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG9iamVjdHMpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgd2FpdCBmb3IgbG9hZGluZyBvZiBwYXR0ZXJuc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXR0ZXJucyBPYmplY3RzIHRvIGVubGl2ZW5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgb2JqZWN0cyBhcmUgY3JlYXRlZFxuICAgICAqIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBlbmxpdmVuUGF0dGVybnM6IGZ1bmN0aW9uKHBhdHRlcm5zLCBjYWxsYmFjaykge1xuICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucyB8fCBbXTtcblxuICAgICAgZnVuY3Rpb24gb25Mb2FkZWQoKSB7XG4gICAgICAgIGlmICgrK251bUxvYWRlZFBhdHRlcm5zID09PSBudW1QYXR0ZXJucykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZFBhdHRlcm5zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZW5saXZlbmVkUGF0dGVybnMgPSBbXSxcbiAgICAgICAgICBudW1Mb2FkZWRQYXR0ZXJucyA9IDAsXG4gICAgICAgICAgbnVtUGF0dGVybnMgPSBwYXR0ZXJucy5sZW5ndGg7XG5cbiAgICAgIGlmICghbnVtUGF0dGVybnMpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW5saXZlbmVkUGF0dGVybnMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBhdHRlcm5zLmZvckVhY2goZnVuY3Rpb24gKHAsIGluZGV4KSB7XG4gICAgICAgIGlmIChwICYmIHAuc291cmNlKSB7XG4gICAgICAgICAgbmV3IGZhYnJpYy5QYXR0ZXJuKHAsIGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICAgICAgICAgIGVubGl2ZW5lZFBhdHRlcm5zW2luZGV4XSA9IHBhdHRlcm47XG4gICAgICAgICAgICBvbkxvYWRlZCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVubGl2ZW5lZFBhdHRlcm5zW2luZGV4XSA9IHA7XG4gICAgICAgICAgb25Mb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBTVkcgZWxlbWVudHMgKHVzdWFsbHkgdGhvc2UgcmV0cmlldmVkIGZyb20gU1ZHIGRvY3VtZW50KVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50cyBTVkcgZWxlbWVudHMgdG8gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVmFsdWUgdG8gc2V0IHNvdXJjZVBhdGggdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fGZhYnJpYy5Hcm91cH1cbiAgICAgKi9cbiAgICBncm91cFNWR0VsZW1lbnRzOiBmdW5jdGlvbihlbGVtZW50cywgb3B0aW9ucywgcGF0aCkge1xuICAgICAgdmFyIG9iamVjdDtcbiAgICAgIGlmIChlbGVtZW50cyAmJiBlbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGVsZW1lbnRzWzBdLnNvdXJjZVBhdGggPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50c1swXTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLndpZHRoICYmIG9wdGlvbnMuaGVpZ2h0KSB7XG4gICAgICAgICAgb3B0aW9ucy5jZW50ZXJQb2ludCA9IHtcbiAgICAgICAgICAgIHg6IG9wdGlvbnMud2lkdGggLyAyLFxuICAgICAgICAgICAgeTogb3B0aW9ucy5oZWlnaHQgLyAyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgb3B0aW9ucy53aWR0aDtcbiAgICAgICAgICBkZWxldGUgb3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG5ldyBmYWJyaWMuR3JvdXAoZWxlbWVudHMsIG9wdGlvbnMpO1xuICAgICAgaWYgKHR5cGVvZiBwYXRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvYmplY3Quc291cmNlUGF0aCA9IHBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQb3B1bGF0ZXMgYW4gb2JqZWN0IHdpdGggcHJvcGVydGllcyBvZiBhbm90aGVyIG9iamVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFNvdXJjZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gb2JqZWN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IHByb3BlcnRpZXMgUHJvcGVydGllcyBuYW1lcyB0byBpbmNsdWRlXG4gICAgICovXG4gICAgcG9wdWxhdGVXaXRoUHJvcGVydGllczogZnVuY3Rpb24oc291cmNlLCBkZXN0aW5hdGlvbiwgcHJvcGVydGllcykge1xuICAgICAgaWYgKHByb3BlcnRpZXMgJiYgQXJyYXkuaXNBcnJheShwcm9wZXJ0aWVzKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2ldIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydGllc1tpXV0gPSBzb3VyY2VbcHJvcGVydGllc1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7Q2FudmFzRWxlbWVudH0gaW5pdGlhbGl6ZWQgY2FudmFzIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjcmVhdGVDYW52YXNFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjYW52YXMgZWxlbWVudCB0aGF0IGlzIGEgY29weSBvZiBhbm90aGVyIGFuZCBpcyBhbHNvIHBhaW50ZWRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc0VsZW1lbnR9IGNhbnZhcyB0byBjb3B5IHNpemUgYW5kIGNvbnRlbnQgb2ZcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7Q2FudmFzRWxlbWVudH0gaW5pdGlhbGl6ZWQgY2FudmFzIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjb3B5Q2FudmFzRWxlbWVudDogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICB2YXIgbmV3Q2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgbmV3Q2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgbmV3Q2FudmFzLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICBuZXdDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcbiAgICAgIHJldHVybiBuZXdDYW52YXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNpbmNlIDIuNi4wIG1vdmVkIGZyb20gY2FudmFzIGluc3RhbmNlIHRvIHV0aWxpdHkuXG4gICAgICogQHBhcmFtIHtDYW52YXNFbGVtZW50fSBjYW52YXNFbCB0byBjb3B5IHNpemUgYW5kIGNvbnRlbnQgb2ZcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0ICdqcGVnJyBvciAncG5nJywgaW4gc29tZSBicm93c2VycyAnd2VicCcgaXMgb2sgdG9vXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHF1YWxpdHkgPD0gMSBhbmQgPiAwXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZGF0YSB1cmxcbiAgICAgKi9cbiAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uKGNhbnZhc0VsLCBmb3JtYXQsIHF1YWxpdHkpIHtcbiAgICAgIHJldHVybiBjYW52YXNFbC50b0RhdGFVUkwoJ2ltYWdlLycgKyBmb3JtYXQsIHF1YWxpdHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGltYWdlIGVsZW1lbnQgKHdvcmtzIG9uIGNsaWVudCBhbmQgbm9kZSlcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gSFRNTCBpbWFnZSBlbGVtZW50XG4gICAgICovXG4gICAgY3JlYXRlSW1hZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgbWF0cml4IEEgYnkgbWF0cml4IEIgdG8gbmVzdCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGEgRmlyc3QgdHJhbnNmb3JtTWF0cml4XG4gICAgICogQHBhcmFtICB7QXJyYXl9IGIgU2Vjb25kIHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGlzMngyIGZsYWcgdG8gbXVsdGlwbHkgbWF0cmljZXMgYXMgMngyIG1hdHJpY2VzXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBwcm9kdWN0IG9mIHRoZSB0d28gdHJhbnNmb3JtIG1hdHJpY2VzXG4gICAgICovXG4gICAgbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlczogZnVuY3Rpb24oYSwgYiwgaXMyeDIpIHtcbiAgICAgIC8vIE1hdHJpeCBtdWx0aXBseSBhICogYlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYVswXSAqIGJbMF0gKyBhWzJdICogYlsxXSxcbiAgICAgICAgYVsxXSAqIGJbMF0gKyBhWzNdICogYlsxXSxcbiAgICAgICAgYVswXSAqIGJbMl0gKyBhWzJdICogYlszXSxcbiAgICAgICAgYVsxXSAqIGJbMl0gKyBhWzNdICogYlszXSxcbiAgICAgICAgaXMyeDIgPyAwIDogYVswXSAqIGJbNF0gKyBhWzJdICogYls1XSArIGFbNF0sXG4gICAgICAgIGlzMngyID8gMCA6IGFbMV0gKiBiWzRdICsgYVszXSAqIGJbNV0gKyBhWzVdXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNvbXBvc2VzIHN0YW5kYXJkIDJ4MyBtYXRyaXggaW50byB0cmFuc2Zvcm0gY29tcG9uZW50c1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYSB0cmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENvbXBvbmVudHMgb2YgdHJhbnNmb3JtXG4gICAgICovXG4gICAgcXJEZWNvbXBvc2U6IGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBhbmdsZSA9IGF0YW4yKGFbMV0sIGFbMF0pLFxuICAgICAgICAgIGRlbm9tID0gcG93KGFbMF0sIDIpICsgcG93KGFbMV0sIDIpLFxuICAgICAgICAgIHNjYWxlWCA9IHNxcnQoZGVub20pLFxuICAgICAgICAgIHNjYWxlWSA9IChhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdKSAvIHNjYWxlWCxcbiAgICAgICAgICBza2V3WCA9IGF0YW4yKGFbMF0gKiBhWzJdICsgYVsxXSAqIGEgWzNdLCBkZW5vbSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbmdsZTogYW5nbGUgLyBQaUJ5MTgwLFxuICAgICAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiBzY2FsZVksXG4gICAgICAgIHNrZXdYOiBza2V3WCAvIFBpQnkxODAsXG4gICAgICAgIHNrZXdZOiAwLFxuICAgICAgICB0cmFuc2xhdGVYOiBhWzRdLFxuICAgICAgICB0cmFuc2xhdGVZOiBhWzVdXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdHJhbnNmb3JtIG1hdHJpeCBzdGFydGluZyBmcm9tIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBraW5kIG9mXG4gICAgICogdGhlIG9uZSByZXR1cm5lZCBmcm9tIHFyRGVjb21wb3NlLCB1c2VmdWwgYWxzbyBpZiB5b3Ugd2FudCB0byBjYWxjdWxhdGUgc29tZVxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBmcm9tIGFuIG9iamVjdCB0aGF0IGlzIG5vdCBlbmxpdmVkIHlldFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlXSBhbmdsZSBpbiBkZWdyZWVzXG4gICAgICogQHJldHVybiB7TnVtYmVyW119IHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKi9cbiAgICBjYWxjUm90YXRlTWF0cml4OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpO1xuICAgICAgfVxuICAgICAgdmFyIHRoZXRhID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyhvcHRpb25zLmFuZ2xlKSxcbiAgICAgICAgICBjb3MgPSBmYWJyaWMudXRpbC5jb3ModGhldGEpLFxuICAgICAgICAgIHNpbiA9IGZhYnJpYy51dGlsLnNpbih0aGV0YSk7XG4gICAgICByZXR1cm4gW2Nvcywgc2luLCAtc2luLCBjb3MsIDAsIDBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdHJhbnNmb3JtIG1hdHJpeCBzdGFydGluZyBmcm9tIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBraW5kIG9mXG4gICAgICogdGhlIG9uZSByZXR1cm5lZCBmcm9tIHFyRGVjb21wb3NlLCB1c2VmdWwgYWxzbyBpZiB5b3Ugd2FudCB0byBjYWxjdWxhdGUgc29tZVxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBmcm9tIGFuIG9iamVjdCB0aGF0IGlzIG5vdCBlbmxpdmVkIHlldC5cbiAgICAgKiBpcyBjYWxsZWQgRGltZW5zaW9uc1RyYW5zZm9ybU1hdHJpeCBiZWNhdXNlIHRob3NlIHByb3BlcnRpZXMgYXJlIHRoZSBvbmUgdGhhdCBpbmZsdWVuY2VcbiAgICAgKiB0aGUgc2l6ZSBvZiB0aGUgcmVzdWx0aW5nIGJveCBvZiB0aGUgb2JqZWN0LlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNjYWxlWF1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNjYWxlWV1cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5mbGlwWF1cbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5mbGlwWV1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNrZXdYXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2tld1ldXG4gICAgICogQHJldHVybiB7TnVtYmVyW119IHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKi9cbiAgICBjYWxjRGltZW5zaW9uc01hdHJpeDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHNjYWxlWCA9IHR5cGVvZiBvcHRpb25zLnNjYWxlWCA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogb3B0aW9ucy5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZID0gdHlwZW9mIG9wdGlvbnMuc2NhbGVZID09PSAndW5kZWZpbmVkJyA/IDEgOiBvcHRpb25zLnNjYWxlWSxcbiAgICAgICAgICBzY2FsZU1hdHJpeCA9IFtcbiAgICAgICAgICAgIG9wdGlvbnMuZmxpcFggPyAtc2NhbGVYIDogc2NhbGVYLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBvcHRpb25zLmZsaXBZID8gLXNjYWxlWSA6IHNjYWxlWSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwXSxcbiAgICAgICAgICBtdWx0aXBseSA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMsXG4gICAgICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnM7XG4gICAgICBpZiAob3B0aW9ucy5za2V3WCkge1xuICAgICAgICBzY2FsZU1hdHJpeCA9IG11bHRpcGx5KFxuICAgICAgICAgIHNjYWxlTWF0cml4LFxuICAgICAgICAgIFsxLCAwLCBNYXRoLnRhbihkZWdyZWVzVG9SYWRpYW5zKG9wdGlvbnMuc2tld1gpKSwgMV0sXG4gICAgICAgICAgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5za2V3WSkge1xuICAgICAgICBzY2FsZU1hdHJpeCA9IG11bHRpcGx5KFxuICAgICAgICAgIHNjYWxlTWF0cml4LFxuICAgICAgICAgIFsxLCBNYXRoLnRhbihkZWdyZWVzVG9SYWRpYW5zKG9wdGlvbnMuc2tld1kpKSwgMCwgMV0sXG4gICAgICAgICAgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NhbGVNYXRyaXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0cmFuc2Zvcm0gbWF0cml4IHN0YXJ0aW5nIGZyb20gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIGtpbmQgb2ZcbiAgICAgKiB0aGUgb25lIHJldHVybmVkIGZyb20gcXJEZWNvbXBvc2UsIHVzZWZ1bCBhbHNvIGlmIHlvdSB3YW50IHRvIGNhbGN1bGF0ZSBzb21lXG4gICAgICogdHJhbnNmb3JtYXRpb25zIGZyb20gYW4gb2JqZWN0IHRoYXQgaXMgbm90IGVubGl2ZWQgeWV0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuYW5nbGVdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZVhdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZVldXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuZmxpcFhdXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuZmxpcFldXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5za2V3WF1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNrZXdYXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMudHJhbnNsYXRlWF1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnRyYW5zbGF0ZVldXG4gICAgICogQHJldHVybiB7TnVtYmVyW119IHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKi9cbiAgICBjb21wb3NlTWF0cml4OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgbWF0cml4ID0gWzEsIDAsIDAsIDEsIG9wdGlvbnMudHJhbnNsYXRlWCB8fCAwLCBvcHRpb25zLnRyYW5zbGF0ZVkgfHwgMF0sXG4gICAgICAgICAgbXVsdGlwbHkgPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzO1xuICAgICAgaWYgKG9wdGlvbnMuYW5nbGUpIHtcbiAgICAgICAgbWF0cml4ID0gbXVsdGlwbHkobWF0cml4LCBmYWJyaWMudXRpbC5jYWxjUm90YXRlTWF0cml4KG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNjYWxlWCAhPT0gMSB8fCBvcHRpb25zLnNjYWxlWSAhPT0gMSB8fFxuICAgICAgICAgIG9wdGlvbnMuc2tld1ggfHwgb3B0aW9ucy5za2V3WSB8fCBvcHRpb25zLmZsaXBYIHx8IG9wdGlvbnMuZmxpcFkpIHtcbiAgICAgICAgbWF0cml4ID0gbXVsdGlwbHkobWF0cml4LCBmYWJyaWMudXRpbC5jYWxjRGltZW5zaW9uc01hdHJpeChvcHRpb25zKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0cml4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXNldCBhbiBvYmplY3QgdHJhbnNmb3JtIHN0YXRlIHRvIG5ldXRyYWwuIFRvcCBhbmQgbGVmdCBhcmUgbm90IGFjY291bnRlZCBmb3JcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7ZmFicmljLk9iamVjdH0gdGFyZ2V0IG9iamVjdCB0byB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICByZXNldE9iamVjdFRyYW5zZm9ybTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgdGFyZ2V0LnNjYWxlWCA9IDE7XG4gICAgICB0YXJnZXQuc2NhbGVZID0gMTtcbiAgICAgIHRhcmdldC5za2V3WCA9IDA7XG4gICAgICB0YXJnZXQuc2tld1kgPSAwO1xuICAgICAgdGFyZ2V0LmZsaXBYID0gZmFsc2U7XG4gICAgICB0YXJnZXQuZmxpcFkgPSBmYWxzZTtcbiAgICAgIHRhcmdldC5yb3RhdGUoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgT2JqZWN0IHRyYW5zZm9ybSB2YWx1ZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7ZmFicmljLk9iamVjdH0gdGFyZ2V0IG9iamVjdCB0byByZWFkIGZyb21cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENvbXBvbmVudHMgb2YgdHJhbnNmb3JtXG4gICAgICovXG4gICAgc2F2ZU9iamVjdFRyYW5zZm9ybTogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGVYOiB0YXJnZXQuc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHRhcmdldC5zY2FsZVksXG4gICAgICAgIHNrZXdYOiB0YXJnZXQuc2tld1gsXG4gICAgICAgIHNrZXdZOiB0YXJnZXQuc2tld1ksXG4gICAgICAgIGFuZ2xlOiB0YXJnZXQuYW5nbGUsXG4gICAgICAgIGxlZnQ6IHRhcmdldC5sZWZ0LFxuICAgICAgICBmbGlwWDogdGFyZ2V0LmZsaXBYLFxuICAgICAgICBmbGlwWTogdGFyZ2V0LmZsaXBZLFxuICAgICAgICB0b3A6IHRhcmdldC50b3BcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBjb250ZXh0IGhhcyB0cmFuc3BhcmVudCBwaXhlbFxuICAgICAqIGF0IHNwZWNpZmllZCBsb2NhdGlvbiAodGFraW5nIHRvbGVyYW5jZSBpbnRvIGFjY291bnQpXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2VcbiAgICAgKi9cbiAgICBpc1RyYW5zcGFyZW50OiBmdW5jdGlvbihjdHgsIHgsIHksIHRvbGVyYW5jZSkge1xuXG4gICAgICAvLyBJZiB0b2xlcmFuY2UgaXMgPiAwIGFkanVzdCBzdGFydCBjb29yZHMgdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgICAvLyBJZiBtb3ZlcyBvZmYgQ2FudmFzIGZpeCB0byAwXG4gICAgICBpZiAodG9sZXJhbmNlID4gMCkge1xuICAgICAgICBpZiAoeCA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgIHggLT0gdG9sZXJhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID4gdG9sZXJhbmNlKSB7XG4gICAgICAgICAgeSAtPSB0b2xlcmFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgeSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIF9pc1RyYW5zcGFyZW50ID0gdHJ1ZSwgaSwgdGVtcCxcbiAgICAgICAgICBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKHgsIHksICh0b2xlcmFuY2UgKiAyKSB8fCAxLCAodG9sZXJhbmNlICogMikgfHwgMSksXG4gICAgICAgICAgbCA9IGltYWdlRGF0YS5kYXRhLmxlbmd0aDtcblxuICAgICAgLy8gU3BsaXQgaW1hZ2UgZGF0YSAtIGZvciB0b2xlcmFuY2UgPiAxLCBwaXhlbERhdGFTaXplID0gNDtcbiAgICAgIGZvciAoaSA9IDM7IGkgPCBsOyBpICs9IDQpIHtcbiAgICAgICAgdGVtcCA9IGltYWdlRGF0YS5kYXRhW2ldO1xuICAgICAgICBfaXNUcmFuc3BhcmVudCA9IHRlbXAgPD0gMDtcbiAgICAgICAgaWYgKF9pc1RyYW5zcGFyZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrOyAvLyBTdG9wIGlmIGNvbG91ciBmb3VuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGltYWdlRGF0YSA9IG51bGw7XG5cbiAgICAgIHJldHVybiBfaXNUcmFuc3BhcmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgcHJlc2VydmVBc3BlY3RSYXRpbyBhdHRyaWJ1dGUgZnJvbSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSB0byBiZSBwYXJzZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCBjb250YWluaW5nIGFsaWduIGFuZCBtZWV0T3JTbGljZSBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBwYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGU6IGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIG1lZXRPclNsaWNlID0gJ21lZXQnLCBhbGlnblggPSAnTWlkJywgYWxpZ25ZID0gJ01pZCcsXG4gICAgICAgICAgYXNwZWN0UmF0aW9BdHRycyA9IGF0dHJpYnV0ZS5zcGxpdCgnICcpLCBhbGlnbjtcblxuICAgICAgaWYgKGFzcGVjdFJhdGlvQXR0cnMgJiYgYXNwZWN0UmF0aW9BdHRycy5sZW5ndGgpIHtcbiAgICAgICAgbWVldE9yU2xpY2UgPSBhc3BlY3RSYXRpb0F0dHJzLnBvcCgpO1xuICAgICAgICBpZiAobWVldE9yU2xpY2UgIT09ICdtZWV0JyAmJiBtZWV0T3JTbGljZSAhPT0gJ3NsaWNlJykge1xuICAgICAgICAgIGFsaWduID0gbWVldE9yU2xpY2U7XG4gICAgICAgICAgbWVldE9yU2xpY2UgPSAnbWVldCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNwZWN0UmF0aW9BdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICBhbGlnbiA9IGFzcGVjdFJhdGlvQXR0cnMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vZGl2aWRlIGFsaWduIGluIGFsaWduWCBhbmQgYWxpZ25ZXG4gICAgICBhbGlnblggPSBhbGlnbiAhPT0gJ25vbmUnID8gYWxpZ24uc2xpY2UoMSwgNCkgOiAnbm9uZSc7XG4gICAgICBhbGlnblkgPSBhbGlnbiAhPT0gJ25vbmUnID8gYWxpZ24uc2xpY2UoNSwgOCkgOiAnbm9uZSc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZWV0T3JTbGljZTogbWVldE9yU2xpY2UsXG4gICAgICAgIGFsaWduWDogYWxpZ25YLFxuICAgICAgICBhbGlnblk6IGFsaWduWVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgY2hhciB3aWR0aHMgY2FjaGUgZm9yIHRoZSBnaXZlbiBmb250IGZhbWlseSBvciBhbGwgdGhlIGNhY2hlIGlmIG5vXG4gICAgICogZm9udEZhbWlseSBpcyBzcGVjaWZpZWQuXG4gICAgICogVXNlIGl0IGlmIHlvdSBrbm93IHlvdSBhcmUgbG9hZGluZyBmb250cyBpbiBhIGxhenkgd2F5IGFuZCB5b3UgYXJlIG5vdCB3YWl0aW5nXG4gICAgICogZm9yIGN1c3RvbSBmb250cyB0byBsb2FkIHByb3Blcmx5IHdoZW4gYWRkaW5nIHRleHQgb2JqZWN0cyB0byB0aGUgY2FudmFzLlxuICAgICAqIElmIGEgdGV4dCBvYmplY3QgaXMgYWRkZWQgd2hlbiBpdHMgb3duIGZvbnQgaXMgbm90IGxvYWRlZCB5ZXQsIHlvdSB3aWxsIGdldCB3cm9uZ1xuICAgICAqIG1lYXN1cmVtZW50IGFuZCBzbyB3cm9uZyBib3VuZGluZyBib3hlcy5cbiAgICAgKiBBZnRlciB0aGUgZm9udCBjYWNoZSBpcyBjbGVhcmVkLCBlaXRoZXIgY2hhbmdlIHRoZSB0ZXh0T2JqZWN0IHRleHQgY29udGVudCBvciBjYWxsXG4gICAgICogaW5pdERpbWVuc2lvbnMoKSB0byB0cmlnZ2VyIGEgcmVjYWxjdWxhdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZm9udEZhbWlseV0gZm9udCBmYW1pbHkgdG8gY2xlYXJcbiAgICAgKi9cbiAgICBjbGVhckZhYnJpY0ZvbnRDYWNoZTogZnVuY3Rpb24oZm9udEZhbWlseSkge1xuICAgICAgZm9udEZhbWlseSA9IChmb250RmFtaWx5IHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKCFmb250RmFtaWx5KSB7XG4gICAgICAgIGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGUgPSB7IH07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldKSB7XG4gICAgICAgIGRlbGV0ZSBmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBjdXJyZW50IGFzcGVjdCByYXRpbywgZGV0ZXJtaW5lcyB0aGUgbWF4IHdpZHRoIGFuZCBoZWlnaHQgdGhhdCBjYW5cbiAgICAgKiByZXNwZWN0IHRoZSB0b3RhbCBhbGxvd2VkIGFyZWEgZm9yIHRoZSBjYWNoZS5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYXIgYXNwZWN0IHJhdGlvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heGltdW1BcmVhIE1heGltdW0gYXJlYSB5b3Ugd2FudCB0byBhY2hpZXZlXG4gICAgICogQHJldHVybiB7T2JqZWN0Lnh9IExpbWl0ZWQgZGltZW5zaW9ucyBieSBYXG4gICAgICogQHJldHVybiB7T2JqZWN0Lnl9IExpbWl0ZWQgZGltZW5zaW9ucyBieSBZXG4gICAgICovXG4gICAgbGltaXREaW1zQnlBcmVhOiBmdW5jdGlvbihhciwgbWF4aW11bUFyZWEpIHtcbiAgICAgIHZhciByb3VnaFdpZHRoID0gTWF0aC5zcXJ0KG1heGltdW1BcmVhICogYXIpLFxuICAgICAgICAgIHBlcmZMaW1pdFNpemVZID0gTWF0aC5mbG9vcihtYXhpbXVtQXJlYSAvIHJvdWdoV2lkdGgpO1xuICAgICAgcmV0dXJuIHsgeDogTWF0aC5mbG9vcihyb3VnaFdpZHRoKSwgeTogcGVyZkxpbWl0U2l6ZVkgfTtcbiAgICB9LFxuXG4gICAgY2FwVmFsdWU6IGZ1bmN0aW9uKG1pbiwgdmFsdWUsIG1heCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgc2NhbGUgZm9yIHRoZSBvYmplY3Qgc291cmNlIHRvIGZpdCBpbnNpZGUgdGhlIG9iamVjdCBkZXN0aW5hdGlvbixcbiAgICAgKiBrZWVwaW5nIGFzcGVjdCByYXRpbyBpbnRhY3QuXG4gICAgICogcmVzcGVjdCB0aGUgdG90YWwgYWxsb3dlZCBhcmVhIGZvciB0aGUgY2FjaGUuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3QgfCBmYWJyaWMuT2JqZWN0fSBzb3VyY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlLmhlaWdodCBuYXR1cmFsIHVuc2NhbGVkIGhlaWdodCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZS53aWR0aCBuYXR1cmFsIHVuc2NhbGVkIHdpZHRoIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdCB8IGZhYnJpYy5PYmplY3R9IGRlc3RpbmF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc3RpbmF0aW9uLmhlaWdodCBuYXR1cmFsIHVuc2NhbGVkIGhlaWdodCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc3RpbmF0aW9uLndpZHRoIG5hdHVyYWwgdW5zY2FsZWQgd2lkdGggb2YgdGhlIG9iamVjdFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gc2NhbGUgZmFjdG9yIHRvIGFwcGx5IHRvIHNvdXJjZSB0byBmaXQgaW50byBkZXN0aW5hdGlvblxuICAgICAqL1xuICAgIGZpbmRTY2FsZVRvRml0OiBmdW5jdGlvbihzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4oZGVzdGluYXRpb24ud2lkdGggLyBzb3VyY2Uud2lkdGgsIGRlc3RpbmF0aW9uLmhlaWdodCAvIHNvdXJjZS5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgc2NhbGUgZm9yIHRoZSBvYmplY3Qgc291cmNlIHRvIGNvdmVyIGVudGlyZWx5IHRoZSBvYmplY3QgZGVzdGluYXRpb24sXG4gICAgICoga2VlcGluZyBhc3BlY3QgcmF0aW8gaW50YWN0LlxuICAgICAqIHJlc3BlY3QgdGhlIHRvdGFsIGFsbG93ZWQgYXJlYSBmb3IgdGhlIGNhY2hlLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0IHwgZmFicmljLk9iamVjdH0gc291cmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZS5oZWlnaHQgbmF0dXJhbCB1bnNjYWxlZCBoZWlnaHQgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2Uud2lkdGggbmF0dXJhbCB1bnNjYWxlZCB3aWR0aCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3QgfCBmYWJyaWMuT2JqZWN0fSBkZXN0aW5hdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXN0aW5hdGlvbi5oZWlnaHQgbmF0dXJhbCB1bnNjYWxlZCBoZWlnaHQgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXN0aW5hdGlvbi53aWR0aCBuYXR1cmFsIHVuc2NhbGVkIHdpZHRoIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlIGZhY3RvciB0byBhcHBseSB0byBzb3VyY2UgdG8gY292ZXIgZGVzdGluYXRpb25cbiAgICAgKi9cbiAgICBmaW5kU2NhbGVUb0NvdmVyOiBmdW5jdGlvbihzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoZGVzdGluYXRpb24ud2lkdGggLyBzb3VyY2Uud2lkdGgsIGRlc3RpbmF0aW9uLmhlaWdodCAvIHNvdXJjZS5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnaXZlbiBhbiBhcnJheSBvZiA2IG51bWJlciByZXR1cm5zIHNvbWV0aGluZyBsaWtlIGBcIm1hdHJpeCguLi5udW1iZXJzKVwiYFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybSBhbiBhcnJheSB3aXRoIDYgbnVtYmVyc1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdHJhbnNmb3JtIG1hdHJpeCBmb3Igc3ZnXG4gICAgICogQHJldHVybiB7T2JqZWN0Lnl9IExpbWl0ZWQgZGltZW5zaW9ucyBieSBZXG4gICAgICovXG4gICAgbWF0cml4VG9TVkc6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuICdtYXRyaXgoJyArIHRyYW5zZm9ybS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnRvRml4ZWQodmFsdWUsIGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyk7XG4gICAgICB9KS5qb2luKCcgJykgKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdpdmVuIGFuIG9iamVjdCBhbmQgYSB0cmFuc2Zvcm0sIGFwcGx5IHRoZSBpbnZlcnNlIHRyYW5zZm9ybSB0byB0aGUgb2JqZWN0LFxuICAgICAqIHRoaXMgaXMgZXF1aXZhbGVudCB0byByZW1vdmUgZnJvbSB0aGF0IG9iamVjdCB0aGF0IHRyYW5zZm9ybWF0aW9uLCBzbyB0aGF0XG4gICAgICogYWRkZWQgaW4gYSBzcGFjZSB3aXRoIHRoZSByZW1vdmVkIHRyYW5zZm9ybSwgdGhlIG9iamVjdCB3aWxsIGJlIHRoZSBzYW1lIGFzIGJlZm9yZS5cbiAgICAgKiBSZW1vdmluZyBmcm9tIGFuIG9iamVjdCBhIHRyYW5zZm9ybSB0aGF0IHNjYWxlIGJ5IDIgaXMgbGlrZSBzY2FsaW5nIGl0IGJ5IDEvMi5cbiAgICAgKiBSZW1vdmluZyBmcm9tIGFuIG9iamVjdCBhIHRyYW5zZnJvbSB0aGF0IHJvdGF0ZSBieSAzMGRlZyBpcyBsaWtlIHJvdGF0aW5nIGJ5IDMwZGVnXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi5cbiAgICAgKiBUaGlzIHV0aWwgaXMgdXNlZCB0byBhZGQgb2JqZWN0cyBpbnNpZGUgdHJhbnNmb3JtZWQgZ3JvdXBzIG9yIG5lc3RlZCBncm91cHMuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgdGhlIG9iamVjdCB5b3Ugd2FudCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm0gdGhlIGRlc3RpbmF0aW9uIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIHJlbW92ZVRyYW5zZm9ybUZyb21PYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgdHJhbnNmb3JtKSB7XG4gICAgICB2YXIgaW52ZXJ0ZWQgPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0odHJhbnNmb3JtKSxcbiAgICAgICAgICBmaW5hbFRyYW5zZm9ybSA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoaW52ZXJ0ZWQsIG9iamVjdC5jYWxjT3duTWF0cml4KCkpO1xuICAgICAgZmFicmljLnV0aWwuYXBwbHlUcmFuc2Zvcm1Ub09iamVjdChvYmplY3QsIGZpbmFsVHJhbnNmb3JtKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2l2ZW4gYW4gb2JqZWN0IGFuZCBhIHRyYW5zZm9ybSwgYXBwbHkgdGhlIHRyYW5zZm9ybSB0byB0aGUgb2JqZWN0LlxuICAgICAqIHRoaXMgaXMgZXF1aXZhbGVudCB0byBjaGFuZ2UgdGhlIHNwYWNlIHdoZXJlIHRoZSBvYmplY3QgaXMgZHJhd24uXG4gICAgICogQWRkaW5nIHRvIGFuIG9iamVjdCBhIHRyYW5zZm9ybSB0aGF0IHNjYWxlIGJ5IDIgaXMgbGlrZSBzY2FsaW5nIGl0IGJ5IDIuXG4gICAgICogVGhpcyBpcyB1c2VkIHdoZW4gcmVtb3ZpbmcgYW4gb2JqZWN0IGZyb20gYW4gYWN0aXZlIHNlbGVjdGlvbiBmb3IgZXhhbXBsZS5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCB0aGUgb2JqZWN0IHlvdSB3YW50IHRvIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybSB0aGUgZGVzdGluYXRpb24gdHJhbnNmb3JtXG4gICAgICovXG4gICAgYWRkVHJhbnNmb3JtVG9PYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgdHJhbnNmb3JtKSB7XG4gICAgICBmYWJyaWMudXRpbC5hcHBseVRyYW5zZm9ybVRvT2JqZWN0KFxuICAgICAgICBvYmplY3QsXG4gICAgICAgIGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXModHJhbnNmb3JtLCBvYmplY3QuY2FsY093bk1hdHJpeCgpKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGlzY2FyZCBhbiBvYmplY3QgdHJhbnNmb3JtIHN0YXRlIGFuZCBhcHBseSB0aGUgb25lIGZyb20gdGhlIG1hdHJpeC5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCB0aGUgb2JqZWN0IHlvdSB3YW50IHRvIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybSB0aGUgZGVzdGluYXRpb24gdHJhbnNmb3JtXG4gICAgICovXG4gICAgYXBwbHlUcmFuc2Zvcm1Ub09iamVjdDogZnVuY3Rpb24ob2JqZWN0LCB0cmFuc2Zvcm0pIHtcbiAgICAgIHZhciBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UodHJhbnNmb3JtKSxcbiAgICAgICAgICBjZW50ZXIgPSBuZXcgZmFicmljLlBvaW50KG9wdGlvbnMudHJhbnNsYXRlWCwgb3B0aW9ucy50cmFuc2xhdGVZKTtcbiAgICAgIG9iamVjdC5mbGlwWCA9IGZhbHNlO1xuICAgICAgb2JqZWN0LmZsaXBZID0gZmFsc2U7XG4gICAgICBvYmplY3Quc2V0KCdzY2FsZVgnLCBvcHRpb25zLnNjYWxlWCk7XG4gICAgICBvYmplY3Quc2V0KCdzY2FsZVknLCBvcHRpb25zLnNjYWxlWSk7XG4gICAgICBvYmplY3Quc2tld1ggPSBvcHRpb25zLnNrZXdYO1xuICAgICAgb2JqZWN0LnNrZXdZID0gb3B0aW9ucy5za2V3WTtcbiAgICAgIG9iamVjdC5hbmdsZSA9IG9wdGlvbnMuYW5nbGU7XG4gICAgICBvYmplY3Quc2V0UG9zaXRpb25CeU9yaWdpbihjZW50ZXIsICdjZW50ZXInLCAnY2VudGVyJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdpdmVuIGEgd2lkdGggYW5kIGhlaWdodCwgcmV0dXJuIHRoZSBzaXplIG9mIHRoZSBib3VuZGluZyBib3hcbiAgICAgKiB0aGF0IGNhbiBjb250YWlucyB0aGUgYm94IHdpdGggd2lkdGgvaGVpZ2h0IHdpdGggYXBwbGllZCB0cmFuc2Zvcm1cbiAgICAgKiBkZXNjcmliZWQgaW4gb3B0aW9ucy5cbiAgICAgKiBVc2UgdG8gY2FsY3VsYXRlIHRoZSBib3hlcyBhcm91bmQgb2JqZWN0cyBmb3IgY29udHJvbHMuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc2NhbGVYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc2NhbGVZXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc2tld1hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5za2V3WVxuICAgICAqIEByZXR1cm4ge09iamVjdC54fSB3aWR0aCBvZiBjb250YWluaW5nXG4gICAgICogQHJldHVybiB7T2JqZWN0Lnl9IGhlaWdodCBvZiBjb250YWluaW5nXG4gICAgICovXG4gICAgc2l6ZUFmdGVyVHJhbnNmb3JtOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgZGltWCA9IHdpZHRoIC8gMiwgZGltWSA9IGhlaWdodCAvIDIsXG4gICAgICAgICAgcG9pbnRzID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiAtZGltWCxcbiAgICAgICAgICAgICAgeTogLWRpbVlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IGRpbVgsXG4gICAgICAgICAgICAgIHk6IC1kaW1ZXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiAtZGltWCxcbiAgICAgICAgICAgICAgeTogZGltWVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogZGltWCxcbiAgICAgICAgICAgICAgeTogZGltWVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgdHJhbnNmb3JtTWF0cml4ID0gZmFicmljLnV0aWwuY2FsY0RpbWVuc2lvbnNNYXRyaXgob3B0aW9ucyksXG4gICAgICAgICAgYmJveCA9IGZhYnJpYy51dGlsLm1ha2VCb3VuZGluZ0JveEZyb21Qb2ludHMocG9pbnRzLCB0cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogYmJveC53aWR0aCxcbiAgICAgICAgeTogYmJveC5oZWlnaHQsXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgMiBjbGlwIHBhdGhzIGludG8gb25lIHZpc3VhbGx5IGVxdWFsIGNsaXAgcGF0aFxuICAgICAqXG4gICAgICogKipJTVBPUlRBTlQqKjpcXFxuICAgICAqIERvZXMgKipOT1QqKiBjbG9uZSB0aGUgYXJndW1lbnRzLCBjbG9uZSB0aGVtIHByb2lyIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSB3cmFwcGVyIChncm91cCkgdGhhdCBjb250YWlucyBvbmUgY2xpcCBwYXRoIGFuZCBpcyBjbGlwcGVkIGJ5IHRoZSBvdGhlciBzbyBjb250ZW50IGlzIGtlcHQgd2hlcmUgYm90aCBvdmVybGFwLlxuICAgICAqIFVzZSB0aGlzIG1ldGhvZCBpZiBib3RoIHRoZSBjbGlwIHBhdGhzIG1heSBoYXZlIG5lc3RlZCBjbGlwIHBhdGhzIG9mIHRoZWlyIG93biwgc28gYXNzaWduaW5nIG9uZSB0byB0aGUgb3RoZXIncyBjbGlwIHBhdGggcHJvcGVydHkgaXMgbm90IHBvc3NpYmxlLlxuICAgICAqXG4gICAgICogSW4gb3JkZXIgdG8gaGFuZGxlIHRoZSBgaW52ZXJ0ZWRgIHByb3BlcnR5IHdlIGZvbGxvdyBsb2dpYyBkZXNjcmliZWQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcXFxuICAgICAqICoqKDEpKiogYm90aCBjbGlwIHBhdGhzIGFyZSBpbnZlcnRlZCAtIHRoZSBjbGlwIHBhdGhzIHBhc3MgdGhlIGludmVydGVkIHByb3AgdG8gdGhlIHdyYXBwZXIgYW5kIGxvb3NlIGl0IHRoZW1zZWx2ZXMuXFxcbiAgICAgKiAqKigyKSoqIG9uZSBpcyBpbnZlcnRlZCBhbmQgdGhlIG90aGVyIGlzbid0IC0gdGhlIHdyYXBwZXIgc2hvdWxkbid0IGJlY29tZSBpbnZlcnRlZCBhbmQgdGhlIGludmVydGVkIGNsaXAgcGF0aCBtdXN0IGNsaXAgdGhlIG5vbiBpbnZlcnRlZCBvbmUgdG8gcHJvZHVjZSBhbiBpZGVudGljYWwgdmlzdWFsIGVmZmVjdC5cXFxuICAgICAqICoqKDMpKiogYm90aCBjbGlwIHBhdGhzIGFyZSBub3QgaW52ZXJ0ZWQgLSB3cmFwcGVyIGFuZCBjbGlwIHBhdGhzIHJlbWFpbiB1bmNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGMxXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBjMlxuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuT2JqZWN0fSBtZXJnZWQgY2xpcCBwYXRoXG4gICAgICovXG4gICAgbWVyZ2VDbGlwUGF0aHM6IGZ1bmN0aW9uIChjMSwgYzIpIHtcbiAgICAgIHZhciBhID0gYzEsIGIgPSBjMjtcbiAgICAgIGlmIChhLmludmVydGVkICYmICFiLmludmVydGVkKSB7XG4gICAgICAgIC8vICBjYXNlICgyKVxuICAgICAgICBhID0gYzI7XG4gICAgICAgIGIgPSBjMTtcbiAgICAgIH1cbiAgICAgIC8vICBgYmAgYmVjb21lcyBgYWAncyBjbGlwIHBhdGggc28gd2UgdHJhbnNmb3JtIGBiYCB0byBgYWAgY29vcmRpbmF0ZSBwbGFuZVxuICAgICAgZmFicmljLnV0aWwuYXBwbHlUcmFuc2Zvcm1Ub09iamVjdChcbiAgICAgICAgYixcbiAgICAgICAgZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhcbiAgICAgICAgICBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0oYS5jYWxjVHJhbnNmb3JtTWF0cml4KCkpLFxuICAgICAgICAgIGIuY2FsY1RyYW5zZm9ybU1hdHJpeCgpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICAvLyAgYXNzaWduIHRoZSBgaW52ZXJ0ZWRgIHByb3AgdG8gdGhlIHdyYXBwaW5nIGdyb3VwXG4gICAgICB2YXIgaW52ZXJ0ZWQgPSBhLmludmVydGVkICYmIGIuaW52ZXJ0ZWQ7XG4gICAgICBpZiAoaW52ZXJ0ZWQpIHtcbiAgICAgICAgLy8gIGNhc2UgKDEpXG4gICAgICAgIGEuaW52ZXJ0ZWQgPSBiLmludmVydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Hcm91cChbYV0sIHsgY2xpcFBhdGg6IGIsIGludmVydGVkOiBpbnZlcnRlZCB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXZTdHlsZSBmaXJzdCBzdHlsZSB0byBjb21wYXJlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRoaXNTdHlsZSBzZWNvbmQgc3R5bGUgdG8gY29tcGFyZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yVGV4dFNwYW5zIHdoZXRoZXIgdG8gY2hlY2sgb3ZlcmxpbmUsIHVuZGVybGluZSwgYW5kIGxpbmUtdGhyb3VnaCBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc3R5bGUgY2hhbmdlZFxuICAgICAqL1xuICAgIGhhc1N0eWxlQ2hhbmdlZDogZnVuY3Rpb24ocHJldlN0eWxlLCB0aGlzU3R5bGUsIGZvclRleHRTcGFucykge1xuICAgICAgZm9yVGV4dFNwYW5zID0gZm9yVGV4dFNwYW5zIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIChwcmV2U3R5bGUuZmlsbCAhPT0gdGhpc1N0eWxlLmZpbGwgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLnN0cm9rZSAhPT0gdGhpc1N0eWxlLnN0cm9rZSB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuc3Ryb2tlV2lkdGggIT09IHRoaXNTdHlsZS5zdHJva2VXaWR0aCB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZm9udFNpemUgIT09IHRoaXNTdHlsZS5mb250U2l6ZSB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZm9udEZhbWlseSAhPT0gdGhpc1N0eWxlLmZvbnRGYW1pbHkgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRXZWlnaHQgIT09IHRoaXNTdHlsZS5mb250V2VpZ2h0IHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250U3R5bGUgIT09IHRoaXNTdHlsZS5mb250U3R5bGUgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3IgIT09IHRoaXNTdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5kZWx0YVkgIT09IHRoaXNTdHlsZS5kZWx0YVkpIHx8XG4gICAgICAgICAgICAgIChmb3JUZXh0U3BhbnMgJiZcbiAgICAgICAgICAgICAgICAocHJldlN0eWxlLm92ZXJsaW5lICE9PSB0aGlzU3R5bGUub3ZlcmxpbmUgfHxcbiAgICAgICAgICAgICAgICBwcmV2U3R5bGUudW5kZXJsaW5lICE9PSB0aGlzU3R5bGUudW5kZXJsaW5lIHx8XG4gICAgICAgICAgICAgICAgcHJldlN0eWxlLmxpbmV0aHJvdWdoICE9PSB0aGlzU3R5bGUubGluZXRocm91Z2gpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXJyYXkgZm9ybSBvZiBhIHRleHQgb2JqZWN0J3MgaW5saW5lIHN0eWxlcyBwcm9wZXJ0eSB3aXRoIHN0eWxlcyBncm91cGVkIGluIHJhbmdlc1xuICAgICAqIHJhdGhlciB0aGFuIHBlciBjaGFyYWN0ZXIuIFRoaXMgZm9ybWF0IGlzIGxlc3MgdmVyYm9zZSwgYW5kIGlzIGJldHRlciBzdWl0ZWQgZm9yIHN0b3JhZ2VcbiAgICAgKiBzbyBpdCBpcyB1c2VkIGluIHNlcmlhbGl6YXRpb24gKG5vdCBkdXJpbmcgcnVudGltZSkuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlcyBwZXIgY2hhcmFjdGVyIHN0eWxlcyBmb3IgYSB0ZXh0IG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRoZSB0ZXh0IHN0cmluZyB0aGF0IHRoZSBzdHlsZXMgYXJlIGFwcGxpZWQgdG9cbiAgICAgKiBAcmV0dXJuIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIHN0eWxlOiBvYmplY3R9W119XG4gICAgICovXG4gICAgc3R5bGVzVG9BcnJheTogZnVuY3Rpb24oc3R5bGVzLCB0ZXh0KSB7XG4gICAgICAvLyBjbG9uZSBzdHlsZSBzdHJ1Y3R1cmUgdG8gcHJldmVudCBtdXRhdGlvblxuICAgICAgdmFyIHN0eWxlcyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShzdHlsZXMsIHRydWUpLFxuICAgICAgICAgIHRleHRMaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpLFxuICAgICAgICAgIGNoYXJJbmRleCA9IC0xLCBwcmV2U3R5bGUgPSB7fSwgc3R5bGVzQXJyYXkgPSBbXTtcbiAgICAgIC8vbG9vcCB0aHJvdWdoIGVhY2ggdGV4dExpbmVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghc3R5bGVzW2ldKSB7XG4gICAgICAgICAgLy9ubyBzdHlsZXMgZXhpc3QgZm9yIHRoaXMgbGluZSwgc28gYWRkIHRoZSBsaW5lJ3MgbGVuZ3RoIHRvIHRoZSBjaGFySW5kZXggdG90YWxcbiAgICAgICAgICBjaGFySW5kZXggKz0gdGV4dExpbmVzW2ldLmxlbmd0aDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvL2xvb3AgdGhyb3VnaCBlYWNoIGNoYXJhY3RlciBvZiB0aGUgY3VycmVudCBsaW5lXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgdGV4dExpbmVzW2ldLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgY2hhckluZGV4Kys7XG4gICAgICAgICAgdmFyIHRoaXNTdHlsZSA9IHN0eWxlc1tpXVtjXTtcbiAgICAgICAgICAvL2NoZWNrIGlmIHN0eWxlIGV4aXN0cyBmb3IgdGhpcyBjaGFyYWN0ZXJcbiAgICAgICAgICBpZiAodGhpc1N0eWxlICYmIE9iamVjdC5rZXlzKHRoaXNTdHlsZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlQ2hhbmdlZCA9IGZhYnJpYy51dGlsLmhhc1N0eWxlQ2hhbmdlZChwcmV2U3R5bGUsIHRoaXNTdHlsZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoc3R5bGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHN0eWxlc0FycmF5LnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBjaGFySW5kZXgsXG4gICAgICAgICAgICAgICAgZW5kOiBjaGFySW5kZXggKyAxLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB0aGlzU3R5bGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy9pZiBzdHlsZSBpcyB0aGUgc2FtZSBhcyBwcmV2aW91cyBjaGFyYWN0ZXIsIGluY3JlYXNlIGVuZCBpbmRleFxuICAgICAgICAgICAgICBzdHlsZXNBcnJheVtzdHlsZXNBcnJheS5sZW5ndGggLSAxXS5lbmQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldlN0eWxlID0gdGhpc1N0eWxlIHx8IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGVzQXJyYXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9iamVjdCBmb3JtIG9mIHRoZSBzdHlsZXMgcHJvcGVydHkgd2l0aCBzdHlsZXMgdGhhdCBhcmUgYXNzaWduZWQgcGVyXG4gICAgICogY2hhcmFjdGVyIHJhdGhlciB0aGFuIGdyb3VwZWQgYnkgcmFuZ2UuIFRoaXMgZm9ybWF0IGlzIG1vcmUgdmVyYm9zZSwgYW5kIGlzXG4gICAgICogb25seSB1c2VkIGR1cmluZyBydW50aW1lIChub3QgZm9yIHNlcmlhbGl6YXRpb24vc3RvcmFnZSlcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzdHlsZXMgdGhlIHNlcmlhbGl6ZWQgZm9ybSBvZiBhIHRleHQgb2JqZWN0J3Mgc3R5bGVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGhlIHRleHQgc3RyaW5nIHRoYXQgdGhlIHN0eWxlcyBhcmUgYXBwbGllZCB0b1xuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBzdHlsZXNGcm9tQXJyYXk6IGZ1bmN0aW9uKHN0eWxlcywgdGV4dCkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgIH1cbiAgICAgIHZhciB0ZXh0TGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKSxcbiAgICAgICAgICBjaGFySW5kZXggPSAtMSwgc3R5bGVJbmRleCA9IDAsIHN0eWxlc09iamVjdCA9IHt9O1xuICAgICAgLy9sb29wIHRocm91Z2ggZWFjaCB0ZXh0TGluZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy9sb29wIHRocm91Z2ggZWFjaCBjaGFyYWN0ZXIgb2YgdGhlIGN1cnJlbnQgbGluZVxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHRleHRMaW5lc1tpXS5sZW5ndGg7IGMrKykge1xuICAgICAgICAgIGNoYXJJbmRleCsrO1xuICAgICAgICAgIC8vY2hlY2sgaWYgdGhlcmUncyBhIHN0eWxlIGNvbGxlY3Rpb24gdGhhdCBpbmNsdWRlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICAgICAgICBpZiAoc3R5bGVzW3N0eWxlSW5kZXhdXG4gICAgICAgICAgICAmJiBzdHlsZXNbc3R5bGVJbmRleF0uc3RhcnQgPD0gY2hhckluZGV4XG4gICAgICAgICAgICAmJiBjaGFySW5kZXggPCBzdHlsZXNbc3R5bGVJbmRleF0uZW5kKSB7XG4gICAgICAgICAgICAvL2NyZWF0ZSBvYmplY3QgZm9yIGxpbmUgaW5kZXggaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgc3R5bGVzT2JqZWN0W2ldID0gc3R5bGVzT2JqZWN0W2ldIHx8IHt9O1xuICAgICAgICAgICAgLy9hc3NpZ24gYSBzdHlsZSBhdCB0aGlzIGNoYXJhY3RlcidzIGluZGV4XG4gICAgICAgICAgICBzdHlsZXNPYmplY3RbaV1bY10gPSBPYmplY3QuYXNzaWduKHt9LCBzdHlsZXNbc3R5bGVJbmRleF0uc3R5bGUpO1xuICAgICAgICAgICAgLy9pZiBjaGFyYWN0ZXIgaXMgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzdHlsZSBjb2xsZWN0aW9uLCBtb3ZlIHRvIHRoZSBuZXh0XG4gICAgICAgICAgICBpZiAoY2hhckluZGV4ID09PSBzdHlsZXNbc3R5bGVJbmRleF0uZW5kIC0gMSkge1xuICAgICAgICAgICAgICBzdHlsZUluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGVzT2JqZWN0O1xuICAgIH1cbiAgfTtcbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBfam9pbiA9IEFycmF5LnByb3RvdHlwZS5qb2luLFxuICAgICAgY29tbWFuZExlbmd0aHMgPSB7XG4gICAgICAgIG06IDIsXG4gICAgICAgIGw6IDIsXG4gICAgICAgIGg6IDEsXG4gICAgICAgIHY6IDEsXG4gICAgICAgIGM6IDYsXG4gICAgICAgIHM6IDQsXG4gICAgICAgIHE6IDQsXG4gICAgICAgIHQ6IDIsXG4gICAgICAgIGE6IDdcbiAgICAgIH0sXG4gICAgICByZXBlYXRlZENvbW1hbmRzID0ge1xuICAgICAgICBtOiAnbCcsXG4gICAgICAgIE06ICdMJ1xuICAgICAgfTtcbiAgZnVuY3Rpb24gc2VnbWVudFRvQmV6aWVyKHRoMiwgdGgzLCBjb3NUaCwgc2luVGgsIHJ4LCByeSwgY3gxLCBjeTEsIG1ULCBmcm9tWCwgZnJvbVkpIHtcbiAgICB2YXIgY29zdGgyID0gZmFicmljLnV0aWwuY29zKHRoMiksXG4gICAgICAgIHNpbnRoMiA9IGZhYnJpYy51dGlsLnNpbih0aDIpLFxuICAgICAgICBjb3N0aDMgPSBmYWJyaWMudXRpbC5jb3ModGgzKSxcbiAgICAgICAgc2ludGgzID0gZmFicmljLnV0aWwuc2luKHRoMyksXG4gICAgICAgIHRvWCA9IGNvc1RoICogcnggKiBjb3N0aDMgLSBzaW5UaCAqIHJ5ICogc2ludGgzICsgY3gxLFxuICAgICAgICB0b1kgPSBzaW5UaCAqIHJ4ICogY29zdGgzICsgY29zVGggKiByeSAqIHNpbnRoMyArIGN5MSxcbiAgICAgICAgY3AxWCA9IGZyb21YICsgbVQgKiAoIC1jb3NUaCAqIHJ4ICogc2ludGgyIC0gc2luVGggKiByeSAqIGNvc3RoMiksXG4gICAgICAgIGNwMVkgPSBmcm9tWSArIG1UICogKCAtc2luVGggKiByeCAqIHNpbnRoMiArIGNvc1RoICogcnkgKiBjb3N0aDIpLFxuICAgICAgICBjcDJYID0gdG9YICsgbVQgKiAoIGNvc1RoICogcnggKiBzaW50aDMgKyBzaW5UaCAqIHJ5ICogY29zdGgzKSxcbiAgICAgICAgY3AyWSA9IHRvWSArIG1UICogKCBzaW5UaCAqIHJ4ICogc2ludGgzIC0gY29zVGggKiByeSAqIGNvc3RoMyk7XG5cbiAgICByZXR1cm4gWydDJyxcbiAgICAgIGNwMVgsIGNwMVksXG4gICAgICBjcDJYLCBjcDJZLFxuICAgICAgdG9YLCB0b1lcbiAgICBdO1xuICB9XG5cbiAgLyogQWRhcHRlZCBmcm9tIGh0dHA6Ly9keHIubW96aWxsYS5vcmcvbW96aWxsYS1jZW50cmFsL3NvdXJjZS9jb250ZW50L3N2Zy9jb250ZW50L3NyYy9uc1NWR1BhdGhEYXRhUGFyc2VyLmNwcFxuICAgKiBieSBBbmRyZWEgQm9nYXp6aSBjb2RlIGlzIHVuZGVyIE1QTC4gaWYgeW91IGRvbid0IGhhdmUgYSBjb3B5IG9mIHRoZSBsaWNlbnNlIHlvdSBjYW4gdGFrZSBpdCBoZXJlXG4gICAqIGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wL1xuICAgKi9cbiAgZnVuY3Rpb24gYXJjVG9TZWdtZW50cyh0b1gsIHRvWSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdGF0ZVgpIHtcbiAgICB2YXIgUEkgPSBNYXRoLlBJLCB0aCA9IHJvdGF0ZVggKiBQSSAvIDE4MCxcbiAgICAgICAgc2luVGggPSBmYWJyaWMudXRpbC5zaW4odGgpLFxuICAgICAgICBjb3NUaCA9IGZhYnJpYy51dGlsLmNvcyh0aCksXG4gICAgICAgIGZyb21YID0gMCwgZnJvbVkgPSAwO1xuXG4gICAgcnggPSBNYXRoLmFicyhyeCk7XG4gICAgcnkgPSBNYXRoLmFicyhyeSk7XG5cbiAgICB2YXIgcHggPSAtY29zVGggKiB0b1ggKiAwLjUgLSBzaW5UaCAqIHRvWSAqIDAuNSxcbiAgICAgICAgcHkgPSAtY29zVGggKiB0b1kgKiAwLjUgKyBzaW5UaCAqIHRvWCAqIDAuNSxcbiAgICAgICAgcngyID0gcnggKiByeCwgcnkyID0gcnkgKiByeSwgcHkyID0gcHkgKiBweSwgcHgyID0gcHggKiBweCxcbiAgICAgICAgcGwgPSByeDIgKiByeTIgLSByeDIgKiBweTIgLSByeTIgKiBweDIsXG4gICAgICAgIHJvb3QgPSAwO1xuXG4gICAgaWYgKHBsIDwgMCkge1xuICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoMSAtIHBsIC8gKHJ4MiAqIHJ5MikpO1xuICAgICAgcnggKj0gcztcbiAgICAgIHJ5ICo9IHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcm9vdCA9IChsYXJnZSA9PT0gc3dlZXAgPyAtMS4wIDogMS4wKSAqXG4gICAgICAgICAgICAgIE1hdGguc3FydCggcGwgLyAocngyICogcHkyICsgcnkyICogcHgyKSk7XG4gICAgfVxuXG4gICAgdmFyIGN4ID0gcm9vdCAqIHJ4ICogcHkgLyByeSxcbiAgICAgICAgY3kgPSAtcm9vdCAqIHJ5ICogcHggLyByeCxcbiAgICAgICAgY3gxID0gY29zVGggKiBjeCAtIHNpblRoICogY3kgKyB0b1ggKiAwLjUsXG4gICAgICAgIGN5MSA9IHNpblRoICogY3ggKyBjb3NUaCAqIGN5ICsgdG9ZICogMC41LFxuICAgICAgICBtVGhldGEgPSBjYWxjVmVjdG9yQW5nbGUoMSwgMCwgKHB4IC0gY3gpIC8gcngsIChweSAtIGN5KSAvIHJ5KSxcbiAgICAgICAgZHRoZXRhID0gY2FsY1ZlY3RvckFuZ2xlKChweCAtIGN4KSAvIHJ4LCAocHkgLSBjeSkgLyByeSwgKC1weCAtIGN4KSAvIHJ4LCAoLXB5IC0gY3kpIC8gcnkpO1xuXG4gICAgaWYgKHN3ZWVwID09PSAwICYmIGR0aGV0YSA+IDApIHtcbiAgICAgIGR0aGV0YSAtPSAyICogUEk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN3ZWVwID09PSAxICYmIGR0aGV0YSA8IDApIHtcbiAgICAgIGR0aGV0YSArPSAyICogUEk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBpbnRvIGN1YmljIGJlemllciBzZWdtZW50cyA8PSA5MGRlZ1xuICAgIHZhciBzZWdtZW50cyA9IE1hdGguY2VpbChNYXRoLmFicyhkdGhldGEgLyBQSSAqIDIpKSxcbiAgICAgICAgcmVzdWx0ID0gW10sIG1EZWx0YSA9IGR0aGV0YSAvIHNlZ21lbnRzLFxuICAgICAgICBtVCA9IDggLyAzICogTWF0aC5zaW4obURlbHRhIC8gNCkgKiBNYXRoLnNpbihtRGVsdGEgLyA0KSAvIE1hdGguc2luKG1EZWx0YSAvIDIpLFxuICAgICAgICB0aDMgPSBtVGhldGEgKyBtRGVsdGE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IHNlZ21lbnRUb0JlemllcihtVGhldGEsIHRoMywgY29zVGgsIHNpblRoLCByeCwgcnksIGN4MSwgY3kxLCBtVCwgZnJvbVgsIGZyb21ZKTtcbiAgICAgIGZyb21YID0gcmVzdWx0W2ldWzVdO1xuICAgICAgZnJvbVkgPSByZXN1bHRbaV1bNl07XG4gICAgICBtVGhldGEgPSB0aDM7XG4gICAgICB0aDMgKz0gbURlbHRhO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLypcbiAgICogUHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY2FsY1ZlY3RvckFuZ2xlKHV4LCB1eSwgdngsIHZ5KSB7XG4gICAgdmFyIHRhID0gTWF0aC5hdGFuMih1eSwgdXgpLFxuICAgICAgICB0YiA9IE1hdGguYXRhbjIodnksIHZ4KTtcbiAgICBpZiAodGIgPj0gdGEpIHtcbiAgICAgIHJldHVybiB0YiAtIHRhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiAyICogTWF0aC5QSSAtICh0YSAtIHRiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGJvdW5kaW5nIGJveCBvZiBhIGJlemllcmN1cnZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MCBzdGFydGluZyBwb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0geTBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgxIGZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MiBzZWNvbmRvIGNvbnRyb2wgcG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MyBlbmQgb2YgYmV6aWVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5M1xuICAgKi9cbiAgLy8gdGFrZW4gZnJvbSBodHRwOi8vanNiaW4uY29tL2l2b21pcS81Ni9lZGl0ICBubyBjcmVkaXRzIGF2YWlsYWJsZSBmb3IgdGhhdC5cbiAgLy8gVE9ETzogY2FuIHdlIG5vcm1hbGl6ZSB0aGlzIHdpdGggdGhlIHN0YXJ0aW5nIHBvaW50cyBzZXQgYXQgMCBhbmQgdGhlbiB0cmFuc2xhdGVkIHRoZSBiYm94P1xuICBmdW5jdGlvbiBnZXRCb3VuZHNPZkN1cnZlKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIHZhciBhcmdzU3RyaW5nO1xuICAgIGlmIChmYWJyaWMuY2FjaGVzQm91bmRzT2ZDdXJ2ZSkge1xuICAgICAgYXJnc1N0cmluZyA9IF9qb2luLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGlmIChmYWJyaWMuYm91bmRzT2ZDdXJ2ZUNhY2hlW2FyZ3NTdHJpbmddKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMuYm91bmRzT2ZDdXJ2ZUNhY2hlW2FyZ3NTdHJpbmddO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0LFxuICAgICAgICBtaW4gPSBNYXRoLm1pbiwgbWF4ID0gTWF0aC5tYXgsXG4gICAgICAgIGFicyA9IE1hdGguYWJzLCB0dmFsdWVzID0gW10sXG4gICAgICAgIGJvdW5kcyA9IFtbXSwgW11dLFxuICAgICAgICBhLCBiLCBjLCB0LCB0MSwgdDIsIGIyYWMsIHNxcnRiMmFjO1xuXG4gICAgYiA9IDYgKiB4MCAtIDEyICogeDEgKyA2ICogeDI7XG4gICAgYSA9IC0zICogeDAgKyA5ICogeDEgLSA5ICogeDIgKyAzICogeDM7XG4gICAgYyA9IDMgKiB4MSAtIDMgKiB4MDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICAgIGEgPSAtMyAqIHkwICsgOSAqIHkxIC0gOSAqIHkyICsgMyAqIHkzO1xuICAgICAgICBjID0gMyAqIHkxIC0gMyAqIHkwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgICAgaWYgKGFicyhiKSA8IDFlLTEyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdCA9IC1jIC8gYjtcbiAgICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgICAgdHZhbHVlcy5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuICAgICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3FydGIyYWMgPSBzcXJ0KGIyYWMpO1xuICAgICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgICAgdHZhbHVlcy5wdXNoKHQxKTtcbiAgICAgIH1cbiAgICAgIHQyID0gKC1iIC0gc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICAgIHR2YWx1ZXMucHVzaCh0Mik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHgsIHksIGogPSB0dmFsdWVzLmxlbmd0aCwgamxlbiA9IGosIG10O1xuICAgIHdoaWxlIChqLS0pIHtcbiAgICAgIHQgPSB0dmFsdWVzW2pdO1xuICAgICAgbXQgPSAxIC0gdDtcbiAgICAgIHggPSAobXQgKiBtdCAqIG10ICogeDApICsgKDMgKiBtdCAqIG10ICogdCAqIHgxKSArICgzICogbXQgKiB0ICogdCAqIHgyKSArICh0ICogdCAqIHQgKiB4Myk7XG4gICAgICBib3VuZHNbMF1bal0gPSB4O1xuXG4gICAgICB5ID0gKG10ICogbXQgKiBtdCAqIHkwKSArICgzICogbXQgKiBtdCAqIHQgKiB5MSkgKyAoMyAqIG10ICogdCAqIHQgKiB5MikgKyAodCAqIHQgKiB0ICogeTMpO1xuICAgICAgYm91bmRzWzFdW2pdID0geTtcbiAgICB9XG5cbiAgICBib3VuZHNbMF1bamxlbl0gPSB4MDtcbiAgICBib3VuZHNbMV1bamxlbl0gPSB5MDtcbiAgICBib3VuZHNbMF1bamxlbiArIDFdID0geDM7XG4gICAgYm91bmRzWzFdW2psZW4gKyAxXSA9IHkzO1xuICAgIHZhciByZXN1bHQgPSBbXG4gICAgICB7XG4gICAgICAgIHg6IG1pbi5hcHBseShudWxsLCBib3VuZHNbMF0pLFxuICAgICAgICB5OiBtaW4uYXBwbHkobnVsbCwgYm91bmRzWzFdKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgeDogbWF4LmFwcGx5KG51bGwsIGJvdW5kc1swXSksXG4gICAgICAgIHk6IG1heC5hcHBseShudWxsLCBib3VuZHNbMV0pXG4gICAgICB9XG4gICAgXTtcbiAgICBpZiAoZmFicmljLmNhY2hlc0JvdW5kc09mQ3VydmUpIHtcbiAgICAgIGZhYnJpYy5ib3VuZHNPZkN1cnZlQ2FjaGVbYXJnc1N0cmluZ10gPSByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYXJjIHRvIGEgYnVuY2ggb2YgYmV6aWVyIGN1cnZlc1xuICAgKiBAcGFyYW0ge051bWJlcn0gZnggc3RhcnRpbmcgcG9pbnQgeFxuICAgKiBAcGFyYW0ge051bWJlcn0gZnkgc3RhcnRpbmcgcG9pbnQgeVxuICAgKiBAcGFyYW0ge0FycmF5fSBjb29yZHMgQXJjIGNvbW1hbmRcbiAgICovXG4gIGZ1bmN0aW9uIGZyb21BcmNUb0JlemllcnMoZngsIGZ5LCBjb29yZHMpIHtcbiAgICB2YXIgcnggPSBjb29yZHNbMV0sXG4gICAgICAgIHJ5ID0gY29vcmRzWzJdLFxuICAgICAgICByb3QgPSBjb29yZHNbM10sXG4gICAgICAgIGxhcmdlID0gY29vcmRzWzRdLFxuICAgICAgICBzd2VlcCA9IGNvb3Jkc1s1XSxcbiAgICAgICAgdHggPSBjb29yZHNbNl0sXG4gICAgICAgIHR5ID0gY29vcmRzWzddLFxuICAgICAgICBzZWdzTm9ybSA9IGFyY1RvU2VnbWVudHModHggLSBmeCwgdHkgLSBmeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2Vnc05vcm0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNlZ3NOb3JtW2ldWzFdICs9IGZ4O1xuICAgICAgc2Vnc05vcm1baV1bMl0gKz0gZnk7XG4gICAgICBzZWdzTm9ybVtpXVszXSArPSBmeDtcbiAgICAgIHNlZ3NOb3JtW2ldWzRdICs9IGZ5O1xuICAgICAgc2Vnc05vcm1baV1bNV0gKz0gZng7XG4gICAgICBzZWdzTm9ybVtpXVs2XSArPSBmeTtcbiAgICB9XG4gICAgcmV0dXJuIHNlZ3NOb3JtO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHRha2UgYSBwYXJzZWQgU1ZHIHBhdGggYW5kIG1ha2UgaXQgc2ltcGxlciBmb3IgZmFicmljSlMgbG9naWMuXG4gICAqIHNpbXBsaWZpY2F0aW9uIGNvbnNpc3Qgb2Y6IG9ubHkgVVBQRVJDQVNFIGFic29sdXRlIGNvbW1hbmRzICggcmVsYXRpdmUgY29udmVydGVkIHRvIGFic29sdXRlIClcbiAgICogUyBjb252ZXJ0ZWQgaW4gQywgVCBjb252ZXJ0ZWQgaW4gUSwgQSBjb252ZXJ0ZWQgaW4gQy5cbiAgICogQHBhcmFtIHtBcnJheX0gcGF0aCB0aGUgYXJyYXkgb2YgY29tbWFuZHMgb2YgYSBwYXJzZWQgc3ZnIHBhdGggZm9yIGZhYnJpYy5QYXRoXG4gICAqIEByZXR1cm4ge0FycmF5fSB0aGUgc2ltcGxpZmllZCBhcnJheSBvZiBjb21tYW5kcyBvZiBhIHBhcnNlZCBzdmcgcGF0aCBmb3IgZmFicmljLlBhdGhcbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VQYXRoU2ltcGxlcihwYXRoKSB7XG4gICAgLy8geCBhbmQgeSByZXByZXNlbnQgdGhlIGxhc3QgcG9pbnQgb2YgdGhlIHBhdGguIHRoZSBwcmV2aW91cyBjb21tYW5kIHBvaW50LlxuICAgIC8vIHdlIGFkZCB0aGVtIHRvIGVhY2ggcmVsYXRpdmUgY29tbWFuZCB0byBtYWtlIGl0IGFuIGFic29sdXRlIGNvbW1lbnQuXG4gICAgLy8gd2UgYWxzbyBzd2FwIHRoZSB2IFYgaCBIIHdpdGggTCwgYmVjYXVzZSBhcmUgZWFzaWVyIHRvIHRyYW5zZm9ybS5cbiAgICB2YXIgeCA9IDAsIHkgPSAwLCBsZW4gPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgLy8geDEgYW5kIHkxIHJlcHJlc2VudCB0aGUgbGFzdCBwb2ludCBvZiB0aGUgc3VicGF0aC4gdGhlIHN1YnBhdGggaXMgc3RhcnRlZCB3aXRoXG4gICAgICAgIC8vIG0gb3IgTSBjb21tYW5kLiBXaGVuIGEgeiBvciBaIGNvbW1hbmQgaXMgZHJhd24sIHggYW5kIHkgbmVlZCB0byBiZSByZXNldHRlZCB0b1xuICAgICAgICAvLyB0aGUgbGFzdCB4MSBhbmQgeTEuXG4gICAgICAgIHgxID0gMCwgeTEgPSAwLCBjdXJyZW50LCBpLCBjb252ZXJ0ZWQsXG4gICAgICAgIC8vIHByZXZpb3VzIHdpbGwgaG9zdCB0aGUgbGV0dGVyIG9mIHRoZSBwcmV2aW91cyBjb21tYW5kLCB0byBoYW5kbGUgUyBhbmQgVC5cbiAgICAgICAgLy8gY29udHJvbFggYW5kIGNvbnRyb2xZIHdpbGwgaG9zdCB0aGUgcHJldmlvdXMgcmVmbGVjdGVkIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgZGVzdGluYXRpb25QYXRoID0gW10sIHByZXZpb3VzLCBjb250cm9sWCwgY29udHJvbFk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb252ZXJ0ZWQgPSBmYWxzZTtcbiAgICAgIGN1cnJlbnQgPSBwYXRoW2ldLnNsaWNlKDApO1xuICAgICAgc3dpdGNoIChjdXJyZW50WzBdKSB7IC8vIGZpcnN0IGxldHRlclxuICAgICAgICBjYXNlICdsJzogLy8gbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnTCc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdoJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgY3VycmVudFswXSA9ICdMJztcbiAgICAgICAgICBjdXJyZW50WzJdID0geTtcbiAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndic6IC8vIHZlcnRpY2FsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ0wnO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzFdO1xuICAgICAgICAgIGN1cnJlbnRbMV0gPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gPSB5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtJzogLy8gbW92ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnTSc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIHgxID0gY3VycmVudFsxXTtcbiAgICAgICAgICB5MSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2MnOiAvLyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnQyc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICBjdXJyZW50WzNdICs9IHg7XG4gICAgICAgICAgY3VycmVudFs0XSArPSB5O1xuICAgICAgICAgIGN1cnJlbnRbNV0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzZdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFswXSA9ICdTJztcbiAgICAgICAgICBjdXJyZW50WzFdICs9IHg7XG4gICAgICAgICAgY3VycmVudFsyXSArPSB5O1xuICAgICAgICAgIGN1cnJlbnRbM10gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzRdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAvLyB3b3VsZCBiZSBzU2NDIGJ1dCBzaW5jZSB3ZSBhcmUgc3dhcHBpbmcgc1NjIGZvciBDLCB3ZSBjaGVjayBqdXN0IHRoYXQuXG4gICAgICAgICAgaWYgKHByZXZpb3VzID09PSAnQycpIHtcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgQywgYywgUywgb3IgcyxcbiAgICAgICAgICAgIC8vIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgICB4ID0gY3VycmVudFszXTtcbiAgICAgICAgICB5ID0gY3VycmVudFs0XTtcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ0MnO1xuICAgICAgICAgIGN1cnJlbnRbNV0gPSBjdXJyZW50WzNdO1xuICAgICAgICAgIGN1cnJlbnRbNl0gPSBjdXJyZW50WzRdO1xuICAgICAgICAgIGN1cnJlbnRbM10gPSBjdXJyZW50WzFdO1xuICAgICAgICAgIGN1cnJlbnRbNF0gPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGN1cnJlbnRbMV0gPSBjb250cm9sWDtcbiAgICAgICAgICBjdXJyZW50WzJdID0gY29udHJvbFk7XG4gICAgICAgICAgLy8gY3VycmVudFszXSBhbmQgY3VycmVudFs0XSBhcmUgTk9XIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICAgICAgICAvLyB3ZSBrZWVwIGl0IGZvciB0aGUgbmV4dCByZWZsZWN0aW9uLlxuICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnUSc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICBjdXJyZW50WzNdICs9IHg7XG4gICAgICAgICAgY3VycmVudFs0XSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcbiAgICAgICAgICB4ID0gY3VycmVudFszXTtcbiAgICAgICAgICB5ID0gY3VycmVudFs0XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndCc6IC8vIHNob3J0aGFuZCBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnVCc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gJ1EnKSB7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgUSwgcSwgVCBvciB0LFxuICAgICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50WzBdID0gJ1EnO1xuICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGN1cnJlbnRbMV0gPSBjb250cm9sWDtcbiAgICAgICAgICBjdXJyZW50WzJdID0gY29udHJvbFk7XG4gICAgICAgICAgY3VycmVudFszXSA9IHg7XG4gICAgICAgICAgY3VycmVudFs0XSA9IHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnQSc7XG4gICAgICAgICAgY3VycmVudFs2XSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbN10gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIGNvbnZlcnRlZCA9IHRydWU7XG4gICAgICAgICAgZGVzdGluYXRpb25QYXRoID0gZGVzdGluYXRpb25QYXRoLmNvbmNhdChmcm9tQXJjVG9CZXppZXJzKHgsIHksIGN1cnJlbnQpKTtcbiAgICAgICAgICB4ID0gY3VycmVudFs2XTtcbiAgICAgICAgICB5ID0gY3VycmVudFs3XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAneic6XG4gICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgIHggPSB4MTtcbiAgICAgICAgICB5ID0geTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgICBpZiAoIWNvbnZlcnRlZCkge1xuICAgICAgICBkZXN0aW5hdGlvblBhdGgucHVzaChjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzID0gY3VycmVudFswXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uUGF0aDtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsYyBsZW5ndGggZnJvbSBwb2ludCB4MSx5MSB0byB4Mix5MlxuICAgKiBAcGFyYW0ge051bWJlcn0geDEgc3RhcnRpbmcgcG9pbnQgeFxuICAgKiBAcGFyYW0ge051bWJlcn0geTEgc3RhcnRpbmcgcG9pbnQgeVxuICAgKiBAcGFyYW0ge051bWJlcn0geDIgc3RhcnRpbmcgcG9pbnQgeFxuICAgKiBAcGFyYW0ge051bWJlcn0geTIgc3RhcnRpbmcgcG9pbnQgeVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGxlbmd0aCBvZiBzZWdtZW50XG4gICAqL1xuICBmdW5jdGlvbiBjYWxjTGluZUxlbmd0aCh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgfVxuXG4gIC8vIGZ1bmN0aW9ucyBmb3IgdGhlIEN1YmljIGJlaXplclxuICAvLyB0YWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20va29udmFqcy9rb252YS9ibG9iLzcuMC41L3NyYy9zaGFwZXMvUGF0aC50cyNMMzUwXG4gIGZ1bmN0aW9uIENCMSh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbiAgfVxuICBmdW5jdGlvbiBDQjIodCkge1xuICAgIHJldHVybiAzICogdCAqIHQgKiAoMSAtIHQpO1xuICB9XG4gIGZ1bmN0aW9uIENCMyh0KSB7XG4gICAgcmV0dXJuIDMgKiB0ICogKDEgLSB0KSAqICgxIC0gdCk7XG4gIH1cbiAgZnVuY3Rpb24gQ0I0KHQpIHtcbiAgICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiAoMSAtIHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UG9pbnRPbkN1YmljQmV6aWVySXRlcmF0b3IocDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSwgcDR4LCBwNHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocGN0KSB7XG4gICAgICB2YXIgYzEgPSBDQjEocGN0KSwgYzIgPSBDQjIocGN0KSwgYzMgPSBDQjMocGN0KSwgYzQgPSBDQjQocGN0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHA0eCAqIGMxICsgcDN4ICogYzIgKyBwMnggKiBjMyArIHAxeCAqIGM0LFxuICAgICAgICB5OiBwNHkgKiBjMSArIHAzeSAqIGMyICsgcDJ5ICogYzMgKyBwMXkgKiBjNFxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGFuZ2VudEN1YmljSXRlcmF0b3IocDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSwgcDR4LCBwNHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBjdCkge1xuICAgICAgdmFyIGludlQgPSAxIC0gcGN0LFxuICAgICAgICAgIHRhbmdlbnRYID0gKDMgKiBpbnZUICogaW52VCAqIChwMnggLSBwMXgpKSArICg2ICogaW52VCAqIHBjdCAqIChwM3ggLSBwMngpKSArXG4gICAgICAgICAgKDMgKiBwY3QgKiBwY3QgKiAocDR4IC0gcDN4KSksXG4gICAgICAgICAgdGFuZ2VudFkgPSAoMyAqIGludlQgKiBpbnZUICogKHAyeSAtIHAxeSkpICsgKDYgKiBpbnZUICogcGN0ICogKHAzeSAtIHAyeSkpICtcbiAgICAgICAgICAoMyAqIHBjdCAqIHBjdCAqIChwNHkgLSBwM3kpKTtcbiAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRhbmdlbnRZLCB0YW5nZW50WCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFFCMSh0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xuICB9XG5cbiAgZnVuY3Rpb24gUUIyKHQpIHtcbiAgICByZXR1cm4gMiAqIHQgKiAoMSAtIHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gUUIzKHQpIHtcbiAgICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQb2ludE9uUXVhZHJhdGljQmV6aWVySXRlcmF0b3IocDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSkge1xuICAgIHJldHVybiBmdW5jdGlvbihwY3QpIHtcbiAgICAgIHZhciBjMSA9IFFCMShwY3QpLCBjMiA9IFFCMihwY3QpLCBjMyA9IFFCMyhwY3QpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcDN4ICogYzEgKyBwMnggKiBjMiArIHAxeCAqIGMzLFxuICAgICAgICB5OiBwM3kgKiBjMSArIHAyeSAqIGMyICsgcDF5ICogYzNcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRhbmdlbnRRdWFkcmF0aWNJdGVyYXRvcihwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwY3QpIHtcbiAgICAgIHZhciBpbnZUID0gMSAtIHBjdCxcbiAgICAgICAgICB0YW5nZW50WCA9ICgyICogaW52VCAqIChwMnggLSBwMXgpKSArICgyICogcGN0ICogKHAzeCAtIHAyeCkpLFxuICAgICAgICAgIHRhbmdlbnRZID0gKDIgKiBpbnZUICogKHAyeSAtIHAxeSkpICsgKDIgKiBwY3QgKiAocDN5IC0gcDJ5KSk7XG4gICAgICByZXR1cm4gTWF0aC5hdGFuMih0YW5nZW50WSwgdGFuZ2VudFgpO1xuICAgIH07XG4gIH1cblxuXG4gIC8vIHRoaXMgd2lsbCBydW4gb3ZlciBhIHBhdGggc2VnbWVudCAoIGEgY3ViaWMgb3IgcXVhZHJhdGljIHNlZ21lbnQpIGFuZCBhcHByb3hpbWF0ZSBpdFxuICAvLyB3aXRoIDEwMCBzZWdlbW50cy4gVGhpcyB3aWxsIGdvb2QgZW5vdWdoIHRvIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBjdXJ2ZVxuICBmdW5jdGlvbiBwYXRoSXRlcmF0b3IoaXRlcmF0b3IsIHgxLCB5MSkge1xuICAgIHZhciB0ZW1wUCA9IHsgeDogeDEsIHk6IHkxIH0sIHAsIHRtcExlbiA9IDAsIHBlcmM7XG4gICAgZm9yIChwZXJjID0gMTsgcGVyYyA8PSAxMDA7IHBlcmMgKz0gMSkge1xuICAgICAgcCA9IGl0ZXJhdG9yKHBlcmMgLyAxMDApO1xuICAgICAgdG1wTGVuICs9IGNhbGNMaW5lTGVuZ3RoKHRlbXBQLngsIHRlbXBQLnksIHAueCwgcC55KTtcbiAgICAgIHRlbXBQID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHRtcExlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIHBhdGhJbmZvLCBhbmQgYSBkaXN0YW5jZSBpbiBwaXhlbHMsIGZpbmQgdGhlIHBlcmNlbnRhZ2UgZnJvbSAwIHRvIDFcbiAgICogdGhhdCBjb3JyZXNwb25kIHRvIHRoYXQgcGl4ZWxzIHJ1biBvdmVyIHRoZSBwYXRoLlxuICAgKiBUaGUgcGVyY2VudGFnZSB3aWxsIGJlIHRoZW4gdXNlZCB0byBmaW5kIHRoZSBjb3JyZWN0IHBvaW50IG9uIHRoZSBjYW52YXMgZm9yIHRoZSBwYXRoLlxuICAgKiBAcGFyYW0ge0FycmF5fSBzZWdJbmZvIGZhYnJpY0pTIGNvbGxlY3Rpb24gb2YgaW5mb3JtYXRpb24gb24gYSBwYXJzZWQgcGF0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGlzdGFuY2UgZnJvbSBzdGFydGluZyBwb2ludCwgaW4gcGl4ZWxzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluZm8gb2JqZWN0IHdpdGggeCBhbmQgeSAoIHRoZSBwb2ludCBvbiBjYW52YXMgKSBhbmQgYW5nbGUsIHRoZSB0YW5nZW50IG9uIHRoYXQgcG9pbnQ7XG4gICAqL1xuICBmdW5jdGlvbiBmaW5kUGVyY2VudGFnZUZvckRpc3RhbmNlKHNlZ0luZm8sIGRpc3RhbmNlKSB7XG4gICAgdmFyIHBlcmMgPSAwLCB0bXBMZW4gPSAwLCBpdGVyYXRvciA9IHNlZ0luZm8uaXRlcmF0b3IsIHRlbXBQID0geyB4OiBzZWdJbmZvLngsIHk6IHNlZ0luZm8ueSB9LFxuICAgICAgICBwLCBuZXh0TGVuLCBuZXh0U3RlcCA9IDAuMDEsIGFuZ2xlRmluZGVyID0gc2VnSW5mby5hbmdsZUZpbmRlciwgbGFzdFBlcmM7XG4gICAgLy8gbmV4dFN0ZXAgPiAwLjAwMDEgY292ZXJzIDAuMDAwMTU2MjUgdGhhdCAxLzY0dGggb2YgMS8xMDBcbiAgICAvLyB0aGUgcGF0aFxuICAgIHdoaWxlICh0bXBMZW4gPCBkaXN0YW5jZSAmJiBuZXh0U3RlcCA+IDAuMDAwMSkge1xuICAgICAgcCA9IGl0ZXJhdG9yKHBlcmMpO1xuICAgICAgbGFzdFBlcmMgPSBwZXJjO1xuICAgICAgbmV4dExlbiA9IGNhbGNMaW5lTGVuZ3RoKHRlbXBQLngsIHRlbXBQLnksIHAueCwgcC55KTtcbiAgICAgIC8vIGNvbXBhcmUgdG1wTGVuIGVhY2ggY3ljbGUgd2l0aCBkaXN0YW5jZSwgZGVjaWRlIG5leHQgcGVyYyB0byB0ZXN0LlxuICAgICAgaWYgKChuZXh0TGVuICsgdG1wTGVuKSA+IGRpc3RhbmNlKSB7XG4gICAgICAgIC8vIHdlIGRpc2NhcmQgdGhpcyBzdGVwIGFuZCB3ZSBtYWtlIHNtYWxsZXIgc3RlcHMuXG4gICAgICAgIHBlcmMgLT0gbmV4dFN0ZXA7XG4gICAgICAgIG5leHRTdGVwIC89IDI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGVtcFAgPSBwO1xuICAgICAgICBwZXJjICs9IG5leHRTdGVwO1xuICAgICAgICB0bXBMZW4gKz0gbmV4dExlbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcC5hbmdsZSA9IGFuZ2xlRmluZGVyKGxhc3RQZXJjKTtcbiAgICByZXR1cm4gcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW4gb3ZlciBhIHBhcnNlZCBhbmQgc2ltcGxpZmVkIHBhdGggYW5kIGV4dHJhYyBzb21lIGluZm9ybWF0aW9ucy5cbiAgICogaW5mb3JtYXRpb25zIGFyZSBsZW5ndGggb2YgZWFjaCBjb21tYW5kIGFuZCBzdGFydGluZyBwb2ludFxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIGZhYnJpY0pTIHBhcnNlZCBwYXRoIGNvbW1hbmRzXG4gICAqIEByZXR1cm4ge0FycmF5fSBwYXRoIGNvbW1hbmRzIGluZm9ybWF0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UGF0aFNlZ21lbnRzSW5mbyhwYXRoKSB7XG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gMCwgbGVuID0gcGF0aC5sZW5ndGgsIGN1cnJlbnQsXG4gICAgICAgIC8veDIgYW5kIHkyIGFyZSB0aGUgY29vcmRzIG9mIHNlZ21lbnQgc3RhcnRcbiAgICAgICAgLy94MSBhbmQgeTEgYXJlIHRoZSBjb29yZHMgb2YgdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgeDEgPSAwLCB5MSA9IDAsIHgyID0gMCwgeTIgPSAwLCBpbmZvID0gW10sIGl0ZXJhdG9yLCB0ZW1wSW5mbywgYW5nbGVGaW5kZXI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY3VycmVudCA9IHBhdGhbaV07XG4gICAgICB0ZW1wSW5mbyA9IHtcbiAgICAgICAgeDogeDEsXG4gICAgICAgIHk6IHkxLFxuICAgICAgICBjb21tYW5kOiBjdXJyZW50WzBdLFxuICAgICAgfTtcbiAgICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvL2ZpcnN0IGxldHRlclxuICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICB0ZW1wSW5mby5sZW5ndGggPSAwO1xuICAgICAgICAgIHgyID0geDEgPSBjdXJyZW50WzFdO1xuICAgICAgICAgIHkyID0geTEgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICB0ZW1wSW5mby5sZW5ndGggPSBjYWxjTGluZUxlbmd0aCh4MSwgeTEsIGN1cnJlbnRbMV0sIGN1cnJlbnRbMl0pO1xuICAgICAgICAgIHgxID0gY3VycmVudFsxXTtcbiAgICAgICAgICB5MSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgIGl0ZXJhdG9yID0gZ2V0UG9pbnRPbkN1YmljQmV6aWVySXRlcmF0b3IoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgICBjdXJyZW50WzZdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhbmdsZUZpbmRlciA9IGdldFRhbmdlbnRDdWJpY0l0ZXJhdG9yKFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgICAgY3VycmVudFs2XVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGVtcEluZm8uaXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgICAgICAgICB0ZW1wSW5mby5hbmdsZUZpbmRlciA9IGFuZ2xlRmluZGVyO1xuICAgICAgICAgIHRlbXBJbmZvLmxlbmd0aCA9IHBhdGhJdGVyYXRvcihpdGVyYXRvciwgeDEsIHkxKTtcbiAgICAgICAgICB4MSA9IGN1cnJlbnRbNV07XG4gICAgICAgICAgeTEgPSBjdXJyZW50WzZdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICBpdGVyYXRvciA9IGdldFBvaW50T25RdWFkcmF0aWNCZXppZXJJdGVyYXRvcihcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICBjdXJyZW50WzRdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhbmdsZUZpbmRlciA9IGdldFRhbmdlbnRRdWFkcmF0aWNJdGVyYXRvcihcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICBjdXJyZW50WzRdXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0ZW1wSW5mby5pdGVyYXRvciA9IGl0ZXJhdG9yO1xuICAgICAgICAgIHRlbXBJbmZvLmFuZ2xlRmluZGVyID0gYW5nbGVGaW5kZXI7XG4gICAgICAgICAgdGVtcEluZm8ubGVuZ3RoID0gcGF0aEl0ZXJhdG9yKGl0ZXJhdG9yLCB4MSwgeTEpO1xuICAgICAgICAgIHgxID0gY3VycmVudFszXTtcbiAgICAgICAgICB5MSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1onOlxuICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAvLyB3ZSBhZGQgdGhvc2UgaW4gb3JkZXIgdG8gZWFzZSBjYWxjdWxhdGlvbnMgbGF0ZXJcbiAgICAgICAgICB0ZW1wSW5mby5kZXN0WCA9IHgyO1xuICAgICAgICAgIHRlbXBJbmZvLmRlc3RZID0geTI7XG4gICAgICAgICAgdGVtcEluZm8ubGVuZ3RoID0gY2FsY0xpbmVMZW5ndGgoeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgIHgxID0geDI7XG4gICAgICAgICAgeTEgPSB5MjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRvdGFsTGVuZ3RoICs9IHRlbXBJbmZvLmxlbmd0aDtcbiAgICAgIGluZm8ucHVzaCh0ZW1wSW5mbyk7XG4gICAgfVxuICAgIGluZm8ucHVzaCh7IGxlbmd0aDogdG90YWxMZW5ndGgsIHg6IHgxLCB5OiB5MSB9KTtcbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBvaW50T25QYXRoKHBhdGgsIGRpc3RhbmNlLCBpbmZvcykge1xuICAgIGlmICghaW5mb3MpIHtcbiAgICAgIGluZm9zID0gZ2V0UGF0aFNlZ21lbnRzSW5mbyhwYXRoKTtcbiAgICB9XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlICgoZGlzdGFuY2UgLSBpbmZvc1tpXS5sZW5ndGggPiAwKSAmJiBpIDwgKGluZm9zLmxlbmd0aCAtIDIpKSB7XG4gICAgICBkaXN0YW5jZSAtPSBpbmZvc1tpXS5sZW5ndGg7XG4gICAgICBpKys7XG4gICAgfVxuICAgIC8vIHZhciBkaXN0YW5jZSA9IGluZm9zW2luZm9zLmxlbmd0aCAtIDFdICogcGVyYztcbiAgICB2YXIgc2VnSW5mbyA9IGluZm9zW2ldLCBzZWdQZXJjZW50ID0gZGlzdGFuY2UgLyBzZWdJbmZvLmxlbmd0aCxcbiAgICAgICAgY29tbWFuZCA9IHNlZ0luZm8uY29tbWFuZCwgc2VnbWVudCA9IHBhdGhbaV0sIGluZm87XG5cbiAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgIGNhc2UgJ00nOlxuICAgICAgICByZXR1cm4geyB4OiBzZWdJbmZvLngsIHk6IHNlZ0luZm8ueSwgYW5nbGU6IDAgfTtcbiAgICAgIGNhc2UgJ1onOlxuICAgICAgY2FzZSAneic6XG4gICAgICAgIGluZm8gPSBuZXcgZmFicmljLlBvaW50KHNlZ0luZm8ueCwgc2VnSW5mby55KS5sZXJwKFxuICAgICAgICAgIG5ldyBmYWJyaWMuUG9pbnQoc2VnSW5mby5kZXN0WCwgc2VnSW5mby5kZXN0WSksXG4gICAgICAgICAgc2VnUGVyY2VudFxuICAgICAgICApO1xuICAgICAgICBpbmZvLmFuZ2xlID0gTWF0aC5hdGFuMihzZWdJbmZvLmRlc3RZIC0gc2VnSW5mby55LCBzZWdJbmZvLmRlc3RYIC0gc2VnSW5mby54KTtcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICBjYXNlICdMJzpcbiAgICAgICAgaW5mbyA9IG5ldyBmYWJyaWMuUG9pbnQoc2VnSW5mby54LCBzZWdJbmZvLnkpLmxlcnAoXG4gICAgICAgICAgbmV3IGZhYnJpYy5Qb2ludChzZWdtZW50WzFdLCBzZWdtZW50WzJdKSxcbiAgICAgICAgICBzZWdQZXJjZW50XG4gICAgICAgICk7XG4gICAgICAgIGluZm8uYW5nbGUgPSBNYXRoLmF0YW4yKHNlZ21lbnRbMl0gLSBzZWdJbmZvLnksIHNlZ21lbnRbMV0gLSBzZWdJbmZvLngpO1xuICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgIGNhc2UgJ0MnOlxuICAgICAgICByZXR1cm4gZmluZFBlcmNlbnRhZ2VGb3JEaXN0YW5jZShzZWdJbmZvLCBkaXN0YW5jZSk7XG4gICAgICBjYXNlICdRJzpcbiAgICAgICAgcmV0dXJuIGZpbmRQZXJjZW50YWdlRm9yRGlzdGFuY2Uoc2VnSW5mbywgZGlzdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZ1xuICAgKiBAcmV0dXJuIHsoc3RyaW5nfG51bWJlcilbXVtdfSBBbiBhcnJheSBvZiBTVkcgcGF0aCBjb21tYW5kc1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2FnZTwvY2FwdGlvbj5cbiAgICogcGFyc2VQYXRoKCdNIDMgNCBRIDMgNSAyIDEgNCAwIFEgOSAxMiAyIDEgNCAwJykgPT09IFtcbiAgICogICBbJ00nLCAzLCA0XSxcbiAgICogICBbJ1EnLCAzLCA1LCAyLCAxLCA0LCAwXSxcbiAgICogICBbJ1EnLCA5LCAxMiwgMiwgMSwgNCwgMF0sXG4gICAqIF07XG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aFN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgY29vcmRzID0gW10sXG4gICAgICAgIGN1cnJlbnRQYXRoLFxuICAgICAgICBwYXJzZWQsXG4gICAgICAgIHJlID0gZmFicmljLnJlUGF0aENvbW1hbmQsXG4gICAgICAgIHJOdW1iZXIgPSAnWy0rXT8oPzpcXFxcZCpcXFxcLlxcXFxkK3xcXFxcZCtcXFxcLj8pKD86W2VFXVstK10/XFxcXGQrKT9cXFxccyonLFxuICAgICAgICByTnVtYmVyQ29tbWFXc3AgPSAnKCcgKyByTnVtYmVyICsgJyknICsgZmFicmljLmNvbW1hV3NwLFxuICAgICAgICByRmxhZ0NvbW1hV3NwID0gJyhbMDFdKScgKyBmYWJyaWMuY29tbWFXc3AgKyAnPycsXG4gICAgICAgIHJBcmNTZXEgPSByTnVtYmVyQ29tbWFXc3AgKyAnPycgKyByTnVtYmVyQ29tbWFXc3AgKyAnPycgKyByTnVtYmVyQ29tbWFXc3AgKyByRmxhZ0NvbW1hV3NwICsgckZsYWdDb21tYVdzcCArXG4gICAgICAgICAgck51bWJlckNvbW1hV3NwICsgJz8oJyArIHJOdW1iZXIgKyAnKScsXG4gICAgICAgIHJlZ0FyY0FyZ3VtZW50U2VxdWVuY2UgPSBuZXcgUmVnRXhwKHJBcmNTZXEsICdnJyksXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBjb29yZHNTdHIsXG4gICAgICAgIC8vIG9uZSBvZiBjb21tYW5kcyAobSxNLGwsTCxxLFEsYyxDLGV0Yy4pIGZvbGxvd2VkIGJ5IG5vbi1jb21tYW5kIGNoYXJhY3RlcnMgKGkuZS4gY29tbWFuZCB2YWx1ZXMpXG4gICAgICAgIHBhdGg7XG4gICAgaWYgKCFwYXRoU3RyaW5nIHx8ICFwYXRoU3RyaW5nLm1hdGNoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwYXRoID0gcGF0aFN0cmluZy5tYXRjaCgvW216bGh2Y3NxdGFdW15temxodmNzcXRhXSovZ2kpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGNvb3Jkc1BhcnNlZCwgbGVuID0gcGF0aC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY3VycmVudFBhdGggPSBwYXRoW2ldO1xuXG4gICAgICBjb29yZHNTdHIgPSBjdXJyZW50UGF0aC5zbGljZSgxKS50cmltKCk7XG4gICAgICBjb29yZHMubGVuZ3RoID0gMDtcblxuICAgICAgdmFyIGNvbW1hbmQgPSBjdXJyZW50UGF0aC5jaGFyQXQoMCk7XG4gICAgICBjb29yZHNQYXJzZWQgPSBbY29tbWFuZF07XG5cbiAgICAgIGlmIChjb21tYW5kLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuICAgICAgICAvLyBhcmNzIGhhdmUgc3BlY2lhbCBmbGFncyB0aGF0IGFwcGFyZW50bHkgZG9uJ3QgcmVxdWlyZSBzcGFjZXMgc28gaGFuZGxlIHNwZWNpYWxcbiAgICAgICAgZm9yICh2YXIgYXJnczsgKGFyZ3MgPSByZWdBcmNBcmd1bWVudFNlcXVlbmNlLmV4ZWMoY29vcmRzU3RyKSk7KSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb29yZHMucHVzaChhcmdzW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhjb29yZHNTdHIpKSkge1xuICAgICAgICAgIGNvb3Jkcy5wdXNoKG1hdGNoWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGNvb3Jkcy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgcGFyc2VkID0gcGFyc2VGbG9hdChjb29yZHNbal0pO1xuICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZCkpIHtcbiAgICAgICAgICBjb29yZHNQYXJzZWQucHVzaChwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21tYW5kTGVuZ3RoID0gY29tbWFuZExlbmd0aHNbY29tbWFuZC50b0xvd2VyQ2FzZSgpXSxcbiAgICAgICAgICByZXBlYXRlZENvbW1hbmQgPSByZXBlYXRlZENvbW1hbmRzW2NvbW1hbmRdIHx8IGNvbW1hbmQ7XG5cbiAgICAgIGlmIChjb29yZHNQYXJzZWQubGVuZ3RoIC0gMSA+IGNvbW1hbmRMZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgayA9IDEsIGtsZW4gPSBjb29yZHNQYXJzZWQubGVuZ3RoOyBrIDwga2xlbjsgayArPSBjb21tYW5kTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goW2NvbW1hbmRdLmNvbmNhdChjb29yZHNQYXJzZWQuc2xpY2UoaywgayArIGNvbW1hbmRMZW5ndGgpKSk7XG4gICAgICAgICAgY29tbWFuZCA9IHJlcGVhdGVkQ29tbWFuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNvb3Jkc1BhcnNlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICpcbiAgICogQ29udmVydHMgcG9pbnRzIHRvIGEgc21vb3RoIFNWRyBwYXRoXG4gICAqIEBwYXJhbSB7eyB4OiBudW1iZXIseTogbnVtYmVyIH1bXX0gcG9pbnRzIEFycmF5IG9mIHBvaW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvcnJlY3Rpb25dIEFwcGx5IGEgY29ycmVjdGlvbiB0byB0aGUgcGF0aCAodXN1YWxseSB3ZSB1c2UgYHdpZHRoIC8gMTAwMGApLiBJZiB2YWx1ZSBpcyB1bmRlZmluZWQgMCBpcyB1c2VkIGFzIHRoZSBjb3JyZWN0aW9uIHZhbHVlLlxuICAgKiBAcmV0dXJuIHsoc3RyaW5nfG51bWJlcilbXVtdfSBBbiBhcnJheSBvZiBTVkcgcGF0aCBjb21tYW5kc1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U21vb3RoUGF0aEZyb21Qb2ludHMocG9pbnRzLCBjb3JyZWN0aW9uKSB7XG4gICAgdmFyIHBhdGggPSBbXSwgaSxcbiAgICAgICAgcDEgPSBuZXcgZmFicmljLlBvaW50KHBvaW50c1swXS54LCBwb2ludHNbMF0ueSksXG4gICAgICAgIHAyID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnkpLFxuICAgICAgICBsZW4gPSBwb2ludHMubGVuZ3RoLCBtdWx0U2lnblggPSAxLCBtdWx0U2lnblkgPSAwLCBtYW55UG9pbnRzID0gbGVuID4gMjtcbiAgICBjb3JyZWN0aW9uID0gY29ycmVjdGlvbiB8fCAwO1xuXG4gICAgaWYgKG1hbnlQb2ludHMpIHtcbiAgICAgIG11bHRTaWduWCA9IHBvaW50c1syXS54IDwgcDIueCA/IC0xIDogcG9pbnRzWzJdLnggPT09IHAyLnggPyAwIDogMTtcbiAgICAgIG11bHRTaWduWSA9IHBvaW50c1syXS55IDwgcDIueSA/IC0xIDogcG9pbnRzWzJdLnkgPT09IHAyLnkgPyAwIDogMTtcbiAgICB9XG4gICAgcGF0aC5wdXNoKFsnTScsIHAxLnggLSBtdWx0U2lnblggKiBjb3JyZWN0aW9uLCBwMS55IC0gbXVsdFNpZ25ZICogY29ycmVjdGlvbl0pO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFwMS5lcShwMikpIHtcbiAgICAgICAgdmFyIG1pZFBvaW50ID0gcDEubWlkUG9pbnRGcm9tKHAyKTtcbiAgICAgICAgLy8gcDEgaXMgb3VyIGJlemllciBjb250cm9sIHBvaW50XG4gICAgICAgIC8vIG1pZHBvaW50IGlzIG91ciBlbmRwb2ludFxuICAgICAgICAvLyBzdGFydCBwb2ludCBpcyBwKGktMSkgdmFsdWUuXG4gICAgICAgIHBhdGgucHVzaChbJ1EnLCBwMS54LCBwMS55LCBtaWRQb2ludC54LCBtaWRQb2ludC55XSk7XG4gICAgICB9XG4gICAgICBwMSA9IHBvaW50c1tpXTtcbiAgICAgIGlmICgoaSArIDEpIDwgcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICBwMiA9IHBvaW50c1tpICsgMV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYW55UG9pbnRzKSB7XG4gICAgICBtdWx0U2lnblggPSBwMS54ID4gcG9pbnRzW2kgLSAyXS54ID8gMSA6IHAxLnggPT09IHBvaW50c1tpIC0gMl0ueCA/IDAgOiAtMTtcbiAgICAgIG11bHRTaWduWSA9IHAxLnkgPiBwb2ludHNbaSAtIDJdLnkgPyAxIDogcDEueSA9PT0gcG9pbnRzW2kgLSAyXS55ID8gMCA6IC0xO1xuICAgIH1cbiAgICBwYXRoLnB1c2goWydMJywgcDEueCArIG11bHRTaWduWCAqIGNvcnJlY3Rpb24sIHAxLnkgKyBtdWx0U2lnblkgKiBjb3JyZWN0aW9uXSk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBhIHBhdGggYnkgdHJhbnNmb3JtaW5nIGVhY2ggc2VnbWVudC5cbiAgICogaXQgaGFzIHRvIGJlIGEgc2ltcGxpZmllZCBwYXRoIG9yIGl0IHdvbid0IHdvcmsuXG4gICAqIFdBUk5JTkc6IHRoaXMgZGVwZW5kcyBmcm9tIHBhdGhPZmZzZXQgZm9yIGNvcnJlY3Qgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggZmFicmljSlMgcGFyc2VkIGFuZCBzaW1wbGlmaWVkIHBhdGggY29tbWFuZHNcbiAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtIG1hdHJpeCB0aGF0IHJlcHJlc2VudCB0aGUgdHJhbnNmb3JtYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXRoT2Zmc2V0XSB0aGUgZmFicmljLlBhdGggcGF0aE9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcn0gcGF0aE9mZnNldC54XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwYXRoT2Zmc2V0LnlcbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgdHJhbnNmb3JtZWQgcGF0aFxuICAgKi9cbiAgZnVuY3Rpb24gdHJhbnNmb3JtUGF0aChwYXRoLCB0cmFuc2Zvcm0sIHBhdGhPZmZzZXQpIHtcbiAgICBpZiAocGF0aE9mZnNldCkge1xuICAgICAgdHJhbnNmb3JtID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBbMSwgMCwgMCwgMSwgLXBhdGhPZmZzZXQueCwgLXBhdGhPZmZzZXQueV1cbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLm1hcChmdW5jdGlvbihwYXRoU2VnbWVudCkge1xuICAgICAgdmFyIG5ld1NlZ21lbnQgPSBwYXRoU2VnbWVudC5zbGljZSgwKSwgcG9pbnQgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcGF0aFNlZ21lbnQubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgICAgIHBvaW50LnggPSBwYXRoU2VnbWVudFtpXTtcbiAgICAgICAgcG9pbnQueSA9IHBhdGhTZWdtZW50W2kgKyAxXTtcbiAgICAgICAgcG9pbnQgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwb2ludCwgdHJhbnNmb3JtKTtcbiAgICAgICAgbmV3U2VnbWVudFtpXSA9IHBvaW50Lng7XG4gICAgICAgIG5ld1NlZ21lbnRbaSArIDFdID0gcG9pbnQueTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdTZWdtZW50O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEpvaW4gcGF0aCBjb21tYW5kcyB0byBnbyBiYWNrIHRvIHN2ZyBmb3JtYXRcbiAgICogQHBhcmFtIHtBcnJheX0gcGF0aERhdGEgZmFicmljSlMgcGFyc2VkIHBhdGggY29tbWFuZHNcbiAgICogQHJldHVybiB7U3RyaW5nfSBqb2luZWQgcGF0aCAnTSAwIDAgTCAyMCAzMCdcbiAgICovXG4gIGZhYnJpYy51dGlsLmpvaW5QYXRoID0gZnVuY3Rpb24ocGF0aERhdGEpIHtcbiAgICByZXR1cm4gcGF0aERhdGEubWFwKGZ1bmN0aW9uIChzZWdtZW50KSB7IHJldHVybiBzZWdtZW50LmpvaW4oJyAnKTsgfSkuam9pbignICcpO1xuICB9O1xuICBmYWJyaWMudXRpbC5wYXJzZVBhdGggPSBwYXJzZVBhdGg7XG4gIGZhYnJpYy51dGlsLm1ha2VQYXRoU2ltcGxlciA9IG1ha2VQYXRoU2ltcGxlcjtcbiAgZmFicmljLnV0aWwuZ2V0U21vb3RoUGF0aEZyb21Qb2ludHMgPSBnZXRTbW9vdGhQYXRoRnJvbVBvaW50cztcbiAgZmFicmljLnV0aWwuZ2V0UGF0aFNlZ21lbnRzSW5mbyA9IGdldFBhdGhTZWdtZW50c0luZm87XG4gIGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUgPSBnZXRCb3VuZHNPZkN1cnZlO1xuICBmYWJyaWMudXRpbC5nZXRQb2ludE9uUGF0aCA9IGdldFBvaW50T25QYXRoO1xuICBmYWJyaWMudXRpbC50cmFuc2Zvcm1QYXRoID0gdHJhbnNmb3JtUGF0aDtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAvKipcbiAgICogSW52b2tlcyBtZXRob2Qgb24gYWxsIGl0ZW1zIGluIGEgZ2l2ZW4gYXJyYXlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE5hbWUgb2YgYSBtZXRob2QgdG8gaW52b2tlXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gaW52b2tlKGFycmF5LCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSwgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBhcmdzLmxlbmd0aCA/IGFycmF5W2ldW21ldGhvZF0uYXBwbHkoYXJyYXlbaV0sIGFyZ3MpIDogYXJyYXlbaV1bbWV0aG9kXS5jYWxsKGFycmF5W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBtYXhpbXVtIHZhbHVlIGluIGFycmF5IChub3QgbmVjZXNzYXJpbHkgXCJmaXJzdFwiIG9uZSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnlQcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gbWF4KGFycmF5LCBieVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxID49IHZhbHVlMjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBtaW5pbXVtIHZhbHVlIGluIGFycmF5IChub3QgbmVjZXNzYXJpbHkgXCJmaXJzdFwiIG9uZSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmFycmF5XG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IEFycmF5IHRvIGl0ZXJhdGUgb3ZlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnlQcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZnVuY3Rpb24gbWluKGFycmF5LCBieVByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGZ1bmN0aW9uKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICByZXR1cm4gdmFsdWUxIDwgdmFsdWUyO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBrID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChrLS0pIHtcbiAgICAgIGFycmF5W2tdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluZChhcnJheSwgYnlQcm9wZXJ0eSwgY29uZGl0aW9uKSB7XG4gICAgaWYgKCFhcnJheSB8fCBhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDEsXG4gICAgICAgIHJlc3VsdCA9IGJ5UHJvcGVydHkgPyBhcnJheVtpXVtieVByb3BlcnR5XSA6IGFycmF5W2ldO1xuICAgIGlmIChieVByb3BlcnR5KSB7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24oYXJyYXlbaV1bYnlQcm9wZXJ0eV0sIHJlc3VsdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBhcnJheVtpXVtieVByb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihhcnJheVtpXSwgcmVzdWx0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMudXRpbC5hcnJheVxuICAgKi9cbiAgZmFicmljLnV0aWwuYXJyYXkgPSB7XG4gICAgZmlsbDogZmlsbCxcbiAgICBpbnZva2U6IGludm9rZSxcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heFxuICB9O1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIENvcGllcyBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIG9uZSBqcyBvYmplY3QgdG8gYW5vdGhlclxuICAgKiB0aGlzIGRvZXMgbm90IGFuZCBjYW5ub3QgY29tcGV0ZSB3aXRoIGdlbmVyaWMgdXRpbHMuXG4gICAqIERvZXMgbm90IGNsb25lIG9yIGV4dGVuZCBmYWJyaWMuT2JqZWN0IHN1YmNsYXNzZXMuXG4gICAqIFRoaXMgaXMgbW9zdGx5IGZvciBpbnRlcm5hbCB1c2UgYW5kIGhhcyBleHRyYSBoYW5kbGluZyBmb3IgZmFicmljSlMgb2JqZWN0c1xuICAgKiBpdCBza2lwcyB0aGUgY2FudmFzIGFuZCBncm91cCBwcm9wZXJ0aWVzIGluIGRlZXAgY2xvbmluZy5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLm9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdGluYXRpb24gV2hlcmUgdG8gY29weSB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFdoZXJlIHRvIGNvcHkgZnJvbVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZWVwXSBXaGV0aGVyIHRvIGV4dGVuZCBuZXN0ZWQgb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGV4dGVuZChkZXN0aW5hdGlvbiwgc291cmNlLCBkZWVwKSB7XG4gICAgLy8gSlNjcmlwdCBEb250RW51bSBidWcgaXMgbm90IHRha2VuIGNhcmUgb2ZcbiAgICAvLyB0aGUgZGVlcCBjbG9uZSBpcyBmb3IgaW50ZXJuYWwgdXNlLCBpcyBub3QgbWVhbnQgdG8gYXZvaWRcbiAgICAvLyBqYXZhc2NyaXB0IHRyYXBzIG9yIGNsb25pbmcgaHRtbCBlbGVtZW50IG9yIHNlbGYgcmVmZXJlbmNlZCBvYmplY3RzLlxuICAgIGlmIChkZWVwKSB7XG4gICAgICBpZiAoIWZhYnJpYy5pc0xpa2VseU5vZGUgJiYgc291cmNlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAvLyBhdm9pZCBjbG9uaW5nIGRlZXAgaW1hZ2VzLCBjYW52YXNlcyxcbiAgICAgICAgZGVzdGluYXRpb24gPSBzb3VyY2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBkZXN0aW5hdGlvbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZGVzdGluYXRpb25baV0gPSBleHRlbmQoeyB9LCBzb3VyY2VbaV0sIGRlZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzb3VyY2UgJiYgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnY2FudmFzJyB8fCBwcm9wZXJ0eSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gY2xvbmUgdGhpcyBwcm9wcyBhdCBhbGwuXG4gICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGtlZXAgdGhlIGtleXMgaW4gdGhlIGNvcHlcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IGV4dGVuZCh7IH0sIHNvdXJjZVtwcm9wZXJ0eV0sIGRlZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgc291bmRzIG9kZCBmb3IgYW4gZXh0ZW5kIGJ1dCBpcyBvayBmb3IgcmVjdXJzaXZlIHVzZVxuICAgICAgICBkZXN0aW5hdGlvbiA9IHNvdXJjZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gZW1wdHkgb2JqZWN0IGFuZCBjb3BpZXMgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBhbm90aGVyIG9iamVjdCB0byBpdFxuICAgKiBUaGlzIG1ldGhvZCBpcyBtb3N0bHkgZm9yIGludGVybmFsIHVzZSwgYW5kIG5vdCBpbnRlbmRlZCBmb3IgZHVwbGljYXRpbmcgc2hhcGVzIGluIGNhbnZhcy4gXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5vYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2xvbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZGVlcF0gV2hldGhlciB0byBjbG9uZSBuZXN0ZWQgb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG4gIC8vVE9ETzogdGhpcyBmdW5jdGlvbiByZXR1cm4gYW4gZW1wdHkgb2JqZWN0IGlmIHlvdSB0cnkgdG8gY2xvbmUgbnVsbFxuICBmdW5jdGlvbiBjbG9uZShvYmplY3QsIGRlZXApIHtcbiAgICByZXR1cm4gZXh0ZW5kKHsgfSwgb2JqZWN0LCBkZWVwKTtcbiAgfVxuXG4gIC8qKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLm9iamVjdCAqL1xuICBmYWJyaWMudXRpbC5vYmplY3QgPSB7XG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgY2xvbmU6IGNsb25lXG4gIH07XG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLnV0aWwsIGZhYnJpYy5PYnNlcnZhYmxlKTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBDYW1lbGl6ZXMgYSBzdHJpbmdcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBjYW1lbGl6ZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IENhbWVsaXplZCB2ZXJzaW9uIG9mIGEgc3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLy0rKC4pPy9nLCBmdW5jdGlvbihtYXRjaCwgY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyID8gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYXBpdGFsaXplcyBhIHN0cmluZ1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGNhcGl0YWxpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZmlyc3RMZXR0ZXJPbmx5XSBJZiB0cnVlIG9ubHkgZmlyc3QgbGV0dGVyIGlzIGNhcGl0YWxpemVkXG4gICAqIGFuZCBvdGhlciBsZXR0ZXJzIHN0YXkgdW50b3VjaGVkLCBpZiBmYWxzZSBmaXJzdCBsZXR0ZXIgaXMgY2FwaXRhbGl6ZWRcbiAgICogYW5kIG90aGVyIGxldHRlcnMgYXJlIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQ2FwaXRhbGl6ZWQgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcsIGZpcnN0TGV0dGVyT25seSkge1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgKGZpcnN0TGV0dGVyT25seSA/IHN0cmluZy5zbGljZSgxKSA6IHN0cmluZy5zbGljZSgxKS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc2NhcGVzIFhNTCBpbiBhIHN0cmluZ1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGVzY2FwZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEVzY2FwZWQgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlWG1sKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxuICAgICAgLnJlcGxhY2UoLycvZywgJyZhcG9zOycpXG4gICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpdmlkZSBhIHN0cmluZyBpbiB0aGUgdXNlciBwZXJjZWl2ZWQgc2luZ2xlIHVuaXRzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5zdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRzdHJpbmcgU3RyaW5nIHRvIGVzY2FwZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgY29udGFpbmluZyB0aGUgZ3JhcGhlbWVzXG4gICAqL1xuICBmdW5jdGlvbiBncmFwaGVtZVNwbGl0KHRleHRzdHJpbmcpIHtcbiAgICB2YXIgaSA9IDAsIGNociwgZ3JhcGhlbWVzID0gW107XG4gICAgZm9yIChpID0gMCwgY2hyOyBpIDwgdGV4dHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKChjaHIgPSBnZXRXaG9sZUNoYXIodGV4dHN0cmluZywgaSkpID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGdyYXBoZW1lcy5wdXNoKGNocik7XG4gICAgfVxuICAgIHJldHVybiBncmFwaGVtZXM7XG4gIH1cblxuICAvLyB0YWtlbiBmcm9tIG1kbiBpbiB0aGUgY2hhckF0IGRvYyBwYWdlLlxuICBmdW5jdGlvbiBnZXRXaG9sZUNoYXIoc3RyLCBpKSB7XG4gICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChpc05hTihjb2RlKSkge1xuICAgICAgcmV0dXJuICcnOyAvLyBQb3NpdGlvbiBub3QgZm91bmRcbiAgICB9XG4gICAgaWYgKGNvZGUgPCAweEQ4MDAgfHwgY29kZSA+IDB4REZGRikge1xuICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoaSk7XG4gICAgfVxuXG4gICAgLy8gSGlnaCBzdXJyb2dhdGUgKGNvdWxkIGNoYW5nZSBsYXN0IGhleCB0byAweERCN0YgdG8gdHJlYXQgaGlnaCBwcml2YXRlXG4gICAgLy8gc3Vycm9nYXRlcyBhcyBzaW5nbGUgY2hhcmFjdGVycylcbiAgICBpZiAoMHhEODAwIDw9IGNvZGUgJiYgY29kZSA8PSAweERCRkYpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoIDw9IChpICsgMSkpIHtcbiAgICAgICAgdGhyb3cgJ0hpZ2ggc3Vycm9nYXRlIHdpdGhvdXQgZm9sbG93aW5nIGxvdyBzdXJyb2dhdGUnO1xuICAgICAgfVxuICAgICAgdmFyIG5leHQgPSBzdHIuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICBpZiAoMHhEQzAwID4gbmV4dCB8fCBuZXh0ID4gMHhERkZGKSB7XG4gICAgICAgIHRocm93ICdIaWdoIHN1cnJvZ2F0ZSB3aXRob3V0IGZvbGxvd2luZyBsb3cgc3Vycm9nYXRlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHIuY2hhckF0KGkpICsgc3RyLmNoYXJBdChpICsgMSk7XG4gICAgfVxuICAgIC8vIExvdyBzdXJyb2dhdGUgKDB4REMwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHhERkZGKVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICB0aHJvdyAnTG93IHN1cnJvZ2F0ZSB3aXRob3V0IHByZWNlZGluZyBoaWdoIHN1cnJvZ2F0ZSc7XG4gICAgfVxuICAgIHZhciBwcmV2ID0gc3RyLmNoYXJDb2RlQXQoaSAtIDEpO1xuXG4gICAgLy8gKGNvdWxkIGNoYW5nZSBsYXN0IGhleCB0byAweERCN0YgdG8gdHJlYXQgaGlnaCBwcml2YXRlXG4gICAgLy8gc3Vycm9nYXRlcyBhcyBzaW5nbGUgY2hhcmFjdGVycylcbiAgICBpZiAoMHhEODAwID4gcHJldiB8fCBwcmV2ID4gMHhEQkZGKSB7XG4gICAgICB0aHJvdyAnTG93IHN1cnJvZ2F0ZSB3aXRob3V0IHByZWNlZGluZyBoaWdoIHN1cnJvZ2F0ZSc7XG4gICAgfVxuICAgIC8vIFdlIGNhbiBwYXNzIG92ZXIgbG93IHN1cnJvZ2F0ZXMgbm93IGFzIHRoZSBzZWNvbmQgY29tcG9uZW50XG4gICAgLy8gaW4gYSBwYWlyIHdoaWNoIHdlIGhhdmUgYWxyZWFkeSBwcm9jZXNzZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTdHJpbmcgdXRpbGl0aWVzXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqL1xuICBmYWJyaWMudXRpbC5zdHJpbmcgPSB7XG4gICAgY2FtZWxpemU6IGNhbWVsaXplLFxuICAgIGNhcGl0YWxpemU6IGNhcGl0YWxpemUsXG4gICAgZXNjYXBlWG1sOiBlc2NhcGVYbWwsXG4gICAgZ3JhcGhlbWVTcGxpdDogZ3JhcGhlbWVTcGxpdFxuICB9O1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLCBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7IH0sXG5cbiAgICAgIElTX0RPTlRFTlVNX0JVR0dZID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBwIGluIHsgdG9TdHJpbmc6IDEgfSkge1xuICAgICAgICAgIGlmIChwID09PSAndG9TdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSkoKSxcblxuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIGFkZE1ldGhvZHMgPSBmdW5jdGlvbihrbGFzcywgc291cmNlLCBwYXJlbnQpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG5cbiAgICAgICAgICBpZiAocHJvcGVydHkgaW4ga2xhc3MucHJvdG90eXBlICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBrbGFzcy5wcm90b3R5cGVbcHJvcGVydHldID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgIChzb3VyY2VbcHJvcGVydHldICsgJycpLmluZGV4T2YoJ2NhbGxTdXBlcicpID4gLTEpIHtcblxuICAgICAgICAgICAga2xhc3MucHJvdG90eXBlW3Byb3BlcnR5XSA9IChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3VwZXJjbGFzcyA9IHRoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcztcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gc291cmNlW3Byb3BlcnR5XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3M7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkgIT09ICdpbml0aWFsaXplJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrbGFzcy5wcm90b3R5cGVbcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSVNfRE9OVEVOVU1fQlVHR1kpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHtcbiAgICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLnRvU3RyaW5nID0gc291cmNlLnRvU3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHtcbiAgICAgICAgICAgICAga2xhc3MucHJvdG90eXBlLnZhbHVlT2YgPSBzb3VyY2UudmFsdWVPZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgZnVuY3Rpb24gU3ViY2xhc3MoKSB7IH1cblxuICBmdW5jdGlvbiBjYWxsU3VwZXIobWV0aG9kTmFtZSkge1xuICAgIHZhciBwYXJlbnRNZXRob2QgPSBudWxsLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBjbGltYiBwcm90b3R5cGUgY2hhaW4gdG8gZmluZCBtZXRob2Qgbm90IGVxdWFsIHRvIGNhbGxlZSdzIG1ldGhvZFxuICAgIHdoaWxlIChfdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzKSB7XG4gICAgICB2YXIgc3VwZXJDbGFzc01ldGhvZCA9IF90aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKF90aGlzW21ldGhvZE5hbWVdICE9PSBzdXBlckNsYXNzTWV0aG9kKSB7XG4gICAgICAgIHBhcmVudE1ldGhvZCA9IHN1cGVyQ2xhc3NNZXRob2Q7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBfdGhpcyA9IF90aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MucHJvdG90eXBlO1xuICAgIH1cblxuICAgIGlmICghcGFyZW50TWV0aG9kKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5sb2coJ3RyaWVkIHRvIGNhbGxTdXBlciAnICsgbWV0aG9kTmFtZSArICcsIG1ldGhvZCBub3QgZm91bmQgaW4gcHJvdG90eXBlIGNoYWluJywgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgID8gcGFyZW50TWV0aG9kLmFwcGx5KHRoaXMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSlcbiAgICAgIDogcGFyZW50TWV0aG9kLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZvciBjcmVhdGlvbiBvZiBcImNsYXNzZXNcIi5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwYXJlbnRdIG9wdGlvbmFsIFwiQ2xhc3NcIiB0byBpbmhlcml0IGZyb21cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHNoYXJlZCBieSBhbGwgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3NcbiAgICogICAgICAgICAgICAgICAgICAoYmUgY2FyZWZ1bCBtb2RpZnlpbmcgb2JqZWN0cyBkZWZpbmVkIGhlcmUgYXMgdGhpcyB3b3VsZCBhZmZlY3QgYWxsIGluc3RhbmNlcylcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzKCkge1xuICAgIHZhciBwYXJlbnQgPSBudWxsLFxuICAgICAgICBwcm9wZXJ0aWVzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwYXJlbnQgPSBwcm9wZXJ0aWVzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtsYXNzKCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAga2xhc3Muc3VwZXJjbGFzcyA9IHBhcmVudDtcbiAgICBrbGFzcy5zdWJjbGFzc2VzID0gW107XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBTdWJjbGFzcy5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgICAga2xhc3MucHJvdG90eXBlID0gbmV3IFN1YmNsYXNzKCk7XG4gICAgICBwYXJlbnQuc3ViY2xhc3Nlcy5wdXNoKGtsYXNzKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGFkZE1ldGhvZHMoa2xhc3MsIHByb3BlcnRpZXNbaV0sIHBhcmVudCk7XG4gICAgfVxuICAgIGlmICgha2xhc3MucHJvdG90eXBlLmluaXRpYWxpemUpIHtcbiAgICAgIGtsYXNzLnByb3RvdHlwZS5pbml0aWFsaXplID0gZW1wdHlGdW5jdGlvbjtcbiAgICB9XG4gICAga2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0ga2xhc3M7XG4gICAga2xhc3MucHJvdG90eXBlLmNhbGxTdXBlciA9IGNhbGxTdXBlcjtcbiAgICByZXR1cm4ga2xhc3M7XG4gIH1cblxuICBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyA9IGNyZWF0ZUNsYXNzO1xufSkoKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuICAvLyBzaW5jZSBpZTExIGNhbiB1c2UgYWRkRXZlbnRMaXN0ZW5lciBidXQgdGhleSBkbyBub3Qgc3VwcG9ydCBvcHRpb25zLCBpIG5lZWQgdG8gY2hlY2tcbiAgdmFyIGNvdWxkVXNlQXR0YWNoRXZlbnQgPSAhIWZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5hdHRhY2hFdmVudCxcbiAgICAgIHRvdWNoRXZlbnRzID0gWyd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICd0b3VjaGVuZCddO1xuICAvKipcbiAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byBhbiBlbGVtZW50XG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgZWxlbWVudCAmJiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBjb3VsZFVzZUF0dGFjaEV2ZW50ID8gZmFsc2UgOiBvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGFuIGVsZW1lbnRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZmFicmljLnV0aWwucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBlbGVtZW50ICYmIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGNvdWxkVXNlQXR0YWNoRXZlbnQgPyBmYWxzZSA6IG9wdGlvbnMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFRvdWNoSW5mbyhldmVudCkge1xuICAgIHZhciB0b3VjaFByb3AgPSBldmVudC5jaGFuZ2VkVG91Y2hlcztcbiAgICBpZiAodG91Y2hQcm9wICYmIHRvdWNoUHJvcFswXSkge1xuICAgICAgcmV0dXJuIHRvdWNoUHJvcFswXTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgZmFicmljLnV0aWwuZ2V0UG9pbnRlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC50YXJnZXQsXG4gICAgICAgIHNjcm9sbCA9IGZhYnJpYy51dGlsLmdldFNjcm9sbExlZnRUb3AoZWxlbWVudCksXG4gICAgICAgIF9ldnQgPSBnZXRUb3VjaEluZm8oZXZlbnQpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBfZXZ0LmNsaWVudFggKyBzY3JvbGwubGVmdCxcbiAgICAgIHk6IF9ldnQuY2xpZW50WSArIHNjcm9sbC50b3BcbiAgICB9O1xuICB9O1xuXG4gIGZhYnJpYy51dGlsLmlzVG91Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRvdWNoRXZlbnRzLmluZGV4T2YoZXZlbnQudHlwZSkgPiAtMSB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcbiAgfTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ3Jvc3MtYnJvd3NlciB3cmFwcGVyIGZvciBzZXR0aW5nIGVsZW1lbnQncyBzdHlsZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBFbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBmdW5jdGlvbiBzZXRTdHlsZShlbGVtZW50LCBzdHlsZXMpIHtcbiAgICB2YXIgZWxlbWVudFN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICBpZiAoIWVsZW1lbnRTdHlsZSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ICs9ICc7JyArIHN0eWxlcztcbiAgICAgIHJldHVybiBzdHlsZXMuaW5kZXhPZignb3BhY2l0eScpID4gLTFcbiAgICAgICAgPyBzZXRPcGFjaXR5KGVsZW1lbnQsIHN0eWxlcy5tYXRjaCgvb3BhY2l0eTpcXHMqKFxcZD9cXC4/XFxkKikvKVsxXSlcbiAgICAgICAgOiBlbGVtZW50O1xuICAgIH1cbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ29wYWNpdHknKSB7XG4gICAgICAgIHNldE9wYWNpdHkoZWxlbWVudCwgc3R5bGVzW3Byb3BlcnR5XSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRQcm9wZXJ0eSA9IChwcm9wZXJ0eSA9PT0gJ2Zsb2F0JyB8fCBwcm9wZXJ0eSA9PT0gJ2Nzc0Zsb2F0JylcbiAgICAgICAgICA/ICh0eXBlb2YgZWxlbWVudFN0eWxlLnN0eWxlRmxvYXQgPT09ICd1bmRlZmluZWQnID8gJ2Nzc0Zsb2F0JyA6ICdzdHlsZUZsb2F0JylcbiAgICAgICAgICA6IHByb3BlcnR5O1xuICAgICAgICBlbGVtZW50U3R5bGUuc2V0UHJvcGVydHkobm9ybWFsaXplZFByb3BlcnR5LCBzdHlsZXNbcHJvcGVydHldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICB2YXIgcGFyc2VFbCA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgIHN1cHBvcnRzT3BhY2l0eSA9IHR5cGVvZiBwYXJzZUVsLnN0eWxlLm9wYWNpdHkgPT09ICdzdHJpbmcnLFxuICAgICAgc3VwcG9ydHNGaWx0ZXJzID0gdHlwZW9mIHBhcnNlRWwuc3R5bGUuZmlsdGVyID09PSAnc3RyaW5nJyxcbiAgICAgIHJlT3BhY2l0eSA9IC9hbHBoYVxccypcXChcXHMqb3BhY2l0eVxccyo9XFxzKihbXlxcKV0rKVxcKS8sXG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICBzZXRPcGFjaXR5ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQ7IH07XG5cbiAgaWYgKHN1cHBvcnRzT3BhY2l0eSkge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgc2V0T3BhY2l0eSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gIH1cbiAgZWxzZSBpZiAoc3VwcG9ydHNGaWx0ZXJzKSB7XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBzZXRPcGFjaXR5ID0gZnVuY3Rpb24oZWxlbWVudCwgdmFsdWUpIHtcbiAgICAgIHZhciBlcyA9IGVsZW1lbnQuc3R5bGU7XG4gICAgICBpZiAoZWxlbWVudC5jdXJyZW50U3R5bGUgJiYgIWVsZW1lbnQuY3VycmVudFN0eWxlLmhhc0xheW91dCkge1xuICAgICAgICBlcy56b29tID0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChyZU9wYWNpdHkudGVzdChlcy5maWx0ZXIpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPj0gMC45OTk5ID8gJycgOiAoJ2FscGhhKG9wYWNpdHk9JyArICh2YWx1ZSAqIDEwMCkgKyAnKScpO1xuICAgICAgICBlcy5maWx0ZXIgPSBlcy5maWx0ZXIucmVwbGFjZShyZU9wYWNpdHksIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlcy5maWx0ZXIgKz0gJyBhbHBoYShvcGFjaXR5PScgKyAodmFsdWUgKiAxMDApICsgJyknO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLnNldFN0eWxlID0gc2V0U3R5bGU7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBfc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIFRha2VzIGlkIGFuZCByZXR1cm5zIGFuIGVsZW1lbnQgd2l0aCB0aGF0IGlkIChpZiBvbmUgZXhpc3RzIGluIGEgZG9jdW1lbnQpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudH0gaWRcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGZhYnJpYy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBpZDtcbiAgfVxuXG4gIHZhciBzbGljZUNhbkNvbnZlcnROb2RlbGlzdHMsXG4gICAgICAvKipcbiAgICAgICAqIENvbnZlcnRzIGFuIGFycmF5LWxpa2Ugb2JqZWN0IChlLmcuIGFyZ3VtZW50cyBvciBOb2RlTGlzdCkgdG8gYW4gYXJyYXlcbiAgICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGFycmF5TGlrZVxuICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgKi9cbiAgICAgIHRvQXJyYXkgPSBmdW5jdGlvbihhcnJheUxpa2UpIHtcbiAgICAgICAgcmV0dXJuIF9zbGljZS5jYWxsKGFycmF5TGlrZSwgMCk7XG4gICAgICB9O1xuXG4gIHRyeSB7XG4gICAgc2xpY2VDYW5Db252ZXJ0Tm9kZWxpc3RzID0gdG9BcnJheShmYWJyaWMuZG9jdW1lbnQuY2hpbGROb2RlcykgaW5zdGFuY2VvZiBBcnJheTtcbiAgfVxuICBjYXRjaCAoZXJyKSB7IH1cblxuICBpZiAoIXNsaWNlQ2FuQ29udmVydE5vZGVsaXN0cykge1xuICAgIHRvQXJyYXkgPSBmdW5jdGlvbihhcnJheUxpa2UpIHtcbiAgICAgIHZhciBhcnIgPSBuZXcgQXJyYXkoYXJyYXlMaWtlLmxlbmd0aCksIGkgPSBhcnJheUxpa2UubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBhcnJbaV0gPSBhcnJheUxpa2VbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBzcGVjaWZpZWQgZWxlbWVudCB3aXRoIHNwZWNpZmllZCBhdHRyaWJ1dGVzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGFnTmFtZSBUeXBlIG9mIGFuIGVsZW1lbnQgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gQXR0cmlidXRlcyB0byBzZXQgb24gYW4gZWxlbWVudFxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gTmV3bHkgY3JlYXRlZCBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiBtYWtlRWxlbWVudCh0YWdOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGVsID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAocHJvcCA9PT0gJ2NsYXNzJykge1xuICAgICAgICBlbC5jbGFzc05hbWUgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocHJvcCA9PT0gJ2ZvcicpIHtcbiAgICAgICAgZWwuaHRtbEZvciA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKHByb3AsIGF0dHJpYnV0ZXNbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBjbGFzcyB0byBhbiBlbGVtZW50XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gYWRkIGNsYXNzIHRvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgQ2xhc3MgdG8gYWRkIHRvIGFuIGVsZW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChlbGVtZW50ICYmICgnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignICcgKyBjbGFzc05hbWUgKyAnICcpID09PSAtMSkge1xuICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gKGVsZW1lbnQuY2xhc3NOYW1lID8gJyAnIDogJycpICsgY2xhc3NOYW1lO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcyBlbGVtZW50IHdpdGggYW5vdGhlciBlbGVtZW50XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gd3JhcFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fFN0cmluZ30gd3JhcHBlciBFbGVtZW50IHRvIHdyYXAgd2l0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEF0dHJpYnV0ZXMgdG8gc2V0IG9uIGEgd3JhcHBlclxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gd3JhcHBlclxuICAgKi9cbiAgZnVuY3Rpb24gd3JhcEVsZW1lbnQoZWxlbWVudCwgd3JhcHBlciwgYXR0cmlidXRlcykge1xuICAgIGlmICh0eXBlb2Ygd3JhcHBlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHdyYXBwZXIgPSBtYWtlRWxlbWVudCh3cmFwcGVyLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh3cmFwcGVyLCBlbGVtZW50KTtcbiAgICB9XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGVsZW1lbnQgc2Nyb2xsIG9mZnNldHNcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBvcGVyYXRlIG9uXG4gICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggbGVmdC90b3AgdmFsdWVzXG4gICAqL1xuICBmdW5jdGlvbiBnZXRTY3JvbGxMZWZ0VG9wKGVsZW1lbnQpIHtcblxuICAgIHZhciBsZWZ0ID0gMCxcbiAgICAgICAgdG9wID0gMCxcbiAgICAgICAgZG9jRWxlbWVudCA9IGZhYnJpYy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgIGJvZHkgPSBmYWJyaWMuZG9jdW1lbnQuYm9keSB8fCB7XG4gICAgICAgICAgc2Nyb2xsTGVmdDogMCwgc2Nyb2xsVG9wOiAwXG4gICAgICAgIH07XG5cbiAgICAvLyBXaGlsZSBsb29wIGNoZWNrcyAoYW5kIHRoZW4gc2V0cyBlbGVtZW50IHRvKSAucGFyZW50Tm9kZSBPUiAuaG9zdFxuICAgIC8vICB0byBhY2NvdW50IGZvciBTaGFkb3dET00uIFdlIHN0aWxsIHdhbnQgdG8gdHJhdmVyc2UgdXAgb3V0IG9mIFNoYWRvd0RPTSxcbiAgICAvLyAgYnV0IHRoZSAucGFyZW50Tm9kZSBvZiBhIHJvb3QgU2hhZG93RE9NIG5vZGUgd2lsbCBhbHdheXMgYmUgbnVsbCwgaW5zdGVhZFxuICAgIC8vICBpdCBzaG91bGQgYmUgYWNjZXNzZWQgdGhyb3VnaCAuaG9zdC4gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI0NzY1NTI4LzQzODM5MzhcbiAgICB3aGlsZSAoZWxlbWVudCAmJiAoZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdCkpIHtcblxuICAgICAgLy8gU2V0IGVsZW1lbnQgdG8gZWxlbWVudCBwYXJlbnQsIG9yICdob3N0JyBpbiBjYXNlIG9mIFNoYWRvd0RPTVxuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7XG5cbiAgICAgIGlmIChlbGVtZW50ID09PSBmYWJyaWMuZG9jdW1lbnQpIHtcbiAgICAgICAgbGVmdCA9IGJvZHkuc2Nyb2xsTGVmdCB8fCBkb2NFbGVtZW50LnNjcm9sbExlZnQgfHwgMDtcbiAgICAgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgIGRvY0VsZW1lbnQuc2Nyb2xsVG9wIHx8IDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGVmdCArPSBlbGVtZW50LnNjcm9sbExlZnQgfHwgMDtcbiAgICAgICAgdG9wICs9IGVsZW1lbnQuc2Nyb2xsVG9wIHx8IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSAxICYmIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCwgdG9wOiB0b3AgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9mZnNldCBmb3IgYSBnaXZlbiBlbGVtZW50XG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGdldCBvZmZzZXQgZm9yXG4gICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggXCJsZWZ0XCIgYW5kIFwidG9wXCIgcHJvcGVydGllc1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudE9mZnNldChlbGVtZW50KSB7XG4gICAgdmFyIGRvY0VsZW0sXG4gICAgICAgIGRvYyA9IGVsZW1lbnQgJiYgZWxlbWVudC5vd25lckRvY3VtZW50LFxuICAgICAgICBib3ggPSB7IGxlZnQ6IDAsIHRvcDogMCB9LFxuICAgICAgICBvZmZzZXQgPSB7IGxlZnQ6IDAsIHRvcDogMCB9LFxuICAgICAgICBzY3JvbGxMZWZ0VG9wLFxuICAgICAgICBvZmZzZXRBdHRyaWJ1dGVzID0ge1xuICAgICAgICAgIGJvcmRlckxlZnRXaWR0aDogJ2xlZnQnLFxuICAgICAgICAgIGJvcmRlclRvcFdpZHRoOiAgJ3RvcCcsXG4gICAgICAgICAgcGFkZGluZ0xlZnQ6ICAgICAnbGVmdCcsXG4gICAgICAgICAgcGFkZGluZ1RvcDogICAgICAndG9wJ1xuICAgICAgICB9O1xuXG4gICAgaWYgKCFkb2MpIHtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgYXR0ciBpbiBvZmZzZXRBdHRyaWJ1dGVzKSB7XG4gICAgICBvZmZzZXRbb2Zmc2V0QXR0cmlidXRlc1thdHRyXV0gKz0gcGFyc2VJbnQoZ2V0RWxlbWVudFN0eWxlKGVsZW1lbnQsIGF0dHIpLCAxMCkgfHwgMDtcbiAgICB9XG5cbiAgICBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBpZiAoIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICBib3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cblxuICAgIHNjcm9sbExlZnRUb3AgPSBnZXRTY3JvbGxMZWZ0VG9wKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGJveC5sZWZ0ICsgc2Nyb2xsTGVmdFRvcC5sZWZ0IC0gKGRvY0VsZW0uY2xpZW50TGVmdCB8fCAwKSArIG9mZnNldC5sZWZ0LFxuICAgICAgdG9wOiBib3gudG9wICsgc2Nyb2xsTGVmdFRvcC50b3AgLSAoZG9jRWxlbS5jbGllbnRUb3AgfHwgMCkgICsgb2Zmc2V0LnRvcFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzdHlsZSBhdHRyaWJ1dGUgdmFsdWUgb2YgYSBnaXZlbiBlbGVtZW50XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gZ2V0IHN0eWxlIGF0dHJpYnV0ZSBmb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgU3R5bGUgYXR0cmlidXRlIHRvIGdldCBmb3IgZWxlbWVudFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFN0eWxlIGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICovXG4gIHZhciBnZXRFbGVtZW50U3R5bGU7XG4gIGlmIChmYWJyaWMuZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZmFicmljLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICBnZXRFbGVtZW50U3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCBhdHRyKSB7XG4gICAgICB2YXIgc3R5bGUgPSBmYWJyaWMuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgICAgIHJldHVybiBzdHlsZSA/IHN0eWxlW2F0dHJdIDogdW5kZWZpbmVkO1xuICAgIH07XG4gIH1cbiAgZWxzZSB7XG4gICAgZ2V0RWxlbWVudFN0eWxlID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cikge1xuICAgICAgdmFyIHZhbHVlID0gZWxlbWVudC5zdHlsZVthdHRyXTtcbiAgICAgIGlmICghdmFsdWUgJiYgZWxlbWVudC5jdXJyZW50U3R5bGUpIHtcbiAgICAgICAgdmFsdWUgPSBlbGVtZW50LmN1cnJlbnRTdHlsZVthdHRyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3R5bGUgPSBmYWJyaWMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxuICAgICAgICBzZWxlY3RQcm9wID0gJ3VzZXJTZWxlY3QnIGluIHN0eWxlXG4gICAgICAgICAgPyAndXNlclNlbGVjdCdcbiAgICAgICAgICA6ICdNb3pVc2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgICAgPyAnTW96VXNlclNlbGVjdCdcbiAgICAgICAgICAgIDogJ1dlYmtpdFVzZXJTZWxlY3QnIGluIHN0eWxlXG4gICAgICAgICAgICAgID8gJ1dlYmtpdFVzZXJTZWxlY3QnXG4gICAgICAgICAgICAgIDogJ0todG1sVXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICAgICAgICA/ICdLaHRtbFVzZXJTZWxlY3QnXG4gICAgICAgICAgICAgICAgOiAnJztcblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGVsZW1lbnQgdW5zZWxlY3RhYmxlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIG1ha2UgdW5zZWxlY3RhYmxlXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IEVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIGluXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZUVsZW1lbnRVbnNlbGVjdGFibGUoZWxlbWVudCkge1xuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVsZW1lbnQub25zZWxlY3RzdGFydCA9IGZhYnJpYy51dGlsLmZhbHNlRnVuY3Rpb247XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0UHJvcCkge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3NlbGVjdFByb3BdID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudW5zZWxlY3RhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBlbGVtZW50LnVuc2VsZWN0YWJsZSA9ICdvbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBlbGVtZW50IHNlbGVjdGFibGVcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gbWFrZSBzZWxlY3RhYmxlXG4gICAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IEVsZW1lbnQgdGhhdCB3YXMgcGFzc2VkIGluXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZUVsZW1lbnRTZWxlY3RhYmxlKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdFByb3ApIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtzZWxlY3RQcm9wXSA9ICcnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudW5zZWxlY3RhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBlbGVtZW50LnVuc2VsZWN0YWJsZSA9ICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgZmFicmljLnV0aWwubWFrZUVsZW1lbnRVbnNlbGVjdGFibGUgPSBtYWtlRWxlbWVudFVuc2VsZWN0YWJsZTtcbiAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFNlbGVjdGFibGUgPSBtYWtlRWxlbWVudFNlbGVjdGFibGU7XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gZ2V0Tm9kZUNhbnZhcyhlbGVtZW50KSB7XG4gICAgdmFyIGltcGwgPSBmYWJyaWMuanNkb21JbXBsRm9yV3JhcHBlcihlbGVtZW50KTtcbiAgICByZXR1cm4gaW1wbC5fY2FudmFzIHx8IGltcGwuX2ltYWdlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNsZWFuVXBKc2RvbU5vZGUoZWxlbWVudCkge1xuICAgIGlmICghZmFicmljLmlzTGlrZWx5Tm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaW1wbCA9IGZhYnJpYy5qc2RvbUltcGxGb3JXcmFwcGVyKGVsZW1lbnQpO1xuICAgIGlmIChpbXBsKSB7XG4gICAgICBpbXBsLl9pbWFnZSA9IG51bGw7XG4gICAgICBpbXBsLl9jYW52YXMgPSBudWxsO1xuICAgICAgLy8gdW5zdXJlIGlmIG5lY2Vzc2FyeVxuICAgICAgaW1wbC5fY3VycmVudFNyYyA9IG51bGw7XG4gICAgICBpbXBsLl9hdHRyaWJ1dGVzID0gbnVsbDtcbiAgICAgIGltcGwuX2NsYXNzTGlzdCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0SW1hZ2VTbW9vdGhpbmcoY3R4LCB2YWx1ZSkge1xuICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGN0eC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWRcbiAgICAgIHx8IGN0eC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgfHwgY3R4Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGN0eC5vSW1hZ2VTbW9vdGhpbmdFbmFibGVkO1xuICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXRJbWFnZVNtb290aGluZyBzZXRzIHRoZSBjb250ZXh0IGltYWdlU21vb3RoaW5nRW5hYmxlZCBwcm9wZXJ0eS5cbiAgICogVXNlZCBieSBjYW52YXMgYW5kIGJ5IEltYWdlT2JqZWN0LlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBwYXJhbSB7SFRNTFJlbmRlcmluZ0NvbnRleHQyRH0gY3R4IHRvIHNldCBvblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIHRydWUgb3IgZmFsc2VcbiAgICovXG4gIGZhYnJpYy51dGlsLnNldEltYWdlU21vb3RoaW5nID0gc2V0SW1hZ2VTbW9vdGhpbmc7XG4gIGZhYnJpYy51dGlsLmdldEJ5SWQgPSBnZXRCeUlkO1xuICBmYWJyaWMudXRpbC50b0FycmF5ID0gdG9BcnJheTtcbiAgZmFicmljLnV0aWwuYWRkQ2xhc3MgPSBhZGRDbGFzcztcbiAgZmFicmljLnV0aWwubWFrZUVsZW1lbnQgPSBtYWtlRWxlbWVudDtcbiAgZmFicmljLnV0aWwud3JhcEVsZW1lbnQgPSB3cmFwRWxlbWVudDtcbiAgZmFicmljLnV0aWwuZ2V0U2Nyb2xsTGVmdFRvcCA9IGdldFNjcm9sbExlZnRUb3A7XG4gIGZhYnJpYy51dGlsLmdldEVsZW1lbnRPZmZzZXQgPSBnZXRFbGVtZW50T2Zmc2V0O1xuICBmYWJyaWMudXRpbC5nZXROb2RlQ2FudmFzID0gZ2V0Tm9kZUNhbnZhcztcbiAgZmFicmljLnV0aWwuY2xlYW5VcEpzZG9tTm9kZSA9IGNsZWFuVXBKc2RvbU5vZGU7XG5cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIGFkZFBhcmFtVG9VcmwodXJsLCBwYXJhbSkge1xuICAgIHJldHVybiB1cmwgKyAoL1xcPy8udGVzdCh1cmwpID8gJyYnIDogJz8nKSArIHBhcmFtO1xuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlGbigpIHsgfVxuXG4gIC8qKlxuICAgKiBDcm9zcy1icm93c2VyIGFic3RyYWN0aW9uIGZvciBzZW5kaW5nIFhNTEh0dHBSZXF1ZXN0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCB0byBzZW5kIFhNTEh0dHBSZXF1ZXN0IHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1ldGhvZD1cIkdFVFwiXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFyYW1ldGVyc10gcGFyYW1ldGVycyB0byBhcHBlbmQgdG8gdXJsIGluIEdFVCBvciBpbiBib2R5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ib2R5XSBib2R5IHRvIHNlbmQgd2l0aCBQT1NUIG9yIFBVVCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25Db21wbGV0ZSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiByZXF1ZXN0IGlzIGNvbXBsZXRlZFxuICAgKiBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdH0gcmVxdWVzdFxuICAgKi9cbiAgZnVuY3Rpb24gcmVxdWVzdCh1cmwsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgIHZhciBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCA/IG9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCkgOiAnR0VUJyxcbiAgICAgICAgb25Db21wbGV0ZSA9IG9wdGlvbnMub25Db21wbGV0ZSB8fCBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgeGhyID0gbmV3IGZhYnJpYy53aW5kb3cuWE1MSHR0cFJlcXVlc3QoKSxcbiAgICAgICAgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBvcHRpb25zLnBhcmFtZXRlcnM7XG5cbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBvbkNvbXBsZXRlKHhocik7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eUZuO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgYm9keSA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMucGFyYW1ldGVycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdXJsID0gYWRkUGFyYW1Ub1VybCh1cmwsIG9wdGlvbnMucGFyYW1ldGVycyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ1BPU1QnIHx8IG1ldGhvZCA9PT0gJ1BVVCcpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG4gICAgfVxuXG4gICAgeGhyLnNlbmQoYm9keSk7XG4gICAgcmV0dXJuIHhocjtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLnJlcXVlc3QgPSByZXF1ZXN0O1xufSkoKTtcblxuXG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIGBjb25zb2xlLmxvZ2AgKHdoZW4gYXZhaWxhYmxlKVxuICogQHBhcmFtIHsqfSBbdmFsdWVzXSBWYWx1ZXMgdG8gbG9nXG4gKi9cbmZhYnJpYy5sb2cgPSBjb25zb2xlLmxvZztcblxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCBgY29uc29sZS53YXJuYCAod2hlbiBhdmFpbGFibGUpXG4gKiBAcGFyYW0geyp9IFt2YWx1ZXNdIFZhbHVlcyB0byBsb2cgYXMgYSB3YXJuaW5nXG4gKi9cbmZhYnJpYy53YXJuID0gY29uc29sZS53YXJuO1xuXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZTtcblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gQW5pbWF0aW9uT3B0aW9uc1xuICAgKiBBbmltYXRpb24gb2YgYSB2YWx1ZSBvciBsaXN0IG9mIHZhbHVlcy5cbiAgICogV2hlbiB1c2luZyBsaXN0cywgdGhpbmsgb2Ygc29tZXRoaW5nIGxpa2UgdGhpczpcbiAgICogZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAqICAgc3RhcnRWYWx1ZTogWzEsIDIsIDNdLFxuICAgKiAgIGVuZFZhbHVlOiBbMiwgNCwgNl0sXG4gICAqICAgb25DaGFuZ2U6IGZ1bmN0aW9uKFthLCBiLCBjXSkge1xuICAgKiAgICAgY2FudmFzLnpvb21Ub1BvaW50KHt4OiBiLCB5OiBjfSwgYSlcbiAgICogICAgIGNhbnZhcy5yZW5kZXJBbGwoKVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIEBleGFtcGxlXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtvbkNoYW5nZV0gQ2FsbGJhY2s7IGludm9rZWQgb24gZXZlcnkgdmFsdWUgY2hhbmdlXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtvbkNvbXBsZXRlXSBDYWxsYmFjazsgaW52b2tlZCB3aGVuIHZhbHVlIGNoYW5nZSBpcyBjb21wbGV0ZWRcbiAgICogQGV4YW1wbGVcbiAgICogLy8gTm90ZTogc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGFuZCBieVZhbHVlIG11c3QgbWF0Y2ggdGhlIHR5cGVcbiAgICogdmFyIGFuaW1hdGlvbk9wdGlvbnMgPSB7IHN0YXJ0VmFsdWU6IDAsIGVuZFZhbHVlOiAxLCBieVZhbHVlOiAwLjI1IH1cbiAgICogdmFyIGFuaW1hdGlvbk9wdGlvbnMgPSB7IHN0YXJ0VmFsdWU6IFswLCAxXSwgZW5kVmFsdWU6IFsxLCAyXSwgYnlWYWx1ZTogWzAuMjUsIDAuMjVdIH1cbiAgICogQHByb3BlcnR5IHtudW1iZXIgfCBudW1iZXJbXX0gW3N0YXJ0VmFsdWU9MF0gU3RhcnRpbmcgdmFsdWVcbiAgICogQHByb3BlcnR5IHtudW1iZXIgfCBudW1iZXJbXX0gW2VuZFZhbHVlPTEwMF0gRW5kaW5nIHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgbnVtYmVyW119IFtieVZhbHVlPTEwMF0gVmFsdWUgdG8gbW9kaWZ5IHRoZSBwcm9wZXJ0eSBieVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZWFzaW5nXSBFYXNpbmcgZnVuY3Rpb25cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkdXJhdGlvbj01MDBdIER1cmF0aW9uIG9mIGNoYW5nZSAoaW4gbXMpXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFthYm9ydF0gQWRkaXRpb25hbCBmdW5jdGlvbiB3aXRoIGxvZ2ljLiBJZiByZXR1cm5zIHRydWUsIGFuaW1hdGlvbiBhYm9ydHMuXG4gICAqXG4gICAqIEB0eXBlZGVmIHsoKSA9PiB2b2lkfSBDYW5jZWxGdW5jdGlvblxuICAgKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBBbmltYXRpb25DdXJyZW50U3RhdGVcbiAgICogQHByb3BlcnR5IHtudW1iZXIgfCBudW1iZXJbXX0gY3VycmVudFZhbHVlIHZhbHVlIGluIHJhbmdlIFtgc3RhcnRWYWx1ZWAsIGBlbmRWYWx1ZWBdXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb21wbGV0aW9uUmF0ZSB2YWx1ZSBpbiByYW5nZSBbMCwgMV1cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGR1cmF0aW9uUmF0ZSB2YWx1ZSBpbiByYW5nZSBbMCwgMV1cbiAgICpcbiAgICogQHR5cGVkZWYgeyhBbmltYXRpb25PcHRpb25zICYgQW5pbWF0aW9uQ3VycmVudFN0YXRlICYgeyBjYW5jZWw6IENhbmNlbEZ1bmN0aW9uIH19IEFuaW1hdGlvbkNvbnRleHRcbiAgICovXG5cbiAgLyoqXG4gICAqIEFycmF5IGhvbGRpbmcgYWxsIHJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgKiBAbWVtYmVyb2YgZmFicmljXG4gICAqIEB0eXBlIHtBbmltYXRpb25Db250ZXh0W119XG4gICAqL1xuICB2YXIgUlVOTklOR19BTklNQVRJT05TID0gW107XG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoUlVOTklOR19BTklNQVRJT05TLCB7XG5cbiAgICAvKipcbiAgICAgKiBjYW5jZWwgYWxsIHJ1bm5pbmcgYW5pbWF0aW9ucyBhdCB0aGUgbmV4dCByZXF1ZXN0QW5pbUZyYW1lXG4gICAgICogQHJldHVybnMge0FuaW1hdGlvbkNvbnRleHRbXX1cbiAgICAgKi9cbiAgICBjYW5jZWxBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhbmltYXRpb25zID0gdGhpcy5zcGxpY2UoMCk7XG4gICAgICBhbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhbmltYXRpb25zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYW5jZWwgYWxsIHJ1bm5pbmcgYW5pbWF0aW9ucyBhdHRhY2hlZCB0byBjYW52YXMgYXQgdGhlIG5leHQgcmVxdWVzdEFuaW1GcmFtZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNhbnZhc30gY2FudmFzXG4gICAgICogQHJldHVybnMge0FuaW1hdGlvbkNvbnRleHRbXX1cbiAgICAgKi9cbiAgICBjYW5jZWxCeUNhbnZhczogZnVuY3Rpb24gKGNhbnZhcykge1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGNhbmNlbGxlZCA9IHRoaXMuZmlsdGVyKGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhbmltYXRpb24udGFyZ2V0ID09PSAnb2JqZWN0JyAmJiBhbmltYXRpb24udGFyZ2V0LmNhbnZhcyA9PT0gY2FudmFzO1xuICAgICAgfSk7XG4gICAgICBjYW5jZWxsZWQuZm9yRWFjaChmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNhbmNlbGxlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FuY2VsIGFsbCBydW5uaW5nIGFuaW1hdGlvbnMgZm9yIHRhcmdldCBhdCB0aGUgbmV4dCByZXF1ZXN0QW5pbUZyYW1lXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICAgKiBAcmV0dXJucyB7QW5pbWF0aW9uQ29udGV4dFtdfVxuICAgICAqL1xuICAgIGNhbmNlbEJ5VGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICB2YXIgY2FuY2VsbGVkID0gdGhpcy5maW5kQW5pbWF0aW9uc0J5VGFyZ2V0KHRhcmdldCk7XG4gICAgICBjYW5jZWxsZWQuZm9yRWFjaChmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNhbmNlbGxlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbmNlbEZ1bmN0aW9ufSBjYW5jZWxGdW5jIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBhbmltYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmaW5kQW5pbWF0aW9uSW5kZXg6IGZ1bmN0aW9uIChjYW5jZWxGdW5jKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleE9mKHRoaXMuZmluZEFuaW1hdGlvbihjYW5jZWxGdW5jKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW5jZWxGdW5jdGlvbn0gY2FuY2VsRnVuYyB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgYW5pbWF0ZVxuICAgICAqIEByZXR1cm5zIHtBbmltYXRpb25Db250ZXh0IHwgdW5kZWZpbmVkfSBhbmltYXRpb24ncyBvcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGZpbmRBbmltYXRpb246IGZ1bmN0aW9uIChjYW5jZWxGdW5jKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kKGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbi5jYW5jZWwgPT09IGNhbmNlbEZ1bmM7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHRhcmdldCB0aGUgb2JqZWN0IHRoYXQgaXMgYXNzaWduZWQgdG8gdGhlIHRhcmdldCBwcm9wZXJ0eSBvZiB0aGUgYW5pbWF0aW9uIGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7QW5pbWF0aW9uQ29udGV4dFtdfSBhcnJheSBvZiBhbmltYXRpb24gb3B0aW9ucyBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRhcmdldFxuICAgICAqL1xuICAgIGZpbmRBbmltYXRpb25zQnlUYXJnZXQ6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb24udGFyZ2V0ID09PSB0YXJnZXQ7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdEVhc2luZyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jICogTWF0aC5jb3ModCAvIGQgKiAoTWF0aC5QSSAvIDIpKSArIGMgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdmFsdWUgZnJvbSBvbmUgdG8gYW5vdGhlciB3aXRoaW4gY2VydGFpbiBwZXJpb2Qgb2YgdGltZSwgaW52b2tpbmcgY2FsbGJhY2tzIGFzIHZhbHVlIGlzIGJlaW5nIGNoYW5nZWQuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0FuaW1hdGlvbk9wdGlvbnN9IFtvcHRpb25zXSBBbmltYXRpb24gb3B0aW9uc1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBOb3RlOiBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgYW5kIGJ5VmFsdWUgbXVzdCBtYXRjaCB0aGUgdHlwZVxuICAgKiBmYWJyaWMudXRpbC5hbmltYXRlKHsgc3RhcnRWYWx1ZTogMCwgZW5kVmFsdWU6IDEsIGJ5VmFsdWU6IDAuMjUgfSlcbiAgICogZmFicmljLnV0aWwuYW5pbWF0ZSh7IHN0YXJ0VmFsdWU6IFswLCAxXSwgZW5kVmFsdWU6IFsxLCAyXSwgYnlWYWx1ZTogWzAuMjUsIDAuMjVdIH0pXG4gICAqIEByZXR1cm5zIHtDYW5jZWxGdW5jdGlvbn0gY2FuY2VsIGZ1bmN0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBhbmltYXRlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIHZhciBjYW5jZWwgPSBmYWxzZSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgcmVtb3ZlRnJvbVJlZ2lzdHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IGZhYnJpYy5ydW5uaW5nQW5pbWF0aW9ucy5pbmRleE9mKGNvbnRleHQpO1xuICAgICAgICAgIHJldHVybiBpbmRleCA+IC0xICYmIGZhYnJpYy5ydW5uaW5nQW5pbWF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgICAgICB9O1xuXG4gICAgY29udGV4dCA9IGV4dGVuZChjbG9uZShvcHRpb25zKSwge1xuICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbmNlbCA9IHRydWU7XG4gICAgICAgIHJldHVybiByZW1vdmVGcm9tUmVnaXN0cnkoKTtcbiAgICAgIH0sXG4gICAgICBjdXJyZW50VmFsdWU6ICdzdGFydFZhbHVlJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGFydFZhbHVlIDogMCxcbiAgICAgIGNvbXBsZXRpb25SYXRlOiAwLFxuICAgICAgZHVyYXRpb25SYXRlOiAwXG4gICAgfSk7XG4gICAgZmFicmljLnJ1bm5pbmdBbmltYXRpb25zLnB1c2goY29udGV4dCk7XG5cbiAgICByZXF1ZXN0QW5pbUZyYW1lKGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgICAgdmFyIHN0YXJ0ID0gdGltZXN0YW1wIHx8ICtuZXcgRGF0ZSgpLFxuICAgICAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCA1MDAsXG4gICAgICAgICAgZmluaXNoID0gc3RhcnQgKyBkdXJhdGlvbiwgdGltZSxcbiAgICAgICAgICBvbkNoYW5nZSA9IG9wdGlvbnMub25DaGFuZ2UgfHwgbm9vcCxcbiAgICAgICAgICBhYm9ydCA9IG9wdGlvbnMuYWJvcnQgfHwgbm9vcCxcbiAgICAgICAgICBvbkNvbXBsZXRlID0gb3B0aW9ucy5vbkNvbXBsZXRlIHx8IG5vb3AsXG4gICAgICAgICAgZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgZGVmYXVsdEVhc2luZyxcbiAgICAgICAgICBpc01hbnkgPSAnc3RhcnRWYWx1ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhcnRWYWx1ZS5sZW5ndGggPiAwIDogZmFsc2UsXG4gICAgICAgICAgc3RhcnRWYWx1ZSA9ICdzdGFydFZhbHVlJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGFydFZhbHVlIDogMCxcbiAgICAgICAgICBlbmRWYWx1ZSA9ICdlbmRWYWx1ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZW5kVmFsdWUgOiAxMDAsXG4gICAgICAgICAgYnlWYWx1ZSA9IG9wdGlvbnMuYnlWYWx1ZSB8fCAoaXNNYW55ID8gc3RhcnRWYWx1ZS5tYXAoZnVuY3Rpb24odmFsdWUsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmRWYWx1ZVtpXSAtIHN0YXJ0VmFsdWVbaV07XG4gICAgICAgICAgfSkgOiBlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUpO1xuXG4gICAgICBvcHRpb25zLm9uU3RhcnQgJiYgb3B0aW9ucy5vblN0YXJ0KCk7XG5cbiAgICAgIChmdW5jdGlvbiB0aWNrKHRpY2t0aW1lKSB7XG4gICAgICAgIHRpbWUgPSB0aWNrdGltZSB8fCArbmV3IERhdGUoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGltZSA+IGZpbmlzaCA/IGR1cmF0aW9uIDogKHRpbWUgLSBzdGFydCksXG4gICAgICAgICAgICB0aW1lUGVyYyA9IGN1cnJlbnRUaW1lIC8gZHVyYXRpb24sXG4gICAgICAgICAgICBjdXJyZW50ID0gaXNNYW55ID8gc3RhcnRWYWx1ZS5tYXAoZnVuY3Rpb24oX3ZhbHVlLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlYXNpbmcoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWVbaV0sIGJ5VmFsdWVbaV0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0pIDogZWFzaW5nKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBieVZhbHVlLCBkdXJhdGlvbiksXG4gICAgICAgICAgICB2YWx1ZVBlcmMgPSBpc01hbnkgPyBNYXRoLmFicygoY3VycmVudFswXSAtIHN0YXJ0VmFsdWVbMF0pIC8gYnlWYWx1ZVswXSlcbiAgICAgICAgICAgICAgOiBNYXRoLmFicygoY3VycmVudCAtIHN0YXJ0VmFsdWUpIC8gYnlWYWx1ZSk7XG4gICAgICAgIC8vICB1cGRhdGUgY29udGV4dFxuICAgICAgICBjb250ZXh0LmN1cnJlbnRWYWx1ZSA9IGlzTWFueSA/IGN1cnJlbnQuc2xpY2UoKSA6IGN1cnJlbnQ7XG4gICAgICAgIGNvbnRleHQuY29tcGxldGlvblJhdGUgPSB2YWx1ZVBlcmM7XG4gICAgICAgIGNvbnRleHQuZHVyYXRpb25SYXRlID0gdGltZVBlcmM7XG4gICAgICAgIGlmIChjYW5jZWwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFib3J0KGN1cnJlbnQsIHZhbHVlUGVyYywgdGltZVBlcmMpKSB7XG4gICAgICAgICAgcmVtb3ZlRnJvbVJlZ2lzdHJ5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lID4gZmluaXNoKSB7XG4gICAgICAgICAgLy8gIHVwZGF0ZSBjb250ZXh0XG4gICAgICAgICAgY29udGV4dC5jdXJyZW50VmFsdWUgPSBpc01hbnkgPyBlbmRWYWx1ZS5zbGljZSgpIDogZW5kVmFsdWU7XG4gICAgICAgICAgY29udGV4dC5jb21wbGV0aW9uUmF0ZSA9IDE7XG4gICAgICAgICAgY29udGV4dC5kdXJhdGlvblJhdGUgPSAxO1xuICAgICAgICAgIC8vICBleGVjdXRlIGNhbGxiYWNrc1xuICAgICAgICAgIG9uQ2hhbmdlKGlzTWFueSA/IGVuZFZhbHVlLnNsaWNlKCkgOiBlbmRWYWx1ZSwgMSwgMSk7XG4gICAgICAgICAgb25Db21wbGV0ZShlbmRWYWx1ZSwgMSwgMSk7XG4gICAgICAgICAgcmVtb3ZlRnJvbVJlZ2lzdHJ5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG9uQ2hhbmdlKGN1cnJlbnQsIHZhbHVlUGVyYywgdGltZVBlcmMpO1xuICAgICAgICAgIHJlcXVlc3RBbmltRnJhbWUodGljayk7XG4gICAgICAgIH1cbiAgICAgIH0pKHN0YXJ0KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb250ZXh0LmNhbmNlbDtcbiAgfVxuXG4gIHZhciBfcmVxdWVzdEFuaW1GcmFtZSA9IGZhYnJpYy53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhYnJpYy53aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICB2YXIgX2NhbmNlbEFuaW1GcmFtZSA9IGZhYnJpYy53aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgZmFicmljLndpbmRvdy5jbGVhclRpbWVvdXQ7XG5cbiAgLyoqXG4gICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBiYXNlZCBvbiBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuICAgKiBJbiBvcmRlciB0byBnZXQgYSBwcmVjaXNlIHN0YXJ0IHRpbWUsIGByZXF1ZXN0QW5pbUZyYW1lYCBzaG91bGQgYmUgY2FsbGVkIGFzIGFuIGVudHJ5IGludG8gdGhlIG1ldGhvZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCBvcHRpb25hbCBFbGVtZW50IHRvIGFzc29jaWF0ZSB3aXRoIGFuaW1hdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gcmVxdWVzdEFuaW1GcmFtZSgpIHtcbiAgICByZXR1cm4gX3JlcXVlc3RBbmltRnJhbWUuYXBwbHkoZmFicmljLndpbmRvdywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbEFuaW1GcmFtZSgpIHtcbiAgICByZXR1cm4gX2NhbmNlbEFuaW1GcmFtZS5hcHBseShmYWJyaWMud2luZG93LCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZmFicmljLnV0aWwuYW5pbWF0ZSA9IGFuaW1hdGU7XG4gIGZhYnJpYy51dGlsLnJlcXVlc3RBbmltRnJhbWUgPSByZXF1ZXN0QW5pbUZyYW1lO1xuICBmYWJyaWMudXRpbC5jYW5jZWxBbmltRnJhbWUgPSBjYW5jZWxBbmltRnJhbWU7XG4gIGZhYnJpYy5ydW5uaW5nQW5pbWF0aW9ucyA9IFJVTk5JTkdfQU5JTUFUSU9OUztcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAvLyBDYWxjdWxhdGUgYW4gaW4tYmV0d2VlbiBjb2xvci4gUmV0dXJucyBhIFwicmdiYSgpXCIgc3RyaW5nLlxuICAvLyBDcmVkaXQ6IEVkd2luIE1hcnRpbiA8ZWR3aW5AYml0c3Rvcm0ub3JnPlxuICAvLyAgICAgICAgIGh0dHA6Ly93d3cuYml0c3Rvcm0ub3JnL2pxdWVyeS9jb2xvci1hbmltYXRpb24vanF1ZXJ5LmFuaW1hdGUtY29sb3JzLmpzXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbG9yKGJlZ2luLCBlbmQsIHBvcykge1xuICAgIHZhciBjb2xvciA9ICdyZ2JhKCdcbiAgICAgICAgKyBwYXJzZUludCgoYmVnaW5bMF0gKyBwb3MgKiAoZW5kWzBdIC0gYmVnaW5bMF0pKSwgMTApICsgJywnXG4gICAgICAgICsgcGFyc2VJbnQoKGJlZ2luWzFdICsgcG9zICogKGVuZFsxXSAtIGJlZ2luWzFdKSksIDEwKSArICcsJ1xuICAgICAgICArIHBhcnNlSW50KChiZWdpblsyXSArIHBvcyAqIChlbmRbMl0gLSBiZWdpblsyXSkpLCAxMCk7XG5cbiAgICBjb2xvciArPSAnLCcgKyAoYmVnaW4gJiYgZW5kID8gcGFyc2VGbG9hdChiZWdpblszXSArIHBvcyAqIChlbmRbM10gLSBiZWdpblszXSkpIDogMSk7XG4gICAgY29sb3IgKz0gJyknO1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoZSBjb2xvciBmcm9tIG9uZSB0byBhbm90aGVyIHdpdGhpbiBjZXJ0YWluIHBlcmlvZCBvZiB0aW1lLCBpbnZva2luZyBjYWxsYmFja3MgYXMgdmFsdWUgaXMgYmVpbmcgY2hhbmdlZC5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tQ29sb3IgVGhlIHN0YXJ0aW5nIGNvbG9yIGluIGhleCBvciByZ2IoYSkgZm9ybWF0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdG9Db2xvciBUaGUgc3RhcnRpbmcgY29sb3IgaW4gaGV4IG9yIHJnYihhKSBmb3JtYXQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZHVyYXRpb25dIER1cmF0aW9uIG9mIGNoYW5nZSAoaW4gbXMpLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuaW1hdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQ2hhbmdlXSBDYWxsYmFjazsgaW52b2tlZCBvbiBldmVyeSB2YWx1ZSBjaGFuZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25Db21wbGV0ZV0gQ2FsbGJhY2s7IGludm9rZWQgd2hlbiB2YWx1ZSBjaGFuZ2UgaXMgY29tcGxldGVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNvbG9yRWFzaW5nXSBFYXNpbmcgZnVuY3Rpb24uIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG9ubHkgdGFrZSB0d28gYXJndW1lbnRzIChjdXJyZW50VGltZSwgZHVyYXRpb24pLiBUaHVzIHRoZSByZWd1bGFyIGFuaW1hdGlvbiBlYXNpbmcgZnVuY3Rpb25zIGNhbm5vdCBiZSB1c2VkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5hYm9ydF0gQWRkaXRpb25hbCBmdW5jdGlvbiB3aXRoIGxvZ2ljLiBJZiByZXR1cm5zIHRydWUsIG9uQ29tcGxldGUgaXMgY2FsbGVkLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IGFib3J0IGZ1bmN0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBhbmltYXRlQ29sb3IoZnJvbUNvbG9yLCB0b0NvbG9yLCBkdXJhdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBzdGFydENvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihmcm9tQ29sb3IpLmdldFNvdXJjZSgpLFxuICAgICAgICBlbmRDb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IodG9Db2xvcikuZ2V0U291cmNlKCksXG4gICAgICAgIG9yaWdpbmFsT25Db21wbGV0ZSA9IG9wdGlvbnMub25Db21wbGV0ZSxcbiAgICAgICAgb3JpZ2luYWxPbkNoYW5nZSA9IG9wdGlvbnMub25DaGFuZ2U7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICByZXR1cm4gZmFicmljLnV0aWwuYW5pbWF0ZShmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKG9wdGlvbnMsIHtcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiB8fCA1MDAsXG4gICAgICBzdGFydFZhbHVlOiBzdGFydENvbG9yLFxuICAgICAgZW5kVmFsdWU6IGVuZENvbG9yLFxuICAgICAgYnlWYWx1ZTogZW5kQ29sb3IsXG4gICAgICBlYXNpbmc6IGZ1bmN0aW9uIChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgYnlWYWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIHBvc1ZhbHVlID0gb3B0aW9ucy5jb2xvckVhc2luZ1xuICAgICAgICAgID8gb3B0aW9ucy5jb2xvckVhc2luZyhjdXJyZW50VGltZSwgZHVyYXRpb24pXG4gICAgICAgICAgOiAxIC0gTWF0aC5jb3MoY3VycmVudFRpbWUgLyBkdXJhdGlvbiAqIChNYXRoLlBJIC8gMikpO1xuICAgICAgICByZXR1cm4gY2FsY3VsYXRlQ29sb3Ioc3RhcnRWYWx1ZSwgYnlWYWx1ZSwgcG9zVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIC8vIGhhcyB0byB0YWtlIGluIGFjY291bnQgZm9yIGNvbG9yIHJlc3RvcmluZztcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKGN1cnJlbnQsIHZhbHVlUGVyYywgdGltZVBlcmMpIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsT25Db21wbGV0ZSkge1xuICAgICAgICAgIHJldHVybiBvcmlnaW5hbE9uQ29tcGxldGUoXG4gICAgICAgICAgICBjYWxjdWxhdGVDb2xvcihlbmRDb2xvciwgZW5kQ29sb3IsIDApLFxuICAgICAgICAgICAgdmFsdWVQZXJjLFxuICAgICAgICAgICAgdGltZVBlcmNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKGN1cnJlbnQsIHZhbHVlUGVyYywgdGltZVBlcmMpIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsT25DaGFuZ2UpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsT25DaGFuZ2UoXG4gICAgICAgICAgICAgIGNhbGN1bGF0ZUNvbG9yKGN1cnJlbnQsIGN1cnJlbnQsIDApLFxuICAgICAgICAgICAgICB2YWx1ZVBlcmMsXG4gICAgICAgICAgICAgIHRpbWVQZXJjXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcmlnaW5hbE9uQ2hhbmdlKGN1cnJlbnQsIHZhbHVlUGVyYywgdGltZVBlcmMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG5cbiAgZmFicmljLnV0aWwuYW5pbWF0ZUNvbG9yID0gYW5pbWF0ZUNvbG9yO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBub3JtYWxpemUoYSwgYywgcCwgcykge1xuICAgIGlmIChhIDwgTWF0aC5hYnMoYykpIHtcbiAgICAgIGEgPSBjO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vaGFuZGxlIHRoZSAwLzAgY2FzZTpcbiAgICAgIGlmIChjID09PSAwICYmIGEgPT09IDApIHtcbiAgICAgICAgcyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKDEpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbihjIC8gYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGE6IGEsIGM6IGMsIHA6IHAsIHM6IHMgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVsYXN0aWMob3B0cywgdCwgZCkge1xuICAgIHJldHVybiBvcHRzLmEgKlxuICAgICAgTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKlxuICAgICAgTWF0aC5zaW4oICh0ICogZCAtIG9wdHMucykgKiAoMiAqIE1hdGguUEkpIC8gb3B0cy5wICk7XG4gIH1cblxuICAvKipcbiAgICogQ3ViaWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEN1YmljKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdWJpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0Q3ViaWModCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluUXVhcnQodCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCAqIHQgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1YXJ0aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dFF1YXJ0KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKiB0IC0gMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1YXJ0aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dFF1YXJ0KHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICogdCArIGI7XG4gICAgfVxuICAgIHJldHVybiAtYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVpbnRpYyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJblF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICogdCArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVpbnRpYyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0UXVpbnQodCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVpbnRpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0UXVpbnQodCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCAqIHQgKiB0ICogdCArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogU2ludXNvaWRhbCBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJblNpbmUodCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqIE1hdGguY29zKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBjICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW51c29pZGFsIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRTaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqIE1hdGguc2luKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbnVzb2lkYWwgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dFNpbmUodCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAvIDIgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQgLyBkKSAtIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvbmVudGlhbCBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkV4cG8odCwgYiwgYywgZCkge1xuICAgIHJldHVybiAodCA9PT0gMCkgPyBiIDogYyAqIE1hdGgucG93KDIsIDEwICogKHQgLyBkIC0gMSkpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvbmVudGlhbCBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0RXhwbyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuICh0ID09PSBkKSA/IGIgKyBjIDogYyAqICgtTWF0aC5wb3coMiwgLTEwICogdCAvIGQpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9uZW50aWFsIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRFeHBvKHQsIGIsIGMsIGQpIHtcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIGlmICh0ID09PSBkKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKC1NYXRoLnBvdygyLCAtMTAgKiAtLXQpICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIENpcmN1bGFyIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluQ2lyYyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jICogKE1hdGguc3FydCgxIC0gKHQgLz0gZCkgKiB0KSAtIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjdWxhciBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0Q2lyYyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiBNYXRoLnNxcnQoMSAtICh0ID0gdCAvIGQgLSAxKSAqIHQpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjdWxhciBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0Q2lyYyh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiAtYyAvIDIgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKSArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRWxhc3RpYyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkO1xuICAgIGlmICh0ID09PSAxKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIGlmICghcCkge1xuICAgICAgcCA9IGQgKiAwLjM7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIHJldHVybiAtZWxhc3RpYyhvcHRzLCB0LCBkKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRWxhc3RpYyBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0RWxhc3RpYyh0LCBiLCBjLCBkKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4LCBwID0gMCwgYSA9IGM7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICB0IC89IGQ7XG4gICAgaWYgKHQgPT09IDEpIHtcbiAgICAgIHJldHVybiBiICsgYztcbiAgICB9XG4gICAgaWYgKCFwKSB7XG4gICAgICBwID0gZCAqIDAuMztcbiAgICB9XG4gICAgdmFyIG9wdHMgPSBub3JtYWxpemUoYSwgYywgcCwgcyk7XG4gICAgcmV0dXJuIG9wdHMuYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgKiBkIC0gb3B0cy5zKSAqICgyICogTWF0aC5QSSkgLyBvcHRzLnAgKSArIG9wdHMuYyArIGI7XG4gIH1cblxuICAvKipcbiAgICogRWxhc3RpYyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0RWxhc3RpYyh0LCBiLCBjLCBkKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4LCBwID0gMCwgYSA9IGM7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0ID09PSAyKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIGlmICghcCkge1xuICAgICAgcCA9IGQgKiAoMC4zICogMS41KTtcbiAgICB9XG4gICAgdmFyIG9wdHMgPSBub3JtYWxpemUoYSwgYywgcCwgcyk7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gLTAuNSAqIGVsYXN0aWMob3B0cywgdCwgZCkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gb3B0cy5hICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICpcbiAgICAgIE1hdGguc2luKCh0ICogZCAtIG9wdHMucykgKiAoMiAqIE1hdGguUEkpIC8gb3B0cy5wICkgKiAwLjUgKyBvcHRzLmMgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkJhY2sodCwgYiwgYywgZCwgcykge1xuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHMgPSAxLjcwMTU4O1xuICAgIH1cbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqICgocyArIDEpICogdCAtIHMpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYWNrd2FyZHMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEJhY2sodCwgYiwgYywgZCwgcykge1xuICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHMgPSAxLjcwMTU4O1xuICAgIH1cbiAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQmFja3dhcmRzIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRCYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBpblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluQm91bmNlKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAtIGVhc2VPdXRCb3VuY2UgKGQgLSB0LCAwLCBjLCBkKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQm91bmNpbmcgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEJvdW5jZSh0LCBiLCBjLCBkKSB7XG4gICAgaWYgKCh0IC89IGQpIDwgKDEgLyAyLjc1KSkge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogdCAqIHQpICsgYjtcbiAgICB9XG4gICAgZWxzZSBpZiAodCA8ICgyIC8gMi43NSkpIHtcbiAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09ICgxLjUgLyAyLjc1KSkgKiB0ICsgMC43NSkgKyBiO1xuICAgIH1cbiAgICBlbHNlIGlmICh0IDwgKDIuNSAvIDIuNzUpKSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMi4yNSAvIDIuNzUpKSAqIHQgKyAwLjkzNzUpICsgYjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgMC45ODQzNzUpICsgYjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQm91bmNpbmcgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEJvdW5jZSh0LCBiLCBjLCBkKSB7XG4gICAgaWYgKHQgPCBkIC8gMikge1xuICAgICAgcmV0dXJuIGVhc2VJbkJvdW5jZSAodCAqIDIsIDAsIGMsIGQpICogMC41ICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGVhc2VPdXRCb3VuY2UodCAqIDIgLSBkLCAwLCBjLCBkKSAqIDAuNSArIGMgKiAwLjUgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVhc2luZyBmdW5jdGlvbnNcbiAgICogU2VlIDxhIGhyZWY9XCJodHRwOi8vZ2l6bWEuY29tL2Vhc2luZy9cIj5FYXNpbmcgRXF1YXRpb25zIGJ5IFJvYmVydCBQZW5uZXI8L2E+XG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZmFicmljLnV0aWwuZWFzZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFF1YWRyYXRpYyBlYXNpbmcgaW5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgICAqL1xuICAgIGVhc2VJblF1YWQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVhZHJhdGljIGVhc2luZyBvdXRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgICAqL1xuICAgIGVhc2VPdXRRdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gLWMgKiAodCAvPSBkKSAqICh0IC0gMikgKyBiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBRdWFkcmF0aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgICAqL1xuICAgIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHQgLz0gKGQgLyAyKTtcbiAgICAgIGlmICh0IDwgMSkge1xuICAgICAgICByZXR1cm4gYyAvIDIgKiB0ICogdCArIGI7XG4gICAgICB9XG4gICAgICByZXR1cm4gLWMgLyAyICogKCgtLXQpICogKHQgLSAyKSAtIDEpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3ViaWMgZWFzaW5nIGluXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5DdWJpYzogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICsgYjtcbiAgICB9LFxuXG4gICAgZWFzZU91dEN1YmljOiBlYXNlT3V0Q3ViaWMsXG4gICAgZWFzZUluT3V0Q3ViaWM6IGVhc2VJbk91dEN1YmljLFxuICAgIGVhc2VJblF1YXJ0OiBlYXNlSW5RdWFydCxcbiAgICBlYXNlT3V0UXVhcnQ6IGVhc2VPdXRRdWFydCxcbiAgICBlYXNlSW5PdXRRdWFydDogZWFzZUluT3V0UXVhcnQsXG4gICAgZWFzZUluUXVpbnQ6IGVhc2VJblF1aW50LFxuICAgIGVhc2VPdXRRdWludDogZWFzZU91dFF1aW50LFxuICAgIGVhc2VJbk91dFF1aW50OiBlYXNlSW5PdXRRdWludCxcbiAgICBlYXNlSW5TaW5lOiBlYXNlSW5TaW5lLFxuICAgIGVhc2VPdXRTaW5lOiBlYXNlT3V0U2luZSxcbiAgICBlYXNlSW5PdXRTaW5lOiBlYXNlSW5PdXRTaW5lLFxuICAgIGVhc2VJbkV4cG86IGVhc2VJbkV4cG8sXG4gICAgZWFzZU91dEV4cG86IGVhc2VPdXRFeHBvLFxuICAgIGVhc2VJbk91dEV4cG86IGVhc2VJbk91dEV4cG8sXG4gICAgZWFzZUluQ2lyYzogZWFzZUluQ2lyYyxcbiAgICBlYXNlT3V0Q2lyYzogZWFzZU91dENpcmMsXG4gICAgZWFzZUluT3V0Q2lyYzogZWFzZUluT3V0Q2lyYyxcbiAgICBlYXNlSW5FbGFzdGljOiBlYXNlSW5FbGFzdGljLFxuICAgIGVhc2VPdXRFbGFzdGljOiBlYXNlT3V0RWxhc3RpYyxcbiAgICBlYXNlSW5PdXRFbGFzdGljOiBlYXNlSW5PdXRFbGFzdGljLFxuICAgIGVhc2VJbkJhY2s6IGVhc2VJbkJhY2ssXG4gICAgZWFzZU91dEJhY2s6IGVhc2VPdXRCYWNrLFxuICAgIGVhc2VJbk91dEJhY2s6IGVhc2VJbk91dEJhY2ssXG4gICAgZWFzZUluQm91bmNlOiBlYXNlSW5Cb3VuY2UsXG4gICAgZWFzZU91dEJvdW5jZTogZWFzZU91dEJvdW5jZSxcbiAgICBlYXNlSW5PdXRCb3VuY2U6IGVhc2VJbk91dEJvdW5jZVxuICB9O1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEBuYW1lIGZhYnJpY1xuICAgKiBAbmFtZXNwYWNlXG4gICAqL1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgcGFyc2VVbml0ID0gZmFicmljLnV0aWwucGFyc2VVbml0LFxuICAgICAgbXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMsXG5cbiAgICAgIHN2Z1ZhbGlkVGFnTmFtZXMgPSBbJ3BhdGgnLCAnY2lyY2xlJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAnZWxsaXBzZScsICdyZWN0JywgJ2xpbmUnLFxuICAgICAgICAnaW1hZ2UnLCAndGV4dCddLFxuICAgICAgc3ZnVmlld0JveEVsZW1lbnRzID0gWydzeW1ib2wnLCAnaW1hZ2UnLCAnbWFya2VyJywgJ3BhdHRlcm4nLCAndmlldycsICdzdmcnXSxcbiAgICAgIHN2Z0ludmFsaWRBbmNlc3RvcnMgPSBbJ3BhdHRlcm4nLCAnZGVmcycsICdzeW1ib2wnLCAnbWV0YWRhdGEnLCAnY2xpcFBhdGgnLCAnbWFzaycsICdkZXNjJ10sXG4gICAgICBzdmdWYWxpZFBhcmVudHMgPSBbJ3N5bWJvbCcsICdnJywgJ2EnLCAnc3ZnJywgJ2NsaXBQYXRoJywgJ2RlZnMnXSxcblxuICAgICAgYXR0cmlidXRlc01hcCA9IHtcbiAgICAgICAgY3g6ICAgICAgICAgICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgeDogICAgICAgICAgICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgcjogICAgICAgICAgICAgICAgICAgICdyYWRpdXMnLFxuICAgICAgICBjeTogICAgICAgICAgICAgICAgICAgJ3RvcCcsXG4gICAgICAgIHk6ICAgICAgICAgICAgICAgICAgICAndG9wJyxcbiAgICAgICAgZGlzcGxheTogICAgICAgICAgICAgICd2aXNpYmxlJyxcbiAgICAgICAgdmlzaWJpbGl0eTogICAgICAgICAgICd2aXNpYmxlJyxcbiAgICAgICAgdHJhbnNmb3JtOiAgICAgICAgICAgICd0cmFuc2Zvcm1NYXRyaXgnLFxuICAgICAgICAnZmlsbC1vcGFjaXR5JzogICAgICAgJ2ZpbGxPcGFjaXR5JyxcbiAgICAgICAgJ2ZpbGwtcnVsZSc6ICAgICAgICAgICdmaWxsUnVsZScsXG4gICAgICAgICdmb250LWZhbWlseSc6ICAgICAgICAnZm9udEZhbWlseScsXG4gICAgICAgICdmb250LXNpemUnOiAgICAgICAgICAnZm9udFNpemUnLFxuICAgICAgICAnZm9udC1zdHlsZSc6ICAgICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAgICdmb250LXdlaWdodCc6ICAgICAgICAnZm9udFdlaWdodCcsXG4gICAgICAgICdsZXR0ZXItc3BhY2luZyc6ICAgICAnY2hhclNwYWNpbmcnLFxuICAgICAgICAncGFpbnQtb3JkZXInOiAgICAgICAgJ3BhaW50Rmlyc3QnLFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICAgJ3N0cm9rZURhc2hBcnJheScsXG4gICAgICAgICdzdHJva2UtZGFzaG9mZnNldCc6ICAnc3Ryb2tlRGFzaE9mZnNldCcsXG4gICAgICAgICdzdHJva2UtbGluZWNhcCc6ICAgICAnc3Ryb2tlTGluZUNhcCcsXG4gICAgICAgICdzdHJva2UtbGluZWpvaW4nOiAgICAnc3Ryb2tlTGluZUpvaW4nLFxuICAgICAgICAnc3Ryb2tlLW1pdGVybGltaXQnOiAgJ3N0cm9rZU1pdGVyTGltaXQnLFxuICAgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAgICAgJ3N0cm9rZU9wYWNpdHknLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogICAgICAgJ3N0cm9rZVdpZHRoJyxcbiAgICAgICAgJ3RleHQtZGVjb3JhdGlvbic6ICAgICd0ZXh0RGVjb3JhdGlvbicsXG4gICAgICAgICd0ZXh0LWFuY2hvcic6ICAgICAgICAndGV4dEFuY2hvcicsXG4gICAgICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAnb3BhY2l0eScsXG4gICAgICAgICdjbGlwLXBhdGgnOiAgICAgICAgICAnY2xpcFBhdGgnLFxuICAgICAgICAnY2xpcC1ydWxlJzogICAgICAgICAgJ2NsaXBSdWxlJyxcbiAgICAgICAgJ3ZlY3Rvci1lZmZlY3QnOiAgICAgICdzdHJva2VVbmlmb3JtJyxcbiAgICAgICAgJ2ltYWdlLXJlbmRlcmluZyc6ICAgICdpbWFnZVNtb290aGluZycsXG4gICAgICB9LFxuXG4gICAgICBjb2xvckF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIHN0cm9rZTogJ3N0cm9rZU9wYWNpdHknLFxuICAgICAgICBmaWxsOiAgICdmaWxsT3BhY2l0eSdcbiAgICAgIH0sXG5cbiAgICAgIGZTaXplID0gJ2ZvbnQtc2l6ZScsIGNQYXRoID0gJ2NsaXAtcGF0aCc7XG5cbiAgZmFicmljLnN2Z1ZhbGlkVGFnTmFtZXNSZWdFeCA9IGdldFN2Z1JlZ2V4KHN2Z1ZhbGlkVGFnTmFtZXMpO1xuICBmYWJyaWMuc3ZnVmlld0JveEVsZW1lbnRzUmVnRXggPSBnZXRTdmdSZWdleChzdmdWaWV3Qm94RWxlbWVudHMpO1xuICBmYWJyaWMuc3ZnSW52YWxpZEFuY2VzdG9yc1JlZ0V4ID0gZ2V0U3ZnUmVnZXgoc3ZnSW52YWxpZEFuY2VzdG9ycyk7XG4gIGZhYnJpYy5zdmdWYWxpZFBhcmVudHNSZWdFeCA9IGdldFN2Z1JlZ2V4KHN2Z1ZhbGlkUGFyZW50cyk7XG5cbiAgZmFicmljLmNzc1J1bGVzID0geyB9O1xuICBmYWJyaWMuZ3JhZGllbnREZWZzID0geyB9O1xuICBmYWJyaWMuY2xpcFBhdGhzID0geyB9O1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUF0dHIoYXR0cikge1xuICAgIC8vIHRyYW5zZm9ybSBhdHRyaWJ1dGUgbmFtZXNcbiAgICBpZiAoYXR0ciBpbiBhdHRyaWJ1dGVzTWFwKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlc01hcFthdHRyXTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHI7XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZShhdHRyLCB2YWx1ZSwgcGFyZW50QXR0cmlidXRlcywgZm9udFNpemUpIHtcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWUpLCBwYXJzZWQ7XG5cbiAgICBpZiAoKGF0dHIgPT09ICdmaWxsJyB8fCBhdHRyID09PSAnc3Ryb2tlJykgJiYgdmFsdWUgPT09ICdub25lJykge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3N0cm9rZVVuaWZvcm0nKSB7XG4gICAgICByZXR1cm4gKHZhbHVlID09PSAnbm9uLXNjYWxpbmctc3Ryb2tlJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdzdHJva2VEYXNoQXJyYXknKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICdub25lJykge1xuICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8sL2csICcgJykuc3BsaXQoL1xccysvKS5tYXAocGFyc2VGbG9hdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICd0cmFuc2Zvcm1NYXRyaXgnKSB7XG4gICAgICBpZiAocGFyZW50QXR0cmlidXRlcyAmJiBwYXJlbnRBdHRyaWJ1dGVzLnRyYW5zZm9ybU1hdHJpeCkge1xuICAgICAgICB2YWx1ZSA9IG11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoXG4gICAgICAgICAgcGFyZW50QXR0cmlidXRlcy50cmFuc2Zvcm1NYXRyaXgsIGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSAnbm9uZScgJiYgdmFsdWUgIT09ICdoaWRkZW4nO1xuICAgICAgLy8gZGlzcGxheT1ub25lIG9uIHBhcmVudCBlbGVtZW50IGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgY2hpbGQgZWxlbWVudFxuICAgICAgaWYgKHBhcmVudEF0dHJpYnV0ZXMgJiYgcGFyZW50QXR0cmlidXRlcy52aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnb3BhY2l0eScpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICBpZiAocGFyZW50QXR0cmlidXRlcyAmJiB0eXBlb2YgcGFyZW50QXR0cmlidXRlcy5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YWx1ZSAqPSBwYXJlbnRBdHRyaWJ1dGVzLm9wYWNpdHk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICd0ZXh0QW5jaG9yJyAvKiB0ZXh0LWFuY2hvciAqLykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ3N0YXJ0JyA/ICdsZWZ0JyA6IHZhbHVlID09PSAnZW5kJyA/ICdyaWdodCcgOiAnY2VudGVyJztcbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ2NoYXJTcGFjaW5nJykge1xuICAgICAgLy8gcGFyc2VVbml0IHJldHVybnMgcHggYW5kIHdlIGNvbnZlcnQgaXQgdG8gZW1cbiAgICAgIHBhcnNlZCA9IHBhcnNlVW5pdCh2YWx1ZSwgZm9udFNpemUpIC8gZm9udFNpemUgKiAxMDAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAncGFpbnRGaXJzdCcpIHtcbiAgICAgIHZhciBmaWxsSW5kZXggPSB2YWx1ZS5pbmRleE9mKCdmaWxsJyk7XG4gICAgICB2YXIgc3Ryb2tlSW5kZXggPSB2YWx1ZS5pbmRleE9mKCdzdHJva2UnKTtcbiAgICAgIHZhciB2YWx1ZSA9ICdmaWxsJztcbiAgICAgIGlmIChmaWxsSW5kZXggPiAtMSAmJiBzdHJva2VJbmRleCA+IC0xICYmIHN0cm9rZUluZGV4IDwgZmlsbEluZGV4KSB7XG4gICAgICAgIHZhbHVlID0gJ3N0cm9rZSc7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmaWxsSW5kZXggPT09IC0xICYmIHN0cm9rZUluZGV4ID4gLTEpIHtcbiAgICAgICAgdmFsdWUgPSAnc3Ryb2tlJztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ2hyZWYnIHx8IGF0dHIgPT09ICd4bGluazpocmVmJyB8fCBhdHRyID09PSAnZm9udCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ2ltYWdlU21vb3RoaW5nJykge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gJ29wdGltaXplUXVhbGl0eScpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHBhcnNlZCA9IGlzQXJyYXkgPyB2YWx1ZS5tYXAocGFyc2VVbml0KSA6IHBhcnNlVW5pdCh2YWx1ZSwgZm9udFNpemUpO1xuICAgIH1cblxuICAgIHJldHVybiAoIWlzQXJyYXkgJiYgaXNOYU4ocGFyc2VkKSA/IHZhbHVlIDogcGFyc2VkKTtcbiAgfVxuXG4gIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICBmdW5jdGlvbiBnZXRTdmdSZWdleChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXignICsgYXJyLmpvaW4oJ3wnKSArICcpXFxcXGInLCAnaScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIEFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gcGFyc2VcbiAgICovXG4gIGZ1bmN0aW9uIF9zZXRTdHJva2VGaWxsT3BhY2l0eShhdHRyaWJ1dGVzKSB7XG4gICAgZm9yICh2YXIgYXR0ciBpbiBjb2xvckF0dHJpYnV0ZXMpIHtcblxuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzW2NvbG9yQXR0cmlidXRlc1thdHRyXV0gPT09ICd1bmRlZmluZWQnIHx8IGF0dHJpYnV0ZXNbYXR0cl0gPT09ICcnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXNbYXR0cl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICghZmFicmljLk9iamVjdC5wcm90b3R5cGVbYXR0cl0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gZmFicmljLk9iamVjdC5wcm90b3R5cGVbYXR0cl07XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzW2F0dHJdLmluZGV4T2YoJ3VybCgnKSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihhdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgIGF0dHJpYnV0ZXNbYXR0cl0gPSBjb2xvci5zZXRBbHBoYSh0b0ZpeGVkKGNvbG9yLmdldEFscGhhKCkgKiBhdHRyaWJ1dGVzW2NvbG9yQXR0cmlidXRlc1thdHRyXV0sIDIpKS50b1JnYmEoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9nZXRNdWx0aXBsZU5vZGVzKGRvYywgbm9kZU5hbWVzKSB7XG4gICAgdmFyIG5vZGVOYW1lLCBub2RlQXJyYXkgPSBbXSwgbm9kZUxpc3QsIGksIGxlbjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlTmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5vZGVOYW1lID0gbm9kZU5hbWVzW2ldO1xuICAgICAgbm9kZUxpc3QgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUobm9kZU5hbWUpO1xuICAgICAgbm9kZUFycmF5ID0gbm9kZUFycmF5LmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2RlTGlzdCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZUFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBcInRyYW5zZm9ybVwiIGF0dHJpYnV0ZSwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVWYWx1ZSBTdHJpbmcgY29udGFpbmluZyBhdHRyaWJ1dGUgdmFsdWVcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIDYgZWxlbWVudHMgcmVwcmVzZW50aW5nIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgKi9cbiAgZmFicmljLnBhcnNlVHJhbnNmb3JtQXR0cmlidXRlID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIHJvdGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIHZhciBjb3MgPSBmYWJyaWMudXRpbC5jb3MoYXJnc1swXSksIHNpbiA9IGZhYnJpYy51dGlsLnNpbihhcmdzWzBdKSxcbiAgICAgICAgICB4ID0gMCwgeSA9IDA7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgeCA9IGFyZ3NbMV07XG4gICAgICAgIHkgPSBhcmdzWzJdO1xuICAgICAgfVxuXG4gICAgICBtYXRyaXhbMF0gPSBjb3M7XG4gICAgICBtYXRyaXhbMV0gPSBzaW47XG4gICAgICBtYXRyaXhbMl0gPSAtc2luO1xuICAgICAgbWF0cml4WzNdID0gY29zO1xuICAgICAgbWF0cml4WzRdID0geCAtIChjb3MgKiB4IC0gc2luICogeSk7XG4gICAgICBtYXRyaXhbNV0gPSB5IC0gKHNpbiAqIHggKyBjb3MgKiB5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZU1hdHJpeChtYXRyaXgsIGFyZ3MpIHtcbiAgICAgIHZhciBtdWx0aXBsaWVyWCA9IGFyZ3NbMF0sXG4gICAgICAgICAgbXVsdGlwbGllclkgPSAoYXJncy5sZW5ndGggPT09IDIpID8gYXJnc1sxXSA6IGFyZ3NbMF07XG5cbiAgICAgIG1hdHJpeFswXSA9IG11bHRpcGxpZXJYO1xuICAgICAgbWF0cml4WzNdID0gbXVsdGlwbGllclk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tld01hdHJpeChtYXRyaXgsIGFyZ3MsIHBvcykge1xuICAgICAgbWF0cml4W3Bvc10gPSBNYXRoLnRhbihmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKGFyZ3NbMF0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGVNYXRyaXgobWF0cml4LCBhcmdzKSB7XG4gICAgICBtYXRyaXhbNF0gPSBhcmdzWzBdO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIG1hdHJpeFs1XSA9IGFyZ3NbMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWRlbnRpdHkgbWF0cml4XG4gICAgdmFyIGlNYXRyaXggPSBmYWJyaWMuaU1hdHJpeCxcblxuICAgICAgICAvLyA9PSBiZWdpbiB0cmFuc2Zvcm0gcmVnZXhwXG4gICAgICAgIG51bWJlciA9IGZhYnJpYy5yZU51bSxcblxuICAgICAgICBjb21tYVdzcCA9IGZhYnJpYy5jb21tYVdzcCxcblxuICAgICAgICBza2V3WCA9ICcoPzooc2tld1gpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCkpJyxcblxuICAgICAgICBza2V3WSA9ICcoPzooc2tld1kpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCkpJyxcblxuICAgICAgICByb3RhdGUgPSAnKD86KHJvdGF0ZSlcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJykoPzonICtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFXc3AgKyAnKCcgKyBudW1iZXIgKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICBjb21tYVdzcCArICcoJyArIG51bWJlciArICcpKT9cXFxccypcXFxcKSknLFxuXG4gICAgICAgIHNjYWxlID0gJyg/OihzY2FsZSlcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJykoPzonICtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFXc3AgKyAnKCcgKyBudW1iZXIgKyAnKSk/XFxcXHMqXFxcXCkpJyxcblxuICAgICAgICB0cmFuc2xhdGUgPSAnKD86KHRyYW5zbGF0ZSlcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyICsgJykoPzonICtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFXc3AgKyAnKCcgKyBudW1iZXIgKyAnKSk/XFxcXHMqXFxcXCkpJyxcblxuICAgICAgICBtYXRyaXggPSAnKD86KG1hdHJpeClcXFxccypcXFxcKFxcXFxzKicgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICsgY29tbWFXc3AgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICsgY29tbWFXc3AgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICsgY29tbWFXc3AgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICsgY29tbWFXc3AgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICsgY29tbWFXc3AgK1xuICAgICAgICAgICAgICAgICAgJygnICsgbnVtYmVyICsgJyknICtcbiAgICAgICAgICAgICAgICAgICdcXFxccypcXFxcKSknLFxuXG4gICAgICAgIHRyYW5zZm9ybSA9ICcoPzonICtcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4ICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUgKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICByb3RhdGUgKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICBza2V3WCArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHNrZXdZICtcbiAgICAgICAgICAgICAgICAgICAgJyknLFxuXG4gICAgICAgIHRyYW5zZm9ybXMgPSAnKD86JyArIHRyYW5zZm9ybSArICcoPzonICsgY29tbWFXc3AgKyAnKicgKyB0cmFuc2Zvcm0gKyAnKSonICsgJyknLFxuXG4gICAgICAgIHRyYW5zZm9ybUxpc3QgPSAnXlxcXFxzKig/OicgKyB0cmFuc2Zvcm1zICsgJz8pXFxcXHMqJCcsXG5cbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1RyYW5zZm9ybUF0dHJpYnV0ZVxuICAgICAgICByZVRyYW5zZm9ybUxpc3QgPSBuZXcgUmVnRXhwKHRyYW5zZm9ybUxpc3QpLFxuICAgICAgICAvLyA9PSBlbmQgdHJhbnNmb3JtIHJlZ2V4cFxuXG4gICAgICAgIHJlVHJhbnNmb3JtID0gbmV3IFJlZ0V4cCh0cmFuc2Zvcm0sICdnJyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYXR0cmlidXRlVmFsdWUpIHtcblxuICAgICAgLy8gc3RhcnQgd2l0aCBpZGVudGl0eSBtYXRyaXhcbiAgICAgIHZhciBtYXRyaXggPSBpTWF0cml4LmNvbmNhdCgpLFxuICAgICAgICAgIG1hdHJpY2VzID0gW107XG5cbiAgICAgIC8vIHJldHVybiBpZiBubyBhcmd1bWVudCB3YXMgZ2l2ZW4gb3JcbiAgICAgIC8vIGFuIGFyZ3VtZW50IGRvZXMgbm90IG1hdGNoIHRyYW5zZm9ybSBhdHRyaWJ1dGUgcmVnZXhwXG4gICAgICBpZiAoIWF0dHJpYnV0ZVZhbHVlIHx8IChhdHRyaWJ1dGVWYWx1ZSAmJiAhcmVUcmFuc2Zvcm1MaXN0LnRlc3QoYXR0cmlidXRlVmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgfVxuXG4gICAgICBhdHRyaWJ1dGVWYWx1ZS5yZXBsYWNlKHJlVHJhbnNmb3JtLCBmdW5jdGlvbihtYXRjaCkge1xuXG4gICAgICAgIHZhciBtID0gbmV3IFJlZ0V4cCh0cmFuc2Zvcm0pLmV4ZWMobWF0Y2gpLmZpbHRlcihmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgLy8gbWF0Y2ggIT09ICcnICYmIG1hdGNoICE9IG51bGxcbiAgICAgICAgICAgICAgcmV0dXJuICghIW1hdGNoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb3BlcmF0aW9uID0gbVsxXSxcbiAgICAgICAgICAgIGFyZ3MgPSBtLnNsaWNlKDIpLm1hcChwYXJzZUZsb2F0KTtcblxuICAgICAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgICAgICAgIGNhc2UgJ3RyYW5zbGF0ZSc6XG4gICAgICAgICAgICB0cmFuc2xhdGVNYXRyaXgobWF0cml4LCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgICBhcmdzWzBdID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyhhcmdzWzBdKTtcbiAgICAgICAgICAgIHJvdGF0ZU1hdHJpeChtYXRyaXgsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2NhbGUnOlxuICAgICAgICAgICAgc2NhbGVNYXRyaXgobWF0cml4LCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NrZXdYJzpcbiAgICAgICAgICAgIHNrZXdNYXRyaXgobWF0cml4LCBhcmdzLCAyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NrZXdZJzpcbiAgICAgICAgICAgIHNrZXdNYXRyaXgobWF0cml4LCBhcmdzLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21hdHJpeCc6XG4gICAgICAgICAgICBtYXRyaXggPSBhcmdzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzbmFwc2hvdCBjdXJyZW50IG1hdHJpeCBpbnRvIG1hdHJpY2VzIGFycmF5XG4gICAgICAgIG1hdHJpY2VzLnB1c2gobWF0cml4LmNvbmNhdCgpKTtcbiAgICAgICAgLy8gcmVzZXRcbiAgICAgICAgbWF0cml4ID0gaU1hdHJpeC5jb25jYXQoKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY29tYmluZWRNYXRyaXggPSBtYXRyaWNlc1swXTtcbiAgICAgIHdoaWxlIChtYXRyaWNlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG1hdHJpY2VzLnNoaWZ0KCk7XG4gICAgICAgIGNvbWJpbmVkTWF0cml4ID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhjb21iaW5lZE1hdHJpeCwgbWF0cmljZXNbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0cml4O1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVN0eWxlU3RyaW5nKHN0eWxlLCBvU3R5bGUpIHtcbiAgICB2YXIgYXR0ciwgdmFsdWU7XG4gICAgc3R5bGUucmVwbGFjZSgvO1xccyokLywgJycpLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHZhciBwYWlyID0gY2h1bmsuc3BsaXQoJzonKTtcblxuICAgICAgYXR0ciA9IHBhaXJbMF0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YWx1ZSA9ICBwYWlyWzFdLnRyaW0oKTtcblxuICAgICAgb1N0eWxlW2F0dHJdID0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlU3R5bGVPYmplY3Qoc3R5bGUsIG9TdHlsZSkge1xuICAgIHZhciBhdHRyLCB2YWx1ZTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XG4gICAgICBpZiAodHlwZW9mIHN0eWxlW3Byb3BdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYXR0ciA9IHByb3AudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhbHVlID0gc3R5bGVbcHJvcF07XG5cbiAgICAgIG9TdHlsZVthdHRyXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0R2xvYmFsU3R5bGVzRm9yRWxlbWVudChlbGVtZW50LCBzdmdVaWQpIHtcbiAgICB2YXIgc3R5bGVzID0geyB9O1xuICAgIGZvciAodmFyIHJ1bGUgaW4gZmFicmljLmNzc1J1bGVzW3N2Z1VpZF0pIHtcbiAgICAgIGlmIChlbGVtZW50TWF0Y2hlc1J1bGUoZWxlbWVudCwgcnVsZS5zcGxpdCgnICcpKSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXVtydWxlXSkge1xuICAgICAgICAgIHN0eWxlc1twcm9wZXJ0eV0gPSBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXVtydWxlXVtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZWxlbWVudE1hdGNoZXNSdWxlKGVsZW1lbnQsIHNlbGVjdG9ycykge1xuICAgIHZhciBmaXJzdE1hdGNoaW5nLCBwYXJlbnRNYXRjaGluZyA9IHRydWU7XG4gICAgLy9zdGFydCBmcm9tIHJpZ2h0bW9zdCBzZWxlY3Rvci5cbiAgICBmaXJzdE1hdGNoaW5nID0gc2VsZWN0b3JNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9ycy5wb3AoKSk7XG4gICAgaWYgKGZpcnN0TWF0Y2hpbmcgJiYgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgcGFyZW50TWF0Y2hpbmcgPSBkb2VzU29tZVBhcmVudE1hdGNoKGVsZW1lbnQsIHNlbGVjdG9ycyk7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdE1hdGNoaW5nICYmIHBhcmVudE1hdGNoaW5nICYmIChzZWxlY3RvcnMubGVuZ3RoID09PSAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvZXNTb21lUGFyZW50TWF0Y2goZWxlbWVudCwgc2VsZWN0b3JzKSB7XG4gICAgdmFyIHNlbGVjdG9yLCBwYXJlbnRNYXRjaGluZyA9IHRydWU7XG4gICAgd2hpbGUgKGVsZW1lbnQucGFyZW50Tm9kZSAmJiBlbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IDEgJiYgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgaWYgKHBhcmVudE1hdGNoaW5nKSB7XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JzLnBvcCgpO1xuICAgICAgfVxuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE1hdGNoaW5nID0gc2VsZWN0b3JNYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9ycy5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNlbGVjdG9yTWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUsXG4gICAgICAgIGNsYXNzTmFtZXMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSxcbiAgICAgICAgaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKSwgbWF0Y2hlciwgaTtcbiAgICAvLyBpIGNoZWNrIGlmIGEgc2VsZWN0b3IgbWF0Y2hlcyBzbGljaW5nIGF3YXkgcGFydCBmcm9tIGl0LlxuICAgIC8vIGlmIGkgZ2V0IGVtcHR5IHN0cmluZyBpIHNob3VsZCBtYXRjaFxuICAgIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCdeJyArIG5vZGVOYW1lLCAnaScpO1xuICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShtYXRjaGVyLCAnJyk7XG4gICAgaWYgKGlkICYmIHNlbGVjdG9yLmxlbmd0aCkge1xuICAgICAgbWF0Y2hlciA9IG5ldyBSZWdFeHAoJyMnICsgaWQgKyAnKD8hW2EtekEtWlxcXFwtXSspJywgJ2knKTtcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShtYXRjaGVyLCAnJyk7XG4gICAgfVxuICAgIGlmIChjbGFzc05hbWVzICYmIHNlbGVjdG9yLmxlbmd0aCkge1xuICAgICAgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMuc3BsaXQoJyAnKTtcbiAgICAgIGZvciAoaSA9IGNsYXNzTmFtZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCdcXFxcLicgKyBjbGFzc05hbWVzW2ldICsgJyg/IVthLXpBLVpcXFxcLV0rKScsICdpJyk7XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShtYXRjaGVyLCAnJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rvci5sZW5ndGggPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogdG8gc3VwcG9ydCBJRTggbWlzc2luZyBnZXRFbGVtZW50QnlJZCBvbiBTVkdkb2N1bWVudCBhbmQgb24gbm9kZSB4bWxET01cbiAgICovXG4gIGZ1bmN0aW9uIGVsZW1lbnRCeUlkKGRvYywgaWQpIHtcbiAgICB2YXIgZWw7XG4gICAgZG9jLmdldEVsZW1lbnRCeUlkICYmIChlbCA9IGRvYy5nZXRFbGVtZW50QnlJZChpZCkpO1xuICAgIGlmIChlbCkge1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgICB2YXIgbm9kZSwgaSwgbGVuLCBub2RlbGlzdCA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGVsaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZWxpc3RbaV07XG4gICAgICBpZiAoaWQgPT09IG5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VVc2VEaXJlY3RpdmVzKGRvYykge1xuICAgIHZhciBub2RlbGlzdCA9IF9nZXRNdWx0aXBsZU5vZGVzKGRvYywgWyd1c2UnLCAnc3ZnOnVzZSddKSwgaSA9IDA7XG4gICAgd2hpbGUgKG5vZGVsaXN0Lmxlbmd0aCAmJiBpIDwgbm9kZWxpc3QubGVuZ3RoKSB7XG4gICAgICB2YXIgZWwgPSBub2RlbGlzdFtpXSxcbiAgICAgICAgICB4bGlua0F0dHJpYnV0ZSA9IGVsLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpIHx8IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXG4gICAgICBpZiAoeGxpbmtBdHRyaWJ1dGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgeGxpbmsgPSB4bGlua0F0dHJpYnV0ZS5zbGljZSgxKSxcbiAgICAgICAgICB4ID0gZWwuZ2V0QXR0cmlidXRlKCd4JykgfHwgMCxcbiAgICAgICAgICB5ID0gZWwuZ2V0QXR0cmlidXRlKCd5JykgfHwgMCxcbiAgICAgICAgICBlbDIgPSBlbGVtZW50QnlJZChkb2MsIHhsaW5rKS5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICAgICAgY3VycmVudFRyYW5zID0gKGVsMi5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpIHx8ICcnKSArICcgdHJhbnNsYXRlKCcgKyB4ICsgJywgJyArIHkgKyAnKScsXG4gICAgICAgICAgcGFyZW50Tm9kZSxcbiAgICAgICAgICBvbGRMZW5ndGggPSBub2RlbGlzdC5sZW5ndGgsIGF0dHIsXG4gICAgICAgICAgaixcbiAgICAgICAgICBhdHRycyxcbiAgICAgICAgICBsZW4sXG4gICAgICAgICAgbmFtZXNwYWNlID0gZmFicmljLnN2Z05TO1xuXG4gICAgICBhcHBseVZpZXdib3hUcmFuc2Zvcm0oZWwyKTtcbiAgICAgIGlmICgvXnN2ZyQvaS50ZXN0KGVsMi5ub2RlTmFtZSkpIHtcbiAgICAgICAgdmFyIGVsMyA9IGVsMi5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsICdnJyk7XG4gICAgICAgIGZvciAoaiA9IDAsIGF0dHJzID0gZWwyLmF0dHJpYnV0ZXMsIGxlbiA9IGF0dHJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgYXR0ciA9IGF0dHJzLml0ZW0oaik7XG4gICAgICAgICAgZWwzLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgYXR0ci5ub2RlTmFtZSwgYXR0ci5ub2RlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsMi5maXJzdENoaWxkICE9IG51bGxcbiAgICAgICAgd2hpbGUgKGVsMi5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZWwzLmFwcGVuZENoaWxkKGVsMi5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbDIgPSBlbDM7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaiA9IDAsIGF0dHJzID0gZWwuYXR0cmlidXRlcywgbGVuID0gYXR0cnMubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgYXR0ciA9IGF0dHJzLml0ZW0oaik7XG4gICAgICAgIGlmIChhdHRyLm5vZGVOYW1lID09PSAneCcgfHwgYXR0ci5ub2RlTmFtZSA9PT0gJ3knIHx8XG4gICAgICAgICAgYXR0ci5ub2RlTmFtZSA9PT0gJ3hsaW5rOmhyZWYnIHx8IGF0dHIubm9kZU5hbWUgPT09ICdocmVmJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF0dHIubm9kZU5hbWUgPT09ICd0cmFuc2Zvcm0nKSB7XG4gICAgICAgICAgY3VycmVudFRyYW5zID0gYXR0ci5ub2RlVmFsdWUgKyAnICcgKyBjdXJyZW50VHJhbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZWwyLnNldEF0dHJpYnV0ZShhdHRyLm5vZGVOYW1lLCBhdHRyLm5vZGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWwyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgY3VycmVudFRyYW5zKTtcbiAgICAgIGVsMi5zZXRBdHRyaWJ1dGUoJ2luc3RhbnRpYXRlZF9ieV91c2UnLCAnMScpO1xuICAgICAgZWwyLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgIHBhcmVudE5vZGUgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZWwyLCBlbCk7XG4gICAgICAvLyBzb21lIGJyb3dzZXJzIGRvIG5vdCBzaG9ydGVuIG5vZGVsaXN0IGFmdGVyIHJlcGxhY2VDaGlsZCAoSUU4KVxuICAgICAgaWYgKG5vZGVsaXN0Lmxlbmd0aCA9PT0gb2xkTGVuZ3RoKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjVmlld0JveEF0dHJpYnV0ZVxuICAvLyBtYXRjaGVzLCBlLmcuOiArMTQuNTZlLTEyLCBldGMuXG4gIHZhciByZVZpZXdCb3hBdHRyVmFsdWUgPSBuZXcgUmVnRXhwKFxuICAgICdeJyArXG4gICAgJ1xcXFxzKignICsgZmFicmljLnJlTnVtICsgJyspXFxcXHMqLD8nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyosPycgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKiw/JyArXG4gICAgJ1xcXFxzKignICsgZmFicmljLnJlTnVtICsgJyspXFxcXHMqJyArXG4gICAgJyQnXG4gICk7XG5cbiAgLyoqXG4gICAqIEFkZCBhIDxnPiBlbGVtZW50IHRoYXQgZW52ZWxvcCBhbGwgY2hpbGQgZWxlbWVudHMgYW5kIG1ha2VzIHRoZSB2aWV3Ym94IHRyYW5zZm9ybU1hdHJpeCBkZXNjZW5kIG9uIGFsbCBlbGVtZW50c1xuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHlWaWV3Ym94VHJhbnNmb3JtKGVsZW1lbnQpIHtcbiAgICBpZiAoIWZhYnJpYy5zdmdWaWV3Qm94RWxlbWVudHNSZWdFeC50ZXN0KGVsZW1lbnQubm9kZU5hbWUpKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHZhciB2aWV3Qm94QXR0ciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JyksXG4gICAgICAgIHNjYWxlWCA9IDEsXG4gICAgICAgIHNjYWxlWSA9IDEsXG4gICAgICAgIG1pblggPSAwLFxuICAgICAgICBtaW5ZID0gMCxcbiAgICAgICAgdmlld0JveFdpZHRoLCB2aWV3Qm94SGVpZ2h0LCBtYXRyaXgsIGVsLFxuICAgICAgICB3aWR0aEF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnd2lkdGgnKSxcbiAgICAgICAgaGVpZ2h0QXR0ciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSxcbiAgICAgICAgeCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd4JykgfHwgMCxcbiAgICAgICAgeSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd5JykgfHwgMCxcbiAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykgfHwgJycsXG4gICAgICAgIG1pc3NpbmdWaWV3Qm94ID0gKCF2aWV3Qm94QXR0ciB8fCAhKHZpZXdCb3hBdHRyID0gdmlld0JveEF0dHIubWF0Y2gocmVWaWV3Qm94QXR0clZhbHVlKSkpLFxuICAgICAgICBtaXNzaW5nRGltQXR0ciA9ICghd2lkdGhBdHRyIHx8ICFoZWlnaHRBdHRyIHx8IHdpZHRoQXR0ciA9PT0gJzEwMCUnIHx8IGhlaWdodEF0dHIgPT09ICcxMDAlJyksXG4gICAgICAgIHRvQmVQYXJzZWQgPSBtaXNzaW5nVmlld0JveCAmJiBtaXNzaW5nRGltQXR0cixcbiAgICAgICAgcGFyc2VkRGltID0geyB9LCB0cmFuc2xhdGVNYXRyaXggPSAnJywgd2lkdGhEaWZmID0gMCwgaGVpZ2h0RGlmZiA9IDA7XG5cbiAgICBwYXJzZWREaW0ud2lkdGggPSAwO1xuICAgIHBhcnNlZERpbS5oZWlnaHQgPSAwO1xuICAgIHBhcnNlZERpbS50b0JlUGFyc2VkID0gdG9CZVBhcnNlZDtcblxuICAgIGlmIChtaXNzaW5nVmlld0JveCkge1xuICAgICAgaWYgKCgoeCB8fCB5KSAmJiBlbGVtZW50LnBhcmVudE5vZGUgJiYgZWxlbWVudC5wYXJlbnROb2RlLm5vZGVOYW1lICE9PSAnI2RvY3VtZW50JykpIHtcbiAgICAgICAgdHJhbnNsYXRlTWF0cml4ID0gJyB0cmFuc2xhdGUoJyArIHBhcnNlVW5pdCh4KSArICcgJyArIHBhcnNlVW5pdCh5KSArICcpICc7XG4gICAgICAgIG1hdHJpeCA9IChlbGVtZW50LmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykgfHwgJycpICsgdHJhbnNsYXRlTWF0cml4O1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgbWF0cml4KTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3gnKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3knKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9CZVBhcnNlZCkge1xuICAgICAgcmV0dXJuIHBhcnNlZERpbTtcbiAgICB9XG5cbiAgICBpZiAobWlzc2luZ1ZpZXdCb3gpIHtcbiAgICAgIHBhcnNlZERpbS53aWR0aCA9IHBhcnNlVW5pdCh3aWR0aEF0dHIpO1xuICAgICAgcGFyc2VkRGltLmhlaWdodCA9IHBhcnNlVW5pdChoZWlnaHRBdHRyKTtcbiAgICAgIC8vIHNldCBhIHRyYW5zZm9ybSBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIHggeSBhbmQgYXJlIGlubmVyKG9ubHkpIFNWR3NcbiAgICAgIHJldHVybiBwYXJzZWREaW07XG4gICAgfVxuICAgIG1pblggPSAtcGFyc2VGbG9hdCh2aWV3Qm94QXR0clsxXSk7XG4gICAgbWluWSA9IC1wYXJzZUZsb2F0KHZpZXdCb3hBdHRyWzJdKTtcbiAgICB2aWV3Qm94V2lkdGggPSBwYXJzZUZsb2F0KHZpZXdCb3hBdHRyWzNdKTtcbiAgICB2aWV3Qm94SGVpZ2h0ID0gcGFyc2VGbG9hdCh2aWV3Qm94QXR0cls0XSk7XG4gICAgcGFyc2VkRGltLm1pblggPSBtaW5YO1xuICAgIHBhcnNlZERpbS5taW5ZID0gbWluWTtcbiAgICBwYXJzZWREaW0udmlld0JveFdpZHRoID0gdmlld0JveFdpZHRoO1xuICAgIHBhcnNlZERpbS52aWV3Qm94SGVpZ2h0ID0gdmlld0JveEhlaWdodDtcbiAgICBpZiAoIW1pc3NpbmdEaW1BdHRyKSB7XG4gICAgICBwYXJzZWREaW0ud2lkdGggPSBwYXJzZVVuaXQod2lkdGhBdHRyKTtcbiAgICAgIHBhcnNlZERpbS5oZWlnaHQgPSBwYXJzZVVuaXQoaGVpZ2h0QXR0cik7XG4gICAgICBzY2FsZVggPSBwYXJzZWREaW0ud2lkdGggLyB2aWV3Qm94V2lkdGg7XG4gICAgICBzY2FsZVkgPSBwYXJzZWREaW0uaGVpZ2h0IC8gdmlld0JveEhlaWdodDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBwYXJzZWREaW0ud2lkdGggPSB2aWV3Qm94V2lkdGg7XG4gICAgICBwYXJzZWREaW0uaGVpZ2h0ID0gdmlld0JveEhlaWdodDtcbiAgICB9XG5cbiAgICAvLyBkZWZhdWx0IGlzIHRvIHByZXNlcnZlIGFzcGVjdCByYXRpb1xuICAgIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBmYWJyaWMudXRpbC5wYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGUocHJlc2VydmVBc3BlY3RSYXRpbyk7XG4gICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ25YICE9PSAnbm9uZScpIHtcbiAgICAgIC8vdHJhbnNsYXRlIGFsbCBjb250YWluZXIgZm9yIHRoZSBlZmZlY3Qgb2YgTWlkLCBNaW4sIE1heFxuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8ubWVldE9yU2xpY2UgPT09ICdtZWV0Jykge1xuICAgICAgICBzY2FsZVkgPSBzY2FsZVggPSAoc2NhbGVYID4gc2NhbGVZID8gc2NhbGVZIDogc2NhbGVYKTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIGFkZGl0aW9uYWwgdHJhbnNsYXRpb24gdG8gbW92ZSB0aGUgdmlld2JveFxuICAgICAgfVxuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8ubWVldE9yU2xpY2UgPT09ICdzbGljZScpIHtcbiAgICAgICAgc2NhbGVZID0gc2NhbGVYID0gKHNjYWxlWCA+IHNjYWxlWSA/IHNjYWxlWCA6IHNjYWxlWSk7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhZGRpdGlvbmFsIHRyYW5zbGF0aW9uIHRvIG1vdmUgdGhlIHZpZXdib3hcbiAgICAgIH1cbiAgICAgIHdpZHRoRGlmZiA9IHBhcnNlZERpbS53aWR0aCAtIHZpZXdCb3hXaWR0aCAqIHNjYWxlWDtcbiAgICAgIGhlaWdodERpZmYgPSBwYXJzZWREaW0uaGVpZ2h0IC0gdmlld0JveEhlaWdodCAqIHNjYWxlWDtcbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduWCA9PT0gJ01pZCcpIHtcbiAgICAgICAgd2lkdGhEaWZmIC89IDI7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblkgPT09ICdNaWQnKSB7XG4gICAgICAgIGhlaWdodERpZmYgLz0gMjtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduWCA9PT0gJ01pbicpIHtcbiAgICAgICAgd2lkdGhEaWZmID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduWSA9PT0gJ01pbicpIHtcbiAgICAgICAgaGVpZ2h0RGlmZiA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNjYWxlWCA9PT0gMSAmJiBzY2FsZVkgPT09IDEgJiYgbWluWCA9PT0gMCAmJiBtaW5ZID09PSAwICYmIHggPT09IDAgJiYgeSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHBhcnNlZERpbTtcbiAgICB9XG4gICAgaWYgKCh4IHx8IHkpICYmIGVsZW1lbnQucGFyZW50Tm9kZS5ub2RlTmFtZSAhPT0gJyNkb2N1bWVudCcpIHtcbiAgICAgIHRyYW5zbGF0ZU1hdHJpeCA9ICcgdHJhbnNsYXRlKCcgKyBwYXJzZVVuaXQoeCkgKyAnICcgKyBwYXJzZVVuaXQoeSkgKyAnKSAnO1xuICAgIH1cblxuICAgIG1hdHJpeCA9IHRyYW5zbGF0ZU1hdHJpeCArICcgbWF0cml4KCcgKyBzY2FsZVggK1xuICAgICAgICAgICAgICAgICAgJyAwJyArXG4gICAgICAgICAgICAgICAgICAnIDAgJyArXG4gICAgICAgICAgICAgICAgICBzY2FsZVkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgKG1pblggKiBzY2FsZVggKyB3aWR0aERpZmYpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIChtaW5ZICogc2NhbGVZICsgaGVpZ2h0RGlmZikgKyAnKSAnO1xuICAgIC8vIHNlZW1zIHVudXNlZC5cbiAgICAvLyBwYXJzZWREaW0udmlld2JveFRyYW5zZm9ybSA9IGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZShtYXRyaXgpO1xuICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnc3ZnJykge1xuICAgICAgZWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGZhYnJpYy5zdmdOUywgJ2cnKTtcbiAgICAgIC8vIGVsZW1lbnQuZmlyc3RDaGlsZCAhPSBudWxsXG4gICAgICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBlbCA9IGVsZW1lbnQ7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3gnKTtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgneScpO1xuICAgICAgbWF0cml4ID0gZWwuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSArIG1hdHJpeDtcbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBtYXRyaXgpO1xuICAgIHJldHVybiBwYXJzZWREaW07XG4gIH1cblxuICBmdW5jdGlvbiBoYXNBbmNlc3RvcldpdGhOb2RlTmFtZShlbGVtZW50LCBub2RlTmFtZSkge1xuICAgIHdoaWxlIChlbGVtZW50ICYmIChlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlKSkge1xuICAgICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgJiYgbm9kZU5hbWUudGVzdChlbGVtZW50Lm5vZGVOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpXG4gICAgICAgICYmICFlbGVtZW50LmdldEF0dHJpYnV0ZSgnaW5zdGFudGlhdGVkX2J5X3VzZScpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIFNWRyBkb2N1bWVudCwgY29udmVydHMgaXQgdG8gYW4gYXJyYXkgb2YgY29ycmVzcG9uZGluZyBmYWJyaWMuKiBpbnN0YW5jZXMgYW5kIHBhc3NlcyB0aGVtIHRvIGEgY2FsbGJhY2tcbiAgICogQHN0YXRpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAcGFyYW0ge1NWR0RvY3VtZW50fSBkb2MgU1ZHIGRvY3VtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGNhbGwgd2hlbiBwYXJzaW5nIGlzIGZpbmlzaGVkO1xuICAgKiBJdCdzIGJlaW5nIHBhc3NlZCBhbiBhcnJheSBvZiBlbGVtZW50cyAocGFyc2VkIGZyb20gYSBkb2N1bWVudCkuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBTVkcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJzaW5nT3B0aW9uc10gb3B0aW9ucyBmb3IgcGFyc2luZyBkb2N1bWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcnNpbmdPcHRpb25zLmNyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiBzZXR0aW5nc1xuICAgKi9cbiAgZmFicmljLnBhcnNlU1ZHRG9jdW1lbnQgPSBmdW5jdGlvbihkb2MsIGNhbGxiYWNrLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucykge1xuICAgIGlmICghZG9jKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGFyc2VVc2VEaXJlY3RpdmVzKGRvYyk7XG5cbiAgICB2YXIgc3ZnVWlkID0gIGZhYnJpYy5PYmplY3QuX191aWQrKywgaSwgbGVuLFxuICAgICAgICBvcHRpb25zID0gYXBwbHlWaWV3Ym94VHJhbnNmb3JtKGRvYyksXG4gICAgICAgIGRlc2NlbmRhbnRzID0gZmFicmljLnV0aWwudG9BcnJheShkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSk7XG4gICAgb3B0aW9ucy5jcm9zc09yaWdpbiA9IHBhcnNpbmdPcHRpb25zICYmIHBhcnNpbmdPcHRpb25zLmNyb3NzT3JpZ2luO1xuICAgIG9wdGlvbnMuc3ZnVWlkID0gc3ZnVWlkO1xuXG4gICAgaWYgKGRlc2NlbmRhbnRzLmxlbmd0aCA9PT0gMCAmJiBmYWJyaWMuaXNMaWtlbHlOb2RlKSB7XG4gICAgICAvLyB3ZSdyZSBsaWtlbHkgaW4gbm9kZSwgd2hlcmUgXCJvMy14bWxcIiBsaWJyYXJ5IGZhaWxzIHRvIGdFQlROKFwiKlwiKVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FqYXhvcmcvbm9kZS1vMy14bWwvaXNzdWVzLzIxXG4gICAgICBkZXNjZW5kYW50cyA9IGRvYy5zZWxlY3ROb2RlcygnLy8qW25hbWUoLikhPVwic3ZnXCJdJyk7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkZXNjZW5kYW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBkZXNjZW5kYW50c1tpXTtcbiAgICAgIH1cbiAgICAgIGRlc2NlbmRhbnRzID0gYXJyO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50cyA9IGRlc2NlbmRhbnRzLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgYXBwbHlWaWV3Ym94VHJhbnNmb3JtKGVsKTtcbiAgICAgIHJldHVybiBmYWJyaWMuc3ZnVmFsaWRUYWdOYW1lc1JlZ0V4LnRlc3QoZWwubm9kZU5hbWUucmVwbGFjZSgnc3ZnOicsICcnKSkgJiZcbiAgICAgICAgICAgICFoYXNBbmNlc3RvcldpdGhOb2RlTmFtZShlbCwgZmFicmljLnN2Z0ludmFsaWRBbmNlc3RvcnNSZWdFeCk7IC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHJ1Y3QuaHRtbCNEZWZzRWxlbWVudFxuICAgIH0pO1xuICAgIGlmICghZWxlbWVudHMgfHwgKGVsZW1lbnRzICYmICFlbGVtZW50cy5sZW5ndGgpKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhbXSwge30pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2xpcFBhdGhzID0geyB9O1xuICAgIGRlc2NlbmRhbnRzLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIGVsLm5vZGVOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykgPT09ICdjbGlwUGF0aCc7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgdmFyIGlkID0gZWwuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgY2xpcFBhdGhzW2lkXSA9IGZhYnJpYy51dGlsLnRvQXJyYXkoZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSkuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMuc3ZnVmFsaWRUYWdOYW1lc1JlZ0V4LnRlc3QoZWwubm9kZU5hbWUucmVwbGFjZSgnc3ZnOicsICcnKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBmYWJyaWMuZ3JhZGllbnREZWZzW3N2Z1VpZF0gPSBmYWJyaWMuZ2V0R3JhZGllbnREZWZzKGRvYyk7XG4gICAgZmFicmljLmNzc1J1bGVzW3N2Z1VpZF0gPSBmYWJyaWMuZ2V0Q1NTUnVsZXMoZG9jKTtcbiAgICBmYWJyaWMuY2xpcFBhdGhzW3N2Z1VpZF0gPSBjbGlwUGF0aHM7XG4gICAgLy8gUHJlY2VkZW5jZSBvZiBydWxlczogICBzdHlsZSA+IGNsYXNzID4gYXR0cmlidXRlXG4gICAgZmFicmljLnBhcnNlRWxlbWVudHMoZWxlbWVudHMsIGZ1bmN0aW9uKGluc3RhbmNlcywgZWxlbWVudHMpIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhpbnN0YW5jZXMsIG9wdGlvbnMsIGVsZW1lbnRzLCBkZXNjZW5kYW50cyk7XG4gICAgICAgIGRlbGV0ZSBmYWJyaWMuZ3JhZGllbnREZWZzW3N2Z1VpZF07XG4gICAgICAgIGRlbGV0ZSBmYWJyaWMuY3NzUnVsZXNbc3ZnVWlkXTtcbiAgICAgICAgZGVsZXRlIGZhYnJpYy5jbGlwUGF0aHNbc3ZnVWlkXTtcbiAgICAgIH1cbiAgICB9LCBjbG9uZShvcHRpb25zKSwgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5UGFyc2VHcmFkaWVudHNYbGluayhkb2MsIGdyYWRpZW50KSB7XG4gICAgdmFyIGdyYWRpZW50c0F0dHJzID0gWydncmFkaWVudFRyYW5zZm9ybScsICd4MScsICd4MicsICd5MScsICd5MicsICdncmFkaWVudFVuaXRzJywgJ2N4JywgJ2N5JywgJ3InLCAnZngnLCAnZnknXSxcbiAgICAgICAgeGxpbmtBdHRyID0gJ3hsaW5rOmhyZWYnLFxuICAgICAgICB4TGluayA9IGdyYWRpZW50LmdldEF0dHJpYnV0ZSh4bGlua0F0dHIpLnNsaWNlKDEpLFxuICAgICAgICByZWZlcmVuY2VkR3JhZGllbnQgPSBlbGVtZW50QnlJZChkb2MsIHhMaW5rKTtcbiAgICBpZiAocmVmZXJlbmNlZEdyYWRpZW50ICYmIHJlZmVyZW5jZWRHcmFkaWVudC5nZXRBdHRyaWJ1dGUoeGxpbmtBdHRyKSkge1xuICAgICAgcmVjdXJzaXZlbHlQYXJzZUdyYWRpZW50c1hsaW5rKGRvYywgcmVmZXJlbmNlZEdyYWRpZW50KTtcbiAgICB9XG4gICAgZ3JhZGllbnRzQXR0cnMuZm9yRWFjaChmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAocmVmZXJlbmNlZEdyYWRpZW50ICYmICFncmFkaWVudC5oYXNBdHRyaWJ1dGUoYXR0cikgJiYgcmVmZXJlbmNlZEdyYWRpZW50Lmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGUoYXR0ciwgcmVmZXJlbmNlZEdyYWRpZW50LmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFncmFkaWVudC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHZhciByZWZlcmVuY2VDbG9uZSA9IHJlZmVyZW5jZWRHcmFkaWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB3aGlsZSAocmVmZXJlbmNlQ2xvbmUuZmlyc3RDaGlsZCkge1xuICAgICAgICBncmFkaWVudC5hcHBlbmRDaGlsZChyZWZlcmVuY2VDbG9uZS5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ3JhZGllbnQucmVtb3ZlQXR0cmlidXRlKHhsaW5rQXR0cik7XG4gIH1cblxuICB2YXIgcmVGb250RGVjbGFyYXRpb24gPSBuZXcgUmVnRXhwKFxuICAgICcobm9ybWFsfGl0YWxpYyk/XFxcXHMqKG5vcm1hbHxzbWFsbC1jYXBzKT9cXFxccyonICtcbiAgICAnKG5vcm1hbHxib2xkfGJvbGRlcnxsaWdodGVyfDEwMHwyMDB8MzAwfDQwMHw1MDB8NjAwfDcwMHw4MDB8OTAwKT9cXFxccyooJyArXG4gICAgICBmYWJyaWMucmVOdW0gK1xuICAgICcoPzpweHxjbXxtbXxlbXxwdHxwY3xpbikqKSg/OlxcXFwvKG5vcm1hbHwnICsgZmFicmljLnJlTnVtICsgJykpP1xcXFxzKyguKiknKTtcblxuICBleHRlbmQoZmFicmljLCB7XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc2hvcnQgZm9udCBkZWNsYXJhdGlvbiwgYnVpbGRpbmcgYWRkaW5nIGl0cyBwcm9wZXJ0aWVzIHRvIGEgc3R5bGUgb2JqZWN0XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgZm9udCBkZWNsYXJhdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvU3R5bGUgZGVmaW5pdGlvblxuICAgICAqL1xuICAgIHBhcnNlRm9udERlY2xhcmF0aW9uOiBmdW5jdGlvbih2YWx1ZSwgb1N0eWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaChyZUZvbnREZWNsYXJhdGlvbik7XG5cbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGZvbnRTdHlsZSA9IG1hdGNoWzFdLFxuICAgICAgICAgIC8vIGZvbnQgdmFyaWFudCBpcyBub3QgdXNlZFxuICAgICAgICAgIC8vIGZvbnRWYXJpYW50ID0gbWF0Y2hbMl0sXG4gICAgICAgICAgZm9udFdlaWdodCA9IG1hdGNoWzNdLFxuICAgICAgICAgIGZvbnRTaXplID0gbWF0Y2hbNF0sXG4gICAgICAgICAgbGluZUhlaWdodCA9IG1hdGNoWzVdLFxuICAgICAgICAgIGZvbnRGYW1pbHkgPSBtYXRjaFs2XTtcblxuICAgICAgaWYgKGZvbnRTdHlsZSkge1xuICAgICAgICBvU3R5bGUuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRXZWlnaHQpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRXZWlnaHQgPSBpc05hTihwYXJzZUZsb2F0KGZvbnRXZWlnaHQpKSA/IGZvbnRXZWlnaHQgOiBwYXJzZUZsb2F0KGZvbnRXZWlnaHQpO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRTaXplKSB7XG4gICAgICAgIG9TdHlsZS5mb250U2l6ZSA9IHBhcnNlVW5pdChmb250U2l6ZSk7XG4gICAgICB9XG4gICAgICBpZiAoZm9udEZhbWlseSkge1xuICAgICAgICBvU3R5bGUuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICB9XG4gICAgICBpZiAobGluZUhlaWdodCkge1xuICAgICAgICBvU3R5bGUubGluZUhlaWdodCA9IGxpbmVIZWlnaHQgPT09ICdub3JtYWwnID8gMSA6IGxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhbiBTVkcgZG9jdW1lbnQsIHJldHVybmluZyBhbGwgb2YgdGhlIGdyYWRpZW50IGRlY2xhcmF0aW9ucyBmb3VuZCBpbiBpdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gR3JhZGllbnQgZGVmaW5pdGlvbnM7IGtleSBjb3JyZXNwb25kcyB0byBlbGVtZW50IGlkLCB2YWx1ZSAtLSB0byBncmFkaWVudCBkZWZpbml0aW9uIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRHcmFkaWVudERlZnM6IGZ1bmN0aW9uKGRvYykge1xuICAgICAgdmFyIHRhZ0FycmF5ID0gW1xuICAgICAgICAgICAgJ2xpbmVhckdyYWRpZW50JyxcbiAgICAgICAgICAgICdyYWRpYWxHcmFkaWVudCcsXG4gICAgICAgICAgICAnc3ZnOmxpbmVhckdyYWRpZW50JyxcbiAgICAgICAgICAgICdzdmc6cmFkaWFsR3JhZGllbnQnXSxcbiAgICAgICAgICBlbExpc3QgPSBfZ2V0TXVsdGlwbGVOb2Rlcyhkb2MsIHRhZ0FycmF5KSxcbiAgICAgICAgICBlbCwgaiA9IDAsIGdyYWRpZW50RGVmcyA9IHsgfTtcbiAgICAgIGogPSBlbExpc3QubGVuZ3RoO1xuICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICBlbCA9IGVsTGlzdFtqXTtcbiAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpKSB7XG4gICAgICAgICAgcmVjdXJzaXZlbHlQYXJzZUdyYWRpZW50c1hsaW5rKGRvYywgZWwpO1xuICAgICAgICB9XG4gICAgICAgIGdyYWRpZW50RGVmc1tlbC5nZXRBdHRyaWJ1dGUoJ2lkJyldID0gZWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JhZGllbnREZWZzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzJyBuYW1lL3ZhbHVlLCBnaXZlbiBlbGVtZW50IGFuZCBhbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXM7XG4gICAgICogUGFyc2VzIHBhcmVudCBcImdcIiBub2RlcyByZWN1cnNpdmVseSB1cHdhcmRzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhdHRyaWJ1dGVzIEFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHBhcnNlZCBhdHRyaWJ1dGVzJyBuYW1lcy92YWx1ZXNcbiAgICAgKi9cbiAgICBwYXJzZUF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJpYnV0ZXMsIHN2Z1VpZCkge1xuXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUsXG4gICAgICAgICAgcGFyZW50QXR0cmlidXRlcyA9IHsgfSxcbiAgICAgICAgICBmb250U2l6ZSwgcGFyZW50Rm9udFNpemU7XG5cbiAgICAgIGlmICh0eXBlb2Ygc3ZnVWlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzdmdVaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3ZnVWlkJyk7XG4gICAgICB9XG4gICAgICAvLyBpZiB0aGVyZSdzIGEgcGFyZW50IGNvbnRhaW5lciAoYGdgIG9yIGBhYCBvciBgc3ltYm9sYCBub2RlKSwgcGFyc2UgaXRzIGF0dHJpYnV0ZXMgcmVjdXJzaXZlbHkgdXB3YXJkc1xuICAgICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSAmJiBmYWJyaWMuc3ZnVmFsaWRQYXJlbnRzUmVnRXgudGVzdChlbGVtZW50LnBhcmVudE5vZGUubm9kZU5hbWUpKSB7XG4gICAgICAgIHBhcmVudEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQucGFyZW50Tm9kZSwgYXR0cmlidXRlcywgc3ZnVWlkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG93bkF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLnJlZHVjZShmdW5jdGlvbihtZW1vLCBhdHRyKSB7XG4gICAgICAgIHZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIGlmICh2YWx1ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgbWVtb1thdHRyXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgfSwgeyB9KTtcbiAgICAgIC8vIGFkZCB2YWx1ZXMgcGFyc2VkIGZyb20gc3R5bGUsIHdoaWNoIHRha2UgcHJlY2VkZW5jZSBvdmVyIGF0dHJpYnV0ZXNcbiAgICAgIC8vIChzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHlsaW5nLmh0bWwjVXNpbmdQcmVzZW50YXRpb25BdHRyaWJ1dGVzKVxuICAgICAgdmFyIGNzc0F0dHJzID0gZXh0ZW5kKFxuICAgICAgICBnZXRHbG9iYWxTdHlsZXNGb3JFbGVtZW50KGVsZW1lbnQsIHN2Z1VpZCksXG4gICAgICAgIGZhYnJpYy5wYXJzZVN0eWxlQXR0cmlidXRlKGVsZW1lbnQpXG4gICAgICApO1xuICAgICAgb3duQXR0cmlidXRlcyA9IGV4dGVuZChcbiAgICAgICAgb3duQXR0cmlidXRlcyxcbiAgICAgICAgY3NzQXR0cnNcbiAgICAgICk7XG4gICAgICBpZiAoY3NzQXR0cnNbY1BhdGhdKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGNQYXRoLCBjc3NBdHRyc1tjUGF0aF0pO1xuICAgICAgfVxuICAgICAgZm9udFNpemUgPSBwYXJlbnRGb250U2l6ZSA9IHBhcmVudEF0dHJpYnV0ZXMuZm9udFNpemUgfHwgZmFicmljLlRleHQuREVGQVVMVF9TVkdfRk9OVF9TSVpFO1xuICAgICAgaWYgKG93bkF0dHJpYnV0ZXNbZlNpemVdKSB7XG4gICAgICAgIC8vIGxvb2tzIGxpa2UgdGhlIG1pbmltdW0gc2hvdWxkIGJlIDlweCB3aGVuIGRlYWxpbmcgd2l0aCBlbXMuIHRoaXMgaXMgd2hhdCBsb29rcyBsaWtlIGluIGJyb3dzZXJzLlxuICAgICAgICBvd25BdHRyaWJ1dGVzW2ZTaXplXSA9IGZvbnRTaXplID0gcGFyc2VVbml0KG93bkF0dHJpYnV0ZXNbZlNpemVdLCBwYXJlbnRGb250U2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBub3JtYWxpemVkQXR0ciwgbm9ybWFsaXplZFZhbHVlLCBub3JtYWxpemVkU3R5bGUgPSB7fTtcbiAgICAgIGZvciAodmFyIGF0dHIgaW4gb3duQXR0cmlidXRlcykge1xuICAgICAgICBub3JtYWxpemVkQXR0ciA9IG5vcm1hbGl6ZUF0dHIoYXR0cik7XG4gICAgICAgIG5vcm1hbGl6ZWRWYWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKG5vcm1hbGl6ZWRBdHRyLCBvd25BdHRyaWJ1dGVzW2F0dHJdLCBwYXJlbnRBdHRyaWJ1dGVzLCBmb250U2l6ZSk7XG4gICAgICAgIG5vcm1hbGl6ZWRTdHlsZVtub3JtYWxpemVkQXR0cl0gPSBub3JtYWxpemVkVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAobm9ybWFsaXplZFN0eWxlICYmIG5vcm1hbGl6ZWRTdHlsZS5mb250KSB7XG4gICAgICAgIGZhYnJpYy5wYXJzZUZvbnREZWNsYXJhdGlvbihub3JtYWxpemVkU3R5bGUuZm9udCwgbm9ybWFsaXplZFN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZXJnZWRBdHRycyA9IGV4dGVuZChwYXJlbnRBdHRyaWJ1dGVzLCBub3JtYWxpemVkU3R5bGUpO1xuICAgICAgcmV0dXJuIGZhYnJpYy5zdmdWYWxpZFBhcmVudHNSZWdFeC50ZXN0KGVsZW1lbnQubm9kZU5hbWUpID8gbWVyZ2VkQXR0cnMgOiBfc2V0U3Ryb2tlRmlsbE9wYWNpdHkobWVyZ2VkQXR0cnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGFuIGFycmF5IG9mIHN2ZyBlbGVtZW50cyB0byBjb3JyZXNwb25kaW5nIGZhYnJpYy4qIGluc3RhbmNlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtBcnJheX0gZWxlbWVudHMgQXJyYXkgb2YgZWxlbWVudHMgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBCZWluZyBwYXNzZWQgYW4gYXJyYXkgb2YgZmFicmljIGluc3RhbmNlcyAodHJhbnNmb3JtZWQgZnJvbSBTVkcgZWxlbWVudHMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBTVkcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBwYXJzZUVsZW1lbnRzOiBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2ssIG9wdGlvbnMsIHJldml2ZXIsIHBhcnNpbmdPcHRpb25zKSB7XG4gICAgICBuZXcgZmFicmljLkVsZW1lbnRzUGFyc2VyKGVsZW1lbnRzLCBjYWxsYmFjaywgb3B0aW9ucywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMpLnBhcnNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBcInN0eWxlXCIgYXR0cmlidXRlLCByZXR1bmluZyBhbiBvYmplY3Qgd2l0aCB2YWx1ZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3RzIHdpdGggdmFsdWVzIHBhcnNlZCBmcm9tIHN0eWxlIGF0dHJpYnV0ZSBvZiBhbiBlbGVtZW50XG4gICAgICovXG4gICAgcGFyc2VTdHlsZUF0dHJpYnV0ZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgdmFyIG9TdHlsZSA9IHsgfSxcbiAgICAgICAgICBzdHlsZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgIHJldHVybiBvU3R5bGU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcnNlU3R5bGVTdHJpbmcoc3R5bGUsIG9TdHlsZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcGFyc2VTdHlsZU9iamVjdChzdHlsZSwgb1N0eWxlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9TdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIFwicG9pbnRzXCIgYXR0cmlidXRlLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdmFsdWVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcG9pbnRzIHBvaW50cyBhdHRyaWJ1dGUgc3RyaW5nXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIHBvaW50c1xuICAgICAqL1xuICAgIHBhcnNlUG9pbnRzQXR0cmlidXRlOiBmdW5jdGlvbihwb2ludHMpIHtcblxuICAgICAgLy8gcG9pbnRzIGF0dHJpYnV0ZSBpcyByZXF1aXJlZCBhbmQgbXVzdCBub3QgYmUgZW1wdHlcbiAgICAgIGlmICghcG9pbnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyByZXBsYWNlIGNvbW1hcyB3aXRoIHdoaXRlc3BhY2UgYW5kIHJlbW92ZSBib29rZW5kaW5nIHdoaXRlc3BhY2VcbiAgICAgIHBvaW50cyA9IHBvaW50cy5yZXBsYWNlKC8sL2csICcgJykudHJpbSgpO1xuXG4gICAgICBwb2ludHMgPSBwb2ludHMuc3BsaXQoL1xccysvKTtcbiAgICAgIHZhciBwYXJzZWRQb2ludHMgPSBbXSwgaSwgbGVuO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgcGFyc2VkUG9pbnRzLnB1c2goe1xuICAgICAgICAgIHg6IHBhcnNlRmxvYXQocG9pbnRzW2ldKSxcbiAgICAgICAgICB5OiBwYXJzZUZsb2F0KHBvaW50c1tpICsgMV0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBvZGQgbnVtYmVyIG9mIHBvaW50cyBpcyBhbiBlcnJvclxuICAgICAgLy8gaWYgKHBhcnNlZFBvaW50cy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAvLyAgIHJldHVybiBudWxsO1xuICAgICAgLy8gfVxuXG4gICAgICByZXR1cm4gcGFyc2VkUG9pbnRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIENTUyBydWxlcyBmb3IgYSBnaXZlbiBTVkcgZG9jdW1lbnRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U1ZHRG9jdW1lbnR9IGRvYyBTVkcgZG9jdW1lbnQgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IENTUyBydWxlcyBvZiB0aGlzIGRvY3VtZW50XG4gICAgICovXG4gICAgZ2V0Q1NTUnVsZXM6IGZ1bmN0aW9uKGRvYykge1xuICAgICAgdmFyIHN0eWxlcyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3R5bGUnKSwgaSwgbGVuLFxuICAgICAgICAgIGFsbFJ1bGVzID0geyB9LCBydWxlcztcblxuICAgICAgLy8gdmVyeSBjcnVkZSBwYXJzaW5nIG9mIHN0eWxlIGNvbnRlbnRzXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdHlsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHN0eWxlQ29udGVudHMgPSBzdHlsZXNbaV0udGV4dENvbnRlbnQ7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGNvbW1lbnRzXG4gICAgICAgIHN0eWxlQ29udGVudHMgPSBzdHlsZUNvbnRlbnRzLnJlcGxhY2UoL1xcL1xcKltcXHNcXFNdKj9cXCpcXC8vZywgJycpO1xuICAgICAgICBpZiAoc3R5bGVDb250ZW50cy50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjb3ZlcnMgYWxsIHRoZSBydWxlIGluIHRoaXMgZm9ybSBgYm9keSB7IHN0eWxlIGNvZGUuLi4gfWBcbiAgICAgICAgLy8gcnVsZXMgPSBzdHlsZUNvbnRlbnRzLm1hdGNoKC9bXntdKlxce1tcXHNcXFNdKj9cXH0vZyk7XG4gICAgICAgIHJ1bGVzID0gc3R5bGVDb250ZW50cy5zcGxpdCgnfScpO1xuICAgICAgICAvLyByZW1vdmUgZW1wdHkgcnVsZXMuXG4gICAgICAgIHJ1bGVzID0gcnVsZXMuZmlsdGVyKGZ1bmN0aW9uKHJ1bGUpIHsgcmV0dXJuIHJ1bGUudHJpbSgpOyB9KTtcbiAgICAgICAgLy8gYXQgdGhpcyBwb2ludCB3ZSBoYXZlIGhvcGVmdWxseSBhbiBhcnJheSBvZiBydWxlcyBgYm9keSB7IHN0eWxlIGNvZGUuLi4gYFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgIHJ1bGVzLmZvckVhY2goZnVuY3Rpb24ocnVsZSkge1xuXG4gICAgICAgICAgdmFyIG1hdGNoID0gcnVsZS5zcGxpdCgneycpLFxuICAgICAgICAgICAgICBydWxlT2JqID0geyB9LCBkZWNsYXJhdGlvbiA9IG1hdGNoWzFdLnRyaW0oKSxcbiAgICAgICAgICAgICAgcHJvcGVydHlWYWx1ZVBhaXJzID0gZGVjbGFyYXRpb24uc3BsaXQoJzsnKS5maWx0ZXIoZnVuY3Rpb24ocGFpcikgeyByZXR1cm4gcGFpci50cmltKCk7IH0pO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcHJvcGVydHlWYWx1ZVBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFpciA9IHByb3BlcnR5VmFsdWVQYWlyc1tpXS5zcGxpdCgnOicpLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFpclswXS50cmltKCksXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYWlyWzFdLnRyaW0oKTtcbiAgICAgICAgICAgIHJ1bGVPYmpbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJ1bGUgPSBtYXRjaFswXS50cmltKCk7XG4gICAgICAgICAgcnVsZS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24oX3J1bGUpIHtcbiAgICAgICAgICAgIF9ydWxlID0gX3J1bGUucmVwbGFjZSgvXnN2Zy9pLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgaWYgKF9ydWxlID09PSAnJykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsUnVsZXNbX3J1bGVdKSB7XG4gICAgICAgICAgICAgIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoYWxsUnVsZXNbX3J1bGVdLCBydWxlT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBhbGxSdWxlc1tfcnVsZV0gPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUocnVsZU9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbFJ1bGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyB1cmwgY29ycmVzcG9uZGluZyB0byBhbiBTVkcgZG9jdW1lbnQsIGFuZCBwYXJzZXMgaXQgaW50byBhIHNldCBvZiBmYWJyaWMgb2JqZWN0cy5cbiAgICAgKiBOb3RlIHRoYXQgU1ZHIGlzIGZldGNoZWQgdmlhIFhNTEh0dHBSZXF1ZXN0LCBzbyBpdCBuZWVkcyB0byBjb25mb3JtIHRvIFNPUCAoU2FtZSBPcmlnaW4gUG9saWN5KVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3QgY29udGFpbmluZyBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiBjcm9zc09yaWdpbiBzZXR0aW5nIHRvIHVzZSBmb3IgZXh0ZXJuYWwgcmVzb3VyY2VzXG4gICAgICovXG4gICAgbG9hZFNWR0Zyb21VUkw6IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIHJldml2ZXIsIG9wdGlvbnMpIHtcblxuICAgICAgdXJsID0gdXJsLnJlcGxhY2UoL15cXG5cXHMqLywgJycpLnRyaW0oKTtcbiAgICAgIG5ldyBmYWJyaWMudXRpbC5yZXF1ZXN0KHVybCwge1xuICAgICAgICBtZXRob2Q6ICdnZXQnLFxuICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlXG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gb25Db21wbGV0ZShyKSB7XG5cbiAgICAgICAgdmFyIHhtbCA9IHIucmVzcG9uc2VYTUw7XG4gICAgICAgIGlmICgheG1sIHx8ICF4bWwuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZmFicmljLnBhcnNlU1ZHRG9jdW1lbnQoeG1sLmRvY3VtZW50RWxlbWVudCwgZnVuY3Rpb24gKHJlc3VsdHMsIF9vcHRpb25zLCBlbGVtZW50cywgYWxsRWxlbWVudHMpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXN1bHRzLCBfb3B0aW9ucywgZWxlbWVudHMsIGFsbEVsZW1lbnRzKTtcbiAgICAgICAgfSwgcmV2aXZlciwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRha2VzIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIGFuIFNWRyBkb2N1bWVudCwgYW5kIHBhcnNlcyBpdCBpbnRvIGEgc2V0IG9mIGZhYnJpYyBvYmplY3RzXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBTVkcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgZm9yIHBhcnNpbmdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY3Jvc3NPcmlnaW5dIGNyb3NzT3JpZ2luIGNyb3NzT3JpZ2luIHNldHRpbmcgdG8gdXNlIGZvciBleHRlcm5hbCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBsb2FkU1ZHRnJvbVN0cmluZzogZnVuY3Rpb24oc3RyaW5nLCBjYWxsYmFjaywgcmV2aXZlciwgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBmYWJyaWMud2luZG93LkRPTVBhcnNlcigpLFxuICAgICAgICAgIGRvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3RyaW5nLnRyaW0oKSwgJ3RleHQveG1sJyk7XG4gICAgICBmYWJyaWMucGFyc2VTVkdEb2N1bWVudChkb2MuZG9jdW1lbnRFbGVtZW50LCBmdW5jdGlvbiAocmVzdWx0cywgX29wdGlvbnMsIGVsZW1lbnRzLCBhbGxFbGVtZW50cykge1xuICAgICAgICBjYWxsYmFjayhyZXN1bHRzLCBfb3B0aW9ucywgZWxlbWVudHMsIGFsbEVsZW1lbnRzKTtcbiAgICAgIH0sIHJldml2ZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG5mYWJyaWMuRWxlbWVudHNQYXJzZXIgPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2ssIG9wdGlvbnMsIHJldml2ZXIsIHBhcnNpbmdPcHRpb25zLCBkb2MpIHtcbiAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMucmV2aXZlciA9IHJldml2ZXI7XG4gIHRoaXMuc3ZnVWlkID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zdmdVaWQpIHx8IDA7XG4gIHRoaXMucGFyc2luZ09wdGlvbnMgPSBwYXJzaW5nT3B0aW9ucztcbiAgdGhpcy5yZWdleFVybCA9IC9edXJsXFwoWydcIl0/IyhbXidcIl0rKVsnXCJdP1xcKS9nO1xuICB0aGlzLmRvYyA9IGRvYztcbn07XG5cbihmdW5jdGlvbihwcm90bykge1xuICBwcm90by5wYXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5zdGFuY2VzID0gbmV3IEFycmF5KHRoaXMuZWxlbWVudHMubGVuZ3RoKTtcbiAgICB0aGlzLm51bUVsZW1lbnRzID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG4gICAgdGhpcy5jcmVhdGVPYmplY3RzKCk7XG4gIH07XG5cbiAgcHJvdG8uY3JlYXRlT2JqZWN0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGkpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdmdVaWQnLCBfdGhpcy5zdmdVaWQpO1xuICAgICAgX3RoaXMuY3JlYXRlT2JqZWN0KGVsZW1lbnQsIGkpO1xuICAgIH0pO1xuICB9O1xuXG4gIHByb3RvLmZpbmRUYWcgPSBmdW5jdGlvbihlbCkge1xuICAgIHJldHVybiBmYWJyaWNbZmFicmljLnV0aWwuc3RyaW5nLmNhcGl0YWxpemUoZWwudGFnTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpKV07XG4gIH07XG5cbiAgcHJvdG8uY3JlYXRlT2JqZWN0ID0gZnVuY3Rpb24oZWwsIGluZGV4KSB7XG4gICAgdmFyIGtsYXNzID0gdGhpcy5maW5kVGFnKGVsKTtcbiAgICBpZiAoa2xhc3MgJiYga2xhc3MuZnJvbUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGtsYXNzLmZyb21FbGVtZW50KGVsLCB0aGlzLmNyZWF0ZUNhbGxiYWNrKGluZGV4LCBlbCksIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGZhYnJpYy5sb2coZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNoZWNrSWZEb25lKCk7XG4gICAgfVxuICB9O1xuXG4gIHByb3RvLmNyZWF0ZUNhbGxiYWNrID0gZnVuY3Rpb24oaW5kZXgsIGVsKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgX29wdGlvbnM7XG4gICAgICBfdGhpcy5yZXNvbHZlR3JhZGllbnQob2JqLCBlbCwgJ2ZpbGwnKTtcbiAgICAgIF90aGlzLnJlc29sdmVHcmFkaWVudChvYmosIGVsLCAnc3Ryb2tlJyk7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgZmFicmljLkltYWdlICYmIG9iai5fb3JpZ2luYWxFbGVtZW50KSB7XG4gICAgICAgIF9vcHRpb25zID0gb2JqLnBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZShlbCk7XG4gICAgICB9XG4gICAgICBvYmouX3JlbW92ZVRyYW5zZm9ybU1hdHJpeChfb3B0aW9ucyk7XG4gICAgICBfdGhpcy5yZXNvbHZlQ2xpcFBhdGgob2JqLCBlbCk7XG4gICAgICBfdGhpcy5yZXZpdmVyICYmIF90aGlzLnJldml2ZXIoZWwsIG9iaik7XG4gICAgICBfdGhpcy5pbnN0YW5jZXNbaW5kZXhdID0gb2JqO1xuICAgICAgX3RoaXMuY2hlY2tJZkRvbmUoKTtcbiAgICB9O1xuICB9O1xuXG4gIHByb3RvLmV4dHJhY3RQcm9wZXJ0eURlZmluaXRpb24gPSBmdW5jdGlvbihvYmosIHByb3BlcnR5LCBzdG9yYWdlKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqW3Byb3BlcnR5XSwgcmVnZXggPSB0aGlzLnJlZ2V4VXJsO1xuICAgIGlmICghcmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgaWQgPSByZWdleC5leGVjKHZhbHVlKVsxXTtcbiAgICByZWdleC5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBmYWJyaWNbc3RvcmFnZV1bdGhpcy5zdmdVaWRdW2lkXTtcbiAgfTtcblxuICBwcm90by5yZXNvbHZlR3JhZGllbnQgPSBmdW5jdGlvbihvYmosIGVsLCBwcm9wZXJ0eSkge1xuICAgIHZhciBncmFkaWVudERlZiA9IHRoaXMuZXh0cmFjdFByb3BlcnR5RGVmaW5pdGlvbihvYmosIHByb3BlcnR5LCAnZ3JhZGllbnREZWZzJyk7XG4gICAgaWYgKGdyYWRpZW50RGVmKSB7XG4gICAgICB2YXIgb3BhY2l0eUF0dHIgPSBlbC5nZXRBdHRyaWJ1dGUocHJvcGVydHkgKyAnLW9wYWNpdHknKTtcbiAgICAgIHZhciBncmFkaWVudCA9IGZhYnJpYy5HcmFkaWVudC5mcm9tRWxlbWVudChncmFkaWVudERlZiwgb2JqLCBvcGFjaXR5QXR0ciwgdGhpcy5vcHRpb25zKTtcbiAgICAgIG9iai5zZXQocHJvcGVydHksIGdyYWRpZW50KTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdG8uY3JlYXRlQ2xpcFBhdGhDYWxsYmFjayA9IGZ1bmN0aW9uKG9iaiwgY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF9uZXdPYmopIHtcbiAgICAgIF9uZXdPYmouX3JlbW92ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgX25ld09iai5maWxsUnVsZSA9IF9uZXdPYmouY2xpcFJ1bGU7XG4gICAgICBjb250YWluZXIucHVzaChfbmV3T2JqKTtcbiAgICB9O1xuICB9O1xuXG4gIHByb3RvLnJlc29sdmVDbGlwUGF0aCA9IGZ1bmN0aW9uKG9iaiwgdXNpbmdFbGVtZW50KSB7XG4gICAgdmFyIGNsaXBQYXRoID0gdGhpcy5leHRyYWN0UHJvcGVydHlEZWZpbml0aW9uKG9iaiwgJ2NsaXBQYXRoJywgJ2NsaXBQYXRocycpLFxuICAgICAgICBlbGVtZW50LCBrbGFzcywgb2JqVHJhbnNmb3JtSW52LCBjb250YWluZXIsIGdUcmFuc2Zvcm0sIG9wdGlvbnM7XG4gICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICBjb250YWluZXIgPSBbXTtcbiAgICAgIG9ialRyYW5zZm9ybUludiA9IGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybShvYmouY2FsY1RyYW5zZm9ybU1hdHJpeCgpKTtcbiAgICAgIC8vIG1vdmUgdGhlIGNsaXBQYXRoIHRhZyBhcyBzaWJsaW5nIHRvIHRoZSByZWFsIGVsZW1lbnQgdGhhdCBpcyB1c2luZyBpdFxuICAgICAgdmFyIGNsaXBQYXRoVGFnID0gY2xpcFBhdGhbMF0ucGFyZW50Tm9kZTtcbiAgICAgIHZhciBjbGlwUGF0aE93bmVyID0gdXNpbmdFbGVtZW50O1xuICAgICAgd2hpbGUgKGNsaXBQYXRoT3duZXIucGFyZW50Tm9kZSAmJiBjbGlwUGF0aE93bmVyLmdldEF0dHJpYnV0ZSgnY2xpcC1wYXRoJykgIT09IG9iai5jbGlwUGF0aCkge1xuICAgICAgICBjbGlwUGF0aE93bmVyID0gY2xpcFBhdGhPd25lci5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgY2xpcFBhdGhPd25lci5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGNsaXBQYXRoVGFnKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IGNsaXBQYXRoW2ldO1xuICAgICAgICBrbGFzcyA9IHRoaXMuZmluZFRhZyhlbGVtZW50KTtcbiAgICAgICAga2xhc3MuZnJvbUVsZW1lbnQoXG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICB0aGlzLmNyZWF0ZUNsaXBQYXRoQ2FsbGJhY2sob2JqLCBjb250YWluZXIpLFxuICAgICAgICAgIHRoaXMub3B0aW9uc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRhaW5lci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY2xpcFBhdGggPSBjb250YWluZXJbMF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2xpcFBhdGggPSBuZXcgZmFicmljLkdyb3VwKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgICBnVHJhbnNmb3JtID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcyhcbiAgICAgICAgb2JqVHJhbnNmb3JtSW52LFxuICAgICAgICBjbGlwUGF0aC5jYWxjVHJhbnNmb3JtTWF0cml4KClcbiAgICAgICk7XG4gICAgICBpZiAoY2xpcFBhdGguY2xpcFBhdGgpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlQ2xpcFBhdGgoY2xpcFBhdGgsIGNsaXBQYXRoT3duZXIpO1xuICAgICAgfVxuICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5xckRlY29tcG9zZShnVHJhbnNmb3JtKTtcbiAgICAgIGNsaXBQYXRoLmZsaXBYID0gZmFsc2U7XG4gICAgICBjbGlwUGF0aC5mbGlwWSA9IGZhbHNlO1xuICAgICAgY2xpcFBhdGguc2V0KCdzY2FsZVgnLCBvcHRpb25zLnNjYWxlWCk7XG4gICAgICBjbGlwUGF0aC5zZXQoJ3NjYWxlWScsIG9wdGlvbnMuc2NhbGVZKTtcbiAgICAgIGNsaXBQYXRoLmFuZ2xlID0gb3B0aW9ucy5hbmdsZTtcbiAgICAgIGNsaXBQYXRoLnNrZXdYID0gb3B0aW9ucy5za2V3WDtcbiAgICAgIGNsaXBQYXRoLnNrZXdZID0gMDtcbiAgICAgIGNsaXBQYXRoLnNldFBvc2l0aW9uQnlPcmlnaW4oeyB4OiBvcHRpb25zLnRyYW5zbGF0ZVgsIHk6IG9wdGlvbnMudHJhbnNsYXRlWSB9LCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgICAgb2JqLmNsaXBQYXRoID0gY2xpcFBhdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gaWYgY2xpcC1wYXRoIGRvZXMgbm90IHJlc29sdmUgdG8gYW55IGVsZW1lbnQsIGRlbGV0ZSB0aGUgcHJvcGVydHkuXG4gICAgICBkZWxldGUgb2JqLmNsaXBQYXRoO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5jaGVja0lmRG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICgtLXRoaXMubnVtRWxlbWVudHMgPT09IDApIHtcbiAgICAgIHRoaXMuaW5zdGFuY2VzID0gdGhpcy5pbnN0YW5jZXMuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lcS1udWxsLCBlcWVxZXFcbiAgICAgICAgcmV0dXJuIGVsICE9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5pbnN0YW5jZXMsIHRoaXMuZWxlbWVudHMpO1xuICAgIH1cbiAgfTtcbn0pKGZhYnJpYy5FbGVtZW50c1BhcnNlci5wcm90b3R5cGUpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogQWRhcHRhdGlvbiBvZiB3b3JrIG9mIEtldmluIExpbmRzZXkgKGtldmluQGtldmxpbmRldi5jb20pICovXG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuUG9pbnQpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlBvaW50IGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZhYnJpYy5Qb2ludCA9IFBvaW50O1xuXG4gIC8qKlxuICAgKiBQb2ludCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBvaW50XG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgKi9cbiAgZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIFBvaW50LnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLlBvaW50LnByb3RvdHlwZSAqLyB7XG5cbiAgICB0eXBlOiAncG9pbnQnLFxuXG4gICAgY29uc3RydWN0b3I6IFBvaW50LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbm90aGVyIHBvaW50IHRvIHRoaXMgb25lIGFuZCByZXR1cm5zIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IG5ldyBQb2ludCBpbnN0YW5jZSB3aXRoIGFkZGVkIHZhbHVlc1xuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgdGhhdC54LCB0aGlzLnkgKyB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFub3RoZXIgcG9pbnQgdG8gdGhpcyBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhZGRFcXVhbHM6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB0aGlzLnggKz0gdGhhdC54O1xuICAgICAgdGhpcy55ICs9IHRoYXQueTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHZhbHVlIHRvIHRoaXMgcG9pbnQgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gbmV3IFBvaW50IHdpdGggYWRkZWQgdmFsdWVcbiAgICAgKi9cbiAgICBzY2FsYXJBZGQ6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgc2NhbGFyLCB0aGlzLnkgKyBzY2FsYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHZhbHVlIHRvIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxhckFkZEVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54ICs9IHNjYWxhcjtcbiAgICAgIHRoaXMueSArPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIGFub3RoZXIgcG9pbnQgZnJvbSB0aGlzIHBvaW50IGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBuZXcgUG9pbnQgb2JqZWN0IHdpdGggc3VidHJhY3RlZCB2YWx1ZXNcbiAgICAgKi9cbiAgICBzdWJ0cmFjdDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gdGhhdC54LCB0aGlzLnkgLSB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgYW5vdGhlciBwb2ludCBmcm9tIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzdWJ0cmFjdEVxdWFsczogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHRoaXMueCAtPSB0aGF0Lng7XG4gICAgICB0aGlzLnkgLT0gdGhhdC55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB2YWx1ZSBmcm9tIHRoaXMgcG9pbnQgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBzY2FsYXJTdWJ0cmFjdDogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSBzY2FsYXIsIHRoaXMueSAtIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyB2YWx1ZSBmcm9tIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxhclN1YnRyYWN0RXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggLT0gc2NhbGFyO1xuICAgICAgdGhpcy55IC09IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHRoaXMgcG9pbnQgYnkgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyTXVsdGlwbHkgaW4gMi4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtdWx0aXBseTogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBzY2FsYXIsIHRoaXMueSAqIHNjYWxhcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhck11bHRpcGx5RXF1YWxzIGluIDIuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgbXVsdGlwbHlFcXVhbHM6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHRoaXMueCAqPSBzY2FsYXI7XG4gICAgICB0aGlzLnkgKj0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERpdmlkZXMgdGhpcyBwb2ludCBieSBhIHZhbHVlIGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIFRPRE86IHJlbmFtZSBpbiBzY2FsYXJEaXZpZGUgaW4gMi4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBkaXZpZGU6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gc2NhbGFyLCB0aGlzLnkgLyBzY2FsYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIHRoaXMgcG9pbnQgYnkgYSB2YWx1ZVxuICAgICAqIFRPRE86IHJlbmFtZSBpbiBzY2FsYXJEaXZpZGVFcXVhbHMgaW4gMi4wXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkaXZpZGVFcXVhbHM6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHRoaXMueCAvPSBzY2FsYXI7XG4gICAgICB0aGlzLnkgLz0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGVxdWFsIHRvIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGVxOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPT09IHRoYXQueCAmJiB0aGlzLnkgPT09IHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGxlc3MgdGhhbiBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBsdDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54IDwgdGhhdC54ICYmIHRoaXMueSA8IHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBsdGU6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA8PSB0aGF0LnggJiYgdGhpcy55IDw9IHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcG9pbnQgaXMgZ3JlYXRlciBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBndDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54ID4gdGhhdC54ICYmIHRoaXMueSA+IHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBndGU6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA+PSB0aGF0LnggJiYgdGhpcy55ID49IHRoYXQueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmV3IHBvaW50IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgbGluZWFyIGludGVycG9sYXRpb24gd2l0aCB0aGlzIG9uZSBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0ICwgcG9zaXRpb24gb2YgaW50ZXJwb2xhdGlvbiwgYmV0d2VlbiAwIGFuZCAxIGRlZmF1bHQgMC41XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGxlcnA6IGZ1bmN0aW9uICh0aGF0LCB0KSB7XG4gICAgICBpZiAodHlwZW9mIHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHQgPSAwLjU7XG4gICAgICB9XG4gICAgICB0ID0gTWF0aC5tYXgoTWF0aC5taW4oMSwgdCksIDApO1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyAodGhhdC54IC0gdGhpcy54KSAqIHQsIHRoaXMueSArICh0aGF0LnkgLSB0aGlzLnkpICogdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGRpc3RhbmNlRnJvbTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHZhciBkeCA9IHRoaXMueCAtIHRoYXQueCxcbiAgICAgICAgICBkeSA9IHRoaXMueSAtIHRoYXQueTtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBiZXR3ZWVuIHRoaXMgcG9pbnQgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbWlkUG9pbnRGcm9tOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVycCh0aGF0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBwb2ludCB3aGljaCBpcyB0aGUgbWluIG9mIHRoaXMgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbWluOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChNYXRoLm1pbih0aGlzLngsIHRoYXQueCksIE1hdGgubWluKHRoaXMueSwgdGhhdC55KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgcG9pbnQgd2hpY2ggaXMgdGhlIG1heCBvZiB0aGlzIGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG1heDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoTWF0aC5tYXgodGhpcy54LCB0aGF0LngpLCBNYXRoLm1heCh0aGlzLnksIHRoYXQueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBvaW50XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy54ICsgJywnICsgdGhpcy55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHgveSBvZiB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRYWTogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeCBvZiB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0WDogZnVuY3Rpb24gKHgpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB5IG9mIHRoaXMgcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRZOiBmdW5jdGlvbiAoeSkge1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHgveSBvZiB0aGlzIHBvaW50IGZyb20gYW5vdGhlciBwb2ludFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldEZyb21Qb2ludDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHRoaXMueCA9IHRoYXQueDtcbiAgICAgIHRoaXMueSA9IHRoYXQueTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTd2FwcyB4L3kgb2YgdGhpcyBwb2ludCBhbmQgYW5vdGhlciBwb2ludFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICovXG4gICAgc3dhcDogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICAgIHkgPSB0aGlzLnk7XG4gICAgICB0aGlzLnggPSB0aGF0Lng7XG4gICAgICB0aGlzLnkgPSB0aGF0Lnk7XG4gICAgICB0aGF0LnggPSB4O1xuICAgICAgdGhhdC55ID0geTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgY2xvbmVkIGluc3RhbmNlIG9mIHRoZSBwb2ludFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBBZGFwdGF0aW9uIG9mIHdvcmsgb2YgS2V2aW4gTGluZHNleSAoa2V2aW5Aa2V2bGluZGV2LmNvbSkgKi9cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuSW50ZXJzZWN0aW9uKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5JbnRlcnNlY3Rpb24gaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyc2VjdGlvbiBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkludGVyc2VjdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gSW50ZXJzZWN0aW9uKHN0YXR1cykge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gIH1cblxuICBmYWJyaWMuSW50ZXJzZWN0aW9uID0gSW50ZXJzZWN0aW9uO1xuXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24ucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuSW50ZXJzZWN0aW9uLnByb3RvdHlwZSAqLyB7XG5cbiAgICBjb25zdHJ1Y3RvcjogSW50ZXJzZWN0aW9uLFxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBhIHBvaW50IHRvIGludGVyc2VjdGlvblxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYXBwZW5kUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdGhpcy5wb2ludHMucHVzaChwb2ludCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBwb2ludHMgdG8gaW50ZXJzZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXG4gICAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhcHBlbmRQb2ludHM6IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgIHRoaXMucG9pbnRzID0gdGhpcy5wb2ludHMuY29uY2F0KHBvaW50cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBvbmUgbGluZSBpbnRlcnNlY3RzIGFub3RoZXJcbiAgICogVE9ETzogcmVuYW1lIGluIGludGVyc2VjdFNlZ21lbnRTZWdtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGExXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBhMlxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYjFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGIyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVMaW5lID0gZnVuY3Rpb24gKGExLCBhMiwgYjEsIGIyKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgdWFUID0gKGIyLnggLSBiMS54KSAqIChhMS55IC0gYjEueSkgLSAoYjIueSAtIGIxLnkpICogKGExLnggLSBiMS54KSxcbiAgICAgICAgdWJUID0gKGEyLnggLSBhMS54KSAqIChhMS55IC0gYjEueSkgLSAoYTIueSAtIGExLnkpICogKGExLnggLSBiMS54KSxcbiAgICAgICAgdUIgPSAoYjIueSAtIGIxLnkpICogKGEyLnggLSBhMS54KSAtIChiMi54IC0gYjEueCkgKiAoYTIueSAtIGExLnkpO1xuICAgIGlmICh1QiAhPT0gMCkge1xuICAgICAgdmFyIHVhID0gdWFUIC8gdUIsXG4gICAgICAgICAgdWIgPSB1YlQgLyB1QjtcbiAgICAgIGlmICgwIDw9IHVhICYmIHVhIDw9IDEgJiYgMCA8PSB1YiAmJiB1YiA8PSAxKSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oJ0ludGVyc2VjdGlvbicpO1xuICAgICAgICByZXN1bHQuYXBwZW5kUG9pbnQobmV3IGZhYnJpYy5Qb2ludChhMS54ICsgdWEgKiAoYTIueCAtIGExLngpLCBhMS55ICsgdWEgKiAoYTIueSAtIGExLnkpKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICh1YVQgPT09IDAgfHwgdWJUID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oJ0NvaW5jaWRlbnQnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCdQYXJhbGxlbCcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgbGluZSBpbnRlcnNlY3RzIHBvbHlnb25cbiAgICogVE9ETzogcmVuYW1lIGluIGludGVyc2VjdFNlZ21lbnRQb2x5Z29uXG4gICAqIGZpeCBkZXRlY3Rpb24gb2YgY29pbmNpZGVudFxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBhMVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTJcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uID0gZnVuY3Rpb24oYTEsIGEyLCBwb2ludHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpLFxuICAgICAgICBsZW5ndGggPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBiMSwgYjIsIGludGVyLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBiMSA9IHBvaW50c1tpXTtcbiAgICAgIGIyID0gcG9pbnRzWyhpICsgMSkgJSBsZW5ndGhdO1xuICAgICAgaW50ZXIgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZUxpbmUoYTEsIGEyLCBiMSwgYjIpO1xuXG4gICAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyLnBvaW50cyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQucG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5zdGF0dXMgPSAnSW50ZXJzZWN0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHBvbHlnb24gaW50ZXJzZWN0cyBhbm90aGVyIHBvbHlnb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMxXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50czJcbiAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn1cbiAgICovXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0UG9seWdvblBvbHlnb24gPSBmdW5jdGlvbiAocG9pbnRzMSwgcG9pbnRzMikge1xuICAgIHZhciByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCksXG4gICAgICAgIGxlbmd0aCA9IHBvaW50czEubGVuZ3RoLCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYTEgPSBwb2ludHMxW2ldLFxuICAgICAgICAgIGEyID0gcG9pbnRzMVsoaSArIDEpICUgbGVuZ3RoXSxcbiAgICAgICAgICBpbnRlciA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbihhMSwgYTIsIHBvaW50czIpO1xuXG4gICAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyLnBvaW50cyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQucG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5zdGF0dXMgPSAnSW50ZXJzZWN0aW9uJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHBvbHlnb24gaW50ZXJzZWN0cyByZWN0YW5nbGVcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHIxXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSByMlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUmVjdGFuZ2xlID0gZnVuY3Rpb24gKHBvaW50cywgcjEsIHIyKSB7XG4gICAgdmFyIG1pbiA9IHIxLm1pbihyMiksXG4gICAgICAgIG1heCA9IHIxLm1heChyMiksXG4gICAgICAgIHRvcFJpZ2h0ID0gbmV3IGZhYnJpYy5Qb2ludChtYXgueCwgbWluLnkpLFxuICAgICAgICBib3R0b21MZWZ0ID0gbmV3IGZhYnJpYy5Qb2ludChtaW4ueCwgbWF4LnkpLFxuICAgICAgICBpbnRlcjEgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24obWluLCB0b3BSaWdodCwgcG9pbnRzKSxcbiAgICAgICAgaW50ZXIyID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKHRvcFJpZ2h0LCBtYXgsIHBvaW50cyksXG4gICAgICAgIGludGVyMyA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbihtYXgsIGJvdHRvbUxlZnQsIHBvaW50cyksXG4gICAgICAgIGludGVyNCA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbihib3R0b21MZWZ0LCBtaW4sIHBvaW50cyksXG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKTtcblxuICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIxLnBvaW50cyk7XG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjIucG9pbnRzKTtcbiAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyMy5wb2ludHMpO1xuICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXI0LnBvaW50cyk7XG5cbiAgICBpZiAocmVzdWx0LnBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQuc3RhdHVzID0gJ0ludGVyc2VjdGlvbic7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLkNvbG9yKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Db2xvciBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbG9yIGNsYXNzXG4gICAqIFRoZSBwdXJwb3NlIG9mIHtAbGluayBmYWJyaWMuQ29sb3J9IGlzIHRvIGFic3RyYWN0IGFuZCBlbmNhcHN1bGF0ZSBjb21tb24gY29sb3Igb3BlcmF0aW9ucztcbiAgICoge0BsaW5rIGZhYnJpYy5Db2xvcn0gaXMgYSBjb25zdHJ1Y3RvciBhbmQgY3JlYXRlcyBpbnN0YW5jZXMgb2Yge0BsaW5rIGZhYnJpYy5Db2xvcn0gb2JqZWN0cy5cbiAgICpcbiAgICogQGNsYXNzIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3Igb3B0aW9uYWwgaW4gaGV4IG9yIHJnYihhKSBvciBoc2wgZm9ybWF0IG9yIGZyb20ga25vd24gY29sb3IgbGlzdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIvI2NvbG9yc31cbiAgICovXG4gIGZ1bmN0aW9uIENvbG9yKGNvbG9yKSB7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgdGhpcy5zZXRTb3VyY2UoWzAsIDAsIDAsIDFdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl90cnlQYXJzaW5nQ29sb3IoY29sb3IpO1xuICAgIH1cbiAgfVxuXG4gIGZhYnJpYy5Db2xvciA9IENvbG9yO1xuXG4gIGZhYnJpYy5Db2xvci5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5Db2xvci5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gY29sb3IgQ29sb3IgdmFsdWUgdG8gcGFyc2VcbiAgICAgKi9cbiAgICBfdHJ5UGFyc2luZ0NvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuICAgICAgdmFyIHNvdXJjZTtcblxuICAgICAgaWYgKGNvbG9yIGluIENvbG9yLmNvbG9yTmFtZU1hcCkge1xuICAgICAgICBjb2xvciA9IENvbG9yLmNvbG9yTmFtZU1hcFtjb2xvcl07XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2xvciA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICBzb3VyY2UgPSBbMjU1LCAyNTUsIDI1NSwgMF07XG4gICAgICB9XG5cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHNvdXJjZSA9IENvbG9yLnNvdXJjZUZyb21IZXgoY29sb3IpO1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgc291cmNlID0gQ29sb3Iuc291cmNlRnJvbVJnYihjb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBzb3VyY2UgPSBDb2xvci5zb3VyY2VGcm9tSHNsKGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIC8vaWYgY29sb3IgaXMgbm90IHJlY29nbml6ZSBsZXQncyBtYWtlIGJsYWNrIGFzIGNhbnZhcyBkb2VzXG4gICAgICAgIHNvdXJjZSA9IFswLCAwLCAwLCAxXTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRhcHRlZCBmcm9tIDxhIGhyZWY9XCJodHRwczovL3Jhd2dpdGh1Yi5jb20vbWppamFja3Nvbi9tamlqYWNrc29uLmdpdGh1Yi5jb20vbWFzdGVyLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdC5odG1sXCI+aHR0cHM6Ly9naXRodWIuY29tL21qaWphY2tzb248L2E+XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gciBSZWQgY29sb3IgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZyBHcmVlbiBjb2xvciB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIEJsdWUgY29sb3IgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gSHNsIGNvbG9yXG4gICAgICovXG4gICAgX3JnYlRvSHNsOiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICByIC89IDI1NTsgZyAvPSAyNTU7IGIgLz0gMjU1O1xuXG4gICAgICB2YXIgaCwgcywgbCxcbiAgICAgICAgICBtYXggPSBmYWJyaWMudXRpbC5hcnJheS5tYXgoW3IsIGcsIGJdKSxcbiAgICAgICAgICBtaW4gPSBmYWJyaWMudXRpbC5hcnJheS5taW4oW3IsIGcsIGJdKTtcblxuICAgICAgbCA9IChtYXggKyBtaW4pIC8gMjtcblxuICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICAgICAgY2FzZSByOlxuICAgICAgICAgICAgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBnOlxuICAgICAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYjpcbiAgICAgICAgICAgIGggPSAociAtIGcpIC8gZCArIDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBoIC89IDY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIE1hdGgucm91bmQoaCAqIDM2MCksXG4gICAgICAgIE1hdGgucm91bmQocyAqIDEwMCksXG4gICAgICAgIE1hdGgucm91bmQobCAqIDEwMClcbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc291cmNlIG9mIHRoaXMgY29sb3IgKHdoZXJlIHNvdXJjZSBpcyBhbiBhcnJheSByZXByZXNlbnRhdGlvbjsgZXg6IFsyMDAsIDIwMCwgMTAwLCAxXSlcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRTb3VyY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzb3VyY2Ugb2YgdGhpcyBjb2xvciAod2hlcmUgc291cmNlIGlzIGFuIGFycmF5IHJlcHJlc2VudGF0aW9uOyBleDogWzIwMCwgMjAwLCAxMDAsIDFdKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZVxuICAgICAqL1xuICAgIHNldFNvdXJjZTogZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gUkdCIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IHJnYigwLTI1NSwwLTI1NSwwLTI1NSlcbiAgICAgKi9cbiAgICB0b1JnYjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICAgIHJldHVybiAncmdiKCcgKyBzb3VyY2VbMF0gKyAnLCcgKyBzb3VyY2VbMV0gKyAnLCcgKyBzb3VyY2VbMl0gKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gUkdCQSBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiByZ2JhKDAtMjU1LDAtMjU1LDAtMjU1LDAtMSlcbiAgICAgKi9cbiAgICB0b1JnYmE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgICByZXR1cm4gJ3JnYmEoJyArIHNvdXJjZVswXSArICcsJyArIHNvdXJjZVsxXSArICcsJyArIHNvdXJjZVsyXSArICcsJyArIHNvdXJjZVszXSArICcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBIU0wgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogaHNsKDAtMzYwLDAlLTEwMCUsMCUtMTAwJSlcbiAgICAgKi9cbiAgICB0b0hzbDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBoc2wgPSB0aGlzLl9yZ2JUb0hzbChzb3VyY2VbMF0sIHNvdXJjZVsxXSwgc291cmNlWzJdKTtcblxuICAgICAgcmV0dXJuICdoc2woJyArIGhzbFswXSArICcsJyArIGhzbFsxXSArICclLCcgKyBoc2xbMl0gKyAnJSknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIEhTTEEgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogaHNsYSgwLTM2MCwwJS0xMDAlLDAlLTEwMCUsMC0xKVxuICAgICAqL1xuICAgIHRvSHNsYTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBoc2wgPSB0aGlzLl9yZ2JUb0hzbChzb3VyY2VbMF0sIHNvdXJjZVsxXSwgc291cmNlWzJdKTtcblxuICAgICAgcmV0dXJuICdoc2xhKCcgKyBoc2xbMF0gKyAnLCcgKyBoc2xbMV0gKyAnJSwnICsgaHNsWzJdICsgJyUsJyArIHNvdXJjZVszXSArICcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBIRVggZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogRkY1NTU1XG4gICAgICovXG4gICAgdG9IZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksIHIsIGcsIGI7XG5cbiAgICAgIHIgPSBzb3VyY2VbMF0udG9TdHJpbmcoMTYpO1xuICAgICAgciA9IChyLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgcikgOiByO1xuXG4gICAgICBnID0gc291cmNlWzFdLnRvU3RyaW5nKDE2KTtcbiAgICAgIGcgPSAoZy5sZW5ndGggPT09IDEpID8gKCcwJyArIGcpIDogZztcblxuICAgICAgYiA9IHNvdXJjZVsyXS50b1N0cmluZygxNik7XG4gICAgICBiID0gKGIubGVuZ3RoID09PSAxKSA/ICgnMCcgKyBiKSA6IGI7XG5cbiAgICAgIHJldHVybiByLnRvVXBwZXJDYXNlKCkgKyBnLnRvVXBwZXJDYXNlKCkgKyBiLnRvVXBwZXJDYXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gSEVYQSBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiBGRjU1NTVDQ1xuICAgICAqL1xuICAgIHRvSGV4YTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSwgYTtcblxuICAgICAgYSA9IE1hdGgucm91bmQoc291cmNlWzNdICogMjU1KTtcbiAgICAgIGEgPSBhLnRvU3RyaW5nKDE2KTtcbiAgICAgIGEgPSAoYS5sZW5ndGggPT09IDEpID8gKCcwJyArIGEpIDogYTtcblxuICAgICAgcmV0dXJuIHRoaXMudG9IZXgoKSArIGEudG9VcHBlckNhc2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB2YWx1ZSBvZiBhbHBoYSBjaGFubmVsIGZvciB0aGlzIGNvbG9yXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAwLTFcbiAgICAgKi9cbiAgICBnZXRBbHBoYTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTb3VyY2UoKVszXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB2YWx1ZSBvZiBhbHBoYSBjaGFubmVsIGZvciB0aGlzIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhIEFscGhhIHZhbHVlIDAtMVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNldEFscGhhOiBmdW5jdGlvbihhbHBoYSkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgICBzb3VyY2VbM10gPSBhbHBoYTtcbiAgICAgIHRoaXMuc2V0U291cmNlKHNvdXJjZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBjb2xvciB0byBpdHMgZ3JheXNjYWxlIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfSB0aGlzQXJnXG4gICAgICovXG4gICAgdG9HcmF5c2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgYXZlcmFnZSA9IHBhcnNlSW50KChzb3VyY2VbMF0gKiAwLjMgKyBzb3VyY2VbMV0gKiAwLjU5ICsgc291cmNlWzJdICogMC4xMSkudG9GaXhlZCgwKSwgMTApLFxuICAgICAgICAgIGN1cnJlbnRBbHBoYSA9IHNvdXJjZVszXTtcbiAgICAgIHRoaXMuc2V0U291cmNlKFthdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjdXJyZW50QWxwaGFdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIGNvbG9yIHRvIGl0cyBibGFjayBhbmQgd2hpdGUgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGhyZXNob2xkXG4gICAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfSB0aGlzQXJnXG4gICAgICovXG4gICAgdG9CbGFja1doaXRlOiBmdW5jdGlvbih0aHJlc2hvbGQpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGF2ZXJhZ2UgPSAoc291cmNlWzBdICogMC4zICsgc291cmNlWzFdICogMC41OSArIHNvdXJjZVsyXSAqIDAuMTEpLnRvRml4ZWQoMCksXG4gICAgICAgICAgY3VycmVudEFscGhhID0gc291cmNlWzNdO1xuXG4gICAgICB0aHJlc2hvbGQgPSB0aHJlc2hvbGQgfHwgMTI3O1xuXG4gICAgICBhdmVyYWdlID0gKE51bWJlcihhdmVyYWdlKSA8IE51bWJlcih0aHJlc2hvbGQpKSA/IDAgOiAyNTU7XG4gICAgICB0aGlzLnNldFNvdXJjZShbYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY3VycmVudEFscGhhXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3ZlcmxheXMgY29sb3Igd2l0aCBhbm90aGVyIGNvbG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd8ZmFicmljLkNvbG9yfSBvdGhlckNvbG9yXG4gICAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfSB0aGlzQXJnXG4gICAgICovXG4gICAgb3ZlcmxheVdpdGg6IGZ1bmN0aW9uKG90aGVyQ29sb3IpIHtcbiAgICAgIGlmICghKG90aGVyQ29sb3IgaW5zdGFuY2VvZiBDb2xvcikpIHtcbiAgICAgICAgb3RoZXJDb2xvciA9IG5ldyBDb2xvcihvdGhlckNvbG9yKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIGFscGhhID0gdGhpcy5nZXRBbHBoYSgpLFxuICAgICAgICAgIG90aGVyQWxwaGEgPSAwLjUsXG4gICAgICAgICAgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBvdGhlclNvdXJjZSA9IG90aGVyQ29sb3IuZ2V0U291cmNlKCksIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2goTWF0aC5yb3VuZCgoc291cmNlW2ldICogKDEgLSBvdGhlckFscGhhKSkgKyAob3RoZXJTb3VyY2VbaV0gKiBvdGhlckFscGhhKSkpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRbM10gPSBhbHBoYTtcbiAgICAgIHRoaXMuc2V0U291cmNlKHJlc3VsdCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ2V4IG1hdGNoaW5nIGNvbG9yIGluIFJHQiBvciBSR0JBIGZvcm1hdHMgKGV4OiByZ2IoMCwgMCwgMCksIHJnYmEoMjU1LCAxMDAsIDEwLCAwLjUpLCByZ2JhKCAyNTUgLCAxMDAgLCAxMCAsIDAuNSApLCByZ2IoMSwxLDEpLCByZ2JhKDEwMCUsIDYwJSwgMTAlLCAwLjUpKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBmYWJyaWMuQ29sb3IucmVSR0JhID0gL15yZ2JhP1xcKFxccyooXFxkezEsM30oPzpcXC5cXGQrKT9cXCU/KVxccyosXFxzKihcXGR7MSwzfSg/OlxcLlxcZCspP1xcJT8pXFxzKixcXHMqKFxcZHsxLDN9KD86XFwuXFxkKyk/XFwlPylcXHMqKD86XFxzKixcXHMqKCg/OlxcZCpcXC4/XFxkKyk/KVxccyopP1xcKSQvaTtcblxuICAvKipcbiAgICogUmVnZXggbWF0Y2hpbmcgY29sb3IgaW4gSFNMIG9yIEhTTEEgZm9ybWF0cyAoZXg6IGhzbCgyMDAsIDgwJSwgMTAlKSwgaHNsYSgzMDAsIDUwJSwgODAlLCAwLjUpLCBoc2xhKCAzMDAgLCA1MCUgLCA4MCUgLCAwLjUgKSlcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKi9cbiAgZmFicmljLkNvbG9yLnJlSFNMYSA9IC9eaHNsYT9cXChcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfVxcJSlcXHMqLFxccyooXFxkezEsM31cXCUpXFxzKig/OlxccyosXFxzKihcXGQrKD86XFwuXFxkKyk/KVxccyopP1xcKSQvaTtcblxuICAvKipcbiAgICogUmVnZXggbWF0Y2hpbmcgY29sb3IgaW4gSEVYIGZvcm1hdCAoZXg6ICNGRjU1NDRDQywgI0ZGNTU1NSwgMDEwMTU1LCBhZmYpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICovXG4gIGZhYnJpYy5Db2xvci5yZUhleCA9IC9eIz8oWzAtOWEtZl17OH18WzAtOWEtZl17Nn18WzAtOWEtZl17NH18WzAtOWEtZl17M30pJC9pO1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgdGhlIDE0OCBjb2xvciBuYW1lcyB3aXRoIEhFWCBjb2RlXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHNlZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvI3N2Zy1jb2xvclxuICAgKi9cbiAgZmFicmljLkNvbG9yLmNvbG9yTmFtZU1hcCA9IHtcbiAgICBhbGljZWJsdWU6ICAgICAgICAgICAgJyNGMEY4RkYnLFxuICAgIGFudGlxdWV3aGl0ZTogICAgICAgICAnI0ZBRUJENycsXG4gICAgYXF1YTogICAgICAgICAgICAgICAgICcjMDBGRkZGJyxcbiAgICBhcXVhbWFyaW5lOiAgICAgICAgICAgJyM3RkZGRDQnLFxuICAgIGF6dXJlOiAgICAgICAgICAgICAgICAnI0YwRkZGRicsXG4gICAgYmVpZ2U6ICAgICAgICAgICAgICAgICcjRjVGNURDJyxcbiAgICBiaXNxdWU6ICAgICAgICAgICAgICAgJyNGRkU0QzQnLFxuICAgIGJsYWNrOiAgICAgICAgICAgICAgICAnIzAwMDAwMCcsXG4gICAgYmxhbmNoZWRhbG1vbmQ6ICAgICAgICcjRkZFQkNEJyxcbiAgICBibHVlOiAgICAgICAgICAgICAgICAgJyMwMDAwRkYnLFxuICAgIGJsdWV2aW9sZXQ6ICAgICAgICAgICAnIzhBMkJFMicsXG4gICAgYnJvd246ICAgICAgICAgICAgICAgICcjQTUyQTJBJyxcbiAgICBidXJseXdvb2Q6ICAgICAgICAgICAgJyNERUI4ODcnLFxuICAgIGNhZGV0Ymx1ZTogICAgICAgICAgICAnIzVGOUVBMCcsXG4gICAgY2hhcnRyZXVzZTogICAgICAgICAgICcjN0ZGRjAwJyxcbiAgICBjaG9jb2xhdGU6ICAgICAgICAgICAgJyNEMjY5MUUnLFxuICAgIGNvcmFsOiAgICAgICAgICAgICAgICAnI0ZGN0Y1MCcsXG4gICAgY29ybmZsb3dlcmJsdWU6ICAgICAgICcjNjQ5NUVEJyxcbiAgICBjb3Juc2lsazogICAgICAgICAgICAgJyNGRkY4REMnLFxuICAgIGNyaW1zb246ICAgICAgICAgICAgICAnI0RDMTQzQycsXG4gICAgY3lhbjogICAgICAgICAgICAgICAgICcjMDBGRkZGJyxcbiAgICBkYXJrYmx1ZTogICAgICAgICAgICAgJyMwMDAwOEInLFxuICAgIGRhcmtjeWFuOiAgICAgICAgICAgICAnIzAwOEI4QicsXG4gICAgZGFya2dvbGRlbnJvZDogICAgICAgICcjQjg4NjBCJyxcbiAgICBkYXJrZ3JheTogICAgICAgICAgICAgJyNBOUE5QTknLFxuICAgIGRhcmtncmV5OiAgICAgICAgICAgICAnI0E5QTlBOScsXG4gICAgZGFya2dyZWVuOiAgICAgICAgICAgICcjMDA2NDAwJyxcbiAgICBkYXJra2hha2k6ICAgICAgICAgICAgJyNCREI3NkInLFxuICAgIGRhcmttYWdlbnRhOiAgICAgICAgICAnIzhCMDA4QicsXG4gICAgZGFya29saXZlZ3JlZW46ICAgICAgICcjNTU2QjJGJyxcbiAgICBkYXJrb3JhbmdlOiAgICAgICAgICAgJyNGRjhDMDAnLFxuICAgIGRhcmtvcmNoaWQ6ICAgICAgICAgICAnIzk5MzJDQycsXG4gICAgZGFya3JlZDogICAgICAgICAgICAgICcjOEIwMDAwJyxcbiAgICBkYXJrc2FsbW9uOiAgICAgICAgICAgJyNFOTk2N0EnLFxuICAgIGRhcmtzZWFncmVlbjogICAgICAgICAnIzhGQkM4RicsXG4gICAgZGFya3NsYXRlYmx1ZTogICAgICAgICcjNDgzRDhCJyxcbiAgICBkYXJrc2xhdGVncmF5OiAgICAgICAgJyMyRjRGNEYnLFxuICAgIGRhcmtzbGF0ZWdyZXk6ICAgICAgICAnIzJGNEY0RicsXG4gICAgZGFya3R1cnF1b2lzZTogICAgICAgICcjMDBDRUQxJyxcbiAgICBkYXJrdmlvbGV0OiAgICAgICAgICAgJyM5NDAwRDMnLFxuICAgIGRlZXBwaW5rOiAgICAgICAgICAgICAnI0ZGMTQ5MycsXG4gICAgZGVlcHNreWJsdWU6ICAgICAgICAgICcjMDBCRkZGJyxcbiAgICBkaW1ncmF5OiAgICAgICAgICAgICAgJyM2OTY5NjknLFxuICAgIGRpbWdyZXk6ICAgICAgICAgICAgICAnIzY5Njk2OScsXG4gICAgZG9kZ2VyYmx1ZTogICAgICAgICAgICcjMUU5MEZGJyxcbiAgICBmaXJlYnJpY2s6ICAgICAgICAgICAgJyNCMjIyMjInLFxuICAgIGZsb3JhbHdoaXRlOiAgICAgICAgICAnI0ZGRkFGMCcsXG4gICAgZm9yZXN0Z3JlZW46ICAgICAgICAgICcjMjI4QjIyJyxcbiAgICBmdWNoc2lhOiAgICAgICAgICAgICAgJyNGRjAwRkYnLFxuICAgIGdhaW5zYm9ybzogICAgICAgICAgICAnI0RDRENEQycsXG4gICAgZ2hvc3R3aGl0ZTogICAgICAgICAgICcjRjhGOEZGJyxcbiAgICBnb2xkOiAgICAgICAgICAgICAgICAgJyNGRkQ3MDAnLFxuICAgIGdvbGRlbnJvZDogICAgICAgICAgICAnI0RBQTUyMCcsXG4gICAgZ3JheTogICAgICAgICAgICAgICAgICcjODA4MDgwJyxcbiAgICBncmV5OiAgICAgICAgICAgICAgICAgJyM4MDgwODAnLFxuICAgIGdyZWVuOiAgICAgICAgICAgICAgICAnIzAwODAwMCcsXG4gICAgZ3JlZW55ZWxsb3c6ICAgICAgICAgICcjQURGRjJGJyxcbiAgICBob25leWRldzogICAgICAgICAgICAgJyNGMEZGRjAnLFxuICAgIGhvdHBpbms6ICAgICAgICAgICAgICAnI0ZGNjlCNCcsXG4gICAgaW5kaWFucmVkOiAgICAgICAgICAgICcjQ0Q1QzVDJyxcbiAgICBpbmRpZ286ICAgICAgICAgICAgICAgJyM0QjAwODInLFxuICAgIGl2b3J5OiAgICAgICAgICAgICAgICAnI0ZGRkZGMCcsXG4gICAga2hha2k6ICAgICAgICAgICAgICAgICcjRjBFNjhDJyxcbiAgICBsYXZlbmRlcjogICAgICAgICAgICAgJyNFNkU2RkEnLFxuICAgIGxhdmVuZGVyYmx1c2g6ICAgICAgICAnI0ZGRjBGNScsXG4gICAgbGF3bmdyZWVuOiAgICAgICAgICAgICcjN0NGQzAwJyxcbiAgICBsZW1vbmNoaWZmb246ICAgICAgICAgJyNGRkZBQ0QnLFxuICAgIGxpZ2h0Ymx1ZTogICAgICAgICAgICAnI0FERDhFNicsXG4gICAgbGlnaHRjb3JhbDogICAgICAgICAgICcjRjA4MDgwJyxcbiAgICBsaWdodGN5YW46ICAgICAgICAgICAgJyNFMEZGRkYnLFxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnI0ZBRkFEMicsXG4gICAgbGlnaHRncmF5OiAgICAgICAgICAgICcjRDNEM0QzJyxcbiAgICBsaWdodGdyZXk6ICAgICAgICAgICAgJyNEM0QzRDMnLFxuICAgIGxpZ2h0Z3JlZW46ICAgICAgICAgICAnIzkwRUU5MCcsXG4gICAgbGlnaHRwaW5rOiAgICAgICAgICAgICcjRkZCNkMxJyxcbiAgICBsaWdodHNhbG1vbjogICAgICAgICAgJyNGRkEwN0EnLFxuICAgIGxpZ2h0c2VhZ3JlZW46ICAgICAgICAnIzIwQjJBQScsXG4gICAgbGlnaHRza3libHVlOiAgICAgICAgICcjODdDRUZBJyxcbiAgICBsaWdodHNsYXRlZ3JheTogICAgICAgJyM3Nzg4OTknLFxuICAgIGxpZ2h0c2xhdGVncmV5OiAgICAgICAnIzc3ODg5OScsXG4gICAgbGlnaHRzdGVlbGJsdWU6ICAgICAgICcjQjBDNERFJyxcbiAgICBsaWdodHllbGxvdzogICAgICAgICAgJyNGRkZGRTAnLFxuICAgIGxpbWU6ICAgICAgICAgICAgICAgICAnIzAwRkYwMCcsXG4gICAgbGltZWdyZWVuOiAgICAgICAgICAgICcjMzJDRDMyJyxcbiAgICBsaW5lbjogICAgICAgICAgICAgICAgJyNGQUYwRTYnLFxuICAgIG1hZ2VudGE6ICAgICAgICAgICAgICAnI0ZGMDBGRicsXG4gICAgbWFyb29uOiAgICAgICAgICAgICAgICcjODAwMDAwJyxcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiAgICAgJyM2NkNEQUEnLFxuICAgIG1lZGl1bWJsdWU6ICAgICAgICAgICAnIzAwMDBDRCcsXG4gICAgbWVkaXVtb3JjaGlkOiAgICAgICAgICcjQkE1NUQzJyxcbiAgICBtZWRpdW1wdXJwbGU6ICAgICAgICAgJyM5MzcwREInLFxuICAgIG1lZGl1bXNlYWdyZWVuOiAgICAgICAnIzNDQjM3MScsXG4gICAgbWVkaXVtc2xhdGVibHVlOiAgICAgICcjN0I2OEVFJyxcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogICAgJyMwMEZBOUEnLFxuICAgIG1lZGl1bXR1cnF1b2lzZTogICAgICAnIzQ4RDFDQycsXG4gICAgbWVkaXVtdmlvbGV0cmVkOiAgICAgICcjQzcxNTg1JyxcbiAgICBtaWRuaWdodGJsdWU6ICAgICAgICAgJyMxOTE5NzAnLFxuICAgIG1pbnRjcmVhbTogICAgICAgICAgICAnI0Y1RkZGQScsXG4gICAgbWlzdHlyb3NlOiAgICAgICAgICAgICcjRkZFNEUxJyxcbiAgICBtb2NjYXNpbjogICAgICAgICAgICAgJyNGRkU0QjUnLFxuICAgIG5hdmFqb3doaXRlOiAgICAgICAgICAnI0ZGREVBRCcsXG4gICAgbmF2eTogICAgICAgICAgICAgICAgICcjMDAwMDgwJyxcbiAgICBvbGRsYWNlOiAgICAgICAgICAgICAgJyNGREY1RTYnLFxuICAgIG9saXZlOiAgICAgICAgICAgICAgICAnIzgwODAwMCcsXG4gICAgb2xpdmVkcmFiOiAgICAgICAgICAgICcjNkI4RTIzJyxcbiAgICBvcmFuZ2U6ICAgICAgICAgICAgICAgJyNGRkE1MDAnLFxuICAgIG9yYW5nZXJlZDogICAgICAgICAgICAnI0ZGNDUwMCcsXG4gICAgb3JjaGlkOiAgICAgICAgICAgICAgICcjREE3MEQ2JyxcbiAgICBwYWxlZ29sZGVucm9kOiAgICAgICAgJyNFRUU4QUEnLFxuICAgIHBhbGVncmVlbjogICAgICAgICAgICAnIzk4RkI5OCcsXG4gICAgcGFsZXR1cnF1b2lzZTogICAgICAgICcjQUZFRUVFJyxcbiAgICBwYWxldmlvbGV0cmVkOiAgICAgICAgJyNEQjcwOTMnLFxuICAgIHBhcGF5YXdoaXA6ICAgICAgICAgICAnI0ZGRUZENScsXG4gICAgcGVhY2hwdWZmOiAgICAgICAgICAgICcjRkZEQUI5JyxcbiAgICBwZXJ1OiAgICAgICAgICAgICAgICAgJyNDRDg1M0YnLFxuICAgIHBpbms6ICAgICAgICAgICAgICAgICAnI0ZGQzBDQicsXG4gICAgcGx1bTogICAgICAgICAgICAgICAgICcjRERBMEREJyxcbiAgICBwb3dkZXJibHVlOiAgICAgICAgICAgJyNCMEUwRTYnLFxuICAgIHB1cnBsZTogICAgICAgICAgICAgICAnIzgwMDA4MCcsXG4gICAgcmViZWNjYXB1cnBsZTogICAgICAgICcjNjYzMzk5JyxcbiAgICByZWQ6ICAgICAgICAgICAgICAgICAgJyNGRjAwMDAnLFxuICAgIHJvc3licm93bjogICAgICAgICAgICAnI0JDOEY4RicsXG4gICAgcm95YWxibHVlOiAgICAgICAgICAgICcjNDE2OUUxJyxcbiAgICBzYWRkbGVicm93bjogICAgICAgICAgJyM4QjQ1MTMnLFxuICAgIHNhbG1vbjogICAgICAgICAgICAgICAnI0ZBODA3MicsXG4gICAgc2FuZHlicm93bjogICAgICAgICAgICcjRjRBNDYwJyxcbiAgICBzZWFncmVlbjogICAgICAgICAgICAgJyMyRThCNTcnLFxuICAgIHNlYXNoZWxsOiAgICAgICAgICAgICAnI0ZGRjVFRScsXG4gICAgc2llbm5hOiAgICAgICAgICAgICAgICcjQTA1MjJEJyxcbiAgICBzaWx2ZXI6ICAgICAgICAgICAgICAgJyNDMEMwQzAnLFxuICAgIHNreWJsdWU6ICAgICAgICAgICAgICAnIzg3Q0VFQicsXG4gICAgc2xhdGVibHVlOiAgICAgICAgICAgICcjNkE1QUNEJyxcbiAgICBzbGF0ZWdyYXk6ICAgICAgICAgICAgJyM3MDgwOTAnLFxuICAgIHNsYXRlZ3JleTogICAgICAgICAgICAnIzcwODA5MCcsXG4gICAgc25vdzogICAgICAgICAgICAgICAgICcjRkZGQUZBJyxcbiAgICBzcHJpbmdncmVlbjogICAgICAgICAgJyMwMEZGN0YnLFxuICAgIHN0ZWVsYmx1ZTogICAgICAgICAgICAnIzQ2ODJCNCcsXG4gICAgdGFuOiAgICAgICAgICAgICAgICAgICcjRDJCNDhDJyxcbiAgICB0ZWFsOiAgICAgICAgICAgICAgICAgJyMwMDgwODAnLFxuICAgIHRoaXN0bGU6ICAgICAgICAgICAgICAnI0Q4QkZEOCcsXG4gICAgdG9tYXRvOiAgICAgICAgICAgICAgICcjRkY2MzQ3JyxcbiAgICB0dXJxdW9pc2U6ICAgICAgICAgICAgJyM0MEUwRDAnLFxuICAgIHZpb2xldDogICAgICAgICAgICAgICAnI0VFODJFRScsXG4gICAgd2hlYXQ6ICAgICAgICAgICAgICAgICcjRjVERUIzJyxcbiAgICB3aGl0ZTogICAgICAgICAgICAgICAgJyNGRkZGRkYnLFxuICAgIHdoaXRlc21va2U6ICAgICAgICAgICAnI0Y1RjVGNScsXG4gICAgeWVsbG93OiAgICAgICAgICAgICAgICcjRkZGRjAwJyxcbiAgICB5ZWxsb3dncmVlbjogICAgICAgICAgJyM5QUNEMzInXG4gIH07XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBxXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgIGlmICh0IDwgMCkge1xuICAgICAgdCArPSAxO1xuICAgIH1cbiAgICBpZiAodCA+IDEpIHtcbiAgICAgIHQgLT0gMTtcbiAgICB9XG4gICAgaWYgKHQgPCAxIC8gNikge1xuICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgfVxuICAgIGlmICh0IDwgMSAvIDIpIHtcbiAgICAgIHJldHVybiBxO1xuICAgIH1cbiAgICBpZiAodCA8IDIgLyAzKSB7XG4gICAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBhIGNvbG9yIGluIFJHQiBmb3JtYXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWUgZXg6IHJnYigwLTI1NSwwLTI1NSwwLTI1NSlcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21SZ2IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiBDb2xvci5mcm9tU291cmNlKENvbG9yLnNvdXJjZUZyb21SZ2IoY29sb3IpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhcnJheSByZXByZXNlbnRhdGlvbiAoZXg6IFsxMDAsIDEwMCwgMjAwLCAxXSkgb2YgYSBjb2xvciB0aGF0J3MgaW4gUkdCIG9yIFJHQkEgZm9ybWF0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHZhbHVlIGV4OiByZ2IoMC0yNTUsMC0yNTUsMC0yNTUpLCByZ2IoMCUtMTAwJSwwJS0xMDAlLDAlLTEwMCUpXG4gICAqIEByZXR1cm4ge0FycmF5fSBzb3VyY2VcbiAgICovXG4gIGZhYnJpYy5Db2xvci5zb3VyY2VGcm9tUmdiID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICB2YXIgbWF0Y2ggPSBjb2xvci5tYXRjaChDb2xvci5yZVJHQmEpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIHIgPSBwYXJzZUludChtYXRjaFsxXSwgMTApIC8gKC8lJC8udGVzdChtYXRjaFsxXSkgPyAxMDAgOiAxKSAqICgvJSQvLnRlc3QobWF0Y2hbMV0pID8gMjU1IDogMSksXG4gICAgICAgICAgZyA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCkgLyAoLyUkLy50ZXN0KG1hdGNoWzJdKSA/IDEwMCA6IDEpICogKC8lJC8udGVzdChtYXRjaFsyXSkgPyAyNTUgOiAxKSxcbiAgICAgICAgICBiID0gcGFyc2VJbnQobWF0Y2hbM10sIDEwKSAvICgvJSQvLnRlc3QobWF0Y2hbM10pID8gMTAwIDogMSkgKiAoLyUkLy50ZXN0KG1hdGNoWzNdKSA/IDI1NSA6IDEpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBwYXJzZUludChyLCAxMCksXG4gICAgICAgIHBhcnNlSW50KGcsIDEwKSxcbiAgICAgICAgcGFyc2VJbnQoYiwgMTApLFxuICAgICAgICBtYXRjaFs0XSA/IHBhcnNlRmxvYXQobWF0Y2hbNF0pIDogMVxuICAgICAgXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBhIGNvbG9yIGluIFJHQkEgZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tUmdiYSA9IENvbG9yLmZyb21SZ2I7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBhIGNvbG9yIGluIEhTTCBmb3JtYXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHZhbHVlIGV4OiBoc2woMC0yNjAsMCUtMTAwJSwwJS0xMDAlKVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tSHNsID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICByZXR1cm4gQ29sb3IuZnJvbVNvdXJjZShDb2xvci5zb3VyY2VGcm9tSHNsKGNvbG9yKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXJyYXkgcmVwcmVzZW50YXRpb24gKGV4OiBbMTAwLCAxMDAsIDIwMCwgMV0pIG9mIGEgY29sb3IgdGhhdCdzIGluIEhTTCBvciBIU0xBIGZvcm1hdC5cbiAgICogQWRhcHRlZCBmcm9tIDxhIGhyZWY9XCJodHRwczovL3Jhd2dpdGh1Yi5jb20vbWppamFja3Nvbi9tamlqYWNrc29uLmdpdGh1Yi5jb20vbWFzdGVyLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdC5odG1sXCI+aHR0cHM6Ly9naXRodWIuY29tL21qaWphY2tzb248L2E+XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHZhbHVlIGV4OiBoc2woMC0zNjAsMCUtMTAwJSwwJS0xMDAlKSBvciBoc2xhKDAtMzYwLDAlLTEwMCUsMCUtMTAwJSwgMC0xKVxuICAgKiBAcmV0dXJuIHtBcnJheX0gc291cmNlXG4gICAqIEBzZWUgaHR0cDovL2h0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvI2hzbC1jb2xvclxuICAgKi9cbiAgZmFicmljLkNvbG9yLnNvdXJjZUZyb21Ic2wgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHZhciBtYXRjaCA9IGNvbG9yLm1hdGNoKENvbG9yLnJlSFNMYSk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBoID0gKCgocGFyc2VGbG9hdChtYXRjaFsxXSkgJSAzNjApICsgMzYwKSAlIDM2MCkgLyAzNjAsXG4gICAgICAgIHMgPSBwYXJzZUZsb2F0KG1hdGNoWzJdKSAvICgvJSQvLnRlc3QobWF0Y2hbMl0pID8gMTAwIDogMSksXG4gICAgICAgIGwgPSBwYXJzZUZsb2F0KG1hdGNoWzNdKSAvICgvJSQvLnRlc3QobWF0Y2hbM10pID8gMTAwIDogMSksXG4gICAgICAgIHIsIGcsIGI7XG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgciA9IGcgPSBiID0gbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgcSA9IGwgPD0gMC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzLFxuICAgICAgICAgIHAgPSBsICogMiAtIHE7XG5cbiAgICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxIC8gMyk7XG4gICAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxIC8gMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIE1hdGgucm91bmQociAqIDI1NSksXG4gICAgICBNYXRoLnJvdW5kKGcgKiAyNTUpLFxuICAgICAgTWF0aC5yb3VuZChiICogMjU1KSxcbiAgICAgIG1hdGNoWzRdID8gcGFyc2VGbG9hdChtYXRjaFs0XSkgOiAxXG4gICAgXTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gSFNMQSBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21Ic2xhID0gQ29sb3IuZnJvbUhzbDtcblxuICAvKipcbiAgICogUmV0dXJucyBuZXcgY29sb3Igb2JqZWN0LCB3aGVuIGdpdmVuIGEgY29sb3IgaW4gSEVYIGZvcm1hdFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHZhbHVlIGV4OiBGRjU1NTVcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfVxuICAgKi9cbiAgZmFicmljLkNvbG9yLmZyb21IZXggPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiBDb2xvci5mcm9tU291cmNlKENvbG9yLnNvdXJjZUZyb21IZXgoY29sb3IpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhcnJheSByZXByZXNlbnRhdGlvbiAoZXg6IFsxMDAsIDEwMCwgMjAwLCAxXSkgb2YgYSBjb2xvciB0aGF0J3MgaW4gSEVYIGZvcm1hdFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIGV4OiBGRjU1NTUgb3IgRkY1NTQ0Q0MgKFJHQmEpXG4gICAqIEByZXR1cm4ge0FycmF5fSBzb3VyY2VcbiAgICovXG4gIGZhYnJpYy5Db2xvci5zb3VyY2VGcm9tSGV4ID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICBpZiAoY29sb3IubWF0Y2goQ29sb3IucmVIZXgpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBjb2xvci5zbGljZShjb2xvci5pbmRleE9mKCcjJykgKyAxKSxcbiAgICAgICAgICBpc1Nob3J0Tm90YXRpb24gPSAodmFsdWUubGVuZ3RoID09PSAzIHx8IHZhbHVlLmxlbmd0aCA9PT0gNCksXG4gICAgICAgICAgaXNSR0JhID0gKHZhbHVlLmxlbmd0aCA9PT0gOCB8fCB2YWx1ZS5sZW5ndGggPT09IDQpLFxuICAgICAgICAgIHIgPSBpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDApICsgdmFsdWUuY2hhckF0KDApKSA6IHZhbHVlLnN1YnN0cmluZygwLCAyKSxcbiAgICAgICAgICBnID0gaXNTaG9ydE5vdGF0aW9uID8gKHZhbHVlLmNoYXJBdCgxKSArIHZhbHVlLmNoYXJBdCgxKSkgOiB2YWx1ZS5zdWJzdHJpbmcoMiwgNCksXG4gICAgICAgICAgYiA9IGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMikgKyB2YWx1ZS5jaGFyQXQoMikpIDogdmFsdWUuc3Vic3RyaW5nKDQsIDYpLFxuICAgICAgICAgIGEgPSBpc1JHQmEgPyAoaXNTaG9ydE5vdGF0aW9uID8gKHZhbHVlLmNoYXJBdCgzKSArIHZhbHVlLmNoYXJBdCgzKSkgOiB2YWx1ZS5zdWJzdHJpbmcoNiwgOCkpIDogJ0ZGJztcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgcGFyc2VJbnQociwgMTYpLFxuICAgICAgICBwYXJzZUludChnLCAxNiksXG4gICAgICAgIHBhcnNlSW50KGIsIDE2KSxcbiAgICAgICAgcGFyc2VGbG9hdCgocGFyc2VJbnQoYSwgMTYpIC8gMjU1KS50b0ZpeGVkKDIpKVxuICAgICAgXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBjb2xvciBpbiBhcnJheSByZXByZXNlbnRhdGlvbiAoZXg6IFsyMDAsIDEwMCwgMTAwLCAwLjVdKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtBcnJheX0gc291cmNlXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tU291cmNlID0gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgdmFyIG9Db2xvciA9IG5ldyBDb2xvcigpO1xuICAgIG9Db2xvci5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICByZXR1cm4gb0NvbG9yO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBzY2FsZU1hcCA9IFsnZScsICdzZScsICdzJywgJ3N3JywgJ3cnLCAnbncnLCAnbicsICduZScsICdlJ10sXG4gICAgICBza2V3TWFwID0gWyducycsICduZXN3JywgJ2V3JywgJ253c2UnXSxcbiAgICAgIGNvbnRyb2xzID0ge30sXG4gICAgICBMRUZUID0gJ2xlZnQnLCBUT1AgPSAndG9wJywgUklHSFQgPSAncmlnaHQnLCBCT1RUT00gPSAnYm90dG9tJywgQ0VOVEVSID0gJ2NlbnRlcicsXG4gICAgICBvcHBvc2l0ZSA9IHtcbiAgICAgICAgdG9wOiBCT1RUT00sXG4gICAgICAgIGJvdHRvbTogVE9QLFxuICAgICAgICBsZWZ0OiBSSUdIVCxcbiAgICAgICAgcmlnaHQ6IExFRlQsXG4gICAgICAgIGNlbnRlcjogQ0VOVEVSLFxuICAgICAgfSwgcmFkaWFuc1RvRGVncmVlcyA9IGZhYnJpYy51dGlsLnJhZGlhbnNUb0RlZ3JlZXMsXG4gICAgICBzaWduID0gKE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KSB7IHJldHVybiAoKHggPiAwKSAtICh4IDwgMCkpIHx8ICt4OyB9KTtcblxuICAvKipcbiAgICogQ29tYmluZSBjb250cm9sIHBvc2l0aW9uIGFuZCBvYmplY3QgYW5nbGUgdG8gZmluZCB0aGUgY29udHJvbCBkaXJlY3Rpb24gY29tcGFyZWRcbiAgICogdG8gdGhlIG9iamVjdCBjZW50ZXIuXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IGZvciB3aGljaCB3ZSBhcmUgcmVuZGVyaW5nIGNvbnRyb2xzXG4gICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGNvbnRyb2wgY2xhc3NcbiAgICogQHJldHVybiB7TnVtYmVyfSAwIC0gNyBhIHF1YWRyYW50IG51bWJlclxuICAgKi9cbiAgZnVuY3Rpb24gZmluZENvcm5lclF1YWRyYW50KGZhYnJpY09iamVjdCwgY29udHJvbCkge1xuICAgIHZhciBjb3JuZXJBbmdsZSA9IGZhYnJpY09iamVjdC5hbmdsZSArIHJhZGlhbnNUb0RlZ3JlZXMoTWF0aC5hdGFuMihjb250cm9sLnksIGNvbnRyb2wueCkpICsgMzYwO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKChjb3JuZXJBbmdsZSAlIDM2MCkgLyA0NSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJlRXZlbnQoZXZlbnROYW1lLCBvcHRpb25zKSB7XG4gICAgdmFyIHRhcmdldCA9IG9wdGlvbnMudHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgY2FudmFzID0gdGFyZ2V0LmNhbnZhcyxcbiAgICAgICAgY2FudmFzT3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvcHRpb25zKTtcbiAgICBjYW52YXNPcHRpb25zLnRhcmdldCA9IHRhcmdldDtcbiAgICBjYW52YXMgJiYgY2FudmFzLmZpcmUoJ29iamVjdDonICsgZXZlbnROYW1lLCBjYW52YXNPcHRpb25zKTtcbiAgICB0YXJnZXQuZmlyZShldmVudE5hbWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3BlY3QgZXZlbnQgYW5kIGZhYnJpY09iamVjdCBwcm9wZXJ0aWVzIHRvIHVuZGVyc3RhbmQgaWYgdGhlIHNjYWxpbmcgYWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBmcm9tIHRoZSB1c2VyIGFjdGlvblxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCBhYm91dCB0byBzY2FsZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNjYWxlIGlzIHByb3BvcnRpb25hbFxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVJc1Byb3BvcnRpb25hbChldmVudERhdGEsIGZhYnJpY09iamVjdCkge1xuICAgIHZhciBjYW52YXMgPSBmYWJyaWNPYmplY3QuY2FudmFzLCB1bmlTY2FsZUtleSA9IGNhbnZhcy51bmlTY2FsZUtleSxcbiAgICAgICAgdW5pZm9ybUlzVG9nZ2xlZCA9IGV2ZW50RGF0YVt1bmlTY2FsZUtleV07XG4gICAgcmV0dXJuIChjYW52YXMudW5pZm9ybVNjYWxpbmcgJiYgIXVuaWZvcm1Jc1RvZ2dsZWQpIHx8XG4gICAgKCFjYW52YXMudW5pZm9ybVNjYWxpbmcgJiYgdW5pZm9ybUlzVG9nZ2xlZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRyYW5zZm9ybSBpcyBjZW50ZXJlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIHRyYW5zZm9ybSBkYXRhXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdHJhbnNmb3JtIGlzIGNlbnRlcmVkXG4gICAqL1xuICBmdW5jdGlvbiBpc1RyYW5zZm9ybUNlbnRlcmVkKHRyYW5zZm9ybSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gQ0VOVEVSICYmIHRyYW5zZm9ybS5vcmlnaW5ZID09PSBDRU5URVI7XG4gIH1cblxuICAvKipcbiAgICogSW5zcGVjdCBmYWJyaWNPYmplY3QgdG8gdW5kZXJzdGFuZCBpZiB0aGUgY3VycmVudCBzY2FsaW5nIGFjdGlvbiBpcyBhbGxvd2VkXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IGFib3V0IHRvIHNjYWxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBieSAneCcgb3IgJ3knIG9yICcnXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2NhbGVQcm9wb3J0aW9uYWxseSB0cnVlIGlmIHdlIGFyZSB0cnlpbmcgdG8gc2NhbGUgcHJvcG9ydGlvbmFsbHlcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzY2FsaW5nIGlzIG5vdCBhbGxvd2VkIGF0IGN1cnJlbnQgY29uZGl0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGluZ0lzRm9yYmlkZGVuKGZhYnJpY09iamVjdCwgYnksIHNjYWxlUHJvcG9ydGlvbmFsbHkpIHtcbiAgICB2YXIgbG9ja1ggPSBmYWJyaWNPYmplY3QubG9ja1NjYWxpbmdYLCBsb2NrWSA9IGZhYnJpY09iamVjdC5sb2NrU2NhbGluZ1k7XG4gICAgaWYgKGxvY2tYICYmIGxvY2tZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFieSAmJiAobG9ja1ggfHwgbG9ja1kpICYmIHNjYWxlUHJvcG9ydGlvbmFsbHkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobG9ja1ggJiYgYnkgPT09ICd4Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChsb2NrWSAmJiBieSA9PT0gJ3knKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybiB0aGUgY29ycmVjdCBjdXJzb3Igc3R5bGUgZm9yIHRoZSBzY2FsZSBhY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgY2F1c2luZyB0aGUgc2NhbGVcbiAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY29udHJvbCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGEgdmFsaWQgY3NzIHN0cmluZyBmb3IgdGhlIGN1cnNvclxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVDdXJzb3JTdHlsZUhhbmRsZXIoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpIHtcbiAgICB2YXIgbm90QWxsb3dlZCA9ICdub3QtYWxsb3dlZCcsXG4gICAgICAgIHNjYWxlUHJvcG9ydGlvbmFsbHkgPSBzY2FsZUlzUHJvcG9ydGlvbmFsKGV2ZW50RGF0YSwgZmFicmljT2JqZWN0KSxcbiAgICAgICAgYnkgPSAnJztcbiAgICBpZiAoY29udHJvbC54ICE9PSAwICYmIGNvbnRyb2wueSA9PT0gMCkge1xuICAgICAgYnkgPSAneCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbnRyb2wueCA9PT0gMCAmJiBjb250cm9sLnkgIT09IDApIHtcbiAgICAgIGJ5ID0gJ3knO1xuICAgIH1cbiAgICBpZiAoc2NhbGluZ0lzRm9yYmlkZGVuKGZhYnJpY09iamVjdCwgYnksIHNjYWxlUHJvcG9ydGlvbmFsbHkpKSB7XG4gICAgICByZXR1cm4gbm90QWxsb3dlZDtcbiAgICB9XG4gICAgdmFyIG4gPSBmaW5kQ29ybmVyUXVhZHJhbnQoZmFicmljT2JqZWN0LCBjb250cm9sKTtcbiAgICByZXR1cm4gc2NhbGVNYXBbbl0gKyAnLXJlc2l6ZSc7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIHRoZSBjb3JyZWN0IGN1cnNvciBzdHlsZSBmb3IgdGhlIHNrZXcgYWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGNhdXNpbmcgdGhlIHNjYWxlXG4gICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGNvbnRyb2wgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHJldHVybiB7U3RyaW5nfSBhIHZhbGlkIGNzcyBzdHJpbmcgZm9yIHRoZSBjdXJzb3JcbiAgICovXG4gIGZ1bmN0aW9uIHNrZXdDdXJzb3JTdHlsZUhhbmRsZXIoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpIHtcbiAgICB2YXIgbm90QWxsb3dlZCA9ICdub3QtYWxsb3dlZCc7XG4gICAgaWYgKGNvbnRyb2wueCAhPT0gMCAmJiBmYWJyaWNPYmplY3QubG9ja1NrZXdpbmdZKSB7XG4gICAgICByZXR1cm4gbm90QWxsb3dlZDtcbiAgICB9XG4gICAgaWYgKGNvbnRyb2wueSAhPT0gMCAmJiBmYWJyaWNPYmplY3QubG9ja1NrZXdpbmdYKSB7XG4gICAgICByZXR1cm4gbm90QWxsb3dlZDtcbiAgICB9XG4gICAgdmFyIG4gPSBmaW5kQ29ybmVyUXVhZHJhbnQoZmFicmljT2JqZWN0LCBjb250cm9sKSAlIDQ7XG4gICAgcmV0dXJuIHNrZXdNYXBbbl0gKyAnLXJlc2l6ZSc7XG4gIH1cblxuICAvKipcbiAgICogQ29tYmluZSBza2V3IGFuZCBzY2FsZSBzdHlsZSBoYW5kbGVycyB0byBjb3ZlciBmYWJyaWMgc3RhbmRhcmQgdXNlIGNhc2VcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgY2F1c2luZyB0aGUgc2NhbGVcbiAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY29udHJvbCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGEgdmFsaWQgY3NzIHN0cmluZyBmb3IgdGhlIGN1cnNvclxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVTa2V3Q3Vyc29yU3R5bGVIYW5kbGVyKGV2ZW50RGF0YSwgY29udHJvbCwgZmFicmljT2JqZWN0KSB7XG4gICAgaWYgKGV2ZW50RGF0YVtmYWJyaWNPYmplY3QuY2FudmFzLmFsdEFjdGlvbktleV0pIHtcbiAgICAgIHJldHVybiBjb250cm9scy5za2V3Q3Vyc29yU3R5bGVIYW5kbGVyKGV2ZW50RGF0YSwgY29udHJvbCwgZmFicmljT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xzLnNjYWxlQ3Vyc29yU3R5bGVIYW5kbGVyKGV2ZW50RGF0YSwgY29udHJvbCwgZmFicmljT2JqZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNwZWN0IGV2ZW50LCBjb250cm9sIGFuZCBmYWJyaWNPYmplY3QgdG8gcmV0dXJuIHRoZSBjb3JyZWN0IGFjdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGNhdXNpbmcgdGhlIHNjYWxlXG4gICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGNvbnRyb2wgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHJldHVybiB7U3RyaW5nfSBhbiBhY3Rpb24gbmFtZVxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVPclNrZXdBY3Rpb25OYW1lKGV2ZW50RGF0YSwgY29udHJvbCwgZmFicmljT2JqZWN0KSB7XG4gICAgdmFyIGlzQWx0ZXJuYXRpdmUgPSBldmVudERhdGFbZmFicmljT2JqZWN0LmNhbnZhcy5hbHRBY3Rpb25LZXldO1xuICAgIGlmIChjb250cm9sLnggPT09IDApIHtcbiAgICAgIC8vIHRoZW4gaXMgc2NhbGVZIG9yIHNrZXdYXG4gICAgICByZXR1cm4gaXNBbHRlcm5hdGl2ZSA/ICdza2V3WCcgOiAnc2NhbGVZJztcbiAgICB9XG4gICAgaWYgKGNvbnRyb2wueSA9PT0gMCkge1xuICAgICAgLy8gdGhlbiBpcyBzY2FsZVkgb3Igc2tld1hcbiAgICAgIHJldHVybiBpc0FsdGVybmF0aXZlID8gJ3NrZXdZJyA6ICdzY2FsZVgnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBjb3JyZWN0IHN0eWxlIGZvciB0aGUgY29udHJvbCB0aGF0IGlzIHVzZWQgZm9yIHJvdGF0aW9uLlxuICAgKiB0aGlzIGZ1bmN0aW9uIGlzIHZlcnkgc2ltcGxlIGFuZCBpdCBqdXN0IHRha2UgY2FyZSBvZiBub3QtYWxsb3dlZCBvciBzdGFuZGFyZCBjdXJzb3JcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgY2F1c2luZyB0aGUgc2NhbGVcbiAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY29udHJvbCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCB0aGF0IGlzIGludGVyZXN0ZWQgaW4gdGhlIGFjdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGEgdmFsaWQgY3NzIHN0cmluZyBmb3IgdGhlIGN1cnNvclxuICAgKi9cbiAgZnVuY3Rpb24gcm90YXRpb25TdHlsZUhhbmRsZXIoZXZlbnREYXRhLCBjb250cm9sLCBmYWJyaWNPYmplY3QpIHtcbiAgICBpZiAoZmFicmljT2JqZWN0LmxvY2tSb3RhdGlvbikge1xuICAgICAgcmV0dXJuICdub3QtYWxsb3dlZCc7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9sLmN1cnNvclN0eWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbW9uRXZlbnRJbmZvKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGU6IGV2ZW50RGF0YSxcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgcG9pbnRlcjoge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogV3JhcCBhbiBhY3Rpb24gaGFuZGxlciB3aXRoIHNhdmluZy9yZXN0b3Jpbmcgb2JqZWN0IHBvc2l0aW9uIG9uIHRoZSB0cmFuc2Zvcm0uXG4gICAqIHRoaXMgaXMgdGhlIGNvZGUgdGhhdCBwZXJtaXRzIHRvIG9iamVjdHMgdG8ga2VlcCB0aGVpciBwb3NpdGlvbiB3aGlsZSB0cmFuc2Zvcm1pbmcuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbkhhbmRsZXIgdGhlIGZ1bmN0aW9uIHRvIHdyYXBcbiAgICogQHJldHVybiB7RnVuY3Rpb259IGEgZnVuY3Rpb24gd2l0aCBhbiBhY3Rpb24gaGFuZGxlciBzaWduYXR1cmVcbiAgICovXG4gIGZ1bmN0aW9uIHdyYXBXaXRoRml4ZWRBbmNob3IoYWN0aW9uSGFuZGxlcikge1xuICAgIHJldHVybiBmdW5jdGlvbihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsIGNlbnRlclBvaW50ID0gdGFyZ2V0LmdldENlbnRlclBvaW50KCksXG4gICAgICAgICAgY29uc3RyYWludCA9IHRhcmdldC50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlclBvaW50LCB0cmFuc2Zvcm0ub3JpZ2luWCwgdHJhbnNmb3JtLm9yaWdpblkpLFxuICAgICAgICAgIGFjdGlvblBlcmZvcm1lZCA9IGFjdGlvbkhhbmRsZXIoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICAgICAgdGFyZ2V0LnNldFBvc2l0aW9uQnlPcmlnaW4oY29uc3RyYWludCwgdHJhbnNmb3JtLm9yaWdpblgsIHRyYW5zZm9ybS5vcmlnaW5ZKTtcbiAgICAgIHJldHVybiBhY3Rpb25QZXJmb3JtZWQ7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwIGFuIGFjdGlvbiBoYW5kbGVyIHdpdGggZmlyaW5nIGFuIGV2ZW50IGlmIHRoZSBhY3Rpb24gaXMgcGVyZm9ybWVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbkhhbmRsZXIgdGhlIGZ1bmN0aW9uIHRvIHdyYXBcbiAgICogQHJldHVybiB7RnVuY3Rpb259IGEgZnVuY3Rpb24gd2l0aCBhbiBhY3Rpb24gaGFuZGxlciBzaWduYXR1cmVcbiAgICovXG4gIGZ1bmN0aW9uIHdyYXBXaXRoRmlyZUV2ZW50KGV2ZW50TmFtZSwgYWN0aW9uSGFuZGxlcikge1xuICAgIHJldHVybiBmdW5jdGlvbihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgICAgdmFyIGFjdGlvblBlcmZvcm1lZCA9IGFjdGlvbkhhbmRsZXIoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICAgICAgaWYgKGFjdGlvblBlcmZvcm1lZCkge1xuICAgICAgICBmaXJlRXZlbnQoZXZlbnROYW1lLCBjb21tb25FdmVudEluZm8oZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3Rpb25QZXJmb3JtZWQ7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGEgcG9pbnQgZGVzY3JpYmVkIGJ5IHggYW5kIHkgaW4gYSBkaXN0YW5jZSBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG9iamVjdFxuICAgKiBib3VuZGluZyBib3guXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblhcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpbllcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7RmFicmljLlBvaW50fSB0aGUgbm9ybWFsaXplZCBwb2ludFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIG9yaWdpblgsIG9yaWdpblksIHgsIHkpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgY29udHJvbCA9IHRhcmdldC5jb250cm9sc1t0cmFuc2Zvcm0uY29ybmVyXSxcbiAgICAgICAgem9vbSA9IHRhcmdldC5jYW52YXMuZ2V0Wm9vbSgpLFxuICAgICAgICBwYWRkaW5nID0gdGFyZ2V0LnBhZGRpbmcgLyB6b29tLFxuICAgICAgICBsb2NhbFBvaW50ID0gdGFyZ2V0LnRvTG9jYWxQb2ludChuZXcgZmFicmljLlBvaW50KHgsIHkpLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICBpZiAobG9jYWxQb2ludC54ID49IHBhZGRpbmcpIHtcbiAgICAgIGxvY2FsUG9pbnQueCAtPSBwYWRkaW5nO1xuICAgIH1cbiAgICBpZiAobG9jYWxQb2ludC54IDw9IC1wYWRkaW5nKSB7XG4gICAgICBsb2NhbFBvaW50LnggKz0gcGFkZGluZztcbiAgICB9XG4gICAgaWYgKGxvY2FsUG9pbnQueSA+PSBwYWRkaW5nKSB7XG4gICAgICBsb2NhbFBvaW50LnkgLT0gcGFkZGluZztcbiAgICB9XG4gICAgaWYgKGxvY2FsUG9pbnQueSA8PSBwYWRkaW5nKSB7XG4gICAgICBsb2NhbFBvaW50LnkgKz0gcGFkZGluZztcbiAgICB9XG4gICAgbG9jYWxQb2ludC54IC09IGNvbnRyb2wub2Zmc2V0WDtcbiAgICBsb2NhbFBvaW50LnkgLT0gY29udHJvbC5vZmZzZXRZO1xuICAgIHJldHVybiBsb2NhbFBvaW50O1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiB0aGUgZmFicmljIG9iamVjdCBpcyBmbGlwcGVkIG9uIG9uZSBzaWRlLlxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9uZSBmbGlwLCBidXQgbm90IHR3by5cbiAgICovXG4gIGZ1bmN0aW9uIHRhcmdldEhhc09uZUZsaXAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5mbGlwWCAhPT0gdGFyZ2V0LmZsaXBZO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY29tcGVuc2F0ZSB0aGUgc2NhbGUgZmFjdG9yIHdoZW4gc2tldyBpcyBhcHBsaWVkIG9uIGJvdGggYXhlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGVuc2F0ZVNjYWxlRm9yU2tldyh0YXJnZXQsIG9wcG9zaXRlU2tldywgc2NhbGVUb0NvbXBlbnNhdGUsIGF4aXMsIHJlZmVyZW5jZSkge1xuICAgIGlmICh0YXJnZXRbb3Bwb3NpdGVTa2V3XSAhPT0gMCkge1xuICAgICAgdmFyIG5ld0RpbSA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKClbYXhpc107XG4gICAgICB2YXIgbmV3VmFsdWUgPSByZWZlcmVuY2UgLyBuZXdEaW0gKiB0YXJnZXRbc2NhbGVUb0NvbXBlbnNhdGVdO1xuICAgICAgdGFyZ2V0LnNldChzY2FsZVRvQ29tcGVuc2F0ZSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBY3Rpb24gaGFuZGxlciBmb3Igc2tld2luZyBvbiB0aGUgWCBheGlzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBza2V3T2JqZWN0WChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAvLyBmaW5kIGhvdyBiaWcgdGhlIG9iamVjdCB3b3VsZCBiZSwgaWYgdGhlcmUgd2FzIG5vIHNrZXdYLiB0YWtlcyBpbiBhY2NvdW50IHNjYWxpbmdcbiAgICAgICAgZGltTm9Ta2V3ID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoMCwgdGFyZ2V0LnNrZXdZKSxcbiAgICAgICAgbG9jYWxQb2ludCA9IGdldExvY2FsUG9pbnQodHJhbnNmb3JtLCB0cmFuc2Zvcm0ub3JpZ2luWCwgdHJhbnNmb3JtLm9yaWdpblksIHgsIHkpLFxuICAgICAgICAvLyB0aGUgbW91c2UgaXMgaW4gdGhlIGNlbnRlciBvZiB0aGUgb2JqZWN0LCBhbmQgd2Ugd2FudCBpdCB0byBzdGF5IHRoZXJlLlxuICAgICAgICAvLyBzbyB0aGUgb2JqZWN0IHdpbGwgZ3JvdyB0d2ljZSBhcyBtdWNoIGFzIHRoZSBtb3VzZS5cbiAgICAgICAgLy8gdGhpcyBtYWtlcyB0aGUgc2tldyBncm93dGggdG8gbG9jYWxQb2ludCAqIDIgLSBkaW1Ob1NrZXcuXG4gICAgICAgIHRvdGFsU2tld1NpemUgPSBNYXRoLmFicyhsb2NhbFBvaW50LnggKiAyKSAtIGRpbU5vU2tldy54LFxuICAgICAgICBjdXJyZW50U2tldyA9IHRhcmdldC5za2V3WCwgbmV3U2tldztcbiAgICBpZiAodG90YWxTa2V3U2l6ZSA8IDIpIHtcbiAgICAgIC8vIGxldCdzIG1ha2UgaXQgZWFzeSB0byBnbyBiYWNrIHRvIHBvc2l0aW9uIDAuXG4gICAgICBuZXdTa2V3ID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBuZXdTa2V3ID0gcmFkaWFuc1RvRGVncmVlcyhcbiAgICAgICAgTWF0aC5hdGFuMigodG90YWxTa2V3U2l6ZSAvIHRhcmdldC5zY2FsZVgpLCAoZGltTm9Ta2V3LnkgLyB0YXJnZXQuc2NhbGVZKSlcbiAgICAgICk7XG4gICAgICAvLyBub3cgd2UgaGF2ZSB0byBmaW5kIHRoZSBzaWduIG9mIHRoZSBza2V3LlxuICAgICAgLy8gaXQgbW9zdGx5IGRlcGVuZCBvbiB0aGUgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uLlxuICAgICAgaWYgKHRyYW5zZm9ybS5vcmlnaW5YID09PSBMRUZUICYmIHRyYW5zZm9ybS5vcmlnaW5ZID09PSBCT1RUT00pIHtcbiAgICAgICAgbmV3U2tldyA9IC1uZXdTa2V3O1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybS5vcmlnaW5YID09PSBSSUdIVCAmJiB0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gVE9QKSB7XG4gICAgICAgIG5ld1NrZXcgPSAtbmV3U2tldztcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXRIYXNPbmVGbGlwKHRhcmdldCkpIHtcbiAgICAgICAgbmV3U2tldyA9IC1uZXdTa2V3O1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaGFzU2tld2VkID0gY3VycmVudFNrZXcgIT09IG5ld1NrZXc7XG4gICAgaWYgKGhhc1NrZXdlZCkge1xuICAgICAgdmFyIGRpbUJlZm9yZVNrZXdpbmcgPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLnk7XG4gICAgICB0YXJnZXQuc2V0KCdza2V3WCcsIG5ld1NrZXcpO1xuICAgICAgY29tcGVuc2F0ZVNjYWxlRm9yU2tldyh0YXJnZXQsICdza2V3WScsICdzY2FsZVknLCAneScsIGRpbUJlZm9yZVNrZXdpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzU2tld2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGlvbiBoYW5kbGVyIGZvciBza2V3aW5nIG9uIHRoZSBZIGF4aXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNrZXdPYmplY3RZKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgIC8vIGZpbmQgaG93IGJpZyB0aGUgb2JqZWN0IHdvdWxkIGJlLCBpZiB0aGVyZSB3YXMgbm8gc2tld1guIHRha2VzIGluIGFjY291bnQgc2NhbGluZ1xuICAgICAgICBkaW1Ob1NrZXcgPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucyh0YXJnZXQuc2tld1gsIDApLFxuICAgICAgICBsb2NhbFBvaW50ID0gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIHRyYW5zZm9ybS5vcmlnaW5YLCB0cmFuc2Zvcm0ub3JpZ2luWSwgeCwgeSksXG4gICAgICAgIC8vIHRoZSBtb3VzZSBpcyBpbiB0aGUgY2VudGVyIG9mIHRoZSBvYmplY3QsIGFuZCB3ZSB3YW50IGl0IHRvIHN0YXkgdGhlcmUuXG4gICAgICAgIC8vIHNvIHRoZSBvYmplY3Qgd2lsbCBncm93IHR3aWNlIGFzIG11Y2ggYXMgdGhlIG1vdXNlLlxuICAgICAgICAvLyB0aGlzIG1ha2VzIHRoZSBza2V3IGdyb3d0aCB0byBsb2NhbFBvaW50ICogMiAtIGRpbU5vU2tldy5cbiAgICAgICAgdG90YWxTa2V3U2l6ZSA9IE1hdGguYWJzKGxvY2FsUG9pbnQueSAqIDIpIC0gZGltTm9Ta2V3LnksXG4gICAgICAgIGN1cnJlbnRTa2V3ID0gdGFyZ2V0LnNrZXdZLCBuZXdTa2V3O1xuICAgIGlmICh0b3RhbFNrZXdTaXplIDwgMikge1xuICAgICAgLy8gbGV0J3MgbWFrZSBpdCBlYXN5IHRvIGdvIGJhY2sgdG8gcG9zaXRpb24gMC5cbiAgICAgIG5ld1NrZXcgPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG5ld1NrZXcgPSByYWRpYW5zVG9EZWdyZWVzKFxuICAgICAgICBNYXRoLmF0YW4yKCh0b3RhbFNrZXdTaXplIC8gdGFyZ2V0LnNjYWxlWSksIChkaW1Ob1NrZXcueCAvIHRhcmdldC5zY2FsZVgpKVxuICAgICAgKTtcbiAgICAgIC8vIG5vdyB3ZSBoYXZlIHRvIGZpbmQgdGhlIHNpZ24gb2YgdGhlIHNrZXcuXG4gICAgICAvLyBpdCBtb3N0bHkgZGVwZW5kIG9uIHRoZSBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24uXG4gICAgICBpZiAodHJhbnNmb3JtLm9yaWdpblggPT09IExFRlQgJiYgdHJhbnNmb3JtLm9yaWdpblkgPT09IEJPVFRPTSkge1xuICAgICAgICBuZXdTa2V3ID0gLW5ld1NrZXc7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtLm9yaWdpblggPT09IFJJR0hUICYmIHRyYW5zZm9ybS5vcmlnaW5ZID09PSBUT1ApIHtcbiAgICAgICAgbmV3U2tldyA9IC1uZXdTa2V3O1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldEhhc09uZUZsaXAodGFyZ2V0KSkge1xuICAgICAgICBuZXdTa2V3ID0gLW5ld1NrZXc7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBoYXNTa2V3ZWQgPSBjdXJyZW50U2tldyAhPT0gbmV3U2tldztcbiAgICBpZiAoaGFzU2tld2VkKSB7XG4gICAgICB2YXIgZGltQmVmb3JlU2tld2luZyA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCkueDtcbiAgICAgIHRhcmdldC5zZXQoJ3NrZXdZJywgbmV3U2tldyk7XG4gICAgICBjb21wZW5zYXRlU2NhbGVGb3JTa2V3KHRhcmdldCwgJ3NrZXdYJywgJ3NjYWxlWCcsICd4JywgZGltQmVmb3JlU2tld2luZyk7XG4gICAgfVxuICAgIHJldHVybiBoYXNTa2V3ZWQ7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlZCBBY3Rpb24gaGFuZGxlciBmb3Igc2tld2luZyBvbiB0aGUgWSBheGlzLCB0YWtlcyBjYXJlIG9mIHRoZVxuICAgKiBza2V3IGRpcmVjdGlvbiBhbmQgZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSBvcmlnaW4gZm9yIHRoZSBhbmNob3IgcG9pbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBza2V3SGFuZGxlclgoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICAvLyBzdGVwMSBmaWd1cmUgb3V0IGFuZCBjaGFuZ2UgdHJhbnNmb3JtIG9yaWdpbi5cbiAgICAvLyBpZiBza2V3WCA+IDAgYW5kIG9yaWdpblkgYm90dG9tIHdlIGFuY2hvciBvbiByaWdodFxuICAgIC8vIGlmIHNrZXdYID4gMCBhbmQgb3JpZ2luWSB0b3Agd2UgYW5jaG9yIG9uIGxlZnRcbiAgICAvLyBpZiBza2V3WCA8IDAgYW5kIG9yaWdpblkgYm90dG9tIHdlIGFuY2hvciBvbiBsZWZ0XG4gICAgLy8gaWYgc2tld1ggPCAwIGFuZCBvcmlnaW5ZIHRvcCB3ZSBhbmNob3Igb24gcmlnaHRcbiAgICAvLyBpZiBza2V3WCBpcyAwLCB3ZSBsb29rIGZvciBtb3VzZSBwb3NpdGlvbiB0byB1bmRlcnN0YW5kIHdoZXJlIGFyZSB3ZSBnb2luZy5cbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCwgY3VycmVudFNrZXcgPSB0YXJnZXQuc2tld1gsIG9yaWdpblgsIG9yaWdpblkgPSB0cmFuc2Zvcm0ub3JpZ2luWTtcbiAgICBpZiAodGFyZ2V0LmxvY2tTa2V3aW5nWCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFNrZXcgPT09IDApIHtcbiAgICAgIHZhciBsb2NhbFBvaW50RnJvbUNlbnRlciA9IGdldExvY2FsUG9pbnQodHJhbnNmb3JtLCBDRU5URVIsIENFTlRFUiwgeCwgeSk7XG4gICAgICBpZiAobG9jYWxQb2ludEZyb21DZW50ZXIueCA+IDApIHtcbiAgICAgICAgLy8gd2UgYXJlIHB1bGxpbmcgcmlnaHQsIGFuY2hvciBsZWZ0O1xuICAgICAgICBvcmlnaW5YID0gTEVGVDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB3ZSBhcmUgcHVsbGluZyByaWdodCwgYW5jaG9yIHJpZ2h0XG4gICAgICAgIG9yaWdpblggPSBSSUdIVDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY3VycmVudFNrZXcgPiAwKSB7XG4gICAgICAgIG9yaWdpblggPSBvcmlnaW5ZID09PSBUT1AgPyBMRUZUIDogUklHSFQ7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFNrZXcgPCAwKSB7XG4gICAgICAgIG9yaWdpblggPSBvcmlnaW5ZID09PSBUT1AgPyBSSUdIVCA6IExFRlQ7XG4gICAgICB9XG4gICAgICAvLyBpcyB0aGUgb2JqZWN0IGZsaXBwZWQgb24gb25lIHNpZGUgb25seT8gc3dhcCB0aGUgb3JpZ2luLlxuICAgICAgaWYgKHRhcmdldEhhc09uZUZsaXAodGFyZ2V0KSkge1xuICAgICAgICBvcmlnaW5YID0gb3JpZ2luWCA9PT0gTEVGVCA/IFJJR0hUIDogTEVGVDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvbmNlIHdlIGhhdmUgdGhlIG9yaWdpbiwgd2UgZmluZCB0aGUgYW5jaG9yIHBvaW50XG4gICAgdHJhbnNmb3JtLm9yaWdpblggPSBvcmlnaW5YO1xuICAgIHZhciBmaW5hbEhhbmRsZXIgPSB3cmFwV2l0aEZpcmVFdmVudCgnc2tld2luZycsIHdyYXBXaXRoRml4ZWRBbmNob3Ioc2tld09iamVjdFgpKTtcbiAgICByZXR1cm4gZmluYWxIYW5kbGVyKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVkIEFjdGlvbiBoYW5kbGVyIGZvciBza2V3aW5nIG9uIHRoZSBZIGF4aXMsIHRha2VzIGNhcmUgb2YgdGhlXG4gICAqIHNrZXcgZGlyZWN0aW9uIGFuZCBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIG9yaWdpbiBmb3IgdGhlIGFuY2hvciBwb2ludFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNrZXdIYW5kbGVyWShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIC8vIHN0ZXAxIGZpZ3VyZSBvdXQgYW5kIGNoYW5nZSB0cmFuc2Zvcm0gb3JpZ2luLlxuICAgIC8vIGlmIHNrZXdZID4gMCBhbmQgb3JpZ2luWCBsZWZ0IHdlIGFuY2hvciBvbiB0b3BcbiAgICAvLyBpZiBza2V3WSA+IDAgYW5kIG9yaWdpblggcmlnaHQgd2UgYW5jaG9yIG9uIGJvdHRvbVxuICAgIC8vIGlmIHNrZXdZIDwgMCBhbmQgb3JpZ2luWCBsZWZ0IHdlIGFuY2hvciBvbiBib3R0b21cbiAgICAvLyBpZiBza2V3WSA8IDAgYW5kIG9yaWdpblggcmlnaHQgd2UgYW5jaG9yIG9uIHRvcFxuICAgIC8vIGlmIHNrZXdZIGlzIDAsIHdlIGxvb2sgZm9yIG1vdXNlIHBvc2l0aW9uIHRvIHVuZGVyc3RhbmQgd2hlcmUgYXJlIHdlIGdvaW5nLlxuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LCBjdXJyZW50U2tldyA9IHRhcmdldC5za2V3WSwgb3JpZ2luWSwgb3JpZ2luWCA9IHRyYW5zZm9ybS5vcmlnaW5YO1xuICAgIGlmICh0YXJnZXQubG9ja1NrZXdpbmdZKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjdXJyZW50U2tldyA9PT0gMCkge1xuICAgICAgdmFyIGxvY2FsUG9pbnRGcm9tQ2VudGVyID0gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIENFTlRFUiwgQ0VOVEVSLCB4LCB5KTtcbiAgICAgIGlmIChsb2NhbFBvaW50RnJvbUNlbnRlci55ID4gMCkge1xuICAgICAgICAvLyB3ZSBhcmUgcHVsbGluZyBkb3duLCBhbmNob3IgdXA7XG4gICAgICAgIG9yaWdpblkgPSBUT1A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gd2UgYXJlIHB1bGxpbmcgdXAsIGFuY2hvciBkb3duXG4gICAgICAgIG9yaWdpblkgPSBCT1RUT007XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGN1cnJlbnRTa2V3ID4gMCkge1xuICAgICAgICBvcmlnaW5ZID0gb3JpZ2luWCA9PT0gTEVGVCA/IFRPUCA6IEJPVFRPTTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50U2tldyA8IDApIHtcbiAgICAgICAgb3JpZ2luWSA9IG9yaWdpblggPT09IExFRlQgPyBCT1RUT00gOiBUT1A7XG4gICAgICB9XG4gICAgICAvLyBpcyB0aGUgb2JqZWN0IGZsaXBwZWQgb24gb25lIHNpZGUgb25seT8gc3dhcCB0aGUgb3JpZ2luLlxuICAgICAgaWYgKHRhcmdldEhhc09uZUZsaXAodGFyZ2V0KSkge1xuICAgICAgICBvcmlnaW5ZID0gb3JpZ2luWSA9PT0gVE9QID8gQk9UVE9NIDogVE9QO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG9uY2Ugd2UgaGF2ZSB0aGUgb3JpZ2luLCB3ZSBmaW5kIHRoZSBhbmNob3IgcG9pbnRcbiAgICB0cmFuc2Zvcm0ub3JpZ2luWSA9IG9yaWdpblk7XG4gICAgdmFyIGZpbmFsSGFuZGxlciA9IHdyYXBXaXRoRmlyZUV2ZW50KCdza2V3aW5nJywgd3JhcFdpdGhGaXhlZEFuY2hvcihza2V3T2JqZWN0WSkpO1xuICAgIHJldHVybiBmaW5hbEhhbmRsZXIoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGlvbiBoYW5kbGVyIGZvciByb3RhdGlvbiBhbmQgc25hcHBpbmcsIHdpdGhvdXQgYW5jaG9yIHBvaW50LlxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHJvdGF0aW9uV2l0aFNuYXBwaW5nKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgdmFyIHQgPSB0cmFuc2Zvcm0sXG4gICAgICAgIHRhcmdldCA9IHQudGFyZ2V0LFxuICAgICAgICBwaXZvdFBvaW50ID0gdGFyZ2V0LnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQodGFyZ2V0LmdldENlbnRlclBvaW50KCksIHQub3JpZ2luWCwgdC5vcmlnaW5ZKTtcblxuICAgIGlmICh0YXJnZXQubG9ja1JvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxhc3RBbmdsZSA9IE1hdGguYXRhbjIodC5leSAtIHBpdm90UG9pbnQueSwgdC5leCAtIHBpdm90UG9pbnQueCksXG4gICAgICAgIGN1ckFuZ2xlID0gTWF0aC5hdGFuMih5IC0gcGl2b3RQb2ludC55LCB4IC0gcGl2b3RQb2ludC54KSxcbiAgICAgICAgYW5nbGUgPSByYWRpYW5zVG9EZWdyZWVzKGN1ckFuZ2xlIC0gbGFzdEFuZ2xlICsgdC50aGV0YSksXG4gICAgICAgIGhhc1JvdGF0ZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRhcmdldC5zbmFwQW5nbGUgPiAwKSB7XG4gICAgICB2YXIgc25hcEFuZ2xlICA9IHRhcmdldC5zbmFwQW5nbGUsXG4gICAgICAgICAgc25hcFRocmVzaG9sZCAgPSB0YXJnZXQuc25hcFRocmVzaG9sZCB8fCBzbmFwQW5nbGUsXG4gICAgICAgICAgcmlnaHRBbmdsZUxvY2tlZCA9IE1hdGguY2VpbChhbmdsZSAvIHNuYXBBbmdsZSkgKiBzbmFwQW5nbGUsXG4gICAgICAgICAgbGVmdEFuZ2xlTG9ja2VkID0gTWF0aC5mbG9vcihhbmdsZSAvIHNuYXBBbmdsZSkgKiBzbmFwQW5nbGU7XG5cbiAgICAgIGlmIChNYXRoLmFicyhhbmdsZSAtIGxlZnRBbmdsZUxvY2tlZCkgPCBzbmFwVGhyZXNob2xkKSB7XG4gICAgICAgIGFuZ2xlID0gbGVmdEFuZ2xlTG9ja2VkO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoYW5nbGUgLSByaWdodEFuZ2xlTG9ja2VkKSA8IHNuYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgYW5nbGUgPSByaWdodEFuZ2xlTG9ja2VkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSBhbmdsZSB0byBwb3NpdGl2ZSB2YWx1ZVxuICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgIGFuZ2xlID0gMzYwICsgYW5nbGU7XG4gICAgfVxuICAgIGFuZ2xlICU9IDM2MDtcblxuICAgIGhhc1JvdGF0ZWQgPSB0YXJnZXQuYW5nbGUgIT09IGFuZ2xlO1xuICAgIHRhcmdldC5hbmdsZSA9IGFuZ2xlO1xuICAgIHJldHVybiBoYXNSb3RhdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhc2ljIHNjYWxpbmcgbG9naWMsIHJldXNlZCB3aXRoIGRpZmZlcmVudCBjb25zdHJhaW4gZm9yIHNjYWxpbmcgWCxZLCBmcmVlbHkgb3IgZXF1YWxseS5cbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBzY2FsaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmJ5ICd4JywgJ3knLCAnZXF1YWxseScgb3IgJycgdG8gaW5kaWNhdGUgdHlwZSBvZiBzY2FsaW5nXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlT2JqZWN0KGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgIGxvY2tTY2FsaW5nWCA9IHRhcmdldC5sb2NrU2NhbGluZ1gsIGxvY2tTY2FsaW5nWSA9IHRhcmdldC5sb2NrU2NhbGluZ1ksXG4gICAgICAgIGJ5ID0gb3B0aW9ucy5ieSwgbmV3UG9pbnQsIHNjYWxlWCwgc2NhbGVZLCBkaW0sXG4gICAgICAgIHNjYWxlUHJvcG9ydGlvbmFsbHkgPSBzY2FsZUlzUHJvcG9ydGlvbmFsKGV2ZW50RGF0YSwgdGFyZ2V0KSxcbiAgICAgICAgZm9yYmlkU2NhbGluZyA9IHNjYWxpbmdJc0ZvcmJpZGRlbih0YXJnZXQsIGJ5LCBzY2FsZVByb3BvcnRpb25hbGx5KSxcbiAgICAgICAgc2lnblgsIHNpZ25ZLCBnZXN0dXJlU2NhbGUgPSB0cmFuc2Zvcm0uZ2VzdHVyZVNjYWxlO1xuXG4gICAgaWYgKGZvcmJpZFNjYWxpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGdlc3R1cmVTY2FsZSkge1xuICAgICAgc2NhbGVYID0gdHJhbnNmb3JtLnNjYWxlWCAqIGdlc3R1cmVTY2FsZTtcbiAgICAgIHNjYWxlWSA9IHRyYW5zZm9ybS5zY2FsZVkgKiBnZXN0dXJlU2NhbGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbmV3UG9pbnQgPSBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgdHJhbnNmb3JtLm9yaWdpblgsIHRyYW5zZm9ybS5vcmlnaW5ZLCB4LCB5KTtcbiAgICAgIC8vIHVzZSBvZiBzaWduOiBXZSB1c2Ugc2lnbiB0byBkZXRlY3QgY2hhbmdlIG9mIGRpcmVjdGlvbiBvZiBhbiBhY3Rpb24uIHNpZ24gdXN1YWxseSBjaGFuZ2Ugd2hlblxuICAgICAgLy8gd2UgY3Jvc3MgdGhlIG9yaWdpbiBwb2ludCB3aXRoIHRoZSBtb3VzZS4gU28gYSBzY2FsZSBmbGlwIGZvciBleGFtcGxlLiBUaGVyZSBpcyBhbiBpc3N1ZSB3aGVuIHNjYWxpbmdcbiAgICAgIC8vIGJ5IGNlbnRlciBhbmQgc2NhbGluZyB1c2luZyBvbmUgbWlkZGxlIGNvbnRyb2wgKCBkZWZhdWx0OiBtciwgbXQsIG1sLCBtYiksIHRoZSBtb3VzZSBtb3ZlbWVudCBjYW4gZWFzaWx5XG4gICAgICAvLyBjcm9zcyBtYW55IHRpbWUgdGhlIG9yaWdpbiBwb2ludCBhbmQgZmxpcCB0aGUgb2JqZWN0LiBzbyB3ZSBuZWVkIGEgd2F5IHRvIGZpbHRlciBvdXQgdGhlIG5vaXNlLlxuICAgICAgLy8gVGhpcyB0ZXJuYXJ5IGhlcmUgc2hvdWxkIGJlIG9rIHRvIGZpbHRlciBvdXQgWCBzY2FsaW5nIHdoZW4gd2Ugd2FudCBZIG9ubHkgYW5kIHZpY2UgdmVyc2EuXG4gICAgICBzaWduWCA9IGJ5ICE9PSAneScgPyBzaWduKG5ld1BvaW50LngpIDogMTtcbiAgICAgIHNpZ25ZID0gYnkgIT09ICd4JyA/IHNpZ24obmV3UG9pbnQueSkgOiAxO1xuICAgICAgaWYgKCF0cmFuc2Zvcm0uc2lnblgpIHtcbiAgICAgICAgdHJhbnNmb3JtLnNpZ25YID0gc2lnblg7XG4gICAgICB9XG4gICAgICBpZiAoIXRyYW5zZm9ybS5zaWduWSkge1xuICAgICAgICB0cmFuc2Zvcm0uc2lnblkgPSBzaWduWTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldC5sb2NrU2NhbGluZ0ZsaXAgJiZcbiAgICAgICAgKHRyYW5zZm9ybS5zaWduWCAhPT0gc2lnblggfHwgdHJhbnNmb3JtLnNpZ25ZICE9PSBzaWduWSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGRpbSA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG4gICAgICAvLyBtaXNzaW5nIGRldGVjdGlvbiBvZiBmbGlwIGFuZCBsb2dpYyB0byBzd2l0Y2ggdGhlIG9yaWdpblxuICAgICAgaWYgKHNjYWxlUHJvcG9ydGlvbmFsbHkgJiYgIWJ5KSB7XG4gICAgICAgIC8vIHVuaWZvcm0gc2NhbGluZ1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLmFicyhuZXdQb2ludC54KSArIE1hdGguYWJzKG5ld1BvaW50LnkpLFxuICAgICAgICAgICAgb3JpZ2luYWwgPSB0cmFuc2Zvcm0ub3JpZ2luYWwsXG4gICAgICAgICAgICBvcmlnaW5hbERpc3RhbmNlID0gTWF0aC5hYnMoZGltLnggKiBvcmlnaW5hbC5zY2FsZVggLyB0YXJnZXQuc2NhbGVYKSArXG4gICAgICAgICAgICAgIE1hdGguYWJzKGRpbS55ICogb3JpZ2luYWwuc2NhbGVZIC8gdGFyZ2V0LnNjYWxlWSksXG4gICAgICAgICAgICBzY2FsZSA9IGRpc3RhbmNlIC8gb3JpZ2luYWxEaXN0YW5jZTtcbiAgICAgICAgc2NhbGVYID0gb3JpZ2luYWwuc2NhbGVYICogc2NhbGU7XG4gICAgICAgIHNjYWxlWSA9IG9yaWdpbmFsLnNjYWxlWSAqIHNjYWxlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNjYWxlWCA9IE1hdGguYWJzKG5ld1BvaW50LnggKiB0YXJnZXQuc2NhbGVYIC8gZGltLngpO1xuICAgICAgICBzY2FsZVkgPSBNYXRoLmFicyhuZXdQb2ludC55ICogdGFyZ2V0LnNjYWxlWSAvIGRpbS55KTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlIGFyZSBzY2FsaW5nIGJ5IGNlbnRlciwgd2UgbmVlZCB0byBkb3VibGUgdGhlIHNjYWxlXG4gICAgICBpZiAoaXNUcmFuc2Zvcm1DZW50ZXJlZCh0cmFuc2Zvcm0pKSB7XG4gICAgICAgIHNjYWxlWCAqPSAyO1xuICAgICAgICBzY2FsZVkgKj0gMjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm0uc2lnblggIT09IHNpZ25YICYmIGJ5ICE9PSAneScpIHtcbiAgICAgICAgdHJhbnNmb3JtLm9yaWdpblggPSBvcHBvc2l0ZVt0cmFuc2Zvcm0ub3JpZ2luWF07XG4gICAgICAgIHNjYWxlWCAqPSAtMTtcbiAgICAgICAgdHJhbnNmb3JtLnNpZ25YID0gc2lnblg7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtLnNpZ25ZICE9PSBzaWduWSAmJiBieSAhPT0gJ3gnKSB7XG4gICAgICAgIHRyYW5zZm9ybS5vcmlnaW5ZID0gb3Bwb3NpdGVbdHJhbnNmb3JtLm9yaWdpblldO1xuICAgICAgICBzY2FsZVkgKj0gLTE7XG4gICAgICAgIHRyYW5zZm9ybS5zaWduWSA9IHNpZ25ZO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBtaW5TY2FsZSBpcyB0YWtlbiBhcmUgaW4gdGhlIHNldHRlci5cbiAgICB2YXIgb2xkU2NhbGVYID0gdGFyZ2V0LnNjYWxlWCwgb2xkU2NhbGVZID0gdGFyZ2V0LnNjYWxlWTtcbiAgICBpZiAoIWJ5KSB7XG4gICAgICAhbG9ja1NjYWxpbmdYICYmIHRhcmdldC5zZXQoJ3NjYWxlWCcsIHNjYWxlWCk7XG4gICAgICAhbG9ja1NjYWxpbmdZICYmIHRhcmdldC5zZXQoJ3NjYWxlWScsIHNjYWxlWSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gZm9yYmlkZGVuIGNhc2VzIGFscmVhZHkgaGFuZGxlZCBvbiB0b3AgaGVyZS5cbiAgICAgIGJ5ID09PSAneCcgJiYgdGFyZ2V0LnNldCgnc2NhbGVYJywgc2NhbGVYKTtcbiAgICAgIGJ5ID09PSAneScgJiYgdGFyZ2V0LnNldCgnc2NhbGVZJywgc2NhbGVZKTtcbiAgICB9XG4gICAgcmV0dXJuIG9sZFNjYWxlWCAhPT0gdGFyZ2V0LnNjYWxlWCB8fCBvbGRTY2FsZVkgIT09IHRhcmdldC5zY2FsZVk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJpYyBzY2FsaW5nIGxvZ2ljLCB0byBzY2FsZSBmcm9tIGNvcm5lcnMgZWl0aGVyIGVxdWFsbHkgb3IgZnJlZWx5LlxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlT2JqZWN0RnJvbUNvcm5lcihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHJldHVybiBzY2FsZU9iamVjdChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gIH1cblxuICAvKipcbiAgICogU2NhbGluZyBsb2dpYyBmb3IgdGhlIFggYXhpcy5cbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZU9iamVjdFgoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICByZXR1cm4gc2NhbGVPYmplY3QoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkgLCB7IGJ5OiAneCcgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2NhbGluZyBsb2dpYyBmb3IgdGhlIFkgYXhpcy5cbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZU9iamVjdFkoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICByZXR1cm4gc2NhbGVPYmplY3QoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkgLCB7IGJ5OiAneScgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcG9zZWQgYWN0aW9uIGhhbmRsZXIgdG8gZWl0aGVyIHNjYWxlIFkgb3Igc2tldyBYXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGluZ1lPclNrZXdpbmdYKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgLy8gb2sgc29tZSBzYWZldHkgbmVlZGVkIGhlcmUuXG4gICAgaWYgKGV2ZW50RGF0YVt0cmFuc2Zvcm0udGFyZ2V0LmNhbnZhcy5hbHRBY3Rpb25LZXldKSB7XG4gICAgICByZXR1cm4gY29udHJvbHMuc2tld0hhbmRsZXJYKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xzLnNjYWxpbmdZKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wb3NlZCBhY3Rpb24gaGFuZGxlciB0byBlaXRoZXIgc2NhbGUgWCBvciBza2V3IFlcbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsaW5nWE9yU2tld2luZ1koZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICAvLyBvayBzb21lIHNhZmV0eSBuZWVkZWQgaGVyZS5cbiAgICBpZiAoZXZlbnREYXRhW3RyYW5zZm9ybS50YXJnZXQuY2FudmFzLmFsdEFjdGlvbktleV0pIHtcbiAgICAgIHJldHVybiBjb250cm9scy5za2V3SGFuZGxlclkoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJvbHMuc2NhbGluZ1goZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGlvbiBoYW5kbGVyIHRvIGNoYW5nZSB0ZXh0Ym94IHdpZHRoXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gY2hhbmdlV2lkdGgoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCwgbG9jYWxQb2ludCA9IGdldExvY2FsUG9pbnQodHJhbnNmb3JtLCB0cmFuc2Zvcm0ub3JpZ2luWCwgdHJhbnNmb3JtLm9yaWdpblksIHgsIHkpLFxuICAgICAgICBzdHJva2VQYWRkaW5nID0gdGFyZ2V0LnN0cm9rZVdpZHRoIC8gKHRhcmdldC5zdHJva2VVbmlmb3JtID8gdGFyZ2V0LnNjYWxlWCA6IDEpLFxuICAgICAgICBtdWx0aXBsaWVyID0gaXNUcmFuc2Zvcm1DZW50ZXJlZCh0cmFuc2Zvcm0pID8gMiA6IDEsXG4gICAgICAgIG9sZFdpZHRoID0gdGFyZ2V0LndpZHRoLFxuICAgICAgICBuZXdXaWR0aCA9IE1hdGguYWJzKGxvY2FsUG9pbnQueCAqIG11bHRpcGxpZXIgLyB0YXJnZXQuc2NhbGVYKSAtIHN0cm9rZVBhZGRpbmc7XG4gICAgdGFyZ2V0LnNldCgnd2lkdGgnLCBNYXRoLm1heChuZXdXaWR0aCwgMCkpO1xuICAgIHJldHVybiBvbGRXaWR0aCAhPT0gbmV3V2lkdGg7XG4gIH1cblxuICAvKipcbiAgICogQWN0aW9uIGhhbmRsZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSB0cmFuc2xhdGlvbiBvY2N1cnJlZFxuICAgKi9cbiAgZnVuY3Rpb24gZHJhZ0hhbmRsZXIoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgbmV3TGVmdCA9IHggLSB0cmFuc2Zvcm0ub2Zmc2V0WCxcbiAgICAgICAgbmV3VG9wID0geSAtIHRyYW5zZm9ybS5vZmZzZXRZLFxuICAgICAgICBtb3ZlWCA9ICF0YXJnZXQuZ2V0KCdsb2NrTW92ZW1lbnRYJykgJiYgdGFyZ2V0LmxlZnQgIT09IG5ld0xlZnQsXG4gICAgICAgIG1vdmVZID0gIXRhcmdldC5nZXQoJ2xvY2tNb3ZlbWVudFknKSAmJiB0YXJnZXQudG9wICE9PSBuZXdUb3A7XG4gICAgbW92ZVggJiYgdGFyZ2V0LnNldCgnbGVmdCcsIG5ld0xlZnQpO1xuICAgIG1vdmVZICYmIHRhcmdldC5zZXQoJ3RvcCcsIG5ld1RvcCk7XG4gICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICBmaXJlRXZlbnQoJ21vdmluZycsIGNvbW1vbkV2ZW50SW5mbyhldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkpO1xuICAgIH1cbiAgICByZXR1cm4gbW92ZVggfHwgbW92ZVk7XG4gIH1cblxuICBjb250cm9scy5zY2FsZUN1cnNvclN0eWxlSGFuZGxlciA9IHNjYWxlQ3Vyc29yU3R5bGVIYW5kbGVyO1xuICBjb250cm9scy5za2V3Q3Vyc29yU3R5bGVIYW5kbGVyID0gc2tld0N1cnNvclN0eWxlSGFuZGxlcjtcbiAgY29udHJvbHMuc2NhbGVTa2V3Q3Vyc29yU3R5bGVIYW5kbGVyID0gc2NhbGVTa2V3Q3Vyc29yU3R5bGVIYW5kbGVyO1xuICBjb250cm9scy5yb3RhdGlvbldpdGhTbmFwcGluZyA9IHdyYXBXaXRoRmlyZUV2ZW50KCdyb3RhdGluZycsIHdyYXBXaXRoRml4ZWRBbmNob3Iocm90YXRpb25XaXRoU25hcHBpbmcpKTtcbiAgY29udHJvbHMuc2NhbGluZ0VxdWFsbHkgPSB3cmFwV2l0aEZpcmVFdmVudCgnc2NhbGluZycsIHdyYXBXaXRoRml4ZWRBbmNob3IoIHNjYWxlT2JqZWN0RnJvbUNvcm5lcikpO1xuICBjb250cm9scy5zY2FsaW5nWCA9IHdyYXBXaXRoRmlyZUV2ZW50KCdzY2FsaW5nJywgd3JhcFdpdGhGaXhlZEFuY2hvcihzY2FsZU9iamVjdFgpKTtcbiAgY29udHJvbHMuc2NhbGluZ1kgPSB3cmFwV2l0aEZpcmVFdmVudCgnc2NhbGluZycsIHdyYXBXaXRoRml4ZWRBbmNob3Ioc2NhbGVPYmplY3RZKSk7XG4gIGNvbnRyb2xzLnNjYWxpbmdZT3JTa2V3aW5nWCA9IHNjYWxpbmdZT3JTa2V3aW5nWDtcbiAgY29udHJvbHMuc2NhbGluZ1hPclNrZXdpbmdZID0gc2NhbGluZ1hPclNrZXdpbmdZO1xuICBjb250cm9scy5jaGFuZ2VXaWR0aCA9IHdyYXBXaXRoRmlyZUV2ZW50KCdyZXNpemluZycsIHdyYXBXaXRoRml4ZWRBbmNob3IoY2hhbmdlV2lkdGgpKTtcbiAgY29udHJvbHMuc2tld0hhbmRsZXJYID0gc2tld0hhbmRsZXJYO1xuICBjb250cm9scy5za2V3SGFuZGxlclkgPSBza2V3SGFuZGxlclk7XG4gIGNvbnRyb2xzLmRyYWdIYW5kbGVyID0gZHJhZ0hhbmRsZXI7XG4gIGNvbnRyb2xzLnNjYWxlT3JTa2V3QWN0aW9uTmFtZSA9IHNjYWxlT3JTa2V3QWN0aW9uTmFtZTtcbiAgY29udHJvbHMucm90YXRpb25TdHlsZUhhbmRsZXIgPSByb3RhdGlvblN0eWxlSGFuZGxlcjtcbiAgY29udHJvbHMuZmlyZUV2ZW50ID0gZmlyZUV2ZW50O1xuICBjb250cm9scy53cmFwV2l0aEZpeGVkQW5jaG9yID0gd3JhcFdpdGhGaXhlZEFuY2hvcjtcbiAgY29udHJvbHMud3JhcFdpdGhGaXJlRXZlbnQgPSB3cmFwV2l0aEZpcmVFdmVudDtcbiAgY29udHJvbHMuZ2V0TG9jYWxQb2ludCA9IGdldExvY2FsUG9pbnQ7XG4gIGZhYnJpYy5jb250cm9sc1V0aWxzID0gY29udHJvbHM7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgY29udHJvbHMgPSBmYWJyaWMuY29udHJvbHNVdGlscztcblxuICAvKipcbiAgICogUmVuZGVyIGEgcm91bmQgY29udHJvbCwgYXMgcGVyIGZhYnJpYyBmZWF0dXJlcy5cbiAgICogVGhpcyBmdW5jdGlvbiBpcyB3cml0dGVuIHRvIHJlc3BlY3Qgb2JqZWN0IHByb3BlcnRpZXMgbGlrZSB0cmFuc3BhcmVudENvcm5lcnMsIGNvcm5lclNpemVcbiAgICogY29ybmVyQ29sb3IsIGNvcm5lclN0cm9rZUNvbG9yXG4gICAqIHBsdXMgdGhlIGFkZGl0aW9uIG9mIG9mZnNldFkgYW5kIG9mZnNldFguXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgeCBjb29yZGluYXRlIHdoZXJlIHRoZSBjb250cm9sIGNlbnRlciBzaG91bGQgYmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCB5IGNvb3JkaW5hdGUgd2hlcmUgdGhlIGNvbnRyb2wgY2VudGVyIHNob3VsZCBiZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPdmVycmlkZSBvdmVycmlkZSBmb3IgZmFicmljLk9iamVjdCBjb250cm9scyBzdHlsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCBmb3Igd2hpY2ggd2UgYXJlIHJlbmRlcmluZyBjb250cm9sc1xuICAgKi9cbiAgZnVuY3Rpb24gcmVuZGVyQ2lyY2xlQ29udHJvbCAoY3R4LCBsZWZ0LCB0b3AsIHN0eWxlT3ZlcnJpZGUsIGZhYnJpY09iamVjdCkge1xuICAgIHN0eWxlT3ZlcnJpZGUgPSBzdHlsZU92ZXJyaWRlIHx8IHt9O1xuICAgIHZhciB4U2l6ZSA9IHRoaXMuc2l6ZVggfHwgc3R5bGVPdmVycmlkZS5jb3JuZXJTaXplIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTaXplLFxuICAgICAgICB5U2l6ZSA9IHRoaXMuc2l6ZVkgfHwgc3R5bGVPdmVycmlkZS5jb3JuZXJTaXplIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTaXplLFxuICAgICAgICB0cmFuc3BhcmVudENvcm5lcnMgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS50cmFuc3BhcmVudENvcm5lcnMgIT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgICBzdHlsZU92ZXJyaWRlLnRyYW5zcGFyZW50Q29ybmVycyA6IGZhYnJpY09iamVjdC50cmFuc3BhcmVudENvcm5lcnMsXG4gICAgICAgIG1ldGhvZE5hbWUgPSB0cmFuc3BhcmVudENvcm5lcnMgPyAnc3Ryb2tlJyA6ICdmaWxsJyxcbiAgICAgICAgc3Ryb2tlID0gIXRyYW5zcGFyZW50Q29ybmVycyAmJiAoc3R5bGVPdmVycmlkZS5jb3JuZXJTdHJva2VDb2xvciB8fCBmYWJyaWNPYmplY3QuY29ybmVyU3Ryb2tlQ29sb3IpLFxuICAgICAgICBteUxlZnQgPSBsZWZ0LFxuICAgICAgICBteVRvcCA9IHRvcCwgc2l6ZTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmNvcm5lckNvbG9yIHx8IGZhYnJpY09iamVjdC5jb3JuZXJDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmNvcm5lclN0cm9rZUNvbG9yIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTdHJva2VDb2xvcjtcbiAgICAvLyBhcyBzb29uIGFzIGZhYnJpYyByZWFjdCB2NSwgcmVtb3ZlIGllMTEsIHVzZSBwcm9wZXIgZWxsaXBzZSBjb2RlLlxuICAgIGlmICh4U2l6ZSA+IHlTaXplKSB7XG4gICAgICBzaXplID0geFNpemU7XG4gICAgICBjdHguc2NhbGUoMS4wLCB5U2l6ZSAvIHhTaXplKTtcbiAgICAgIG15VG9wID0gdG9wICogeFNpemUgLyB5U2l6ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeVNpemUgPiB4U2l6ZSkge1xuICAgICAgc2l6ZSA9IHlTaXplO1xuICAgICAgY3R4LnNjYWxlKHhTaXplIC8geVNpemUsIDEuMCk7XG4gICAgICBteUxlZnQgPSBsZWZ0ICogeVNpemUgLyB4U2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzaXplID0geFNpemU7XG4gICAgfVxuICAgIC8vIHRoaXMgaXMgc3RpbGwgd3JvbmdcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyhteUxlZnQsIG15VG9wLCBzaXplIC8gMiwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICBjdHhbbWV0aG9kTmFtZV0oKTtcbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgc3F1YXJlIGNvbnRyb2wsIGFzIHBlciBmYWJyaWMgZmVhdHVyZXMuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgd3JpdHRlbiB0byByZXNwZWN0IG9iamVjdCBwcm9wZXJ0aWVzIGxpa2UgdHJhbnNwYXJlbnRDb3JuZXJzLCBjb3JuZXJTaXplXG4gICAqIGNvcm5lckNvbG9yLCBjb3JuZXJTdHJva2VDb2xvclxuICAgKiBwbHVzIHRoZSBhZGRpdGlvbiBvZiBvZmZzZXRZIGFuZCBvZmZzZXRYLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IHggY29vcmRpbmF0ZSB3aGVyZSB0aGUgY29udHJvbCBjZW50ZXIgc2hvdWxkIGJlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgeSBjb29yZGluYXRlIHdoZXJlIHRoZSBjb250cm9sIGNlbnRlciBzaG91bGQgYmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb3ZlcnJpZGUgZm9yIGZhYnJpYy5PYmplY3QgY29udHJvbHMgc3R5bGVcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgZm9yIHdoaWNoIHdlIGFyZSByZW5kZXJpbmcgY29udHJvbHNcbiAgICovXG4gIGZ1bmN0aW9uIHJlbmRlclNxdWFyZUNvbnRyb2woY3R4LCBsZWZ0LCB0b3AsIHN0eWxlT3ZlcnJpZGUsIGZhYnJpY09iamVjdCkge1xuICAgIHN0eWxlT3ZlcnJpZGUgPSBzdHlsZU92ZXJyaWRlIHx8IHt9O1xuICAgIHZhciB4U2l6ZSA9IHRoaXMuc2l6ZVggfHwgc3R5bGVPdmVycmlkZS5jb3JuZXJTaXplIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTaXplLFxuICAgICAgICB5U2l6ZSA9IHRoaXMuc2l6ZVkgfHwgc3R5bGVPdmVycmlkZS5jb3JuZXJTaXplIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTaXplLFxuICAgICAgICB0cmFuc3BhcmVudENvcm5lcnMgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS50cmFuc3BhcmVudENvcm5lcnMgIT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgICBzdHlsZU92ZXJyaWRlLnRyYW5zcGFyZW50Q29ybmVycyA6IGZhYnJpY09iamVjdC50cmFuc3BhcmVudENvcm5lcnMsXG4gICAgICAgIG1ldGhvZE5hbWUgPSB0cmFuc3BhcmVudENvcm5lcnMgPyAnc3Ryb2tlJyA6ICdmaWxsJyxcbiAgICAgICAgc3Ryb2tlID0gIXRyYW5zcGFyZW50Q29ybmVycyAmJiAoXG4gICAgICAgICAgc3R5bGVPdmVycmlkZS5jb3JuZXJTdHJva2VDb2xvciB8fCBmYWJyaWNPYmplY3QuY29ybmVyU3Ryb2tlQ29sb3JcbiAgICAgICAgKSwgeFNpemVCeTIgPSB4U2l6ZSAvIDIsIHlTaXplQnkyID0geVNpemUgLyAyO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyQ29sb3IgfHwgZmFicmljT2JqZWN0LmNvcm5lckNvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyU3Ryb2tlQ29sb3IgfHwgZmFicmljT2JqZWN0LmNvcm5lclN0cm9rZUNvbG9yO1xuICAgIC8vIHRoaXMgaXMgc3RpbGwgd3JvbmdcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICBjdHgudHJhbnNsYXRlKGxlZnQsIHRvcCk7XG4gICAgY3R4LnJvdGF0ZShkZWdyZWVzVG9SYWRpYW5zKGZhYnJpY09iamVjdC5hbmdsZSkpO1xuICAgIC8vIHRoaXMgZG9lcyBub3Qgd29yaywgYW5kIGZpeGVkIHdpdGggKCAmJiApIGRvZXMgbm90IG1ha2Ugc2Vuc2UuXG4gICAgLy8gdG8gaGF2ZSByZWFsIHRyYW5zcGFyZW50IGNvcm5lcnMgd2UgbmVlZCB0aGUgY29udHJvbHMgb24gdXBwZXJDYW52YXNcbiAgICAvLyB0cmFuc3BhcmVudENvcm5lcnMgfHwgY3R4LmNsZWFyUmVjdCgteFNpemVCeTIsIC15U2l6ZUJ5MiwgeFNpemUsIHlTaXplKTtcbiAgICBjdHhbbWV0aG9kTmFtZSArICdSZWN0J10oLXhTaXplQnkyLCAteVNpemVCeTIsIHhTaXplLCB5U2l6ZSk7XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgY3R4LnN0cm9rZVJlY3QoLXhTaXplQnkyLCAteVNpemVCeTIsIHhTaXplLCB5U2l6ZSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICBjb250cm9scy5yZW5kZXJDaXJjbGVDb250cm9sID0gcmVuZGVyQ2lyY2xlQ29udHJvbDtcbiAgY29udHJvbHMucmVuZGVyU3F1YXJlQ29udHJvbCA9IHJlbmRlclNxdWFyZUNvbnRyb2w7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBmdW5jdGlvbiBDb250cm9sKG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXNbaV0gPSBvcHRpb25zW2ldO1xuICAgIH1cbiAgfVxuXG4gIGZhYnJpYy5Db250cm9sID0gQ29udHJvbDtcblxuICBmYWJyaWMuQ29udHJvbC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5Db250cm9sLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBrZWVwIHRyYWNrIG9mIGNvbnRyb2wgdmlzaWJpbGl0eS5cbiAgICAgKiBtYWlubHkgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICogaWYgeW91IGRvIG5vdCB3YW50IHRvIHNlZSBhIGNvbnRyb2wsIHlvdSBjYW4gcmVtb3ZlIGl0XG4gICAgICogZnJvbSB0aGUgY29udHJvbHNldC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdmlzaWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIGFjdGlvbiB0aGF0IHRoZSBjb250cm9sIHdpbGwgbGlrZWx5IGV4ZWN1dGUuXG4gICAgICogVGhpcyBpcyBvcHRpb25hbC4gRmFicmljSlMgdXNlcyB0byBpZGVudGlmeSB3aGF0IHRoZSB1c2VyIGlzIGRvaW5nIGZvciBzb21lXG4gICAgICogZXh0cmEgb3B0aW1pemF0aW9ucy4gSWYgeW91IGFyZSB3cml0aW5nIGEgY3VzdG9tIGNvbnRyb2wgYW5kIHlvdSB3YW50IHRvIGtub3dcbiAgICAgKiBzb21ld2hlcmUgZWxzZSBpbiB0aGUgY29kZSB3aGF0IGlzIGdvaW5nIG9uLCB5b3UgY2FuIHVzZSB0aGlzIHN0cmluZyBoZXJlLlxuICAgICAqIHlvdSBjYW4gYWxzbyBwcm92aWRlIGEgY3VzdG9tIGdldEFjdGlvbk5hbWUgaWYgeW91ciBjb250cm9sIHJ1biBtdWx0aXBsZSBhY3Rpb25zXG4gICAgICogZGVwZW5kaW5nIG9uIHNvbWUgZXh0ZXJuYWwgc3RhdGUuXG4gICAgICogZGVmYXVsdCB0byBzY2FsZSBzaW5jZSBpcyB0aGUgbW9zdCBjb21tb24sIHVzZWQgb24gNCBjb3JuZXJzIGJ5IGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdzY2FsZSdcbiAgICAgKi9cbiAgICBhY3Rpb25OYW1lOiAnc2NhbGUnLFxuXG4gICAgLyoqXG4gICAgICogRHJhd2luZyBhbmdsZSBvZiB0aGUgY29udHJvbC5cbiAgICAgKiBOT1QgdXNlZCBmb3Igbm93LCBidXQgbmFtZSBtYXJrZWQgYXMgbmVlZGVkIGZvciBpbnRlcm5hbCBsb2dpY1xuICAgICAqIGV4YW1wbGU6IHRvIHJldXNlIHRoZSBzYW1lIGRyYXdpbmcgZnVuY3Rpb24gZm9yIGRpZmZlcmVudCByb3RhdGVkIGNvbnRyb2xzXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgYW5nbGU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC4gWFxuICAgICAqIDAsMCBpcyB0aGUgY2VudGVyIG9mIHRoZSBPYmplY3QsIHdoaWxlIC0wLjUgKGxlZnQpIG9yIDAuNSAocmlnaHQpIGFyZSB0aGUgZXh0cmVtaXRpZXNcbiAgICAgKiBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbC4gWVxuICAgICAqIDAsMCBpcyB0aGUgY2VudGVyIG9mIHRoZSBPYmplY3QsIHdoaWxlIC0wLjUgKHRvcCkgb3IgMC41IChib3R0b20pIGFyZSB0aGUgZXh0cmVtaXRpZXNcbiAgICAgKiBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIG9mZnNldCBvZiB0aGUgY29udHJvbCBmcm9tIHRoZSBkZWZpbmVkIHBvc2l0aW9uLiBJbiBwaXhlbHNcbiAgICAgKiBQb3NpdGl2ZSBvZmZzZXQgbW92ZXMgdGhlIGNvbnRyb2wgdG8gdGhlIHJpZ2h0LCBuZWdhdGl2ZSB0byB0aGUgbGVmdC5cbiAgICAgKiBJdCB1c2VkIHdoZW4geW91IHdhbnQgdG8gaGF2ZSBwb3NpdGlvbiBvZiBjb250cm9sIHRoYXQgZG9lcyBub3Qgc2NhbGUgd2l0aFxuICAgICAqIHRoZSBib3VuZGluZyBib3guIEV4YW1wbGU6IHJvdGF0aW9uIGNvbnRyb2wgaXMgcGxhY2VkIGF0IHg6MCwgeTogMC41IG9uXG4gICAgICogdGhlIGJvdW5kaW5kYm94LCB3aXRoIGFuIG9mZnNldCBvZiAzMCBwaXhlbHMgdmVydGljYWxseS4gVGhvc2UgMzAgcGl4ZWxzIHdpbGxcbiAgICAgKiBzdGF5IDMwIHBpeGVscyBubyBtYXR0ZXIgaG93IHRoZSBvYmplY3QgaXMgYmlnLiBBbm90aGVyIGV4YW1wbGUgaXMgaGF2aW5nIDJcbiAgICAgKiBjb250cm9scyBpbiB0aGUgY29ybmVyLCB0aGF0IHN0YXkgaW4gdGhlIHNhbWUgcG9zaXRpb24gd2hlbiB0aGUgb2JqZWN0IHNjYWxlLlxuICAgICAqIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIG9mZnNldCBvZiB0aGUgY29udHJvbCBmcm9tIHRoZSBkZWZpbmVkIHBvc2l0aW9uLiBJbiBwaXhlbHNcbiAgICAgKiBQb3NpdGl2ZSBvZmZzZXQgbW92ZXMgdGhlIGNvbnRyb2wgdG8gdGhlIGJvdHRvbSwgbmVnYXRpdmUgdG8gdGhlIHRvcC5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBvZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGVuZ3RoIG9mIHRoZSBjb250cm9sLiBJZiBudWxsLCBkZWZhdWx0cyB0byBvYmplY3QncyBjb3JuZXJTaXplLlxuICAgICAqIEV4cGVjdHMgYm90aCBzaXplWCBhbmQgc2l6ZVkgdG8gYmUgc2V0IHdoZW4gc2V0LlxuICAgICAqIEB0eXBlIHs/TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBzaXplWDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgY29udHJvbC4gSWYgbnVsbCwgZGVmYXVsdHMgdG8gb2JqZWN0J3MgY29ybmVyU2l6ZS5cbiAgICAgKiBFeHBlY3RzIGJvdGggc2l6ZVggYW5kIHNpemVZIHRvIGJlIHNldCB3aGVuIHNldC5cbiAgICAgKiBAdHlwZSB7P051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgc2l6ZVk6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsZW5ndGggb2YgdGhlIHRvdWNoIGFyZWEgb2YgdGhlIGNvbnRyb2wuIElmIG51bGwsIGRlZmF1bHRzIHRvIG9iamVjdCdzIHRvdWNoQ29ybmVyU2l6ZS5cbiAgICAgKiBFeHBlY3RzIGJvdGggdG91Y2hTaXplWCBhbmQgdG91Y2hTaXplWSB0byBiZSBzZXQgd2hlbiBzZXQuXG4gICAgICogQHR5cGUgez9OdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHRvdWNoU2l6ZVg6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgdGhlIHRvdWNoIGFyZWEgb2YgdGhlIGNvbnRyb2wuIElmIG51bGwsIGRlZmF1bHRzIHRvIG9iamVjdCdzIHRvdWNoQ29ybmVyU2l6ZS5cbiAgICAgKiBFeHBlY3RzIGJvdGggdG91Y2hTaXplWCBhbmQgdG91Y2hTaXplWSB0byBiZSBzZXQgd2hlbiBzZXQuXG4gICAgICogQHR5cGUgez9OdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHRvdWNoU2l6ZVk6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDc3MgY3Vyc29yIHN0eWxlIHRvIGRpc3BsYXkgd2hlbiB0aGUgY29udHJvbCBpcyBob3ZlcmVkLlxuICAgICAqIGlmIHRoZSBtZXRob2QgYGN1cnNvclN0eWxlSGFuZGxlcmAgaXMgcHJvdmlkZWQsIHRoaXMgcHJvcGVydHkgaXMgaWdub3JlZC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdjcm9zc2hhaXInXG4gICAgICovXG4gICAgY3Vyc29yU3R5bGU6ICdjcm9zc2hhaXInLFxuXG4gICAgLyoqXG4gICAgICogSWYgY29udHJvbHMgaGFzIGFuIG9mZnNldFkgb3Igb2Zmc2V0WCwgZHJhdyBhIGxpbmUgdGhhdCBjb25uZWN0c1xuICAgICAqIHRoZSBjb250cm9sIHRvIHRoZSBib3VuZGluZyBib3hcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHdpdGhDb25uZWN0aW9uOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250cm9sIGFjdGlvbkhhbmRsZXIsIHByb3ZpZGUgb25lIHRvIGhhbmRsZSBhY3Rpb24gKCBjb250cm9sIGJlaW5nIG1vdmVkIClcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1EYXRhIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggeCBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgYWN0aW9uL2V2ZW50IG1vZGlmaWVkIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBhY3Rpb25IYW5kbGVyOiBmdW5jdGlvbigvKiBldmVudERhdGEsIHRyYW5zZm9ybURhdGEsIHgsIHkgKi8pIHsgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250cm9sIGhhbmRsZXIgZm9yIG1vdXNlIGRvd24sIHByb3ZpZGUgb25lIHRvIGhhbmRsZSBtb3VzZSBkb3duIG9uIGNvbnRyb2xcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1EYXRhIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggeCBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgYWN0aW9uL2V2ZW50IG1vZGlmaWVkIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBtb3VzZURvd25IYW5kbGVyOiBmdW5jdGlvbigvKiBldmVudERhdGEsIHRyYW5zZm9ybURhdGEsIHgsIHkgKi8pIHsgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250cm9sIG1vdXNlVXBIYW5kbGVyLCBwcm92aWRlIG9uZSB0byBoYW5kbGUgYW4gZWZmZWN0IG9uIG1vdXNlIHVwLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybURhdGEgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCB4IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB5IHBvc2l0aW9uIG9mIHRoZSBjdXJzb3JcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBhY3Rpb24vZXZlbnQgbW9kaWZpZWQgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIG1vdXNlVXBIYW5kbGVyOiBmdW5jdGlvbigvKiBldmVudERhdGEsIHRyYW5zZm9ybURhdGEsIHgsIHkgKi8pIHsgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udHJvbCBhY3Rpb25IYW5kbGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCBvbiB3aGljaCB0aGUgY29udHJvbCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIGNvbnRyb2wgZm9yIHdoaWNoIHRoZSBhY3Rpb24gaGFuZGxlciBpcyBiZWluZyBhc2tlZFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgYWN0aW9uIGhhbmRsZXJcbiAgICAgKi9cbiAgICBnZXRBY3Rpb25IYW5kbGVyOiBmdW5jdGlvbigvKiBldmVudERhdGEsIGZhYnJpY09iamVjdCwgY29udHJvbCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uSGFuZGxlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250cm9sIG1vdXNlRG93biBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCBvbiB3aGljaCB0aGUgY29udHJvbCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIGNvbnRyb2wgZm9yIHdoaWNoIHRoZSBhY3Rpb24gaGFuZGxlciBpcyBiZWluZyBhc2tlZFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgYWN0aW9uIGhhbmRsZXJcbiAgICAgKi9cbiAgICBnZXRNb3VzZURvd25IYW5kbGVyOiBmdW5jdGlvbigvKiBldmVudERhdGEsIGZhYnJpY09iamVjdCwgY29udHJvbCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMubW91c2VEb3duSGFuZGxlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250cm9sIG1vdXNlVXAgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3Qgb24gd2hpY2ggdGhlIGNvbnRyb2wgaXMgZGlzcGxheWVkXG4gICAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCBjb250cm9sIGZvciB3aGljaCB0aGUgYWN0aW9uIGhhbmRsZXIgaXMgYmVpbmcgYXNrZWRcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhlIGFjdGlvbiBoYW5kbGVyXG4gICAgICovXG4gICAgZ2V0TW91c2VVcEhhbmRsZXI6IGZ1bmN0aW9uKC8qIGV2ZW50RGF0YSwgZmFicmljT2JqZWN0LCBjb250cm9sICovKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb3VzZVVwSGFuZGxlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250cm9sIGN1cnNvclN0eWxlIGZvciBjc3MgdXNpbmcgY3Vyc29yU3R5bGUuIElmIHlvdSBuZWVkIGEgbW9yZSBlbGFib3JhdGVcbiAgICAgKiBmdW5jdGlvbiB5b3UgY2FuIHBhc3Mgb25lIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAqIHRoZSBjdXJzb3JTdHlsZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY3VycmVudCBjb250cm9sICggbGlrZWx5IHRoaXMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3Qgb24gd2hpY2ggdGhlIGNvbnRyb2wgaXMgZGlzcGxheWVkXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogZnVuY3Rpb24oZXZlbnREYXRhLCBjb250cm9sIC8qIGZhYnJpY09iamVjdCAqLykge1xuICAgICAgcmV0dXJuIGNvbnRyb2wuY3Vyc29yU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFjdGlvbiBuYW1lLiBUaGUgYmFzaWMgaW1wbGVtZW50YXRpb24ganVzdCByZXR1cm4gdGhlIGFjdGlvbk5hbWUgcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjdXJyZW50IGNvbnRyb2wgKCBsaWtlbHkgdGhpcylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBvbiB3aGljaCB0aGUgY29udHJvbCBpcyBkaXNwbGF5ZWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0QWN0aW9uTmFtZTogZnVuY3Rpb24oZXZlbnREYXRhLCBjb250cm9sIC8qIGZhYnJpY09iamVjdCAqLykge1xuICAgICAgcmV0dXJuIGNvbnRyb2wuYWN0aW9uTmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250cm9scyB2aXNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3Qgb24gd2hpY2ggdGhlIGNvbnRyb2wgaXMgZGlzcGxheWVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRyb2xLZXkga2V5IHdoZXJlIHRoZSBjb250cm9sIGlzIG1lbW9yaXplZCBvbiB0aGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldFZpc2liaWxpdHk6IGZ1bmN0aW9uKGZhYnJpY09iamVjdCwgY29udHJvbEtleSkge1xuICAgICAgdmFyIG9iamVjdFZpc2liaWxpdHkgPSBmYWJyaWNPYmplY3QuX2NvbnRyb2xzVmlzaWJpbGl0eTtcbiAgICAgIGlmIChvYmplY3RWaXNpYmlsaXR5ICYmIHR5cGVvZiBvYmplY3RWaXNpYmlsaXR5W2NvbnRyb2xLZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gb2JqZWN0VmlzaWJpbGl0eVtjb250cm9sS2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnZpc2libGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29udHJvbHMgdmlzaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJpbGl0eSBmb3IgdGhlIG9iamVjdFxuICAgICAqIEByZXR1cm4ge1ZvaWR9XG4gICAgICovXG4gICAgc2V0VmlzaWJpbGl0eTogZnVuY3Rpb24odmlzaWJpbGl0eSAvKiBuYW1lLCBmYWJyaWNPYmplY3QgKi8pIHtcbiAgICAgIHRoaXMudmlzaWJsZSA9IHZpc2liaWxpdHk7XG4gICAgfSxcblxuXG4gICAgcG9zaXRpb25IYW5kbGVyOiBmdW5jdGlvbihkaW0sIGZpbmFsTWF0cml4IC8qLCBmYWJyaWNPYmplY3QsIGN1cnJlbnRDb250cm9sICovKSB7XG4gICAgICB2YXIgcG9pbnQgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludCh7XG4gICAgICAgIHg6IHRoaXMueCAqIGRpbS54ICsgdGhpcy5vZmZzZXRYLFxuICAgICAgICB5OiB0aGlzLnkgKiBkaW0ueSArIHRoaXMub2Zmc2V0WSB9LCBmaW5hbE1hdHJpeCk7XG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvb3JkcyBmb3IgdGhpcyBjb250cm9sIGJhc2VkIG9uIG9iamVjdCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9iamVjdEFuZ2xlIGFuZ2xlIGZyb20gdGhlIGZhYnJpYyBvYmplY3QgaG9sZGluZyB0aGUgY29udHJvbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvYmplY3RDb3JuZXJTaXplIGNvcm5lclNpemUgZnJvbSB0aGUgZmFicmljIG9iamVjdCBob2xkaW5nIHRoZSBjb250cm9sIChvciB0b3VjaENvcm5lclNpemUgaWZcbiAgICAgKiAgIGlzVG91Y2ggaXMgdHJ1ZSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2VudGVyWCB4IGNvb3JkaW5hdGUgd2hlcmUgdGhlIGNvbnRyb2wgY2VudGVyIHNob3VsZCBiZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjZW50ZXJZIHkgY29vcmRpbmF0ZSB3aGVyZSB0aGUgY29udHJvbCBjZW50ZXIgc2hvdWxkIGJlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc1RvdWNoIHRydWUgaWYgdG91Y2ggY29ybmVyLCBmYWxzZSBpZiBub3JtYWwgY29ybmVyXG4gICAgICovXG4gICAgY2FsY0Nvcm5lckNvb3JkczogZnVuY3Rpb24ob2JqZWN0QW5nbGUsIG9iamVjdENvcm5lclNpemUsIGNlbnRlclgsIGNlbnRlclksIGlzVG91Y2gpIHtcbiAgICAgIHZhciBjb3NIYWxmT2Zmc2V0LFxuICAgICAgICAgIHNpbkhhbGZPZmZzZXQsXG4gICAgICAgICAgY29zSGFsZk9mZnNldENvbXAsXG4gICAgICAgICAgc2luSGFsZk9mZnNldENvbXAsXG4gICAgICAgICAgeFNpemUgPSAoaXNUb3VjaCkgPyB0aGlzLnRvdWNoU2l6ZVggOiB0aGlzLnNpemVYLFxuICAgICAgICAgIHlTaXplID0gKGlzVG91Y2gpID8gdGhpcy50b3VjaFNpemVZIDogdGhpcy5zaXplWTtcbiAgICAgIGlmICh4U2l6ZSAmJiB5U2l6ZSAmJiB4U2l6ZSAhPT0geVNpemUpIHtcbiAgICAgICAgLy8gaGFuZGxlIHJlY3Rhbmd1bGFyIGNvcm5lcnNcbiAgICAgICAgdmFyIGNvbnRyb2xUcmlhbmdsZUFuZ2xlID0gTWF0aC5hdGFuMih5U2l6ZSwgeFNpemUpO1xuICAgICAgICB2YXIgY29ybmVySHlwb3RlbnVzZSA9IE1hdGguc3FydCh4U2l6ZSAqIHhTaXplICsgeVNpemUgKiB5U2l6ZSkgLyAyO1xuICAgICAgICB2YXIgbmV3VGhldGEgPSBjb250cm9sVHJpYW5nbGVBbmdsZSAtIGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMob2JqZWN0QW5nbGUpO1xuICAgICAgICB2YXIgbmV3VGhldGFDb21wID0gTWF0aC5QSSAvIDIgLSBjb250cm9sVHJpYW5nbGVBbmdsZSAtIGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMob2JqZWN0QW5nbGUpO1xuICAgICAgICBjb3NIYWxmT2Zmc2V0ID0gY29ybmVySHlwb3RlbnVzZSAqIGZhYnJpYy51dGlsLmNvcyhuZXdUaGV0YSk7XG4gICAgICAgIHNpbkhhbGZPZmZzZXQgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuc2luKG5ld1RoZXRhKTtcbiAgICAgICAgLy8gdXNlIGNvbXBsZW1lbnRhcnkgYW5nbGUgZm9yIHR3byBjb3JuZXJzXG4gICAgICAgIGNvc0hhbGZPZmZzZXRDb21wID0gY29ybmVySHlwb3RlbnVzZSAqIGZhYnJpYy51dGlsLmNvcyhuZXdUaGV0YUNvbXApO1xuICAgICAgICBzaW5IYWxmT2Zmc2V0Q29tcCA9IGNvcm5lckh5cG90ZW51c2UgKiBmYWJyaWMudXRpbC5zaW4obmV3VGhldGFDb21wKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBoYW5kbGUgc3F1YXJlIGNvcm5lcnNcbiAgICAgICAgLy8gdXNlIGRlZmF1bHQgb2JqZWN0IGNvcm5lciBzaXplIHVubGVzcyBzaXplIGlzIGRlZmluZWRcbiAgICAgICAgdmFyIGNvcm5lclNpemUgPSAoeFNpemUgJiYgeVNpemUpID8geFNpemUgOiBvYmplY3RDb3JuZXJTaXplO1xuICAgICAgICAvKiAwLjcwNzEwNjc4MTIgc3RhbmRzIGZvciBzcXJ0KDIpLzIgKi9cbiAgICAgICAgY29ybmVySHlwb3RlbnVzZSA9IGNvcm5lclNpemUgKiAwLjcwNzEwNjc4MTI7XG4gICAgICAgIC8vIGNvbXBsZW1lbnRhcnkgYW5nbGVzIGFyZSBlcXVhbCBzaW5jZSB0aGV5J3JlIGJvdGggNDUgZGVncmVlc1xuICAgICAgICB2YXIgbmV3VGhldGEgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKDQ1IC0gb2JqZWN0QW5nbGUpO1xuICAgICAgICBjb3NIYWxmT2Zmc2V0ID0gY29zSGFsZk9mZnNldENvbXAgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuY29zKG5ld1RoZXRhKTtcbiAgICAgICAgc2luSGFsZk9mZnNldCA9IHNpbkhhbGZPZmZzZXRDb21wID0gY29ybmVySHlwb3RlbnVzZSAqIGZhYnJpYy51dGlsLnNpbihuZXdUaGV0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRsOiB7XG4gICAgICAgICAgeDogY2VudGVyWCAtIHNpbkhhbGZPZmZzZXRDb21wLFxuICAgICAgICAgIHk6IGNlbnRlclkgLSBjb3NIYWxmT2Zmc2V0Q29tcCxcbiAgICAgICAgfSxcbiAgICAgICAgdHI6IHtcbiAgICAgICAgICB4OiBjZW50ZXJYICsgY29zSGFsZk9mZnNldCxcbiAgICAgICAgICB5OiBjZW50ZXJZIC0gc2luSGFsZk9mZnNldCxcbiAgICAgICAgfSxcbiAgICAgICAgYmw6IHtcbiAgICAgICAgICB4OiBjZW50ZXJYIC0gY29zSGFsZk9mZnNldCxcbiAgICAgICAgICB5OiBjZW50ZXJZICsgc2luSGFsZk9mZnNldCxcbiAgICAgICAgfSxcbiAgICAgICAgYnI6IHtcbiAgICAgICAgICB4OiBjZW50ZXJYICsgc2luSGFsZk9mZnNldENvbXAsXG4gICAgICAgICAgeTogY2VudGVyWSArIGNvc0hhbGZPZmZzZXRDb21wLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBSZW5kZXIgZnVuY3Rpb24gZm9yIHRoZSBjb250cm9sLlxuICAgICogV2hlbiB0aGlzIGZ1bmN0aW9uIHJ1bnMgdGhlIGNvbnRleHQgaXMgdW5zY2FsZWQuIHVucm90YXRlLiBKdXN0IHJldGluYSBzY2FsZWQuXG4gICAgKiBhbGwgdGhlIGZ1bmN0aW9ucyB3aWxsIGhhdmUgdG8gdHJhbnNsYXRlIHRvIHRoZSBwb2ludCBsZWZ0LHRvcCBiZWZvcmUgc3RhcnRpbmcgRHJhd2luZ1xuICAgICogaWYgdGhleSB3YW50IHRvIGRyYXcgYSBjb250cm9sIHdoZXJlIHRoZSBwb3NpdGlvbiBpcyBkZXRlY3RlZC5cbiAgICAqIGxlZnQgYW5kIHRvcCBhcmUgdGhlIHJlc3VsdCBvZiB0aGUgcG9zaXRpb25IYW5kbGVyIGZ1bmN0aW9uXG4gICAgKiBAcGFyYW0ge1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IHRoZSBjb250ZXh0IHdoZXJlIHRoZSBjb250cm9sIHdpbGwgYmUgZHJhd25cbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IHBvc2l0aW9uIG9mIHRoZSBjYW52YXMgd2hlcmUgd2UgYXJlIGFib3V0IHRvIHJlbmRlciB0aGUgY29udHJvbC5cbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgcG9zaXRpb24gb2YgdGhlIGNhbnZhcyB3aGVyZSB3ZSBhcmUgYWJvdXQgdG8gcmVuZGVyIHRoZSBjb250cm9sLlxuICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGVcbiAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBvYmplY3Qgd2hlcmUgdGhlIGNvbnRyb2wgaXMgYWJvdXQgdG8gYmUgcmVuZGVyZWRcbiAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4LCBsZWZ0LCB0b3AsIHN0eWxlT3ZlcnJpZGUsIGZhYnJpY09iamVjdCkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICBzd2l0Y2ggKHN0eWxlT3ZlcnJpZGUuY29ybmVyU3R5bGUgfHwgZmFicmljT2JqZWN0LmNvcm5lclN0eWxlKSB7XG4gICAgICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICAgICAgZmFicmljLmNvbnRyb2xzVXRpbHMucmVuZGVyQ2lyY2xlQ29udHJvbC5jYWxsKHRoaXMsIGN0eCwgbGVmdCwgdG9wLCBzdHlsZU92ZXJyaWRlLCBmYWJyaWNPYmplY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGZhYnJpYy5jb250cm9sc1V0aWxzLnJlbmRlclNxdWFyZUNvbnRyb2wuY2FsbCh0aGlzLCBjdHgsIGxlZnQsIHRvcCwgc3R5bGVPdmVycmlkZSwgZmFicmljT2JqZWN0KTtcbiAgICAgIH1cbiAgICB9LFxuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgZnVuY3Rpb24gZ2V0Q29sb3JTdG9wKGVsLCBtdWx0aXBsaWVyKSB7XG4gICAgdmFyIHN0eWxlID0gZWwuZ2V0QXR0cmlidXRlKCdzdHlsZScpLFxuICAgICAgICBvZmZzZXQgPSBlbC5nZXRBdHRyaWJ1dGUoJ29mZnNldCcpIHx8IDAsXG4gICAgICAgIGNvbG9yLCBjb2xvckFscGhhLCBvcGFjaXR5LCBpO1xuXG4gICAgLy8gY29udmVydCBwZXJjZW50cyB0byBhYnNvbHV0ZSB2YWx1ZXNcbiAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KG9mZnNldCkgLyAoLyUkLy50ZXN0KG9mZnNldCkgPyAxMDAgOiAxKTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPCAwID8gMCA6IG9mZnNldCA+IDEgPyAxIDogb2Zmc2V0O1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgdmFyIGtleVZhbHVlUGFpcnMgPSBzdHlsZS5zcGxpdCgvXFxzKjtcXHMqLyk7XG5cbiAgICAgIGlmIChrZXlWYWx1ZVBhaXJzW2tleVZhbHVlUGFpcnMubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICAgIGtleVZhbHVlUGFpcnMucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IGtleVZhbHVlUGFpcnMubGVuZ3RoOyBpLS07ICkge1xuXG4gICAgICAgIHZhciBzcGxpdCA9IGtleVZhbHVlUGFpcnNbaV0uc3BsaXQoL1xccyo6XFxzKi8pLFxuICAgICAgICAgICAga2V5ID0gc3BsaXRbMF0udHJpbSgpLFxuICAgICAgICAgICAgdmFsdWUgPSBzcGxpdFsxXS50cmltKCk7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ3N0b3AtY29sb3InKSB7XG4gICAgICAgICAgY29sb3IgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdG9wLW9wYWNpdHknKSB7XG4gICAgICAgICAgb3BhY2l0eSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgY29sb3IgPSBlbC5nZXRBdHRyaWJ1dGUoJ3N0b3AtY29sb3InKSB8fCAncmdiKDAsMCwwKSc7XG4gICAgfVxuICAgIGlmICghb3BhY2l0eSkge1xuICAgICAgb3BhY2l0eSA9IGVsLmdldEF0dHJpYnV0ZSgnc3RvcC1vcGFjaXR5Jyk7XG4gICAgfVxuXG4gICAgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGNvbG9yKTtcbiAgICBjb2xvckFscGhhID0gY29sb3IuZ2V0QWxwaGEoKTtcbiAgICBvcGFjaXR5ID0gaXNOYU4ocGFyc2VGbG9hdChvcGFjaXR5KSkgPyAxIDogcGFyc2VGbG9hdChvcGFjaXR5KTtcbiAgICBvcGFjaXR5ICo9IGNvbG9yQWxwaGEgKiBtdWx0aXBsaWVyO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgY29sb3I6IGNvbG9yLnRvUmdiKCksXG4gICAgICBvcGFjaXR5OiBvcGFjaXR5XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExpbmVhckNvb3JkcyhlbCkge1xuICAgIHJldHVybiB7XG4gICAgICB4MTogZWwuZ2V0QXR0cmlidXRlKCd4MScpIHx8IDAsXG4gICAgICB5MTogZWwuZ2V0QXR0cmlidXRlKCd5MScpIHx8IDAsXG4gICAgICB4MjogZWwuZ2V0QXR0cmlidXRlKCd4MicpIHx8ICcxMDAlJyxcbiAgICAgIHkyOiBlbC5nZXRBdHRyaWJ1dGUoJ3kyJykgfHwgMFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSYWRpYWxDb29yZHMoZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IGVsLmdldEF0dHJpYnV0ZSgnZngnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ2N4JykgfHwgJzUwJScsXG4gICAgICB5MTogZWwuZ2V0QXR0cmlidXRlKCdmeScpIHx8IGVsLmdldEF0dHJpYnV0ZSgnY3knKSB8fCAnNTAlJyxcbiAgICAgIHIxOiAwLFxuICAgICAgeDI6IGVsLmdldEF0dHJpYnV0ZSgnY3gnKSB8fCAnNTAlJyxcbiAgICAgIHkyOiBlbC5nZXRBdHRyaWJ1dGUoJ2N5JykgfHwgJzUwJScsXG4gICAgICByMjogZWwuZ2V0QXR0cmlidXRlKCdyJykgfHwgJzUwJSdcbiAgICB9O1xuICB9XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgdmFyIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lO1xuXG4gIC8qKlxuICAgKiBHcmFkaWVudCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkdyYWRpZW50XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2dyYWRpZW50c31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkdyYWRpZW50I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuR3JhZGllbnQgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5HcmFkaWVudC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCBvZmZzZXQgZm9yIGFsaWduaW5nIGdyYWRpZW50cyBjb21pbmcgZnJvbSBTVkcgd2hlbiBvdXRzaWRlIHBhdGhncm91cHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIG9mZnNldCBmb3IgYWxpZ25pbmcgZ3JhZGllbnRzIGNvbWluZyBmcm9tIFNWRyB3aGVuIG91dHNpZGUgcGF0aGdyb3Vwc1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBvZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFuc2Zvcm0gbWF0cml4IHRvIGFwcGx5IHRvIHRoZSBncmFkaWVudCBiZWZvcmUgcGFpbnRpbmcuXG4gICAgICogSW1wb3J0ZWQgZnJvbSBzdmcgZ3JhZGllbnRzLCBpcyBub3QgYXBwbGllZCB3aXRoIHRoZSBjdXJyZW50IHRyYW5zZm9ybSBpbiB0aGUgY2VudGVyLlxuICAgICAqIEJlZm9yZSB0aGlzIHRyYW5zZm9ybSBpcyBhcHBsaWVkLCB0aGUgb3JpZ2luIHBvaW50IGlzIGF0IHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIG9iamVjdFxuICAgICAqIHBsdXMgdGhlIGFkZGl0aW9uIG9mIG9mZnNldFkgYW5kIG9mZnNldFguXG4gICAgICogQHR5cGUgTnVtYmVyW11cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgZ3JhZGllbnRUcmFuc2Zvcm06IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBjb29yZGluYXRlcyB1bml0cyBmb3IgY29vcmRzLlxuICAgICAqIElmIGBwaXhlbHNgLCB0aGUgbnVtYmVyIG9mIGNvb3JkcyBhcmUgaW4gdGhlIHNhbWUgdW5pdCBvZiB3aWR0aCAvIGhlaWdodC5cbiAgICAgKiBJZiBzZXQgYXMgYHBlcmNlbnRhZ2VgIHRoZSBjb29yZHMgYXJlIHN0aWxsIGEgbnVtYmVyLCBidXQgMSBtZWFucyAxMDAlIG9mIHdpZHRoXG4gICAgICogZm9yIHRoZSBYIGFuZCAxMDAlIG9mIHRoZSBoZWlnaHQgZm9yIHRoZSB5LiBJdCBjYW4gYmUgYmlnZ2VyIHRoYW4gMSBhbmQgbmVnYXRpdmUuXG4gICAgICogYWxsb3dlZCB2YWx1ZXMgcGl4ZWxzIG9yIHBlcmNlbnRhZ2UuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHQgJ3BpeGVscydcbiAgICAgKi9cbiAgICBncmFkaWVudFVuaXRzOiAncGl4ZWxzJyxcblxuICAgIC8qKlxuICAgICAqIEdyYWRpZW50IHR5cGUgbGluZWFyIG9yIHJhZGlhbFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0ICdwaXhlbHMnXG4gICAgICovXG4gICAgdHlwZTogJ2xpbmVhcicsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0IHdpdGggdHlwZSwgY29vcmRzLCBncmFkaWVudFVuaXRzIGFuZCBjb2xvclN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnR5cGVdIGdyYWRpZW50IHR5cGUgbGluZWFyIG9yIHJhZGlhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5ncmFkaWVudFVuaXRzXSBncmFkaWVudCB1bml0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5vZmZzZXRYXSBTVkcgaW1wb3J0IGNvbXBhdGliaWxpdHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMub2Zmc2V0WV0gU1ZHIGltcG9ydCBjb21wYXRpYmlsaXR5XG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gb3B0aW9ucy5jb2xvclN0b3BzIGNvbnRhaW5zIHRoZSBjb2xvcnN0b3BzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmNvb3JkcyBjb250YWlucyB0aGUgY29vcmRzIG9mIHRoZSBncmFkaWVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29yZHMueDFdIFggY29vcmRpYW50ZSBvZiB0aGUgZmlyc3QgcG9pbnQgZm9yIGxpbmVhciBvciBvZiB0aGUgZm9jYWwgcG9pbnQgZm9yIHJhZGlhbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29yZHMueTFdIFkgY29vcmRpYW50ZSBvZiB0aGUgZmlyc3QgcG9pbnQgZm9yIGxpbmVhciBvciBvZiB0aGUgZm9jYWwgcG9pbnQgZm9yIHJhZGlhbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29yZHMueDJdIFggY29vcmRpYW50ZSBvZiB0aGUgc2Vjb25kIHBvaW50IGZvciBsaW5lYXIgb3Igb2YgdGhlIGNlbnRlciBwb2ludCBmb3IgcmFkaWFsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb3Jkcy55Ml0gWSBjb29yZGlhbnRlIG9mIHRoZSBzZWNvbmQgcG9pbnQgZm9yIGxpbmVhciBvciBvZiB0aGUgY2VudGVyIHBvaW50IGZvciByYWRpYWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29vcmRzLnIxXSBvbmx5IGZvciByYWRpYWwgZ3JhZGllbnQsIHJhZGl1cyBvZiB0aGUgaW5uZXIgY2lyY2xlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb3Jkcy5yMl0gb25seSBmb3IgcmFkaWFsIGdyYWRpZW50LCByYWRpdXMgb2YgdGhlIGV4dGVybmFsIGNpcmNsZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgb3B0aW9ucy5jb29yZHMgfHwgKG9wdGlvbnMuY29vcmRzID0geyB9KTtcblxuICAgICAgdmFyIGNvb3JkcywgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBzZXRzIGV2ZXJ5dGhpbmcsIHRoZW4gY29vcmRzIGFuZCBjb2xvcnN0b3BzIGdldCBzZXRzIGFnYWluXG4gICAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICBfdGhpc1tvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmlkKSB7XG4gICAgICAgIHRoaXMuaWQgKz0gJ18nICsgZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuaWQgPSBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICB9XG5cbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDE6IG9wdGlvbnMuY29vcmRzLngxIHx8IDAsXG4gICAgICAgIHkxOiBvcHRpb25zLmNvb3Jkcy55MSB8fCAwLFxuICAgICAgICB4Mjogb3B0aW9ucy5jb29yZHMueDIgfHwgMCxcbiAgICAgICAgeTI6IG9wdGlvbnMuY29vcmRzLnkyIHx8IDBcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIGNvb3Jkcy5yMSA9IG9wdGlvbnMuY29vcmRzLnIxIHx8IDA7XG4gICAgICAgIGNvb3Jkcy5yMiA9IG9wdGlvbnMuY29vcmRzLnIyIHx8IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29vcmRzID0gY29vcmRzO1xuICAgICAgdGhpcy5jb2xvclN0b3BzID0gb3B0aW9ucy5jb2xvclN0b3BzLnNsaWNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW5vdGhlciBjb2xvclN0b3BcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29sb3JTdG9wIE9iamVjdCB3aXRoIG9mZnNldCBhbmQgY29sb3JcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JhZGllbnR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBhZGRDb2xvclN0b3A6IGZ1bmN0aW9uKGNvbG9yU3RvcHMpIHtcbiAgICAgIGZvciAodmFyIHBvc2l0aW9uIGluIGNvbG9yU3RvcHMpIHtcbiAgICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihjb2xvclN0b3BzW3Bvc2l0aW9uXSk7XG4gICAgICAgIHRoaXMuY29sb3JTdG9wcy5wdXNoKHtcbiAgICAgICAgICBvZmZzZXQ6IHBhcnNlRmxvYXQocG9zaXRpb24pLFxuICAgICAgICAgIGNvbG9yOiBjb2xvci50b1JnYigpLFxuICAgICAgICAgIG9wYWNpdHk6IGNvbG9yLmdldEFscGhhKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBncmFkaWVudFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBvYmplY3QgPSB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgY29vcmRzOiB0aGlzLmNvb3JkcyxcbiAgICAgICAgY29sb3JTdG9wczogdGhpcy5jb2xvclN0b3BzLFxuICAgICAgICBvZmZzZXRYOiB0aGlzLm9mZnNldFgsXG4gICAgICAgIG9mZnNldFk6IHRoaXMub2Zmc2V0WSxcbiAgICAgICAgZ3JhZGllbnRVbml0czogdGhpcy5ncmFkaWVudFVuaXRzLFxuICAgICAgICBncmFkaWVudFRyYW5zZm9ybTogdGhpcy5ncmFkaWVudFRyYW5zZm9ybSA/IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0uY29uY2F0KCkgOiB0aGlzLmdyYWRpZW50VHJhbnNmb3JtXG4gICAgICB9O1xuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBvYmplY3QsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGdyYWRpZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGEgZ3JhZGllbnQgZm9yXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcmVwcmVzZW50YXRpb24gb2YgYW4gZ3JhZGllbnQgKGxpbmVhci9yYWRpYWwpXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKG9iamVjdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGNvb3JkcyA9IGNsb25lKHRoaXMuY29vcmRzLCB0cnVlKSwgaSwgbGVuLCBvcHRpb25zID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICBtYXJrdXAsIGNvbW1vbkF0dHJpYnV0ZXMsIGNvbG9yU3RvcHMgPSBjbG9uZSh0aGlzLmNvbG9yU3RvcHMsIHRydWUpLFxuICAgICAgICAgIG5lZWRzU3dhcCA9IGNvb3Jkcy5yMSA+IGNvb3Jkcy5yMixcbiAgICAgICAgICB0cmFuc2Zvcm0gPSB0aGlzLmdyYWRpZW50VHJhbnNmb3JtID8gdGhpcy5ncmFkaWVudFRyYW5zZm9ybS5jb25jYXQoKSA6IGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpLFxuICAgICAgICAgIG9mZnNldFggPSAtdGhpcy5vZmZzZXRYLCBvZmZzZXRZID0gLXRoaXMub2Zmc2V0WSxcbiAgICAgICAgICB3aXRoVmlld3BvcnQgPSAhIW9wdGlvbnMuYWRkaXRpb25hbFRyYW5zZm9ybSxcbiAgICAgICAgICBncmFkaWVudFVuaXRzID0gdGhpcy5ncmFkaWVudFVuaXRzID09PSAncGl4ZWxzJyA/ICd1c2VyU3BhY2VPblVzZScgOiAnb2JqZWN0Qm91bmRpbmdCb3gnO1xuICAgICAgLy8gY29sb3JTdG9wcyBtdXN0IGJlIHNvcnRlZCBhc2NlbmRpbmdcbiAgICAgIGNvbG9yU3RvcHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLm9mZnNldCAtIGIub2Zmc2V0O1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChncmFkaWVudFVuaXRzID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnKSB7XG4gICAgICAgIG9mZnNldFggLz0gb2JqZWN0LndpZHRoO1xuICAgICAgICBvZmZzZXRZIC89IG9iamVjdC5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Zmc2V0WCArPSBvYmplY3Qud2lkdGggLyAyO1xuICAgICAgICBvZmZzZXRZICs9IG9iamVjdC5oZWlnaHQgLyAyO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC50eXBlID09PSAncGF0aCcgJiYgdGhpcy5ncmFkaWVudFVuaXRzICE9PSAncGVyY2VudGFnZScpIHtcbiAgICAgICAgb2Zmc2V0WCAtPSBvYmplY3QucGF0aE9mZnNldC54O1xuICAgICAgICBvZmZzZXRZIC09IG9iamVjdC5wYXRoT2Zmc2V0Lnk7XG4gICAgICB9XG5cblxuICAgICAgdHJhbnNmb3JtWzRdIC09IG9mZnNldFg7XG4gICAgICB0cmFuc2Zvcm1bNV0gLT0gb2Zmc2V0WTtcblxuICAgICAgY29tbW9uQXR0cmlidXRlcyA9ICdpZD1cIlNWR0lEXycgKyB0aGlzLmlkICtcbiAgICAgICAgICAgICAgICAgICAgICdcIiBncmFkaWVudFVuaXRzPVwiJyArIGdyYWRpZW50VW5pdHMgKyAnXCInO1xuICAgICAgY29tbW9uQXR0cmlidXRlcyArPSAnIGdyYWRpZW50VHJhbnNmb3JtPVwiJyArICh3aXRoVmlld3BvcnQgP1xuICAgICAgICBvcHRpb25zLmFkZGl0aW9uYWxUcmFuc2Zvcm0gKyAnICcgOiAnJykgKyBmYWJyaWMudXRpbC5tYXRyaXhUb1NWRyh0cmFuc2Zvcm0pICsgJ1wiICc7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIG1hcmt1cCA9IFtcbiAgICAgICAgICAnPGxpbmVhckdyYWRpZW50ICcsXG4gICAgICAgICAgY29tbW9uQXR0cmlidXRlcyxcbiAgICAgICAgICAnIHgxPVwiJywgY29vcmRzLngxLFxuICAgICAgICAgICdcIiB5MT1cIicsIGNvb3Jkcy55MSxcbiAgICAgICAgICAnXCIgeDI9XCInLCBjb29yZHMueDIsXG4gICAgICAgICAgJ1wiIHkyPVwiJywgY29vcmRzLnkyLFxuICAgICAgICAgICdcIj5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIC8vIHN2ZyByYWRpYWwgZ3JhZGllbnQgaGFzIGp1c3QgMSByYWRpdXMuIHRoZSBiaWdnZXN0LlxuICAgICAgICBtYXJrdXAgPSBbXG4gICAgICAgICAgJzxyYWRpYWxHcmFkaWVudCAnLFxuICAgICAgICAgIGNvbW1vbkF0dHJpYnV0ZXMsXG4gICAgICAgICAgJyBjeD1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy54MSA6IGNvb3Jkcy54MixcbiAgICAgICAgICAnXCIgY3k9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMueTEgOiBjb29yZHMueTIsXG4gICAgICAgICAgJ1wiIHI9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMucjEgOiBjb29yZHMucjIsXG4gICAgICAgICAgJ1wiIGZ4PVwiJywgbmVlZHNTd2FwID8gY29vcmRzLngyIDogY29vcmRzLngxLFxuICAgICAgICAgICdcIiBmeT1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy55MiA6IGNvb3Jkcy55MSxcbiAgICAgICAgICAnXCI+XFxuJ1xuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICBpZiAobmVlZHNTd2FwKSB7XG4gICAgICAgICAgLy8gc3ZnIGdvZXMgZnJvbSBpbnRlcm5hbCB0byBleHRlcm5hbCByYWRpdXMuIGlmIHJhZGl1cyBhcmUgaW52ZXJ0ZWQsIHN3YXAgY29sb3Igc3RvcHMuXG4gICAgICAgICAgY29sb3JTdG9wcyA9IGNvbG9yU3RvcHMuY29uY2F0KCk7XG4gICAgICAgICAgY29sb3JTdG9wcy5yZXZlcnNlKCk7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29sb3JTdG9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29sb3JTdG9wc1tpXS5vZmZzZXQgPSAxIC0gY29sb3JTdG9wc1tpXS5vZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtaW5SYWRpdXMgPSBNYXRoLm1pbihjb29yZHMucjEsIGNvb3Jkcy5yMik7XG4gICAgICAgIGlmIChtaW5SYWRpdXMgPiAwKSB7XG4gICAgICAgICAgLy8gaSBoYXZlIHRvIHNoaWZ0IGFsbCBjb2xvclN0b3BzIGFuZCBhZGQgbmV3IG9uZSBpbiAwLlxuICAgICAgICAgIHZhciBtYXhSYWRpdXMgPSBNYXRoLm1heChjb29yZHMucjEsIGNvb3Jkcy5yMiksXG4gICAgICAgICAgICAgIHBlcmNlbnRhZ2VTaGlmdCA9IG1pblJhZGl1cyAvIG1heFJhZGl1cztcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb2xvclN0b3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb2xvclN0b3BzW2ldLm9mZnNldCArPSBwZXJjZW50YWdlU2hpZnQgKiAoMSAtIGNvbG9yU3RvcHNbaV0ub2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gY29sb3JTdG9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY29sb3JTdG9wID0gY29sb3JTdG9wc1tpXTtcbiAgICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICAgJzxzdG9wICcsXG4gICAgICAgICAgJ29mZnNldD1cIicsIChjb2xvclN0b3Aub2Zmc2V0ICogMTAwKSArICclJyxcbiAgICAgICAgICAnXCIgc3R5bGU9XCJzdG9wLWNvbG9yOicsIGNvbG9yU3RvcC5jb2xvcixcbiAgICAgICAgICAodHlwZW9mIGNvbG9yU3RvcC5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJyA/ICc7c3RvcC1vcGFjaXR5OiAnICsgY29sb3JTdG9wLm9wYWNpdHkgOiAnOycpLFxuICAgICAgICAgICdcIi8+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBtYXJrdXAucHVzaCgodGhpcy50eXBlID09PSAnbGluZWFyJyA/ICc8L2xpbmVhckdyYWRpZW50PlxcbicgOiAnPC9yYWRpYWxHcmFkaWVudD5cXG4nKSk7XG5cbiAgICAgIHJldHVybiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgQ2FudmFzR3JhZGllbnRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHJldHVybiB7Q2FudmFzR3JhZGllbnR9XG4gICAgICovXG4gICAgdG9MaXZlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBncmFkaWVudCwgY29vcmRzID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKHRoaXMuY29vcmRzKSwgaSwgbGVuO1xuXG4gICAgICBpZiAoIXRoaXMudHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KFxuICAgICAgICAgIGNvb3Jkcy54MSwgY29vcmRzLnkxLCBjb29yZHMueDIsIGNvb3Jkcy55Mik7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxuICAgICAgICAgIGNvb3Jkcy54MSwgY29vcmRzLnkxLCBjb29yZHMucjEsIGNvb3Jkcy54MiwgY29vcmRzLnkyLCBjb29yZHMucjIpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLmNvbG9yU3RvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5jb2xvclN0b3BzW2ldLmNvbG9yLFxuICAgICAgICAgICAgb3BhY2l0eSA9IHRoaXMuY29sb3JTdG9wc1tpXS5vcGFjaXR5LFxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5jb2xvclN0b3BzW2ldLm9mZnNldDtcblxuICAgICAgICBpZiAodHlwZW9mIG9wYWNpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKGNvbG9yKS5zZXRBbHBoYShvcGFjaXR5KS50b1JnYmEoKTtcbiAgICAgICAgfVxuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aob2Zmc2V0LCBjb2xvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9XG4gIH0pO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLkdyYWRpZW50LCB7XG5cbiAgICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkdyYWRpZW50fSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuR3JhZGllbnRcbiAgICAgKiBAcGFyYW0ge1NWR0dyYWRpZW50RWxlbWVudH0gZWwgU1ZHIGdyYWRpZW50IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wYWNpdHlBdHRyIEEgZmlsbC1vcGFjaXR5IG9yIHN0cm9rZS1vcGFjaXR5IGF0dHJpYnV0ZSB0byBtdWx0aXBseSB0byBlYWNoIHN0b3AncyBvcGFjaXR5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdmdPcHRpb25zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzaXplIG9mIHRoZSBTVkcgaW4gb3JkZXIgdG8gcGFyc2UgY29ycmVjdGx5IGdyYWRpZW50c1xuICAgICAqIHRoYXQgdXNlcyBncmFkaWVudFVuaXRzIGFzICd1c2VyU3BhY2VPblVzZScgYW5kIHBlcmNlbnRhZ2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0Lm51bWJlcn0gdmlld0JveFdpZHRoIHdpZHRoIHBhcnQgb2YgdGhlIHZpZXdCb3ggYXR0cmlidXRlIG9uIHN2Z1xuICAgICAqIEBwYXJhbSB7T2JqZWN0Lm51bWJlcn0gdmlld0JveEhlaWdodCBoZWlnaHQgcGFydCBvZiB0aGUgdmlld0JveCBhdHRyaWJ1dGUgb24gc3ZnXG4gICAgICogQHBhcmFtIHtPYmplY3QubnVtYmVyfSB3aWR0aCB3aWR0aCBwYXJ0IG9mIHRoZSBzdmcgdGFnIGlmIHZpZXdCb3ggaXMgbm90IHNwZWNpZmllZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0Lm51bWJlcn0gaGVpZ2h0IGhlaWdodCBwYXJ0IG9mIHRoZSBzdmcgdGFnIGlmIHZpZXdCb3ggaXMgbm90IHNwZWNpZmllZFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5HcmFkaWVudH0gR3JhZGllbnQgaW5zdGFuY2VcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wc2VydmVycy5odG1sI0xpbmVhckdyYWRpZW50RWxlbWVudFxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BzZXJ2ZXJzLmh0bWwjUmFkaWFsR3JhZGllbnRFbGVtZW50XG4gICAgICovXG4gICAgZnJvbUVsZW1lbnQ6IGZ1bmN0aW9uKGVsLCBpbnN0YW5jZSwgb3BhY2l0eUF0dHIsIHN2Z09wdGlvbnMpIHtcbiAgICAgIC8qKlxuICAgICAgICogIEBleGFtcGxlOlxuICAgICAgICpcbiAgICAgICAqICA8bGluZWFyR3JhZGllbnQgaWQ9XCJsaW5lYXJHcmFkMVwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMCVcIiBzdG9wLWNvbG9yPVwid2hpdGVcIi8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIxMDAlXCIgc3RvcC1jb2xvcj1cImJsYWNrXCIvPlxuICAgICAgICogIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICAgKlxuICAgICAgICogIE9SXG4gICAgICAgKlxuICAgICAgICogIDxsaW5lYXJHcmFkaWVudCBpZD1cImxpbmVhckdyYWQyXCI+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwXCIgc3R5bGU9XCJzdG9wLWNvbG9yOnJnYigyNTUsMjU1LDI1NSlcIi8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIxXCIgc3R5bGU9XCJzdG9wLWNvbG9yOnJnYigwLDAsMClcIi8+XG4gICAgICAgKiAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKiAgT1JcbiAgICAgICAqXG4gICAgICAgKiAgPHJhZGlhbEdyYWRpZW50IGlkPVwicmFkaWFsR3JhZDFcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjAlXCIgc3RvcC1jb2xvcj1cIndoaXRlXCIgc3RvcC1vcGFjaXR5PVwiMVwiIC8+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCI1MCVcIiBzdG9wLWNvbG9yPVwiYmxhY2tcIiBzdG9wLW9wYWNpdHk9XCIwLjVcIiAvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMTAwJVwiIHN0b3AtY29sb3I9XCJ3aGl0ZVwiIHN0b3Atb3BhY2l0eT1cIjFcIiAvPlxuICAgICAgICogIDwvcmFkaWFsR3JhZGllbnQ+XG4gICAgICAgKlxuICAgICAgICogIE9SXG4gICAgICAgKlxuICAgICAgICogIDxyYWRpYWxHcmFkaWVudCBpZD1cInJhZGlhbEdyYWQyXCI+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwXCIgc3RvcC1jb2xvcj1cInJnYigyNTUsMjU1LDI1NSlcIiAvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMC41XCIgc3RvcC1jb2xvcj1cInJnYigwLDAsMClcIiAvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMVwiIHN0b3AtY29sb3I9XCJyZ2IoMjU1LDI1NSwyNTUpXCIgLz5cbiAgICAgICAqICA8L3JhZGlhbEdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICB2YXIgbXVsdGlwbGllciA9IHBhcnNlRmxvYXQob3BhY2l0eUF0dHIpIC8gKC8lJC8udGVzdChvcGFjaXR5QXR0cikgPyAxMDAgOiAxKTtcbiAgICAgIG11bHRpcGxpZXIgPSBtdWx0aXBsaWVyIDwgMCA/IDAgOiBtdWx0aXBsaWVyID4gMSA/IDEgOiBtdWx0aXBsaWVyO1xuICAgICAgaWYgKGlzTmFOKG11bHRpcGxpZXIpKSB7XG4gICAgICAgIG11bHRpcGxpZXIgPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3JTdG9wRWxzID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0b3AnKSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGdyYWRpZW50VW5pdHMgPSBlbC5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnKSA9PT0gJ3VzZXJTcGFjZU9uVXNlJyA/XG4gICAgICAgICAgICAncGl4ZWxzJyA6ICdwZXJjZW50YWdlJyxcbiAgICAgICAgICBncmFkaWVudFRyYW5zZm9ybSA9IGVsLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRUcmFuc2Zvcm0nKSB8fCAnJyxcbiAgICAgICAgICBjb2xvclN0b3BzID0gW10sXG4gICAgICAgICAgY29vcmRzLCBpLCBvZmZzZXRYID0gMCwgb2Zmc2V0WSA9IDAsXG4gICAgICAgICAgdHJhbnNmb3JtTWF0cml4O1xuICAgICAgaWYgKGVsLm5vZGVOYW1lID09PSAnbGluZWFyR3JhZGllbnQnIHx8IGVsLm5vZGVOYW1lID09PSAnTElORUFSR1JBRElFTlQnKSB7XG4gICAgICAgIHR5cGUgPSAnbGluZWFyJztcbiAgICAgICAgY29vcmRzID0gZ2V0TGluZWFyQ29vcmRzKGVsKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0eXBlID0gJ3JhZGlhbCc7XG4gICAgICAgIGNvb3JkcyA9IGdldFJhZGlhbENvb3JkcyhlbCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IGNvbG9yU3RvcEVscy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIGNvbG9yU3RvcHMucHVzaChnZXRDb2xvclN0b3AoY29sb3JTdG9wRWxzW2ldLCBtdWx0aXBsaWVyKSk7XG4gICAgICB9XG5cbiAgICAgIHRyYW5zZm9ybU1hdHJpeCA9IGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZShncmFkaWVudFRyYW5zZm9ybSk7XG5cbiAgICAgIF9fY29udmVydFBlcmNlbnRVbml0c1RvVmFsdWVzKGluc3RhbmNlLCBjb29yZHMsIHN2Z09wdGlvbnMsIGdyYWRpZW50VW5pdHMpO1xuXG4gICAgICBpZiAoZ3JhZGllbnRVbml0cyA9PT0gJ3BpeGVscycpIHtcbiAgICAgICAgb2Zmc2V0WCA9IC1pbnN0YW5jZS5sZWZ0O1xuICAgICAgICBvZmZzZXRZID0gLWluc3RhbmNlLnRvcDtcbiAgICAgIH1cblxuICAgICAgdmFyIGdyYWRpZW50ID0gbmV3IGZhYnJpYy5HcmFkaWVudCh7XG4gICAgICAgIGlkOiBlbC5nZXRBdHRyaWJ1dGUoJ2lkJyksXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGNvb3JkczogY29vcmRzLFxuICAgICAgICBjb2xvclN0b3BzOiBjb2xvclN0b3BzLFxuICAgICAgICBncmFkaWVudFVuaXRzOiBncmFkaWVudFVuaXRzLFxuICAgICAgICBncmFkaWVudFRyYW5zZm9ybTogdHJhbnNmb3JtTWF0cml4LFxuICAgICAgICBvZmZzZXRYOiBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZOiBvZmZzZXRZLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9XG4gICAgLyogX0ZST01fU1ZHX0VORF8gKi9cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfX2NvbnZlcnRQZXJjZW50VW5pdHNUb1ZhbHVlcyhpbnN0YW5jZSwgb3B0aW9ucywgc3ZnT3B0aW9ucywgZ3JhZGllbnRVbml0cykge1xuICAgIHZhciBwcm9wVmFsdWUsIGZpbmFsVmFsdWU7XG4gICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICBwcm9wVmFsdWUgPSBvcHRpb25zW3Byb3BdO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gJ0luZmluaXR5Jykge1xuICAgICAgICBmaW5hbFZhbHVlID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHByb3BWYWx1ZSA9PT0gJy1JbmZpbml0eScpIHtcbiAgICAgICAgZmluYWxWYWx1ZSA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmluYWxWYWx1ZSA9IHBhcnNlRmxvYXQob3B0aW9uc1twcm9wXSwgMTApO1xuICAgICAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3N0cmluZycgJiYgL14oXFxkK1xcLlxcZCspJXwoXFxkKyklJC8udGVzdChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgZmluYWxWYWx1ZSAqPSAwLjAxO1xuICAgICAgICAgIGlmIChncmFkaWVudFVuaXRzID09PSAncGl4ZWxzJykge1xuICAgICAgICAgICAgLy8gdGhlbiB3ZSBuZWVkIHRvIGZpeCB0aG9zZSBwZXJjZW50YWdlcyBoZXJlIGluIHN2ZyBwYXJzaW5nXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ3gxJyB8fCBwcm9wID09PSAneDInIHx8IHByb3AgPT09ICdyMicpIHtcbiAgICAgICAgICAgICAgZmluYWxWYWx1ZSAqPSBzdmdPcHRpb25zLnZpZXdCb3hXaWR0aCB8fCBzdmdPcHRpb25zLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICd5MScgfHwgcHJvcCA9PT0gJ3kyJykge1xuICAgICAgICAgICAgICBmaW5hbFZhbHVlICo9IHN2Z09wdGlvbnMudmlld0JveEhlaWdodCB8fCBzdmdPcHRpb25zLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wdGlvbnNbcHJvcF0gPSBmaW5hbFZhbHVlO1xuICAgIH0pO1xuICB9XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkO1xuXG4gIC8qKlxuICAgKiBQYXR0ZXJuIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUGF0dGVyblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL3BhdHRlcm5zfFBhdHRlcm4gZGVtb31cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9keW5hbWljLXBhdHRlcm5zfER5bmFtaWNQYXR0ZXJuIGRlbW99XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5QYXR0ZXJuI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuXG5cbiAgZmFicmljLlBhdHRlcm4gPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5QYXR0ZXJuLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXQgcHJvcGVydHkgb2YgYSBwYXR0ZXJuIChvbmUgb2YgcmVwZWF0LCByZXBlYXQteCwgcmVwZWF0LXkgb3Igbm8tcmVwZWF0KVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmVwZWF0OiAncmVwZWF0JyxcblxuICAgIC8qKlxuICAgICAqIFBhdHRlcm4gaG9yaXpvbnRhbCBvZmZzZXQgZnJvbSBvYmplY3QncyBsZWZ0L3RvcCBjb3JuZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBQYXR0ZXJuIHZlcnRpY2FsIG9mZnNldCBmcm9tIG9iamVjdCdzIGxlZnQvdG9wIGNvcm5lclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WTogMCxcblxuICAgIC8qKlxuICAgICAqIGNyb3NzT3JpZ2luIHZhbHVlIChvbmUgb2YgXCJcIiwgXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIilcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNyb3NzT3JpZ2luOiAnJyxcblxuICAgIC8qKlxuICAgICAqIHRyYW5zZm9ybSBtYXRyaXggdG8gY2hhbmdlIHRoZSBwYXR0ZXJuLCBpbXBvcnRlZCBmcm9tIHN2Z3MuXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhdHRlcm5UcmFuc2Zvcm06IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGZ1bmN0aW9uIHRvIGludm9rZSBhZnRlciBjYWxsYmFjayBpbml0LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QYXR0ZXJufSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgaWYgKCFvcHRpb25zLnNvdXJjZSB8fCAob3B0aW9ucy5zb3VyY2UgJiYgdHlwZW9mIG9wdGlvbnMuc291cmNlICE9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBpbWcgc3JjIHN0cmluZ1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUltYWdlKCk7XG4gICAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZShvcHRpb25zLnNvdXJjZSwgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICAgICAgX3RoaXMuc291cmNlID0gaW1nO1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKF90aGlzLCBpc0Vycm9yKTtcbiAgICAgICAgfSwgbnVsbCwgdGhpcy5jcm9zc09yaWdpbik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVyblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHBhdHRlcm4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMsXG4gICAgICAgICAgc291cmNlLCBvYmplY3Q7XG5cbiAgICAgIC8vIDxpbWc+IGVsZW1lbnRcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2Uuc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICBzb3VyY2UgPSB0aGlzLnNvdXJjZS5zcmM7XG4gICAgICB9XG4gICAgICAvLyA8Y2FudmFzPiBlbGVtZW50XG4gICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UgPT09ICdvYmplY3QnICYmIHRoaXMuc291cmNlLnRvRGF0YVVSTCkge1xuICAgICAgICBzb3VyY2UgPSB0aGlzLnNvdXJjZS50b0RhdGFVUkwoKTtcbiAgICAgIH1cblxuICAgICAgb2JqZWN0ID0ge1xuICAgICAgICB0eXBlOiAncGF0dGVybicsXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICByZXBlYXQ6IHRoaXMucmVwZWF0LFxuICAgICAgICBjcm9zc09yaWdpbjogdGhpcy5jcm9zc09yaWdpbixcbiAgICAgICAgb2Zmc2V0WDogdG9GaXhlZCh0aGlzLm9mZnNldFgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICBvZmZzZXRZOiB0b0ZpeGVkKHRoaXMub2Zmc2V0WSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgIHBhdHRlcm5UcmFuc2Zvcm06IHRoaXMucGF0dGVyblRyYW5zZm9ybSA/IHRoaXMucGF0dGVyblRyYW5zZm9ybS5jb25jYXQoKSA6IG51bGxcbiAgICAgIH07XG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIG9iamVjdCwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHBhdHRlcm5cbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcGF0dGVyblNvdXJjZSA9IHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuc291cmNlKCkgOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICBwYXR0ZXJuV2lkdGggPSBwYXR0ZXJuU291cmNlLndpZHRoIC8gb2JqZWN0LndpZHRoLFxuICAgICAgICAgIHBhdHRlcm5IZWlnaHQgPSBwYXR0ZXJuU291cmNlLmhlaWdodCAvIG9iamVjdC5oZWlnaHQsXG4gICAgICAgICAgcGF0dGVybk9mZnNldFggPSB0aGlzLm9mZnNldFggLyBvYmplY3Qud2lkdGgsXG4gICAgICAgICAgcGF0dGVybk9mZnNldFkgPSB0aGlzLm9mZnNldFkgLyBvYmplY3QuaGVpZ2h0LFxuICAgICAgICAgIHBhdHRlcm5JbWdTcmMgPSAnJztcbiAgICAgIGlmICh0aGlzLnJlcGVhdCA9PT0gJ3JlcGVhdC14JyB8fCB0aGlzLnJlcGVhdCA9PT0gJ25vLXJlcGVhdCcpIHtcbiAgICAgICAgcGF0dGVybkhlaWdodCA9IDE7XG4gICAgICAgIGlmIChwYXR0ZXJuT2Zmc2V0WSkge1xuICAgICAgICAgIHBhdHRlcm5IZWlnaHQgKz0gTWF0aC5hYnMocGF0dGVybk9mZnNldFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZXBlYXQgPT09ICdyZXBlYXQteScgfHwgdGhpcy5yZXBlYXQgPT09ICduby1yZXBlYXQnKSB7XG4gICAgICAgIHBhdHRlcm5XaWR0aCA9IDE7XG4gICAgICAgIGlmIChwYXR0ZXJuT2Zmc2V0WCkge1xuICAgICAgICAgIHBhdHRlcm5XaWR0aCArPSBNYXRoLmFicyhwYXR0ZXJuT2Zmc2V0WCk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgaWYgKHBhdHRlcm5Tb3VyY2Uuc3JjKSB7XG4gICAgICAgIHBhdHRlcm5JbWdTcmMgPSBwYXR0ZXJuU291cmNlLnNyYztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHBhdHRlcm5Tb3VyY2UudG9EYXRhVVJMKSB7XG4gICAgICAgIHBhdHRlcm5JbWdTcmMgPSBwYXR0ZXJuU291cmNlLnRvRGF0YVVSTCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzxwYXR0ZXJuIGlkPVwiU1ZHSURfJyArIHRoaXMuaWQgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgeD1cIicgKyBwYXR0ZXJuT2Zmc2V0WCArXG4gICAgICAgICAgICAgICAgICAgICdcIiB5PVwiJyArIHBhdHRlcm5PZmZzZXRZICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIHdpZHRoPVwiJyArIHBhdHRlcm5XaWR0aCArXG4gICAgICAgICAgICAgICAgICAgICdcIiBoZWlnaHQ9XCInICsgcGF0dGVybkhlaWdodCArICdcIj5cXG4nICtcbiAgICAgICAgICAgICAgICc8aW1hZ2UgeD1cIjBcIiB5PVwiMFwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgJyB3aWR0aD1cIicgKyBwYXR0ZXJuU291cmNlLndpZHRoICtcbiAgICAgICAgICAgICAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyArIHBhdHRlcm5Tb3VyY2UuaGVpZ2h0ICtcbiAgICAgICAgICAgICAgICAgICAgICAnXCIgeGxpbms6aHJlZj1cIicgKyBwYXR0ZXJuSW1nU3JjICtcbiAgICAgICAgICAgICAgICdcIj48L2ltYWdlPlxcbicgK1xuICAgICAgICAgICAgICc8L3BhdHRlcm4+XFxuJztcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIENhbnZhc1BhdHRlcm5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gY3JlYXRlIHBhdHRlcm5cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNQYXR0ZXJufVxuICAgICAqL1xuICAgIHRvTGl2ZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAvLyBpZiB0aGUgaW1hZ2UgZmFpbGVkIHRvIGxvYWQsIHJldHVybiwgYW5kIGFsbG93IHJlc3QgdG8gY29udGludWUgbG9hZGluZ1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbiBpbWFnZVxuICAgICAgaWYgKHR5cGVvZiBzb3VyY2Uuc3JjICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIXNvdXJjZS5jb21wbGV0ZSkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlLm5hdHVyYWxXaWR0aCA9PT0gMCB8fCBzb3VyY2UubmF0dXJhbEhlaWdodCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHNvdXJjZSwgdGhpcy5yZXBlYXQpO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgaWYgKGZhYnJpYy5TaGFkb3cpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlNoYWRvdyBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoYWRvdyBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlNoYWRvd1xuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL3NoYWRvd3N8U2hhZG93IGRlbW99XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5TaGFkb3cjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5TaGFkb3cgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5TaGFkb3cucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBjb2xvclxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29sb3I6ICdyZ2IoMCwwLDApJyxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBibHVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgYmx1cjogMCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBob3Jpem9udGFsIG9mZnNldFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb2Zmc2V0WDogMCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyB2ZXJ0aWNhbCBvZmZzZXRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9mZnNldFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBzaGFkb3cgc2hvdWxkIGFmZmVjdCBzdHJva2Ugb3BlcmF0aW9uc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFmZmVjdFN0cm9rZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0b09iamVjdCBzaG91bGQgaW5jbHVkZSBkZWZhdWx0IHZhbHVlc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGluY2x1ZGVEZWZhdWx0VmFsdWVzOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgZmFsc2VgLCB0aGUgc2hhZG93IHdpbGwgc2NhbGUgd2l0aCB0aGUgb2JqZWN0LlxuICAgICAqIFdoZW4gYHRydWVgLCB0aGUgc2hhZG93J3Mgb2Zmc2V0WCwgb2Zmc2V0WSwgYW5kIGJsdXIgd2lsbCBub3QgYmUgYWZmZWN0ZWQgYnkgdGhlIG9iamVjdCdzIHNjYWxlLlxuICAgICAqIGRlZmF1bHQgdG8gZmFsc2VcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBub25TY2FsaW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgd2l0aCBhbnkgb2YgY29sb3IsIGJsdXIsIG9mZnNldFgsIG9mZnNldFkgcHJvcGVydGllcyBvciBzdHJpbmcgKGUuZy4gXCJyZ2JhKDAsMCwwLDAuMikgMnB4IDJweCAxMHB4XCIpXG4gICAgICogQHJldHVybiB7ZmFicmljLlNoYWRvd30gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5fcGFyc2VTaGFkb3cob3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pZCA9IGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2hhZG93IFNoYWRvdyB2YWx1ZSB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gU2hhZG93IG9iamVjdCB3aXRoIGNvbG9yLCBvZmZzZXRYLCBvZmZzZXRZIGFuZCBibHVyXG4gICAgICovXG4gICAgX3BhcnNlU2hhZG93OiBmdW5jdGlvbihzaGFkb3cpIHtcbiAgICAgIHZhciBzaGFkb3dTdHIgPSBzaGFkb3cudHJpbSgpLFxuICAgICAgICAgIG9mZnNldHNBbmRCbHVyID0gZmFicmljLlNoYWRvdy5yZU9mZnNldHNBbmRCbHVyLmV4ZWMoc2hhZG93U3RyKSB8fCBbXSxcbiAgICAgICAgICBjb2xvciA9IHNoYWRvd1N0ci5yZXBsYWNlKGZhYnJpYy5TaGFkb3cucmVPZmZzZXRzQW5kQmx1ciwgJycpIHx8ICdyZ2IoMCwwLDApJztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sb3I6IGNvbG9yLnRyaW0oKSxcbiAgICAgICAgb2Zmc2V0WDogcGFyc2VGbG9hdChvZmZzZXRzQW5kQmx1clsxXSwgMTApIHx8IDAsXG4gICAgICAgIG9mZnNldFk6IHBhcnNlRmxvYXQob2Zmc2V0c0FuZEJsdXJbMl0sIDEwKSB8fCAwLFxuICAgICAgICBibHVyOiBwYXJzZUZsb2F0KG9mZnNldHNBbmRCbHVyWzNdLCAxMCkgfHwgMFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzLXRleHQtZGVjb3ItMy8jdGV4dC1zaGFkb3dcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgQ1NTMyB0ZXh0LXNoYWRvdyBkZWNsYXJhdGlvblxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbdGhpcy5vZmZzZXRYLCB0aGlzLm9mZnNldFksIHRoaXMuYmx1ciwgdGhpcy5jb2xvcl0uam9pbigncHggJyk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3dcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGEgc2hhZG93XG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIGZCb3hYID0gNDAsIGZCb3hZID0gNDAsIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMsXG4gICAgICAgICAgb2Zmc2V0ID0gZmFicmljLnV0aWwucm90YXRlVmVjdG9yKFxuICAgICAgICAgICAgeyB4OiB0aGlzLm9mZnNldFgsIHk6IHRoaXMub2Zmc2V0WSB9LFxuICAgICAgICAgICAgZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucygtb2JqZWN0LmFuZ2xlKSksXG4gICAgICAgICAgQkxVUl9CT1ggPSAyMCwgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpO1xuXG4gICAgICBpZiAob2JqZWN0LndpZHRoICYmIG9iamVjdC5oZWlnaHQpIHtcbiAgICAgICAgLy9odHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvZmlsdGVycy5odG1sI0ZpbHRlckVmZmVjdHNSZWdpb25cbiAgICAgICAgLy8gd2UgYWRkIHNvbWUgZXh0cmEgc3BhY2UgdG8gZmlsdGVyIGJveCB0byBjb250YWluIHRoZSBibHVyICggMjAgKVxuICAgICAgICBmQm94WCA9IHRvRml4ZWQoKE1hdGguYWJzKG9mZnNldC54KSArIHRoaXMuYmx1cikgLyBvYmplY3Qud2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpICogMTAwICsgQkxVUl9CT1g7XG4gICAgICAgIGZCb3hZID0gdG9GaXhlZCgoTWF0aC5hYnMob2Zmc2V0LnkpICsgdGhpcy5ibHVyKSAvIG9iamVjdC5oZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpICogMTAwICsgQkxVUl9CT1g7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0LmZsaXBYKSB7XG4gICAgICAgIG9mZnNldC54ICo9IC0xO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5mbGlwWSkge1xuICAgICAgICBvZmZzZXQueSAqPSAtMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgJzxmaWx0ZXIgaWQ9XCJTVkdJRF8nICsgdGhpcy5pZCArICdcIiB5PVwiLScgKyBmQm94WSArICclXCIgaGVpZ2h0PVwiJyArICgxMDAgKyAyICogZkJveFkpICsgJyVcIiAnICtcbiAgICAgICAgICAneD1cIi0nICsgZkJveFggKyAnJVwiIHdpZHRoPVwiJyArICgxMDAgKyAyICogZkJveFgpICsgJyVcIiAnICsgJz5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlR2F1c3NpYW5CbHVyIGluPVwiU291cmNlQWxwaGFcIiBzdGREZXZpYXRpb249XCInICtcbiAgICAgICAgICAgIHRvRml4ZWQodGhpcy5ibHVyID8gdGhpcy5ibHVyIC8gMiA6IDAsIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJ1wiPjwvZmVHYXVzc2lhbkJsdXI+XFxuJyArXG4gICAgICAgICAgJ1xcdDxmZU9mZnNldCBkeD1cIicgKyB0b0ZpeGVkKG9mZnNldC54LCBOVU1fRlJBQ1RJT05fRElHSVRTKSArXG4gICAgICAgICAgJ1wiIGR5PVwiJyArIHRvRml4ZWQob2Zmc2V0LnksIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJ1wiIHJlc3VsdD1cIm9CbHVyXCIgPjwvZmVPZmZzZXQ+XFxuJyArXG4gICAgICAgICAgJ1xcdDxmZUZsb29kIGZsb29kLWNvbG9yPVwiJyArIGNvbG9yLnRvUmdiKCkgKyAnXCIgZmxvb2Qtb3BhY2l0eT1cIicgKyBjb2xvci5nZXRBbHBoYSgpICsgJ1wiLz5cXG4nICtcbiAgICAgICAgICAnXFx0PGZlQ29tcG9zaXRlIGluMj1cIm9CbHVyXCIgb3BlcmF0b3I9XCJpblwiIC8+XFxuJyArXG4gICAgICAgICAgJ1xcdDxmZU1lcmdlPlxcbicgK1xuICAgICAgICAgICAgJ1xcdFxcdDxmZU1lcmdlTm9kZT48L2ZlTWVyZ2VOb2RlPlxcbicgK1xuICAgICAgICAgICAgJ1xcdFxcdDxmZU1lcmdlTm9kZSBpbj1cIlNvdXJjZUdyYXBoaWNcIj48L2ZlTWVyZ2VOb2RlPlxcbicgK1xuICAgICAgICAgICdcXHQ8L2ZlTWVyZ2U+XFxuJyArXG4gICAgICAgICc8L2ZpbHRlcj5cXG4nKTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3dcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvdyBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgICAgYmx1cjogdGhpcy5ibHVyLFxuICAgICAgICAgIG9mZnNldFg6IHRoaXMub2Zmc2V0WCxcbiAgICAgICAgICBvZmZzZXRZOiB0aGlzLm9mZnNldFksXG4gICAgICAgICAgYWZmZWN0U3Ryb2tlOiB0aGlzLmFmZmVjdFN0cm9rZSxcbiAgICAgICAgICBub25TY2FsaW5nOiB0aGlzLm5vblNjYWxpbmdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB7IH0sIHByb3RvID0gZmFicmljLlNoYWRvdy5wcm90b3R5cGU7XG5cbiAgICAgIFsnY29sb3InLCAnYmx1cicsICdvZmZzZXRYJywgJ29mZnNldFknLCAnYWZmZWN0U3Ryb2tlJywgJ25vblNjYWxpbmcnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgaWYgKHRoaXNbcHJvcF0gIT09IHByb3RvW3Byb3BdKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gdGhpc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmVnZXggbWF0Y2hpbmcgc2hhZG93IG9mZnNldFgsIG9mZnNldFkgYW5kIGJsdXIgKGV4OiBcIjJweCAycHggMTBweCByZ2JhKDAsMCwwLDAuMilcIiwgXCJyZ2IoMCwyNTUsMCkgMnB4IDJweFwiKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLlNoYWRvd1xuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgZmFicmljLlNoYWRvdy5yZU9mZnNldHNBbmRCbHVyID0gLyg/Olxcc3xeKSgtP1xcZCsoPzpcXC5cXGQqKT8oPzpweCk/KD86XFxzP3wkKSk/KC0/XFxkKyg/OlxcLlxcZCopPyg/OnB4KT8oPzpcXHM/fCQpKT8oXFxkKyg/OlxcLlxcZCopPyg/OnB4KT8pPyg/Olxccz98JCkoPzokfFxccykvO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uICgpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKGZhYnJpYy5TdGF0aWNDYW52YXMpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlN0YXRpY0NhbnZhcyBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gYWxpYXNlcyBmb3IgZmFzdGVyIHJlc29sdXRpb25cbiAgdmFyIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBnZXRFbGVtZW50T2Zmc2V0ID0gZmFicmljLnV0aWwuZ2V0RWxlbWVudE9mZnNldCxcbiAgICAgIHJlbW92ZUZyb21BcnJheSA9IGZhYnJpYy51dGlsLnJlbW92ZUZyb21BcnJheSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgdHJhbnNmb3JtUG9pbnQgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludCxcbiAgICAgIGludmVydFRyYW5zZm9ybSA9IGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybSxcbiAgICAgIGdldE5vZGVDYW52YXMgPSBmYWJyaWMudXRpbC5nZXROb2RlQ2FudmFzLFxuICAgICAgY3JlYXRlQ2FudmFzRWxlbWVudCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQsXG5cbiAgICAgIENBTlZBU19JTklUX0VSUk9SID0gbmV3IEVycm9yKCdDb3VsZCBub3QgaW5pdGlhbGl6ZSBgY2FudmFzYCBlbGVtZW50Jyk7XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBjYW52YXMgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5TdGF0aWNDYW52YXNcbiAgICogQG1peGVzIGZhYnJpYy5Db2xsZWN0aW9uXG4gICAqIEBtaXhlcyBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL3N0YXRpY19jYW52YXN8U3RhdGljQ2FudmFzIGRlbW99XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQGZpcmVzIGJlZm9yZTpyZW5kZXJcbiAgICogQGZpcmVzIGFmdGVyOnJlbmRlclxuICAgKiBAZmlyZXMgY2FudmFzOmNsZWFyZWRcbiAgICogQGZpcmVzIG9iamVjdDphZGRlZFxuICAgKiBAZmlyZXMgb2JqZWN0OnJlbW92ZWRcbiAgICovXG4gIGZhYnJpYy5TdGF0aWNDYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQ29tbW9uTWV0aG9kcywgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTdHJpbmd9IGVsICZsdDtjYW52YXM+IGVsZW1lbnQgdG8gaW5pdGlhbGl6ZSBpbnN0YW5jZSBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB0aGlzLnJlbmRlckFuZFJlc2V0Qm91bmQgPSB0aGlzLnJlbmRlckFuZFJlc2V0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLnJlcXVlc3RSZW5kZXJBbGxCb3VuZCA9IHRoaXMucmVxdWVzdFJlbmRlckFsbC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5faW5pdFN0YXRpYyhlbCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJhY2tncm91bmQgY29sb3Igb2YgY2FudmFzIGluc3RhbmNlLlxuICAgICAqIFNob3VsZCBiZSBzZXQgdmlhIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI3NldEJhY2tncm91bmRDb2xvcn0uXG4gICAgICogQHR5cGUgeyhTdHJpbmd8ZmFicmljLlBhdHRlcm4pfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYmFja2dyb3VuZENvbG9yOiAnJyxcblxuICAgIC8qKlxuICAgICAqIEJhY2tncm91bmQgaW1hZ2Ugb2YgY2FudmFzIGluc3RhbmNlLlxuICAgICAqIHNpbmNlIDIuNC4wIGltYWdlIGNhY2hpbmcgaXMgYWN0aXZlLCBwbGVhc2Ugd2hlbiBwdXR0aW5nIGFuIGltYWdlIGFzIGJhY2tncm91bmQsIGFkZCB0byB0aGVcbiAgICAgKiBjYW52YXMgcHJvcGVydHkgYSByZWZlcmVuY2UgdG8gdGhlIGNhbnZhcyBpdCBpcyBvbi4gT3RoZXJ3aXNlIHRoZSBpbWFnZSBjYW5ub3QgZGV0ZWN0IHRoZSB6b29tXG4gICAgICogdmFsZS4gQXMgYW4gYWx0ZXJuYXRpdmUgeW91IGNhbiBkaXNhYmxlIGltYWdlIG9iamVjdENhY2hpbmdcbiAgICAgKiBAdHlwZSBmYWJyaWMuSW1hZ2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRJbWFnZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE92ZXJsYXkgY29sb3Igb2YgY2FudmFzIGluc3RhbmNlLlxuICAgICAqIFNob3VsZCBiZSBzZXQgdmlhIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI3NldE92ZXJsYXlDb2xvcn1cbiAgICAgKiBAc2luY2UgMS4zLjlcbiAgICAgKiBAdHlwZSB7KFN0cmluZ3xmYWJyaWMuUGF0dGVybil9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvdmVybGF5Q29sb3I6ICcnLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcmxheSBpbWFnZSBvZiBjYW52YXMgaW5zdGFuY2UuXG4gICAgICogc2luY2UgMi40LjAgaW1hZ2UgY2FjaGluZyBpcyBhY3RpdmUsIHBsZWFzZSB3aGVuIHB1dHRpbmcgYW4gaW1hZ2UgYXMgb3ZlcmxheSwgYWRkIHRvIHRoZVxuICAgICAqIGNhbnZhcyBwcm9wZXJ0eSBhIHJlZmVyZW5jZSB0byB0aGUgY2FudmFzIGl0IGlzIG9uLiBPdGhlcndpc2UgdGhlIGltYWdlIGNhbm5vdCBkZXRlY3QgdGhlIHpvb21cbiAgICAgKiB2YWxlLiBBcyBhbiBhbHRlcm5hdGl2ZSB5b3UgY2FuIGRpc2FibGUgaW1hZ2Ugb2JqZWN0Q2FjaGluZ1xuICAgICAqIEB0eXBlIGZhYnJpYy5JbWFnZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxheUltYWdlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdG9PYmplY3QvdG9EYXRhbGVzc09iamVjdCBzaG91bGQgaW5jbHVkZSBkZWZhdWx0IHZhbHVlc1xuICAgICAqIGlmIHNldCB0byBmYWxzZSwgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoZSBvYmplY3QgdmFsdWUuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW5jbHVkZURlZmF1bHRWYWx1ZXM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvYmplY3RzJyBzdGF0ZSBzaG91bGQgYmUgc2F2ZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdGF0ZWZ1bDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB7QGxpbmsgZmFicmljLkNvbGxlY3Rpb24uYWRkfSwge0BsaW5rIGZhYnJpYy5Db2xsZWN0aW9uLmluc2VydEF0fSBhbmQge0BsaW5rIGZhYnJpYy5Db2xsZWN0aW9uLnJlbW92ZX0sXG4gICAgICoge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMubW92ZVRvfSwge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMuY2xlYXJ9IGFuZCBtYW55IG1vcmUsIHNob3VsZCBhbHNvIHJlLXJlbmRlciBjYW52YXMuXG4gICAgICogRGlzYWJsaW5nIHRoaXMgb3B0aW9uIHdpbGwgbm90IGdpdmUgYSBwZXJmb3JtYW5jZSBib29zdCB3aGVuIGFkZGluZy9yZW1vdmluZyBhIGxvdCBvZiBvYmplY3RzIHRvL2Zyb20gY2FudmFzIGF0IG9uY2VcbiAgICAgKiBzaW5jZSB0aGUgcmVuZGVycyBhcmUgcXVlcXVlZCBhbmQgZXhlY3V0ZWQgb25lIHBlciBmcmFtZS5cbiAgICAgKiBEaXNhYmxpbmcgaXMgc3VnZ2VzdGVkIGFueXdheSBhbmQgbWFuYWdpbmcgdGhlIHJlbmRlcnMgb2YgdGhlIGFwcCBtYW51YWxseSBpcyBub3QgYSBiaWcgZWZmb3J0ICggY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKSApXG4gICAgICogTGVmdCBkZWZhdWx0IHRvIHRydWUgdG8gZG8gbm90IGJyZWFrIGRvY3VtZW50YXRpb24gYW5kIG9sZCBhcHAsIGZpZGRsZXMuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmVuZGVyT25BZGRSZW1vdmU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvYmplY3QgY29udHJvbHMgKGJvcmRlcnMvY29udHJvbHMpIGFyZSByZW5kZXJlZCBhYm92ZSBvdmVybGF5IGltYWdlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29udHJvbHNBYm92ZU92ZXJsYXk6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJyb3dzZXIgY2FuIGJlIHNjcm9sbGVkIHdoZW4gdXNpbmcgYSB0b3VjaHNjcmVlbiBhbmQgZHJhZ2dpbmcgb24gdGhlIGNhbnZhc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFsbG93VG91Y2hTY3JvbGxpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBjYW52YXMgd2lsbCB1c2UgaW1hZ2Ugc21vb3RoaW5nLCB0aGlzIGlzIG9uIGJ5IGRlZmF1bHQgaW4gYnJvd3NlcnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbWFnZVNtb290aGluZ0VuYWJsZWQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNmb3JtYXRpb24gKGEgQ2FudmFzIDJEIEFQSSB0cmFuc2Zvcm0gbWF0cml4KSB3aGljaCBmb2N1c2VzIHRoZSB2aWV3cG9ydFxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RGVmYXVsdCB0cmFuc2Zvcm08L2NhcHRpb24+XG4gICAgICogY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNjYWxlIGJ5IDcwJSBhbmQgdHJhbnNsYXRlIHRvd2FyZCBib3R0b20tcmlnaHQgYnkgNTAsIHdpdGhvdXQgc2tld2luZzwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMudmlld3BvcnRUcmFuc2Zvcm0gPSBbMC43LCAwLCAwLCAwLjcsIDUwLCA1MF07XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB2aWV3cG9ydFRyYW5zZm9ybTogZmFicmljLmlNYXRyaXguY29uY2F0KCksXG5cbiAgICAvKipcbiAgICAgKiBpZiBzZXQgdG8gZmFsc2UgYmFja2dyb3VuZCBpbWFnZSBpcyBub3QgYWZmZWN0ZWQgYnkgdmlld3BvcnQgdHJhbnNmb3JtXG4gICAgICogQHNpbmNlIDEuNi4zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYmFja2dyb3VuZFZwdDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIGlmIHNldCB0byBmYWxzZSBvdmVybHlhIGltYWdlIGlzIG5vdCBhZmZlY3RlZCBieSB2aWV3cG9ydCB0cmFuc2Zvcm1cbiAgICAgKiBAc2luY2UgMS42LjNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvdmVybGF5VnB0OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBjYW52YXMgaXMgc2NhbGVkIGJ5IGRldmljZVBpeGVsUmF0aW8gZm9yIGJldHRlciByZW5kZXJpbmcgb24gcmV0aW5hIHNjcmVlbnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBlbmFibGVSZXRpbmFTY2FsaW5nOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgY2FudmFzIGVsZW1lbnQgZXh0ZW5zaW9uIG92ZXIgZGVzaWduXG4gICAgICogcHJvcGVydGllcyBhcmUgdGwsdHIsYmwsYnIuXG4gICAgICogaWYgY2FudmFzIGlzIG5vdCB6b29tZWQvcGFubmVkIHRob3NlIHBvaW50cyBhcmUgdGhlIGZvdXIgY29ybmVyIG9mIGNhbnZhc1xuICAgICAqIGlmIGNhbnZhcyBpcyB2aWV3cG9ydFRyYW5zZm9ybWVkIHlvdSB0aG9zZSBwb2ludHMgaW5kaWNhdGUgdGhlIGV4dGVuc2lvblxuICAgICAqIG9mIGNhbnZhcyBlbGVtZW50IGluIHBsYWluIHVudHJhc2Zvcm1lZCBjb29yZGluYXRlc1xuICAgICAqIFRoZSBjb29yZGluYXRlcyBnZXQgdXBkYXRlZCB3aXRoIEBtZXRob2QgY2FsY1ZpZXdwb3J0Qm91bmRhcmllcy5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB2cHRDb29yZHM6IHsgfSxcblxuICAgIC8qKlxuICAgICAqIEJhc2VkIG9uIHZwdENvb3JkcyBhbmQgb2JqZWN0LmFDb29yZHMsIHNraXAgcmVuZGVyaW5nIG9mIG9iamVjdHMgdGhhdFxuICAgICAqIGFyZSBub3QgaW5jbHVkZWQgaW4gY3VycmVudCB2aWV3cG9ydC5cbiAgICAgKiBNYXkgZ3JlYXRseSBoZWxwIGluIGFwcGxpY2F0aW9ucyB3aXRoIGNyb3dkZWQgY2FudmFzIGFuZCB1c2Ugb2Ygem9vbS9wYW5cbiAgICAgKiBJZiBPbmUgb2YgdGhlIGNvcm5lciBvZiB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBvYmplY3QgaXMgb24gdGhlIGNhbnZhc1xuICAgICAqIHRoZSBvYmplY3RzIGdldCByZW5kZXJlZC5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGVcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBza2lwT2Zmc2NyZWVuOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogYSBmYWJyaWNPYmplY3QgdGhhdCwgd2l0aG91dCBzdHJva2UgZGVmaW5lIGEgY2xpcHBpbmcgYXJlYSB3aXRoIHRoZWlyIHNoYXBlLiBmaWxsZWQgaW4gYmxhY2tcbiAgICAgKiB0aGUgY2xpcFBhdGggb2JqZWN0IGdldHMgdXNlZCB3aGVuIHRoZSBjYW52YXMgaGFzIHJlbmRlcmVkLCBhbmQgdGhlIGNvbnRleHQgaXMgcGxhY2VkIGluIHRoZVxuICAgICAqIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzLlxuICAgICAqIGNsaXBQYXRoIHdpbGwgY2xpcCBhd2F5IGNvbnRyb2xzLCBpZiB5b3UgZG8gbm90IHdhbnQgdGhpcyB0byBoYXBwZW4gdXNlIGNvbnRyb2xzQWJvdmVPdmVybGF5ID0gdHJ1ZVxuICAgICAqIEB0eXBlIGZhYnJpYy5PYmplY3RcbiAgICAgKi9cbiAgICBjbGlwUGF0aDogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU3RyaW5nfSBlbCAmbHQ7Y2FudmFzPiBlbGVtZW50IHRvIGluaXRpYWxpemUgaW5zdGFuY2Ugb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRTdGF0aWM6IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2IgPSB0aGlzLnJlcXVlc3RSZW5kZXJBbGxCb3VuZDtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBbXTtcbiAgICAgIHRoaXMuX2NyZWF0ZUxvd2VyQ2FudmFzKGVsKTtcbiAgICAgIHRoaXMuX2luaXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgLy8gb25seSBpbml0aWFsaXplIHJldGluYSBzY2FsaW5nIG9uY2VcbiAgICAgIGlmICghdGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLl9pbml0UmV0aW5hU2NhbGluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vdmVybGF5SW1hZ2UpIHtcbiAgICAgICAgdGhpcy5zZXRPdmVybGF5SW1hZ2Uob3B0aW9ucy5vdmVybGF5SW1hZ2UsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICB0aGlzLnNldEJhY2tncm91bmRJbWFnZShvcHRpb25zLmJhY2tncm91bmRJbWFnZSwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHRoaXMuc2V0QmFja2dyb3VuZENvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vdmVybGF5Q29sb3IpIHtcbiAgICAgICAgdGhpcy5zZXRPdmVybGF5Q29sb3Iob3B0aW9ucy5vdmVybGF5Q29sb3IsIGNiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1JldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyA+IDEgJiYgdGhpcy5lbmFibGVSZXRpbmFTY2FsaW5nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJldGluYVNjYWxpbmcgaWYgYXBwbGllZCwgb3RoZXJ3aXNlIDE7XG4gICAgICovXG4gICAgZ2V0UmV0aW5hU2NhbGluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNSZXRpbmFTY2FsaW5nKCkgPyBNYXRoLm1heCgxLCBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbykgOiAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0UmV0aW5hU2NhbGluZzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzUmV0aW5hU2NhbGluZygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzY2FsZVJhdGlvID0gZmFicmljLmRldmljZVBpeGVsUmF0aW87XG4gICAgICB0aGlzLl9faW5pdFJldGluYVNjYWxpbmcoc2NhbGVSYXRpbywgdGhpcy5sb3dlckNhbnZhc0VsLCB0aGlzLmNvbnRleHRDb250YWluZXIpO1xuICAgICAgaWYgKHRoaXMudXBwZXJDYW52YXNFbCkge1xuICAgICAgICB0aGlzLl9faW5pdFJldGluYVNjYWxpbmcoc2NhbGVSYXRpbywgdGhpcy51cHBlckNhbnZhc0VsLCB0aGlzLmNvbnRleHRUb3ApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfX2luaXRSZXRpbmFTY2FsaW5nOiBmdW5jdGlvbihzY2FsZVJhdGlvLCBjYW52YXMsIGNvbnRleHQpIHtcbiAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy53aWR0aCAqIHNjYWxlUmF0aW8pO1xuICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5oZWlnaHQgKiBzY2FsZVJhdGlvKTtcbiAgICAgIGNvbnRleHQuc2NhbGUoc2NhbGVSYXRpbywgc2NhbGVSYXRpbyk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBjYW52YXMgZWxlbWVudCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50XG4gICAgICogVGhpcyBtZXRob2QgaXMgYWxzbyBhdHRhY2hlZCBhcyBcInJlc2l6ZVwiIGV2ZW50IGhhbmRsZXIgb2Ygd2luZG93XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2FsY09mZnNldDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5fb2Zmc2V0ID0gZ2V0RWxlbWVudE9mZnNldCh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjb3ZlcmxheUltYWdlfG92ZXJsYXkgaW1hZ2V9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KGZhYnJpYy5JbWFnZXxTdHJpbmcpfSBpbWFnZSBmYWJyaWMuSW1hZ2UgaW5zdGFuY2Ugb3IgVVJMIG9mIGFuIGltYWdlIHRvIHNldCBvdmVybGF5IHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gaW1hZ2UgaXMgbG9hZGVkIGFuZCBzZXQgYXMgYW4gb3ZlcmxheVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyB0byBzZXQgZm9yIHRoZSB7QGxpbmsgZmFicmljLkltYWdlfG92ZXJsYXkgaW1hZ2V9LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9NbnpIVC98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgb3ZlcmxheUltYWdlIHdpdGggbGVmdC90b3AgPSAwPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5SW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2phaWxfY2VsbF9iYXJzLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICAvLyBOZWVkZWQgdG8gcG9zaXRpb24gb3ZlcmxheUltYWdlIGF0IDAvMFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5vdmVybGF5SW1hZ2Ugd2l0aCBkaWZmZXJlbnQgcHJvcGVydGllczwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgb3BhY2l0eTogMC41LFxuICAgICAqICAgYW5nbGU6IDQ1LFxuICAgICAqICAgbGVmdDogNDAwLFxuICAgICAqICAgdG9wOiA0MDAsXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN0cmV0Y2hlZCBvdmVybGF5SW1hZ2UgIzEgLSB3aWR0aC9oZWlnaHQgY29ycmVzcG9uZCB0byBjYW52YXMgd2lkdGgvaGVpZ2h0PC9jYXB0aW9uPlxuICAgICAqIGZhYnJpYy5JbWFnZS5mcm9tVVJMKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBmdW5jdGlvbihpbWcsIGlzRXJyb3IpIHtcbiAgICAgKiAgICBpbWcuc2V0KHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsIG9yaWdpblg6ICdsZWZ0Jywgb3JpZ2luWTogJ3RvcCd9KTtcbiAgICAgKiAgICBjYW52YXMuc2V0T3ZlcmxheUltYWdlKGltZywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN0cmV0Y2hlZCBvdmVybGF5SW1hZ2UgIzIgLSB3aWR0aC9oZWlnaHQgY29ycmVzcG9uZCB0byBjYW52YXMgd2lkdGgvaGVpZ2h0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5SW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2phaWxfY2VsbF9iYXJzLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAqICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIG92ZXJsYXlJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+b3ZlcmxheUltYWdlIGxvYWRlZCBmcm9tIGNyb3NzLW9yaWdpbjwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgb3BhY2l0eTogMC41LFxuICAgICAqICAgYW5nbGU6IDQ1LFxuICAgICAqICAgbGVmdDogNDAwLFxuICAgICAqICAgdG9wOiA0MDAsXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJyxcbiAgICAgKiAgIGNyb3NzT3JpZ2luOiAnYW5vbnltb3VzJ1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNldE92ZXJsYXlJbWFnZTogZnVuY3Rpb24gKGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZXRCZ092ZXJsYXlJbWFnZSgnb3ZlcmxheUltYWdlJywgaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kSW1hZ2V8YmFja2dyb3VuZCBpbWFnZX0gZm9yIHRoaXMgY2FudmFzXG4gICAgICogQHBhcmFtIHsoZmFicmljLkltYWdlfFN0cmluZyl9IGltYWdlIGZhYnJpYy5JbWFnZSBpbnN0YW5jZSBvciBVUkwgb2YgYW4gaW1hZ2UgdG8gc2V0IGJhY2tncm91bmQgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBpbWFnZSBpcyBsb2FkZWQgYW5kIHNldCBhcyBiYWNrZ3JvdW5kXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBvcHRpb25zIHRvIHNldCBmb3IgdGhlIHtAbGluayBmYWJyaWMuSW1hZ2V8YmFja2dyb3VuZCBpbWFnZX0uXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2RqbnI4bzdhLzI4L3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBiYWNrZ3JvdW5kSW1hZ2Ugd2l0aCBsZWZ0L3RvcCA9IDA8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICAvLyBOZWVkZWQgdG8gcG9zaXRpb24gYmFja2dyb3VuZEltYWdlIGF0IDAvMFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5iYWNrZ3JvdW5kSW1hZ2Ugd2l0aCBkaWZmZXJlbnQgcHJvcGVydGllczwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9ob25leV9pbV9zdWJ0bGUucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgYmFja2dyb3VuZEltYWdlICMxIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBmYWJyaWMuSW1hZ2UuZnJvbVVSTCgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAqICAgIGltZy5zZXQoe3dpZHRoOiBjYW52YXMud2lkdGgsIGhlaWdodDogY2FudmFzLmhlaWdodCwgb3JpZ2luWDogJ2xlZnQnLCBvcmlnaW5ZOiAndG9wJ30pO1xuICAgICAqICAgIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoaW1nLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3RyZXRjaGVkIGJhY2tncm91bmRJbWFnZSAjMiAtIHdpZHRoL2hlaWdodCBjb3JyZXNwb25kIHRvIGNhbnZhcyB3aWR0aC9oZWlnaHQ8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAqICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIGJhY2tncm91bmRJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+YmFja2dyb3VuZEltYWdlIGxvYWRlZCBmcm9tIGNyb3NzLW9yaWdpbjwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9ob25leV9pbV9zdWJ0bGUucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgICogICBjcm9zc09yaWdpbjogJ2Fub255bW91cydcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICAvLyBUT0RPOiBmaXggc3RyZXRjaGVkIGV4YW1wbGVzXG4gICAgc2V0QmFja2dyb3VuZEltYWdlOiBmdW5jdGlvbiAoaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NldEJnT3ZlcmxheUltYWdlKCdiYWNrZ3JvdW5kSW1hZ2UnLCBpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlDb2xvcnxmb3JlZ3JvdW5kIGNvbG9yfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhTdHJpbmd8ZmFicmljLlBhdHRlcm4pfSBvdmVybGF5Q29sb3IgQ29sb3Igb3IgcGF0dGVybiB0byBzZXQgZm9yZWdyb3VuZCBjb2xvciB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGZvcmVncm91bmQgY29sb3IgaXMgc2V0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL3BCNTVoL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBvdmVybGF5Q29sb3IgLSBjb2xvciB2YWx1ZTwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUNvbG9yKCdyZ2JhKDI1NSwgNzMsIDY0LCAwLjYpJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgb3ZlcmxheUNvbG9yPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRPdmVybGF5Q29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZydcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBvdmVybGF5Q29sb3Igd2l0aCByZXBlYXQgYW5kIG9mZnNldDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUNvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnLFxuICAgICAqICAgcmVwZWF0OiAncmVwZWF0JyxcbiAgICAgKiAgIG9mZnNldFg6IDIwMCxcbiAgICAgKiAgIG9mZnNldFk6IDEwMFxuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKi9cbiAgICBzZXRPdmVybGF5Q29sb3I6IGZ1bmN0aW9uKG92ZXJsYXlDb2xvciwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5Q29sb3IoJ292ZXJsYXlDb2xvcicsIG92ZXJsYXlDb2xvciwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2JhY2tncm91bmRDb2xvcnxiYWNrZ3JvdW5kIGNvbG9yfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhTdHJpbmd8ZmFicmljLlBhdHRlcm4pfSBiYWNrZ3JvdW5kQ29sb3IgQ29sb3Igb3IgcGF0dGVybiB0byBzZXQgYmFja2dyb3VuZCBjb2xvciB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGJhY2tncm91bmQgY29sb3IgaXMgc2V0XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL2hYenZrL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk5vcm1hbCBiYWNrZ3JvdW5kQ29sb3IgLSBjb2xvciB2YWx1ZTwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZENvbG9yKCdyZ2JhKDI1NSwgNzMsIDY0LCAwLjYpJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgYmFja2dyb3VuZENvbG9yPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kQ29sb3Ioe1xuICAgICAqICAgc291cmNlOiAnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvZXNjaGVyZXNxdWVfc3RlLnBuZydcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+ZmFicmljLlBhdHRlcm4gdXNlZCBhcyBiYWNrZ3JvdW5kQ29sb3Igd2l0aCByZXBlYXQgYW5kIG9mZnNldDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZENvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnLFxuICAgICAqICAgcmVwZWF0OiAncmVwZWF0JyxcbiAgICAgKiAgIG9mZnNldFg6IDIwMCxcbiAgICAgKiAgIG9mZnNldFk6IDEwMFxuICAgICAqIH0sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKi9cbiAgICBzZXRCYWNrZ3JvdW5kQ29sb3I6IGZ1bmN0aW9uKGJhY2tncm91bmRDb2xvciwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5Q29sb3IoJ2JhY2tncm91bmRDb2xvcicsIGJhY2tncm91bmRDb2xvciwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBzZXQgKHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2JhY2tncm91bmRJbWFnZXxiYWNrZ3JvdW5kSW1hZ2V9XG4gICAgICogb3Ige0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjb3ZlcmxheUltYWdlfG92ZXJsYXlJbWFnZX0pXG4gICAgICogQHBhcmFtIHsoZmFicmljLkltYWdlfFN0cmluZ3xudWxsKX0gaW1hZ2UgZmFicmljLkltYWdlIGluc3RhbmNlLCBVUkwgb2YgYW4gaW1hZ2Ugb3IgbnVsbCB0byBzZXQgYmFja2dyb3VuZCBvciBvdmVybGF5IHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gaW1hZ2UgaXMgbG9hZGVkIGFuZCBzZXQgYXMgYmFja2dyb3VuZCBvciBvdmVybGF5LiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgdGhlIGNyZWF0ZWQgaW1hZ2UsIHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYSBmbGFnIGluZGljYXRpbmcgd2hldGhlciBhbiBlcnJvciBvY2N1cnJlZCBvciBub3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBvcHRpb25zIHRvIHNldCBmb3IgdGhlIHtAbGluayBmYWJyaWMuSW1hZ2V8aW1hZ2V9LlxuICAgICAqL1xuICAgIF9fc2V0QmdPdmVybGF5SW1hZ2U6IGZ1bmN0aW9uKHByb3BlcnR5LCBpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZShpbWFnZSwgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICAgICAgaWYgKGltZykge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IGZhYnJpYy5JbWFnZShpbWcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIGluc3RhbmNlLmNhbnZhcyA9IHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGltZywgaXNFcnJvcik7XG4gICAgICAgIH0sIHRoaXMsIG9wdGlvbnMgJiYgb3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyAmJiBpbWFnZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGltYWdlO1xuICAgICAgICBpbWFnZSAmJiAoaW1hZ2UuY2FudmFzID0gdGhpcyk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGltYWdlLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBzZXQgKHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2JhY2tncm91bmRDb2xvcnxiYWNrZ3JvdW5kQ29sb3J9XG4gICAgICogb3Ige0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjb3ZlcmxheUNvbG9yfG92ZXJsYXlDb2xvcn0pXG4gICAgICogQHBhcmFtIHsoT2JqZWN0fFN0cmluZ3xudWxsKX0gY29sb3IgT2JqZWN0IHdpdGggcGF0dGVybiBpbmZvcm1hdGlvbiwgY29sb3IgdmFsdWUgb3IgbnVsbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgaXMgaW52b2tlZCB3aGVuIGNvbG9yIGlzIHNldFxuICAgICAqL1xuICAgIF9fc2V0QmdPdmVybGF5Q29sb3I6IGZ1bmN0aW9uKHByb3BlcnR5LCBjb2xvciwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXNbcHJvcGVydHldID0gY29sb3I7XG4gICAgICB0aGlzLl9pbml0R3JhZGllbnQoY29sb3IsIHByb3BlcnR5KTtcbiAgICAgIHRoaXMuX2luaXRQYXR0ZXJuKGNvbG9yLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUNhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgQ0FOVkFTX0lOSVRfRVJST1I7XG4gICAgICB9XG4gICAgICBpZiAoIWVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5nZXRDb250ZXh0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBDQU5WQVNfSU5JVF9FUlJPUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdE9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgbG93ZXJDYW52YXNFbCA9IHRoaXMubG93ZXJDYW52YXNFbDtcbiAgICAgIHRoaXMuX3NldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLndpZHRoIHx8IHBhcnNlSW50KGxvd2VyQ2FudmFzRWwud2lkdGgsIDEwKSB8fCAwO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmhlaWdodCB8fCBwYXJzZUludChsb3dlckNhbnZhc0VsLmhlaWdodCwgMTApIHx8IDA7XG5cbiAgICAgIGlmICghdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbG93ZXJDYW52YXNFbC53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICBsb3dlckNhbnZhc0VsLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgICBsb3dlckNhbnZhc0VsLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArICdweCc7XG4gICAgICBsb3dlckNhbnZhc0VsLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0uc2xpY2UoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJvdHRvbSBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtjYW52YXNFbF1cbiAgICAgKi9cbiAgICBfY3JlYXRlTG93ZXJDYW52YXM6IGZ1bmN0aW9uIChjYW52YXNFbCkge1xuICAgICAgLy8gY2FudmFzRWwgPT09ICdIVE1MQ2FudmFzRWxlbWVudCcgZG9lcyBub3Qgd29yayBvbiBqc2RvbS9ub2RlXG4gICAgICBpZiAoY2FudmFzRWwgJiYgY2FudmFzRWwuZ2V0Q29udGV4dCkge1xuICAgICAgICB0aGlzLmxvd2VyQ2FudmFzRWwgPSBjYW52YXNFbDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmxvd2VyQ2FudmFzRWwgPSBmYWJyaWMudXRpbC5nZXRCeUlkKGNhbnZhc0VsKSB8fCB0aGlzLl9jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB9XG5cbiAgICAgIGZhYnJpYy51dGlsLmFkZENsYXNzKHRoaXMubG93ZXJDYW52YXNFbCwgJ2xvd2VyLWNhbnZhcycpO1xuICAgICAgdGhpcy5fb3JpZ2luYWxDYW52YXNTdHlsZSA9IHRoaXMubG93ZXJDYW52YXNFbC5zdHlsZTtcbiAgICAgIGlmICh0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuX2FwcGx5Q2FudmFzU3R5bGUodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZXh0Q29udGFpbmVyID0gdGhpcy5sb3dlckNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2FudmFzIHdpZHRoIChpbiBweClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNhbnZhcyBoZWlnaHQgKGluIHB4KVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB3aWR0aCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gdmFsdWUgICAgICAgICAgICAgICAgICAgICAgICAgVmFsdWUgdG8gc2V0IHdpZHRoIHRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RGltZW5zaW9ucyh7IHdpZHRoOiB2YWx1ZSB9LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBoZWlnaHQgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlIHRvIHNldCBoZWlnaHQgdG9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIFtvcHRpb25zXSAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5iYWNrc3RvcmVPbmx5PWZhbHNlXSBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjYW52YXMgYmFja3N0b3JlIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmNzc09ubHk9ZmFsc2VdICAgICAgIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNzcyBkaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0RGltZW5zaW9ucyh7IGhlaWdodDogdmFsdWUgfSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgZGltZW5zaW9ucyAod2lkdGgsIGhlaWdodCkgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2UuIHdoZW4gb3B0aW9ucy5jc3NPbmx5IGZsYWcgYWN0aXZlIHlvdSBzaG91bGQgYWxzbyBzdXBwbHkgdGhlIHVuaXQgb2YgbWVhc3VyZSAocHgvJS9lbSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgIGRpbWVuc2lvbnMgICAgICAgICAgICAgICAgICAgIE9iamVjdCB3aXRoIHdpZHRoL2hlaWdodCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbZGltZW5zaW9ucy53aWR0aF0gICAgICAgICAgICBXaWR0aCBvZiBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW2RpbWVuc2lvbnMuaGVpZ2h0XSAgICAgICAgICAgSGVpZ2h0IG9mIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RGltZW5zaW9uczogZnVuY3Rpb24gKGRpbWVuc2lvbnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjc3NWYWx1ZTtcblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gZGltZW5zaW9ucykge1xuICAgICAgICBjc3NWYWx1ZSA9IGRpbWVuc2lvbnNbcHJvcF07XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmNzc09ubHkpIHtcbiAgICAgICAgICB0aGlzLl9zZXRCYWNrc3RvcmVEaW1lbnNpb24ocHJvcCwgZGltZW5zaW9uc1twcm9wXSk7XG4gICAgICAgICAgY3NzVmFsdWUgKz0gJ3B4JztcbiAgICAgICAgICB0aGlzLmhhc0xvc3RDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5iYWNrc3RvcmVPbmx5KSB7XG4gICAgICAgICAgdGhpcy5fc2V0Q3NzRGltZW5zaW9uKHByb3AsIGNzc1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2ggJiYgdGhpcy5mcmVlRHJhd2luZ0JydXNoLl9zZXRCcnVzaFN0eWxlcyh0aGlzLmNvbnRleHRUb3ApO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5pdFJldGluYVNjYWxpbmcoKTtcbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuY3NzT25seSkge1xuICAgICAgICB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmb3Igc2V0dGluZyB3aWR0aC9oZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIHByb3BlcnR5ICh3aWR0aHxoZWlnaHQpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHZhbHVlIHRvIHNldCBwcm9wZXJ0eSB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgX3NldEJhY2tzdG9yZURpbWVuc2lvbjogZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWxbcHJvcF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHRoaXMudXBwZXJDYW52YXNFbCkge1xuICAgICAgICB0aGlzLnVwcGVyQ2FudmFzRWxbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2FjaGVDYW52YXNFbCkge1xuICAgICAgICB0aGlzLmNhY2hlQ2FudmFzRWxbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpc1twcm9wXSA9IHZhbHVlO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZvciBzZXR0aW5nIGNzcyB3aWR0aC9oZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIHByb3BlcnR5ICh3aWR0aHxoZWlnaHQpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIHZhbHVlIHRvIHNldCBwcm9wZXJ0eSB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgX3NldENzc0RpbWVuc2lvbjogZnVuY3Rpb24gKHByb3AsIHZhbHVlKSB7XG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHRoaXMudXBwZXJDYW52YXNFbCkge1xuICAgICAgICB0aGlzLnVwcGVyQ2FudmFzRWwuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMud3JhcHBlckVsKSB7XG4gICAgICAgIHRoaXMud3JhcHBlckVsLnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNhbnZhcyB6b29tIGxldmVsXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFpvb206IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtWzBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHZpZXdwb3J0IHRyYW5zZm9ybWF0aW9uIG9mIHRoaXMgY2FudmFzIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gdnB0IGEgQ2FudmFzIDJEIEFQSSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBzZXRWaWV3cG9ydFRyYW5zZm9ybTogZnVuY3Rpb24gKHZwdCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBiYWNrZ3JvdW5kT2JqZWN0ID0gdGhpcy5iYWNrZ3JvdW5kSW1hZ2UsXG4gICAgICAgICAgb3ZlcmxheU9iamVjdCA9IHRoaXMub3ZlcmxheUltYWdlLFxuICAgICAgICAgIG9iamVjdCwgaSwgbGVuO1xuICAgICAgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSA9IHZwdDtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5fb2JqZWN0c1tpXTtcbiAgICAgICAgb2JqZWN0Lmdyb3VwIHx8IG9iamVjdC5zZXRDb29yZHModHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIGFjdGl2ZU9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChiYWNrZ3JvdW5kT2JqZWN0KSB7XG4gICAgICAgIGJhY2tncm91bmRPYmplY3Quc2V0Q29vcmRzKHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKG92ZXJsYXlPYmplY3QpIHtcbiAgICAgICAgb3ZlcmxheU9iamVjdC5zZXRDb29yZHModHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGNWaWV3cG9ydEJvdW5kYXJpZXMoKTtcbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB6b29tIGxldmVsIG9mIHRoaXMgY2FudmFzIGluc3RhbmNlLCB0aGUgem9vbSBjZW50ZXJlZCBhcm91bmQgcG9pbnRcbiAgICAgKiBtZWFuaW5nIHRoYXQgZm9sbG93aW5nIHpvb20gdG8gcG9pbnQgd2l0aCB0aGUgc2FtZSBwb2ludCB3aWxsIGhhdmUgdGhlIHZpc3VhbFxuICAgICAqIGVmZmVjdCBvZiB0aGUgem9vbSBvcmlnaW5hdGluZyBmcm9tIHRoYXQgcG9pbnQuIFRoZSBwb2ludCB3b24ndCBtb3ZlLlxuICAgICAqIEl0IGhhcyBub3RoaW5nIHRvIGRvIHdpdGggY2FudmFzIGNlbnRlciBvciB2aXN1YWwgY2VudGVyIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgdG8gem9vbSB3aXRoIHJlc3BlY3QgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdG8gc2V0IHpvb20gdG8sIGxlc3MgdGhhbiAxIHpvb21zIG91dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgem9vbVRvUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCwgdmFsdWUpIHtcbiAgICAgIC8vIFRPRE86IGp1c3QgY2hhbmdlIHRoZSBzY2FsZSwgcHJlc2VydmUgb3RoZXIgdHJhbnNmb3JtYXRpb25zXG4gICAgICB2YXIgYmVmb3JlID0gcG9pbnQsIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0uc2xpY2UoMCk7XG4gICAgICBwb2ludCA9IHRyYW5zZm9ybVBvaW50KHBvaW50LCBpbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSkpO1xuICAgICAgdnB0WzBdID0gdmFsdWU7XG4gICAgICB2cHRbM10gPSB2YWx1ZTtcbiAgICAgIHZhciBhZnRlciA9IHRyYW5zZm9ybVBvaW50KHBvaW50LCB2cHQpO1xuICAgICAgdnB0WzRdICs9IGJlZm9yZS54IC0gYWZ0ZXIueDtcbiAgICAgIHZwdFs1XSArPSBiZWZvcmUueSAtIGFmdGVyLnk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydFRyYW5zZm9ybSh2cHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHpvb20gbGV2ZWwgb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgdG8gc2V0IHpvb20gdG8sIGxlc3MgdGhhbiAxIHpvb21zIG91dFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0Wm9vbTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLnpvb21Ub1BvaW50KG5ldyBmYWJyaWMuUG9pbnQoMCwgMCksIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW4gdmlld3BvcnQgc28gYXMgdG8gcGxhY2UgcG9pbnQgYXQgdG9wIGxlZnQgY29ybmVyIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCB0byBtb3ZlIHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICBhYnNvbHV0ZVBhbjogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB2YXIgdnB0ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybS5zbGljZSgwKTtcbiAgICAgIHZwdFs0XSA9IC1wb2ludC54O1xuICAgICAgdnB0WzVdID0gLXBvaW50Lnk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydFRyYW5zZm9ybSh2cHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYW5zIHZpZXdwb2ludCByZWxhdGl2ZWx5XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IChwb3NpdGlvbiB2ZWN0b3IpIHRvIG1vdmUgYnlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHJlbGF0aXZlUGFuOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmFic29sdXRlUGFuKG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgIC1wb2ludC54IC0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybVs0XSxcbiAgICAgICAgLXBvaW50LnkgLSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtWzVdXG4gICAgICApKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyAmbHQ7Y2FudmFzPiBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvd2VyQ2FudmFzRWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIGFkZGVkXG4gICAgICovXG4gICAgX29uT2JqZWN0QWRkZWQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdGhpcy5zdGF0ZWZ1bCAmJiBvYmouc2V0dXBTdGF0ZSgpO1xuICAgICAgb2JqLl9zZXQoJ2NhbnZhcycsIHRoaXMpO1xuICAgICAgb2JqLnNldENvb3JkcygpO1xuICAgICAgdGhpcy5maXJlKCdvYmplY3Q6YWRkZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgb2JqLmZpcmUoJ2FkZGVkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIHJlbW92ZWRcbiAgICAgKi9cbiAgICBfb25PYmplY3RSZW1vdmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHRoaXMuZmlyZSgnb2JqZWN0OnJlbW92ZWQnLCB7IHRhcmdldDogb2JqIH0pO1xuICAgICAgb2JqLmZpcmUoJ3JlbW92ZWQnKTtcbiAgICAgIGRlbGV0ZSBvYmouY2FudmFzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgc3BlY2lmaWVkIGNvbnRleHQgb2YgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gY2xlYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyQ29udGV4dDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRleHQgb2YgY2FudmFzIHdoZXJlIG9iamVjdHMgYXJlIGRyYXduXG4gICAgICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHRDb250YWluZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY29udGV4dHMgKGJhY2tncm91bmQsIG1haW4sIHRvcCkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnJlbW92ZS5hcHBseSh0aGlzLCB0aGlzLmdldE9iamVjdHMoKSk7XG4gICAgICB0aGlzLmJhY2tncm91bmRJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLm92ZXJsYXlJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9ICcnO1xuICAgICAgdGhpcy5vdmVybGF5Q29sb3IgPSAnJztcbiAgICAgIGlmICh0aGlzLl9oYXNJVGV4dEhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMub2ZmKCdtb3VzZTp1cCcsIHRoaXMuX21vdXNlVXBJVGV4dEhhbmRsZXIpO1xuICAgICAgICB0aGlzLl9pVGV4dEluc3RhbmNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hhc0lUZXh0SGFuZGxlcnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KHRoaXMuY29udGV4dENvbnRhaW5lcik7XG4gICAgICB0aGlzLmZpcmUoJ2NhbnZhczpjbGVhcmVkJyk7XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbnZhc1RvRHJhd09uID0gdGhpcy5jb250ZXh0Q29udGFpbmVyO1xuICAgICAgdGhpcy5yZW5kZXJDYW52YXMoY2FudmFzVG9EcmF3T24sIHRoaXMuX29iamVjdHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGNyZWF0ZWQgdG8gYmUgaW5zdGFuY2UgYm91bmQgYXQgaW5pdGlhbGl6YXRpb25cbiAgICAgKiB1c2VkIGluIHJlcXVlc3RBbmltYXRpb25GcmFtZSByZW5kZXJpbmdcbiAgICAgKiBMZXQgdGhlIGZhYnJpY0pTIGNhbGwgaXQuIElmIHlvdSBjYWxsIGl0IG1hbnVhbGx5IHlvdSBjb3VsZCBoYXZlIG1vcmVcbiAgICAgKiBhbmltYXRpb25GcmFtZSBzdGFja2luZyBvbiB0byBvZiBlYWNoIG90aGVyXG4gICAgICogZm9yIGFuIGltcGVyYXRpdmUgcmVuZGVyaW5nLCB1c2UgY2FudmFzLnJlbmRlckFsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVuZGVyQW5kUmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IDA7XG4gICAgICB0aGlzLnJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYSByZW5kZXJBbGwgcmVxdWVzdCB0byBuZXh0IGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgKiB1bmxlc3Mgb25lIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIGluIHRoYXQgY2FzZSBub3RoaW5nIGlzIGRvbmVcbiAgICAgKiBhIGJvb2xlYW4gZmxhZyB3aWxsIGF2b2lkIGFwcGVuZGluZyBtb3JlLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlcXVlc3RSZW5kZXJBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gZmFicmljLnV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLnJlbmRlckFuZFJlc2V0Qm91bmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIDQgY29ybmVyIG9mIGNhbnZhcyB3aXRoIGN1cnJlbnQgdmlld3BvcnRUcmFuc2Zvcm0uXG4gICAgICogaGVscHMgdG8gZGV0ZXJtaW5hdGUgd2hlbiBhbiBvYmplY3QgaXMgaW4gdGhlIGN1cnJlbnQgcmVuZGVyaW5nIHZpZXdwb3J0IHVzaW5nXG4gICAgICogb2JqZWN0IGFic29sdXRlIGNvb3JkaW5hdGVzICggYUNvb3JkcyApXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwb2ludHMudGxcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2FsY1ZpZXdwb3J0Qm91bmRhcmllczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9pbnRzID0geyB9LCB3aWR0aCA9IHRoaXMud2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIGlWcHQgPSBpbnZlcnRUcmFuc2Zvcm0odGhpcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICBwb2ludHMudGwgPSB0cmFuc2Zvcm1Qb2ludCh7IHg6IDAsIHk6IDAgfSwgaVZwdCk7XG4gICAgICBwb2ludHMuYnIgPSB0cmFuc2Zvcm1Qb2ludCh7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSwgaVZwdCk7XG4gICAgICBwb2ludHMudHIgPSBuZXcgZmFicmljLlBvaW50KHBvaW50cy5ici54LCBwb2ludHMudGwueSk7XG4gICAgICBwb2ludHMuYmwgPSBuZXcgZmFicmljLlBvaW50KHBvaW50cy50bC54LCBwb2ludHMuYnIueSk7XG4gICAgICB0aGlzLnZwdENvb3JkcyA9IHBvaW50cztcbiAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfSxcblxuICAgIGNhbmNlbFJlcXVlc3RlZFJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICBmYWJyaWMudXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5pc1JlbmRlcmluZyk7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGJhY2tncm91bmQsIG9iamVjdHMsIG92ZXJsYXkgYW5kIGNvbnRyb2xzLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzIHRvIHJlbmRlclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlckNhbnZhczogZnVuY3Rpb24oY3R4LCBvYmplY3RzKSB7XG4gICAgICB2YXIgdiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sIHBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgdGhpcy5jYW5jZWxSZXF1ZXN0ZWRSZW5kZXIoKTtcbiAgICAgIHRoaXMuY2FsY1ZpZXdwb3J0Qm91bmRhcmllcygpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgIGZhYnJpYy51dGlsLnNldEltYWdlU21vb3RoaW5nKGN0eCwgdGhpcy5pbWFnZVNtb290aGluZ0VuYWJsZWQpO1xuICAgICAgdGhpcy5maXJlKCdiZWZvcmU6cmVuZGVyJywgeyBjdHg6IGN0eCwgfSk7XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kKGN0eCk7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAvL2FwcGx5IHZpZXdwb3J0IHRyYW5zZm9ybSBvbmNlIGZvciBhbGwgcmVuZGVyaW5nIHByb2Nlc3NcbiAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICB0aGlzLl9yZW5kZXJPYmplY3RzKGN0eCwgb2JqZWN0cyk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgaWYgKCF0aGlzLmNvbnRyb2xzQWJvdmVPdmVybGF5ICYmIHRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5kcmF3Q29udHJvbHMoY3R4KTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHBhdGguY2FudmFzID0gdGhpcztcbiAgICAgICAgLy8gbmVlZGVkIHRvIHNldHVwIGEgY291cGxlIG9mIHZhcmlhYmxlc1xuICAgICAgICBwYXRoLnNob3VsZENhY2hlKCk7XG4gICAgICAgIHBhdGguX3RyYW5zZm9ybURvbmUgPSB0cnVlO1xuICAgICAgICBwYXRoLnJlbmRlckNhY2hlKHsgZm9yQ2xpcHBpbmc6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZHJhd0NsaXBQYXRoT25DYW52YXMoY3R4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbmRlck92ZXJsYXkoY3R4KTtcbiAgICAgIGlmICh0aGlzLmNvbnRyb2xzQWJvdmVPdmVybGF5ICYmIHRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5kcmF3Q29udHJvbHMoY3R4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlyZSgnYWZ0ZXI6cmVuZGVyJywgeyBjdHg6IGN0eCwgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhaW50IHRoZSBjYWNoZWQgY2xpcFBhdGggb24gdGhlIGxvd2VyQ2FudmFzRWxcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd0NsaXBQYXRoT25DYW52YXM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHYgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLCBwYXRoID0gdGhpcy5jbGlwUGF0aDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgLy8gREVCVUc6IHVuY29tbWVudCB0aGlzIGxpbmUsIGNvbW1lbnQgdGhlIGZvbGxvd2luZ1xuICAgICAgLy8gY3R4Lmdsb2JhbEFscGhhID0gMC40O1xuICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XG4gICAgICBwYXRoLnRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnNjYWxlKDEgLyBwYXRoLnpvb21YLCAxIC8gcGF0aC56b29tWSk7XG4gICAgICBjdHguZHJhd0ltYWdlKHBhdGguX2NhY2hlQ2FudmFzLCAtcGF0aC5jYWNoZVRyYW5zbGF0aW9uWCwgLXBhdGguY2FjaGVUcmFuc2xhdGlvblkpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKi9cbiAgICBfcmVuZGVyT2JqZWN0czogZnVuY3Rpb24oY3R4LCBvYmplY3RzKSB7XG4gICAgICB2YXIgaSwgbGVuO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBvYmplY3RzW2ldICYmIG9iamVjdHNbaV0ucmVuZGVyKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAnYmFja2dyb3VuZCcgb3IgJ292ZXJsYXknXG4gICAgICovXG4gICAgX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXk6IGZ1bmN0aW9uKGN0eCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBmaWxsID0gdGhpc1twcm9wZXJ0eSArICdDb2xvciddLCBvYmplY3QgPSB0aGlzW3Byb3BlcnR5ICsgJ0ltYWdlJ10sXG4gICAgICAgICAgdiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sIG5lZWRzVnB0ID0gdGhpc1twcm9wZXJ0eSArICdWcHQnXTtcbiAgICAgIGlmICghZmlsbCAmJiAhb2JqZWN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbyh0aGlzLndpZHRoLCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbyh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIGN0eC5saW5lVG8oMCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLnRvTGl2ZVxuICAgICAgICAgID8gZmlsbC50b0xpdmUoY3R4LCB0aGlzKVxuICAgICAgICAgIDogZmlsbDtcbiAgICAgICAgaWYgKG5lZWRzVnB0KSB7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgudHJhbnNmb3JtKDEsIDAsIDAsIDEsIGZpbGwub2Zmc2V0WCB8fCAwLCBmaWxsLm9mZnNldFkgfHwgMCk7XG4gICAgICAgIHZhciBtID0gZmlsbC5ncmFkaWVudFRyYW5zZm9ybSB8fCBmaWxsLnBhdHRlcm5UcmFuc2Zvcm07XG4gICAgICAgIG0gJiYgY3R4LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYgKG5lZWRzVnB0KSB7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QucmVuZGVyKGN0eCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJCYWNrZ3JvdW5kOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXkoY3R4LCAnYmFja2dyb3VuZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyT3ZlcmxheTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kT3JPdmVybGF5KGN0eCwgJ292ZXJsYXknKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBhIGNlbnRlciBvZiBjYW52YXMuXG4gICAgICogUmV0dXJuZWQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggdG9wIGFuZCBsZWZ0IHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB3aXRoIFwidG9wXCIgYW5kIFwibGVmdFwiIG51bWJlciB2YWx1ZXNcbiAgICAgKiBAZGVwcmVjYXRlZCBtaWdyYXRlIHRvIGBnZXRDZW50ZXJQb2ludGBcbiAgICAgKi9cbiAgICBnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICBsZWZ0OiB0aGlzLndpZHRoIC8gMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBhIGNlbnRlciBvZiBjYW52YXMuXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBcbiAgICAgKi9cbiAgICBnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQodGhpcy53aWR0aCAvIDIsIHRoaXMuaGVpZ2h0IC8gMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBpbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICovXG4gICAgY2VudGVyT2JqZWN0SDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQodGhpcy5nZXRDZW50ZXJQb2ludCgpLngsIG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBpbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJPYmplY3RWOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgbmV3IGZhYnJpYy5Qb2ludChvYmplY3QuZ2V0Q2VudGVyUG9pbnQoKS54LCB0aGlzLmdldENlbnRlclBvaW50KCkueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBjZW50ZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHkgaW4gdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyT2JqZWN0OiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciB2cENlbnRlciA9IHRoaXMuZ2V0VnBDZW50ZXIoKTtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCB2cENlbnRlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBpbiB0aGUgdmlld3BvcnQsIG9iamVjdC50b3AgaXMgdW5jaGFuZ2VkXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyT2JqZWN0SDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgdnBDZW50ZXIgPSB0aGlzLmdldFZwQ2VudGVyKCk7XG4gICAgICB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KHZwQ2VudGVyLngsIG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLnkpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBWZXJ0aWNhbGx5IGluIHRoZSB2aWV3cG9ydCwgb2JqZWN0LnRvcCBpcyB1bmNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJPYmplY3RWOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciB2cENlbnRlciA9IHRoaXMuZ2V0VnBDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQob2JqZWN0LmdldENlbnRlclBvaW50KCkueCwgdnBDZW50ZXIueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50IGluIGNhbnZhcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIGNlbnRlciBvZiBhY3R1YWwgdmlld3BvcnQuXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB2cENlbnRlciwgdmlld3BvcnQgY2VudGVyXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGdldFZwQ2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCksXG4gICAgICAgICAgaVZwdCA9IGludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKTtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1Qb2ludChjZW50ZXIsIGlWcHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXJcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gY2VudGVyIENlbnRlciBwb2ludFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX2NlbnRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0LCBjZW50ZXIpIHtcbiAgICAgIG9iamVjdC5zZXRQb3NpdGlvbkJ5T3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXRhbGVzcyBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGpzb24gc3RyaW5nXG4gICAgICovXG4gICAgdG9EYXRhbGVzc0pTT046IGZ1bmN0aW9uIChwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0RhdGFsZXNzT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b09iamVjdE1ldGhvZCgndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXRhbGVzcyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b09iamVjdE1ldGhvZCgndG9EYXRhbGVzc09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdE1ldGhvZDogZnVuY3Rpb24gKG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcblxuICAgICAgdmFyIGNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aCwgZGF0YSA9IHtcbiAgICAgICAgdmVyc2lvbjogZmFicmljLnZlcnNpb24sXG4gICAgICAgIG9iamVjdHM6IHRoaXMuX3RvT2JqZWN0cyhtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSxcbiAgICAgIH07XG4gICAgICBpZiAoY2xpcFBhdGggJiYgIWNsaXBQYXRoLmV4Y2x1ZGVGcm9tRXhwb3J0KSB7XG4gICAgICAgIGRhdGEuY2xpcFBhdGggPSB0aGlzLl90b09iamVjdCh0aGlzLmNsaXBQYXRoLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIH1cbiAgICAgIGV4dGVuZChkYXRhLCB0aGlzLl9fc2VyaWFsaXplQmdPdmVybGF5KG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcblxuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBkYXRhLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvT2JqZWN0czogZnVuY3Rpb24obWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gIW9iamVjdC5leGNsdWRlRnJvbUV4cG9ydDtcbiAgICAgIH0pLm1hcChmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9PYmplY3QoaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvT2JqZWN0OiBmdW5jdGlvbihpbnN0YW5jZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9yaWdpbmFsVmFsdWU7XG5cbiAgICAgIGlmICghdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICBvcmlnaW5hbFZhbHVlID0gaW5zdGFuY2UuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgIGluc3RhbmNlLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBvYmplY3QgPSBpbnN0YW5jZVttZXRob2ROYW1lXShwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIGlmICghdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICBpbnN0YW5jZS5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9fc2VyaWFsaXplQmdPdmVybGF5OiBmdW5jdGlvbihtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgZGF0YSA9IHt9LCBiZ0ltYWdlID0gdGhpcy5iYWNrZ3JvdW5kSW1hZ2UsIG92ZXJsYXlJbWFnZSA9IHRoaXMub3ZlcmxheUltYWdlLFxuICAgICAgICAgIGJnQ29sb3IgPSB0aGlzLmJhY2tncm91bmRDb2xvciwgb3ZlcmxheUNvbG9yID0gdGhpcy5vdmVybGF5Q29sb3I7XG5cbiAgICAgIGlmIChiZ0NvbG9yICYmIGJnQ29sb3IudG9PYmplY3QpIHtcbiAgICAgICAgaWYgKCFiZ0NvbG9yLmV4Y2x1ZGVGcm9tRXhwb3J0KSB7XG4gICAgICAgICAgZGF0YS5iYWNrZ3JvdW5kID0gYmdDb2xvci50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYmdDb2xvcikge1xuICAgICAgICBkYXRhLmJhY2tncm91bmQgPSBiZ0NvbG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAob3ZlcmxheUNvbG9yICYmIG92ZXJsYXlDb2xvci50b09iamVjdCkge1xuICAgICAgICBpZiAoIW92ZXJsYXlDb2xvci5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICAgIGRhdGEub3ZlcmxheSA9IG92ZXJsYXlDb2xvci50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3ZlcmxheUNvbG9yKSB7XG4gICAgICAgIGRhdGEub3ZlcmxheSA9IG92ZXJsYXlDb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGJnSW1hZ2UgJiYgIWJnSW1hZ2UuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgZGF0YS5iYWNrZ3JvdW5kSW1hZ2UgPSB0aGlzLl90b09iamVjdChiZ0ltYWdlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVybGF5SW1hZ2UgJiYgIW92ZXJsYXlJbWFnZS5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICBkYXRhLm92ZXJsYXlJbWFnZSA9IHRoaXMuX3RvT2JqZWN0KG92ZXJsYXlJbWFnZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgZ2V0U3ZnVHJhbnNmb3JtKCkgd2lsbCBhcHBseSB0aGUgU3RhdGljQ2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtIHRvIHRoZSBTVkcgdHJhbnNmb3JtYXRpb24uIFdoZW4gdHJ1ZSxcbiAgICAgKiBhIHpvb21lZCBjYW52YXMgd2lsbCB0aGVuIHByb2R1Y2Ugem9vbWVkIFNWRyBvdXRwdXQuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3ZnVmlld3BvcnRUcmFuc2Zvcm1hdGlvbjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3QgZm9yIFNWRyBvdXRwdXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN1cHByZXNzUHJlYW1ibGU9ZmFsc2VdIElmIHRydWUgeG1sIHRhZyBpcyBub3QgaW5jbHVkZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudmlld0JveF0gU1ZHIHZpZXdib3ggb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3gueF0geC1jb29yZGluYXRlIG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC55XSB5LWNvb3JkaW5hdGUgb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LndpZHRoXSBXaWR0aCBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3guaGVpZ2h0XSBIZWlnaHQgb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1VVEYtOF0gRW5jb2Rpbmcgb2YgU1ZHIG91dHB1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy53aWR0aF0gZGVzaXJlZCB3aWR0aCBvZiBzdmcgd2l0aCBvciB3aXRob3V0IHVuaXRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhlaWdodF0gZGVzaXJlZCBoZWlnaHQgb2Ygc3ZnIHdpdGggb3Igd2l0aG91dCB1bml0c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY29udmVydGVkIGludG8gc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHN0cmluZ1xuICAgICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI3NlcmlhbGl6YXRpb259XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9qUTNaWi98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgU1ZHIG91dHB1dDwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKCk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U1ZHIG91dHB1dCB3aXRob3V0IHByZWFtYmxlICh3aXRob3V0ICZsdDs/eG1sIC4uLz4pPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoe3N1cHByZXNzUHJlYW1ibGU6IHRydWV9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TVkcgb3V0cHV0IHdpdGggdmlld0JveCBhdHRyaWJ1dGU8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyh7XG4gICAgICogICB2aWV3Qm94OiB7XG4gICAgICogICAgIHg6IDEwMCxcbiAgICAgKiAgICAgeTogMTAwLFxuICAgICAqICAgICB3aWR0aDogMjAwLFxuICAgICAqICAgICBoZWlnaHQ6IDMwMFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNWRyBvdXRwdXQgd2l0aCBkaWZmZXJlbnQgZW5jb2RpbmcgKGRlZmF1bHQ6IFVURi04KTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKHtlbmNvZGluZzogJ0lTTy04ODU5LTEnfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+TW9kaWZ5IFNWRyBvdXRwdXQgd2l0aCByZXZpdmVyIGZ1bmN0aW9uPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcobnVsbCwgZnVuY3Rpb24oc3ZnKSB7XG4gICAgICogICByZXR1cm4gc3ZnLnJlcGxhY2UoJ3N0cm9rZS1kYXNoYXJyYXk6IDsgc3Ryb2tlLWxpbmVjYXA6IGJ1dHQ7IHN0cm9rZS1saW5lam9pbjogbWl0ZXI7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgJywgJycpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvcHRpb25zLCByZXZpdmVyKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIG9wdGlvbnMucmV2aXZlciA9IHJldml2ZXI7XG4gICAgICB2YXIgbWFya3VwID0gW107XG5cbiAgICAgIHRoaXMuX3NldFNWR1ByZWFtYmxlKG1hcmt1cCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9zZXRTVkdIZWFkZXIobWFya3VwLCBvcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKCc8ZyBjbGlwLXBhdGg9XCJ1cmwoIycgKyB0aGlzLmNsaXBQYXRoLmNsaXBQYXRoSWQgKyAnKVwiID5cXG4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldFNWR0JnT3ZlcmxheUNvbG9yKG1hcmt1cCwgJ2JhY2tncm91bmQnKTtcbiAgICAgIHRoaXMuX3NldFNWR0JnT3ZlcmxheUltYWdlKG1hcmt1cCwgJ2JhY2tncm91bmRJbWFnZScsIHJldml2ZXIpO1xuICAgICAgdGhpcy5fc2V0U1ZHT2JqZWN0cyhtYXJrdXAsIHJldml2ZXIpO1xuICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldFNWR0JnT3ZlcmxheUNvbG9yKG1hcmt1cCwgJ292ZXJsYXknKTtcbiAgICAgIHRoaXMuX3NldFNWR0JnT3ZlcmxheUltYWdlKG1hcmt1cCwgJ292ZXJsYXlJbWFnZScsIHJldml2ZXIpO1xuXG4gICAgICBtYXJrdXAucHVzaCgnPC9zdmc+Jyk7XG5cbiAgICAgIHJldHVybiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR1ByZWFtYmxlOiBmdW5jdGlvbihtYXJrdXAsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLnN1cHByZXNzUHJlYW1ibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCInLCAob3B0aW9ucy5lbmNvZGluZyB8fCAnVVRGLTgnKSwgJ1wiIHN0YW5kYWxvbmU9XCJub1wiID8+XFxuJyxcbiAgICAgICAgJzwhRE9DVFlQRSBzdmcgUFVCTElDIFwiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU5cIiAnLFxuICAgICAgICAnXCJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGRcIj5cXG4nXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdIZWFkZXI6IGZ1bmN0aW9uKG1hcmt1cCwgb3B0aW9ucykge1xuICAgICAgdmFyIHdpZHRoID0gb3B0aW9ucy53aWR0aCB8fCB0aGlzLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIHZwdCwgdmlld0JveCA9ICd2aWV3Qm94PVwiMCAwICcgKyB0aGlzLndpZHRoICsgJyAnICsgdGhpcy5oZWlnaHQgKyAnXCIgJyxcbiAgICAgICAgICBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuXG4gICAgICBpZiAob3B0aW9ucy52aWV3Qm94KSB7XG4gICAgICAgIHZpZXdCb3ggPSAndmlld0JveD1cIicgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlld0JveC54ICsgJyAnICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3gueSArICcgJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LndpZHRoICsgJyAnICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3guaGVpZ2h0ICsgJ1wiICc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuc3ZnVmlld3BvcnRUcmFuc2Zvcm1hdGlvbikge1xuICAgICAgICAgIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICAgICAgdmlld0JveCA9ICd2aWV3Qm94PVwiJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKC12cHRbNF0gLyB2cHRbMF0sIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIHRvRml4ZWQoLXZwdFs1XSAvIHZwdFszXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoIC8gdnB0WzBdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcgJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuaGVpZ2h0IC8gdnB0WzNdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICdcIiAnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPHN2ZyAnLFxuICAgICAgICAneG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiICcsXG4gICAgICAgICd4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiAnLFxuICAgICAgICAndmVyc2lvbj1cIjEuMVwiICcsXG4gICAgICAgICd3aWR0aD1cIicsIHdpZHRoLCAnXCIgJyxcbiAgICAgICAgJ2hlaWdodD1cIicsIGhlaWdodCwgJ1wiICcsXG4gICAgICAgIHZpZXdCb3gsXG4gICAgICAgICd4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlxcbicsXG4gICAgICAgICc8ZGVzYz5DcmVhdGVkIHdpdGggRmFicmljLmpzICcsIGZhYnJpYy52ZXJzaW9uLCAnPC9kZXNjPlxcbicsXG4gICAgICAgICc8ZGVmcz5cXG4nLFxuICAgICAgICB0aGlzLmNyZWF0ZVNWR0ZvbnRGYWNlc01hcmt1cCgpLFxuICAgICAgICB0aGlzLmNyZWF0ZVNWR1JlZkVsZW1lbnRzTWFya3VwKCksXG4gICAgICAgIHRoaXMuY3JlYXRlU1ZHQ2xpcFBhdGhNYXJrdXAob3B0aW9ucyksXG4gICAgICAgICc8L2RlZnM+XFxuJ1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlU1ZHQ2xpcFBhdGhNYXJrdXA6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGg7XG4gICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgY2xpcFBhdGguY2xpcFBhdGhJZCA9ICdDTElQUEFUSF8nICsgZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgICByZXR1cm4gICc8Y2xpcFBhdGggaWQ9XCInICsgY2xpcFBhdGguY2xpcFBhdGhJZCArICdcIiA+XFxuJyArXG4gICAgICAgICAgdGhpcy5jbGlwUGF0aC50b0NsaXBQYXRoU1ZHKG9wdGlvbnMucmV2aXZlcikgK1xuICAgICAgICAgICc8L2NsaXBQYXRoPlxcbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbWFya3VwIGNvbnRhaW5pbmcgU1ZHIHJlZmVyZW5jZWQgZWxlbWVudHMgbGlrZSBwYXR0ZXJucywgZ3JhZGllbnRzIGV0Yy5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgY3JlYXRlU1ZHUmVmRWxlbWVudHNNYXJrdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBtYXJrdXAgPSBbJ2JhY2tncm91bmQnLCAnb3ZlcmxheSddLm1hcChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICB2YXIgZmlsbCA9IF90aGlzW3Byb3AgKyAnQ29sb3InXTtcbiAgICAgICAgICAgIGlmIChmaWxsICYmIGZpbGwudG9MaXZlKSB7XG4gICAgICAgICAgICAgIHZhciBzaG91bGRUcmFuc2Zvcm0gPSBfdGhpc1twcm9wICsgJ1ZwdCddLCB2cHQgPSBfdGhpcy52aWV3cG9ydFRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICAgIG9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IF90aGlzLndpZHRoIC8gKHNob3VsZFRyYW5zZm9ybSA/IHZwdFswXSA6IDEpLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IF90aGlzLmhlaWdodCAvIChzaG91bGRUcmFuc2Zvcm0gPyB2cHRbM10gOiAxKVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbGwudG9TVkcoXG4gICAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICAgIHsgYWRkaXRpb25hbFRyYW5zZm9ybTogc2hvdWxkVHJhbnNmb3JtID8gZmFicmljLnV0aWwubWF0cml4VG9TVkcodnB0KSA6ICcnIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIHJldHVybiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbWFya3VwIGNvbnRhaW5pbmcgU1ZHIGZvbnQgZmFjZXMsXG4gICAgICogZm9udCBVUkxzIGZvciBmb250IGZhY2VzIG11c3QgYmUgY29sbGVjdGVkIGJ5IGRldmVsb3BlcnNcbiAgICAgKiBhbmQgYXJlIG5vdCBleHRyYWN0ZWQgZnJvbSB0aGUgRE9NIGJ5IGZhYnJpY2pzXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyBBcnJheSBvZiBmYWJyaWMgb2JqZWN0c1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjcmVhdGVTVkdGb250RmFjZXNNYXJrdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcmt1cCA9ICcnLCBmb250TGlzdCA9IHsgfSwgb2JqLCBmb250RmFtaWx5LFxuICAgICAgICAgIHN0eWxlLCByb3csIHJvd0luZGV4LCBfY2hhciwgY2hhckluZGV4LCBpLCBsZW4sXG4gICAgICAgICAgZm9udFBhdGhzID0gZmFicmljLmZvbnRQYXRocywgb2JqZWN0cyA9IFtdO1xuXG4gICAgICB0aGlzLl9vYmplY3RzLmZvckVhY2goZnVuY3Rpb24gYWRkKG9iamVjdCkge1xuICAgICAgICBvYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5fb2JqZWN0cykge1xuICAgICAgICAgIG9iamVjdC5fb2JqZWN0cy5mb3JFYWNoKGFkZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9iaiA9IG9iamVjdHNbaV07XG4gICAgICAgIGZvbnRGYW1pbHkgPSBvYmouZm9udEZhbWlseTtcbiAgICAgICAgaWYgKG9iai50eXBlLmluZGV4T2YoJ3RleHQnKSA9PT0gLTEgfHwgZm9udExpc3RbZm9udEZhbWlseV0gfHwgIWZvbnRQYXRoc1tmb250RmFtaWx5XSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvbnRMaXN0W2ZvbnRGYW1pbHldID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFvYmouc3R5bGVzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUgPSBvYmouc3R5bGVzO1xuICAgICAgICBmb3IgKHJvd0luZGV4IGluIHN0eWxlKSB7XG4gICAgICAgICAgcm93ID0gc3R5bGVbcm93SW5kZXhdO1xuICAgICAgICAgIGZvciAoY2hhckluZGV4IGluIHJvdykge1xuICAgICAgICAgICAgX2NoYXIgPSByb3dbY2hhckluZGV4XTtcbiAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBfY2hhci5mb250RmFtaWx5O1xuICAgICAgICAgICAgaWYgKCFmb250TGlzdFtmb250RmFtaWx5XSAmJiBmb250UGF0aHNbZm9udEZhbWlseV0pIHtcbiAgICAgICAgICAgICAgZm9udExpc3RbZm9udEZhbWlseV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqIGluIGZvbnRMaXN0KSB7XG4gICAgICAgIG1hcmt1cCArPSBbXG4gICAgICAgICAgJ1xcdFxcdEBmb250LWZhY2Uge1xcbicsXG4gICAgICAgICAgJ1xcdFxcdFxcdGZvbnQtZmFtaWx5OiBcXCcnLCBqLCAnXFwnO1xcbicsXG4gICAgICAgICAgJ1xcdFxcdFxcdHNyYzogdXJsKFxcJycsIGZvbnRQYXRoc1tqXSwgJ1xcJyk7XFxuJyxcbiAgICAgICAgICAnXFx0XFx0fVxcbidcbiAgICAgICAgXS5qb2luKCcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICBtYXJrdXAgPSBbXG4gICAgICAgICAgJ1xcdDxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj4nLFxuICAgICAgICAgICc8IVtDREFUQVtcXG4nLFxuICAgICAgICAgIG1hcmt1cCxcbiAgICAgICAgICAnXV0+JyxcbiAgICAgICAgICAnPC9zdHlsZT5cXG4nXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdHM6IGZ1bmN0aW9uKG1hcmt1cCwgcmV2aXZlcikge1xuICAgICAgdmFyIGluc3RhbmNlLCBpLCBsZW4sIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpbnN0YW5jZSA9IG9iamVjdHNbaV07XG4gICAgICAgIGlmIChpbnN0YW5jZS5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFNWR09iamVjdChtYXJrdXAsIGluc3RhbmNlLCByZXZpdmVyKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHT2JqZWN0OiBmdW5jdGlvbihtYXJrdXAsIGluc3RhbmNlLCByZXZpdmVyKSB7XG4gICAgICBtYXJrdXAucHVzaChpbnN0YW5jZS50b1NWRyhyZXZpdmVyKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR0JnT3ZlcmxheUltYWdlOiBmdW5jdGlvbihtYXJrdXAsIHByb3BlcnR5LCByZXZpdmVyKSB7XG4gICAgICBpZiAodGhpc1twcm9wZXJ0eV0gJiYgIXRoaXNbcHJvcGVydHldLmV4Y2x1ZGVGcm9tRXhwb3J0ICYmIHRoaXNbcHJvcGVydHldLnRvU1ZHKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKHRoaXNbcHJvcGVydHldLnRvU1ZHKHJldml2ZXIpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHQmdPdmVybGF5Q29sb3I6IGZ1bmN0aW9uKG1hcmt1cCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBmaWxsZXIgPSB0aGlzW3Byb3BlcnR5ICsgJ0NvbG9yJ10sIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sIGZpbmFsV2lkdGggPSB0aGlzLndpZHRoLFxuICAgICAgICAgIGZpbmFsSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICBpZiAoIWZpbGxlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZmlsbGVyLnRvTGl2ZSkge1xuICAgICAgICB2YXIgcmVwZWF0ID0gZmlsbGVyLnJlcGVhdCwgaVZwdCA9IGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybSh2cHQpLCBzaG91bGRJbnZlcnQgPSB0aGlzW3Byb3BlcnR5ICsgJ1ZwdCddLFxuICAgICAgICAgICAgYWRkaXRpb25hbFRyYW5zZm9ybSA9IHNob3VsZEludmVydCA/IGZhYnJpYy51dGlsLm1hdHJpeFRvU1ZHKGlWcHQpIDogJyc7XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8cmVjdCB0cmFuc2Zvcm09XCInICsgYWRkaXRpb25hbFRyYW5zZm9ybSArICcgdHJhbnNsYXRlKCcsIGZpbmFsV2lkdGggLyAyLCAnLCcsIGZpbmFsSGVpZ2h0IC8gMiwgJylcIicsXG4gICAgICAgICAgJyB4PVwiJywgZmlsbGVyLm9mZnNldFggLSBmaW5hbFdpZHRoIC8gMixcbiAgICAgICAgICAnXCIgeT1cIicsIGZpbGxlci5vZmZzZXRZIC0gZmluYWxIZWlnaHQgLyAyLCAnXCIgJyxcbiAgICAgICAgICAnd2lkdGg9XCInLFxuICAgICAgICAgIChyZXBlYXQgPT09ICdyZXBlYXQteScgfHwgcmVwZWF0ID09PSAnbm8tcmVwZWF0J1xuICAgICAgICAgICAgPyBmaWxsZXIuc291cmNlLndpZHRoXG4gICAgICAgICAgICA6IGZpbmFsV2lkdGggKSxcbiAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyxcbiAgICAgICAgICAocmVwZWF0ID09PSAncmVwZWF0LXgnIHx8IHJlcGVhdCA9PT0gJ25vLXJlcGVhdCdcbiAgICAgICAgICAgID8gZmlsbGVyLnNvdXJjZS5oZWlnaHRcbiAgICAgICAgICAgIDogZmluYWxIZWlnaHQpLFxuICAgICAgICAgICdcIiBmaWxsPVwidXJsKCNTVkdJRF8nICsgZmlsbGVyLmlkICsgJylcIicsXG4gICAgICAgICAgJz48L3JlY3Q+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8cmVjdCB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiICcsXG4gICAgICAgICAgJ2ZpbGw9XCInLCBmaWxsZXIsICdcIicsXG4gICAgICAgICAgJz48L3JlY3Q+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgdGhlIG9iamVjdHMgb2YgYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgKiB0byB0aGUgYm90dG9tIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmQgdG8gYmFja1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VuZFRvQmFjazogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGksIG9iaiwgb2JqcztcbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZVNlbGVjdGlvbiAmJiBvYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgb2JqcyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gb2Jqcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmopO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMudW5zaGlmdChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICAgIHRoaXMuX29iamVjdHMudW5zaGlmdChvYmplY3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgdGhlIG9iamVjdHMgb2YgYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgKiB0byB0aGUgdG9wIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGksIG9iaiwgb2JqcztcbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZVNlbGVjdGlvbiAmJiBvYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgb2JqcyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmopO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICAgIHRoaXMuX29iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgYSBzZWxlY3Rpb24gZG93biBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQW4gb3B0aW9uYWwgcGFyYW1ldGVyLCBpbnRlcnNlY3RpbmcgYWxsb3dzIHRvIG1vdmUgdGhlIG9iamVjdCBpbiBiZWhpbmRcbiAgICAgKiB0aGUgZmlyc3QgaW50ZXJzZWN0aW5nIG9iamVjdC4gV2hlcmUgaW50ZXJzZWN0aW9uIGlzIGNhbGN1bGF0ZWQgd2l0aFxuICAgICAqIGJvdW5kaW5nIGJveC4gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIGZvdW5kLCB0aGVyZSB3aWxsIG5vdCBiZSBjaGFuZ2UgaW4gdGhlXG4gICAgICogc3RhY2suXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgYmVoaW5kIG5leHQgbG93ZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VuZEJhY2t3YXJkczogZnVuY3Rpb24gKG9iamVjdCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgaSwgb2JqLCBpZHgsIG5ld0lkeCwgb2Jqcywgb2Jqc01vdmVkID0gMDtcblxuICAgICAgaWYgKG9iamVjdCA9PT0gYWN0aXZlU2VsZWN0aW9uICYmIG9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICBvYmpzID0gYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2Jqcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9iaiA9IG9ianNbaV07XG4gICAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iaik7XG4gICAgICAgICAgaWYgKGlkeCA+IDAgKyBvYmpzTW92ZWQpIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGlkeCAtIDE7XG4gICAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Jqc01vdmVkKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKGlkeCAhPT0gMCkge1xuICAgICAgICAgIC8vIGlmIG9iamVjdCBpcyBub3Qgb24gdGhlIGJvdHRvbSBvZiBzdGFja1xuICAgICAgICAgIG5ld0lkeCA9IHRoaXMuX2ZpbmROZXdMb3dlckluZGV4KG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kTmV3TG93ZXJJbmRleDogZnVuY3Rpb24ob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZykge1xuICAgICAgdmFyIG5ld0lkeCwgaTtcblxuICAgICAgaWYgKGludGVyc2VjdGluZykge1xuICAgICAgICBuZXdJZHggPSBpZHg7XG5cbiAgICAgICAgLy8gdHJhdmVyc2UgZG93biB0aGUgc3RhY2sgbG9va2luZyBmb3IgdGhlIG5lYXJlc3QgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAgICBmb3IgKGkgPSBpZHggLSAxOyBpID49IDA7IC0taSkge1xuXG4gICAgICAgICAgdmFyIGlzSW50ZXJzZWN0aW5nID0gb2JqZWN0LmludGVyc2VjdHNXaXRoT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdChvYmplY3QpO1xuXG4gICAgICAgICAgaWYgKGlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4IC0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0lkeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIGEgc2VsZWN0aW9uIHVwIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICAgKiBBbiBvcHRpb25hbCBwYXJhbWV0ZXIsIGludGVyc2VjdGluZyBhbGxvd3MgdG8gbW92ZSB0aGUgb2JqZWN0IGluIGZyb250XG4gICAgICogb2YgdGhlIGZpcnN0IGludGVyc2VjdGluZyBvYmplY3QuIFdoZXJlIGludGVyc2VjdGlvbiBpcyBjYWxjdWxhdGVkIHdpdGhcbiAgICAgKiBib3VuZGluZyBib3guIElmIG5vIGludGVyc2VjdGlvbiBpcyBmb3VuZCwgdGhlcmUgd2lsbCBub3QgYmUgY2hhbmdlIGluIHRoZVxuICAgICAqIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW50ZXJzZWN0aW5nXSBJZiBgdHJ1ZWAsIHNlbmQgb2JqZWN0IGluIGZyb250IG9mIG5leHQgdXBwZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYnJpbmdGb3J3YXJkOiBmdW5jdGlvbiAob2JqZWN0LCBpbnRlcnNlY3RpbmcpIHtcbiAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBpLCBvYmosIGlkeCwgbmV3SWR4LCBvYmpzLCBvYmpzTW92ZWQgPSAwO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVTZWxlY3Rpb24gJiYgb2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IG9ianMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqKTtcbiAgICAgICAgICBpZiAoaWR4IDwgdGhpcy5fb2JqZWN0cy5sZW5ndGggLSAxIC0gb2Jqc01vdmVkKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpZHggKyAxO1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iaik7XG4gICAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9ianNNb3ZlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XG4gICAgICAgIGlmIChpZHggIT09IHRoaXMuX29iamVjdHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIC8vIGlmIG9iamVjdCBpcyBub3Qgb24gdG9wIG9mIHN0YWNrIChsYXN0IGl0ZW0gaW4gYW4gYXJyYXkpXG4gICAgICAgICAgbmV3SWR4ID0gdGhpcy5fZmluZE5ld1VwcGVySW5kZXgob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZyk7XG4gICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UobmV3SWR4LCAwLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmROZXdVcHBlckluZGV4OiBmdW5jdGlvbihvYmplY3QsIGlkeCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICB2YXIgbmV3SWR4LCBpLCBsZW47XG5cbiAgICAgIGlmIChpbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4O1xuXG4gICAgICAgIC8vIHRyYXZlcnNlIHVwIHRoZSBzdGFjayBsb29raW5nIGZvciB0aGUgbmVhcmVzdCBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAgICAgIGZvciAoaSA9IGlkeCArIDEsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblxuICAgICAgICAgIHZhciBpc0ludGVyc2VjdGluZyA9IG9iamVjdC5pbnRlcnNlY3RzV2l0aE9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uaXNDb250YWluZWRXaXRoaW5PYmplY3Qob2JqZWN0KTtcblxuICAgICAgICAgIGlmIChpc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgbmV3SWR4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeCArIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdJZHg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCB0byBzcGVjaWZpZWQgbGV2ZWwgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFBvc2l0aW9uIHRvIG1vdmUgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIG1vdmVUbzogZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgpIHtcbiAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UoaW5kZXgsIDAsIG9iamVjdCk7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGEgY2FudmFzIGVsZW1lbnQgYW5kIGRpc3Bvc2Ugb2JqZWN0c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY2FuY2VsIGV2ZW50dWFsbHkgb25nb2luZyByZW5kZXJzXG4gICAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICBmYWJyaWMudXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5pc1JlbmRlcmluZyk7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3JFYWNoT2JqZWN0KGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3QuZGlzcG9zZSAmJiBvYmplY3QuZGlzcG9zZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kSW1hZ2UgJiYgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UuZGlzcG9zZSkge1xuICAgICAgICB0aGlzLmJhY2tncm91bmRJbWFnZS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmJhY2tncm91bmRJbWFnZSA9IG51bGw7XG4gICAgICBpZiAodGhpcy5vdmVybGF5SW1hZ2UgJiYgdGhpcy5vdmVybGF5SW1hZ2UuZGlzcG9zZSkge1xuICAgICAgICB0aGlzLm92ZXJsYXlJbWFnZS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm92ZXJsYXlJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLl9pVGV4dEluc3RhbmNlcyA9IG51bGw7XG4gICAgICB0aGlzLmNvbnRleHRDb250YWluZXIgPSBudWxsO1xuICAgICAgLy8gcmVzdG9yZSBjYW52YXMgc3R5bGVcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbC5jbGFzc0xpc3QucmVtb3ZlKCdsb3dlci1jYW52YXMnKTtcbiAgICAgIGZhYnJpYy51dGlsLnNldFN0eWxlKHRoaXMubG93ZXJDYW52YXNFbCwgdGhpcy5fb3JpZ2luYWxDYW52YXNTdHlsZSk7XG4gICAgICBkZWxldGUgdGhpcy5fb3JpZ2luYWxDYW52YXNTdHlsZTtcbiAgICAgIC8vIHJlc3RvcmUgY2FudmFzIHNpemUgdG8gb3JpZ2luYWwgc2l6ZSBpbiBjYXNlIHJldGluYSBzY2FsaW5nIHdhcyBhcHBsaWVkXG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMud2lkdGgpO1xuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xuICAgICAgZmFicmljLnV0aWwuY2xlYW5VcEpzZG9tTm9kZSh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLkNhbnZhcyAoJyArIHRoaXMuY29tcGxleGl0eSgpICsgJyk6ICcgK1xuICAgICAgICAgICAgICAgJ3sgb2JqZWN0czogJyArIHRoaXMuX29iamVjdHMubGVuZ3RoICsgJyB9Pic7XG4gICAgfVxuICB9KTtcblxuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIGZhYnJpYy5PYnNlcnZhYmxlKTtcbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCBmYWJyaWMuQ29sbGVjdGlvbik7XG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgZmFicmljLkRhdGFVUkxFeHBvcnRlcik7XG5cbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcyAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBFTVBUWV9KU09OOiAne1wib2JqZWN0c1wiOiBbXSwgXCJiYWNrZ3JvdW5kXCI6IFwid2hpdGVcIn0nLFxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSB3YXkgdG8gY2hlY2sgc3VwcG9ydCBvZiBzb21lIG9mIHRoZSBjYW52YXMgbWV0aG9kc1xuICAgICAqIChlaXRoZXIgdGhvc2Ugb2YgSFRNTENhbnZhc0VsZW1lbnQgaXRzZWxmLCBvciByZW5kZXJpbmcgY29udGV4dClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lIE1ldGhvZCB0byBjaGVjayBzdXBwb3J0IGZvcjtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb3VsZCBiZSBvbmUgb2YgXCJzZXRMaW5lRGFzaFwiXG4gICAgICogQHJldHVybiB7Qm9vbGVhbiB8IG51bGx9IGB0cnVlYCBpZiBtZXRob2QgaXMgc3VwcG9ydGVkIChvciBhdCBsZWFzdCBleGlzdHMpLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBgbnVsbGAgaWYgY2FudmFzIGVsZW1lbnQgb3IgY29udGV4dCBjYW4gbm90IGJlIGluaXRpYWxpemVkXG4gICAgICovXG4gICAgc3VwcG9ydHM6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZWwgPSBjcmVhdGVDYW52YXNFbGVtZW50KCk7XG5cbiAgICAgIGlmICghZWwgfHwgIWVsLmdldENvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSBlbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAobWV0aG9kTmFtZSkge1xuXG4gICAgICAgIGNhc2UgJ3NldExpbmVEYXNoJzpcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIGN0eC5zZXRMaW5lRGFzaCAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICogdGhpcyBhbGlhcyBpcyBwcm92aWRlZCBiZWNhdXNlIGlmIHlvdSBjYWxsIEpTT04uc3RyaW5naWZ5IG9uIGFuIGluc3RhbmNlLFxuICAgKiB0aGUgdG9KU09OIG9iamVjdCB3aWxsIGJlIGludm9rZWQgaWYgaXQgZXhpc3RzLlxuICAgKiBIYXZpbmcgYSB0b0pTT04gbWV0aG9kIG1lYW5zIHlvdSBjYW4gZG8gSlNPTi5zdHJpbmdpZnkobXlDYW52YXMpXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAqIEByZXR1cm4ge09iamVjdH0gSlNPTiBjb21wYXRpYmxlIG9iamVjdFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNzZXJpYWxpemF0aW9ufVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL3BlYzg2L3xqc0ZpZGRsZSBkZW1vfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5KU09OIHdpdGhvdXQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzPC9jYXB0aW9uPlxuICAgKiB2YXIganNvbiA9IGNhbnZhcy50b0pTT04oKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+SlNPTiB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbmNsdWRlZDwvY2FwdGlvbj5cbiAgICogdmFyIGpzb24gPSBjYW52YXMudG9KU09OKFsnbG9ja01vdmVtZW50WCcsICdsb2NrTW92ZW1lbnRZJywgJ2xvY2tSb3RhdGlvbicsICdsb2NrU2NhbGluZ1gnLCAnbG9ja1NjYWxpbmdZJ10pO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5KU09OIHdpdGhvdXQgZGVmYXVsdCB2YWx1ZXM8L2NhcHRpb24+XG4gICAqIGNhbnZhcy5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IGZhbHNlO1xuICAgKiB2YXIganNvbiA9IGNhbnZhcy50b0pTT04oKTtcbiAgICovXG4gIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnRvSlNPTiA9IGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnRvT2JqZWN0O1xuXG4gIGlmIChmYWJyaWMuaXNMaWtlbHlOb2RlKSB7XG4gICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuY3JlYXRlUE5HU3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW1wbCA9IGdldE5vZGVDYW52YXModGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHJldHVybiBpbXBsICYmIGltcGwuY3JlYXRlUE5HU3RyZWFtKCk7XG4gICAgfTtcbiAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5jcmVhdGVKUEVHU3RyZWFtID0gZnVuY3Rpb24ob3B0cykge1xuICAgICAgdmFyIGltcGwgPSBnZXROb2RlQ2FudmFzKHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICByZXR1cm4gaW1wbCAmJiBpbXBsLmNyZWF0ZUpQRUdTdHJlYW0ob3B0cyk7XG4gICAgfTtcbiAgfVxufSkoKTtcblxuXG4vKipcbiAqIEJhc2VCcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5CYXNlQnJ1c2hcbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZnJlZWRyYXdpbmd8RnJlZWRyYXdpbmcgZGVtb31cbiAqL1xuZmFicmljLkJhc2VCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLkJhc2VCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBDb2xvciBvZiBhIGJydXNoXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgY29sb3I6ICdyZ2IoMCwgMCwgMCknLFxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBhIGJydXNoLCBoYXMgdG8gYmUgYSBOdW1iZXIsIG5vIHN0cmluZyBsaXRlcmFsc1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHdpZHRoOiAxLFxuXG4gIC8qKlxuICAgKiBTaGFkb3cgb2JqZWN0IHJlcHJlc2VudGluZyBzaGFkb3cgb2YgdGhpcyBzaGFwZS5cbiAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcInNoYWRvd0NvbG9yXCIgKFN0cmluZyksIFwic2hhZG93T2Zmc2V0WFwiIChOdW1iZXIpLFxuICAgKiBcInNoYWRvd09mZnNldFlcIiAoTnVtYmVyKSBhbmQgXCJzaGFkb3dCbHVyXCIgKE51bWJlcikgc2luY2UgdjEuMi4xMlxuICAgKiBAdHlwZSBmYWJyaWMuU2hhZG93XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzaGFkb3c6IG51bGwsXG5cbiAgLyoqXG4gICAqIExpbmUgZW5kaW5ncyBzdHlsZSBvZiBhIGJydXNoIChvbmUgb2YgXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIilcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VMaW5lQ2FwOiAncm91bmQnLFxuXG4gIC8qKlxuICAgKiBDb3JuZXIgc3R5bGUgb2YgYSBicnVzaCAob25lIG9mIFwiYmV2ZWxcIiwgXCJyb3VuZFwiLCBcIm1pdGVyXCIpXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc3Ryb2tlTGluZUpvaW46ICdyb3VuZCcsXG5cbiAgLyoqXG4gICAqIE1heGltdW0gbWl0ZXIgbGVuZ3RoICh1c2VkIGZvciBzdHJva2VMaW5lSm9pbiA9IFwibWl0ZXJcIikgb2YgYSBicnVzaCdzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc3Ryb2tlTWl0ZXJMaW1pdDogICAgICAgICAxMCxcblxuICAvKipcbiAgICogU3Ryb2tlIERhc2ggQXJyYXkuXG4gICAqIEB0eXBlIEFycmF5XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VEYXNoQXJyYXk6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdoZW4gYHRydWVgLCB0aGUgZnJlZSBkcmF3aW5nIGlzIGxpbWl0ZWQgdG8gdGhlIHdoaXRlYm9hcmQgc2l6ZS4gRGVmYXVsdCB0byBmYWxzZS5cbiAgICogQHR5cGUgQm9vbGVhblxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAqL1xuXG4gIGxpbWl0ZWRUb0NhbnZhc1NpemU6IGZhbHNlLFxuXG5cbiAgLyoqXG4gICAqIFNldHMgYnJ1c2ggc3R5bGVzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICovXG4gIF9zZXRCcnVzaFN0eWxlczogZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY3R4LmxpbmVDYXAgPSB0aGlzLnN0cm9rZUxpbmVDYXA7XG4gICAgY3R4Lm1pdGVyTGltaXQgPSB0aGlzLnN0cm9rZU1pdGVyTGltaXQ7XG4gICAgY3R4LmxpbmVKb2luID0gdGhpcy5zdHJva2VMaW5lSm9pbjtcbiAgICBjdHguc2V0TGluZURhc2godGhpcy5zdHJva2VEYXNoQXJyYXkgfHwgW10pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0cmFuc2Zvcm1hdGlvbiBvbiBnaXZlbiBjb250ZXh0XG4gICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dDJkfSBjdHggY29udGV4dCB0byByZW5kZXIgb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zYXZlQW5kVHJhbnNmb3JtOiBmdW5jdGlvbihjdHgpIHtcbiAgICB2YXIgdiA9IHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBicnVzaCBzaGFkb3cgc3R5bGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0U2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuc2hhZG93KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzLFxuICAgICAgICBzaGFkb3cgPSB0aGlzLnNoYWRvdyxcbiAgICAgICAgY3R4ID0gY2FudmFzLmNvbnRleHRUb3AsXG4gICAgICAgIHpvb20gPSBjYW52YXMuZ2V0Wm9vbSgpO1xuICAgIGlmIChjYW52YXMgJiYgY2FudmFzLl9pc1JldGluYVNjYWxpbmcoKSkge1xuICAgICAgem9vbSAqPSBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG5cbiAgICBjdHguc2hhZG93Q29sb3IgPSBzaGFkb3cuY29sb3I7XG4gICAgY3R4LnNoYWRvd0JsdXIgPSBzaGFkb3cuYmx1ciAqIHpvb207XG4gICAgY3R4LnNoYWRvd09mZnNldFggPSBzaGFkb3cub2Zmc2V0WCAqIHpvb207XG4gICAgY3R4LnNoYWRvd09mZnNldFkgPSBzaGFkb3cub2Zmc2V0WSAqIHpvb207XG4gIH0sXG5cbiAgbmVlZHNGdWxsUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpO1xuICAgIHJldHVybiBjb2xvci5nZXRBbHBoYSgpIDwgMSB8fCAhIXRoaXMuc2hhZG93O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGJydXNoIHNoYWRvdyBzdHlsZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldFNoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG5cbiAgICBjdHguc2hhZG93Q29sb3IgPSAnJztcbiAgICBjdHguc2hhZG93Qmx1ciA9IGN0eC5zaGFkb3dPZmZzZXRYID0gY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpcyBwb2ludGVyIGlzIG91dHNpZGUgY2FudmFzIGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICogQHByaXZhdGVcbiAgKi9cbiAgX2lzT3V0U2lkZUNhbnZhczogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHJldHVybiBwb2ludGVyLnggPCAwIHx8IHBvaW50ZXIueCA+IHRoaXMuY2FudmFzLmdldFdpZHRoKCkgfHwgcG9pbnRlci55IDwgMCB8fCBwb2ludGVyLnkgPiB0aGlzLmNhbnZhcy5nZXRIZWlnaHQoKTtcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogUGVuY2lsQnJ1c2ggY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QZW5jaWxCcnVzaFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuQmFzZUJydXNoXG4gICAqL1xuICBmYWJyaWMuUGVuY2lsQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQmFzZUJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5QZW5jaWxCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRGlzY2FyZCBwb2ludHMgdGhhdCBhcmUgbGVzcyB0aGFuIGBkZWNpbWF0ZWAgcGl4ZWwgZGlzdGFudCBmcm9tIGVhY2ggb3RoZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwLjRcbiAgICAgKi9cbiAgICBkZWNpbWF0ZTogMC40LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBzdHJhaWdodCBsaW5lIGJldHdlZW4gbGFzdCByZWNvcmRlZCBwb2ludCB0byBjdXJyZW50IHBvaW50ZXJcbiAgICAgKiBVc2VkIGZvciBgc2hpZnRgIGZ1bmN0aW9uYWxpdHlcbiAgICAgKlxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGRyYXdTdHJhaWdodExpbmU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IG1vZGlmaWVyIGtleSB0aGF0IG1ha2VzIHRoZSBicnVzaCBkcmF3IGEgc3RyYWlnaHQgbGluZS5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXkgdGhlIGZlYXR1cmUgaXMgZGlzYWJsZWQuXG4gICAgICogQHR5cGUgeydhbHRLZXknIHwgJ3NoaWZ0S2V5JyB8ICdjdHJsS2V5JyB8ICdub25lJyB8IHVuZGVmaW5lZCB8IG51bGx9XG4gICAgICovXG4gICAgc3RyYWlnaHRMaW5lS2V5OiAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QZW5jaWxCcnVzaH0gSW5zdGFuY2Ugb2YgYSBwZW5jaWwgYnJ1c2hcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5fcG9pbnRzID0gW107XG4gICAgfSxcblxuICAgIG5lZWRzRnVsbFJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCduZWVkc0Z1bGxSZW5kZXInKSB8fCB0aGlzLl9oYXNTdHJhaWdodExpbmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgaW5zaWRlIG9uIG1vdXNlIGRvd24gYW5kIG1vdXNlIG1vdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgICAqL1xuICAgIF9kcmF3U2VnbWVudDogZnVuY3Rpb24gKGN0eCwgcDEsIHAyKSB7XG4gICAgICB2YXIgbWlkUG9pbnQgPSBwMS5taWRQb2ludEZyb20ocDIpO1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8ocDEueCwgcDEueSwgbWlkUG9pbnQueCwgbWlkUG9pbnQueSk7XG4gICAgICByZXR1cm4gbWlkUG9pbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgb24gbW91c2UgZG93blxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAgICovXG4gICAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMuX2lzTWFpbkV2ZW50KG9wdGlvbnMuZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmF3U3RyYWlnaHRMaW5lID0gb3B0aW9ucy5lW3RoaXMuc3RyYWlnaHRMaW5lS2V5XTtcbiAgICAgIHRoaXMuX3ByZXBhcmVGb3JEcmF3aW5nKHBvaW50ZXIpO1xuICAgICAgLy8gY2FwdHVyZSBjb29yZGluYXRlcyBpbW1lZGlhdGVseVxuICAgICAgLy8gdGhpcyBhbGxvd3MgdG8gZHJhdyBkb3RzICh3aGVuIG1vdmVtZW50IG5ldmVyIG9jY3VycylcbiAgICAgIHRoaXMuX2NhcHR1cmVEcmF3aW5nUGF0aChwb2ludGVyKTtcbiAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIG9uIG1vdXNlIG1vdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzLl9pc01haW5FdmVudChvcHRpb25zLmUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd1N0cmFpZ2h0TGluZSA9IG9wdGlvbnMuZVt0aGlzLnN0cmFpZ2h0TGluZUtleV07XG4gICAgICBpZiAodGhpcy5saW1pdGVkVG9DYW52YXNTaXplID09PSB0cnVlICYmIHRoaXMuX2lzT3V0U2lkZUNhbnZhcyhwb2ludGVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY2FwdHVyZURyYXdpbmdQYXRoKHBvaW50ZXIpICYmIHRoaXMuX3BvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmICh0aGlzLm5lZWRzRnVsbFJlbmRlcigpKSB7XG4gICAgICAgICAgLy8gcmVkcmF3IGN1cnZlXG4gICAgICAgICAgLy8gY2xlYXIgdG9wIGNhbnZhc1xuICAgICAgICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5fcG9pbnRzLCBsZW5ndGggPSBwb2ludHMubGVuZ3RoLCBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgICAgICAgIC8vIGRyYXcgdGhlIGN1cnZlIHVwZGF0ZVxuICAgICAgICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICBpZiAodGhpcy5vbGRFbmQpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy5vbGRFbmQueCwgdGhpcy5vbGRFbmQueSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub2xkRW5kID0gdGhpcy5fZHJhd1NlZ21lbnQoY3R4LCBwb2ludHNbbGVuZ3RoIC0gMl0sIHBvaW50c1tsZW5ndGggLSAxXSwgdHJ1ZSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbiBtb3VzZSB1cFxuICAgICAqL1xuICAgIG9uTW91c2VVcDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcy5faXNNYWluRXZlbnQob3B0aW9ucy5lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd1N0cmFpZ2h0TGluZSA9IGZhbHNlO1xuICAgICAgdGhpcy5vbGRFbmQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9maW5hbGl6ZUFuZEFkZFBhdGgoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciBBY3R1YWwgbW91c2UgcG9zaXRpb24gcmVsYXRlZCB0byB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIF9wcmVwYXJlRm9yRHJhd2luZzogZnVuY3Rpb24ocG9pbnRlcikge1xuXG4gICAgICB2YXIgcCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54LCBwb2ludGVyLnkpO1xuXG4gICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgdGhpcy5fYWRkUG9pbnQocCk7XG4gICAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLm1vdmVUbyhwLngsIHAueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFBvaW50IHRvIGJlIGFkZGVkIHRvIHBvaW50cyBhcnJheVxuICAgICAqL1xuICAgIF9hZGRQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIGlmICh0aGlzLl9wb2ludHMubGVuZ3RoID4gMSAmJiBwb2ludC5lcSh0aGlzLl9wb2ludHNbdGhpcy5fcG9pbnRzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kcmF3U3RyYWlnaHRMaW5lICYmIHRoaXMuX3BvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMuX2hhc1N0cmFpZ2h0TGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BvaW50cy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBwb2ludHMgYXJyYXkgYW5kIHNldCBjb250ZXh0VG9wIGNhbnZhcyBzdHlsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9wb2ludHMgPSBbXTtcbiAgICAgIHRoaXMuX3NldEJydXNoU3R5bGVzKHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgICAgdGhpcy5fc2V0U2hhZG93KCk7XG4gICAgICB0aGlzLl9oYXNTdHJhaWdodExpbmUgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciBBY3R1YWwgbW91c2UgcG9zaXRpb24gcmVsYXRlZCB0byB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIF9jYXB0dXJlRHJhd2luZ1BhdGg6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgIHZhciBwb2ludGVyUG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRQb2ludChwb2ludGVyUG9pbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgc21vb3RoIHBhdGggb24gdGhlIHRvcENhbnZhcyB1c2luZyBxdWFkcmF0aWNDdXJ2ZVRvXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gW2N0eF1cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBpLCBsZW4sXG4gICAgICAgICAgcDEgPSB0aGlzLl9wb2ludHNbMF0sXG4gICAgICAgICAgcDIgPSB0aGlzLl9wb2ludHNbMV07XG4gICAgICBjdHggPSBjdHggfHwgdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIC8vaWYgd2Ugb25seSBoYXZlIDIgcG9pbnRzIGluIHRoZSBwYXRoIGFuZCB0aGV5IGFyZSB0aGUgc2FtZVxuICAgICAgLy9pdCBtZWFucyB0aGF0IHRoZSB1c2VyIG9ubHkgY2xpY2tlZCB0aGUgY2FudmFzIHdpdGhvdXQgbW92aW5nIHRoZSBtb3VzZVxuICAgICAgLy90aGVuIHdlIHNob3VsZCBiZSBkcmF3aW5nIGEgZG90LiBBIHBhdGggaXNuJ3QgZHJhd24gYmV0d2VlbiB0d28gaWRlbnRpY2FsIGRvdHNcbiAgICAgIC8vdGhhdCdzIHdoeSB3ZSBzZXQgdGhlbSBhcGFydCBhIGJpdFxuICAgICAgaWYgKHRoaXMuX3BvaW50cy5sZW5ndGggPT09IDIgJiYgcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGggLyAxMDAwO1xuICAgICAgICBwMSA9IG5ldyBmYWJyaWMuUG9pbnQocDEueCwgcDEueSk7XG4gICAgICAgIHAyID0gbmV3IGZhYnJpYy5Qb2ludChwMi54LCBwMi55KTtcbiAgICAgICAgcDEueCAtPSB3aWR0aDtcbiAgICAgICAgcDIueCArPSB3aWR0aDtcbiAgICAgIH1cbiAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueSk7XG5cbiAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHRoaXMuX3BvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyB3ZSBwaWNrIHRoZSBwb2ludCBiZXR3ZWVuIHBpICsgMSAmIHBpICsgMiBhcyB0aGVcbiAgICAgICAgLy8gZW5kIHBvaW50IGFuZCBwMSBhcyBvdXIgY29udHJvbCBwb2ludC5cbiAgICAgICAgdGhpcy5fZHJhd1NlZ21lbnQoY3R4LCBwMSwgcDIpO1xuICAgICAgICBwMSA9IHRoaXMuX3BvaW50c1tpXTtcbiAgICAgICAgcDIgPSB0aGlzLl9wb2ludHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gRHJhdyBsYXN0IGxpbmUgYXMgYSBzdHJhaWdodCBsaW5lIHdoaWxlXG4gICAgICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCBwb2ludCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZVxuICAgICAgLy8gdGhlIGJlemllciBjb250cm9sIHBvaW50XG4gICAgICBjdHgubGluZVRvKHAxLngsIHAxLnkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgcG9pbnRzIHRvIFNWRyBwYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIEFycmF5IG9mIHBvaW50c1xuICAgICAqIEByZXR1cm4geyhzdHJpbmd8bnVtYmVyKVtdW119IFNWRyBwYXRoIGNvbW1hbmRzXG4gICAgICovXG4gICAgY29udmVydFBvaW50c1RvU1ZHUGF0aDogZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgdmFyIGNvcnJlY3Rpb24gPSB0aGlzLndpZHRoIC8gMTAwMDtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5nZXRTbW9vdGhQYXRoRnJvbVBvaW50cyhwb2ludHMsIGNvcnJlY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpW11bXX0gcGF0aERhdGEgU1ZHIHBhdGggY29tbWFuZHNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfaXNFbXB0eVNWR1BhdGg6IGZ1bmN0aW9uIChwYXRoRGF0YSkge1xuICAgICAgdmFyIHBhdGhTdHJpbmcgPSBmYWJyaWMudXRpbC5qb2luUGF0aChwYXRoRGF0YSk7XG4gICAgICByZXR1cm4gcGF0aFN0cmluZyA9PT0gJ00gMCAwIFEgMCAwIDAgMCBMIDAgMCc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgZmFicmljLlBhdGggb2JqZWN0IHRvIGFkZCBvbiBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKVtdW119IHBhdGhEYXRhIFBhdGggZGF0YVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QYXRofSBQYXRoIHRvIGFkZCBvbiBjYW52YXNcbiAgICAgKi9cbiAgICBjcmVhdGVQYXRoOiBmdW5jdGlvbihwYXRoRGF0YSkge1xuICAgICAgdmFyIHBhdGggPSBuZXcgZmFicmljLlBhdGgocGF0aERhdGEsIHtcbiAgICAgICAgZmlsbDogbnVsbCxcbiAgICAgICAgc3Ryb2tlOiB0aGlzLmNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgc3Ryb2tlTGluZUNhcDogdGhpcy5zdHJva2VMaW5lQ2FwLFxuICAgICAgICBzdHJva2VNaXRlckxpbWl0OiB0aGlzLnN0cm9rZU1pdGVyTGltaXQsXG4gICAgICAgIHN0cm9rZUxpbmVKb2luOiB0aGlzLnN0cm9rZUxpbmVKb2luLFxuICAgICAgICBzdHJva2VEYXNoQXJyYXk6IHRoaXMuc3Ryb2tlRGFzaEFycmF5LFxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5zaGFkb3cpIHtcbiAgICAgICAgdGhpcy5zaGFkb3cuYWZmZWN0U3Ryb2tlID0gdHJ1ZTtcbiAgICAgICAgcGF0aC5zaGFkb3cgPSBuZXcgZmFicmljLlNoYWRvdyh0aGlzLnNoYWRvdyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpbWF0ZSBwb2ludHMgYXJyYXkgd2l0aCB0aGUgZGVjaW1hdGUgdmFsdWVcbiAgICAgKi9cbiAgICBkZWNpbWF0ZVBvaW50czogZnVuY3Rpb24ocG9pbnRzLCBkaXN0YW5jZSkge1xuICAgICAgaWYgKHBvaW50cy5sZW5ndGggPD0gMikge1xuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgfVxuICAgICAgdmFyIHpvb20gPSB0aGlzLmNhbnZhcy5nZXRab29tKCksIGFkanVzdGVkRGlzdGFuY2UgPSBNYXRoLnBvdyhkaXN0YW5jZSAvIHpvb20sIDIpLFxuICAgICAgICAgIGksIGwgPSBwb2ludHMubGVuZ3RoIC0gMSwgbGFzdFBvaW50ID0gcG9pbnRzWzBdLCBuZXdQb2ludHMgPSBbbGFzdFBvaW50XSxcbiAgICAgICAgICBjRGlzdGFuY2U7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbCAtIDE7IGkrKykge1xuICAgICAgICBjRGlzdGFuY2UgPSBNYXRoLnBvdyhsYXN0UG9pbnQueCAtIHBvaW50c1tpXS54LCAyKSArIE1hdGgucG93KGxhc3RQb2ludC55IC0gcG9pbnRzW2ldLnksIDIpO1xuICAgICAgICBpZiAoY0Rpc3RhbmNlID49IGFkanVzdGVkRGlzdGFuY2UpIHtcbiAgICAgICAgICBsYXN0UG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgbmV3UG9pbnRzLnB1c2gobGFzdFBvaW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgdGhlIGxhc3QgcG9pbnQgZnJvbSB0aGUgb3JpZ2luYWwgbGluZSB0byB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgICAqIFRoaXMgZW5zdXJlcyBkZWNpbWF0ZSBkb2Vzbid0IGRlbGV0ZSB0aGUgbGFzdCBwb2ludCBvbiB0aGUgbGluZSwgYW5kIGVuc3VyZXMgdGhlIGxpbmUgaXMgPiAxIHBvaW50LlxuICAgICAgICovXG4gICAgICBuZXdQb2ludHMucHVzaChwb2ludHNbbF0pO1xuICAgICAgcmV0dXJuIG5ld1BvaW50cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2V1cCBhZnRlciBkcmF3aW5nIHRoZSBwYXRoIG9uIGNvbnRleHRUb3AgY2FudmFzXG4gICAgICogd2UgdXNlIHRoZSBwb2ludHMgY2FwdHVyZWQgdG8gY3JlYXRlIGFuIG5ldyBmYWJyaWMgcGF0aCBvYmplY3RcbiAgICAgKiBhbmQgYWRkIGl0IHRvIHRoZSBmYWJyaWMgY2FudmFzLlxuICAgICAqL1xuICAgIF9maW5hbGl6ZUFuZEFkZFBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBpZiAodGhpcy5kZWNpbWF0ZSkge1xuICAgICAgICB0aGlzLl9wb2ludHMgPSB0aGlzLmRlY2ltYXRlUG9pbnRzKHRoaXMuX3BvaW50cywgdGhpcy5kZWNpbWF0ZSk7XG4gICAgICB9XG4gICAgICB2YXIgcGF0aERhdGEgPSB0aGlzLmNvbnZlcnRQb2ludHNUb1NWR1BhdGgodGhpcy5fcG9pbnRzKTtcbiAgICAgIGlmICh0aGlzLl9pc0VtcHR5U1ZHUGF0aChwYXRoRGF0YSkpIHtcbiAgICAgICAgLy8gZG8gbm90IGNyZWF0ZSAwIHdpZHRoL2hlaWdodCBwYXRocywgYXMgdGhleSBhcmVcbiAgICAgICAgLy8gcmVuZGVyZWQgaW5jb25zaXN0ZW50bHkgYWNyb3NzIGJyb3dzZXJzXG4gICAgICAgIC8vIEZpcmVmb3ggNCwgZm9yIGV4YW1wbGUsIHJlbmRlcnMgYSBkb3QsXG4gICAgICAgIC8vIHdoZXJlYXMgQ2hyb21lIDEwIHJlbmRlcnMgbm90aGluZ1xuICAgICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGggPSB0aGlzLmNyZWF0ZVBhdGgocGF0aERhdGEpO1xuICAgICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgICAgdGhpcy5jYW52YXMuZmlyZSgnYmVmb3JlOnBhdGg6Y3JlYXRlZCcsIHsgcGF0aDogcGF0aCB9KTtcbiAgICAgIHRoaXMuY2FudmFzLmFkZChwYXRoKTtcbiAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHBhdGguc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLl9yZXNldFNoYWRvdygpO1xuXG5cbiAgICAgIC8vIGZpcmUgZXZlbnQgJ3BhdGgnIGNyZWF0ZWRcbiAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3BhdGg6Y3JlYXRlZCcsIHsgcGF0aDogcGF0aCB9KTtcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4vKipcbiAqIENpcmNsZUJydXNoIGNsYXNzXG4gKiBAY2xhc3MgZmFicmljLkNpcmNsZUJydXNoXG4gKi9cbmZhYnJpYy5DaXJjbGVCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5CYXNlQnJ1c2gsIC8qKiBAbGVuZHMgZmFicmljLkNpcmNsZUJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIGEgYnJ1c2hcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICB3aWR0aDogMTAsXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7ZmFicmljLkNhbnZhc30gY2FudmFzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DaXJjbGVCcnVzaH0gSW5zdGFuY2Ugb2YgYSBjaXJjbGUgYnJ1c2hcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgaW5zaWRlIG9uIG1vdXNlIGRvd24gYW5kIG1vdXNlIG1vdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIGRyYXdEb3Q6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB2YXIgcG9pbnQgPSB0aGlzLmFkZFBvaW50KHBvaW50ZXIpLFxuICAgICAgICBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcbiAgICB0aGlzLmRvdChjdHgsIHBvaW50KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIGRvdDogZnVuY3Rpb24oY3R4LCBwb2ludCkge1xuICAgIGN0eC5maWxsU3R5bGUgPSBwb2ludC5maWxsO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIHBvaW50LnJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBkb3duXG4gICAqL1xuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMucG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMuX3NldFNoYWRvdygpO1xuICAgIHRoaXMuZHJhd0RvdChwb2ludGVyKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBmdWxsIHN0YXRlIG9mIHRoZSBicnVzaFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCAgPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCBpLCBsZW4sXG4gICAgICAgIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuZG90KGN0eCwgcG9pbnRzW2ldKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBvbk1vdXNlTW92ZTogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIGlmICh0aGlzLmxpbWl0ZWRUb0NhbnZhc1NpemUgPT09IHRydWUgJiYgdGhpcy5faXNPdXRTaWRlQ2FudmFzKHBvaW50ZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5lZWRzRnVsbFJlbmRlcigpKSB7XG4gICAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgICB0aGlzLmFkZFBvaW50KHBvaW50ZXIpO1xuICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5kcmF3RG90KHBvaW50ZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSB1cFxuICAgKi9cbiAgb25Nb3VzZVVwOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZSA9IHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlLCBpLCBsZW47XG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBmYWxzZTtcblxuICAgIHZhciBjaXJjbGVzID0gW107XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHBvaW50ID0gdGhpcy5wb2ludHNbaV0sXG4gICAgICAgICAgY2lyY2xlID0gbmV3IGZhYnJpYy5DaXJjbGUoe1xuICAgICAgICAgICAgcmFkaXVzOiBwb2ludC5yYWRpdXMsXG4gICAgICAgICAgICBsZWZ0OiBwb2ludC54LFxuICAgICAgICAgICAgdG9wOiBwb2ludC55LFxuICAgICAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGZpbGw6IHBvaW50LmZpbGxcbiAgICAgICAgICB9KTtcblxuICAgICAgdGhpcy5zaGFkb3cgJiYgKGNpcmNsZS5zaGFkb3cgPSBuZXcgZmFicmljLlNoYWRvdyh0aGlzLnNoYWRvdykpO1xuXG4gICAgICBjaXJjbGVzLnB1c2goY2lyY2xlKTtcbiAgICB9XG4gICAgdmFyIGdyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChjaXJjbGVzKTtcbiAgICBncm91cC5jYW52YXMgPSB0aGlzLmNhbnZhcztcblxuICAgIHRoaXMuY2FudmFzLmZpcmUoJ2JlZm9yZTpwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IGdyb3VwIH0pO1xuICAgIHRoaXMuY2FudmFzLmFkZChncm91cCk7XG4gICAgdGhpcy5jYW52YXMuZmlyZSgncGF0aDpjcmVhdGVkJywgeyBwYXRoOiBncm91cCB9KTtcblxuICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICB0aGlzLl9yZXNldFNoYWRvdygpO1xuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gb3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZTtcbiAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gSnVzdCBhZGRlZCBwb2ludGVyIHBvaW50XG4gICAqL1xuICBhZGRQb2ludDogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHZhciBwb2ludGVyUG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KSxcblxuICAgICAgICBjaXJjbGVSYWRpdXMgPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoXG4gICAgICAgICAgTWF0aC5tYXgoMCwgdGhpcy53aWR0aCAtIDIwKSwgdGhpcy53aWR0aCArIDIwKSAvIDIsXG5cbiAgICAgICAgY2lyY2xlQ29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpXG4gICAgICAgICAgLnNldEFscGhhKGZhYnJpYy51dGlsLmdldFJhbmRvbUludCgwLCAxMDApIC8gMTAwKVxuICAgICAgICAgIC50b1JnYmEoKTtcblxuICAgIHBvaW50ZXJQb2ludC5yYWRpdXMgPSBjaXJjbGVSYWRpdXM7XG4gICAgcG9pbnRlclBvaW50LmZpbGwgPSBjaXJjbGVDb2xvcjtcblxuICAgIHRoaXMucG9pbnRzLnB1c2gocG9pbnRlclBvaW50KTtcblxuICAgIHJldHVybiBwb2ludGVyUG9pbnQ7XG4gIH1cbn0pO1xuXG5cbi8qKlxuICogU3ByYXlCcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5TcHJheUJydXNoXG4gKi9cbmZhYnJpYy5TcHJheUJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoIGZhYnJpYy5CYXNlQnJ1c2gsIC8qKiBAbGVuZHMgZmFicmljLlNwcmF5QnJ1c2gucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogV2lkdGggb2YgYSBzcHJheVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHdpZHRoOiAgICAgICAgICAgICAgMTAsXG5cbiAgLyoqXG4gICAqIERlbnNpdHkgb2YgYSBzcHJheSAobnVtYmVyIG9mIGRvdHMgcGVyIGNodW5rKVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGRlbnNpdHk6ICAgICAgICAgICAgMjAsXG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIHNwcmF5IGRvdHNcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBkb3RXaWR0aDogICAgICAgICAgIDEsXG5cbiAgLyoqXG4gICAqIFdpZHRoIHZhcmlhbmNlIG9mIHNwcmF5IGRvdHNcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBkb3RXaWR0aFZhcmlhbmNlOiAgIDEsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3BhY2l0eSBvZiBhIGRvdCBzaG91bGQgYmUgcmFuZG9tXG4gICAqIEB0eXBlIEJvb2xlYW5cbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHJhbmRvbU9wYWNpdHk6ICAgICAgICBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciBvdmVybGFwcGluZyBkb3RzIChyZWN0YW5nbGVzKSBzaG91bGQgYmUgcmVtb3ZlZCAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpXG4gICAqIEB0eXBlIEJvb2xlYW5cbiAgICogQGRlZmF1bHRcbiAgICovXG4gIG9wdGltaXplT3ZlcmxhcHBpbmc6ICB0cnVlLFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuU3ByYXlCcnVzaH0gSW5zdGFuY2Ugb2YgYSBzcHJheSBicnVzaFxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5zcHJheUNodW5rcyA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIGRvd25cbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5zcHJheUNodW5rcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICB0aGlzLl9zZXRTaGFkb3coKTtcblxuICAgIHRoaXMuYWRkU3ByYXlDaHVuayhwb2ludGVyKTtcbiAgICB0aGlzLnJlbmRlcih0aGlzLnNwcmF5Q2h1bmtQb2ludHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIG1vdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgaWYgKHRoaXMubGltaXRlZFRvQ2FudmFzU2l6ZSA9PT0gdHJ1ZSAmJiB0aGlzLl9pc091dFNpZGVDYW52YXMocG9pbnRlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hZGRTcHJheUNodW5rKHBvaW50ZXIpO1xuICAgIHRoaXMucmVuZGVyKHRoaXMuc3ByYXlDaHVua1BvaW50cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgdXBcbiAgICovXG4gIG9uTW91c2VVcDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmUgPSB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgdmFyIHJlY3RzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWxlbiA9IHRoaXMuc3ByYXlDaHVua3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB2YXIgc3ByYXlDaHVuayA9IHRoaXMuc3ByYXlDaHVua3NbaV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gc3ByYXlDaHVuay5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcblxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBmYWJyaWMuUmVjdCh7XG4gICAgICAgICAgd2lkdGg6IHNwcmF5Q2h1bmtbal0ud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBzcHJheUNodW5rW2pdLndpZHRoLFxuICAgICAgICAgIGxlZnQ6IHNwcmF5Q2h1bmtbal0ueCArIDEsXG4gICAgICAgICAgdG9wOiBzcHJheUNodW5rW2pdLnkgKyAxLFxuICAgICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgICAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgICAgICAgIGZpbGw6IHRoaXMuY29sb3JcbiAgICAgICAgfSk7XG4gICAgICAgIHJlY3RzLnB1c2gocmVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW1pemVPdmVybGFwcGluZykge1xuICAgICAgcmVjdHMgPSB0aGlzLl9nZXRPcHRpbWl6ZWRSZWN0cyhyZWN0cyk7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChyZWN0cyk7XG4gICAgdGhpcy5zaGFkb3cgJiYgZ3JvdXAuc2V0KCdzaGFkb3cnLCBuZXcgZmFicmljLlNoYWRvdyh0aGlzLnNoYWRvdykpO1xuICAgIHRoaXMuY2FudmFzLmZpcmUoJ2JlZm9yZTpwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IGdyb3VwIH0pO1xuICAgIHRoaXMuY2FudmFzLmFkZChncm91cCk7XG4gICAgdGhpcy5jYW52YXMuZmlyZSgncGF0aDpjcmVhdGVkJywgeyBwYXRoOiBncm91cCB9KTtcblxuICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICB0aGlzLl9yZXNldFNoYWRvdygpO1xuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gb3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZTtcbiAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlY3RzXG4gICAqL1xuICBfZ2V0T3B0aW1pemVkUmVjdHM6IGZ1bmN0aW9uKHJlY3RzKSB7XG5cbiAgICAvLyBhdm9pZCBjcmVhdGluZyBkdXBsaWNhdGUgcmVjdHMgYXQgdGhlIHNhbWUgY29vcmRpbmF0ZXNcbiAgICB2YXIgdW5pcXVlUmVjdHMgPSB7IH0sIGtleSwgaSwgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gcmVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGtleSA9IHJlY3RzW2ldLmxlZnQgKyAnJyArIHJlY3RzW2ldLnRvcDtcbiAgICAgIGlmICghdW5pcXVlUmVjdHNba2V5XSkge1xuICAgICAgICB1bmlxdWVSZWN0c1trZXldID0gcmVjdHNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB1bmlxdWVSZWN0c0FycmF5ID0gW107XG4gICAgZm9yIChrZXkgaW4gdW5pcXVlUmVjdHMpIHtcbiAgICAgIHVuaXF1ZVJlY3RzQXJyYXkucHVzaCh1bmlxdWVSZWN0c1trZXldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pcXVlUmVjdHNBcnJheTtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIG5ldyBjaHVuayBvZiBzcHJheSBicnVzaFxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbihzcHJheUNodW5rKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsIGksIGxlbjtcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcblxuICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHNwcmF5Q2h1bmsubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwb2ludCA9IHNwcmF5Q2h1bmtbaV07XG4gICAgICBpZiAodHlwZW9mIHBvaW50Lm9wYWNpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHBvaW50Lm9wYWNpdHk7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFJlY3QocG9pbnQueCwgcG9pbnQueSwgcG9pbnQud2lkdGgsIHBvaW50LndpZHRoKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIGFsbCBzcHJheSBjaHVua3NcbiAgICovXG4gIF9yZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCBpLCBpbGVuO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuXG4gICAgdGhpcy5fc2F2ZUFuZFRyYW5zZm9ybShjdHgpO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRoaXMuc3ByYXlDaHVua3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB0aGlzLnJlbmRlcih0aGlzLnNwcmF5Q2h1bmtzW2ldKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIGFkZFNwcmF5Q2h1bms6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLnNwcmF5Q2h1bmtQb2ludHMgPSBbXTtcblxuICAgIHZhciB4LCB5LCB3aWR0aCwgcmFkaXVzID0gdGhpcy53aWR0aCAvIDIsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kZW5zaXR5OyBpKyspIHtcblxuICAgICAgeCA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludChwb2ludGVyLnggLSByYWRpdXMsIHBvaW50ZXIueCArIHJhZGl1cyk7XG4gICAgICB5ID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KHBvaW50ZXIueSAtIHJhZGl1cywgcG9pbnRlci55ICsgcmFkaXVzKTtcblxuICAgICAgaWYgKHRoaXMuZG90V2lkdGhWYXJpYW5jZSkge1xuICAgICAgICB3aWR0aCA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludChcbiAgICAgICAgICAvLyBib3R0b20gY2xhbXAgd2lkdGggdG8gMVxuICAgICAgICAgIE1hdGgubWF4KDEsIHRoaXMuZG90V2lkdGggLSB0aGlzLmRvdFdpZHRoVmFyaWFuY2UpLFxuICAgICAgICAgIHRoaXMuZG90V2lkdGggKyB0aGlzLmRvdFdpZHRoVmFyaWFuY2UpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHdpZHRoID0gdGhpcy5kb3RXaWR0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludCh4LCB5KTtcbiAgICAgIHBvaW50LndpZHRoID0gd2lkdGg7XG5cbiAgICAgIGlmICh0aGlzLnJhbmRvbU9wYWNpdHkpIHtcbiAgICAgICAgcG9pbnQub3BhY2l0eSA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludCgwLCAxMDApIC8gMTAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNwcmF5Q2h1bmtQb2ludHMucHVzaChwb2ludCk7XG4gICAgfVxuXG4gICAgdGhpcy5zcHJheUNodW5rcy5wdXNoKHRoaXMuc3ByYXlDaHVua1BvaW50cyk7XG4gIH1cbn0pO1xuXG5cbi8qKlxuICogUGF0dGVybkJydXNoIGNsYXNzXG4gKiBAY2xhc3MgZmFicmljLlBhdHRlcm5CcnVzaFxuICogQGV4dGVuZHMgZmFicmljLkJhc2VCcnVzaFxuICovXG5mYWJyaWMuUGF0dGVybkJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLlBlbmNpbEJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5QYXR0ZXJuQnJ1c2gucHJvdG90eXBlICovIHtcblxuICBnZXRQYXR0ZXJuU3JjOiBmdW5jdGlvbigpIHtcblxuICAgIHZhciBkb3RXaWR0aCA9IDIwLFxuICAgICAgICBkb3REaXN0YW5jZSA9IDUsXG4gICAgICAgIHBhdHRlcm5DYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksXG4gICAgICAgIHBhdHRlcm5DdHggPSBwYXR0ZXJuQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICBwYXR0ZXJuQ2FudmFzLndpZHRoID0gcGF0dGVybkNhbnZhcy5oZWlnaHQgPSBkb3RXaWR0aCArIGRvdERpc3RhbmNlO1xuXG4gICAgcGF0dGVybkN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgIHBhdHRlcm5DdHguYmVnaW5QYXRoKCk7XG4gICAgcGF0dGVybkN0eC5hcmMoZG90V2lkdGggLyAyLCBkb3RXaWR0aCAvIDIsIGRvdFdpZHRoIC8gMiwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICBwYXR0ZXJuQ3R4LmNsb3NlUGF0aCgpO1xuICAgIHBhdHRlcm5DdHguZmlsbCgpO1xuXG4gICAgcmV0dXJuIHBhdHRlcm5DYW52YXM7XG4gIH0sXG5cbiAgZ2V0UGF0dGVyblNyY0Z1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gU3RyaW5nKHRoaXMuZ2V0UGF0dGVyblNyYykucmVwbGFjZSgndGhpcy5jb2xvcicsICdcIicgKyB0aGlzLmNvbG9yICsgJ1wiJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgXCJwYXR0ZXJuXCIgaW5zdGFuY2UgcHJvcGVydHlcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgZ2V0UGF0dGVybjogZnVuY3Rpb24oY3R4KSB7XG4gICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRoaXMuc291cmNlIHx8IHRoaXMuZ2V0UGF0dGVyblNyYygpLCAncmVwZWF0Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYnJ1c2ggc3R5bGVzXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICovXG4gIF9zZXRCcnVzaFN0eWxlczogZnVuY3Rpb24oY3R4KSB7XG4gICAgdGhpcy5jYWxsU3VwZXIoJ19zZXRCcnVzaFN0eWxlcycsIGN0eCk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRQYXR0ZXJuKGN0eCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgcGF0aFxuICAgKi9cbiAgY3JlYXRlUGF0aDogZnVuY3Rpb24ocGF0aERhdGEpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXMuY2FsbFN1cGVyKCdjcmVhdGVQYXRoJywgcGF0aERhdGEpLFxuICAgICAgICB0b3BMZWZ0ID0gcGF0aC5fZ2V0TGVmdFRvcENvb3JkcygpLnNjYWxhckFkZChwYXRoLnN0cm9rZVdpZHRoIC8gMik7XG5cbiAgICBwYXRoLnN0cm9rZSA9IG5ldyBmYWJyaWMuUGF0dGVybih7XG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlIHx8IHRoaXMuZ2V0UGF0dGVyblNyY0Z1bmN0aW9uKCksXG4gICAgICBvZmZzZXRYOiAtdG9wTGVmdC54LFxuICAgICAgb2Zmc2V0WTogLXRvcExlZnQueVxuICAgIH0pO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGdldFBvaW50ZXIgPSBmYWJyaWMudXRpbC5nZXRQb2ludGVyLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBpc1RvdWNoRXZlbnQgPSBmYWJyaWMudXRpbC5pc1RvdWNoRXZlbnQ7XG5cbiAgLyoqXG4gICAqIENhbnZhcyBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkNhbnZhc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI2NhbnZhc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkNhbnZhcyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKlxuICAgKiBAZmlyZXMgb2JqZWN0Om1vZGlmaWVkIGF0IHRoZSBlbmQgb2YgYSB0cmFuc2Zvcm0gb3IgYW55IGNoYW5nZSB3aGVuIHN0YXRlZnVsbCBpcyB0cnVlXG4gICAqIEBmaXJlcyBvYmplY3Q6cm90YXRpbmcgd2hpbGUgYW4gb2JqZWN0IGlzIGJlaW5nIHJvdGF0ZWQgZnJvbSB0aGUgY29udHJvbFxuICAgKiBAZmlyZXMgb2JqZWN0OnNjYWxpbmcgd2hpbGUgYW4gb2JqZWN0IGlzIGJlaW5nIHNjYWxlZCBieSBjb250cm9sc1xuICAgKiBAZmlyZXMgb2JqZWN0Om1vdmluZyB3aGlsZSBhbiBvYmplY3QgaXMgYmVpbmcgZHJhZ2dlZFxuICAgKiBAZmlyZXMgb2JqZWN0OnNrZXdpbmcgd2hpbGUgYW4gb2JqZWN0IGlzIGJlaW5nIHNrZXdlZCBmcm9tIHRoZSBjb250cm9sc1xuICAgKlxuICAgKiBAZmlyZXMgYmVmb3JlOnRyYW5zZm9ybSBiZWZvcmUgYSB0cmFuc2Zvcm0gaXMgaXMgc3RhcnRlZFxuICAgKiBAZmlyZXMgYmVmb3JlOnNlbGVjdGlvbjpjbGVhcmVkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246Y2xlYXJlZFxuICAgKiBAZmlyZXMgc2VsZWN0aW9uOnVwZGF0ZWRcbiAgICogQGZpcmVzIHNlbGVjdGlvbjpjcmVhdGVkXG4gICAqXG4gICAqIEBmaXJlcyBwYXRoOmNyZWF0ZWQgYWZ0ZXIgYSBkcmF3aW5nIG9wZXJhdGlvbiBlbmRzIGFuZCB0aGUgcGF0aCBpcyBhZGRlZFxuICAgKiBAZmlyZXMgbW91c2U6ZG93blxuICAgKiBAZmlyZXMgbW91c2U6bW92ZVxuICAgKiBAZmlyZXMgbW91c2U6dXBcbiAgICogQGZpcmVzIG1vdXNlOmRvd246YmVmb3JlICBvbiBtb3VzZSBkb3duLCBiZWZvcmUgdGhlIGlubmVyIGZhYnJpYyBsb2dpYyBydW5zXG4gICAqIEBmaXJlcyBtb3VzZTptb3ZlOmJlZm9yZSBvbiBtb3VzZSBtb3ZlLCBiZWZvcmUgdGhlIGlubmVyIGZhYnJpYyBsb2dpYyBydW5zXG4gICAqIEBmaXJlcyBtb3VzZTp1cDpiZWZvcmUgb24gbW91c2UgdXAsIGJlZm9yZSB0aGUgaW5uZXIgZmFicmljIGxvZ2ljIHJ1bnNcbiAgICogQGZpcmVzIG1vdXNlOm92ZXJcbiAgICogQGZpcmVzIG1vdXNlOm91dFxuICAgKiBAZmlyZXMgbW91c2U6ZGJsY2xpY2sgd2hlbmV2ZXIgYSBuYXRpdmUgZGJsIGNsaWNrIGV2ZW50IGZpcmVzIG9uIHRoZSBjYW52YXMuXG4gICAqXG4gICAqIEBmaXJlcyBkcmFnb3ZlclxuICAgKiBAZmlyZXMgZHJhZ2VudGVyXG4gICAqIEBmaXJlcyBkcmFnbGVhdmVcbiAgICogQGZpcmVzIGRyb3A6YmVmb3JlIGJlZm9yZSBkcm9wIGV2ZW50LiBzYW1lIG5hdGl2ZSBldmVudC4gVGhpcyBpcyBhZGRlZCB0byBoYW5kbGUgZWRnZSBjYXNlc1xuICAgKiBAZmlyZXMgZHJvcFxuICAgKiBAZmlyZXMgYWZ0ZXI6cmVuZGVyIGF0IHRoZSBlbmQgb2YgdGhlIHJlbmRlciBwcm9jZXNzLCByZWNlaXZlcyB0aGUgY29udGV4dCBpbiB0aGUgY2FsbGJhY2tcbiAgICogQGZpcmVzIGJlZm9yZTpyZW5kZXIgYXQgc3RhcnQgdGhlIHJlbmRlciBwcm9jZXNzLCByZWNlaXZlcyB0aGUgY29udGV4dCBpbiB0aGUgY2FsbGJhY2tcbiAgICpcbiAgICovXG4gIGZhYnJpYy5DYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuU3RhdGljQ2FudmFzLCAvKiogQGxlbmRzIGZhYnJpYy5DYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFN0cmluZ30gZWwgJmx0O2NhbnZhcz4gZWxlbWVudCB0byBpbml0aWFsaXplIGluc3RhbmNlIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMucmVuZGVyQW5kUmVzZXRCb3VuZCA9IHRoaXMucmVuZGVyQW5kUmVzZXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbEJvdW5kID0gdGhpcy5yZXF1ZXN0UmVuZGVyQWxsLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9pbml0U3RhdGljKGVsLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRJbnRlcmFjdGl2ZSgpO1xuICAgICAgdGhpcy5fY3JlYXRlQ2FjaGVDYW52YXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBvYmplY3RzIGNhbiBiZSB0cmFuc2Zvcm1lZCBieSBvbmUgc2lkZSAodW5wcm9wb3J0aW9uYWxseSlcbiAgICAgKiB3aGVuIGRyYWdnZWQgb24gdGhlIGNvcm5lcnMgdGhhdCBub3JtYWxseSB3b3VsZCBub3QgZG8gdGhhdC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAc2luY2UgZmFicmljIDQuMCAvLyBjaGFuZ2VkIG5hbWUgYW5kIGRlZmF1bHQgdmFsdWVcbiAgICAgKi9cbiAgICB1bmlmb3JtU2NhbGluZzogICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBzd2l0Y2hlcyB1bmlmb3JtIHNjYWxpbmcuXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQuXG4gICAgICogdG90YWxseSB3cm9uZyBuYW1lZC4gdGhpcyBzb3VuZHMgbGlrZSBgdW5pZm9ybSBzY2FsaW5nYFxuICAgICAqIGlmIENhbnZhcy51bmlmb3JtU2NhbGluZyBpcyB0cnVlLCBwcmVzc2luZyB0aGlzIHdpbGwgc2V0IGl0IHRvIGZhbHNlXG4gICAgICogYW5kIHZpY2V2ZXJzYS5cbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVuaVNjYWxlS2V5OiAgICAgICAgICAgJ3NoaWZ0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0cyB1c2UgY2VudGVyIHBvaW50IGFzIHRoZSBvcmlnaW4gb2Ygc2NhbGUgdHJhbnNmb3JtYXRpb24uXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcImNlbnRlclRyYW5zZm9ybVwiIChCb29sZWFuKS5cbiAgICAgKiBAc2luY2UgMS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZFNjYWxpbmc6ICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0cyB1c2UgY2VudGVyIHBvaW50IGFzIHRoZSBvcmlnaW4gb2Ygcm90YXRlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRSb3RhdGlvbjogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2gga2V5IGVuYWJsZSBjZW50ZXJlZCBUcmFuc2Zvcm1cbiAgICAgKiB2YWx1ZXM6ICdhbHRLZXknLCAnc2hpZnRLZXknLCAnY3RybEtleScuXG4gICAgICogSWYgYG51bGxgIG9yICdub25lJyBvciBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5XG4gICAgICogZmVhdHVyZSBpcyBkaXNhYmxlZCBmZWF0dXJlIGRpc2FibGVkLlxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRLZXk6ICAgICAgICAgICAnYWx0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgZW5hYmxlIGFsdGVybmF0ZSBhY3Rpb24gb24gY29ybmVyXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQgZmVhdHVyZSBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFsdEFjdGlvbktleTogICAgICAgICAgICdzaGlmdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBjYW52YXMgaXMgaW50ZXJhY3RpdmUuIFRoaXMgcHJvcGVydHkgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGludGVyYWN0aXZlOiAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBncm91cCBzZWxlY3Rpb24gc2hvdWxkIGJlIGVuYWJsZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb246ICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBvciBrZXlzIGVuYWJsZSBtdWx0aXBsZSBjbGljayBzZWxlY3Rpb25cbiAgICAgKiBQYXNzIHZhbHVlIGFzIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgKiB2YWx1ZXM6ICdhbHRLZXknLCAnc2hpZnRLZXknLCAnY3RybEtleScuXG4gICAgICogSWYgYG51bGxgIG9yIGVtcHR5IG9yIGNvbnRhaW5pbmcgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nfEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25LZXk6ICAgICAgICAgICAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgYWx0ZXJuYXRpdmUgc2VsZWN0aW9uXG4gICAgICogaW4gY2FzZSBvZiB0YXJnZXQgb3ZlcmxhcHBpbmcgd2l0aCBhY3RpdmUgb2JqZWN0XG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIEZvciBhIHNlcmllcyBvZiByZWFzb24gdGhhdCBjb21lIGZyb20gdGhlIGdlbmVyYWwgZXhwZWN0YXRpb25zIG9uIGhvd1xuICAgICAqIHRoaW5ncyBzaG91bGQgd29yaywgdGhpcyBmZWF0dXJlIHdvcmtzIG9ubHkgZm9yIHByZXNlcnZlT2JqZWN0U3RhY2tpbmcgdHJ1ZS5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkLlxuICAgICAqIEBzaW5jZSAxLjYuNVxuICAgICAqIEB0eXBlIG51bGx8U3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbHRTZWxlY3Rpb25LZXk6ICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2Ygc2VsZWN0aW9uXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25Db2xvcjogICAgICAgICAncmdiYSgxMDAsIDEwMCwgMjU1LCAwLjMpJywgLy8gYmx1ZVxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBkYXNoIGFycmF5IHBhdHRlcm5cbiAgICAgKiBJZiBub3QgZW1wdHkgdGhlIHNlbGVjdGlvbiBib3JkZXIgaXMgZGFzaGVkXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25EYXNoQXJyYXk6ICAgICBbXSxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHRoZSBib3JkZXIgb2Ygc2VsZWN0aW9uICh1c3VhbGx5IHNsaWdodGx5IGRhcmtlciB0aGFuIGNvbG9yIG9mIHNlbGVjdGlvbiBpdHNlbGYpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25Cb3JkZXJDb2xvcjogICAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpJyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIGEgbGluZSB1c2VkIGluIG9iamVjdC9ncm91cCBzZWxlY3Rpb25cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkxpbmVXaWR0aDogICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3Qgb25seSBzaGFwZXMgdGhhdCBhcmUgZnVsbHkgY29udGFpbmVkIGluIHRoZSBkcmFnZ2VkIHNlbGVjdGlvbiByZWN0YW5nbGUuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uRnVsbHlDb250YWluZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIGhvdmVyaW5nIG92ZXIgYW4gb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaG92ZXJDdXJzb3I6ICAgICAgICAgICAgJ21vdmUnLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIG1vdmluZyBhbiBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtb3ZlQ3Vyc29yOiAgICAgICAgICAgICAnbW92ZScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIGZvciB0aGUgZW50aXJlIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZGVmYXVsdEN1cnNvcjogICAgICAgICAgJ2RlZmF1bHQnLFxuXG4gICAgLyoqXG4gICAgICogQ3Vyc29yIHZhbHVlIHVzZWQgZHVyaW5nIGZyZWUgZHJhd2luZ1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZnJlZURyYXdpbmdDdXJzb3I6ICAgICAgJ2Nyb3NzaGFpcicsXG5cbiAgICAvKipcbiAgICAgKiBDdXJzb3IgdmFsdWUgdXNlZCBmb3IgZGlzYWJsZWQgZWxlbWVudHMgKCBjb3JuZXJzIHdpdGggZGlzYWJsZWQgYWN0aW9uIClcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG5vdEFsbG93ZWRDdXJzb3I6ICAgICAgICAgJ25vdC1hbGxvd2VkJyxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZWxlbWVudCBjbGFzcyB0aGF0J3MgZ2l2ZW4gdG8gd3JhcHBlciAoZGl2KSBlbGVtZW50IG9mIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29udGFpbmVyQ2xhc3M6ICAgICAgICAgJ2NhbnZhcy1jb250YWluZXInLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBvYmplY3QgZGV0ZWN0aW9uIGhhcHBlbnMgb24gcGVyLXBpeGVsIGJhc2lzIHJhdGhlciB0aGFuIG9uIHBlci1ib3VuZGluZy1ib3hcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwZXJQaXhlbFRhcmdldEZpbmQ6ICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBwaXhlbHMgYXJvdW5kIHRhcmdldCBwaXhlbCB0byB0b2xlcmF0ZSAoY29uc2lkZXIgYWN0aXZlKSBkdXJpbmcgb2JqZWN0IGRldGVjdGlvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdGFyZ2V0RmluZFRvbGVyYW5jZTogICAgMCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGFyZ2V0IGRldGVjdGlvbiBpcyBza2lwcGVkLiBUYXJnZXQgZGV0ZWN0aW9uIHdpbGwgcmV0dXJuIGFsd2F5cyB1bmRlZmluZWQuXG4gICAgICogY2xpY2sgc2VsZWN0aW9uIHdvbid0IHdvcmsgYW55bW9yZSwgZXZlbnRzIHdpbGwgZmlyZSB3aXRoIG5vIHRhcmdldHMuXG4gICAgICogaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkIGJlZm9yZSBzZXR0aW5nIGl0IHRvIHRydWUsIGl0IHdpbGwgYmUgZGVzZWxlY3RlZCBhdCB0aGUgZmlyc3QgY2xpY2suXG4gICAgICogYXJlYSBzZWxlY3Rpb24gd2lsbCBzdGlsbCB3b3JrLiBjaGVjayB0aGUgYHNlbGVjdGlvbmAgcHJvcGVydHkgdG9vLlxuICAgICAqIGlmIHlvdSBkZWFjdGl2YXRlIGJvdGgsIHlvdSBzaG91bGQgbG9vayBpbnRvIHN0YXRpY0NhbnZhcy5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBza2lwVGFyZ2V0RmluZDogICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgbW91c2UgZXZlbnRzIG9uIGNhbnZhcyAobW91c2Vkb3duL21vdXNlbW92ZS9tb3VzZXVwKSByZXN1bHQgaW4gZnJlZSBkcmF3aW5nLlxuICAgICAqIEFmdGVyIG1vdXNlZG93biwgbW91c2Vtb3ZlIGNyZWF0ZXMgYSBzaGFwZSxcbiAgICAgKiBhbmQgdGhlbiBtb3VzZXVwIGZpbmFsaXplcyBpdCBhbmQgYWRkcyBhbiBpbnN0YW5jZSBvZiBgZmFicmljLlBhdGhgIG9udG8gY2FudmFzLlxuICAgICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC00I2ZyZWVfZHJhd2luZ31cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpc0RyYXdpbmdNb2RlOiAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9iamVjdHMgc2hvdWxkIHJlbWFpbiBpbiBjdXJyZW50IHN0YWNrIHBvc2l0aW9uIHdoZW4gc2VsZWN0ZWQuXG4gICAgICogV2hlbiBmYWxzZSBvYmplY3RzIGFyZSBicm91Z2h0IHRvIHRvcCBhbmQgcmVuZGVyZWQgYXMgcGFydCBvZiB0aGUgc2VsZWN0aW9uIGdyb3VwXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcHJlc2VydmVPYmplY3RTdGFja2luZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIGFuZ2xlIHRoYXQgYW4gb2JqZWN0IHdpbGwgbG9jayB0byB3aGlsZSByb3RhdGluZy5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAc2luY2UgMS42LjdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNuYXBBbmdsZTogMCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgc25hcEFuZ2xlIHRoZSByb3RhdGlvbiB3aWxsIGxvY2sgdG8gdGhlIHNuYXBBbmdsZS5cbiAgICAgKiBXaGVuIGBudWxsYCwgdGhlIHNuYXBUaHJlc2hvbGQgd2lsbCBkZWZhdWx0IHRvIHRoZSBzbmFwQW5nbGUuXG4gICAgICogQHR5cGUgbnVsbHxOdW1iZXJcbiAgICAgKiBAc2luY2UgMS42LjdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNuYXBUaHJlc2hvbGQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHJpZ2h0IGNsaWNrIG9uIGNhbnZhcyBjYW4gb3V0cHV0IHRoZSBjb250ZXh0IG1lbnUgb3Igbm90XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAxLjYuNVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3RvcENvbnRleHRNZW51OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgY2FudmFzIGNhbiBmaXJlIHJpZ2h0IGNsaWNrIGV2ZW50c1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMS42LjVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZpcmVSaWdodENsaWNrOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgY2FudmFzIGNhbiBmaXJlIG1pZGRsZSBjbGljayBldmVudHNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDEuNy44XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaXJlTWlkZGxlQ2xpY2s6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogS2VlcCB0cmFjayBvZiB0aGUgc3ViVGFyZ2V0cyBmb3IgTW91c2UgRXZlbnRzXG4gICAgICogQHR5cGUgZmFicmljLk9iamVjdFtdXG4gICAgICovXG4gICAgdGFyZ2V0czogW10sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBvcHRpb24gaXMgZW5hYmxlZCwgUG9pbnRlckV2ZW50IGlzIHVzZWQgaW5zdGVhZCBvZiBNb3VzZUV2ZW50LlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGVuYWJsZVBvaW50ZXJFdmVudHM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogS2VlcCB0cmFjayBvZiB0aGUgaG92ZXJlZCB0YXJnZXRcbiAgICAgKiBAdHlwZSBmYWJyaWMuT2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaG92ZXJlZFRhcmdldDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGhvbGQgdGhlIGxpc3Qgb2YgbmVzdGVkIHRhcmdldHMgaG92ZXJlZFxuICAgICAqIEB0eXBlIGZhYnJpYy5PYmplY3RbXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hvdmVyZWRUYXJnZXRzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRJbnRlcmFjdGl2ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gbnVsbDtcbiAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSBudWxsO1xuICAgICAgdGhpcy5faW5pdFdyYXBwZXJFbGVtZW50KCk7XG4gICAgICB0aGlzLl9jcmVhdGVVcHBlckNhbnZhcygpO1xuICAgICAgdGhpcy5faW5pdEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICAgIHRoaXMuX2luaXRSZXRpbmFTY2FsaW5nKCk7XG5cbiAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaCA9IGZhYnJpYy5QZW5jaWxCcnVzaCAmJiBuZXcgZmFicmljLlBlbmNpbEJydXNoKHRoaXMpO1xuXG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBvYmplY3RzIGluIHR3byBncm91cHMsIG9uZSB0byByZW5kZXIgaW1tZWRpYXRlbHlcbiAgICAgKiBhbmQgb25lIHRvIHJlbmRlciBhcyBhY3RpdmVHcm91cC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb2JqZWN0cyB0byByZW5kZXIgaW1tZWRpYXRlbHkgYW5kIHB1c2hlcyB0aGUgb3RoZXIgaW4gdGhlIGFjdGl2ZUdyb3VwLlxuICAgICAqL1xuICAgIF9jaG9vc2VPYmplY3RzVG9SZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgICAgICBvYmplY3QsIG9ianNUb1JlbmRlciwgYWN0aXZlR3JvdXBPYmplY3RzO1xuXG4gICAgICBpZiAoYWN0aXZlT2JqZWN0cy5sZW5ndGggPiAwICYmICF0aGlzLnByZXNlcnZlT2JqZWN0U3RhY2tpbmcpIHtcbiAgICAgICAgb2Jqc1RvUmVuZGVyID0gW107XG4gICAgICAgIGFjdGl2ZUdyb3VwT2JqZWN0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9iamVjdCA9IHRoaXMuX29iamVjdHNbaV07XG4gICAgICAgICAgaWYgKGFjdGl2ZU9iamVjdHMuaW5kZXhPZihvYmplY3QpID09PSAtMSApIHtcbiAgICAgICAgICAgIG9ianNUb1JlbmRlci5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlR3JvdXBPYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2ZU9iamVjdHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5fb2JqZWN0cyA9IGFjdGl2ZUdyb3VwT2JqZWN0cztcbiAgICAgICAgfVxuICAgICAgICBvYmpzVG9SZW5kZXIucHVzaC5hcHBseShvYmpzVG9SZW5kZXIsIGFjdGl2ZUdyb3VwT2JqZWN0cyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Jqc1RvUmVuZGVyID0gdGhpcy5fb2JqZWN0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpzVG9SZW5kZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYm90aCB0aGUgdG9wIGNhbnZhcyBhbmQgdGhlIHNlY29uZGFyeSBjb250YWluZXIgY2FudmFzLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuY29udGV4dFRvcERpcnR5ICYmICF0aGlzLl9ncm91cFNlbGVjdG9yICYmICF0aGlzLmlzRHJhd2luZ01vZGUpIHtcbiAgICAgICAgdGhpcy5jbGVhckNvbnRleHQodGhpcy5jb250ZXh0VG9wKTtcbiAgICAgICAgdGhpcy5jb250ZXh0VG9wRGlydHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc0xvc3RDb250ZXh0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyVG9wTGF5ZXIodGhpcy5jb250ZXh0VG9wKTtcbiAgICAgICAgdGhpcy5oYXNMb3N0Q29udGV4dCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGNhbnZhc1RvRHJhd09uID0gdGhpcy5jb250ZXh0Q29udGFpbmVyO1xuICAgICAgdGhpcy5yZW5kZXJDYW52YXMoY2FudmFzVG9EcmF3T24sIHRoaXMuX2Nob29zZU9iamVjdHNUb1JlbmRlcigpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW5kZXJUb3BMYXllcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSAmJiB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoICYmIHRoaXMuZnJlZURyYXdpbmdCcnVzaC5fcmVuZGVyKCk7XG4gICAgICAgIHRoaXMuY29udGV4dFRvcERpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIHdlIHJlbmRlciB0aGUgdG9wIGNvbnRleHQgLSBsYXN0IG9iamVjdFxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICYmIHRoaXMuX2dyb3VwU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fZHJhd1NlbGVjdGlvbihjdHgpO1xuICAgICAgICB0aGlzLmNvbnRleHRUb3BEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gcmVuZGVyIG9ubHkgdGhlIHRvcCBjYW52YXMuXG4gICAgICogQWxzbyB1c2VkIHRvIHJlbmRlciB0aGUgZ3JvdXAgc2VsZWN0aW9uIGJveC5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlclRvcDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dFRvcDtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICB0aGlzLnJlbmRlclRvcExheWVyKGN0eCk7XG4gICAgICB0aGlzLmZpcmUoJ2FmdGVyOnJlbmRlcicpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX25vcm1hbGl6ZVBvaW50ZXI6IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50ZXIpIHtcbiAgICAgIHZhciBtID0gb2JqZWN0LmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBpbnZlcnRlZE0gPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0obSksXG4gICAgICAgICAgdnB0UG9pbnRlciA9IHRoaXMucmVzdG9yZVBvaW50ZXJWcHQocG9pbnRlcik7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQodnB0UG9pbnRlciwgaW52ZXJ0ZWRNKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyB0cmFuc3BhcmVudCBhdCBhIGNlcnRhaW4gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldCBPYmplY3QgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBMZWZ0IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUb3AgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUYXJnZXRUcmFuc3BhcmVudDogZnVuY3Rpb24gKHRhcmdldCwgeCwgeSkge1xuICAgICAgLy8gaW4gY2FzZSB0aGUgdGFyZ2V0IGlzIHRoZSBhY3RpdmVPYmplY3QsIHdlIGNhbm5vdCBleGVjdXRlIHRoaXMgb3B0aW1pemF0aW9uXG4gICAgICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gZHJhdyBjb250cm9scyB0b28uXG4gICAgICBpZiAodGFyZ2V0LnNob3VsZENhY2hlKCkgJiYgdGFyZ2V0Ll9jYWNoZUNhbnZhcyAmJiB0YXJnZXQgIT09IHRoaXMuX2FjdGl2ZU9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZFBvaW50ZXIgPSB0aGlzLl9ub3JtYWxpemVQb2ludGVyKHRhcmdldCwge3g6IHgsIHk6IHl9KSxcbiAgICAgICAgICAgIHRhcmdldFJlbGF0aXZlWCA9IE1hdGgubWF4KHRhcmdldC5jYWNoZVRyYW5zbGF0aW9uWCArIChub3JtYWxpemVkUG9pbnRlci54ICogdGFyZ2V0Lnpvb21YKSwgMCksXG4gICAgICAgICAgICB0YXJnZXRSZWxhdGl2ZVkgPSBNYXRoLm1heCh0YXJnZXQuY2FjaGVUcmFuc2xhdGlvblkgKyAobm9ybWFsaXplZFBvaW50ZXIueSAqIHRhcmdldC56b29tWSksIDApO1xuXG4gICAgICAgIHZhciBpc1RyYW5zcGFyZW50ID0gZmFicmljLnV0aWwuaXNUcmFuc3BhcmVudChcbiAgICAgICAgICB0YXJnZXQuX2NhY2hlQ29udGV4dCwgTWF0aC5yb3VuZCh0YXJnZXRSZWxhdGl2ZVgpLCBNYXRoLnJvdW5kKHRhcmdldFJlbGF0aXZlWSksIHRoaXMudGFyZ2V0RmluZFRvbGVyYW5jZSk7XG5cbiAgICAgICAgcmV0dXJuIGlzVHJhbnNwYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHRDYWNoZSxcbiAgICAgICAgICBvcmlnaW5hbENvbG9yID0gdGFyZ2V0LnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciwgdiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm07XG5cbiAgICAgIHRhcmdldC5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IgPSAnJztcblxuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICB0YXJnZXQucmVuZGVyKGN0eCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICB0YXJnZXQuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yID0gb3JpZ2luYWxDb2xvcjtcblxuICAgICAgdmFyIGlzVHJhbnNwYXJlbnQgPSBmYWJyaWMudXRpbC5pc1RyYW5zcGFyZW50KFxuICAgICAgICBjdHgsIHgsIHksIHRoaXMudGFyZ2V0RmluZFRvbGVyYW5jZSk7XG5cbiAgICAgIHJldHVybiBpc1RyYW5zcGFyZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0YWtlcyBhbiBldmVudCBhbmQgZGV0ZXJtaW5lcyBpZiBzZWxlY3Rpb24ga2V5IGhhcyBiZWVuIHByZXNzZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX2lzU2VsZWN0aW9uS2V5UHJlc3NlZDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHNlbGVjdGlvbktleVByZXNzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5zZWxlY3Rpb25LZXkpKSB7XG4gICAgICAgIHNlbGVjdGlvbktleVByZXNzZWQgPSAhIXRoaXMuc2VsZWN0aW9uS2V5LmZpbmQoZnVuY3Rpb24oa2V5KSB7IHJldHVybiBlW2tleV0gPT09IHRydWU7IH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvbktleVByZXNzZWQgPSBlW3RoaXMuc2VsZWN0aW9uS2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGVjdGlvbktleVByZXNzZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9zaG91bGRDbGVhclNlbGVjdGlvbjogZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgICAgICBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgICF0YXJnZXRcbiAgICAgICAgfHxcbiAgICAgICAgKHRhcmdldCAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdCAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdHMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdHMuaW5kZXhPZih0YXJnZXQpID09PSAtMSAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdCAhPT0gdGFyZ2V0ICYmXG4gICAgICAgICAgIXRoaXMuX2lzU2VsZWN0aW9uS2V5UHJlc3NlZChlKSlcbiAgICAgICAgfHxcbiAgICAgICAgKHRhcmdldCAmJiAhdGFyZ2V0LmV2ZW50ZWQpXG4gICAgICAgIHx8XG4gICAgICAgICh0YXJnZXQgJiZcbiAgICAgICAgICAhdGFyZ2V0LnNlbGVjdGFibGUgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgIT09IHRhcmdldClcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNlbnRlcmVkU2NhbGluZyBmcm9tIG9iamVjdCBjYW4ndCBvdmVycmlkZSBjZW50ZXJlZFNjYWxpbmcgZnJvbSBjYW52YXMuXG4gICAgICogdGhpcyBzaG91bGQgYmUgZml4ZWQsIHNpbmNlIG9iamVjdCBzZXR0aW5nIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBjYW52YXMuXG4gICAgICogYWxzbyB0aGlzIHNob3VsZCBiZSBzb21ldGhpbmcgdGhhdCB3aWxsIGJlIG1pZ3JhdGVkIGluIHRoZSBjb250cm9sIHByb3BlcnRpZXMuXG4gICAgICogYXMgYWJpbGl0eSB0byBkZWZpbmUgdGhlIG9yaWdpbiBvZiB0aGUgdHJhbnNmb3JtYXRpb24gdGhhdCB0aGUgY29udHJvbCBwcm92aWRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhbHRLZXlcbiAgICAgKi9cbiAgICBfc2hvdWxkQ2VudGVyVHJhbnNmb3JtOiBmdW5jdGlvbiAodGFyZ2V0LCBhY3Rpb24sIGFsdEtleSkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2VudGVyVHJhbnNmb3JtO1xuXG4gICAgICBpZiAoYWN0aW9uID09PSAnc2NhbGUnIHx8IGFjdGlvbiA9PT0gJ3NjYWxlWCcgfHwgYWN0aW9uID09PSAnc2NhbGVZJyB8fCBhY3Rpb24gPT09ICdyZXNpemluZycpIHtcbiAgICAgICAgY2VudGVyVHJhbnNmb3JtID0gdGhpcy5jZW50ZXJlZFNjYWxpbmcgfHwgdGFyZ2V0LmNlbnRlcmVkU2NhbGluZztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgICAgY2VudGVyVHJhbnNmb3JtID0gdGhpcy5jZW50ZXJlZFJvdGF0aW9uIHx8IHRhcmdldC5jZW50ZXJlZFJvdGF0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2VudGVyVHJhbnNmb3JtID8gIWFsdEtleSA6IGFsdEtleTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2hvdWxkIGRpc2FwcGVhciBiZWZvcmUgcmVsZWFzZSA0LjBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRPcmlnaW5Gcm9tQ29ybmVyOiBmdW5jdGlvbih0YXJnZXQsIGNvcm5lcikge1xuICAgICAgdmFyIG9yaWdpbiA9IHtcbiAgICAgICAgeDogdGFyZ2V0Lm9yaWdpblgsXG4gICAgICAgIHk6IHRhcmdldC5vcmlnaW5ZXG4gICAgICB9O1xuXG4gICAgICBpZiAoY29ybmVyID09PSAnbWwnIHx8IGNvcm5lciA9PT0gJ3RsJyB8fCBjb3JuZXIgPT09ICdibCcpIHtcbiAgICAgICAgb3JpZ2luLnggPSAncmlnaHQnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyID09PSAnbXInIHx8IGNvcm5lciA9PT0gJ3RyJyB8fCBjb3JuZXIgPT09ICdicicpIHtcbiAgICAgICAgb3JpZ2luLnggPSAnbGVmdCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3JuZXIgPT09ICd0bCcgfHwgY29ybmVyID09PSAnbXQnIHx8IGNvcm5lciA9PT0gJ3RyJykge1xuICAgICAgICBvcmlnaW4ueSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyID09PSAnYmwnIHx8IGNvcm5lciA9PT0gJ21iJyB8fCBjb3JuZXIgPT09ICdicicpIHtcbiAgICAgICAgb3JpZ2luLnkgPSAndG9wJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhbHJlYWR5U2VsZWN0ZWQgdHJ1ZSBpZiB0YXJnZXQgaXMgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb3JuZXIgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXIgbWwsIG1yLCB0bCAuLi5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gW3RhcmdldF0gaW5zZXJ0ZWQgYmFjayB0byBoZWxwIG92ZXJyaWRpbmcuIFVudXNlZFxuICAgICAqL1xuICAgIF9nZXRBY3Rpb25Gcm9tQ29ybmVyOiBmdW5jdGlvbihhbHJlYWR5U2VsZWN0ZWQsIGNvcm5lciwgZSwgdGFyZ2V0KSB7XG4gICAgICBpZiAoIWNvcm5lciB8fCAhYWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiAnZHJhZyc7XG4gICAgICB9XG4gICAgICB2YXIgY29udHJvbCA9IHRhcmdldC5jb250cm9sc1tjb3JuZXJdO1xuICAgICAgcmV0dXJuIGNvbnRyb2wuZ2V0QWN0aW9uTmFtZShlLCBjb250cm9sLCB0YXJnZXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2V0dXBDdXJyZW50VHJhbnNmb3JtOiBmdW5jdGlvbiAoZSwgdGFyZ2V0LCBhbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSksIGNvcm5lciA9IHRhcmdldC5fX2Nvcm5lcixcbiAgICAgICAgICBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW2Nvcm5lcl0sXG4gICAgICAgICAgYWN0aW9uSGFuZGxlciA9IChhbHJlYWR5U2VsZWN0ZWQgJiYgY29ybmVyKSA/XG4gICAgICAgICAgICBjb250cm9sLmdldEFjdGlvbkhhbmRsZXIoZSwgdGFyZ2V0LCBjb250cm9sKSA6IGZhYnJpYy5jb250cm9sc1V0aWxzLmRyYWdIYW5kbGVyLFxuICAgICAgICAgIGFjdGlvbiA9IHRoaXMuX2dldEFjdGlvbkZyb21Db3JuZXIoYWxyZWFkeVNlbGVjdGVkLCBjb3JuZXIsIGUsIHRhcmdldCksXG4gICAgICAgICAgb3JpZ2luID0gdGhpcy5fZ2V0T3JpZ2luRnJvbUNvcm5lcih0YXJnZXQsIGNvcm5lciksXG4gICAgICAgICAgYWx0S2V5ID0gZVt0aGlzLmNlbnRlcmVkS2V5XSxcbiAgICAgICAgICB0cmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgYWN0aW9uSGFuZGxlcjogYWN0aW9uSGFuZGxlcixcbiAgICAgICAgICAgIGNvcm5lcjogY29ybmVyLFxuICAgICAgICAgICAgc2NhbGVYOiB0YXJnZXQuc2NhbGVYLFxuICAgICAgICAgICAgc2NhbGVZOiB0YXJnZXQuc2NhbGVZLFxuICAgICAgICAgICAgc2tld1g6IHRhcmdldC5za2V3WCxcbiAgICAgICAgICAgIHNrZXdZOiB0YXJnZXQuc2tld1ksXG4gICAgICAgICAgICAvLyB1c2VkIGJ5IHRyYW5zYXRpb25cbiAgICAgICAgICAgIG9mZnNldFg6IHBvaW50ZXIueCAtIHRhcmdldC5sZWZ0LFxuICAgICAgICAgICAgb2Zmc2V0WTogcG9pbnRlci55IC0gdGFyZ2V0LnRvcCxcbiAgICAgICAgICAgIG9yaWdpblg6IG9yaWdpbi54LFxuICAgICAgICAgICAgb3JpZ2luWTogb3JpZ2luLnksXG4gICAgICAgICAgICBleDogcG9pbnRlci54LFxuICAgICAgICAgICAgZXk6IHBvaW50ZXIueSxcbiAgICAgICAgICAgIGxhc3RYOiBwb2ludGVyLngsXG4gICAgICAgICAgICBsYXN0WTogcG9pbnRlci55LFxuICAgICAgICAgICAgLy8gdW5zdXJlIHRoZXkgYXJlIHVzZWZ1bCBhbnltb3JlLlxuICAgICAgICAgICAgLy8gbGVmdDogdGFyZ2V0LmxlZnQsXG4gICAgICAgICAgICAvLyB0b3A6IHRhcmdldC50b3AsXG4gICAgICAgICAgICB0aGV0YTogZGVncmVlc1RvUmFkaWFucyh0YXJnZXQuYW5nbGUpLFxuICAgICAgICAgICAgLy8gZW5kIG9mIHVuc3VyZVxuICAgICAgICAgICAgd2lkdGg6IHRhcmdldC53aWR0aCAqIHRhcmdldC5zY2FsZVgsXG4gICAgICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIGFsdEtleTogYWx0S2V5LFxuICAgICAgICAgICAgb3JpZ2luYWw6IGZhYnJpYy51dGlsLnNhdmVPYmplY3RUcmFuc2Zvcm0odGFyZ2V0KSxcbiAgICAgICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2VudGVyVHJhbnNmb3JtKHRhcmdldCwgYWN0aW9uLCBhbHRLZXkpKSB7XG4gICAgICAgIHRyYW5zZm9ybS5vcmlnaW5YID0gJ2NlbnRlcic7XG4gICAgICAgIHRyYW5zZm9ybS5vcmlnaW5ZID0gJ2NlbnRlcic7XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm0ub3JpZ2luYWwub3JpZ2luWCA9IG9yaWdpbi54O1xuICAgICAgdHJhbnNmb3JtLm9yaWdpbmFsLm9yaWdpblkgPSBvcmlnaW4ueTtcbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICB0aGlzLl9iZWZvcmVUcmFuc2Zvcm0oZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3Vyc29yIHR5cGUgb2YgdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIEN1cnNvciB0eXBlIG9mIHRoZSBjYW52YXMgZWxlbWVudC5cbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtdWkvI2N1cnNvclxuICAgICAqL1xuICAgIHNldEN1cnNvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLnVwcGVyQ2FudmFzRWwuc3R5bGUuY3Vyc29yID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0byBkcmF3IHRoZSBzZWxlY3Rpb24gb25cbiAgICAgKi9cbiAgICBfZHJhd1NlbGVjdGlvbjogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5fZ3JvdXBTZWxlY3RvcixcbiAgICAgICAgICB2aWV3cG9ydFN0YXJ0ID0gbmV3IGZhYnJpYy5Qb2ludChzZWxlY3Rvci5leCwgc2VsZWN0b3IuZXkpLFxuICAgICAgICAgIHN0YXJ0ID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQodmlld3BvcnRTdGFydCwgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSksXG4gICAgICAgICAgdmlld3BvcnRFeHRlbnQgPSBuZXcgZmFicmljLlBvaW50KHNlbGVjdG9yLmV4ICsgc2VsZWN0b3IubGVmdCwgc2VsZWN0b3IuZXkgKyBzZWxlY3Rvci50b3ApLFxuICAgICAgICAgIGV4dGVudCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHZpZXdwb3J0RXh0ZW50LCB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKSxcbiAgICAgICAgICBtaW5YID0gTWF0aC5taW4oc3RhcnQueCwgZXh0ZW50LngpLFxuICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihzdGFydC55LCBleHRlbnQueSksXG4gICAgICAgICAgbWF4WCA9IE1hdGgubWF4KHN0YXJ0LngsIGV4dGVudC54KSxcbiAgICAgICAgICBtYXhZID0gTWF0aC5tYXgoc3RhcnQueSwgZXh0ZW50LnkpLFxuICAgICAgICAgIHN0cm9rZU9mZnNldCA9IHRoaXMuc2VsZWN0aW9uTGluZVdpZHRoIC8gMjtcblxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uQ29sb3IpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuc2VsZWN0aW9uQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uTGluZVdpZHRoIHx8ICF0aGlzLnNlbGVjdGlvbkJvcmRlckNvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnNlbGVjdGlvbkxpbmVXaWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc2VsZWN0aW9uQm9yZGVyQ29sb3I7XG5cbiAgICAgIG1pblggKz0gc3Ryb2tlT2Zmc2V0O1xuICAgICAgbWluWSArPSBzdHJva2VPZmZzZXQ7XG4gICAgICBtYXhYIC09IHN0cm9rZU9mZnNldDtcbiAgICAgIG1heFkgLT0gc3Ryb2tlT2Zmc2V0O1xuICAgICAgLy8gc2VsZWN0aW9uIGJvcmRlclxuICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuX3NldExpbmVEYXNoLmNhbGwodGhpcywgY3R4LCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICBjdHguc3Ryb2tlUmVjdChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZXRlcm1pbmVzIHdoYXQgb2JqZWN0IHdlIGFyZSBjbGlja2luZyBvblxuICAgICAqIHRoZSBza2lwR3JvdXAgcGFyYW1ldGVyIGlzIGZvciBpbnRlcm5hbCB1c2UsIGlzIG5lZWRlZCBmb3Igc2hpZnQrY2xpY2sgYWN0aW9uXG4gICAgICogMTEvMDkvMjAxOCBUT0RPOiB3b3VsZCBiZSBjb29sIGlmIGZpbmRUYXJnZXQgY291bGQgZGlzY2VybiBiZXR3ZWVuIGJlaW5nIGEgZnVsbCB0YXJnZXRcbiAgICAgKiBvciB0aGUgb3V0c2lkZSBwYXJ0IG9mIHRoZSBjb3JuZXIuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcEdyb3VwIHdoZW4gdHJ1ZSwgYWN0aXZlR3JvdXAgaXMgc2tpcHBlZCBhbmQgb25seSBvYmplY3RzIGFyZSB0cmF2ZXJzZWQgdGhyb3VnaFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoZSB0YXJnZXQgZm91bmRcbiAgICAgKi9cbiAgICBmaW5kVGFyZ2V0OiBmdW5jdGlvbiAoZSwgc2tpcEdyb3VwKSB7XG4gICAgICBpZiAodGhpcy5za2lwVGFyZ2V0RmluZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpZ25vcmVab29tID0gdHJ1ZSxcbiAgICAgICAgICBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUsIGlnbm9yZVpvb20pLFxuICAgICAgICAgIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBhT2JqZWN0cyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLFxuICAgICAgICAgIGFjdGl2ZVRhcmdldCwgYWN0aXZlVGFyZ2V0U3VicyxcbiAgICAgICAgICBpc1RvdWNoID0gaXNUb3VjaEV2ZW50KGUpLFxuICAgICAgICAgIHNob3VsZExvb2tGb3JBY3RpdmUgPSAoYU9iamVjdHMubGVuZ3RoID4gMSAmJiAhc2tpcEdyb3VwKSB8fCBhT2JqZWN0cy5sZW5ndGggPT09IDE7XG5cbiAgICAgIC8vIGZpcnN0IGNoZWNrIGN1cnJlbnQgZ3JvdXAgKGlmIG9uZSBleGlzdHMpXG4gICAgICAvLyBhY3RpdmUgZ3JvdXAgZG9lcyBub3QgY2hlY2sgc3ViIHRhcmdldHMgbGlrZSBub3JtYWwgZ3JvdXBzLlxuICAgICAgLy8gaWYgYWN0aXZlIGdyb3VwIGp1c3QgZXhpdHMuXG4gICAgICB0aGlzLnRhcmdldHMgPSBbXTtcblxuICAgICAgLy8gaWYgd2UgaGl0IHRoZSBjb3JuZXIgb2YgYW4gYWN0aXZlT2JqZWN0LCBsZXQncyByZXR1cm4gdGhhdC5cbiAgICAgIGlmIChzaG91bGRMb29rRm9yQWN0aXZlICYmIGFjdGl2ZU9iamVjdC5fZmluZFRhcmdldENvcm5lcihwb2ludGVyLCBpc1RvdWNoKSkge1xuICAgICAgICByZXR1cm4gYWN0aXZlT2JqZWN0O1xuICAgICAgfVxuICAgICAgaWYgKGFPYmplY3RzLmxlbmd0aCA+IDEgJiYgIXNraXBHcm91cCAmJiBhY3RpdmVPYmplY3QgPT09IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyhbYWN0aXZlT2JqZWN0XSwgcG9pbnRlcikpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZU9iamVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChhT2JqZWN0cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgYWN0aXZlT2JqZWN0ID09PSB0aGlzLl9zZWFyY2hQb3NzaWJsZVRhcmdldHMoW2FjdGl2ZU9iamVjdF0sIHBvaW50ZXIpKSB7XG4gICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZU9iamVjdFN0YWNraW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZU9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhY3RpdmVUYXJnZXQgPSBhY3RpdmVPYmplY3Q7XG4gICAgICAgICAgYWN0aXZlVGFyZ2V0U3VicyA9IHRoaXMudGFyZ2V0cztcbiAgICAgICAgICB0aGlzLnRhcmdldHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyh0aGlzLl9vYmplY3RzLCBwb2ludGVyKTtcbiAgICAgIGlmIChlW3RoaXMuYWx0U2VsZWN0aW9uS2V5XSAmJiB0YXJnZXQgJiYgYWN0aXZlVGFyZ2V0ICYmIHRhcmdldCAhPT0gYWN0aXZlVGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldCA9IGFjdGl2ZVRhcmdldDtcbiAgICAgICAgdGhpcy50YXJnZXRzID0gYWN0aXZlVGFyZ2V0U3VicztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBwb2ludCBpcyBpbnNpZGUgdGhlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BvaW50ZXJdIHgseSBvYmplY3Qgb2YgcG9pbnQgY29vcmRpbmF0ZXMgd2Ugd2FudCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBPYmplY3QgdG8gdGVzdCBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtnbG9iYWxQb2ludGVyXSB4LHkgb2JqZWN0IG9mIHBvaW50IGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIGNhbnZhcyB1c2VkIHRvIHNlYXJjaCBwZXIgcGl4ZWwgdGFyZ2V0LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpbiBhbiBhcmVhIG9mIGdpdmVuIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NoZWNrVGFyZ2V0OiBmdW5jdGlvbihwb2ludGVyLCBvYmosIGdsb2JhbFBvaW50ZXIpIHtcbiAgICAgIGlmIChvYmogJiZcbiAgICAgICAgICBvYmoudmlzaWJsZSAmJlxuICAgICAgICAgIG9iai5ldmVudGVkICYmXG4gICAgICAgICAgLy8gaHR0cDovL3d3dy5nZW9nLnViYy5jYS9jb3Vyc2VzL2tsaW5rL2dpcy5ub3Rlcy9uY2dpYS91MzIuaHRtbFxuICAgICAgICAgIC8vIGh0dHA6Ly9pZGF2LnVjZGF2aXMuZWR1L35va3JleWxvcy9UQXNoaXAvU3ByaW5nMjAwMC9Qb2ludEluUG9seWdvbi5odG1sXG4gICAgICAgICAgb2JqLmNvbnRhaW5zUG9pbnQocG9pbnRlcilcbiAgICAgICkge1xuICAgICAgICBpZiAoKHRoaXMucGVyUGl4ZWxUYXJnZXRGaW5kIHx8IG9iai5wZXJQaXhlbFRhcmdldEZpbmQpICYmICFvYmouaXNFZGl0aW5nKSB7XG4gICAgICAgICAgdmFyIGlzVHJhbnNwYXJlbnQgPSB0aGlzLmlzVGFyZ2V0VHJhbnNwYXJlbnQob2JqLCBnbG9iYWxQb2ludGVyLngsIGdsb2JhbFBvaW50ZXIueSk7XG4gICAgICAgICAgaWYgKCFpc1RyYW5zcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBzZWFyY2ggaW5zaWRlIG9iamVjdHMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgcG9pbnRlciBpbiBib3VuZGluZyBib3ggb3IgdGhhdCBjb250YWlucyBwb2ludGVyT25DYW52YXMgd2hlbiBwYWludGVkXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29iamVjdHNdIG9iamVjdHMgYXJyYXkgdG8gbG9vayBpbnRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwb2ludGVyXSB4LHkgb2JqZWN0IG9mIHBvaW50IGNvb3JkaW5hdGVzIHdlIHdhbnQgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gb2JqZWN0IHRoYXQgY29udGFpbnMgcG9pbnRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlYXJjaFBvc3NpYmxlVGFyZ2V0czogZnVuY3Rpb24ob2JqZWN0cywgcG9pbnRlcikge1xuICAgICAgLy8gQ2FjaGUgYWxsIHRhcmdldHMgd2hlcmUgdGhlaXIgYm91bmRpbmcgYm94IGNvbnRhaW5zIHBvaW50LlxuICAgICAgdmFyIHRhcmdldCwgaSA9IG9iamVjdHMubGVuZ3RoLCBzdWJUYXJnZXQ7XG4gICAgICAvLyBEbyBub3QgY2hlY2sgZm9yIGN1cnJlbnRseSBncm91cGVkIG9iamVjdHMsIHNpbmNlIHdlIGNoZWNrIHRoZSBwYXJlbnQgZ3JvdXAgaXRzZWxmLlxuICAgICAgLy8gdW50aWwgd2UgY2FsbCB0aGlzIGZ1bmN0aW9uIHNwZWNpZmljYWxseSB0byBzZWFyY2ggaW5zaWRlIHRoZSBhY3RpdmVHcm91cFxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgb2JqVG9DaGVjayA9IG9iamVjdHNbaV07XG4gICAgICAgIHZhciBwb2ludGVyVG9Vc2UgPSBvYmpUb0NoZWNrLmdyb3VwID9cbiAgICAgICAgICB0aGlzLl9ub3JtYWxpemVQb2ludGVyKG9ialRvQ2hlY2suZ3JvdXAsIHBvaW50ZXIpIDogcG9pbnRlcjtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrVGFyZ2V0KHBvaW50ZXJUb1VzZSwgb2JqVG9DaGVjaywgcG9pbnRlcikpIHtcbiAgICAgICAgICB0YXJnZXQgPSBvYmplY3RzW2ldO1xuICAgICAgICAgIGlmICh0YXJnZXQuc3ViVGFyZ2V0Q2hlY2sgJiYgdGFyZ2V0IGluc3RhbmNlb2YgZmFicmljLkdyb3VwKSB7XG4gICAgICAgICAgICBzdWJUYXJnZXQgPSB0aGlzLl9zZWFyY2hQb3NzaWJsZVRhcmdldHModGFyZ2V0Ll9vYmplY3RzLCBwb2ludGVyKTtcbiAgICAgICAgICAgIHN1YlRhcmdldCAmJiB0aGlzLnRhcmdldHMucHVzaChzdWJUYXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwb2ludGVyIGNvb3JkaW5hdGVzIHdpdGhvdXQgdGhlIGVmZmVjdCBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciB3aXRoIFwieFwiIGFuZCBcInlcIiBudW1iZXIgdmFsdWVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBcInhcIiBhbmQgXCJ5XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqL1xuICAgIHJlc3RvcmVQb2ludGVyVnB0OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoXG4gICAgICAgIHBvaW50ZXIsXG4gICAgICAgIGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwb2ludGVyIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIGNhbnZhcy5cbiAgICAgKiBDYW4gcmV0dXJuIGNvb3JkaW5hdGVzIHdpdGggb3Igd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybS5cbiAgICAgKiBpZ25vcmVab29tIGZhbHNlIGdpdmVzIGJhY2sgY29vcmRpbmF0ZXMgdGhhdCByZXByZXNlbnRcbiAgICAgKiB0aGUgcG9pbnQgY2xpY2tlZCBvbiBjYW52YXMgZWxlbWVudC5cbiAgICAgKiBpZ25vcmVab29tIHRydWUgZ2l2ZXMgYmFjayBjb29yZGluYXRlcyBhZnRlciBiZWluZyBwcm9jZXNzZWRcbiAgICAgKiBieSB0aGUgdmlld3BvcnRUcmFuc2Zvcm0gKCBzb3J0IG9mIGNvb3JkaW5hdGVzIG9mIHdoYXQgaXMgZGlzcGxheWVkXG4gICAgICogb24gdGhlIGNhbnZhcyB3aGVyZSB5b3UgYXJlIGNsaWNraW5nLlxuICAgICAqIGlnbm9yZVpvb20gdHJ1ZSA9IEhUTUxFbGVtZW50IGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRvcCxsZWZ0XG4gICAgICogaWdub3JlWm9vbSBmYWxzZSwgZGVmYXVsdCA9IGZhYnJpYyBzcGFjZSBjb29yZGluYXRlcywgdGhlIHNhbWUgdXNlZCBmb3Igc2hhcGUgcG9zaXRpb25cbiAgICAgKiBUbyBpbnRlcmFjdCB3aXRoIHlvdXIgc2hhcGVzIHRvcCBhbmQgbGVmdCB5b3Ugd2FudCB0byB1c2UgaWdub3JlWm9vbSB0cnVlXG4gICAgICogbW9zdCBvZiB0aGUgdGltZSwgd2hpbGUgaWdub3JlWm9vbSBmYWxzZSB3aWxsIGdpdmUgeW91IGNvb3JkaW5hdGVzXG4gICAgICogY29tcGF0aWJsZSB3aXRoIHRoZSBvYmplY3Qub0Nvb3JkcyBzeXN0ZW0uXG4gICAgICogb2YgdGhlIHRpbWUuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlWm9vbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ4XCIgYW5kIFwieVwiIG51bWJlciB2YWx1ZXNcbiAgICAgKi9cbiAgICBnZXRQb2ludGVyOiBmdW5jdGlvbiAoZSwgaWdub3JlWm9vbSkge1xuICAgICAgLy8gcmV0dXJuIGNhY2hlZCB2YWx1ZXMgaWYgd2UgYXJlIGluIHRoZSBldmVudCBwcm9jZXNzaW5nIGNoYWluXG4gICAgICBpZiAodGhpcy5fYWJzb2x1dGVQb2ludGVyICYmICFpZ25vcmVab29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hYnNvbHV0ZVBvaW50ZXI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcG9pbnRlciAmJiBpZ25vcmVab29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludGVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IGdldFBvaW50ZXIoZSksXG4gICAgICAgICAgdXBwZXJDYW52YXNFbCA9IHRoaXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICBib3VuZHMgPSB1cHBlckNhbnZhc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIGJvdW5kc1dpZHRoID0gYm91bmRzLndpZHRoIHx8IDAsXG4gICAgICAgICAgYm91bmRzSGVpZ2h0ID0gYm91bmRzLmhlaWdodCB8fCAwLFxuICAgICAgICAgIGNzc1NjYWxlO1xuXG4gICAgICBpZiAoIWJvdW5kc1dpZHRoIHx8ICFib3VuZHNIZWlnaHQgKSB7XG4gICAgICAgIGlmICgndG9wJyBpbiBib3VuZHMgJiYgJ2JvdHRvbScgaW4gYm91bmRzKSB7XG4gICAgICAgICAgYm91bmRzSGVpZ2h0ID0gTWF0aC5hYnMoIGJvdW5kcy50b3AgLSBib3VuZHMuYm90dG9tICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdyaWdodCcgaW4gYm91bmRzICYmICdsZWZ0JyBpbiBib3VuZHMpIHtcbiAgICAgICAgICBib3VuZHNXaWR0aCA9IE1hdGguYWJzKCBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgICAgcG9pbnRlci54ID0gcG9pbnRlci54IC0gdGhpcy5fb2Zmc2V0LmxlZnQ7XG4gICAgICBwb2ludGVyLnkgPSBwb2ludGVyLnkgLSB0aGlzLl9vZmZzZXQudG9wO1xuICAgICAgaWYgKCFpZ25vcmVab29tKSB7XG4gICAgICAgIHBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHBvaW50ZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0aW5hU2NhbGluZyA9IHRoaXMuZ2V0UmV0aW5hU2NhbGluZygpO1xuICAgICAgaWYgKHJldGluYVNjYWxpbmcgIT09IDEpIHtcbiAgICAgICAgcG9pbnRlci54IC89IHJldGluYVNjYWxpbmc7XG4gICAgICAgIHBvaW50ZXIueSAvPSByZXRpbmFTY2FsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRzV2lkdGggPT09IDAgfHwgYm91bmRzSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIC8vIElmIGJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSAoaS5lLiBub3QgdmlzaWJsZSksIGRvIG5vdCBhcHBseSBzY2FsZS5cbiAgICAgICAgY3NzU2NhbGUgPSB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjc3NTY2FsZSA9IHtcbiAgICAgICAgICB3aWR0aDogdXBwZXJDYW52YXNFbC53aWR0aCAvIGJvdW5kc1dpZHRoLFxuICAgICAgICAgIGhlaWdodDogdXBwZXJDYW52YXNFbC5oZWlnaHQgLyBib3VuZHNIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcG9pbnRlci54ICogY3NzU2NhbGUud2lkdGgsXG4gICAgICAgIHk6IHBvaW50ZXIueSAqIGNzc1NjYWxlLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdGhyb3dzIHtDQU5WQVNfSU5JVF9FUlJPUn0gSWYgY2FudmFzIGNhbiBub3QgYmUgaW5pdGlhbGl6ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlVXBwZXJDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsb3dlckNhbnZhc0NsYXNzID0gdGhpcy5sb3dlckNhbnZhc0VsLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqbG93ZXItY2FudmFzXFxzKi8sICcnKSxcbiAgICAgICAgICBsb3dlckNhbnZhc0VsID0gdGhpcy5sb3dlckNhbnZhc0VsLCB1cHBlckNhbnZhc0VsID0gdGhpcy51cHBlckNhbnZhc0VsO1xuXG4gICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIHRvIGNyZWF0ZSBhIG5ldyB1cHBlckNhbnZhcyBlbGVtZW50IGlmIHdlIGhhdmUgYWxyZWFkeSBvbmUuXG4gICAgICBpZiAodXBwZXJDYW52YXNFbCkge1xuICAgICAgICB1cHBlckNhbnZhc0VsLmNsYXNzTmFtZSA9ICcnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHVwcGVyQ2FudmFzRWwgPSB0aGlzLl9jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAgIHRoaXMudXBwZXJDYW52YXNFbCA9IHVwcGVyQ2FudmFzRWw7XG4gICAgICB9XG4gICAgICBmYWJyaWMudXRpbC5hZGRDbGFzcyh1cHBlckNhbnZhc0VsLCAndXBwZXItY2FudmFzICcgKyBsb3dlckNhbnZhc0NsYXNzKTtcblxuICAgICAgdGhpcy53cmFwcGVyRWwuYXBwZW5kQ2hpbGQodXBwZXJDYW52YXNFbCk7XG5cbiAgICAgIHRoaXMuX2NvcHlDYW52YXNTdHlsZShsb3dlckNhbnZhc0VsLCB1cHBlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMuX2FwcGx5Q2FudmFzU3R5bGUodXBwZXJDYW52YXNFbCk7XG4gICAgICB0aGlzLmNvbnRleHRUb3AgPSB1cHBlckNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udGV4dCBvZiB0b3AgY2FudmFzIHdoZXJlIGludGVyYWN0aW9ucyBhcmUgZHJhd25cbiAgICAgKiBAcmV0dXJucyB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIGdldFRvcENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHRUb3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhY2hlQ2FudmFzRWwgPSB0aGlzLl9jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB0aGlzLmNhY2hlQ2FudmFzRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMud2lkdGgpO1xuICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5jb250ZXh0Q2FjaGUgPSB0aGlzLmNhY2hlQ2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFdyYXBwZXJFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLndyYXBwZXJFbCA9IGZhYnJpYy51dGlsLndyYXBFbGVtZW50KHRoaXMubG93ZXJDYW52YXNFbCwgJ2RpdicsIHtcbiAgICAgICAgJ2NsYXNzJzogdGhpcy5jb250YWluZXJDbGFzc1xuICAgICAgfSk7XG4gICAgICBmYWJyaWMudXRpbC5zZXRTdHlsZSh0aGlzLndyYXBwZXJFbCwge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCArICdweCcsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQgKyAncHgnLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgfSk7XG4gICAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFVuc2VsZWN0YWJsZSh0aGlzLndyYXBwZXJFbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBjYW52YXMgZWxlbWVudCB0byBhcHBseSBzdHlsZXMgb25cbiAgICAgKi9cbiAgICBfYXBwbHlDYW52YXNTdHlsZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGggfHwgZWxlbWVudC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodCB8fCBlbGVtZW50LmhlaWdodDtcblxuICAgICAgZmFicmljLnV0aWwuc2V0U3R5bGUoZWxlbWVudCwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgJ3B4JyxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyAncHgnLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgICd0b3VjaC1hY3Rpb24nOiB0aGlzLmFsbG93VG91Y2hTY3JvbGxpbmcgPyAnbWFuaXB1bGF0aW9uJyA6ICdub25lJyxcbiAgICAgICAgJy1tcy10b3VjaC1hY3Rpb24nOiB0aGlzLmFsbG93VG91Y2hTY3JvbGxpbmcgPyAnbWFuaXB1bGF0aW9uJyA6ICdub25lJ1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50LndpZHRoID0gd2lkdGg7XG4gICAgICBlbGVtZW50LmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50VW5zZWxlY3RhYmxlKGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb3B5IHRoZSBlbnRpcmUgaW5saW5lIHN0eWxlIGZyb20gb25lIGVsZW1lbnQgKGZyb21FbCkgdG8gYW5vdGhlciAodG9FbClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZnJvbUVsIEVsZW1lbnQgc3R5bGUgaXMgY29waWVkIGZyb21cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRvRWwgRWxlbWVudCBjb3BpZWQgc3R5bGUgaXMgYXBwbGllZCB0b1xuICAgICAqL1xuICAgIF9jb3B5Q2FudmFzU3R5bGU6IGZ1bmN0aW9uIChmcm9tRWwsIHRvRWwpIHtcbiAgICAgIHRvRWwuc3R5bGUuY3NzVGV4dCA9IGZyb21FbC5zdHlsZS5jc3NUZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRleHQgb2YgY2FudmFzIHdoZXJlIG9iamVjdCBzZWxlY3Rpb24gaXMgZHJhd25cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uQ29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0VG9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zICZsdDtjYW52YXM+IGVsZW1lbnQgb24gd2hpY2ggb2JqZWN0IHNlbGVjdGlvbiBpcyBkcmF3blxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbkVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVwcGVyQ2FudmFzRWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudGx5IGFjdGl2ZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSBhY3RpdmUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0QWN0aXZlT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIGN1cnJlbnQgc2VsZWN0ZWQgb2JqZWN0c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IGFjdGl2ZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVPYmplY3RzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYWN0aXZlID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICBpZiAoYWN0aXZlLnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nICYmIGFjdGl2ZS5fb2JqZWN0cykge1xuICAgICAgICAgIHJldHVybiBhY3RpdmUuX29iamVjdHMuc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFthY3RpdmVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIHJlbW92ZWRcbiAgICAgKi9cbiAgICBfb25PYmplY3RSZW1vdmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIC8vIHJlbW92aW5nIGFjdGl2ZSBvYmplY3Qgc2hvdWxkIGZpcmUgXCJzZWxlY3Rpb246Y2xlYXJlZFwiIGV2ZW50c1xuICAgICAgaWYgKG9iaiA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnNlbGVjdGlvbjpjbGVhcmVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgICAgdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdCgpO1xuICAgICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjbGVhcmVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgICAgb2JqLmZpcmUoJ2Rlc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmogPT09IHRoaXMuX2hvdmVyZWRUYXJnZXQpe1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfb25PYmplY3RSZW1vdmVkJywgb2JqKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBDb21wYXJlcyB0aGUgb2xkIGFjdGl2ZU9iamVjdCB3aXRoIHRoZSBjdXJyZW50IG9uZSBhbmQgZmlyZXMgY29ycmVjdCBldmVudHNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBvbGQgYWN0aXZlT2JqZWN0XG4gICAgICovXG4gICAgX2ZpcmVTZWxlY3Rpb25FdmVudHM6IGZ1bmN0aW9uKG9sZE9iamVjdHMsIGUpIHtcbiAgICAgIHZhciBzb21ldGhpbmdDaGFuZ2VkID0gZmFsc2UsIG9iamVjdHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgICAgICBhZGRlZCA9IFtdLCByZW1vdmVkID0gW107XG4gICAgICBvbGRPYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2xkT2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3RzLmluZGV4T2Yob2xkT2JqZWN0KSA9PT0gLTEpIHtcbiAgICAgICAgICBzb21ldGhpbmdDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBvbGRPYmplY3QuZmlyZSgnZGVzZWxlY3RlZCcsIHtcbiAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICB0YXJnZXQ6IG9sZE9iamVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlbW92ZWQucHVzaChvbGRPYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9sZE9iamVjdHMuaW5kZXhPZihvYmplY3QpID09PSAtMSkge1xuICAgICAgICAgIHNvbWV0aGluZ0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIG9iamVjdC5maXJlKCdzZWxlY3RlZCcsIHtcbiAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICB0YXJnZXQ6IG9iamVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFkZGVkLnB1c2gob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAob2xkT2JqZWN0cy5sZW5ndGggPiAwICYmIG9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBzb21ldGhpbmdDaGFuZ2VkICYmIHRoaXMuZmlyZSgnc2VsZWN0aW9uOnVwZGF0ZWQnLCB7XG4gICAgICAgICAgZTogZSxcbiAgICAgICAgICBzZWxlY3RlZDogYWRkZWQsXG4gICAgICAgICAgZGVzZWxlY3RlZDogcmVtb3ZlZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y3JlYXRlZCcsIHtcbiAgICAgICAgICBlOiBlLFxuICAgICAgICAgIHNlbGVjdGVkOiBhZGRlZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvbGRPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2xlYXJlZCcsIHtcbiAgICAgICAgICBlOiBlLFxuICAgICAgICAgIGRlc2VsZWN0ZWQ6IHJlbW92ZWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGdpdmVuIG9iamVjdCBhcyB0aGUgb25seSBhY3RpdmUgb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZXQgYXMgYW4gYWN0aXZlIG9uZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCAocGFzc2VkIGFsb25nIHdoZW4gZmlyaW5nIFwib2JqZWN0OnNlbGVjdGVkXCIpXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QsIGUpIHtcbiAgICAgIHZhciBjdXJyZW50QWN0aXZlcyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpO1xuICAgICAgdGhpcy5fc2V0QWN0aXZlT2JqZWN0KG9iamVjdCwgZSk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uRXZlbnRzKGN1cnJlbnRBY3RpdmVzLCBlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgcHJpdmF0ZSBtZXRob2QgZm9yIG5vdy5cbiAgICAgKiBUaGlzIGlzIHN1cHBvc2VkIHRvIGJlIGVxdWl2YWxlbnQgdG8gc2V0QWN0aXZlT2JqZWN0IGJ1dCB3aXRob3V0IGZpcmluZ1xuICAgICAqIGFueSBldmVudC4gVGhlcmUgaXMgY29tbWl0bWVudCB0byBoYXZlIHRoaXMgc3RheSB0aGlzIHdheS5cbiAgICAgKiBUaGlzIGlzIHRoZSBmdW5jdGlvbmFsIHBhcnQgb2Ygc2V0QWN0aXZlT2JqZWN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBzZXQgYXMgYWN0aXZlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IChwYXNzZWQgYWxvbmcgd2hlbiBmaXJpbmcgXCJvYmplY3Q6c2VsZWN0ZWRcIilcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzZWxlY3Rpb24gaGFwcGVuZWRcbiAgICAgKi9cbiAgICBfc2V0QWN0aXZlT2JqZWN0OiBmdW5jdGlvbihvYmplY3QsIGUpIHtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVPYmplY3QgPT09IG9iamVjdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2Rpc2NhcmRBY3RpdmVPYmplY3QoZSwgb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm9uU2VsZWN0KHsgZTogZSB9KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLl9hY3RpdmVPYmplY3QgPSBvYmplY3Q7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIHByaXZhdGUgbWV0aG9kIGZvciBub3cuXG4gICAgICogVGhpcyBpcyBzdXBwb3NlZCB0byBiZSBlcXVpdmFsZW50IHRvIGRpc2NhcmRBY3RpdmVPYmplY3QgYnV0IHdpdGhvdXQgZmlyaW5nXG4gICAgICogYW55IGV2ZW50cy4gVGhlcmUgaXMgY29tbWl0bWVudCB0byBoYXZlIHRoaXMgc3RheSB0aGlzIHdheS5cbiAgICAgKiBUaGlzIGlzIHRoZSBmdW5jdGlvbmFsIHBhcnQgb2YgZGlzY2FyZEFjdGl2ZU9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgKHBhc3NlZCBhbG9uZyB3aGVuIGZpcmluZyBcIm9iamVjdDpkZXNlbGVjdGVkXCIpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBzZXQgYXMgYWN0aXZlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIGhhcHBlbmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGlzY2FyZEFjdGl2ZU9iamVjdDogZnVuY3Rpb24oZSwgb2JqZWN0KSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgaWYgKG9iaikge1xuICAgICAgICAvLyBvbkRlc2VsZWN0IHJldHVybiBUUlVFIHRvIGNhbmNlbCBzZWxlY3Rpb247XG4gICAgICAgIGlmIChvYmoub25EZXNlbGVjdCh7IGU6IGUsIG9iamVjdDogb2JqZWN0IH0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzY2FyZHMgY3VycmVudGx5IGFjdGl2ZSBvYmplY3QgYW5kIGZpcmUgZXZlbnRzLiBJZiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IGZhYnJpY1xuICAgICAqIGFzIGEgY29uc2VxdWVuY2Ugb2YgYSBtb3VzZSBldmVudCwgdGhlIGV2ZW50IGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBhbmRcbiAgICAgKiBzZW50IHRvIHRoZSBmaXJlIGZ1bmN0aW9uIGZvciB0aGUgY3VzdG9tIGV2ZW50cy4gV2hlbiB1c2VkIGFzIGEgbWV0aG9kIHRoZVxuICAgICAqIGUgcGFyYW0gZG9lcyBub3QgaGF2ZSBhbnkgYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHtldmVudH0gZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGlzY2FyZEFjdGl2ZU9iamVjdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBjdXJyZW50QWN0aXZlcyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLCBhY3RpdmVPYmplY3QgPSB0aGlzLmdldEFjdGl2ZU9iamVjdCgpO1xuICAgICAgaWYgKGN1cnJlbnRBY3RpdmVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBhY3RpdmVPYmplY3QsIGU6IGUgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kaXNjYXJkQWN0aXZlT2JqZWN0KGUpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhjdXJyZW50QWN0aXZlcywgZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGEgY2FudmFzIGVsZW1lbnQgYW5kIHJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0aGlzLndyYXBwZXJFbDtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB3cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMudXBwZXJDYW52YXNFbCk7XG4gICAgICB3cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICB0aGlzLmNvbnRleHRDYWNoZSA9IG51bGw7XG4gICAgICB0aGlzLmNvbnRleHRUb3AgPSBudWxsO1xuICAgICAgWyd1cHBlckNhbnZhc0VsJywgJ2NhY2hlQ2FudmFzRWwnXS5mb3JFYWNoKChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNsZWFuVXBKc2RvbU5vZGUodGhpc1tlbGVtZW50XSk7XG4gICAgICAgIHRoaXNbZWxlbWVudF0gPSB1bmRlZmluZWQ7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICAgIGlmICh3cmFwcGVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgd3JhcHBlci5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0aGlzLmxvd2VyQ2FudmFzRWwsIHRoaXMud3JhcHBlckVsKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLndyYXBwZXJFbDtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGNvbnRleHRzIChiYWNrZ3JvdW5kLCBtYWluLCB0b3ApIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdGhpcy5kaXNjYXJkQWN0aXZlR3JvdXAoKTtcbiAgICAgIHRoaXMuZGlzY2FyZEFjdGl2ZU9iamVjdCgpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQodGhpcy5jb250ZXh0VG9wKTtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcignY2xlYXInKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3Mgb2JqZWN0cycgY29udHJvbHMgKGJvcmRlcnMvY29udHJvbHMpXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBjb250cm9scyBvblxuICAgICAqL1xuICAgIGRyYXdDb250cm9sczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuXG4gICAgICBpZiAoYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIGFjdGl2ZU9iamVjdC5fcmVuZGVyQ29udHJvbHMoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG9PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICAvL0lmIHRoZSBvYmplY3QgaXMgcGFydCBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gZ3JvdXAsIGl0IHNob3VsZFxuICAgICAgLy9iZSB0cmFuc2Zvcm1lZCBhcHByb3ByaWF0ZWx5XG4gICAgICAvL2kuZS4gaXQgc2hvdWxkIGJlIHNlcmlhbGlzZWQgYXMgaXQgd291bGQgYXBwZWFyIGlmIHRoZSBzZWxlY3Rpb24gZ3JvdXBcbiAgICAgIC8vd2VyZSB0byBiZSBkZXN0cm95ZWQuXG4gICAgICB2YXIgb3JpZ2luYWxQcm9wZXJ0aWVzID0gdGhpcy5fcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UpLFxuICAgICAgICAgIG9iamVjdCA9IHRoaXMuY2FsbFN1cGVyKCdfdG9PYmplY3QnLCBpbnN0YW5jZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAvL1VuZG8gdGhlIGRhbWFnZSB3ZSBkaWQgYnkgY2hhbmdpbmcgYWxsIG9mIGl0cyBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLl91bndpbmRHcm91cFRyYW5zZm9ybU9uT2JqZWN0KGluc3RhbmNlLCBvcmlnaW5hbFByb3BlcnRpZXMpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhbGlzZXMgYW4gb2JqZWN0J3MgZ3JvdXAgdHJhbnNmb3JtYXRpb24gb24gaXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gW2luc3RhbmNlXSB0aGUgb2JqZWN0IHRvIHRyYW5zZm9ybSAoZ2V0cyBtdXRhdGVkKVxuICAgICAqIEByZXR1cm5zIHRoZSBvcmlnaW5hbCB2YWx1ZXMgb2YgaW5zdGFuY2Ugd2hpY2ggd2VyZSBjaGFuZ2VkXG4gICAgICovXG4gICAgX3JlYWxpemVHcm91cFRyYW5zZm9ybU9uT2JqZWN0OiBmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgICAgaWYgKGluc3RhbmNlLmdyb3VwICYmIGluc3RhbmNlLmdyb3VwLnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nICYmIHRoaXMuX2FjdGl2ZU9iamVjdCA9PT0gaW5zdGFuY2UuZ3JvdXApIHtcbiAgICAgICAgdmFyIGxheW91dFByb3BzID0gWydhbmdsZScsICdmbGlwWCcsICdmbGlwWScsICdsZWZ0JywgJ3NjYWxlWCcsICdzY2FsZVknLCAnc2tld1gnLCAnc2tld1knLCAndG9wJ107XG4gICAgICAgIC8vQ29weSBhbGwgdGhlIHBvc2l0aW9uYWxseSByZWxldmFudCBwcm9wZXJ0aWVzIGFjcm9zcyBub3dcbiAgICAgICAgdmFyIG9yaWdpbmFsVmFsdWVzID0ge307XG4gICAgICAgIGxheW91dFByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgIG9yaWdpbmFsVmFsdWVzW3Byb3BdID0gaW5zdGFuY2VbcHJvcF07XG4gICAgICAgIH0pO1xuICAgICAgICBmYWJyaWMudXRpbC5hZGRUcmFuc2Zvcm1Ub09iamVjdChpbnN0YW5jZSwgdGhpcy5fYWN0aXZlT2JqZWN0LmNhbGNPd25NYXRyaXgoKSk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFZhbHVlcztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgdGhlIGNoYW5nZWQgcHJvcGVydGllcyBvZiBpbnN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBbaW5zdGFuY2VdIHRoZSBvYmplY3QgdG8gdW4tdHJhbnNmb3JtIChnZXRzIG11dGF0ZWQpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcmlnaW5hbFZhbHVlc10gdGhlIG9yaWdpbmFsIHZhbHVlcyBvZiBpbnN0YW5jZSwgYXMgcmV0dXJuZWQgYnkgX3JlYWxpemVHcm91cFRyYW5zZm9ybU9uT2JqZWN0XG4gICAgICovXG4gICAgX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlLCBvcmlnaW5hbFZhbHVlcykge1xuICAgICAgaWYgKG9yaWdpbmFsVmFsdWVzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldChvcmlnaW5hbFZhbHVlcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdDogZnVuY3Rpb24obWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcikge1xuICAgICAgLy9JZiB0aGUgb2JqZWN0IGlzIGluIGEgc2VsZWN0aW9uIGdyb3VwLCBzaW11bGF0ZSB3aGF0IHdvdWxkIGhhcHBlbiB0byB0aGF0XG4gICAgICAvL29iamVjdCB3aGVuIHRoZSBncm91cCBpcyBkZXNlbGVjdGVkXG4gICAgICB2YXIgb3JpZ2luYWxQcm9wZXJ0aWVzID0gdGhpcy5fcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UpO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXRTVkdPYmplY3QnLCBtYXJrdXAsIGluc3RhbmNlLCByZXZpdmVyKTtcbiAgICAgIHRoaXMuX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UsIG9yaWdpbmFsUHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIHNldFZpZXdwb3J0VHJhbnNmb3JtOiBmdW5jdGlvbiAodnB0KSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLl9hY3RpdmVPYmplY3QgJiYgdGhpcy5fYWN0aXZlT2JqZWN0LmlzRWRpdGluZykge1xuICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB9XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZXRWaWV3cG9ydFRyYW5zZm9ybS5jYWxsKHRoaXMsIHZwdCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBjb3B5aW5nIHN0YXRpYyBwcm9wZXJ0aWVzIG1hbnVhbGx5IHRvIHdvcmsgYXJvdW5kIE9wZXJhJ3MgYnVnLFxuICAvLyB3aGVyZSBcInByb3RvdHlwZVwiIHByb3BlcnR5IGlzIGVudW1lcmFibGUgYW5kIG92ZXJyaWRlcyBleGlzdGluZyBwcm90b3R5cGVcbiAgZm9yICh2YXIgcHJvcCBpbiBmYWJyaWMuU3RhdGljQ2FudmFzKSB7XG4gICAgaWYgKHByb3AgIT09ICdwcm90b3R5cGUnKSB7XG4gICAgICBmYWJyaWMuQ2FudmFzW3Byb3BdID0gZmFicmljLlN0YXRpY0NhbnZhc1twcm9wXTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBhZGRMaXN0ZW5lciA9IGZhYnJpYy51dGlsLmFkZExpc3RlbmVyLFxuICAgICAgcmVtb3ZlTGlzdGVuZXIgPSBmYWJyaWMudXRpbC5yZW1vdmVMaXN0ZW5lcixcbiAgICAgIFJJR0hUX0NMSUNLID0gMywgTUlERExFX0NMSUNLID0gMiwgTEVGVF9DTElDSyA9IDEsXG4gICAgICBhZGRFdmVudE9wdGlvbnMgPSB7IHBhc3NpdmU6IGZhbHNlIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tDbGljayhlLCB2YWx1ZSkge1xuICAgIHJldHVybiBlLmJ1dHRvbiAmJiAoZS5idXR0b24gPT09IHZhbHVlIC0gMSk7XG4gIH1cblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5DYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5DYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5zIHRoZSBpZCBvZiB0aGUgdG91Y2ggZXZlbnQgdGhhdCBvd25zIHRoZSBmYWJyaWMgdHJhbnNmb3JtXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtYWluVG91Y2hJZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgbW91c2UgbGlzdGVuZXJzIHRvIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gaW4gY2FzZSB3ZSBpbml0aWFsaXplZCB0aGUgY2xhc3MgdHdpY2UuIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4gbm9ybWFsbHlcbiAgICAgIC8vIGJ1dCBpbiBzb21lIGtpbmQgb2YgYXBwbGljYXRpb25zIHdoZXJlIHRoZSBjYW52YXMgZWxlbWVudCBtYXkgYmUgY2hhbmdlZFxuICAgICAgLy8gdGhpcyBpcyBhIHdvcmthcm91bmQgdG8gaGF2aW5nIGRvdWJsZSBsaXN0ZW5lcnMuXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgICAgdGhpcy5hZGRPclJlbW92ZShhZGRMaXN0ZW5lciwgJ2FkZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYW4gZXZlbnQgcHJlZml4IHBvaW50ZXIgb3IgbW91c2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0RXZlbnRQcmVmaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuYWJsZVBvaW50ZXJFdmVudHMgPyAncG9pbnRlcicgOiAnbW91c2UnO1xuICAgIH0sXG5cbiAgICBhZGRPclJlbW92ZTogZnVuY3Rpb24oZnVuY3RvciwgZXZlbnRqc0Z1bmN0b3IpIHtcbiAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIGV2ZW50VHlwZVByZWZpeCA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgICBmdW5jdG9yKGZhYnJpYy53aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdkb3duJywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnb3V0JywgdGhpcy5fb25Nb3VzZU91dCk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdlbnRlcicsIHRoaXMuX29uTW91c2VFbnRlcik7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICd3aGVlbCcsIHRoaXMuX29uTW91c2VXaGVlbCk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdjb250ZXh0bWVudScsIHRoaXMuX29uQ29udGV4dE1lbnUpO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCAnZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ2RyYWdvdmVyJywgdGhpcy5fb25EcmFnT3Zlcik7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdkcmFnZW50ZXInLCB0aGlzLl9vbkRyYWdFbnRlcik7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdkcmFnbGVhdmUnLCB0aGlzLl9vbkRyYWdMZWF2ZSk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdkcm9wJywgdGhpcy5fb25Ecm9wKTtcbiAgICAgIGlmICghdGhpcy5lbmFibGVQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGV2ZW50anMgIT09ICd1bmRlZmluZWQnICYmIGV2ZW50anNGdW5jdG9yIGluIGV2ZW50anMpIHtcbiAgICAgICAgZXZlbnRqc1tldmVudGpzRnVuY3Rvcl0oY2FudmFzRWxlbWVudCwgJ2dlc3R1cmUnLCB0aGlzLl9vbkdlc3R1cmUpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXShjYW52YXNFbGVtZW50LCAnZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgICAgIGV2ZW50anNbZXZlbnRqc0Z1bmN0b3JdKGNhbnZhc0VsZW1lbnQsICdvcmllbnRhdGlvbicsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXShjYW52YXNFbGVtZW50LCAnc2hha2UnLCB0aGlzLl9vblNoYWtlKTtcbiAgICAgICAgZXZlbnRqc1tldmVudGpzRnVuY3Rvcl0oY2FudmFzRWxlbWVudCwgJ2xvbmdwcmVzcycsIHRoaXMuX29uTG9uZ1ByZXNzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYWRkT3JSZW1vdmUocmVtb3ZlTGlzdGVuZXIsICdyZW1vdmUnKTtcbiAgICAgIC8vIGlmIHlvdSBkaXNwb3NlIG9uIGEgbW91c2VEb3duLCBiZWZvcmUgbW91c2UgdXAsIHlvdSBuZWVkIHRvIGNsZWFuIGRvY3VtZW50IHRvLi4uXG4gICAgICB2YXIgZXZlbnRUeXBlUHJlZml4ID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ3VwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ21vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9iaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmV2ZW50c0JvdW5kKSB7XG4gICAgICAgIC8vIGZvciBhbnkgcmVhc29uIHdlIHBhc3MgaGVyZSB0d2ljZSB3ZSBkbyBub3Qgd2FudCB0byBiaW5kIGV2ZW50cyB0d2ljZS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fb25Nb3VzZURvd24gPSB0aGlzLl9vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Ub3VjaFN0YXJ0ID0gdGhpcy5fb25Ub3VjaFN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IHRoaXMuX29uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlVXAgPSB0aGlzLl9vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uVG91Y2hFbmQgPSB0aGlzLl9vblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblJlc2l6ZSA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkdlc3R1cmUgPSB0aGlzLl9vbkdlc3R1cmUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRHJhZyA9IHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25TaGFrZSA9IHRoaXMuX29uU2hha2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTG9uZ1ByZXNzID0gdGhpcy5fb25Mb25nUHJlc3MuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UgPSB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlV2hlZWwgPSB0aGlzLl9vbk1vdXNlV2hlZWwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VPdXQgPSB0aGlzLl9vbk1vdXNlT3V0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlRW50ZXIgPSB0aGlzLl9vbk1vdXNlRW50ZXIuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uQ29udGV4dE1lbnUgPSB0aGlzLl9vbkNvbnRleHRNZW51LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkRvdWJsZUNsaWNrID0gdGhpcy5fb25Eb3VibGVDbGljay5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25EcmFnT3ZlciA9IHRoaXMuX29uRHJhZ092ZXIuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRHJhZ0VudGVyID0gdGhpcy5fc2ltcGxlRXZlbnRIYW5kbGVyLmJpbmQodGhpcywgJ2RyYWdlbnRlcicpO1xuICAgICAgdGhpcy5fb25EcmFnTGVhdmUgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIuYmluZCh0aGlzLCAnZHJhZ2xlYXZlJyk7XG4gICAgICB0aGlzLl9vbkRyb3AgPSB0aGlzLl9vbkRyb3AuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuZXZlbnRzQm91bmQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgZ2VzdHVyZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25HZXN0dXJlOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25UcmFuc2Zvcm1HZXN0dXJlICYmIHRoaXMuX19vblRyYW5zZm9ybUdlc3R1cmUoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBkcmFnXG4gICAgICogQHBhcmFtIHtFdmVudH0gW3NlbGZdIElubmVyIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9vbkRyYWc6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vbkRyYWcgJiYgdGhpcy5fX29uRHJhZyhlLCBzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIHdoZWVsIGV2ZW50XG4gICAgICovXG4gICAgX29uTW91c2VXaGVlbDogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5fX29uTW91c2VXaGVlbChlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Nb3VzZU91dDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX2hvdmVyZWRUYXJnZXQ7XG4gICAgICB0aGlzLmZpcmUoJ21vdXNlOm91dCcsIHsgdGFyZ2V0OiB0YXJnZXQsIGU6IGUgfSk7XG4gICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRhcmdldCAmJiB0YXJnZXQuZmlyZSgnbW91c2VvdXQnLCB7IGU6IGUgfSk7XG5cbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uKF90YXJnZXQpe1xuICAgICAgICBfdGhpcy5maXJlKCdtb3VzZTpvdXQnLCB7IHRhcmdldDogdGFyZ2V0LCBlOiBlIH0pO1xuICAgICAgICBfdGFyZ2V0ICYmIHRhcmdldC5maXJlKCdtb3VzZW91dCcsIHsgZTogZSB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMgPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWVudGVyXG4gICAgICovXG4gICAgX29uTW91c2VFbnRlcjogZnVuY3Rpb24oZSkge1xuICAgICAgLy8gVGhpcyBmaW5kIHRhcmdldCBhbmQgY29uc2VxdWVudCAnbW91c2U6b3ZlcicgaXMgdXNlZCB0b1xuICAgICAgLy8gY2xlYXIgb2xkIGluc3RhbmNlcyBvbiBob3ZlcmVkIHRhcmdldC5cbiAgICAgIC8vIGNhbGxpbmcgZmluZFRhcmdldCBoYXMgdGhlIHNpZGUgZWZmZWN0IG9mIGtpbGxpbmcgdGFyZ2V0Ll9fY29ybmVyLlxuICAgICAgLy8gYXMgYSBzaG9ydCB0ZXJtIGZpeCB3ZSBhcmUgbm90IGZpcmluZyB0aGlzIGlmIHdlIGFyZSBjdXJyZW50bHkgdHJhbnNmb3JtaW5nLlxuICAgICAgLy8gYXMgYSBsb25nIHRlcm0gZml4IHdlIG5lZWQgdG8gc2VwYXJhdGUgdGhlIGFjdGlvbiBvZiBmaW5kaW5nIGEgdGFyZ2V0IHdpdGggdGhlXG4gICAgICAvLyBzaWRlIGVmZmVjdHMgd2UgYWRkZWQgdG8gaXQuXG4gICAgICBpZiAoIXRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gJiYgIXRoaXMuZmluZFRhcmdldChlKSkge1xuICAgICAgICB0aGlzLmZpcmUoJ21vdXNlOm92ZXInLCB7IHRhcmdldDogbnVsbCwgZTogZSB9KTtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gW107XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBvcmllbnRhdGlvbiBjaGFuZ2VcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uT3JpZW50YXRpb25DaGFuZ2U6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vbk9yaWVudGF0aW9uQ2hhbmdlICYmIHRoaXMuX19vbk9yaWVudGF0aW9uQ2hhbmdlKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgc2hha2VcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uU2hha2U6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vblNoYWtlICYmIHRoaXMuX19vblNoYWtlKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgc2hha2VcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbc2VsZl0gSW5uZXIgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX29uTG9uZ1ByZXNzOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25Mb25nUHJlc3MgJiYgdGhpcy5fX29uTG9uZ1ByZXNzKGUsIHNlbGYpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBwcmV2ZW50IGRlZmF1bHQgdG8gYWxsb3cgZHJvcCBldmVudCB0byBiZSBmaXJlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBzaGFrZVxuICAgICAqL1xuICAgIF9vbkRyYWdPdmVyOiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fc2ltcGxlRXZlbnRIYW5kbGVyKCdkcmFnb3ZlcicsIGUpO1xuICAgICAgdGhpcy5fZmlyZUVudGVyTGVhdmVFdmVudHModGFyZ2V0LCBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYGRyb3A6YmVmb3JlYCBpcyBhIGFuIGV2ZW50IHRoYXQgYWxsb3cgeW91IHRvIHNjaGVkdWxlIGxvZ2ljXG4gICAgICogYmVmb3JlIHRoZSBgZHJvcGAgZXZlbnQuIFByZWZlciBgZHJvcGAgZXZlbnQgYWx3YXlzLCBidXQgaWYgeW91IG5lZWRcbiAgICAgKiB0byBydW4gc29tZSBkcm9wLWRpc2FibGluZyBsb2dpYyBvbiBhbiBldmVudCwgc2luY2UgdGhlcmUgaXMgbm8gd2F5XG4gICAgICogdG8gaGFuZGxlIGV2ZW50IGhhbmRsZXJzIG9yZGVyaW5nLCB1c2UgYGRyb3A6YmVmb3JlYFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBfb25Ecm9wOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fc2ltcGxlRXZlbnRIYW5kbGVyKCdkcm9wOmJlZm9yZScsIGUpO1xuICAgICAgcmV0dXJuIHRoaXMuX3NpbXBsZUV2ZW50SGFuZGxlcignZHJvcCcsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vbkNvbnRleHRNZW51OiBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHRoaXMuc3RvcENvbnRleHRNZW51KSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2RibGNsaWNrJyk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgdGhlIGlkIG9mIGFuIGV2ZW50LlxuICAgICAqIHJldHVybnMgZWl0aGVyIHRoZSBwb2ludGVySWQgb3IgdGhlIGlkZW50aWZpZXIgb3IgMCBmb3IgdGhlIG1vdXNlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldnQgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0UG9pbnRlcklkOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciBjaGFuZ2VkVG91Y2hlcyA9IGV2dC5jaGFuZ2VkVG91Y2hlcztcblxuICAgICAgaWYgKGNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkVG91Y2hlc1swXSAmJiBjaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5lbmFibGVQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgIHJldHVybiBldnQucG9pbnRlcklkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYW4gZXZlbnQgaGFzIHRoZSBpZCBvZiB0aGUgZXZlbnQgdGhhdCBpcyBjb25zaWRlcmVkIG1haW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZXZ0fSBldmVudCBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfaXNNYWluRXZlbnQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKGV2dC5pc1ByaW1hcnkgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZXZ0LmlzUHJpbWFyeSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGV2dC50eXBlID09PSAndG91Y2hlbmQnICYmIGV2dC50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChldnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgcmV0dXJuIGV2dC5jaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyID09PSB0aGlzLm1haW5Ub3VjaElkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uVG91Y2hTdGFydDogZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHRoaXMubWFpblRvdWNoSWQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5tYWluVG91Y2hJZCA9IHRoaXMuZ2V0UG9pbnRlcklkKGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX29uTW91c2VEb3duKGUpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIGV2ZW50VHlwZVByZWZpeCA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIC8vIFVuYmluZCBtb3VzZWRvd24gdG8gcHJldmVudCBkb3VibGUgdHJpZ2dlcnMgZnJvbSB0b3VjaCBkZXZpY2VzXG4gICAgICByZW1vdmVMaXN0ZW5lcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnZG93bicsIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9fb25Nb3VzZURvd24oZSk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgdmFyIGNhbnZhc0VsZW1lbnQgPSB0aGlzLnVwcGVyQ2FudmFzRWwsXG4gICAgICAgICAgZXZlbnRUeXBlUHJlZml4ID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICd1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgICBhZGRMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uVG91Y2hFbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgc3RpbGwgdG91Y2hlcyBzdG9wIGhlcmVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fX29uTW91c2VVcChlKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICB0aGlzLm1haW5Ub3VjaElkID0gbnVsbDtcbiAgICAgIHZhciBldmVudFR5cGVQcmVmaXggPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuX3dpbGxBZGRNb3VzZURvd24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3dpbGxBZGRNb3VzZURvd24pO1xuICAgICAgfVxuICAgICAgdGhpcy5fd2lsbEFkZE1vdXNlRG93biA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFdhaXQgNDAwbXMgYmVmb3JlIHJlYmluZGluZyBtb3VzZWRvd24gdG8gcHJldmVudCBkb3VibGUgdHJpZ2dlcnNcbiAgICAgICAgLy8gZnJvbSB0b3VjaCBkZXZpY2VzXG4gICAgICAgIGFkZExpc3RlbmVyKF90aGlzLnVwcGVyQ2FudmFzRWwsIGV2ZW50VHlwZVByZWZpeCArICdkb3duJywgX3RoaXMuX29uTW91c2VEb3duKTtcbiAgICAgICAgX3RoaXMuX3dpbGxBZGRNb3VzZURvd24gPSAwO1xuICAgICAgfSwgNDAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZXVwXG4gICAgICovXG4gICAgX29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX19vbk1vdXNlVXAoZSk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgdmFyIGNhbnZhc0VsZW1lbnQgPSB0aGlzLnVwcGVyQ2FudmFzRWwsXG4gICAgICAgICAgZXZlbnRUeXBlUHJlZml4ID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICAgIGlmICh0aGlzLl9pc01haW5FdmVudChlKSkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICd1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ21vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgICAgYWRkTGlzdGVuZXIoY2FudmFzRWxlbWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ21vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAhdGhpcy5hbGxvd1RvdWNoU2Nyb2xsaW5nICYmIGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fX29uTW91c2VNb3ZlKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWxjT2Zmc2V0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZXMgd2hldGhlciB0aGUgY2FudmFzIHNob3VsZCBiZSByZWRyYXduIGluIG1vdXNldXAgYW5kIG1vdXNlZG93biBldmVudHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICovXG4gICAgX3Nob3VsZFJlbmRlcjogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuXG4gICAgICBpZiAoXG4gICAgICAgICEhYWN0aXZlT2JqZWN0ICE9PSAhIXRhcmdldCB8fFxuICAgICAgICAoYWN0aXZlT2JqZWN0ICYmIHRhcmdldCAmJiAoYWN0aXZlT2JqZWN0ICE9PSB0YXJnZXQpKVxuICAgICAgKSB7XG4gICAgICAgIC8vIHRoaXMgY292ZXJzOiBzd2l0Y2ggb2YgdGFyZ2V0LCBmcm9tIHRhcmdldCB0byBubyB0YXJnZXQsIHNlbGVjdGlvbiBvZiB0YXJnZXRcbiAgICAgICAgLy8gbXVsdGlTZWxlY3Rpb24gd2l0aCBrZXkgYW5kIG1vdXNlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYWN0aXZlT2JqZWN0ICYmIGFjdGl2ZU9iamVjdC5pc0VkaXRpbmcpIHtcbiAgICAgICAgLy8gaWYgd2UgbW91c2UgdXAvZG93biBvdmVyIGEgZWRpdGluZyB0ZXh0Ym94IGEgY3Vyc29yIGNoYW5nZSxcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gbmVlZCB0byByZSByZW5kZXJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZWZpbmVzIHRoZSBhY3Rpb25zIHdoZW4gbW91c2UgaXMgcmVsZWFzZWQgb24gY2FudmFzLlxuICAgICAqIFRoZSBtZXRob2QgcmVzZXRzIHRoZSBjdXJyZW50VHJhbnNmb3JtIHBhcmFtZXRlcnMsIHN0b3JlIHRoZSBpbWFnZSBjb3JuZXJcbiAgICAgKiBwb3NpdGlvbiBpbiB0aGUgaW1hZ2Ugb2JqZWN0IGFuZCByZW5kZXIgdGhlIGNhbnZhcyBvbiB0b3AuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZXVwXG4gICAgICovXG4gICAgX19vbk1vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdGFyZ2V0LCB0cmFuc2Zvcm0gPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLFxuICAgICAgICAgIGdyb3VwU2VsZWN0b3IgPSB0aGlzLl9ncm91cFNlbGVjdG9yLCBzaG91bGRSZW5kZXIgPSBmYWxzZSxcbiAgICAgICAgICBpc0NsaWNrID0gKCFncm91cFNlbGVjdG9yIHx8IChncm91cFNlbGVjdG9yLmxlZnQgPT09IDAgJiYgZ3JvdXBTZWxlY3Rvci50b3AgPT09IDApKTtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwOmJlZm9yZScpO1xuICAgICAgLy8gaWYgcmlnaHQvbWlkZGxlIGNsaWNrIGp1c3QgZmlyZSBldmVudHMgYW5kIHJldHVyblxuICAgICAgLy8gdGFyZ2V0IHVuZGVmaW5lZCB3aWxsIG1ha2UgdGhlIF9oYW5kbGVFdmVudCBzZWFyY2ggdGhlIHRhcmdldFxuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgUklHSFRfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVSaWdodENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwJywgUklHSFRfQ0xJQ0ssIGlzQ2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgTUlERExFX0NMSUNLKSkge1xuICAgICAgICBpZiAodGhpcy5maXJlTWlkZGxlQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXAnLCBNSURETEVfQ0xJQ0ssIGlzQ2xpY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSAmJiB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdGhpcy5fb25Nb3VzZVVwSW5EcmF3aW5nTW9kZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lzTWFpbkV2ZW50KGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5fZmluYWxpemVDdXJyZW50VHJhbnNmb3JtKGUpO1xuICAgICAgICBzaG91bGRSZW5kZXIgPSB0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0NsaWNrKSB7XG4gICAgICAgIHZhciB0YXJnZXRXYXNBY3RpdmUgPSB0YXJnZXQgPT09IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgICAgdGhpcy5fbWF5YmVHcm91cE9iamVjdHMoZSk7XG4gICAgICAgIGlmICghc2hvdWxkUmVuZGVyKSB7XG4gICAgICAgICAgc2hvdWxkUmVuZGVyID0gKFxuICAgICAgICAgICAgdGhpcy5fc2hvdWxkUmVuZGVyKHRhcmdldCkgfHxcbiAgICAgICAgICAgICghdGFyZ2V0V2FzQWN0aXZlICYmIHRhcmdldCA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjb3JuZXIsIHBvaW50ZXI7XG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGNvcm5lciA9IHRhcmdldC5fZmluZFRhcmdldENvcm5lcihcbiAgICAgICAgICB0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSksXG4gICAgICAgICAgZmFicmljLnV0aWwuaXNUb3VjaEV2ZW50KGUpXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0YXJnZXQuc2VsZWN0YWJsZSAmJiB0YXJnZXQgIT09IHRoaXMuX2FjdGl2ZU9iamVjdCAmJiB0YXJnZXQuYWN0aXZlT24gPT09ICd1cCcpIHtcbiAgICAgICAgICB0aGlzLnNldEFjdGl2ZU9iamVjdCh0YXJnZXQsIGUpO1xuICAgICAgICAgIHNob3VsZFJlbmRlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbnRyb2wgPSB0YXJnZXQuY29udHJvbHNbY29ybmVyXSxcbiAgICAgICAgICAgICAgbW91c2VVcEhhbmRsZXIgPSBjb250cm9sICYmIGNvbnRyb2wuZ2V0TW91c2VVcEhhbmRsZXIoZSwgdGFyZ2V0LCBjb250cm9sKTtcbiAgICAgICAgICBpZiAobW91c2VVcEhhbmRsZXIpIHtcbiAgICAgICAgICAgIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICAgICAgICBtb3VzZVVwSGFuZGxlcihlLCB0cmFuc2Zvcm0sIHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmlzTW92aW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBpZiB3ZSBhcmUgZW5kaW5nIHVwIGEgdHJhbnNmb3JtIG9uIGEgZGlmZmVyZW50IGNvbnRyb2wgb3IgYSBuZXcgb2JqZWN0XG4gICAgICAvLyBmaXJlIHRoZSBvcmlnaW5hbCBtb3VzZSB1cCBmcm9tIHRoZSBjb3JuZXIgdGhhdCBzdGFydGVkIHRoZSB0cmFuc2Zvcm1cbiAgICAgIGlmICh0cmFuc2Zvcm0gJiYgKHRyYW5zZm9ybS50YXJnZXQgIT09IHRhcmdldCB8fCB0cmFuc2Zvcm0uY29ybmVyICE9PSBjb3JuZXIpKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbENvbnRyb2wgPSB0cmFuc2Zvcm0udGFyZ2V0ICYmIHRyYW5zZm9ybS50YXJnZXQuY29udHJvbHNbdHJhbnNmb3JtLmNvcm5lcl0sXG4gICAgICAgICAgICBvcmlnaW5hbE1vdXNlVXBIYW5kbGVyID0gb3JpZ2luYWxDb250cm9sICYmIG9yaWdpbmFsQ29udHJvbC5nZXRNb3VzZVVwSGFuZGxlcihlLCB0YXJnZXQsIGNvbnRyb2wpO1xuICAgICAgICBwb2ludGVyID0gcG9pbnRlciB8fCB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICAgIG9yaWdpbmFsTW91c2VVcEhhbmRsZXIgJiYgb3JpZ2luYWxNb3VzZVVwSGFuZGxlcihlLCB0cmFuc2Zvcm0sIHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldEN1cnNvckZyb21FdmVudChlLCB0YXJnZXQpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ3VwJywgTEVGVF9DTElDSywgaXNDbGljayk7XG4gICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0gbnVsbDtcbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSBudWxsO1xuICAgICAgLy8gcmVzZXQgdGhlIHRhcmdldCBpbmZvcm1hdGlvbiBhYm91dCB3aGljaCBjb3JuZXIgaXMgc2VsZWN0ZWRcbiAgICAgIHRhcmdldCAmJiAodGFyZ2V0Ll9fY29ybmVyID0gMCk7XG4gICAgICBpZiAoc2hvdWxkUmVuZGVyKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzQ2xpY2spIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUb3AoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBIYW5kbGUgZXZlbnQgZmlyaW5nIGZvciB0YXJnZXQgYW5kIHN1YnRhcmdldHNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIGV2ZW50IGZyb20gbW91c2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIGV2ZW50IHRvIGZpcmUgKHVwLCBkb3duIG9yIG1vdmUpXG4gICAgICogQHJldHVybiB7RmFicmljLk9iamVjdH0gdGFyZ2V0IHJldHVybiB0aGUgdGhlIHRhcmdldCBmb3VuZCwgZm9yIGludGVybmFsIHJlYXNvbnMuXG4gICAgICovXG4gICAgX3NpbXBsZUV2ZW50SGFuZGxlcjogZnVuY3Rpb24oZXZlbnRUeXBlLCBlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5maW5kVGFyZ2V0KGUpLFxuICAgICAgICAgIHRhcmdldHMgPSB0aGlzLnRhcmdldHMsXG4gICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIHN1YlRhcmdldHM6IHRhcmdldHMsXG4gICAgICAgICAgfTtcbiAgICAgIHRoaXMuZmlyZShldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgdGFyZ2V0ICYmIHRhcmdldC5maXJlKGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICBpZiAoIXRhcmdldHMpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0YXJnZXRzW2ldLmZpcmUoZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogSGFuZGxlIGV2ZW50IGZpcmluZyBmb3IgdGFyZ2V0IGFuZCBzdWJ0YXJnZXRzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBldmVudCBmcm9tIG1vdXNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBldmVudCB0byBmaXJlICh1cCwgZG93biBvciBtb3ZlKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0T2JqIHJlY2VpdmluZyBldmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYnV0dG9uXSBidXR0b24gdXNlZCBpbiB0aGUgZXZlbnQgMSA9IGxlZnQsIDIgPSBtaWRkbGUsIDMgPSByaWdodFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNDbGljayBmb3IgbGVmdCBidXR0b24gb25seSwgaW5kaWNhdGVzIHRoYXQgdGhlIG1vdXNlIHVwIGhhcHBlbmVkIHdpdGhvdXQgbW92ZS5cbiAgICAgKi9cbiAgICBfaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUsIGV2ZW50VHlwZSwgYnV0dG9uLCBpc0NsaWNrKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0LFxuICAgICAgICAgIHRhcmdldHMgPSB0aGlzLnRhcmdldHMgfHwgW10sXG4gICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIHN1YlRhcmdldHM6IHRhcmdldHMsXG4gICAgICAgICAgICBidXR0b246IGJ1dHRvbiB8fCBMRUZUX0NMSUNLLFxuICAgICAgICAgICAgaXNDbGljazogaXNDbGljayB8fCBmYWxzZSxcbiAgICAgICAgICAgIHBvaW50ZXI6IHRoaXMuX3BvaW50ZXIsXG4gICAgICAgICAgICBhYnNvbHV0ZVBvaW50ZXI6IHRoaXMuX2Fic29sdXRlUG9pbnRlcixcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5fY3VycmVudFRyYW5zZm9ybVxuICAgICAgICAgIH07XG4gICAgICBpZiAoZXZlbnRUeXBlID09PSAndXAnKSB7XG4gICAgICAgIG9wdGlvbnMuY3VycmVudFRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlKTtcbiAgICAgICAgb3B0aW9ucy5jdXJyZW50U3ViVGFyZ2V0cyA9IHRoaXMudGFyZ2V0cztcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlyZSgnbW91c2U6JyArIGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoJ21vdXNlJyArIGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0c1tpXS5maXJlKCdtb3VzZScgKyBldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgc2VuZCB0aGUgbW91c2UgZXZlbnQgdGhhdCBnZW5lcmF0ZSB0aGUgZmluYWxpemUgZG93biwgc28gaXQgY2FuIGJlIHVzZWQgaW4gdGhlIGV2ZW50XG4gICAgICovXG4gICAgX2ZpbmFsaXplQ3VycmVudFRyYW5zZm9ybTogZnVuY3Rpb24oZSkge1xuXG4gICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSxcbiAgICAgICAgICB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlOiBlLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgICAgIGFjdGlvbjogdHJhbnNmb3JtLmFjdGlvbixcbiAgICAgICAgICB9O1xuXG4gICAgICBpZiAodGFyZ2V0Ll9zY2FsaW5nKSB7XG4gICAgICAgIHRhcmdldC5fc2NhbGluZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQuc2V0Q29vcmRzKCk7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkIHx8ICh0aGlzLnN0YXRlZnVsICYmIHRhcmdldC5oYXNTdGF0ZUNoYW5nZWQoKSkpIHtcbiAgICAgICAgdGhpcy5fZmlyZSgnbW9kaWZpZWQnLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Nb3VzZURvd25JbkRyYXdpbmdNb2RlOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuZ2V0QWN0aXZlT2JqZWN0KCkpIHtcbiAgICAgICAgdGhpcy5kaXNjYXJkQWN0aXZlT2JqZWN0KGUpLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpO1xuICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoLm9uTW91c2VEb3duKHBvaW50ZXIsIHsgZTogZSwgcG9pbnRlcjogcG9pbnRlciB9KTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICovXG4gICAgX29uTW91c2VNb3ZlSW5EcmF3aW5nTW9kZTogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoLm9uTW91c2VNb3ZlKHBvaW50ZXIsIHsgZTogZSwgcG9pbnRlcjogcG9pbnRlciB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMuZnJlZURyYXdpbmdDdXJzb3IpO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ21vdmUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZXVwXG4gICAgICovXG4gICAgX29uTW91c2VVcEluRHJhd2luZ01vZGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpO1xuICAgICAgdGhpcy5faXNDdXJyZW50bHlEcmF3aW5nID0gdGhpcy5mcmVlRHJhd2luZ0JydXNoLm9uTW91c2VVcCh7IGU6IGUsIHBvaW50ZXI6IHBvaW50ZXIgfSk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgZGVmaW5lcyB0aGUgYWN0aW9ucyB3aGVuIG1vdXNlIGlzIGNsaWNrZWQgb24gY2FudmFzLlxuICAgICAqIFRoZSBtZXRob2QgaW5pdHMgdGhlIGN1cnJlbnRUcmFuc2Zvcm0gcGFyYW1ldGVycyBhbmQgcmVuZGVycyBhbGwgdGhlXG4gICAgICogY2FudmFzIHNvIHRoZSBjdXJyZW50IGltYWdlIGNhbiBiZSBwbGFjZWQgb24gdGhlIHRvcCBjYW52YXMgYW5kIHRoZSByZXN0XG4gICAgICogaW4gb24gdGhlIGNvbnRhaW5lciBvbmUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfX29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fY2FjaGVUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bjpiZWZvcmUnKTtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQ7XG4gICAgICAvLyBpZiByaWdodCBjbGljayBqdXN0IGZpcmUgZXZlbnRzXG4gICAgICBpZiAoY2hlY2tDbGljayhlLCBSSUdIVF9DTElDSykpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyZVJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicsIFJJR0hUX0NMSUNLKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0NsaWNrKGUsIE1JRERMRV9DTElDSykpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyZU1pZGRsZUNsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nLCBNSURETEVfQ0xJQ0spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSkge1xuICAgICAgICB0aGlzLl9vbk1vdXNlRG93bkluRHJhd2luZ01vZGUoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pc01haW5FdmVudChlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGlnbm9yZSBpZiBzb21lIG9iamVjdCBpcyBiZWluZyB0cmFuc2Zvcm1lZCBhdCB0aGlzIG1vbWVudFxuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuX3BvaW50ZXI7XG4gICAgICAvLyBzYXZlIHBvaW50ZXIgZm9yIGNoZWNrIGluIF9fb25Nb3VzZVVwIGV2ZW50XG4gICAgICB0aGlzLl9wcmV2aW91c1BvaW50ZXIgPSBwb2ludGVyO1xuICAgICAgdmFyIHNob3VsZFJlbmRlciA9IHRoaXMuX3Nob3VsZFJlbmRlcih0YXJnZXQpLFxuICAgICAgICAgIHNob3VsZEdyb3VwID0gdGhpcy5fc2hvdWxkR3JvdXAoZSwgdGFyZ2V0KTtcbiAgICAgIGlmICh0aGlzLl9zaG91bGRDbGVhclNlbGVjdGlvbihlLCB0YXJnZXQpKSB7XG4gICAgICAgIHRoaXMuZGlzY2FyZEFjdGl2ZU9iamVjdChlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNob3VsZEdyb3VwKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUdyb3VwaW5nKGUsIHRhcmdldCk7XG4gICAgICAgIHRhcmdldCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICYmICghdGFyZ2V0IHx8XG4gICAgICAgICghdGFyZ2V0LnNlbGVjdGFibGUgJiYgIXRhcmdldC5pc0VkaXRpbmcgJiYgdGFyZ2V0ICE9PSB0aGlzLl9hY3RpdmVPYmplY3QpKSkge1xuICAgICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0ge1xuICAgICAgICAgIGV4OiB0aGlzLl9hYnNvbHV0ZVBvaW50ZXIueCxcbiAgICAgICAgICBleTogdGhpcy5fYWJzb2x1dGVQb2ludGVyLnksXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICB2YXIgYWxyZWFkeVNlbGVjdGVkID0gdGFyZ2V0ID09PSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICAgIGlmICh0YXJnZXQuc2VsZWN0YWJsZSAmJiB0YXJnZXQuYWN0aXZlT24gPT09ICdkb3duJykge1xuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KHRhcmdldCwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvcm5lciA9IHRhcmdldC5fZmluZFRhcmdldENvcm5lcihcbiAgICAgICAgICB0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSksXG4gICAgICAgICAgZmFicmljLnV0aWwuaXNUb3VjaEV2ZW50KGUpXG4gICAgICAgICk7XG4gICAgICAgIHRhcmdldC5fX2Nvcm5lciA9IGNvcm5lcjtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmIChjb3JuZXIgfHwgIXNob3VsZEdyb3VwKSkge1xuICAgICAgICAgIHRoaXMuX3NldHVwQ3VycmVudFRyYW5zZm9ybShlLCB0YXJnZXQsIGFscmVhZHlTZWxlY3RlZCk7XG4gICAgICAgICAgdmFyIGNvbnRyb2wgPSB0YXJnZXQuY29udHJvbHNbY29ybmVyXSxcbiAgICAgICAgICAgICAgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKSxcbiAgICAgICAgICAgICAgbW91c2VEb3duSGFuZGxlciA9IGNvbnRyb2wgJiYgY29udHJvbC5nZXRNb3VzZURvd25IYW5kbGVyKGUsIHRhcmdldCwgY29udHJvbCk7XG4gICAgICAgICAgaWYgKG1vdXNlRG93bkhhbmRsZXIpIHtcbiAgICAgICAgICAgIG1vdXNlRG93bkhhbmRsZXIoZSwgdGhpcy5fY3VycmVudFRyYW5zZm9ybSwgcG9pbnRlci54LCBwb2ludGVyLnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nKTtcbiAgICAgIC8vIHdlIG11c3QgcmVuZGVyQWxsIHNvIHRoYXQgd2UgdXBkYXRlIHRoZSB2aXN1YWxzXG4gICAgICAoc2hvdWxkUmVuZGVyIHx8IHNob3VsZEdyb3VwKSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVzZXQgY2FjaGUgZm9ybSBjb21tb24gaW5mb3JtYXRpb24gbmVlZGVkIGR1cmluZyBldmVudCBwcm9jZXNzaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzZXRUcmFuc2Zvcm1FdmVudERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fdGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3BvaW50ZXIgPSBudWxsO1xuICAgICAgdGhpcy5fYWJzb2x1dGVQb2ludGVyID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FjaGUgY29tbW9uIGluZm9ybWF0aW9uIG5lZWRlZCBkdXJpbmcgZXZlbnQgcHJvY2Vzc2luZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gZXZlbnRcbiAgICAgKi9cbiAgICBfY2FjaGVUcmFuc2Zvcm1FdmVudERhdGE6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIHJlc2V0IGluIG9yZGVyIHRvIGF2b2lkIHN0YWxlIGNhY2hpbmdcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICB0aGlzLl9wb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUsIHRydWUpO1xuICAgICAgdGhpcy5fYWJzb2x1dGVQb2ludGVyID0gdGhpcy5yZXN0b3JlUG9pbnRlclZwdCh0aGlzLl9wb2ludGVyKTtcbiAgICAgIHRoaXMuX3RhcmdldCA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPyB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLnRhcmdldCA6IHRoaXMuZmluZFRhcmdldChlKSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9iZWZvcmVUcmFuc2Zvcm06IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybTtcbiAgICAgIHRoaXMuc3RhdGVmdWwgJiYgdC50YXJnZXQuc2F2ZVN0YXRlKCk7XG4gICAgICB0aGlzLmZpcmUoJ2JlZm9yZTp0cmFuc2Zvcm0nLCB7XG4gICAgICAgIGU6IGUsXG4gICAgICAgIHRyYW5zZm9ybTogdCxcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZWZpbmVzIHRoZSBhY3Rpb25zIHdoZW4gbW91c2UgaXMgaG92ZXJpbmcgdGhlIGNhbnZhcy5cbiAgICAgKiBUaGUgY3VycmVudFRyYW5zZm9ybSBwYXJhbWV0ZXIgd2lsbCBkZWZpbmUgd2hldGhlciB0aGUgdXNlciBpcyByb3RhdGluZy9zY2FsaW5nL3RyYW5zbGF0aW5nXG4gICAgICogYW4gaW1hZ2Ugb3IgbmVpdGhlciBvZiB0aGVtIChvbmx5IGhvdmVyaW5nKS4gQSBncm91cCBzZWxlY3Rpb24gaXMgYWxzbyBwb3NzaWJsZSBhbmQgd291bGQgY2FuY2VsXG4gICAgICogYWxsIGFueSBvdGhlciB0eXBlIG9mIGFjdGlvbi5cbiAgICAgKiBJbiBjYXNlIG9mIGFuIGltYWdlIHRyYW5zZm9ybWF0aW9uIG9ubHkgdGhlIHRvcCBjYW52YXMgd2lsbCBiZSByZW5kZXJlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqL1xuICAgIF9fb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnbW92ZTpiZWZvcmUnKTtcbiAgICAgIHRoaXMuX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgICAgdmFyIHRhcmdldCwgcG9pbnRlcjtcblxuICAgICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSkge1xuICAgICAgICB0aGlzLl9vbk1vdXNlTW92ZUluRHJhd2luZ01vZGUoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pc01haW5FdmVudChlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBncm91cFNlbGVjdG9yID0gdGhpcy5fZ3JvdXBTZWxlY3RvcjtcblxuICAgICAgLy8gV2UgaW5pdGlhbGx5IGNsaWNrZWQgaW4gYW4gZW1wdHkgYXJlYSwgc28gd2UgZHJhdyBhIGJveCBmb3IgbXVsdGlwbGUgc2VsZWN0aW9uXG4gICAgICBpZiAoZ3JvdXBTZWxlY3Rvcikge1xuICAgICAgICBwb2ludGVyID0gdGhpcy5fYWJzb2x1dGVQb2ludGVyO1xuXG4gICAgICAgIGdyb3VwU2VsZWN0b3IubGVmdCA9IHBvaW50ZXIueCAtIGdyb3VwU2VsZWN0b3IuZXg7XG4gICAgICAgIGdyb3VwU2VsZWN0b3IudG9wID0gcG9pbnRlci55IC0gZ3JvdXBTZWxlY3Rvci5leTtcblxuICAgICAgICB0aGlzLnJlbmRlclRvcCgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIXRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5maW5kVGFyZ2V0KGUpIHx8IG51bGw7XG4gICAgICAgIHRoaXMuX3NldEN1cnNvckZyb21FdmVudChlLCB0YXJnZXQpO1xuICAgICAgICB0aGlzLl9maXJlT3Zlck91dEV2ZW50cyh0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybU9iamVjdChlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdtb3ZlJyk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2UgdGhlIG1vdXNlb3V0LCBtb3VzZW92ZXIgZXZlbnRzIGZvciB0aGUgZmFicmljIG9iamVjdCBvbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtGYWJyaWMuT2JqZWN0fSB0YXJnZXQgdGhlIHRhcmdldCB3aGVyZSB0aGUgdGFyZ2V0IGZyb20gdGhlIG1vdXNlbW92ZSBldmVudFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVPdmVyT3V0RXZlbnRzOiBmdW5jdGlvbih0YXJnZXQsIGUpIHtcbiAgICAgIHZhciBfaG92ZXJlZFRhcmdldCA9IHRoaXMuX2hvdmVyZWRUYXJnZXQsXG4gICAgICAgICAgX2hvdmVyZWRUYXJnZXRzID0gdGhpcy5faG92ZXJlZFRhcmdldHMsIHRhcmdldHMgPSB0aGlzLnRhcmdldHMsXG4gICAgICAgICAgbGVuZ3RoID0gTWF0aC5tYXgoX2hvdmVyZWRUYXJnZXRzLmxlbmd0aCwgdGFyZ2V0cy5sZW5ndGgpO1xuXG4gICAgICB0aGlzLmZpcmVTeW50aGV0aWNJbk91dEV2ZW50cyh0YXJnZXQsIGUsIHtcbiAgICAgICAgb2xkVGFyZ2V0OiBfaG92ZXJlZFRhcmdldCxcbiAgICAgICAgZXZ0T3V0OiAnbW91c2VvdXQnLFxuICAgICAgICBjYW52YXNFdnRPdXQ6ICdtb3VzZTpvdXQnLFxuICAgICAgICBldnRJbjogJ21vdXNlb3ZlcicsXG4gICAgICAgIGNhbnZhc0V2dEluOiAnbW91c2U6b3ZlcicsXG4gICAgICB9KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNJbk91dEV2ZW50cyh0YXJnZXRzW2ldLCBlLCB7XG4gICAgICAgICAgb2xkVGFyZ2V0OiBfaG92ZXJlZFRhcmdldHNbaV0sXG4gICAgICAgICAgZXZ0T3V0OiAnbW91c2VvdXQnLFxuICAgICAgICAgIGV2dEluOiAnbW91c2VvdmVyJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMgPSB0aGlzLnRhcmdldHMuY29uY2F0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZSB0aGUgZHJhZ0VudGVyLCBkcmFnTGVhdmUgZXZlbnRzIGZvciB0aGUgZmFicmljIG9iamVjdHMgb24gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7RmFicmljLk9iamVjdH0gdGFyZ2V0IHRoZSB0YXJnZXQgd2hlcmUgdGhlIHRhcmdldCBmcm9tIHRoZSBvbkRyYWcgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBvbmRyYWdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlRW50ZXJMZWF2ZUV2ZW50czogZnVuY3Rpb24odGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgX2RyYWdnZWRvdmVyVGFyZ2V0ID0gdGhpcy5fZHJhZ2dlZG92ZXJUYXJnZXQsXG4gICAgICAgICAgX2hvdmVyZWRUYXJnZXRzID0gdGhpcy5faG92ZXJlZFRhcmdldHMsIHRhcmdldHMgPSB0aGlzLnRhcmdldHMsXG4gICAgICAgICAgbGVuZ3RoID0gTWF0aC5tYXgoX2hvdmVyZWRUYXJnZXRzLmxlbmd0aCwgdGFyZ2V0cy5sZW5ndGgpO1xuXG4gICAgICB0aGlzLmZpcmVTeW50aGV0aWNJbk91dEV2ZW50cyh0YXJnZXQsIGUsIHtcbiAgICAgICAgb2xkVGFyZ2V0OiBfZHJhZ2dlZG92ZXJUYXJnZXQsXG4gICAgICAgIGV2dE91dDogJ2RyYWdsZWF2ZScsXG4gICAgICAgIGV2dEluOiAnZHJhZ2VudGVyJyxcbiAgICAgIH0pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNJbk91dEV2ZW50cyh0YXJnZXRzW2ldLCBlLCB7XG4gICAgICAgICAgb2xkVGFyZ2V0OiBfaG92ZXJlZFRhcmdldHNbaV0sXG4gICAgICAgICAgZXZ0T3V0OiAnZHJhZ2xlYXZlJyxcbiAgICAgICAgICBldnRJbjogJ2RyYWdlbnRlcicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fZHJhZ2dlZG92ZXJUYXJnZXQgPSB0YXJnZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZSB0aGUgc3ludGhldGljIGluL291dCBldmVudHMgZm9yIHRoZSBmYWJyaWMgb2JqZWN0cyBvbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtGYWJyaWMuT2JqZWN0fSB0YXJnZXQgdGhlIHRhcmdldCB3aGVyZSB0aGUgdGFyZ2V0IGZyb20gdGhlIHN1cHBvcnRlZCBldmVudHNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgY29uZmlndXJhdGlvbiBmb3IgdGhlIGZ1bmN0aW9uIHRvIHdvcmtcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnRhcmdldE5hbWUgcHJvcGVydHkgb24gdGhlIGNhbnZhcyB3aGVyZSB0aGUgb2xkIHRhcmdldCBpcyBzdG9yZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5jYW52YXNFdnRPdXRdIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgYXQgY2FudmFzIGxldmVsIGZvciBvdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmV2dE91dCBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIGZvciBvdXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5jYW52YXNFdnRJbl0gbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBhdCBjYW52YXMgbGV2ZWwgZm9yIGluXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5ldnRJbiBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIGZvciBpblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzOiBmdW5jdGlvbih0YXJnZXQsIGUsIGNvbmZpZykge1xuICAgICAgdmFyIGluT3B0LCBvdXRPcHQsIG9sZFRhcmdldCA9IGNvbmZpZy5vbGRUYXJnZXQsIG91dEZpcmVzLCBpbkZpcmVzLFxuICAgICAgICAgIHRhcmdldENoYW5nZWQgPSBvbGRUYXJnZXQgIT09IHRhcmdldCwgY2FudmFzRXZ0SW4gPSBjb25maWcuY2FudmFzRXZ0SW4sIGNhbnZhc0V2dE91dCA9IGNvbmZpZy5jYW52YXNFdnRPdXQ7XG4gICAgICBpZiAodGFyZ2V0Q2hhbmdlZCkge1xuICAgICAgICBpbk9wdCA9IHsgZTogZSwgdGFyZ2V0OiB0YXJnZXQsIHByZXZpb3VzVGFyZ2V0OiBvbGRUYXJnZXQgfTtcbiAgICAgICAgb3V0T3B0ID0geyBlOiBlLCB0YXJnZXQ6IG9sZFRhcmdldCwgbmV4dFRhcmdldDogdGFyZ2V0IH07XG4gICAgICB9XG4gICAgICBpbkZpcmVzID0gdGFyZ2V0ICYmIHRhcmdldENoYW5nZWQ7XG4gICAgICBvdXRGaXJlcyA9IG9sZFRhcmdldCAmJiB0YXJnZXRDaGFuZ2VkO1xuICAgICAgaWYgKG91dEZpcmVzKSB7XG4gICAgICAgIGNhbnZhc0V2dE91dCAmJiB0aGlzLmZpcmUoY2FudmFzRXZ0T3V0LCBvdXRPcHQpO1xuICAgICAgICBvbGRUYXJnZXQuZmlyZShjb25maWcuZXZ0T3V0LCBvdXRPcHQpO1xuICAgICAgfVxuICAgICAgaWYgKGluRmlyZXMpIHtcbiAgICAgICAgY2FudmFzRXZ0SW4gJiYgdGhpcy5maXJlKGNhbnZhc0V2dEluLCBpbk9wdCk7XG4gICAgICAgIHRhcmdldC5maXJlKGNvbmZpZy5ldnRJbiwgaW5PcHQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZWZpbmVzIGFjdGlvbnMgd2hlbiBhbiBFdmVudCBNb3VzZSBXaGVlbFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNldXBcbiAgICAgKi9cbiAgICBfX29uTW91c2VXaGVlbDogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5fY2FjaGVUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnd2hlZWwnKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfdHJhbnNmb3JtT2JqZWN0OiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKSxcbiAgICAgICAgICB0cmFuc2Zvcm0gPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtO1xuXG4gICAgICB0cmFuc2Zvcm0ucmVzZXQgPSBmYWxzZTtcbiAgICAgIHRyYW5zZm9ybS5zaGlmdEtleSA9IGUuc2hpZnRLZXk7XG4gICAgICB0cmFuc2Zvcm0uYWx0S2V5ID0gZVt0aGlzLmNlbnRlcmVkS2V5XTtcblxuICAgICAgdGhpcy5fcGVyZm9ybVRyYW5zZm9ybUFjdGlvbihlLCB0cmFuc2Zvcm0sIHBvaW50ZXIpO1xuICAgICAgdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGVyZm9ybVRyYW5zZm9ybUFjdGlvbjogZnVuY3Rpb24oZSwgdHJhbnNmb3JtLCBwb2ludGVyKSB7XG4gICAgICB2YXIgeCA9IHBvaW50ZXIueCxcbiAgICAgICAgICB5ID0gcG9pbnRlci55LFxuICAgICAgICAgIGFjdGlvbiA9IHRyYW5zZm9ybS5hY3Rpb24sXG4gICAgICAgICAgYWN0aW9uUGVyZm9ybWVkID0gZmFsc2UsXG4gICAgICAgICAgYWN0aW9uSGFuZGxlciA9IHRyYW5zZm9ybS5hY3Rpb25IYW5kbGVyO1xuICAgICAgICAgIC8vIHRoaXMgb2JqZWN0IGNvdWxkIGJlIGNyZWF0ZWQgZnJvbSB0aGUgZnVuY3Rpb24gaW4gdGhlIGNvbnRyb2wgaGFuZGxlcnNcblxuXG4gICAgICBpZiAoYWN0aW9uSGFuZGxlcikge1xuICAgICAgICBhY3Rpb25QZXJmb3JtZWQgPSBhY3Rpb25IYW5kbGVyKGUsIHRyYW5zZm9ybSwgeCwgeSk7XG4gICAgICB9XG4gICAgICBpZiAoYWN0aW9uID09PSAnZHJhZycgJiYgYWN0aW9uUGVyZm9ybWVkKSB7XG4gICAgICAgIHRyYW5zZm9ybS50YXJnZXQuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldEN1cnNvcih0cmFuc2Zvcm0udGFyZ2V0Lm1vdmVDdXJzb3IgfHwgdGhpcy5tb3ZlQ3Vyc29yKTtcbiAgICAgIH1cbiAgICAgIHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQgPSB0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkIHx8IGFjdGlvblBlcmZvcm1lZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZTogZmFicmljLmNvbnRyb2xzVXRpbHMuZmlyZUV2ZW50LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3Vyc29yIGRlcGVuZGluZyBvbiB3aGVyZSB0aGUgY2FudmFzIGlzIGJlaW5nIGhvdmVyZWQuXG4gICAgICogTm90ZTogdmVyeSBidWdneSBpbiBPcGVyYVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBPYmplY3QgdGhhdCB0aGUgbW91c2UgaXMgaG92ZXJpbmcsIGlmIHNvLlxuICAgICAqL1xuICAgIF9zZXRDdXJzb3JGcm9tRXZlbnQ6IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMuZGVmYXVsdEN1cnNvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBob3ZlckN1cnNvciA9IHRhcmdldC5ob3ZlckN1cnNvciB8fCB0aGlzLmhvdmVyQ3Vyc29yLFxuICAgICAgICAgIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCAmJiB0aGlzLl9hY3RpdmVPYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicgP1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlT2JqZWN0IDogbnVsbCxcbiAgICAgICAgICAvLyBvbmx5IHNob3cgcHJvcGVyIGNvcm5lciB3aGVuIGdyb3VwIHNlbGVjdGlvbiBpcyBub3QgYWN0aXZlXG4gICAgICAgICAgY29ybmVyID0gKCFhY3RpdmVTZWxlY3Rpb24gfHwgIWFjdGl2ZVNlbGVjdGlvbi5jb250YWlucyh0YXJnZXQpKVxuICAgICAgICAgIC8vIGhlcmUgd2UgY2FsbCBmaW5kVGFyZ2V0Q29ybmVyIGFsd2F5cyB3aXRoIHVuZGVmaW5lZCBmb3IgdGhlIHRvdWNoIHBhcmFtZXRlci5cbiAgICAgICAgICAvLyB3ZSBhc3N1bWUgdGhhdCBpZiB5b3UgYXJlIHVzaW5nIGEgY3Vyc29yIHlvdSBkbyBub3QgbmVlZCB0byBpbnRlcmFjdCB3aXRoXG4gICAgICAgICAgLy8gdGhlIGJpZ2dlciB0b3VjaCBhcmVhLlxuICAgICAgICAgICAgICAgICAgICAmJiB0YXJnZXQuX2ZpbmRUYXJnZXRDb3JuZXIodGhpcy5nZXRQb2ludGVyKGUsIHRydWUpKTtcblxuICAgICAgaWYgKCFjb3JuZXIpIHtcbiAgICAgICAgaWYgKHRhcmdldC5zdWJUYXJnZXRDaGVjayl7XG4gICAgICAgICAgLy8gaG92ZXJDdXJzb3Igc2hvdWxkIGNvbWUgZnJvbSB0b3AtbW9zdCBzdWJUYXJnZXQsXG4gICAgICAgICAgLy8gc28gd2Ugd2FsayB0aGUgYXJyYXkgYmFja3dhcmRzXG4gICAgICAgICAgdGhpcy50YXJnZXRzLmNvbmNhdCgpLnJldmVyc2UoKS5tYXAoZnVuY3Rpb24oX3RhcmdldCl7XG4gICAgICAgICAgICBob3ZlckN1cnNvciA9IF90YXJnZXQuaG92ZXJDdXJzb3IgfHwgaG92ZXJDdXJzb3I7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDdXJzb3IoaG92ZXJDdXJzb3IpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKHRoaXMuZ2V0Q29ybmVyQ3Vyc29yKGNvcm5lciwgdGFyZ2V0LCBlKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0Q29ybmVyQ3Vyc29yOiBmdW5jdGlvbihjb3JuZXIsIHRhcmdldCwgZSkge1xuICAgICAgdmFyIGNvbnRyb2wgPSB0YXJnZXQuY29udHJvbHNbY29ybmVyXTtcbiAgICAgIHJldHVybiBjb250cm9sLmN1cnNvclN0eWxlSGFuZGxlcihlLCBjb250cm9sLCB0YXJnZXQpO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgbWluID0gTWF0aC5taW4sXG4gICAgICBtYXggPSBNYXRoLm1heDtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5DYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5DYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgX3Nob3VsZEdyb3VwOiBmdW5jdGlvbihlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICByZXR1cm4gYWN0aXZlT2JqZWN0ICYmIHRoaXMuX2lzU2VsZWN0aW9uS2V5UHJlc3NlZChlKSAmJiB0YXJnZXQgJiYgdGFyZ2V0LnNlbGVjdGFibGUgJiYgdGhpcy5zZWxlY3Rpb24gJiZcbiAgICAgICAgICAgIChhY3RpdmVPYmplY3QgIT09IHRhcmdldCB8fCBhY3RpdmVPYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpICYmICF0YXJnZXQub25TZWxlY3QoeyBlOiBlIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfaGFuZGxlR3JvdXBpbmc6IGZ1bmN0aW9uIChlLCB0YXJnZXQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG4gICAgICAvLyBhdm9pZCBtdWx0aSBzZWxlY3Qgd2hlbiBzaGlmdCBjbGljayBvbiBhIGNvcm5lclxuICAgICAgaWYgKGFjdGl2ZU9iamVjdC5fX2Nvcm5lcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0ID09PSBhY3RpdmVPYmplY3QpIHtcbiAgICAgICAgLy8gaWYgaXQncyBhIGdyb3VwLCBmaW5kIHRhcmdldCBhZ2FpbiwgdXNpbmcgYWN0aXZlR3JvdXAgb2JqZWN0c1xuICAgICAgICB0YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoZSwgdHJ1ZSk7XG4gICAgICAgIC8vIGlmIGV2ZW4gb2JqZWN0IGlzIG5vdCBmb3VuZCBvciB3ZSBhcmUgb24gYWN0aXZlT2JqZWN0Q29ybmVyLCBiYWlsIG91dFxuICAgICAgICBpZiAoIXRhcmdldCB8fCAhdGFyZ2V0LnNlbGVjdGFibGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhY3RpdmVPYmplY3QgJiYgYWN0aXZlT2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZVNlbGVjdGlvbih0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUFjdGl2ZVNlbGVjdGlvbih0YXJnZXQsIGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVBY3RpdmVTZWxlY3Rpb246IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBjdXJyZW50QWN0aXZlT2JqZWN0cyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cy5zbGljZSgwKTtcbiAgICAgIGlmIChhY3RpdmVTZWxlY3Rpb24uY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICBhY3RpdmVTZWxlY3Rpb24ucmVtb3ZlV2l0aFVwZGF0ZSh0YXJnZXQpO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMudGFyZ2V0cy5jb25jYXQoKTtcbiAgICAgICAgaWYgKGFjdGl2ZVNlbGVjdGlvbi5zaXplKCkgPT09IDEpIHtcbiAgICAgICAgICAvLyBhY3RpdmF0ZSBsYXN0IHJlbWFpbmluZyBvYmplY3RcbiAgICAgICAgICB0aGlzLl9zZXRBY3RpdmVPYmplY3QoYWN0aXZlU2VsZWN0aW9uLml0ZW0oMCksIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYWN0aXZlU2VsZWN0aW9uLmFkZFdpdGhVcGRhdGUodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldCA9IGFjdGl2ZVNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMgPSB0aGlzLnRhcmdldHMuY29uY2F0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uRXZlbnRzKGN1cnJlbnRBY3RpdmVPYmplY3RzLCBlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQWN0aXZlU2VsZWN0aW9uOiBmdW5jdGlvbih0YXJnZXQsIGUpIHtcbiAgICAgIHZhciBjdXJyZW50QWN0aXZlcyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLCBncm91cCA9IHRoaXMuX2NyZWF0ZUdyb3VwKHRhcmdldCk7XG4gICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gZ3JvdXA7XG4gICAgICAvLyBJU1NVRSA0MTE1OiBzaG91bGQgd2UgY29uc2lkZXIgc3ViVGFyZ2V0cyBoZXJlP1xuICAgICAgLy8gdGhpcy5faG92ZXJlZFRhcmdldHMgPSBbXTtcbiAgICAgIC8vIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gdGhpcy50YXJnZXRzLmNvbmNhdCgpO1xuICAgICAgdGhpcy5fc2V0QWN0aXZlT2JqZWN0KGdyb3VwLCBlKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25FdmVudHMoY3VycmVudEFjdGl2ZXMsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfY3JlYXRlR3JvdXA6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuICAgICAgICAgIGlzQWN0aXZlTG93ZXIgPSBvYmplY3RzLmluZGV4T2YodGhpcy5fYWN0aXZlT2JqZWN0KSA8IG9iamVjdHMuaW5kZXhPZih0YXJnZXQpLFxuICAgICAgICAgIGdyb3VwT2JqZWN0cyA9IGlzQWN0aXZlTG93ZXJcbiAgICAgICAgICAgID8gW3RoaXMuX2FjdGl2ZU9iamVjdCwgdGFyZ2V0XVxuICAgICAgICAgICAgOiBbdGFyZ2V0LCB0aGlzLl9hY3RpdmVPYmplY3RdO1xuICAgICAgdGhpcy5fYWN0aXZlT2JqZWN0LmlzRWRpdGluZyAmJiB0aGlzLl9hY3RpdmVPYmplY3QuZXhpdEVkaXRpbmcoKTtcbiAgICAgIHJldHVybiBuZXcgZmFicmljLkFjdGl2ZVNlbGVjdGlvbihncm91cE9iamVjdHMsIHtcbiAgICAgICAgY2FudmFzOiB0aGlzXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIG1vdXNlIGV2ZW50XG4gICAgICovXG4gICAgX2dyb3VwU2VsZWN0ZWRPYmplY3RzOiBmdW5jdGlvbiAoZSkge1xuXG4gICAgICB2YXIgZ3JvdXAgPSB0aGlzLl9jb2xsZWN0T2JqZWN0cyhlKSxcbiAgICAgICAgICBhR3JvdXA7XG5cbiAgICAgIC8vIGRvIG5vdCBjcmVhdGUgZ3JvdXAgZm9yIDEgZWxlbWVudCBvbmx5XG4gICAgICBpZiAoZ3JvdXAubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KGdyb3VwWzBdLCBlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGdyb3VwLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYUdyb3VwID0gbmV3IGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24oZ3JvdXAucmV2ZXJzZSgpLCB7XG4gICAgICAgICAgY2FudmFzOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldEFjdGl2ZU9iamVjdChhR3JvdXAsIGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jb2xsZWN0T2JqZWN0czogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGdyb3VwID0gW10sXG4gICAgICAgICAgY3VycmVudE9iamVjdCxcbiAgICAgICAgICB4MSA9IHRoaXMuX2dyb3VwU2VsZWN0b3IuZXgsXG4gICAgICAgICAgeTEgPSB0aGlzLl9ncm91cFNlbGVjdG9yLmV5LFxuICAgICAgICAgIHgyID0geDEgKyB0aGlzLl9ncm91cFNlbGVjdG9yLmxlZnQsXG4gICAgICAgICAgeTIgPSB5MSArIHRoaXMuX2dyb3VwU2VsZWN0b3IudG9wLFxuICAgICAgICAgIHNlbGVjdGlvblgxWTEgPSBuZXcgZmFicmljLlBvaW50KG1pbih4MSwgeDIpLCBtaW4oeTEsIHkyKSksXG4gICAgICAgICAgc2VsZWN0aW9uWDJZMiA9IG5ldyBmYWJyaWMuUG9pbnQobWF4KHgxLCB4MiksIG1heCh5MSwgeTIpKSxcbiAgICAgICAgICBhbGxvd0ludGVyc2VjdCA9ICF0aGlzLnNlbGVjdGlvbkZ1bGx5Q29udGFpbmVkLFxuICAgICAgICAgIGlzQ2xpY2sgPSB4MSA9PT0geDIgJiYgeTEgPT09IHkyO1xuICAgICAgLy8gd2UgaXRlcmF0ZSByZXZlcnNlIG9yZGVyIHRvIGNvbGxlY3QgdG9wIGZpcnN0IGluIGNhc2Ugb2YgY2xpY2suXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIGN1cnJlbnRPYmplY3QgPSB0aGlzLl9vYmplY3RzW2ldO1xuXG4gICAgICAgIGlmICghY3VycmVudE9iamVjdCB8fCAhY3VycmVudE9iamVjdC5zZWxlY3RhYmxlIHx8ICFjdXJyZW50T2JqZWN0LnZpc2libGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoYWxsb3dJbnRlcnNlY3QgJiYgY3VycmVudE9iamVjdC5pbnRlcnNlY3RzV2l0aFJlY3Qoc2VsZWN0aW9uWDFZMSwgc2VsZWN0aW9uWDJZMiwgdHJ1ZSkpIHx8XG4gICAgICAgICAgICBjdXJyZW50T2JqZWN0LmlzQ29udGFpbmVkV2l0aGluUmVjdChzZWxlY3Rpb25YMVkxLCBzZWxlY3Rpb25YMlkyLCB0cnVlKSB8fFxuICAgICAgICAgICAgKGFsbG93SW50ZXJzZWN0ICYmIGN1cnJlbnRPYmplY3QuY29udGFpbnNQb2ludChzZWxlY3Rpb25YMVkxLCBudWxsLCB0cnVlKSkgfHxcbiAgICAgICAgICAgIChhbGxvd0ludGVyc2VjdCAmJiBjdXJyZW50T2JqZWN0LmNvbnRhaW5zUG9pbnQoc2VsZWN0aW9uWDJZMiwgbnVsbCwgdHJ1ZSkpXG4gICAgICAgICkge1xuICAgICAgICAgIGdyb3VwLnB1c2goY3VycmVudE9iamVjdCk7XG4gICAgICAgICAgLy8gb25seSBhZGQgb25lIG9iamVjdCBpZiBpdCdzIGEgY2xpY2tcbiAgICAgICAgICBpZiAoaXNDbGljaykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cC5sZW5ndGggPiAxKSB7XG4gICAgICAgIGdyb3VwID0gZ3JvdXAuZmlsdGVyKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiAhb2JqZWN0Lm9uU2VsZWN0KHsgZTogZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbWF5YmVHcm91cE9iamVjdHM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbiAmJiB0aGlzLl9ncm91cFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwU2VsZWN0ZWRPYmplY3RzKGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5kZWZhdWx0Q3Vyc29yKTtcbiAgICAgIC8vIGNsZWFyIHNlbGVjdGlvbiBhbmQgY3VycmVudCB0cmFuc2Zvcm1hdGlvblxuICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RvciA9IG51bGw7XG4gICAgfVxuICB9KTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24gKCkge1xuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgY2FudmFzIGVsZW1lbnQgdG8gYSBkYXRhdXJsIGltYWdlLiBOb3RlIHRoYXQgd2hlbiBtdWx0aXBsaWVyIGlzIHVzZWQsIGNyb3BwaW5nIGlzIHNjYWxlZCBhcHByb3ByaWF0ZWx5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5mb3JtYXQ9cG5nXSBUaGUgZm9ybWF0IG9mIHRoZSBvdXRwdXQgaW1hZ2UuIEVpdGhlciBcImpwZWdcIiBvciBcInBuZ1wiXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnF1YWxpdHk9MV0gUXVhbGl0eSBsZXZlbCAoMC4uMSkuIE9ubHkgdXNlZCBmb3IganBlZy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubXVsdGlwbGllcj0xXSBNdWx0aXBsaWVyIHRvIHNjYWxlIGJ5LCB0byBoYXZlIGNvbnNpc3RlbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVmdF0gQ3JvcHBpbmcgbGVmdCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b3BdIENyb3BwaW5nIHRvcCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gQ3JvcHBpbmcgd2lkdGguIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIENyb3BwaW5nIGhlaWdodC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nXSBFbmFibGUgcmV0aW5hIHNjYWxpbmcgZm9yIGNsb25lIGltYWdlLiBJbnRyb2R1Y2UgaW4gMi4wLjBcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFJldHVybnMgYSBkYXRhOiBVUkwgY29udGFpbmluZyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QgaW4gdGhlIGZvcm1hdCBzcGVjaWZpZWQgYnkgb3B0aW9ucy5mb3JtYXRcbiAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL05mWlZiL3xqc0ZpZGRsZSBkZW1vfVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkdlbmVyYXRlIGpwZWcgZGF0YVVSTCB3aXRoIGxvd2VyIHF1YWxpdHk8L2NhcHRpb24+XG4gICAgICogdmFyIGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKHtcbiAgICAgKiAgIGZvcm1hdDogJ2pwZWcnLFxuICAgICAqICAgcXVhbGl0eTogMC44XG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2VuZXJhdGUgY3JvcHBlZCBwbmcgZGF0YVVSTCAoY2xpcHBpbmcgb2YgY2FudmFzKTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoe1xuICAgICAqICAgZm9ybWF0OiAncG5nJyxcbiAgICAgKiAgIGxlZnQ6IDEwMCxcbiAgICAgKiAgIHRvcDogMTAwLFxuICAgICAqICAgd2lkdGg6IDIwMCxcbiAgICAgKiAgIGhlaWdodDogMjAwXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2VuZXJhdGUgZG91YmxlIHNjYWxlZCBwbmcgZGF0YVVSTDwvY2FwdGlvbj5cbiAgICAgKiB2YXIgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoe1xuICAgICAqICAgZm9ybWF0OiAncG5nJyxcbiAgICAgKiAgIG11bHRpcGxpZXI6IDJcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICB0b0RhdGFVUkw6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8ICdwbmcnLFxuICAgICAgICAgIHF1YWxpdHkgPSBvcHRpb25zLnF1YWxpdHkgfHwgMSxcbiAgICAgICAgICBtdWx0aXBsaWVyID0gKG9wdGlvbnMubXVsdGlwbGllciB8fCAxKSAqIChvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmcgPyB0aGlzLmdldFJldGluYVNjYWxpbmcoKSA6IDEpLFxuICAgICAgICAgIGNhbnZhc0VsID0gdGhpcy50b0NhbnZhc0VsZW1lbnQobXVsdGlwbGllciwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudG9EYXRhVVJMKGNhbnZhc0VsLCBmb3JtYXQsIHF1YWxpdHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgSFRNTENhbnZhcyBlbGVtZW50IHBhaW50ZWQgd2l0aCB0aGUgY3VycmVudCBjYW52YXMgY29udGVudC5cbiAgICAgKiBObyBuZWVkIHRvIHJlc2l6ZSB0aGUgYWN0dWFsIG9uZSBvciByZXBhaW50IGl0LlxuICAgICAqIFdpbGwgdHJhbnNmZXIgb2JqZWN0IG93bmVyc2hpcCB0byBhIG5ldyBjYW52YXMsIHBhaW50IGl0LCBhbmQgc2V0IGV2ZXJ5dGhpbmcgYmFjay5cbiAgICAgKiBUaGlzIGlzIGFuIGludGVybWVkaWFyeSBzdGVwIHVzZWQgdG8gZ2V0IHRvIGEgZGF0YVVybCBidXQgYWxzbyBpdCBpcyB1c2VmdWwgdG9cbiAgICAgKiBjcmVhdGUgcXVpY2sgaW1hZ2UgY29waWVzIG9mIGEgY2FudmFzIHdpdGhvdXQgcGFzc2luZyBmb3IgdGhlIGRhdGFVcmwgc3RyaW5nXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFttdWx0aXBsaWVyXSBhIHpvb20gZmFjdG9yLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3JvcHBpbmddIENyb3BwaW5nIGluZm9ybWF0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY3JvcHBpbmcubGVmdF0gQ3JvcHBpbmcgbGVmdCBvZmZzZXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjcm9wcGluZy50b3BdIENyb3BwaW5nIHRvcCBvZmZzZXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjcm9wcGluZy53aWR0aF0gQ3JvcHBpbmcgd2lkdGguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjcm9wcGluZy5oZWlnaHRdIENyb3BwaW5nIGhlaWdodC5cbiAgICAgKi9cbiAgICB0b0NhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKG11bHRpcGxpZXIsIGNyb3BwaW5nKSB7XG4gICAgICBtdWx0aXBsaWVyID0gbXVsdGlwbGllciB8fCAxO1xuICAgICAgY3JvcHBpbmcgPSBjcm9wcGluZyB8fCB7IH07XG4gICAgICB2YXIgc2NhbGVkV2lkdGggPSAoY3JvcHBpbmcud2lkdGggfHwgdGhpcy53aWR0aCkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHNjYWxlZEhlaWdodCA9IChjcm9wcGluZy5oZWlnaHQgfHwgdGhpcy5oZWlnaHQpICogbXVsdGlwbGllcixcbiAgICAgICAgICB6b29tID0gdGhpcy5nZXRab29tKCksXG4gICAgICAgICAgb3JpZ2luYWxXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgb3JpZ2luYWxIZWlnaHQgPSB0aGlzLmhlaWdodCxcbiAgICAgICAgICBuZXdab29tID0gem9vbSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgdnAgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLFxuICAgICAgICAgIHRyYW5zbGF0ZVggPSAodnBbNF0gLSAoY3JvcHBpbmcubGVmdCB8fCAwKSkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHRyYW5zbGF0ZVkgPSAodnBbNV0gLSAoY3JvcHBpbmcudG9wIHx8IDApKSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgb3JpZ2luYWxJbnRlcmFjdGl2ZSA9IHRoaXMuaW50ZXJhY3RpdmUsXG4gICAgICAgICAgbmV3VnAgPSBbbmV3Wm9vbSwgMCwgMCwgbmV3Wm9vbSwgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWV0sXG4gICAgICAgICAgb3JpZ2luYWxSZXRpbmEgPSB0aGlzLmVuYWJsZVJldGluYVNjYWxpbmcsXG4gICAgICAgICAgY2FudmFzRWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksXG4gICAgICAgICAgb3JpZ2luYWxDb250ZXh0VG9wID0gdGhpcy5jb250ZXh0VG9wO1xuICAgICAgY2FudmFzRWwud2lkdGggPSBzY2FsZWRXaWR0aDtcbiAgICAgIGNhbnZhc0VsLmhlaWdodCA9IHNjYWxlZEhlaWdodDtcbiAgICAgIHRoaXMuY29udGV4dFRvcCA9IG51bGw7XG4gICAgICB0aGlzLmVuYWJsZVJldGluYVNjYWxpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuaW50ZXJhY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSBuZXdWcDtcbiAgICAgIHRoaXMud2lkdGggPSBzY2FsZWRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gc2NhbGVkSGVpZ2h0O1xuICAgICAgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyhjYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpLCB0aGlzLl9vYmplY3RzKTtcbiAgICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSB2cDtcbiAgICAgIHRoaXMud2lkdGggPSBvcmlnaW5hbFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBvcmlnaW5hbEhlaWdodDtcbiAgICAgIHRoaXMuY2FsY1ZpZXdwb3J0Qm91bmRhcmllcygpO1xuICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IG9yaWdpbmFsSW50ZXJhY3RpdmU7XG4gICAgICB0aGlzLmVuYWJsZVJldGluYVNjYWxpbmcgPSBvcmlnaW5hbFJldGluYTtcbiAgICAgIHRoaXMuY29udGV4dFRvcCA9IG9yaWdpbmFsQ29udGV4dFRvcDtcbiAgICAgIHJldHVybiBjYW52YXNFbDtcbiAgICB9LFxuICB9KTtcblxufSkoKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlICovIHtcbiAgLyoqXG4gICAqIFBvcHVsYXRlcyBjYW52YXMgd2l0aCBkYXRhIGZyb20gdGhlIHNwZWNpZmllZCBKU09OLlxuICAgKiBKU09OIGZvcm1hdCBtdXN0IGNvbmZvcm0gdG8gdGhlIG9uZSBvZiB7QGxpbmsgZmFicmljLkNhbnZhcyN0b0pTT059XG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ganNvbiBKU09OIHN0cmluZyBvciBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2ssIGludm9rZWQgd2hlbiBqc29uIGlzIHBhcnNlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgY29ycmVzcG9uZGluZyBvYmplY3RzIChlLmc6IHtAbGluayBmYWJyaWMuSW1hZ2V9KVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgaW5pdGlhbGl6ZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIEpTT04gZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY3JlYXRlZC5cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICogQGNoYWluYWJsZVxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNkZXNlcmlhbGl6YXRpb259XG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvZm1nWHQvfGpzRmlkZGxlIGRlbW99XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPmxvYWRGcm9tSlNPTjwvY2FwdGlvbj5cbiAgICogY2FudmFzLmxvYWRGcm9tSlNPTihqc29uLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPmxvYWRGcm9tSlNPTiB3aXRoIHJldml2ZXI8L2NhcHRpb24+XG4gICAqIGNhbnZhcy5sb2FkRnJvbUpTT04oanNvbiwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIGZ1bmN0aW9uKG8sIG9iamVjdCkge1xuICAgKiAgIC8vIGBvYCA9IGpzb24gb2JqZWN0XG4gICAqICAgLy8gYG9iamVjdGAgPSBmYWJyaWMuT2JqZWN0IGluc3RhbmNlXG4gICAqICAgLy8gLi4uIGRvIHNvbWUgc3R1ZmYgLi4uXG4gICAqIH0pO1xuICAgKi9cbiAgbG9hZEZyb21KU09OOiBmdW5jdGlvbiAoanNvbiwgY2FsbGJhY2ssIHJldml2ZXIpIHtcbiAgICBpZiAoIWpzb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXJpYWxpemUgaWYgaXQgd2Fzbid0IGFscmVhZHlcbiAgICB2YXIgc2VyaWFsaXplZCA9ICh0eXBlb2YganNvbiA9PT0gJ3N0cmluZycpXG4gICAgICA/IEpTT04ucGFyc2UoanNvbilcbiAgICAgIDogZmFicmljLnV0aWwub2JqZWN0LmNsb25lKGpzb24pO1xuXG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgY2xpcFBhdGggPSBzZXJpYWxpemVkLmNsaXBQYXRoLFxuICAgICAgICByZW5kZXJPbkFkZFJlbW92ZSA9IHRoaXMucmVuZGVyT25BZGRSZW1vdmU7XG5cbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlID0gZmFsc2U7XG5cbiAgICBkZWxldGUgc2VyaWFsaXplZC5jbGlwUGF0aDtcblxuICAgIHRoaXMuX2VubGl2ZW5PYmplY3RzKHNlcmlhbGl6ZWQub2JqZWN0cywgZnVuY3Rpb24gKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIF90aGlzLmNsZWFyKCk7XG4gICAgICBfdGhpcy5fc2V0QmdPdmVybGF5KHNlcmlhbGl6ZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgICAgX3RoaXMuX2VubGl2ZW5PYmplY3RzKFtjbGlwUGF0aF0sIGZ1bmN0aW9uIChlbmxpdmVuZWRDYW52YXNDbGlwKSB7XG4gICAgICAgICAgICBfdGhpcy5jbGlwUGF0aCA9IGVubGl2ZW5lZENhbnZhc0NsaXBbMF07XG4gICAgICAgICAgICBfdGhpcy5fX3NldHVwQ2FudmFzLmNhbGwoX3RoaXMsIHNlcmlhbGl6ZWQsIGVubGl2ZW5lZE9iamVjdHMsIHJlbmRlck9uQWRkUmVtb3ZlLCBjYWxsYmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgX3RoaXMuX19zZXR1cENhbnZhcy5jYWxsKF90aGlzLCBzZXJpYWxpemVkLCBlbmxpdmVuZWRPYmplY3RzLCByZW5kZXJPbkFkZFJlbW92ZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCByZXZpdmVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlcmlhbGl6ZWQgT2JqZWN0IHdpdGggYmFja2dyb3VuZCBhbmQgb3ZlcmxheSBpbmZvcm1hdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fSByZXN0b3JlZCBjYW52YXMgb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWNoZWQgcmVuZGVyT25BZGRSZW1vdmUgY2FsbGJhY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgSW52b2tlZCBhZnRlciBhbGwgYmFja2dyb3VuZCBhbmQgb3ZlcmxheSBpbWFnZXMvcGF0dGVybnMgbG9hZGVkXG4gICAqL1xuICBfX3NldHVwQ2FudmFzOiBmdW5jdGlvbihzZXJpYWxpemVkLCBlbmxpdmVuZWRPYmplY3RzLCByZW5kZXJPbkFkZFJlbW92ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGVubGl2ZW5lZE9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmosIGluZGV4KSB7XG4gICAgICAvLyB3ZSBzcGxpY2UgdGhlIGFycmF5IGp1c3QgaW4gY2FzZSBzb21lIGN1c3RvbSBjbGFzc2VzIHJlc3RvcmVkIGZyb20gSlNPTlxuICAgICAgLy8gd2lsbCBhZGQgbW9yZSBvYmplY3QgdG8gY2FudmFzIGF0IGNhbnZhcyBpbml0LlxuICAgICAgX3RoaXMuaW5zZXJ0QXQob2JqLCBpbmRleCk7XG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSA9IHJlbmRlck9uQWRkUmVtb3ZlO1xuICAgIC8vIHJlbW92ZSBwYXJ0cyBpIGNhbm5vdCBzZXQgYXMgb3B0aW9uc1xuICAgIGRlbGV0ZSBzZXJpYWxpemVkLm9iamVjdHM7XG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQuYmFja2dyb3VuZEltYWdlO1xuICAgIGRlbGV0ZSBzZXJpYWxpemVkLm92ZXJsYXlJbWFnZTtcbiAgICBkZWxldGUgc2VyaWFsaXplZC5iYWNrZ3JvdW5kO1xuICAgIGRlbGV0ZSBzZXJpYWxpemVkLm92ZXJsYXk7XG4gICAgLy8gdGhpcy5faW5pdE9wdGlvbnMgZG9lcyB0b28gbWFueSB0aGluZ3MgdG8ganVzdFxuICAgIC8vIGNhbGwgaXQuIE5vcm1hbGx5IGxvYWRpbmcgYW4gT2JqZWN0IGZyb20gSlNPTlxuICAgIC8vIGNyZWF0ZSB0aGUgT2JqZWN0IGluc3RhbmNlLiBIZXJlIHRoZSBDYW52YXMgaXNcbiAgICAvLyBhbHJlYWR5IGFuIGluc3RhbmNlIGFuZCB3ZSBhcmUganVzdCBsb2FkaW5nIHRoaW5ncyBvdmVyIGl0XG4gICAgdGhpcy5fc2V0T3B0aW9ucyhzZXJpYWxpemVkKTtcbiAgICB0aGlzLnJlbmRlckFsbCgpO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpYWxpemVkIE9iamVjdCB3aXRoIGJhY2tncm91bmQgYW5kIG92ZXJsYXkgaW5mb3JtYXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgSW52b2tlZCBhZnRlciBhbGwgYmFja2dyb3VuZCBhbmQgb3ZlcmxheSBpbWFnZXMvcGF0dGVybnMgbG9hZGVkXG4gICAqL1xuICBfc2V0QmdPdmVybGF5OiBmdW5jdGlvbihzZXJpYWxpemVkLCBjYWxsYmFjaykge1xuICAgIHZhciBsb2FkZWQgPSB7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGZhbHNlLFxuICAgICAgb3ZlcmxheUNvbG9yOiBmYWxzZSxcbiAgICAgIGJhY2tncm91bmRJbWFnZTogZmFsc2UsXG4gICAgICBvdmVybGF5SW1hZ2U6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICghc2VyaWFsaXplZC5iYWNrZ3JvdW5kSW1hZ2UgJiYgIXNlcmlhbGl6ZWQub3ZlcmxheUltYWdlICYmICFzZXJpYWxpemVkLmJhY2tncm91bmQgJiYgIXNlcmlhbGl6ZWQub3ZlcmxheSkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2JJZkxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChsb2FkZWQuYmFja2dyb3VuZEltYWdlICYmIGxvYWRlZC5vdmVybGF5SW1hZ2UgJiYgbG9hZGVkLmJhY2tncm91bmRDb2xvciAmJiBsb2FkZWQub3ZlcmxheUNvbG9yKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ2JhY2tncm91bmRJbWFnZScsIHNlcmlhbGl6ZWQuYmFja2dyb3VuZEltYWdlLCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ292ZXJsYXlJbWFnZScsIHNlcmlhbGl6ZWQub3ZlcmxheUltYWdlLCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ2JhY2tncm91bmRDb2xvcicsIHNlcmlhbGl6ZWQuYmFja2dyb3VuZCwgbG9hZGVkLCBjYklmTG9hZGVkKTtcbiAgICB0aGlzLl9fc2V0QmdPdmVybGF5KCdvdmVybGF5Q29sb3InLCBzZXJpYWxpemVkLm92ZXJsYXksIGxvYWRlZCwgY2JJZkxvYWRlZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBzZXQgKGJhY2tncm91bmRJbWFnZSwgb3ZlcmxheUltYWdlLCBiYWNrZ3JvdW5kQ29sb3IsIG92ZXJsYXlDb2xvcilcbiAgICogQHBhcmFtIHsoT2JqZWN0fFN0cmluZyl9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgKiBAcGFyYW0ge09iamVjdH0gbG9hZGVkIFNldCBsb2FkZWQgcHJvcGVydHkgdG8gdHJ1ZSBpZiBwcm9wZXJ0eSBpcyBzZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZSBhZnRlciBwcm9wZXJ0eSBpcyBzZXRcbiAgICovXG4gIF9fc2V0QmdPdmVybGF5OiBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUsIGxvYWRlZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2JhY2tncm91bmRJbWFnZScgfHwgcHJvcGVydHkgPT09ICdvdmVybGF5SW1hZ2UnKSB7XG4gICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhbdmFsdWVdLCBmdW5jdGlvbihlbmxpdmVkT2JqZWN0KXtcbiAgICAgICAgX3RoaXNbcHJvcGVydHldID0gZW5saXZlZE9iamVjdFswXTtcbiAgICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzWydzZXQnICsgZmFicmljLnV0aWwuc3RyaW5nLmNhcGl0YWxpemUocHJvcGVydHksIHRydWUpXSh2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGxvYWRlZFtwcm9wZXJ0eV0gPSB0cnVlO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBvYmplY3RzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXVxuICAgKi9cbiAgX2VubGl2ZW5PYmplY3RzOiBmdW5jdGlvbiAob2JqZWN0cywgY2FsbGJhY2ssIHJldml2ZXIpIHtcbiAgICBpZiAoIW9iamVjdHMgfHwgb2JqZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKFtdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhvYmplY3RzLCBmdW5jdGlvbihlbmxpdmVuZWRPYmplY3RzKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICB9LCBudWxsLCByZXZpdmVyKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgX3RvRGF0YVVSTDogZnVuY3Rpb24gKGZvcm1hdCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmNsb25lKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgY2FsbGJhY2soY2xvbmUudG9EYXRhVVJMKGZvcm1hdCkpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtdWx0aXBsaWVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBfdG9EYXRhVVJMV2l0aE11bHRpcGxpZXI6IGZ1bmN0aW9uIChmb3JtYXQsIG11bHRpcGxpZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jbG9uZShmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgIGNhbGxiYWNrKGNsb25lLnRvRGF0YVVSTFdpdGhNdWx0aXBsaWVyKGZvcm1hdCwgbXVsdGlwbGllcikpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZXMgY2FudmFzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tdIFJlY2VpdmVzIGNsb25lZCBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzXSBBcnJheSBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgaW4gdGhlIGNsb25lZCBjYW52YXMgYW5kIGNoaWxkcmVuXG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKGNhbGxiYWNrLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTihwcm9wZXJ0aWVzKSk7XG4gICAgdGhpcy5jbG9uZVdpdGhvdXREYXRhKGZ1bmN0aW9uKGNsb25lKSB7XG4gICAgICBjbG9uZS5sb2FkRnJvbUpTT04oZGF0YSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZXMgY2FudmFzIGluc3RhbmNlIHdpdGhvdXQgY2xvbmluZyBleGlzdGluZyBkYXRhLlxuICAgKiBUaGlzIGVzc2VudGlhbGx5IGNvcGllcyBjYW52YXMgZGltZW5zaW9ucywgY2xpcHBpbmcgcHJvcGVydGllcywgZXRjLlxuICAgKiBidXQgbGVhdmVzIGRhdGEgZW1wdHkgKHNvIHRoYXQgeW91IGNhbiBwb3B1bGF0ZSBpdCB3aXRoIHlvdXIgb3duKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrXSBSZWNlaXZlcyBjbG9uZWQgaW5zdGFuY2UgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgY2xvbmVXaXRob3V0RGF0YTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgZWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG5cbiAgICBlbC53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgZWwuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG5cbiAgICB2YXIgY2xvbmUgPSBuZXcgZmFicmljLkNhbnZhcyhlbCk7XG4gICAgaWYgKHRoaXMuYmFja2dyb3VuZEltYWdlKSB7XG4gICAgICBjbG9uZS5zZXRCYWNrZ3JvdW5kSW1hZ2UodGhpcy5iYWNrZ3JvdW5kSW1hZ2Uuc3JjLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xvbmUucmVuZGVyQWxsKCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGNsb25lKTtcbiAgICAgIH0pO1xuICAgICAgY2xvbmUuYmFja2dyb3VuZEltYWdlT3BhY2l0eSA9IHRoaXMuYmFja2dyb3VuZEltYWdlT3BhY2l0eTtcbiAgICAgIGNsb25lLmJhY2tncm91bmRJbWFnZVN0cmV0Y2ggPSB0aGlzLmJhY2tncm91bmRJbWFnZVN0cmV0Y2g7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soY2xvbmUpO1xuICAgIH1cbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIGNhcGl0YWxpemUgPSBmYWJyaWMudXRpbC5zdHJpbmcuY2FwaXRhbGl6ZSxcbiAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgb2JqZWN0Q2FjaGluZyA9ICFmYWJyaWMuaXNMaWtlbHlOb2RlLFxuICAgICAgQUxJQVNJTkdfTElNSVQgPSAyO1xuXG4gIGlmIChmYWJyaWMuT2JqZWN0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvb3Qgb2JqZWN0IGNsYXNzIGZyb20gd2hpY2ggYWxsIDJkIHNoYXBlIGNsYXNzZXMgaW5oZXJpdCBmcm9tXG4gICAqIEBjbGFzcyBmYWJyaWMuT2JqZWN0XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI29iamVjdHN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5PYmplY3QjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICpcbiAgICogQGZpcmVzIGFkZGVkXG4gICAqIEBmaXJlcyByZW1vdmVkXG4gICAqXG4gICAqIEBmaXJlcyBzZWxlY3RlZFxuICAgKiBAZmlyZXMgZGVzZWxlY3RlZFxuICAgKiBAZmlyZXMgbW9kaWZpZWRcbiAgICogQGZpcmVzIG1vZGlmaWVkXG4gICAqIEBmaXJlcyBtb3ZlZFxuICAgKiBAZmlyZXMgc2NhbGVkXG4gICAqIEBmaXJlcyByb3RhdGVkXG4gICAqIEBmaXJlcyBza2V3ZWRcbiAgICpcbiAgICogQGZpcmVzIHJvdGF0aW5nXG4gICAqIEBmaXJlcyBzY2FsaW5nXG4gICAqIEBmaXJlcyBtb3ZpbmdcbiAgICogQGZpcmVzIHNrZXdpbmdcbiAgICpcbiAgICogQGZpcmVzIG1vdXNlZG93blxuICAgKiBAZmlyZXMgbW91c2V1cFxuICAgKiBAZmlyZXMgbW91c2VvdmVyXG4gICAqIEBmaXJlcyBtb3VzZW91dFxuICAgKiBAZmlyZXMgbW91c2V3aGVlbFxuICAgKiBAZmlyZXMgbW91c2VkYmxjbGlja1xuICAgKlxuICAgKiBAZmlyZXMgZHJhZ292ZXJcbiAgICogQGZpcmVzIGRyYWdlbnRlclxuICAgKiBAZmlyZXMgZHJhZ2xlYXZlXG4gICAqIEBmaXJlcyBkcm9wXG4gICAqL1xuICBmYWJyaWMuT2JqZWN0ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkNvbW1vbk1ldGhvZHMsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3QgKHJlY3QsIGNpcmNsZSwgcGF0aCwgZXRjLikuXG4gICAgICogTm90ZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgbWVhbnQgdG8gYmUgcmVhZC1vbmx5IGFuZCBub3QgbWVhbnQgdG8gYmUgbW9kaWZpZWQuXG4gICAgICogSWYgeW91IG1vZGlmeSwgY2VydGFpbiBwYXJ0cyBvZiBGYWJyaWMgKHN1Y2ggYXMgSlNPTiBsb2FkaW5nKSB3b24ndCB3b3JrIGNvcnJlY3RseS5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICAgICAgICAgICAgICAgICAgICAgJ29iamVjdCcsXG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvbiBvZiBhbiBvYmplY3QgKG9uZSBvZiBcImxlZnRcIiwgXCJyaWdodFwiLCBcImNlbnRlclwiKVxuICAgICAqIFNlZSBodHRwOi8vanNmaWRkbGUubmV0LzFvdzAyZ2VhLzI0NC8gb24gaG93IG9yaWdpblgvb3JpZ2luWSBhZmZlY3Qgb2JqZWN0cyBpbiBncm91cHNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9yaWdpblg6ICAgICAgICAgICAgICAgICAgJ2xlZnQnLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uIG9mIGFuIG9iamVjdCAob25lIG9mIFwidG9wXCIsIFwiYm90dG9tXCIsIFwiY2VudGVyXCIpXG4gICAgICogU2VlIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvMW93MDJnZWEvMjQ0LyBvbiBob3cgb3JpZ2luWC9vcmlnaW5ZIGFmZmVjdCBvYmplY3RzIGluIGdyb3Vwc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3JpZ2luWTogICAgICAgICAgICAgICAgICAndG9wJyxcblxuICAgIC8qKlxuICAgICAqIFRvcCBwb3NpdGlvbiBvZiBhbiBvYmplY3QuIE5vdGUgdGhhdCBieSBkZWZhdWx0IGl0J3MgcmVsYXRpdmUgdG8gb2JqZWN0IHRvcC4gWW91IGNhbiBjaGFuZ2UgdGhpcyBieSBzZXR0aW5nIG9yaWdpblk9e3RvcC9jZW50ZXIvYm90dG9tfVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdG9wOiAgICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogTGVmdCBwb3NpdGlvbiBvZiBhbiBvYmplY3QuIE5vdGUgdGhhdCBieSBkZWZhdWx0IGl0J3MgcmVsYXRpdmUgdG8gb2JqZWN0IGxlZnQuIFlvdSBjYW4gY2hhbmdlIHRoaXMgYnkgc2V0dGluZyBvcmlnaW5YPXtsZWZ0L2NlbnRlci9yaWdodH1cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxlZnQ6ICAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCB3aWR0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgd2lkdGg6ICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGVpZ2h0OiAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHNjYWxlIGZhY3RvciAoaG9yaXpvbnRhbClcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNjYWxlWDogICAgICAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBzY2FsZSBmYWN0b3IgKHZlcnRpY2FsKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVZOiAgICAgICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBhbiBvYmplY3QgaXMgcmVuZGVyZWQgYXMgZmxpcHBlZCBob3Jpem9udGFsbHlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmbGlwWDogICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBhbiBvYmplY3QgaXMgcmVuZGVyZWQgYXMgZmxpcHBlZCB2ZXJ0aWNhbGx5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmxpcFk6ICAgICAgICAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIE9wYWNpdHkgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvcGFjaXR5OiAgICAgICAgICAgICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBBbmdsZSBvZiByb3RhdGlvbiBvZiBhbiBvYmplY3QgKGluIGRlZ3JlZXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbmdsZTogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBBbmdsZSBvZiBza2V3IG9uIHggYXhlcyBvZiBhbiBvYmplY3QgKGluIGRlZ3JlZXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBza2V3WDogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBBbmdsZSBvZiBza2V3IG9uIHkgYXhlcyBvZiBhbiBvYmplY3QgKGluIGRlZ3JlZXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBza2V3WTogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBTaXplIG9mIG9iamVjdCdzIGNvbnRyb2xsaW5nIGNvcm5lcnMgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvcm5lclNpemU6ICAgICAgICAgICAgICAgMTMsXG5cbiAgICAvKipcbiAgICAgKiBTaXplIG9mIG9iamVjdCdzIGNvbnRyb2xsaW5nIGNvcm5lcnMgd2hlbiB0b3VjaCBpbnRlcmFjdGlvbiBpcyBkZXRlY3RlZFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdG91Y2hDb3JuZXJTaXplOiAgICAgICAgICAgICAgIDI0LFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBvYmplY3QncyBjb250cm9sbGluZyBjb3JuZXJzIGFyZSByZW5kZXJlZCBhcyB0cmFuc3BhcmVudCBpbnNpZGUgKGkuZS4gc3Ryb2tlIGluc3RlYWQgb2YgZmlsbClcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0cmFuc3BhcmVudENvcm5lcnM6ICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIHdoZW4gaG92ZXJpbmcgb3ZlciB0aGlzIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhvdmVyQ3Vyc29yOiAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBtb3ZpbmcgdGhpcyBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtb3ZlQ3Vyc29yOiAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBQYWRkaW5nIGJldHdlZW4gb2JqZWN0IGFuZCBpdHMgY29udHJvbGxpbmcgYm9yZGVycyAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGFkZGluZzogICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgY29udHJvbGxpbmcgYm9yZGVycyBvZiBhbiBvYmplY3QgKHdoZW4gaXQncyBhY3RpdmUpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBib3JkZXJDb2xvcjogICAgICAgICAgICAgICdyZ2IoMTc4LDIwNCwyNTUpJyxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IHNwZWNpZnlpbmcgZGFzaCBwYXR0ZXJuIG9mIGFuIG9iamVjdCdzIGJvcmRlcnMgKGhhc0JvcmRlciBtdXN0IGJlIHRydWUpXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBib3JkZXJEYXNoQXJyYXk6ICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBjb250cm9sbGluZyBjb3JuZXJzIG9mIGFuIG9iamVjdCAod2hlbiBpdCdzIGFjdGl2ZSlcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvcm5lckNvbG9yOiAgICAgICAgICAgICAgJ3JnYigxNzgsMjA0LDI1NSknLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgY29udHJvbGxpbmcgY29ybmVycyBvZiBhbiBvYmplY3QgKHdoZW4gaXQncyBhY3RpdmUgYW5kIHRyYW5zcGFyZW50Q29ybmVycyBmYWxzZSlcbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvcm5lclN0cm9rZUNvbG9yOiAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgc3R5bGUgb2YgY29udHJvbCwgJ3JlY3QnIG9yICdjaXJjbGUnXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICovXG4gICAgY29ybmVyU3R5bGU6ICAgICAgICAgICdyZWN0JyxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IHNwZWNpZnlpbmcgZGFzaCBwYXR0ZXJuIG9mIGFuIG9iamVjdCdzIGNvbnRyb2wgKGhhc0JvcmRlciBtdXN0IGJlIHRydWUpXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjb3JuZXJEYXNoQXJyYXk6ICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoaXMgb2JqZWN0IHdpbGwgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uXG4gICAgICogd2hlbiBiZWluZyBzY2FsZWQgdmlhIHRoZSBjb250cm9scy5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkU2NhbGluZzogICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHRoaXMgb2JqZWN0IHdpbGwgdXNlIGNlbnRlciBwb2ludCBhcyB0aGUgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uXG4gICAgICogd2hlbiBiZWluZyByb3RhdGVkIHZpYSB0aGUgY29udHJvbHMuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcImNlbnRlclRyYW5zZm9ybVwiIChCb29sZWFuKS5cbiAgICAgKiBAc2luY2UgMS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZFJvdGF0aW9uOiAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBvYmplY3QncyBmaWxsXG4gICAgICogdGFrZXMgY3NzIGNvbG9ycyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTMvXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaWxsOiAgICAgICAgICAgICAgICAgICAgICdyZ2IoMCwwLDApJyxcblxuICAgIC8qKlxuICAgICAqIEZpbGwgcnVsZSB1c2VkIHRvIGZpbGwgYW4gb2JqZWN0XG4gICAgICogYWNjZXB0ZWQgdmFsdWVzIGFyZSBub256ZXJvLCBldmVub2RkXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSB3YXMgdXNlZCBmb3Igc2V0dGluZyBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gdW50aWwgdjEuNC4xMiAodXNlIGBmYWJyaWMuT2JqZWN0I2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbmAgaW5zdGVhZClcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZpbGxSdWxlOiAgICAgICAgICAgICAgICAgJ25vbnplcm8nLFxuXG4gICAgLyoqXG4gICAgICogQ29tcG9zaXRlIHJ1bGUgdXNlZCBmb3IgY2FudmFzIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uOiAnc291cmNlLW92ZXInLFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBvZiBhbiBvYmplY3QuXG4gICAgICogdGFrZXMgY3NzIGNvbG9ycyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTMvXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgICcnLFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0aW9uIEJhY2tncm91bmQgY29sb3Igb2YgYW4gb2JqZWN0LiBjb2xvcmVkIGxheWVyIGJlaGluZCB0aGUgb2JqZWN0IHdoZW4gaXQgaXMgYWN0aXZlLlxuICAgICAqIGRvZXMgbm90IG1peCBnb29kIHdpdGggZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIG1ldGhvZHMuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3I6ICAgICAgICAgICcnLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkZWZpbmVkLCBhbiBvYmplY3QgaXMgcmVuZGVyZWQgdmlhIHN0cm9rZSBhbmQgdGhpcyBwcm9wZXJ0eSBzcGVjaWZpZXMgaXRzIGNvbG9yXG4gICAgICogdGFrZXMgY3NzIGNvbG9ycyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWNvbG9yLTMvXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2U6ICAgICAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIHN0cm9rZSB1c2VkIHRvIHJlbmRlciB0aGlzIG9iamVjdFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlV2lkdGg6ICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgc3BlY2lmeWluZyBkYXNoIHBhdHRlcm4gb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlIChzdHJva2UgbXVzdCBiZSBkZWZpbmVkKVxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3Ryb2tlRGFzaEFycmF5OiAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogTGluZSBvZmZzZXQgb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VEYXNoT2Zmc2V0OiAwLFxuXG4gICAgLyoqXG4gICAgICogTGluZSBlbmRpbmdzIHN0eWxlIG9mIGFuIG9iamVjdCdzIHN0cm9rZSAob25lIG9mIFwiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCIpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VMaW5lQ2FwOiAgICAgICAgICAgICdidXR0JyxcblxuICAgIC8qKlxuICAgICAqIENvcm5lciBzdHlsZSBvZiBhbiBvYmplY3QncyBzdHJva2UgKG9uZSBvZiBcImJldmVsXCIsIFwicm91bmRcIiwgXCJtaXRlclwiKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlTGluZUpvaW46ICAgICAgICAgICAnbWl0ZXInLFxuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBtaXRlciBsZW5ndGggKHVzZWQgZm9yIHN0cm9rZUxpbmVKb2luID0gXCJtaXRlclwiKSBvZiBhbiBvYmplY3QncyBzdHJva2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZU1pdGVyTGltaXQ6ICAgICAgICAgNCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBvYmplY3QgcmVwcmVzZW50aW5nIHNoYWRvdyBvZiB0aGlzIHNoYXBlXG4gICAgICogQHR5cGUgZmFicmljLlNoYWRvd1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2hhZG93OiAgICAgICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogT3BhY2l0eSBvZiBvYmplY3QncyBjb250cm9sbGluZyBib3JkZXJzIHdoZW4gb2JqZWN0IGlzIGFjdGl2ZSBhbmQgbW92aW5nXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBib3JkZXJPcGFjaXR5V2hlbk1vdmluZzogIDAuNCxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIGZhY3RvciBvZiBvYmplY3QncyBjb250cm9sbGluZyBib3JkZXJzXG4gICAgICogYmlnZ2VyIG51bWJlciB3aWxsIG1ha2UgYSB0aGlja2VyIGJvcmRlclxuICAgICAqIGJvcmRlciBpcyAxLCBzbyB0aGlzIGlzIGJhc2ljYWxseSBhIGJvcmRlciB0aGlja25lc3NcbiAgICAgKiBzaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gY2hhbmdlIHRoZSBib3JkZXIgaXRzZWxmLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYm9yZGVyU2NhbGVGYWN0b3I6ICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBhbGxvd2VkIHNjYWxlIHZhbHVlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWluU2NhbGVMaW1pdDogICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgYW4gb2JqZWN0IGNhbiBub3QgYmUgc2VsZWN0ZWQgZm9yIG1vZGlmaWNhdGlvbiAodXNpbmcgZWl0aGVyIHBvaW50LWNsaWNrLWJhc2VkIG9yIGdyb3VwLWJhc2VkIHNlbGVjdGlvbikuXG4gICAgICogQnV0IGV2ZW50cyBzdGlsbCBmaXJlIG9uIGl0LlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGFibGU6ICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIGFuIG9iamVjdCBjYW4gbm90IGJlIGEgdGFyZ2V0IG9mIGV2ZW50cy4gQWxsIGV2ZW50cyBwcm9wYWdhdGUgdGhyb3VnaCBpdC4gSW50cm9kdWNlZCBpbiB2MS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBldmVudGVkOiAgICAgICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBhbiBvYmplY3QgaXMgbm90IHJlbmRlcmVkIG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHZpc2libGU6ICAgICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIG9iamVjdCdzIGNvbnRyb2xzIGFyZSBub3QgZGlzcGxheWVkIGFuZCBjYW4gbm90IGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBvYmplY3RcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBoYXNDb250cm9sczogICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBvYmplY3QncyBjb250cm9sbGluZyBib3JkZXJzIGFyZSBub3QgcmVuZGVyZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBoYXNCb3JkZXJzOiAgICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIG9iamVjdHMgYXJlIFwiZm91bmRcIiBvbiBjYW52YXMgb24gcGVyLXBpeGVsIGJhc2lzIHJhdGhlciB0aGFuIGFjY29yZGluZyB0byBib3VuZGluZyBib3hcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwZXJQaXhlbFRhcmdldEZpbmQ6ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgZmFsc2VgLCBkZWZhdWx0IG9iamVjdCdzIHZhbHVlcyBhcmUgbm90IGluY2x1ZGVkIGluIGl0cyBzZXJpYWxpemF0aW9uXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW5jbHVkZURlZmF1bHRWYWx1ZXM6ICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBob3Jpem9udGFsIG1vdmVtZW50IGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tNb3ZlbWVudFg6ICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHZlcnRpY2FsIG1vdmVtZW50IGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tNb3ZlbWVudFk6ICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHJvdGF0aW9uIGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tSb3RhdGlvbjogICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGhvcml6b250YWwgc2NhbGluZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrU2NhbGluZ1g6ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCB2ZXJ0aWNhbCBzY2FsaW5nIGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTY2FsaW5nWTogICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGhvcml6b250YWwgc2tld2luZyBpcyBsb2NrZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrU2tld2luZ1g6ICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCB2ZXJ0aWNhbCBza2V3aW5nIGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTa2V3aW5nWTogICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGNhbm5vdCBiZSBmbGlwcGVkIGJ5IHNjYWxpbmcgaW50byBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBsb2NrU2NhbGluZ0ZsaXA6ICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBpcyBub3QgZXhwb3J0ZWQgaW4gT0JKRUNUL0pTT05cbiAgICAgKiBAc2luY2UgMS42LjNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBleGNsdWRlRnJvbUV4cG9ydDogICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBpcyBjYWNoZWQgb24gYW4gYWRkaXRpb25hbCBjYW52YXMuXG4gICAgICogV2hlbiBgZmFsc2VgLCBvYmplY3QgaXMgbm90IGNhY2hlZCB1bmxlc3MgbmVjZXNzYXJ5ICggY2xpcFBhdGggKVxuICAgICAqIGRlZmF1bHQgdG8gdHJ1ZVxuICAgICAqIEBzaW5jZSAxLjcuMFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgb2JqZWN0Q2FjaGluZzogICAgICAgICAgICBvYmplY3RDYWNoaW5nLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgdHJ1ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBjaGVja2VkIGZvciBjYWNoZSBpbnZhbGlkYXRpb24uIEluIHNvbWUgcGFydGljdWxhclxuICAgICAqIHNpdHVhdGlvbiB5b3UgbWF5IHdhbnQgdGhpcyB0byBiZSBkaXNhYmxlZCAoIHNwcmF5IGJydXNoLCB2ZXJ5IGJpZywgZ3JvdXBzKVxuICAgICAqIG9yIGlmIHlvdXIgYXBwbGljYXRpb24gZG9lcyBub3QgYWxsb3cgeW91IHRvIG1vZGlmeSBwcm9wZXJ0aWVzIGZvciBncm91cHMgY2hpbGQgeW91IHdhbnRcbiAgICAgKiB0byBkaXNhYmxlIGl0IGZvciBncm91cHMuXG4gICAgICogZGVmYXVsdCB0byBmYWxzZVxuICAgICAqIHNpbmNlIDEuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgc3RhdGVmdWxsQ2FjaGU6ICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgY2FjaGUgZG9lcyBub3QgZ2V0IHVwZGF0ZWQgZHVyaW5nIHNjYWxpbmcuIFRoZSBwaWN0dXJlIHdpbGwgZ2V0IGJsb2NreSBpZiBzY2FsZWRcbiAgICAgKiB0b28gbXVjaCBhbmQgd2lsbCBiZSByZWRyYXduIHdpdGggY29ycmVjdCBkZXRhaWxzIGF0IHRoZSBlbmQgb2Ygc2NhbGluZy5cbiAgICAgKiB0aGlzIHNldHRpbmcgaXMgcGVyZm9ybWFuY2UgYW5kIGFwcGxpY2F0aW9uIGRlcGVuZGFudC5cbiAgICAgKiBkZWZhdWx0IHRvIHRydWVcbiAgICAgKiBzaW5jZSAxLjcuMFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgbm9TY2FsZUNhY2hlOiAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYGZhbHNlYCwgdGhlIHN0b2tlIHdpZHRoIHdpbGwgc2NhbGUgd2l0aCB0aGUgb2JqZWN0LlxuICAgICAqIFdoZW4gYHRydWVgLCB0aGUgc3Ryb2tlIHdpbGwgYWx3YXlzIG1hdGNoIHRoZSBleGFjdCBwaXhlbCBzaXplIGVudGVyZWQgZm9yIHN0cm9rZSB3aWR0aC5cbiAgICAgKiB0aGlzIFByb3BlcnR5IGRvZXMgbm90IHdvcmsgb24gVGV4dCBjbGFzc2VzIG9yIGRyYXdpbmcgY2FsbCB0aGF0IHVzZXMgc3Ryb2tlVGV4dCxmaWxsVGV4dCBtZXRob2RzXG4gICAgICogZGVmYXVsdCB0byBmYWxzZVxuICAgICAqIEBzaW5jZSAyLjYuMFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHN0cm9rZVVuaWZvcm06ICAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgb2JqZWN0J3MgY2FjaGUgd2lsbCBiZSByZXJlbmRlcmVkIG5leHQgcmVuZGVyIGNhbGwuXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGRpcnR5OiAgICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICoga2VlcHMgdGhlIHZhbHVlIG9mIHRoZSBsYXN0IGhvdmVyZWQgY29ybmVyIGR1cmluZyBtb3VzZSBtb3ZlLlxuICAgICAqIDAgaXMgbm8gY29ybmVyLCBvciAnbXQnLCAnbWwnLCAnbXRyJyBldGMuLlxuICAgICAqIEl0IHNob3VsZCBiZSBwcml2YXRlLCBidXQgdGhlcmUgaXMgbm8gaGFybSBpbiB1c2luZyBpdCBhc1xuICAgICAqIGEgcmVhZC1vbmx5IHByb3BlcnR5LlxuICAgICAqIEB0eXBlIG51bWJlcnxzdHJpbmd8YW55XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIF9fY29ybmVyOiAwLFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZmlsbCBvciB0aGUgc3Ryb2tlIGlzIGRyYXduIGZpcnN0IChvbmUgb2YgXCJmaWxsXCIgb3IgXCJzdHJva2VcIilcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhaW50Rmlyc3Q6ICAgICAgICAgICAnZmlsbCcsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuICdkb3duJywgb2JqZWN0IGlzIHNldCB0byBhY3RpdmUgb24gbW91c2Vkb3duL3RvdWNoc3RhcnRcbiAgICAgKiBXaGVuICd1cCcsIG9iamVjdCBpcyBzZXQgdG8gYWN0aXZlIG9uIG1vdXNldXAvdG91Y2hlbmRcbiAgICAgKiBFeHBlcmltZW50YWwuIExldCdzIHNlZSBpZiB0aGlzIGJyZWFrcyBhbnl0aGluZyBiZWZvcmUgc3VwcG9ydGluZyBvZmZpY2lhbGx5XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBzaW5jZSA0LjQuMFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0ICdkb3duJ1xuICAgICAqL1xuICAgIGFjdGl2ZU9uOiAgICAgICAgICAgJ2Rvd24nLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgc3RhdGVcbiAgICAgKiBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWQpXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiAoXG4gICAgICAndG9wIGxlZnQgd2lkdGggaGVpZ2h0IHNjYWxlWCBzY2FsZVkgZmxpcFggZmxpcFkgb3JpZ2luWCBvcmlnaW5ZIHRyYW5zZm9ybU1hdHJpeCAnICtcbiAgICAgICdzdHJva2Ugc3Ryb2tlV2lkdGggc3Ryb2tlRGFzaEFycmF5IHN0cm9rZUxpbmVDYXAgc3Ryb2tlRGFzaE9mZnNldCBzdHJva2VMaW5lSm9pbiBzdHJva2VNaXRlckxpbWl0ICcgK1xuICAgICAgJ2FuZ2xlIG9wYWNpdHkgZmlsbCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gc2hhZG93IHZpc2libGUgYmFja2dyb3VuZENvbG9yICcgK1xuICAgICAgJ3NrZXdYIHNrZXdZIGZpbGxSdWxlIHBhaW50Rmlyc3QgY2xpcFBhdGggc3Ryb2tlVW5pZm9ybSdcbiAgICApLnNwbGl0KCcgJyksXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBjYWNoZSBuZWVkcyByZWZyZXNoXG4gICAgICogVGhvc2UgcHJvcGVydGllcyBhcmUgY2hlY2tlZCBieSBzdGF0ZWZ1bGxDYWNoZSBPTiAoIG9yIGxhenkgbW9kZSBpZiB3ZSB3YW50ICkgb3IgZnJvbSBzaW5nbGVcbiAgICAgKiBjYWxscyB0byBPYmplY3Quc2V0KGtleSwgdmFsdWUpLiBJZiB0aGUga2V5IGlzIGluIHRoaXMgbGlzdCwgdGhlIG9iamVjdCBpcyBtYXJrZWQgYXMgZGlydHlcbiAgICAgKiBhbmQgcmVmcmVzaGVkIGF0IHRoZSBuZXh0IHJlbmRlclxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiAoXG4gICAgICAnZmlsbCBzdHJva2Ugc3Ryb2tlV2lkdGggc3Ryb2tlRGFzaEFycmF5IHdpZHRoIGhlaWdodCBwYWludEZpcnN0IHN0cm9rZVVuaWZvcm0nICtcbiAgICAgICcgc3Ryb2tlTGluZUNhcCBzdHJva2VEYXNoT2Zmc2V0IHN0cm9rZUxpbmVKb2luIHN0cm9rZU1pdGVyTGltaXQgYmFja2dyb3VuZENvbG9yIGNsaXBQYXRoJ1xuICAgICkuc3BsaXQoJyAnKSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciBmb3IgYW5pbWF0aW5nIGNvbG9ycy5cbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGNvbG9yUHJvcGVydGllczogKFxuICAgICAgJ2ZpbGwgc3Ryb2tlIGJhY2tncm91bmRDb2xvcidcbiAgICApLnNwbGl0KCcgJyksXG5cbiAgICAvKipcbiAgICAgKiBhIGZhYnJpY09iamVjdCB0aGF0LCB3aXRob3V0IHN0cm9rZSBkZWZpbmUgYSBjbGlwcGluZyBhcmVhIHdpdGggdGhlaXIgc2hhcGUuIGZpbGxlZCBpbiBibGFja1xuICAgICAqIHRoZSBjbGlwUGF0aCBvYmplY3QgZ2V0cyB1c2VkIHdoZW4gdGhlIG9iamVjdCBoYXMgcmVuZGVyZWQsIGFuZCB0aGUgY29udGV4dCBpcyBwbGFjZWQgaW4gdGhlIGNlbnRlclxuICAgICAqIG9mIHRoZSBvYmplY3QgY2FjaGVDYW52YXMuXG4gICAgICogSWYgeW91IHdhbnQgMCwwIG9mIGEgY2xpcFBhdGggdG8gYWxpZ24gd2l0aCBhbiBvYmplY3QgY2VudGVyLCB1c2UgY2xpcFBhdGgub3JpZ2luWC9ZIHRvICdjZW50ZXInXG4gICAgICogQHR5cGUgZmFicmljLk9iamVjdFxuICAgICAqL1xuICAgIGNsaXBQYXRoOiB1bmRlZmluZWQsXG5cbiAgICAvKipcbiAgICAgKiBNZWFuaW5nZnVsIE9OTFkgd2hlbiB0aGUgb2JqZWN0IGlzIHVzZWQgYXMgY2xpcFBhdGguXG4gICAgICogaWYgdHJ1ZSwgdGhlIGNsaXBQYXRoIHdpbGwgbWFrZSB0aGUgb2JqZWN0IGNsaXAgdG8gdGhlIG91dHNpZGUgb2YgdGhlIGNsaXBQYXRoXG4gICAgICogc2luY2UgMi40LjBcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBpbnZlcnRlZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBNZWFuaW5nZnVsIE9OTFkgd2hlbiB0aGUgb2JqZWN0IGlzIHVzZWQgYXMgY2xpcFBhdGguXG4gICAgICogaWYgdHJ1ZSwgdGhlIGNsaXBQYXRoIHdpbGwgaGF2ZSBpdHMgdG9wIGFuZCBsZWZ0IHJlbGF0aXZlIHRvIGNhbnZhcywgYW5kIHdpbGxcbiAgICAgKiBub3QgYmUgaW5mbHVlbmNlZCBieSB0aGUgb2JqZWN0IHRyYW5zZm9ybS4gVGhpcyB3aWxsIG1ha2UgdGhlIGNsaXBQYXRoIHJlbGF0aXZlXG4gICAgICogdG8gdGhlIGNhbnZhcywgYnV0IGNsaXBwaW5nIGp1c3QgYSBwYXJ0aWN1bGFyIG9iamVjdC5cbiAgICAgKiBXQVJOSU5HIHRoaXMgaXMgYmV0YSwgdGhpcyBmZWF0dXJlIG1heSBjaGFuZ2Ugb3IgYmUgcmVuYW1lZC5cbiAgICAgKiBzaW5jZSAyLjQuMFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGFic29sdXRlUG9zaXRpb25lZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHRoZSBjYW52YXMgdXNlZCB0byBrZWVwIHRoZSBjYWNoZWQgY29weSBvZiB0aGUgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQ2FjaGVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY2FjaGVQcm9wZXJ0aWVzID0ge307XG4gICAgICB0aGlzLl9jYWNoZUNhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIHRoaXMuX2NhY2hlQ29udGV4dCA9IHRoaXMuX2NhY2hlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB0aGlzLl91cGRhdGVDYWNoZUNhbnZhcygpO1xuICAgICAgLy8gaWYgY2FudmFzIGdldHMgY3JlYXRlZCwgaXMgZW1wdHksIHNvIGRpcnR5LlxuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpbWl0IHRoZSBjYWNoZSBkaW1lbnNpb25zIHNvIHRoYXQgWCAqIFkgZG8gbm90IGNyb3NzIGZhYnJpYy5wZXJmTGltaXRTaXplVG90YWxcbiAgICAgKiBhbmQgZWFjaCBzaWRlIGRvIG5vdCBjcm9zcyBmYWJyaWMuY2FjaGVTaWRlTGltaXRcbiAgICAgKiB0aG9zZSBudW1iZXJzIGFyZSBjb25maWd1cmFibGUgc28gdGhhdCB5b3UgY2FuIGdldCBhcyBtdWNoIGRldGFpbCBhcyB5b3Ugd2FudFxuICAgICAqIG1ha2luZyBiYXJnYWluIHdpdGggcGVyZm9ybWFuY2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXMud2lkdGggd2lkdGggb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXMuaGVpZ2h0IGhlaWdodCBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltcy56b29tWCB6b29tWCB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zLnpvb21ZIHpvb21ZIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS53aWR0aCB3aWR0aCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LmhlaWdodCBoZWlnaHQgb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWCB6b29tWCB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVkgem9vbVkgem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKi9cbiAgICBfbGltaXRDYWNoZVNpemU6IGZ1bmN0aW9uKGRpbXMpIHtcbiAgICAgIHZhciBwZXJmTGltaXRTaXplVG90YWwgPSBmYWJyaWMucGVyZkxpbWl0U2l6ZVRvdGFsLFxuICAgICAgICAgIHdpZHRoID0gZGltcy53aWR0aCwgaGVpZ2h0ID0gZGltcy5oZWlnaHQsXG4gICAgICAgICAgbWF4ID0gZmFicmljLm1heENhY2hlU2lkZUxpbWl0LCBtaW4gPSBmYWJyaWMubWluQ2FjaGVTaWRlTGltaXQ7XG4gICAgICBpZiAod2lkdGggPD0gbWF4ICYmIGhlaWdodCA8PSBtYXggJiYgd2lkdGggKiBoZWlnaHQgPD0gcGVyZkxpbWl0U2l6ZVRvdGFsKSB7XG4gICAgICAgIGlmICh3aWR0aCA8IG1pbikge1xuICAgICAgICAgIGRpbXMud2lkdGggPSBtaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodCA8IG1pbikge1xuICAgICAgICAgIGRpbXMuaGVpZ2h0ID0gbWluO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaW1zO1xuICAgICAgfVxuICAgICAgdmFyIGFyID0gd2lkdGggLyBoZWlnaHQsIGxpbWl0ZWREaW1zID0gZmFicmljLnV0aWwubGltaXREaW1zQnlBcmVhKGFyLCBwZXJmTGltaXRTaXplVG90YWwpLFxuICAgICAgICAgIGNhcFZhbHVlID0gZmFicmljLnV0aWwuY2FwVmFsdWUsXG4gICAgICAgICAgeCA9IGNhcFZhbHVlKG1pbiwgbGltaXRlZERpbXMueCwgbWF4KSxcbiAgICAgICAgICB5ID0gY2FwVmFsdWUobWluLCBsaW1pdGVkRGltcy55LCBtYXgpO1xuICAgICAgaWYgKHdpZHRoID4geCkge1xuICAgICAgICBkaW1zLnpvb21YIC89IHdpZHRoIC8geDtcbiAgICAgICAgZGltcy53aWR0aCA9IHg7XG4gICAgICAgIGRpbXMuY2FwcGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHQgPiB5KSB7XG4gICAgICAgIGRpbXMuem9vbVkgLz0gaGVpZ2h0IC8geTtcbiAgICAgICAgZGltcy5oZWlnaHQgPSB5O1xuICAgICAgICBkaW1zLmNhcHBlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGltcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkaW1lbnNpb24gYW5kIHRoZSB6b29tIGxldmVsIG5lZWRlZCB0byBjcmVhdGUgYSBjYWNoZSBjYW52YXNcbiAgICAgKiBiaWcgZW5vdWdoIHRvIGhvc3QgdGhlIG9iamVjdCB0byBiZSBjYWNoZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnggd2lkdGggb2Ygb2JqZWN0IHRvIGJlIGNhY2hlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0ueSBoZWlnaHQgb2Ygb2JqZWN0IHRvIGJlIGNhY2hlZFxuICAgICAqIEByZXR1cm4ge09iamVjdH0ud2lkdGggd2lkdGggb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVggem9vbVggem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21ZIHpvb21ZIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICovXG4gICAgX2dldENhY2hlQ2FudmFzRGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqZWN0U2NhbGUgPSB0aGlzLmdldFRvdGFsT2JqZWN0U2NhbGluZygpLFxuICAgICAgICAgIC8vIGNhY3VsYXRlIGRpbWVuc2lvbnMgd2l0aG91dCBza2V3aW5nXG4gICAgICAgICAgZGltID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKDAsIDApLFxuICAgICAgICAgIG5lZWRlZFggPSBkaW0ueCAqIG9iamVjdFNjYWxlLnNjYWxlWCAvIHRoaXMuc2NhbGVYLFxuICAgICAgICAgIG5lZWRlZFkgPSBkaW0ueSAqIG9iamVjdFNjYWxlLnNjYWxlWSAvIHRoaXMuc2NhbGVZO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gZm9yIHN1cmUgdGhpcyBBTElBU0lOR19MSU1JVCBpcyBzbGlnaHRseSBjcmVhdGluZyBwcm9ibGVtXG4gICAgICAgIC8vIGluIHNpdHVhdGlvbiBpbiB3aGljaCB0aGUgY2FjaGUgY2FudmFzIGdldHMgYW4gdXBwZXIgbGltaXRcbiAgICAgICAgLy8gYWxzbyBvYmplY3RTY2FsZSBjb250YWlucyBhbHJlYWR5IHNjYWxlWCBhbmQgc2NhbGVZXG4gICAgICAgIHdpZHRoOiBuZWVkZWRYICsgQUxJQVNJTkdfTElNSVQsXG4gICAgICAgIGhlaWdodDogbmVlZGVkWSArIEFMSUFTSU5HX0xJTUlULFxuICAgICAgICB6b29tWDogb2JqZWN0U2NhbGUuc2NhbGVYLFxuICAgICAgICB6b29tWTogb2JqZWN0U2NhbGUuc2NhbGVZLFxuICAgICAgICB4OiBuZWVkZWRYLFxuICAgICAgICB5OiBuZWVkZWRZXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY2FudmFzIGZvciBjYWNoZVxuICAgICAqIHJldHVybnMgdHJ1ZSBvciBmYWxzZSBpZiBjYW52YXMgbmVlZGVkIHJlc2l6ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGNhbnZhcyBoYXMgYmVlbiByZXNpemVkXG4gICAgICovXG4gICAgX3VwZGF0ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0YXJnZXRDYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIGlmICh0aGlzLm5vU2NhbGVDYWNoZSAmJiB0YXJnZXRDYW52YXMgJiYgdGFyZ2V0Q2FudmFzLl9jdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRDYW52YXMuX2N1cnJlbnRUcmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAgICAgYWN0aW9uID0gdGFyZ2V0Q2FudmFzLl9jdXJyZW50VHJhbnNmb3JtLmFjdGlvbjtcbiAgICAgICAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBhY3Rpb24uc2xpY2UgJiYgYWN0aW9uLnNsaWNlKDAsIDUpID09PSAnc2NhbGUnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FjaGVDYW52YXMsXG4gICAgICAgICAgZGltcyA9IHRoaXMuX2xpbWl0Q2FjaGVTaXplKHRoaXMuX2dldENhY2hlQ2FudmFzRGltZW5zaW9ucygpKSxcbiAgICAgICAgICBtaW5DYWNoZVNpemUgPSBmYWJyaWMubWluQ2FjaGVTaWRlTGltaXQsXG4gICAgICAgICAgd2lkdGggPSBkaW1zLndpZHRoLCBoZWlnaHQgPSBkaW1zLmhlaWdodCwgZHJhd2luZ1dpZHRoLCBkcmF3aW5nSGVpZ2h0LFxuICAgICAgICAgIHpvb21YID0gZGltcy56b29tWCwgem9vbVkgPSBkaW1zLnpvb21ZLFxuICAgICAgICAgIGRpbWVuc2lvbnNDaGFuZ2VkID0gd2lkdGggIT09IHRoaXMuY2FjaGVXaWR0aCB8fCBoZWlnaHQgIT09IHRoaXMuY2FjaGVIZWlnaHQsXG4gICAgICAgICAgem9vbUNoYW5nZWQgPSB0aGlzLnpvb21YICE9PSB6b29tWCB8fCB0aGlzLnpvb21ZICE9PSB6b29tWSxcbiAgICAgICAgICBzaG91bGRSZWRyYXcgPSBkaW1lbnNpb25zQ2hhbmdlZCB8fCB6b29tQ2hhbmdlZCxcbiAgICAgICAgICBhZGRpdGlvbmFsV2lkdGggPSAwLCBhZGRpdGlvbmFsSGVpZ2h0ID0gMCwgc2hvdWxkUmVzaXplQ2FudmFzID0gZmFsc2U7XG4gICAgICBpZiAoZGltZW5zaW9uc0NoYW5nZWQpIHtcbiAgICAgICAgdmFyIGNhbnZhc1dpZHRoID0gdGhpcy5fY2FjaGVDYW52YXMud2lkdGgsXG4gICAgICAgICAgICBjYW52YXNIZWlnaHQgPSB0aGlzLl9jYWNoZUNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICBzaXplR3Jvd2luZyA9IHdpZHRoID4gY2FudmFzV2lkdGggfHwgaGVpZ2h0ID4gY2FudmFzSGVpZ2h0LFxuICAgICAgICAgICAgc2l6ZVNocmlua2luZyA9ICh3aWR0aCA8IGNhbnZhc1dpZHRoICogMC45IHx8IGhlaWdodCA8IGNhbnZhc0hlaWdodCAqIDAuOSkgJiZcbiAgICAgICAgICAgICAgY2FudmFzV2lkdGggPiBtaW5DYWNoZVNpemUgJiYgY2FudmFzSGVpZ2h0ID4gbWluQ2FjaGVTaXplO1xuICAgICAgICBzaG91bGRSZXNpemVDYW52YXMgPSBzaXplR3Jvd2luZyB8fCBzaXplU2hyaW5raW5nO1xuICAgICAgICBpZiAoc2l6ZUdyb3dpbmcgJiYgIWRpbXMuY2FwcGVkICYmICh3aWR0aCA+IG1pbkNhY2hlU2l6ZSB8fCBoZWlnaHQgPiBtaW5DYWNoZVNpemUpKSB7XG4gICAgICAgICAgYWRkaXRpb25hbFdpZHRoID0gd2lkdGggKiAwLjE7XG4gICAgICAgICAgYWRkaXRpb25hbEhlaWdodCA9IGhlaWdodCAqIDAuMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBmYWJyaWMuVGV4dCAmJiB0aGlzLnBhdGgpIHtcbiAgICAgICAgc2hvdWxkUmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgc2hvdWxkUmVzaXplQ2FudmFzID0gdHJ1ZTtcbiAgICAgICAgYWRkaXRpb25hbFdpZHRoICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKDApICogdGhpcy56b29tWDtcbiAgICAgICAgYWRkaXRpb25hbEhlaWdodCArPSB0aGlzLmdldEhlaWdodE9mTGluZSgwKSAqIHRoaXMuem9vbVk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUmVkcmF3KSB7XG4gICAgICAgIGlmIChzaG91bGRSZXNpemVDYW52YXMpIHtcbiAgICAgICAgICBjYW52YXMud2lkdGggPSBNYXRoLmNlaWwod2lkdGggKyBhZGRpdGlvbmFsV2lkdGgpO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICsgYWRkaXRpb25hbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZHJhd2luZ1dpZHRoID0gZGltcy54IC8gMjtcbiAgICAgICAgZHJhd2luZ0hlaWdodCA9IGRpbXMueSAvIDI7XG4gICAgICAgIHRoaXMuY2FjaGVUcmFuc2xhdGlvblggPSBNYXRoLnJvdW5kKGNhbnZhcy53aWR0aCAvIDIgLSBkcmF3aW5nV2lkdGgpICsgZHJhd2luZ1dpZHRoO1xuICAgICAgICB0aGlzLmNhY2hlVHJhbnNsYXRpb25ZID0gTWF0aC5yb3VuZChjYW52YXMuaGVpZ2h0IC8gMiAtIGRyYXdpbmdIZWlnaHQpICsgZHJhd2luZ0hlaWdodDtcbiAgICAgICAgdGhpcy5jYWNoZVdpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuY2FjaGVIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX2NhY2hlQ29udGV4dC50cmFuc2xhdGUodGhpcy5jYWNoZVRyYW5zbGF0aW9uWCwgdGhpcy5jYWNoZVRyYW5zbGF0aW9uWSk7XG4gICAgICAgIHRoaXMuX2NhY2hlQ29udGV4dC5zY2FsZSh6b29tWCwgem9vbVkpO1xuICAgICAgICB0aGlzLnpvb21YID0gem9vbVg7XG4gICAgICAgIHRoaXMuem9vbVkgPSB6b29tWTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgb2JqZWN0J3MgcHJvcGVydGllcyBmcm9tIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRHcmFkaWVudChvcHRpb25zLmZpbGwsICdmaWxsJyk7XG4gICAgICB0aGlzLl9pbml0R3JhZGllbnQob3B0aW9ucy5zdHJva2UsICdzdHJva2UnKTtcbiAgICAgIHRoaXMuX2luaXRQYXR0ZXJuKG9wdGlvbnMuZmlsbCwgJ2ZpbGwnKTtcbiAgICAgIHRoaXMuX2luaXRQYXR0ZXJuKG9wdGlvbnMuc3Ryb2tlLCAnc3Ryb2tlJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgY29udGV4dCB3aGVuIHJlbmRlcmluZyBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHRcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIG5lZWRGdWxsVHJhbnNmb3JtID0gKHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuX3RyYW5zZm9ybURvbmUpIHx8XG4gICAgICAgICAodGhpcy5ncm91cCAmJiB0aGlzLmNhbnZhcyAmJiBjdHggPT09IHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgICAgdmFyIG0gPSB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoIW5lZWRGdWxsVHJhbnNmb3JtKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTLFxuXG4gICAgICAgICAgb2JqZWN0ID0ge1xuICAgICAgICAgICAgdHlwZTogICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUsXG4gICAgICAgICAgICB2ZXJzaW9uOiAgICAgICAgICAgICAgICAgIGZhYnJpYy52ZXJzaW9uLFxuICAgICAgICAgICAgb3JpZ2luWDogICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgICBvcmlnaW5ZOiAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luWSxcbiAgICAgICAgICAgIGxlZnQ6ICAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmxlZnQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgdG9wOiAgICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMudG9wLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHdpZHRoOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGhlaWdodDogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBmaWxsOiAgICAgICAgICAgICAgICAgICAgICh0aGlzLmZpbGwgJiYgdGhpcy5maWxsLnRvT2JqZWN0KSA/IHRoaXMuZmlsbC50b09iamVjdCgpIDogdGhpcy5maWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiAgICAgICAgICAgICAgICAgICAodGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2UudG9PYmplY3QpID8gdGhpcy5zdHJva2UudG9PYmplY3QoKSA6IHRoaXMuc3Ryb2tlLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc3Ryb2tlV2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiAgICAgICAgICB0aGlzLnN0cm9rZURhc2hBcnJheSA/IHRoaXMuc3Ryb2tlRGFzaEFycmF5LmNvbmNhdCgpIDogdGhpcy5zdHJva2VEYXNoQXJyYXksXG4gICAgICAgICAgICBzdHJva2VMaW5lQ2FwOiAgICAgICAgICAgIHRoaXMuc3Ryb2tlTGluZUNhcCxcbiAgICAgICAgICAgIHN0cm9rZURhc2hPZmZzZXQ6ICAgICAgICAgdGhpcy5zdHJva2VEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgc3Ryb2tlTGluZUpvaW46ICAgICAgICAgICB0aGlzLnN0cm9rZUxpbmVKb2luLFxuICAgICAgICAgICAgc3Ryb2tlVW5pZm9ybTogICAgICAgICAgICB0aGlzLnN0cm9rZVVuaWZvcm0sXG4gICAgICAgICAgICBzdHJva2VNaXRlckxpbWl0OiAgICAgICAgIHRvRml4ZWQodGhpcy5zdHJva2VNaXRlckxpbWl0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHNjYWxlWDogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNjYWxlWCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBzY2FsZVk6ICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5zY2FsZVksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgYW5nbGU6ICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuYW5nbGUsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgZmxpcFg6ICAgICAgICAgICAgICAgICAgICB0aGlzLmZsaXBYLFxuICAgICAgICAgICAgZmxpcFk6ICAgICAgICAgICAgICAgICAgICB0aGlzLmZsaXBZLFxuICAgICAgICAgICAgb3BhY2l0eTogICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMub3BhY2l0eSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBzaGFkb3c6ICAgICAgICAgICAgICAgICAgICh0aGlzLnNoYWRvdyAmJiB0aGlzLnNoYWRvdy50b09iamVjdCkgPyB0aGlzLnNoYWRvdy50b09iamVjdCgpIDogdGhpcy5zaGFkb3csXG4gICAgICAgICAgICB2aXNpYmxlOiAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBmaWxsUnVsZTogICAgICAgICAgICAgICAgIHRoaXMuZmlsbFJ1bGUsXG4gICAgICAgICAgICBwYWludEZpcnN0OiAgICAgICAgICAgICAgIHRoaXMucGFpbnRGaXJzdCxcbiAgICAgICAgICAgIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjogdGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24sXG4gICAgICAgICAgICBza2V3WDogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5za2V3WCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBza2V3WTogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5za2V3WSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuY2xpcFBhdGggJiYgIXRoaXMuY2xpcFBhdGguZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgb2JqZWN0LmNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aC50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgICAgb2JqZWN0LmNsaXBQYXRoLmludmVydGVkID0gdGhpcy5jbGlwUGF0aC5pbnZlcnRlZDtcbiAgICAgICAgb2JqZWN0LmNsaXBQYXRoLmFic29sdXRlUG9zaXRpb25lZCA9IHRoaXMuY2xpcFBhdGguYWJzb2x1dGVQb3NpdGlvbmVkO1xuICAgICAgfVxuXG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIG9iamVjdCwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5fcmVtb3ZlRGVmYXVsdFZhbHVlcyhvYmplY3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIChkYXRhbGVzcykgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgLy8gd2lsbCBiZSBvdmVyd3JpdHRlbiBieSBzdWJjbGFzc2VzXG4gICAgICByZXR1cm4gdGhpcy50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICovXG4gICAgX3JlbW92ZURlZmF1bHRWYWx1ZXM6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHByb3RvdHlwZSA9IGZhYnJpYy51dGlsLmdldEtsYXNzKG9iamVjdC50eXBlKS5wcm90b3R5cGUsXG4gICAgICAgICAgc3RhdGVQcm9wZXJ0aWVzID0gcHJvdG90eXBlLnN0YXRlUHJvcGVydGllcztcbiAgICAgIHN0YXRlUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgaWYgKHByb3AgPT09ICdsZWZ0JyB8fCBwcm9wID09PSAndG9wJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0W3Byb3BdID09PSBwcm90b3R5cGVbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJhc2ljYWxseSBhIGNoZWNrIGZvciBbXSA9PT0gW11cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0W3Byb3BdKSAmJiBBcnJheS5pc0FycmF5KHByb3RvdHlwZVtwcm9wXSlcbiAgICAgICAgICAmJiBvYmplY3RbcHJvcF0ubGVuZ3RoID09PSAwICYmIHByb3RvdHlwZVtwcm9wXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLicgKyBjYXBpdGFsaXplKHRoaXMudHlwZSkgKyAnPic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgb2JqZWN0IHNjYWxlIGZhY3RvciBjb3VudGluZyBhbHNvIHRoZSBncm91cCBzY2FsaW5nXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBzY2FsZVggYW5kIHNjYWxlWSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0T2JqZWN0U2NhbGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpZiB0aGUgb2JqZWN0IGlzIGEgdG9wIGxldmVsIG9uZSwgb24gdGhlIGNhbnZhcywgd2UgZ28gZm9yIHNpbXBsZSBhcml0bWV0aWNcbiAgICAgIC8vIG90aGVyd2lzZSB0aGUgY29tcGxleCBtZXRob2Qgd2l0aCBhbmdsZXMgd2lsbCByZXR1cm4gYXBwcm94aW1hdGlvbnMgYW5kIGRlY2ltYWxzXG4gICAgICAvLyBhbmQgd2lsbCBsaWtlbHkga2lsbCB0aGUgY2FjaGUgd2hlbiBub3QgbmVlZGVkXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFicmljanMvZmFicmljLmpzL2lzc3Vlcy83MTU3XG4gICAgICBpZiAoIXRoaXMuZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzY2FsZVg6IHRoaXMuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVksXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyBpZiB3ZSBhcmUgaW5zaWRlIGEgZ3JvdXAgdG90YWwgem9vbSBjYWxjdWxhdGlvbiBpcyBjb21wbGV4LCB3ZSBkZWZlciB0byBnZW5lcmljIG1hdHJpY2VzXG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKTtcbiAgICAgIHJldHVybiB7IHNjYWxlWDogTWF0aC5hYnMob3B0aW9ucy5zY2FsZVgpLCBzY2FsZVk6IE1hdGguYWJzKG9wdGlvbnMuc2NhbGVZKSB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG9iamVjdCBzY2FsZSBmYWN0b3IgY291bnRpbmcgYWxzbyB0aGUgZ3JvdXAgc2NhbGluZywgem9vbSBhbmQgcmV0aW5hXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBzY2FsZVggYW5kIHNjYWxlWSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0VG90YWxPYmplY3RTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpLCBzY2FsZVggPSBzY2FsZS5zY2FsZVgsIHNjYWxlWSA9IHNjYWxlLnNjYWxlWTtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB2YXIgem9vbSA9IHRoaXMuY2FudmFzLmdldFpvb20oKTtcbiAgICAgICAgdmFyIHJldGluYSA9IHRoaXMuY2FudmFzLmdldFJldGluYVNjYWxpbmcoKTtcbiAgICAgICAgc2NhbGVYICo9IHpvb20gKiByZXRpbmE7XG4gICAgICAgIHNjYWxlWSAqPSB6b29tICogcmV0aW5hO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc2NhbGVYOiBzY2FsZVgsIHNjYWxlWTogc2NhbGVZIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgb2JqZWN0IG9wYWNpdHkgY291bnRpbmcgYWxzbyB0aGUgZ3JvdXAgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0T2JqZWN0T3BhY2l0eTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIG9wYWNpdHkgKj0gdGhpcy5ncm91cC5nZXRPYmplY3RPcGFjaXR5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3BhY2l0eTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgc2hvdWxkQ29uc3RyYWluVmFsdWUgPSAoa2V5ID09PSAnc2NhbGVYJyB8fCBrZXkgPT09ICdzY2FsZVknKSxcbiAgICAgICAgICBpc0NoYW5nZWQgPSB0aGlzW2tleV0gIT09IHZhbHVlLCBncm91cE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmIChzaG91bGRDb25zdHJhaW5WYWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX2NvbnN0cmFpblNjYWxlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzY2FsZVgnICYmIHZhbHVlIDwgMCkge1xuICAgICAgICB0aGlzLmZsaXBYID0gIXRoaXMuZmxpcFg7XG4gICAgICAgIHZhbHVlICo9IC0xO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc2NhbGVZJyAmJiB2YWx1ZSA8IDApIHtcbiAgICAgICAgdGhpcy5mbGlwWSA9ICF0aGlzLmZsaXBZO1xuICAgICAgICB2YWx1ZSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3NoYWRvdycgJiYgdmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIGZhYnJpYy5TaGFkb3cpKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IGZhYnJpYy5TaGFkb3codmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnZGlydHknICYmIHRoaXMuZ3JvdXApIHtcbiAgICAgICAgdGhpcy5ncm91cC5zZXQoJ2RpcnR5JywgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcblxuICAgICAgaWYgKGlzQ2hhbmdlZCkge1xuICAgICAgICBncm91cE5lZWRzVXBkYXRlID0gdGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKTtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgZ3JvdXBOZWVkc1VwZGF0ZSAmJiB0aGlzLmdyb3VwLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChncm91cE5lZWRzVXBkYXRlICYmIHRoaXMuc3RhdGVQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5ncm91cC5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSB0aGUgcGFyZW50IGdyb3VwIG9mIGFuIG9iamVjdCBldmVyeVxuICAgICAqIHRpbWUgYSBub24tZGVsZWdhdGVkIHByb3BlcnR5IGNoYW5nZXMgb24gdGhlIGdyb3VwLiBJdCBpcyBwYXNzZWQgdGhlIGtleVxuICAgICAqIGFuZCB2YWx1ZSBhcyBwYXJhbWV0ZXJzLiBOb3QgYWRkaW5nIGluIHRoaXMgZnVuY3Rpb24ncyBzaWduYXR1cmUgdG8gYXZvaWRcbiAgICAgKiBUcmF2aXMgYnVpbGQgZXJyb3IgYWJvdXQgdW51c2VkIHZhcmlhYmxlcy5cbiAgICAgKi9cbiAgICBzZXRPbkdyb3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGltcGxlbWVudGVkIGJ5IHN1Yi1jbGFzc2VzLCBhcyBuZWVkZWQuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB2aWV3cG9ydFRyYW5zZm9ybSBmcm9tIE9iamVjdCdzIGNhbnZhcyBpZiBwb3NzaWJsZVxuICAgICAqIEBtZXRob2QgZ2V0Vmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRWaWV3cG9ydFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogcmV0dXJuIGlmIHRoZSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpbiByZW5kZXJpbmdcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzTm90VmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcGFjaXR5ID09PSAwIHx8XG4gICAgICAgICghdGhpcy53aWR0aCAmJiAhdGhpcy5oZWlnaHQgJiYgdGhpcy5zdHJva2VXaWR0aCA9PT0gMCkgfHxcbiAgICAgICAgIXRoaXMudmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbiBvYmplY3Qgb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgLy8gZG8gbm90IHJlbmRlciBpZiB3aWR0aC9oZWlnaHQgYXJlIHplcm9zIG9yIG9iamVjdCBpcyBub3QgdmlzaWJsZVxuICAgICAgaWYgKHRoaXMuaXNOb3RWaXNpYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnNraXBPZmZzY3JlZW4gJiYgIXRoaXMuZ3JvdXAgJiYgIXRoaXMuaXNPblNjcmVlbigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXR1cENvbXBvc2l0ZU9wZXJhdGlvbihjdHgpO1xuICAgICAgdGhpcy5kcmF3U2VsZWN0aW9uQmFja2dyb3VuZChjdHgpO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oY3R4KTtcbiAgICAgIHRoaXMuX3NldE9wYWNpdHkoY3R4KTtcbiAgICAgIHRoaXMuX3NldFNoYWRvdyhjdHgsIHRoaXMpO1xuICAgICAgaWYgKHRoaXMuc2hvdWxkQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLnJlbmRlckNhY2hlKCk7XG4gICAgICAgIHRoaXMuZHJhd0NhY2hlT25DYW52YXMoY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmVDYWNoZUNhbnZhcygpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhd09iamVjdChjdHgpO1xuICAgICAgICBpZiAodGhpcy5vYmplY3RDYWNoaW5nICYmIHRoaXMuc3RhdGVmdWxsQ2FjaGUpIHtcbiAgICAgICAgICB0aGlzLnNhdmVTdGF0ZSh7IHByb3BlcnR5U2V0OiAnY2FjaGVQcm9wZXJ0aWVzJyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyQ2FjaGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKCF0aGlzLl9jYWNoZUNhbnZhcyB8fCAhdGhpcy5fY2FjaGVDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUNhY2hlQ2FudmFzKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0NhY2hlRGlydHkoKSkge1xuICAgICAgICB0aGlzLnN0YXRlZnVsbENhY2hlICYmIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdjYWNoZVByb3BlcnRpZXMnIH0pO1xuICAgICAgICB0aGlzLmRyYXdPYmplY3QodGhpcy5fY2FjaGVDb250ZXh0LCBvcHRpb25zLmZvckNsaXBwaW5nKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgY2FjaGVDYW52YXMgYW5kIGl0cyBkaW1lbnNpb25zIGZyb20gdGhlIG9iamVjdHNcbiAgICAgKi9cbiAgICBfcmVtb3ZlQ2FjaGVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY2FjaGVDYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5fY2FjaGVDb250ZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMuY2FjaGVXaWR0aCA9IDA7XG4gICAgICB0aGlzLmNhY2hlSGVpZ2h0ID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCB3aWxsIGRyYXcgYSBzdHJva2VcbiAgICAgKiBEb2VzIG5vdCBjb25zaWRlciB0ZXh0IHN0eWxlcy4gVGhpcyBpcyBqdXN0IGEgc2hvcnRjdXQgdXNlZCBhdCByZW5kZXJpbmcgdGltZVxuICAgICAqIFdlIHdhbnQgaXQgdG8gYmUgYW4gYXBwcm94aW1hdGlvbiBhbmQgYmUgZmFzdC5cbiAgICAgKiB3cm90ZSB0byBhdm9pZCBleHRyYSBjYWNoaW5nLCBpdCBoYXMgdG8gcmV0dXJuIHRydWUgd2hlbiBzdHJva2UgaGFwcGVucyxcbiAgICAgKiBjYW4gZ3Vlc3Mgd2hlbiBpdCB3aWxsIG5vdCBoYXBwZW4gYXQgMTAwJSBjaGFuY2UsIGRvZXMgbm90IG1hdHRlciBpZiBpdCBtaXNzZXNcbiAgICAgKiBzb21lIHVzZSBjYXNlIHdoZXJlIHRoZSBzdHJva2UgaXMgaW52aXNpYmxlLlxuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKi9cbiAgICBoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3Ryb2tlICYmIHRoaXMuc3Ryb2tlICE9PSAndHJhbnNwYXJlbnQnICYmIHRoaXMuc3Ryb2tlV2lkdGggIT09IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0cnVlIGlmIHRoZSBvYmplY3Qgd2lsbCBkcmF3IGEgZmlsbFxuICAgICAqIERvZXMgbm90IGNvbnNpZGVyIHRleHQgc3R5bGVzLiBUaGlzIGlzIGp1c3QgYSBzaG9ydGN1dCB1c2VkIGF0IHJlbmRlcmluZyB0aW1lXG4gICAgICogV2Ugd2FudCBpdCB0byBiZSBhbiBhcHByb3hpbWF0aW9uIGFuZCBiZSBmYXN0LlxuICAgICAqIHdyb3RlIHRvIGF2b2lkIGV4dHJhIGNhY2hpbmcsIGl0IGhhcyB0byByZXR1cm4gdHJ1ZSB3aGVuIGZpbGwgaGFwcGVucyxcbiAgICAgKiBjYW4gZ3Vlc3Mgd2hlbiBpdCB3aWxsIG5vdCBoYXBwZW4gYXQgMTAwJSBjaGFuY2UsIGRvZXMgbm90IG1hdHRlciBpZiBpdCBtaXNzZXNcbiAgICAgKiBzb21lIHVzZSBjYXNlIHdoZXJlIHRoZSBmaWxsIGlzIGludmlzaWJsZS5cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAgICovXG4gICAgaGFzRmlsbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWxsICYmIHRoaXMuZmlsbCAhPT0gJ3RyYW5zcGFyZW50JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCBmb3JjZSB0aGUgb2JqZWN0IHRvIGhhdmUgaXRzIG93biBjYWNoZSwgZXZlbiBpZiBpdCBpcyBpbnNpZGUgYSBncm91cFxuICAgICAqIGl0IG1heSBiZSBuZWVkZWQgd2hlbiB5b3VyIG9iamVjdCBiZWhhdmUgaW4gYSBwYXJ0aWN1bGFyIHdheSBvbiB0aGUgY2FjaGUgYW5kIGFsd2F5cyBuZWVkc1xuICAgICAqIGl0cyBvd24gaXNvbGF0ZWQgY2FudmFzIHRvIHJlbmRlciBjb3JyZWN0bHkuXG4gICAgICogQ3JlYXRlZCB0byBiZSBvdmVycmlkZGVuXG4gICAgICogc2luY2UgMS43LjEyXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICAqL1xuICAgIG5lZWRzSXRzT3duQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucGFpbnRGaXJzdCA9PT0gJ3N0cm9rZScgJiZcbiAgICAgICAgdGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSAmJiB0eXBlb2YgdGhpcy5zaGFkb3cgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZSBpZiB0aGUgb2JqZWN0IHNob3VsZCBjYWNoZSBvciBub3QuIENyZWF0ZSBpdHMgb3duIGNhY2hlIGxldmVsXG4gICAgICogb2JqZWN0Q2FjaGluZyBpcyBhIGdsb2JhbCBmbGFnLCB3aW5zIG92ZXIgZXZlcnl0aGluZ1xuICAgICAqIG5lZWRzSXRzT3duQ2FjaGUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGRyYXdpbmcgbWV0aG9kIHJlcXVpcmVzXG4gICAgICogYSBjYWNoZSBzdGVwLiBOb25lIG9mIHRoZSBmYWJyaWMgY2xhc3NlcyByZXF1aXJlcyBpdC5cbiAgICAgKiBHZW5lcmFsbHkgeW91IGRvIG5vdCBjYWNoZSBvYmplY3RzIGluIGdyb3VwcyBiZWNhdXNlIHRoZSBncm91cCBvdXRzaWRlIGlzIGNhY2hlZC5cbiAgICAgKiBSZWFkIGFzOiBjYWNoZSBpZiBpcyBuZWVkZWQsIG9yIGlmIHRoZSBmZWF0dXJlIGlzIGVuYWJsZWQgYnV0IHdlIGFyZSBub3QgYWxyZWFkeSBjYWNoaW5nLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5vd25DYWNoaW5nID0gdGhpcy5uZWVkc0l0c093bkNhY2hlKCkgfHwgKFxuICAgICAgICB0aGlzLm9iamVjdENhY2hpbmcgJiZcbiAgICAgICAgKCF0aGlzLmdyb3VwIHx8ICF0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5vd25DYWNoaW5nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBvciBhIGNoaWxkIG9iamVjdCB3aWxsIGNhc3QgYSBzaGFkb3dcbiAgICAgKiB1c2VkIGJ5IEdyb3VwLnNob3VsZENhY2hlIHRvIGtub3cgaWYgY2hpbGQgaGFzIGEgc2hhZG93IHJlY3Vyc2l2ZWx5XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB3aWxsRHJhd1NoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnNoYWRvdyAmJiAodGhpcy5zaGFkb3cub2Zmc2V0WCAhPT0gMCB8fCB0aGlzLnNoYWRvdy5vZmZzZXRZICE9PSAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgZHJhd2luZyBvcGVyYXRpb24gZm9yIGFuIG9iamVjdCBjbGlwUGF0aFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGNsaXBQYXRoXG4gICAgICovXG4gICAgZHJhd0NsaXBQYXRoT25DYWNoZTogZnVuY3Rpb24oY3R4LCBjbGlwUGF0aCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIC8vIERFQlVHOiB1bmNvbW1lbnQgdGhpcyBsaW5lLCBjb21tZW50IHRoZSBmb2xsb3dpbmdcbiAgICAgIC8vIGN0eC5nbG9iYWxBbHBoYSA9IDAuNFxuICAgICAgaWYgKGNsaXBQYXRoLmludmVydGVkKSB7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICAgIH1cbiAgICAgIC8vY3R4LnNjYWxlKDEgLyAyLCAxIC8gMik7XG4gICAgICBpZiAoY2xpcFBhdGguYWJzb2x1dGVQb3NpdGlvbmVkKSB7XG4gICAgICAgIHZhciBtID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcbiAgICAgIH1cbiAgICAgIGNsaXBQYXRoLnRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnNjYWxlKDEgLyBjbGlwUGF0aC56b29tWCwgMSAvIGNsaXBQYXRoLnpvb21ZKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoY2xpcFBhdGguX2NhY2hlQ2FudmFzLCAtY2xpcFBhdGguY2FjaGVUcmFuc2xhdGlvblgsIC1jbGlwUGF0aC5jYWNoZVRyYW5zbGF0aW9uWSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBkcmF3aW5nIG9wZXJhdGlvbiBmb3IgYW4gb2JqZWN0IG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd09iamVjdDogZnVuY3Rpb24oY3R4LCBmb3JDbGlwcGluZykge1xuICAgICAgdmFyIG9yaWdpbmFsRmlsbCA9IHRoaXMuZmlsbCwgb3JpZ2luYWxTdHJva2UgPSB0aGlzLnN0cm9rZTtcbiAgICAgIGlmIChmb3JDbGlwcGluZykge1xuICAgICAgICB0aGlzLmZpbGwgPSAnYmxhY2snO1xuICAgICAgICB0aGlzLnN0cm9rZSA9ICcnO1xuICAgICAgICB0aGlzLl9zZXRDbGlwcGluZ1Byb3BlcnRpZXMoY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXIoY3R4KTtcbiAgICAgIHRoaXMuX2RyYXdDbGlwUGF0aChjdHgsIHRoaXMuY2xpcFBhdGgpO1xuICAgICAgdGhpcy5maWxsID0gb3JpZ2luYWxGaWxsO1xuICAgICAgdGhpcy5zdHJva2UgPSBvcmlnaW5hbFN0cm9rZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSBjbGlwUGF0aCBzdGF0ZSBhbmQgY2FjaGUgYW5kIGRyYXcgaXQgb24gaW5zdGFuY2UncyBjYWNoZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGNsaXBQYXRoXG4gICAgICovXG4gICAgX2RyYXdDbGlwUGF0aDogZnVuY3Rpb24gKGN0eCwgY2xpcFBhdGgpIHtcbiAgICAgIGlmICghY2xpcFBhdGgpIHsgcmV0dXJuOyB9XG4gICAgICAvLyBuZWVkZWQgdG8gc2V0dXAgYSBjb3VwbGUgb2YgdmFyaWFibGVzXG4gICAgICAvLyBwYXRoIGNhbnZhcyBnZXRzIG92ZXJyaWRkZW4gd2l0aCB0aGlzIG9uZS5cbiAgICAgIC8vIFRPRE8gZmluZCBhIGJldHRlciBzb2x1dGlvbj9cbiAgICAgIGNsaXBQYXRoLmNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgY2xpcFBhdGguc2hvdWxkQ2FjaGUoKTtcbiAgICAgIGNsaXBQYXRoLl90cmFuc2Zvcm1Eb25lID0gdHJ1ZTtcbiAgICAgIGNsaXBQYXRoLnJlbmRlckNhY2hlKHsgZm9yQ2xpcHBpbmc6IHRydWUgfSk7XG4gICAgICB0aGlzLmRyYXdDbGlwUGF0aE9uQ2FjaGUoY3R4LCBjbGlwUGF0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhaW50IHRoZSBjYWNoZWQgY29weSBvZiB0aGUgb2JqZWN0IG9uIHRoZSB0YXJnZXQgY29udGV4dC5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd0NhY2hlT25DYW52YXM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LnNjYWxlKDEgLyB0aGlzLnpvb21YLCAxIC8gdGhpcy56b29tWSk7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX2NhY2hlQ2FudmFzLCAtdGhpcy5jYWNoZVRyYW5zbGF0aW9uWCwgLXRoaXMuY2FjaGVUcmFuc2xhdGlvblkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjYWNoZSBpcyBkaXJ0eVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcENhbnZhcyBza2lwIGNhbnZhcyBjaGVja3MgYmVjYXVzZSB0aGlzIG9iamVjdCBpcyBwYWludGVkXG4gICAgICogb24gcGFyZW50IGNhbnZhcy5cbiAgICAgKi9cbiAgICBpc0NhY2hlRGlydHk6IGZ1bmN0aW9uKHNraXBDYW52YXMpIHtcbiAgICAgIGlmICh0aGlzLmlzTm90VmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jYWNoZUNhbnZhcyAmJiB0aGlzLl9jYWNoZUNvbnRleHQgJiYgIXNraXBDYW52YXMgJiYgdGhpcy5fdXBkYXRlQ2FjaGVDYW52YXMoKSkge1xuICAgICAgICAvLyBpbiB0aGlzIGNhc2UgdGhlIGNvbnRleHQgaXMgYWxyZWFkeSBjbGVhcmVkLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSB8fFxuICAgICAgICAgICh0aGlzLmNsaXBQYXRoICYmIHRoaXMuY2xpcFBhdGguYWJzb2x1dGVQb3NpdGlvbmVkKSB8fFxuICAgICAgICAgICh0aGlzLnN0YXRlZnVsbENhY2hlICYmIHRoaXMuaGFzU3RhdGVDaGFuZ2VkKCdjYWNoZVByb3BlcnRpZXMnKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NhY2hlQ2FudmFzICYmIHRoaXMuX2NhY2hlQ29udGV4dCAmJiAhc2tpcENhbnZhcykge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5jYWNoZVdpZHRoIC8gdGhpcy56b29tWDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmNhY2hlSGVpZ2h0IC8gdGhpcy56b29tWTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlQ29udGV4dC5jbGVhclJlY3QoLXdpZHRoIC8gMiwgLWhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGJhY2tncm91bmQgZm9yIHRoZSBvYmplY3QgYmlnIGFzIGl0cyB1bnRyYW5zZm9ybWVkIGRpbWVuc2lvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBkaW0gPSB0aGlzLl9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcblxuICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAtZGltLnggLyAyLFxuICAgICAgICAtZGltLnkgLyAyLFxuICAgICAgICBkaW0ueCxcbiAgICAgICAgZGltLnlcbiAgICAgICk7XG4gICAgICAvLyBpZiB0aGVyZSBpcyBiYWNrZ3JvdW5kIGNvbG9yIG5vIG90aGVyIHNoYWRvd3NcbiAgICAgIC8vIHNob3VsZCBiZSBjYXN0ZWRcbiAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfc2V0T3BhY2l0eTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5ncm91cCAmJiAhdGhpcy5ncm91cC5fdHJhbnNmb3JtRG9uZSkge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmdldE9iamVjdE9wYWNpdHkoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0U3Ryb2tlU3R5bGVzOiBmdW5jdGlvbihjdHgsIGRlY2wpIHtcbiAgICAgIHZhciBzdHJva2UgPSBkZWNsLnN0cm9rZTtcbiAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGRlY2wuc3Ryb2tlV2lkdGg7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gZGVjbC5zdHJva2VMaW5lQ2FwO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkZWNsLnN0cm9rZURhc2hPZmZzZXQ7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IGRlY2wuc3Ryb2tlTGluZUpvaW47XG4gICAgICAgIGN0eC5taXRlckxpbWl0ID0gZGVjbC5zdHJva2VNaXRlckxpbWl0O1xuICAgICAgICBpZiAoc3Ryb2tlLnRvTGl2ZSkge1xuICAgICAgICAgIGlmIChzdHJva2UuZ3JhZGllbnRVbml0cyA9PT0gJ3BlcmNlbnRhZ2UnIHx8IHN0cm9rZS5ncmFkaWVudFRyYW5zZm9ybSB8fCBzdHJva2UucGF0dGVyblRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFuc2Zvcm0gZ3JhZGllbnQgaW4gYSBwYXR0ZXJuLlxuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHNsb3cgcHJvY2Vzcy4gSWYgeW91IGFyZSBoaXR0aW5nIHRoaXMgY29kZXBhdGgsIGFuZCB0aGUgb2JqZWN0XG4gICAgICAgICAgICAvLyBpcyBub3QgdXNpbmcgY2FjaGluZywgeW91IHNob3VsZCBjb25zaWRlciBzd2l0Y2hpbmcgaXQgb24uXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIGEgY2FudmFzIGFzIGJpZyBhcyB0aGUgY3VycmVudCBvYmplY3QgY2FjaGluZyBjYW52YXMuXG4gICAgICAgICAgICB0aGlzLl9hcHBseVBhdHRlcm5Gb3JUcmFuc2Zvcm1lZEdyYWRpZW50KGN0eCwgc3Ryb2tlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpcyBhIHNpbXBsZSBncmFkaWVudCBvciBwYXR0ZXJuXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2UudG9MaXZlKGN0eCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShjdHgsIHN0cm9rZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGlzIGEgY29sb3JcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBkZWNsLnN0cm9rZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0RmlsbFN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICB2YXIgZmlsbCA9IGRlY2wuZmlsbDtcbiAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgIGlmIChmaWxsLnRvTGl2ZSkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLnRvTGl2ZShjdHgsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKGN0eCwgZGVjbC5maWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0Q2xpcHBpbmdQcm9wZXJ0aWVzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjMDAwMDAwJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBTZXRzIGxpbmUgZGFzaFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBzZXQgdGhlIGRhc2ggbGluZSBvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhc2hBcnJheSBhcnJheSByZXByZXNlbnRpbmcgZGFzaGVzXG4gICAgICovXG4gICAgX3NldExpbmVEYXNoOiBmdW5jdGlvbihjdHgsIGRhc2hBcnJheSkge1xuICAgICAgaWYgKCFkYXNoQXJyYXkgfHwgZGFzaEFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBTcGVjIHJlcXVpcmVzIHRoZSBjb25jYXRlbmF0aW9uIG9mIHR3byBjb3BpZXMgdGhlIGRhc2ggbGlzdCB3aGVuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaXMgb2RkXG4gICAgICBpZiAoMSAmIGRhc2hBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgZGFzaEFycmF5LnB1c2guYXBwbHkoZGFzaEFycmF5LCBkYXNoQXJyYXkpO1xuICAgICAgfVxuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgY29udHJvbHMgYW5kIGJvcmRlcnMgZm9yIHRoZSBvYmplY3RcbiAgICAgKiB0aGUgY29udGV4dCBoZXJlIGlzIG5vdCB0cmFuc2Zvcm1lZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlT3ZlcnJpZGVdIHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqL1xuICAgIF9yZW5kZXJDb250cm9sczogZnVuY3Rpb24oY3R4LCBzdHlsZU92ZXJyaWRlKSB7XG4gICAgICB2YXIgdnB0ID0gdGhpcy5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpLFxuICAgICAgICAgIG1hdHJpeCA9IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAgIG9wdGlvbnMsIGRyYXdCb3JkZXJzLCBkcmF3Q29udHJvbHM7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7IH07XG4gICAgICBkcmF3Qm9yZGVycyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLmhhc0JvcmRlcnMgIT09ICd1bmRlZmluZWQnID8gc3R5bGVPdmVycmlkZS5oYXNCb3JkZXJzIDogdGhpcy5oYXNCb3JkZXJzO1xuICAgICAgZHJhd0NvbnRyb2xzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgIT09ICd1bmRlZmluZWQnID8gc3R5bGVPdmVycmlkZS5oYXNDb250cm9scyA6IHRoaXMuaGFzQ29udHJvbHM7XG4gICAgICBtYXRyaXggPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKHZwdCwgbWF0cml4KTtcbiAgICAgIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5xckRlY29tcG9zZShtYXRyaXgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUob3B0aW9ucy50cmFuc2xhdGVYLCBvcHRpb25zLnRyYW5zbGF0ZVkpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDEgKiB0aGlzLmJvcmRlclNjYWxlRmFjdG9yO1xuICAgICAgaWYgKCF0aGlzLmdyb3VwKSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuaXNNb3ZpbmcgPyB0aGlzLmJvcmRlck9wYWNpdHlXaGVuTW92aW5nIDogMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZsaXBYKSB7XG4gICAgICAgIG9wdGlvbnMuYW5nbGUgLT0gMTgwO1xuICAgICAgfVxuICAgICAgY3R4LnJvdGF0ZShkZWdyZWVzVG9SYWRpYW5zKHRoaXMuZ3JvdXAgPyBvcHRpb25zLmFuZ2xlIDogdGhpcy5hbmdsZSkpO1xuICAgICAgaWYgKHN0eWxlT3ZlcnJpZGUuZm9yQWN0aXZlU2VsZWN0aW9uIHx8IHRoaXMuZ3JvdXApIHtcbiAgICAgICAgZHJhd0JvcmRlcnMgJiYgdGhpcy5kcmF3Qm9yZGVyc0luR3JvdXAoY3R4LCBvcHRpb25zLCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkcmF3Qm9yZGVycyAmJiB0aGlzLmRyYXdCb3JkZXJzKGN0eCwgc3R5bGVPdmVycmlkZSk7XG4gICAgICB9XG4gICAgICBkcmF3Q29udHJvbHMgJiYgdGhpcy5kcmF3Q29udHJvbHMoY3R4LCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9zZXRTaGFkb3c6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnNoYWRvdykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzaGFkb3cgPSB0aGlzLnNoYWRvdywgY2FudmFzID0gdGhpcy5jYW52YXMsIHNjYWxpbmcsXG4gICAgICAgICAgbXVsdFggPSAoY2FudmFzICYmIGNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybVswXSkgfHwgMSxcbiAgICAgICAgICBtdWx0WSA9IChjYW52YXMgJiYgY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtWzNdKSB8fCAxO1xuICAgICAgaWYgKHNoYWRvdy5ub25TY2FsaW5nKSB7XG4gICAgICAgIHNjYWxpbmcgPSB7IHNjYWxlWDogMSwgc2NhbGVZOiAxIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2NhbGluZyA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbnZhcyAmJiBjYW52YXMuX2lzUmV0aW5hU2NhbGluZygpKSB7XG4gICAgICAgIG11bHRYICo9IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICBtdWx0WSAqPSBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIH1cbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvdy5jb2xvcjtcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gc2hhZG93LmJsdXIgKiBmYWJyaWMuYnJvd3NlclNoYWRvd0JsdXJDb25zdGFudCAqXG4gICAgICAgIChtdWx0WCArIG11bHRZKSAqIChzY2FsaW5nLnNjYWxlWCArIHNjYWxpbmcuc2NhbGVZKSAvIDQ7XG4gICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHNoYWRvdy5vZmZzZXRYICogbXVsdFggKiBzY2FsaW5nLnNjYWxlWDtcbiAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gc2hhZG93Lm9mZnNldFkgKiBtdWx0WSAqIHNjYWxpbmcuc2NhbGVZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zaGFkb3cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdHguc2hhZG93Q29sb3IgPSAnJztcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gY3R4LnNoYWRvd09mZnNldFggPSBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWxsZXIgZmFicmljLlBhdHRlcm4gb3IgZmFicmljLkdyYWRpZW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvZmZzZXQub2Zmc2V0WCBvZmZzZXQgZm9yIHRleHQgcmVuZGVyaW5nXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvZmZzZXQub2Zmc2V0WSBvZmZzZXQgZm9yIHRleHQgcmVuZGVyaW5nXG4gICAgICovXG4gICAgX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtOiBmdW5jdGlvbihjdHgsIGZpbGxlcikge1xuICAgICAgaWYgKCFmaWxsZXIgfHwgIWZpbGxlci50b0xpdmUpIHtcbiAgICAgICAgcmV0dXJuIHsgb2Zmc2V0WDogMCwgb2Zmc2V0WTogMCB9O1xuICAgICAgfVxuICAgICAgdmFyIHQgPSBmaWxsZXIuZ3JhZGllbnRUcmFuc2Zvcm0gfHwgZmlsbGVyLnBhdHRlcm5UcmFuc2Zvcm07XG4gICAgICB2YXIgb2Zmc2V0WCA9IC10aGlzLndpZHRoIC8gMiArIGZpbGxlci5vZmZzZXRYIHx8IDAsXG4gICAgICAgICAgb2Zmc2V0WSA9IC10aGlzLmhlaWdodCAvIDIgKyBmaWxsZXIub2Zmc2V0WSB8fCAwO1xuXG4gICAgICBpZiAoZmlsbGVyLmdyYWRpZW50VW5pdHMgPT09ICdwZXJjZW50YWdlJykge1xuICAgICAgICBjdHgudHJhbnNmb3JtKHRoaXMud2lkdGgsIDAsIDAsIHRoaXMuaGVpZ2h0LCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHgudHJhbnNmb3JtKDEsIDAsIDAsIDEsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgfVxuICAgICAgaWYgKHQpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSh0WzBdLCB0WzFdLCB0WzJdLCB0WzNdLCB0WzRdLCB0WzVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG9mZnNldFg6IG9mZnNldFgsIG9mZnNldFk6IG9mZnNldFkgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclBhaW50SW5PcmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ID09PSAnc3Ryb2tlJykge1xuICAgICAgICB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyRmlsbChjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckZpbGwoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogZnVuY3Rpb24gdGhhdCBhY3R1YWxseSByZW5kZXIgc29tZXRoaW5nIG9uIHRoZSBjb250ZXh0LlxuICAgICAqIGVtcHR5IGhlcmUgdG8gYWxsb3cgT2JlY3RzIHRvIHdvcmsgb24gdGVzdHMgdG8gYmVuY2htYXJrIGZhYnJpYyBmdW5jdGlvbmFsaXRlc1xuICAgICAqIG5vdCByZWxhdGVkIHRvIHJlbmRlcmluZ1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbigvKiBjdHggKi8pIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyRmlsbDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuZmlsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXRGaWxsU3R5bGVzKGN0eCwgdGhpcyk7XG4gICAgICBpZiAodGhpcy5maWxsUnVsZSA9PT0gJ2V2ZW5vZGQnKSB7XG4gICAgICAgIGN0eC5maWxsKCdldmVub2RkJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hhZG93ICYmICF0aGlzLnNoYWRvdy5hZmZlY3RTdHJva2UpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBpZiAodGhpcy5zdHJva2VVbmlmb3JtICYmIHRoaXMuZ3JvdXApIHtcbiAgICAgICAgdmFyIHNjYWxpbmcgPSB0aGlzLmdldE9iamVjdFNjYWxpbmcoKTtcbiAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsaW5nLnNjYWxlWCwgMSAvIHNjYWxpbmcuc2NhbGVZKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc3Ryb2tlVW5pZm9ybSkge1xuICAgICAgICBjdHguc2NhbGUoMSAvIHRoaXMuc2NhbGVYLCAxIC8gdGhpcy5zY2FsZVkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICB0aGlzLl9zZXRTdHJva2VTdHlsZXMoY3R4LCB0aGlzKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gdHJ5IHRvIHBhdGNoIHRoZSBtaXNzaW5nIGdyYWRpZW50VHJhbnNmb3JtIG9uIGNhbnZhcyBncmFkaWVudHMuXG4gICAgICogdHJhbnNmb3JtaW5nIGEgY29udGV4dCB0byB0cmFuc2Zvcm0gdGhlIGdyYWRpZW50LCBpcyBnb2luZyB0byB0cmFuc2Zvcm0gdGhlIHN0cm9rZSB0b28uXG4gICAgICogd2Ugd2FudCB0byB0cmFuc2Zvcm0gdGhlIGdyYWRpZW50IGJ1dCBub3QgdGhlIHN0cm9rZSBvcGVyYXRpb24sIHNvIHdlIGNyZWF0ZVxuICAgICAqIGEgdHJhbnNmb3JtZWQgZ3JhZGllbnQgb24gYSBwYXR0ZXJuIGFuZCB0aGVuIHdlIHVzZSB0aGUgcGF0dGVybiBpbnN0ZWFkIG9mIHRoZSBncmFkaWVudC5cbiAgICAgKiB0aGlzIG1ldGhvZCBoYXMgZHJ3YWJhY2tzOiBpcyBzbG93LCBpcyBpbiBsb3cgcmVzb2x1dGlvbiwgbmVlZHMgYSBwYXRjaCBmb3Igd2hlbiB0aGUgc2l6ZVxuICAgICAqIGlzIGxpbWl0ZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtmYWJyaWMuR3JhZGllbnR9IGZpbGxlciBhIGZhYnJpYyBncmFkaWVudCBpbnN0YW5jZVxuICAgICAqL1xuICAgIF9hcHBseVBhdHRlcm5Gb3JUcmFuc2Zvcm1lZEdyYWRpZW50OiBmdW5jdGlvbihjdHgsIGZpbGxlcikge1xuICAgICAgdmFyIGRpbXMgPSB0aGlzLl9saW1pdENhY2hlU2l6ZSh0aGlzLl9nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnMoKSksXG4gICAgICAgICAgcENhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSwgcEN0eCwgcmV0aW5hU2NhbGluZyA9IHRoaXMuY2FudmFzLmdldFJldGluYVNjYWxpbmcoKSxcbiAgICAgICAgICB3aWR0aCA9IGRpbXMueCAvIHRoaXMuc2NhbGVYIC8gcmV0aW5hU2NhbGluZywgaGVpZ2h0ID0gZGltcy55IC8gdGhpcy5zY2FsZVkgLyByZXRpbmFTY2FsaW5nO1xuICAgICAgcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgcENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBwQ3R4ID0gcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgcEN0eC5iZWdpblBhdGgoKTsgcEN0eC5tb3ZlVG8oMCwgMCk7IHBDdHgubGluZVRvKHdpZHRoLCAwKTsgcEN0eC5saW5lVG8od2lkdGgsIGhlaWdodCk7XG4gICAgICBwQ3R4LmxpbmVUbygwLCBoZWlnaHQpOyBwQ3R4LmNsb3NlUGF0aCgpO1xuICAgICAgcEN0eC50cmFuc2xhdGUod2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICAgIHBDdHguc2NhbGUoXG4gICAgICAgIGRpbXMuem9vbVggLyB0aGlzLnNjYWxlWCAvIHJldGluYVNjYWxpbmcsXG4gICAgICAgIGRpbXMuem9vbVkgLyB0aGlzLnNjYWxlWSAvIHJldGluYVNjYWxpbmdcbiAgICAgICk7XG4gICAgICB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShwQ3R4LCBmaWxsZXIpO1xuICAgICAgcEN0eC5maWxsU3R5bGUgPSBmaWxsZXIudG9MaXZlKGN0eCk7XG4gICAgICBwQ3R4LmZpbGwoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoLXRoaXMud2lkdGggLyAyIC0gdGhpcy5zdHJva2VXaWR0aCAvIDIsIC10aGlzLmhlaWdodCAvIDIgLSB0aGlzLnN0cm9rZVdpZHRoIC8gMik7XG4gICAgICBjdHguc2NhbGUoXG4gICAgICAgIHJldGluYVNjYWxpbmcgKiB0aGlzLnNjYWxlWCAvIGRpbXMuem9vbVgsXG4gICAgICAgIHJldGluYVNjYWxpbmcgKiB0aGlzLnNjYWxlWSAvIGRpbXMuem9vbVlcbiAgICAgICk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBwQ3R4LmNyZWF0ZVBhdHRlcm4ocENhbnZhcywgJ25vLXJlcGVhdCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGhlbHBlciBmb3Igc3ZnIGltcG9ydC4gaXQgcmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBvYmplY3QgaW4gdGhlIHN2Z1xuICAgICAqIHVudHJhbnNmb3JtZWQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIHBvaW50IGZyb20gZWxlbWVudCBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIF9maW5kQ2VudGVyRnJvbUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHsgeDogdGhpcy5sZWZ0ICsgdGhpcy53aWR0aCAvIDIsIHk6IHRoaXMudG9wICsgdGhpcy5oZWlnaHQgLyAyIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYW4gaGVscGVyIGZvciBzdmcgaW1wb3J0LiBpdCBkZWNvbXBvc2UgdGhlIHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIGFuZCBhc3NpZ24gcHJvcGVydGllcyB0byBvYmplY3QuXG4gICAgICogdW50cmFuc2Zvcm1lZCBjb29yZGluYXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9hc3NpZ25UcmFuc2Zvcm1NYXRyaXhQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5xckRlY29tcG9zZSh0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICAgIHRoaXMuZmxpcFggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mbGlwWSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldCgnc2NhbGVYJywgb3B0aW9ucy5zY2FsZVgpO1xuICAgICAgICB0aGlzLnNldCgnc2NhbGVZJywgb3B0aW9ucy5zY2FsZVkpO1xuICAgICAgICB0aGlzLmFuZ2xlID0gb3B0aW9ucy5hbmdsZTtcbiAgICAgICAgdGhpcy5za2V3WCA9IG9wdGlvbnMuc2tld1g7XG4gICAgICAgIHRoaXMuc2tld1kgPSAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGhlbHBlciBmb3Igc3ZnIGltcG9ydC4gaXQgcmVtb3ZlcyB0aGUgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqIGFuZCBzZXQgdG8gb2JqZWN0IHByb3BlcnRpZXMgdGhhdCBmYWJyaWNqcyBjYW4gaGFuZGxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHt0aGlzQXJnfVxuICAgICAqL1xuICAgIF9yZW1vdmVUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zKSB7XG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5fZmluZENlbnRlckZyb21FbGVtZW50KCk7XG4gICAgICBpZiAodGhpcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgdGhpcy5fYXNzaWduVHJhbnNmb3JtTWF0cml4UHJvcHMoKTtcbiAgICAgICAgY2VudGVyID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoY2VudGVyLCB0aGlzLnRyYW5zZm9ybU1hdHJpeCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IG51bGw7XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zY2FsZVggKj0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuc2NhbGVYO1xuICAgICAgICB0aGlzLnNjYWxlWSAqPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5zY2FsZVk7XG4gICAgICAgIHRoaXMuY3JvcFggPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5jcm9wWDtcbiAgICAgICAgdGhpcy5jcm9wWSA9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLmNyb3BZO1xuICAgICAgICBjZW50ZXIueCArPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5vZmZzZXRMZWZ0O1xuICAgICAgICBjZW50ZXIueSArPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5vZmZzZXRUb3A7XG4gICAgICAgIHRoaXMud2lkdGggPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5oZWlnaHQ7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFBvc2l0aW9uQnlPcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgYW4gaW5zdGFuY2UsIHVzaW5nIGEgY2FsbGJhY2sgbWV0aG9kIHdpbGwgd29yayBmb3IgZXZlcnkgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGlzIGludm9rZWQgd2l0aCBhIGNsb25lIGFzIGEgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgb2JqZWN0Rm9ybSA9IHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5mcm9tT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuZnJvbU9iamVjdChvYmplY3RGb3JtLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnT2JqZWN0Jywgb2JqZWN0Rm9ybSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBvdXQgb2YgYW4gb2JqZWN0XG4gICAgICogbWFrZXMgdXNlIG9mIHRvQ2FudmFzRWxlbWVudC5cbiAgICAgKiBPbmNlIHRoaXMgbWV0aG9kIHdhcyBiYXNlZCBvbiB0b0RhdGFVcmwgYW5kIGxvYWRJbWFnZSwgc28gaXQgYWxzbyBoYWQgYSBxdWFsaXR5XG4gICAgICogYW5kIGZvcm1hdCBvcHRpb24uIHRvQ2FudmFzRWxlbWVudCBpcyBmYXN0ZXIgYW5kIHByb2R1Y2Ugbm8gbG9zcyBvZiBxdWFsaXR5LlxuICAgICAqIElmIHlvdSBuZWVkIHRvIGdldCBhIHJlYWwgSnBlZyBvciBQbmcgZnJvbSBhbiBvYmplY3QsIHVzaW5nIHRvRGF0YVVSTCBpcyB0aGUgcmlnaHQgd2F5IHRvIGRvIGl0LlxuICAgICAqIHRvQ2FudmFzRWxlbWVudCBhbmQgdGhlbiB0b0Jsb2IgZnJvbSB0aGUgb2J0YWluZWQgY2FudmFzIGlzIGFsc28gYSBnb29kIG9wdGlvbi5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzeW5jIG5vdywgYnV0IHN0aWxsIHN1cHBvcnQgdGhlIGNhbGxiYWNrIGJlY2F1c2Ugd2UgZGlkIG5vdCB3YW50IHRvIGJyZWFrLlxuICAgICAqIFdoZW4gZmFicmljSlMgNS4wIHdpbGwgYmUgcGxhbm5lZCwgdGhpcyB3aWxsIHByb2JhYmx5IGJlIGNoYW5nZWQgdG8gbm90IGhhdmUgYSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjaywgaW52b2tlZCB3aXRoIGFuIGluc3RhbmNlIGFzIGEgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIGZvciBjbG9uZSBhcyBpbWFnZSwgcGFzc2VkIHRvIHRvRGF0YVVSTFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tdWx0aXBsaWVyPTFdIE11bHRpcGxpZXIgdG8gc2NhbGUgYnlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGVmdF0gQ3JvcHBpbmcgbGVmdCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50b3BdIENyb3BwaW5nIHRvcCBvZmZzZXQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aF0gQ3JvcHBpbmcgd2lkdGguIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIENyb3BwaW5nIGhlaWdodC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nXSBFbmFibGUgcmV0aW5hIHNjYWxpbmcgZm9yIGNsb25lIGltYWdlLiBJbnRyb2R1Y2UgaW4gMS42LjRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRUcmFuc2Zvcm1dIFJlbW92ZSBjdXJyZW50IG9iamVjdCB0cmFuc2Zvcm0gKCBubyBzY2FsZSAsIG5vIGFuZ2xlLCBubyBmbGlwLCBubyBza2V3ICkuIEludHJvZHVjZWQgaW4gMi4zLjRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhvdXRTaGFkb3ddIFJlbW92ZSBjdXJyZW50IG9iamVjdCBzaGFkb3cuIEludHJvZHVjZWQgaW4gMi40LjJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgY2xvbmVBc0ltYWdlOiBmdW5jdGlvbihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgdmFyIGNhbnZhc0VsID0gdGhpcy50b0NhbnZhc0VsZW1lbnQob3B0aW9ucyk7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IGZhYnJpYy5JbWFnZShjYW52YXNFbCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgSFRNTENhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubXVsdGlwbGllcj0xXSBNdWx0aXBsaWVyIHRvIHNjYWxlIGJ5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxlZnRdIENyb3BwaW5nIGxlZnQgb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG9wXSBDcm9wcGluZyB0b3Agb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGhdIENyb3BwaW5nIHdpZHRoLiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBDcm9wcGluZyBoZWlnaHQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZ10gRW5hYmxlIHJldGluYSBzY2FsaW5nIGZvciBjbG9uZSBpbWFnZS4gSW50cm9kdWNlIGluIDEuNi40XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0VHJhbnNmb3JtXSBSZW1vdmUgY3VycmVudCBvYmplY3QgdHJhbnNmb3JtICggbm8gc2NhbGUgLCBubyBhbmdsZSwgbm8gZmxpcCwgbm8gc2tldyApLiBJbnRyb2R1Y2VkIGluIDIuMy40XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0U2hhZG93XSBSZW1vdmUgY3VycmVudCBvYmplY3Qgc2hhZG93LiBJbnRyb2R1Y2VkIGluIDIuNC4yXG4gICAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IFJldHVybnMgRE9NIGVsZW1lbnQgPGNhbnZhcz4gd2l0aCB0aGUgZmFicmljLk9iamVjdFxuICAgICAqL1xuICAgIHRvQ2FudmFzRWxlbWVudDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICAgIHZhciB1dGlscyA9IGZhYnJpYy51dGlsLCBvcmlnUGFyYW1zID0gdXRpbHMuc2F2ZU9iamVjdFRyYW5zZm9ybSh0aGlzKSxcbiAgICAgICAgICBvcmlnaW5hbEdyb3VwID0gdGhpcy5ncm91cCxcbiAgICAgICAgICBvcmlnaW5hbFNoYWRvdyA9IHRoaXMuc2hhZG93LCBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICBtdWx0aXBsaWVyID0gKG9wdGlvbnMubXVsdGlwbGllciB8fCAxKSAqIChvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmcgPyBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbyA6IDEpO1xuICAgICAgZGVsZXRlIHRoaXMuZ3JvdXA7XG4gICAgICBpZiAob3B0aW9ucy53aXRob3V0VHJhbnNmb3JtKSB7XG4gICAgICAgIHV0aWxzLnJlc2V0T2JqZWN0VHJhbnNmb3JtKHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMud2l0aG91dFNoYWRvdykge1xuICAgICAgICB0aGlzLnNoYWRvdyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcbiAgICAgICAgICAvLyBza2lwIGNhbnZhcyB6b29tIGFuZCBjYWxjdWxhdGUgd2l0aCBzZXRDb29yZHMgbm93LlxuICAgICAgICAgIGJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KHRydWUsIHRydWUpLFxuICAgICAgICAgIHNoYWRvdyA9IHRoaXMuc2hhZG93LCBzY2FsaW5nLFxuICAgICAgICAgIHNoYWRvd09mZnNldCA9IHsgeDogMCwgeTogMCB9LCBzaGFkb3dCbHVyLFxuICAgICAgICAgIHdpZHRoLCBoZWlnaHQ7XG5cbiAgICAgIGlmIChzaGFkb3cpIHtcbiAgICAgICAgc2hhZG93Qmx1ciA9IHNoYWRvdy5ibHVyO1xuICAgICAgICBpZiAoc2hhZG93Lm5vblNjYWxpbmcpIHtcbiAgICAgICAgICBzY2FsaW5nID0geyBzY2FsZVg6IDEsIHNjYWxlWTogMSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNjYWxpbmcgPSB0aGlzLmdldE9iamVjdFNjYWxpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zaWRlciBub24gc2NhbGluZyBzaGFkb3cuXG4gICAgICAgIHNoYWRvd09mZnNldC54ID0gMiAqIE1hdGgucm91bmQoYWJzKHNoYWRvdy5vZmZzZXRYKSArIHNoYWRvd0JsdXIpICogKGFicyhzY2FsaW5nLnNjYWxlWCkpO1xuICAgICAgICBzaGFkb3dPZmZzZXQueSA9IDIgKiBNYXRoLnJvdW5kKGFicyhzaGFkb3cub2Zmc2V0WSkgKyBzaGFkb3dCbHVyKSAqIChhYnMoc2NhbGluZy5zY2FsZVkpKTtcbiAgICAgIH1cbiAgICAgIHdpZHRoID0gYm91bmRpbmdSZWN0LndpZHRoICsgc2hhZG93T2Zmc2V0Lng7XG4gICAgICBoZWlnaHQgPSBib3VuZGluZ1JlY3QuaGVpZ2h0ICsgc2hhZG93T2Zmc2V0Lnk7XG4gICAgICAvLyBpZiB0aGUgY3VycmVudCB3aWR0aC9oZWlnaHQgaXMgbm90IGFuIGludGVnZXJcbiAgICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBpdCBzby5cbiAgICAgIGVsLndpZHRoID0gTWF0aC5jZWlsKHdpZHRoKTtcbiAgICAgIGVsLmhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQpO1xuICAgICAgdmFyIGNhbnZhcyA9IG5ldyBmYWJyaWMuU3RhdGljQ2FudmFzKGVsLCB7XG4gICAgICAgIGVuYWJsZVJldGluYVNjYWxpbmc6IGZhbHNlLFxuICAgICAgICByZW5kZXJPbkFkZFJlbW92ZTogZmFsc2UsXG4gICAgICAgIHNraXBPZmZzY3JlZW46IGZhbHNlLFxuICAgICAgfSk7XG4gICAgICBpZiAob3B0aW9ucy5mb3JtYXQgPT09ICdqcGVnJykge1xuICAgICAgICBjYW52YXMuYmFja2dyb3VuZENvbG9yID0gJyNmZmYnO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRQb3NpdGlvbkJ5T3JpZ2luKG5ldyBmYWJyaWMuUG9pbnQoY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIpLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuXG4gICAgICB2YXIgb3JpZ2luYWxDYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIGNhbnZhcy5hZGQodGhpcyk7XG4gICAgICB2YXIgY2FudmFzRWwgPSBjYW52YXMudG9DYW52YXNFbGVtZW50KG11bHRpcGxpZXIgfHwgMSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNoYWRvdyA9IG9yaWdpbmFsU2hhZG93O1xuICAgICAgdGhpcy5zZXQoJ2NhbnZhcycsIG9yaWdpbmFsQ2FudmFzKTtcbiAgICAgIGlmIChvcmlnaW5hbEdyb3VwKSB7XG4gICAgICAgIHRoaXMuZ3JvdXAgPSBvcmlnaW5hbEdyb3VwO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXQob3JpZ1BhcmFtcykuc2V0Q29vcmRzKCk7XG4gICAgICAvLyBjYW52YXMuZGlzcG9zZSB3aWxsIGNhbGwgaW1hZ2UuZGlzcG9zZSB0aGF0IHdpbGwgbnVsbGlmeSB0aGUgZWxlbWVudHNcbiAgICAgIC8vIHNpbmNlIHRoaXMgY2FudmFzIGlzIGEgc2ltcGxlIGVsZW1lbnQgZm9yIHRoZSBwcm9jZXNzLCB3ZSByZW1vdmUgcmVmZXJlbmNlc1xuICAgICAgLy8gdG8gb2JqZWN0cyBpbiB0aGlzIHdheSBpbiBvcmRlciB0byBhdm9pZCBvYmplY3QgdHJhc2hpbmcuXG4gICAgICBjYW52YXMuX29iamVjdHMgPSBbXTtcbiAgICAgIGNhbnZhcy5kaXNwb3NlKCk7XG4gICAgICBjYW52YXMgPSBudWxsO1xuXG4gICAgICByZXR1cm4gY2FudmFzRWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgZGF0YS11cmwtbGlrZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5mb3JtYXQ9cG5nXSBUaGUgZm9ybWF0IG9mIHRoZSBvdXRwdXQgaW1hZ2UuIEVpdGhlciBcImpwZWdcIiBvciBcInBuZ1wiXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnF1YWxpdHk9MV0gUXVhbGl0eSBsZXZlbCAoMC4uMSkuIE9ubHkgdXNlZCBmb3IganBlZy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubXVsdGlwbGllcj0xXSBNdWx0aXBsaWVyIHRvIHNjYWxlIGJ5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxlZnRdIENyb3BwaW5nIGxlZnQgb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG9wXSBDcm9wcGluZyB0b3Agb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGhdIENyb3BwaW5nIHdpZHRoLiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBDcm9wcGluZyBoZWlnaHQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZ10gRW5hYmxlIHJldGluYSBzY2FsaW5nIGZvciBjbG9uZSBpbWFnZS4gSW50cm9kdWNlIGluIDEuNi40XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0VHJhbnNmb3JtXSBSZW1vdmUgY3VycmVudCBvYmplY3QgdHJhbnNmb3JtICggbm8gc2NhbGUgLCBubyBhbmdsZSwgbm8gZmxpcCwgbm8gc2tldyApLiBJbnRyb2R1Y2VkIGluIDIuMy40XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0U2hhZG93XSBSZW1vdmUgY3VycmVudCBvYmplY3Qgc2hhZG93LiBJbnRyb2R1Y2VkIGluIDIuNC4yXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBSZXR1cm5zIGEgZGF0YTogVVJMIGNvbnRhaW5pbmcgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0IGluIHRoZSBmb3JtYXQgc3BlY2lmaWVkIGJ5IG9wdGlvbnMuZm9ybWF0XG4gICAgICovXG4gICAgdG9EYXRhVVJMOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC50b0RhdGFVUkwodGhpcy50b0NhbnZhc0VsZW1lbnQob3B0aW9ucyksIG9wdGlvbnMuZm9ybWF0IHx8ICdwbmcnLCBvcHRpb25zLnF1YWxpdHkgfHwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBzcGVjaWZpZWQgdHlwZSBpcyBpZGVudGljYWwgdG8gdGhlIHR5cGUgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIHRvIGNoZWNrIGFnYWluc3RcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gQXJyYXkuZnJvbShhcmd1bWVudHMpLmluY2x1ZGVzKHRoaXMudHlwZSkgOiB0aGlzLnR5cGUgPT09IHR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlIChpcyAxIHVubGVzcyBzdWJjbGFzc2VkKVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gSlNPTlxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgLy8gZGVsZWdhdGUsIG5vdCBhbGlhc1xuICAgICAgcmV0dXJuIHRoaXMudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgXCJhbmdsZVwiIG9mIGFuIGluc3RhbmNlIHdpdGggY2VudGVyZWQgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgQW5nbGUgdmFsdWUgKGluIGRlZ3JlZXMpXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICB2YXIgc2hvdWxkQ2VudGVyT3JpZ2luID0gKHRoaXMub3JpZ2luWCAhPT0gJ2NlbnRlcicgfHwgdGhpcy5vcmlnaW5ZICE9PSAnY2VudGVyJykgJiYgdGhpcy5jZW50ZXJlZFJvdGF0aW9uO1xuXG4gICAgICBpZiAoc2hvdWxkQ2VudGVyT3JpZ2luKSB7XG4gICAgICAgIHRoaXMuX3NldE9yaWdpblRvQ2VudGVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0KCdhbmdsZScsIGFuZ2xlKTtcblxuICAgICAgaWYgKHNob3VsZENlbnRlck9yaWdpbikge1xuICAgICAgICB0aGlzLl9yZXNldE9yaWdpbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IG9uIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVySDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuY2VudGVyT2JqZWN0SCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgb24gY3VycmVudCB2aWV3cG9ydCBvZiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVySDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRDZW50ZXJPYmplY3RIKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgb24gY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJWOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jZW50ZXJPYmplY3RWKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgb24gY3VycmVudCB2aWV3cG9ydCBvZiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyVjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRDZW50ZXJPYmplY3RWKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSBvbiBjYW52YXMgdG8gd2hpY2ggaXMgd2FzIGFkZGVkIGxhc3RcbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5jZW50ZXJPYmplY3QodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3Qgb24gY3VycmVudCB2aWV3cG9ydCBvZiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy52aWV3cG9ydENlbnRlck9iamVjdCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnRlciByZWxhdGl2ZSB0byBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IHRvIG9wZXJhdGUgdXBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcG9pbnRlcl0gUG9pbnRlciB0byBvcGVyYXRlIHVwb24gKGluc3RlYWQgb2YgZXZlbnQpXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiBhIHBvaW50ZXIgKHgsIHkpXG4gICAgICovXG4gICAgZ2V0TG9jYWxQb2ludGVyOiBmdW5jdGlvbihlLCBwb2ludGVyKSB7XG4gICAgICBwb2ludGVyID0gcG9pbnRlciB8fCB0aGlzLmNhbnZhcy5nZXRQb2ludGVyKGUpO1xuICAgICAgdmFyIHBDbGlja2VkID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludGVyLngsIHBvaW50ZXIueSksXG4gICAgICAgICAgb2JqZWN0TGVmdFRvcCA9IHRoaXMuX2dldExlZnRUb3BDb29yZHMoKTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHBDbGlja2VkID0gZmFicmljLnV0aWwucm90YXRlUG9pbnQoXG4gICAgICAgICAgcENsaWNrZWQsIG9iamVjdExlZnRUb3AsIGRlZ3JlZXNUb1JhZGlhbnMoLXRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBDbGlja2VkLnggLSBvYmplY3RMZWZ0VG9wLngsXG4gICAgICAgIHk6IHBDbGlja2VkLnkgLSBvYmplY3RMZWZ0VG9wLnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY2FudmFzIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBmb3Igc3BlY2lmaWMgb2JqZWN0XG4gICAgICogY3VzdG9tIGNvbXBvc2l0aW9uIG9wZXJhdGlvbiBmb3IgdGhlIHBhcnRpY3VsYXIgb2JqZWN0IGNhbiBiZSBzcGVjaWZpZWQgdXNpbmcgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBSZW5kZXJpbmcgY2FudmFzIGNvbnRleHRcbiAgICAgKi9cbiAgICBfc2V0dXBDb21wb3NpdGVPcGVyYXRpb246IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgIGlmICh0aGlzLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbikge1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbmNlbCBpbnN0YW5jZSdzIHJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAqIG92ZXJyaWRlIGlmIG5lY2Vzc2FyeSB0byBkaXNwb3NlIGFydGlmYWN0cyBzdWNoIGFzIGBjbGlwUGF0aGBcbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZmFicmljLnJ1bm5pbmdBbmltYXRpb25zKSB7XG4gICAgICAgIGZhYnJpYy5ydW5uaW5nQW5pbWF0aW9ucy5jYW5jZWxCeVRhcmdldCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGZhYnJpYy51dGlsLmNyZWF0ZUFjY2Vzc29ycyAmJiBmYWJyaWMudXRpbC5jcmVhdGVBY2Nlc3NvcnMoZmFicmljLk9iamVjdCk7XG5cbiAgZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCBmYWJyaWMuT2JzZXJ2YWJsZSk7XG5cbiAgLyoqXG4gICAqIERlZmluZXMgdGhlIG51bWJlciBvZiBmcmFjdGlvbiBkaWdpdHMgdG8gdXNlIHdoZW4gc2VyaWFsaXppbmcgb2JqZWN0IHZhbHVlcy5cbiAgICogWW91IGNhbiB1c2UgaXQgdG8gaW5jcmVhc2UvZGVjcmVhc2UgcHJlY2lzaW9uIG9mIHN1Y2ggdmFsdWVzIGxpa2UgbGVmdCwgdG9wLCBzY2FsZVgsIHNjYWxlWSwgZXRjLlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0XG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IDI7XG5cbiAgLyoqXG4gICAqIERlZmluZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgZW5saXZlbmVkIGZyb20gdGhlIG9iamVjdCBwYXNzZWQgdG8ge0BsaW5rIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3R9XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3RcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHN0cmluZ1tdXG4gICAqL1xuICBmYWJyaWMuT2JqZWN0LkVOTElWRU5fUFJPUFMgPSBbJ2NsaXBQYXRoJ107XG5cbiAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCA9IGZ1bmN0aW9uKGNsYXNzTmFtZSwgb2JqZWN0LCBjYWxsYmFjaywgZXh0cmFQYXJhbSkge1xuICAgIHZhciBrbGFzcyA9IGZhYnJpY1tjbGFzc05hbWVdO1xuICAgIG9iamVjdCA9IGNsb25lKG9iamVjdCwgdHJ1ZSk7XG4gICAgZmFicmljLnV0aWwuZW5saXZlblBhdHRlcm5zKFtvYmplY3QuZmlsbCwgb2JqZWN0LnN0cm9rZV0sIGZ1bmN0aW9uKHBhdHRlcm5zKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdHRlcm5zWzBdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvYmplY3QuZmlsbCA9IHBhdHRlcm5zWzBdO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuc1sxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb2JqZWN0LnN0cm9rZSA9IHBhdHRlcm5zWzFdO1xuICAgICAgfVxuICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdEVubGl2YWJsZXMob2JqZWN0LCBvYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZXh0cmFQYXJhbSA/IG5ldyBrbGFzcyhvYmplY3RbZXh0cmFQYXJhbV0sIG9iamVjdCkgOiBuZXcga2xhc3Mob2JqZWN0KTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW5zdGFuY2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuaXF1ZSBpZCB1c2VkIGludGVybmFsbHkgd2hlbiBjcmVhdGluZyBTVkcgZWxlbWVudHNcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdFxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICovXG4gIGZhYnJpYy5PYmplY3QuX191aWQgPSAwO1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBvcmlnaW5YT2Zmc2V0ID0ge1xuICAgICAgICBsZWZ0OiAtMC41LFxuICAgICAgICBjZW50ZXI6IDAsXG4gICAgICAgIHJpZ2h0OiAwLjVcbiAgICAgIH0sXG4gICAgICBvcmlnaW5ZT2Zmc2V0ID0ge1xuICAgICAgICB0b3A6IC0wLjUsXG4gICAgICAgIGNlbnRlcjogMCxcbiAgICAgICAgYm90dG9tOiAwLjVcbiAgICAgIH07XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBjb29yZGluYXRlcyBmcm9tIGEgc2V0IG9mIG9yaWdpbiB0byBhbm90aGVyIChiYXNlZCBvbiB0aGUgb2JqZWN0J3MgZGltZW5zaW9ucylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBvcmlnaW5YIGFuZCBvcmlnaW5ZIHBhcmFtc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tT3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZyb21PcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvT3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvT3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVUb0dpdmVuT3JpZ2luOiBmdW5jdGlvbihwb2ludCwgZnJvbU9yaWdpblgsIGZyb21PcmlnaW5ZLCB0b09yaWdpblgsIHRvT3JpZ2luWSkge1xuICAgICAgdmFyIHggPSBwb2ludC54LFxuICAgICAgICAgIHkgPSBwb2ludC55LFxuICAgICAgICAgIG9mZnNldFgsIG9mZnNldFksIGRpbTtcblxuICAgICAgaWYgKHR5cGVvZiBmcm9tT3JpZ2luWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnJvbU9yaWdpblggPSBvcmlnaW5YT2Zmc2V0W2Zyb21PcmlnaW5YXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmcm9tT3JpZ2luWCAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdG9PcmlnaW5YID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b09yaWdpblggPSBvcmlnaW5YT2Zmc2V0W3RvT3JpZ2luWF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdG9PcmlnaW5YIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0WCA9IHRvT3JpZ2luWCAtIGZyb21PcmlnaW5YO1xuXG4gICAgICBpZiAodHlwZW9mIGZyb21PcmlnaW5ZID09PSAnc3RyaW5nJykge1xuICAgICAgICBmcm9tT3JpZ2luWSA9IG9yaWdpbllPZmZzZXRbZnJvbU9yaWdpblldO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZyb21PcmlnaW5ZIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0b09yaWdpblkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRvT3JpZ2luWSA9IG9yaWdpbllPZmZzZXRbdG9PcmlnaW5ZXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0b09yaWdpblkgLT0gMC41O1xuICAgICAgfVxuXG4gICAgICBvZmZzZXRZID0gdG9PcmlnaW5ZIC0gZnJvbU9yaWdpblk7XG5cbiAgICAgIGlmIChvZmZzZXRYIHx8IG9mZnNldFkpIHtcbiAgICAgICAgZGltID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG4gICAgICAgIHggPSBwb2ludC54ICsgb2Zmc2V0WCAqIGRpbS54O1xuICAgICAgICB5ID0gcG9pbnQueSArIG9mZnNldFkgKiBkaW0ueTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZXMgdGhlIGNvb3JkaW5hdGVzIGZyb20gb3JpZ2luIHRvIGNlbnRlciBjb29yZGluYXRlcyAoYmFzZWQgb24gdGhlIG9iamVjdCdzIGRpbWVuc2lvbnMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luWCBhbmQgb3JpZ2luWSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdHJhbnNsYXRlVG9DZW50ZXJQb2ludDogZnVuY3Rpb24ocG9pbnQsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBwID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHAsIHBvaW50LCBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBjb29yZGluYXRlcyBmcm9tIGNlbnRlciB0byBvcmlnaW4gY29vcmRpbmF0ZXMgKGJhc2VkIG9uIHRoZSBvYmplY3QncyBkaW1lbnNpb25zKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBjZW50ZXIgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIGNlbnRlciBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQ6IGZ1bmN0aW9uKGNlbnRlciwgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIHAgPSB0aGlzLnRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicsIG9yaWdpblgsIG9yaWdpblkpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHAsIGNlbnRlciwgZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVhbCBjZW50ZXIgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVmdFRvcCA9IG5ldyBmYWJyaWMuUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCk7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb0NlbnRlclBvaW50KGxlZnRUb3AsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBiYXNlZCBvbiBjZW50ZXIgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBvcmlnaW5YIGFuZCBvcmlnaW5ZIHBhcmFtc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICAvLyBnZXRPcmlnaW5Qb2ludDogZnVuY3Rpb24oY2VudGVyKSB7XG4gICAgLy8gICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlciwgdGhpcy5vcmlnaW5YLCB0aGlzLm9yaWdpblkpO1xuICAgIC8vIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGFzIGlmIGl0IGhhcyBhIGRpZmZlcmVudCBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgZ2V0UG9pbnRCeU9yaWdpbjogZnVuY3Rpb24ob3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoY2VudGVyLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgaW4gbG9jYWwgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgVGhlIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBnbG9iYWwgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdG9Mb2NhbFBvaW50OiBmdW5jdGlvbihwb2ludCwgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgICBwLCBwMjtcblxuICAgICAgaWYgKHR5cGVvZiBvcmlnaW5YICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3JpZ2luWSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgIHAgPSB0aGlzLnRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicsIG9yaWdpblgsIG9yaWdpblkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHAgPSBuZXcgZmFicmljLlBvaW50KHRoaXMubGVmdCwgdGhpcy50b3ApO1xuICAgICAgfVxuXG4gICAgICBwMiA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICBwMiA9IGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KHAyLCBjZW50ZXIsIC1kZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwMi5zdWJ0cmFjdEVxdWFscyhwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgaW4gZ2xvYmFsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgLy8gdG9HbG9iYWxQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAvLyAgIHJldHVybiBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwb2ludCwgdGhpcy5nZXRDZW50ZXJQb2ludCgpLCBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKS5hZGRFcXVhbHMobmV3IGZhYnJpYy5Qb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKSk7XG4gICAgLy8gfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBvYmplY3QgdGFraW5nIGludG8gY29uc2lkZXJhdGlvbiB0aGUgb2JqZWN0J3Mgb3JpZ2luXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvcyBUaGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWCBIb3Jpem9udGFsIG9yaWdpbjogJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIHNldFBvc2l0aW9uQnlPcmlnaW46IGZ1bmN0aW9uKHBvcywgb3JpZ2luWCwgb3JpZ2luWSkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMudHJhbnNsYXRlVG9DZW50ZXJQb2ludChwb3MsIG9yaWdpblgsIG9yaWdpblkpLFxuICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlciwgdGhpcy5vcmlnaW5YLCB0aGlzLm9yaWdpblkpO1xuICAgICAgdGhpcy5zZXQoJ2xlZnQnLCBwb3NpdGlvbi54KTtcbiAgICAgIHRoaXMuc2V0KCd0b3AnLCBwb3NpdGlvbi55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRvIE9uZSBvZiAnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXG4gICAgICovXG4gICAgYWRqdXN0UG9zaXRpb246IGZ1bmN0aW9uKHRvKSB7XG4gICAgICB2YXIgYW5nbGUgPSBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpLFxuICAgICAgICAgIGh5cG90RnVsbCA9IHRoaXMuZ2V0U2NhbGVkV2lkdGgoKSxcbiAgICAgICAgICB4RnVsbCA9IGZhYnJpYy51dGlsLmNvcyhhbmdsZSkgKiBoeXBvdEZ1bGwsXG4gICAgICAgICAgeUZ1bGwgPSBmYWJyaWMudXRpbC5zaW4oYW5nbGUpICogaHlwb3RGdWxsLFxuICAgICAgICAgIG9mZnNldEZyb20sIG9mZnNldFRvO1xuXG4gICAgICAvL1RPRE86IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY29uc2lkZXIgbWl4ZWQgc2l0dWF0aW9uIGxpa2UgdG9wLCBjZW50ZXIuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3JpZ2luWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2Zmc2V0RnJvbSA9IG9yaWdpblhPZmZzZXRbdGhpcy5vcmlnaW5YXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvZmZzZXRGcm9tID0gdGhpcy5vcmlnaW5YIC0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2Zmc2V0VG8gPSBvcmlnaW5YT2Zmc2V0W3RvXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvZmZzZXRUbyA9IHRvIC0gMC41O1xuICAgICAgfVxuICAgICAgdGhpcy5sZWZ0ICs9IHhGdWxsICogKG9mZnNldFRvIC0gb2Zmc2V0RnJvbSk7XG4gICAgICB0aGlzLnRvcCArPSB5RnVsbCAqIChvZmZzZXRUbyAtIG9mZnNldEZyb20pO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMub3JpZ2luWCA9IHRvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvcmlnaW4vcG9zaXRpb24gb2YgdGhlIG9iamVjdCB0byBpdCdzIGNlbnRlciBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBfc2V0T3JpZ2luVG9DZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5YID0gdGhpcy5vcmlnaW5YO1xuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5ZID0gdGhpcy5vcmlnaW5ZO1xuXG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRDZW50ZXJQb2ludCgpO1xuXG4gICAgICB0aGlzLm9yaWdpblggPSAnY2VudGVyJztcbiAgICAgIHRoaXMub3JpZ2luWSA9ICdjZW50ZXInO1xuXG4gICAgICB0aGlzLmxlZnQgPSBjZW50ZXIueDtcbiAgICAgIHRoaXMudG9wID0gY2VudGVyLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgb3JpZ2luL3Bvc2l0aW9uIG9mIHRoZSBvYmplY3QgdG8gaXQncyBvcmlnaW5hbCBvcmlnaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgX3Jlc2V0T3JpZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcmlnaW5Qb2ludCA9IHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChcbiAgICAgICAgdGhpcy5nZXRDZW50ZXJQb2ludCgpLFxuICAgICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblgsXG4gICAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWSk7XG5cbiAgICAgIHRoaXMub3JpZ2luWCA9IHRoaXMuX29yaWdpbmFsT3JpZ2luWDtcbiAgICAgIHRoaXMub3JpZ2luWSA9IHRoaXMuX29yaWdpbmFsT3JpZ2luWTtcblxuICAgICAgdGhpcy5sZWZ0ID0gb3JpZ2luUG9pbnQueDtcbiAgICAgIHRoaXMudG9wID0gb3JpZ2luUG9pbnQueTtcblxuICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5YID0gbnVsbDtcbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWSA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExlZnRUb3BDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludCh0aGlzLmdldENlbnRlclBvaW50KCksICdsZWZ0JywgJ3RvcCcpO1xuICAgIH0sXG4gIH0pO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBhcnJheUZyb21Db29yZHMoY29vcmRzKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLnRsLngsIGNvb3Jkcy50bC55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLnRyLngsIGNvb3Jkcy50ci55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLmJyLngsIGNvb3Jkcy5ici55KSxcbiAgICAgIG5ldyBmYWJyaWMuUG9pbnQoY29vcmRzLmJsLngsIGNvb3Jkcy5ibC55KVxuICAgIF07XG4gIH1cblxuICB2YXIgdXRpbCA9IGZhYnJpYy51dGlsLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IHV0aWwuZGVncmVlc1RvUmFkaWFucyxcbiAgICAgIG11bHRpcGx5TWF0cmljZXMgPSB1dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMsXG4gICAgICB0cmFuc2Zvcm1Qb2ludCA9IHV0aWwudHJhbnNmb3JtUG9pbnQ7XG5cbiAgdXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIG9iamVjdCdzIGNvcm5lciBwb3NpdGlvbiBpbiBjYW52YXMgZWxlbWVudCBjb29yZGluYXRlcy5cbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSBkZXBlbmRpbmcgb24gY29udHJvbCBrZXlzIGFuZCBwYWRkaW5nIHRoZSBtYWluIGNvbnRyb2xzLlxuICAgICAqIGVhY2ggcHJvcGVydHkgaXMgYW4gb2JqZWN0IHdpdGggeCwgeSBhbmQgY29ybmVyLlxuICAgICAqIFRoZSBgY29ybmVyYCBwcm9wZXJ0eSBjb250YWlucyBpbiBhIHNpbWlsYXIgbWFubmVyIHRoZSA0IHBvaW50cyBvZiB0aGVcbiAgICAgKiBpbnRlcmFjdGl2ZSBhcmVhIG9mIHRoZSBjb3JuZXIuXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGRlcGVuZHMgZnJvbSB0aGUgY29udHJvbHMgcG9zaXRpb25IYW5kbGVyIGFuZCBhcmUgdXNlZFxuICAgICAqIHRvIGRyYXcgYW5kIGxvY2F0ZSBjb250cm9sc1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqL1xuICAgIG9Db29yZHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBvYmplY3QncyBjb3JuZXIgcG9zaXRpb24gaW4gY2FudmFzIG9iamVjdCBhYnNvbHV0ZSBjb29yZGluYXRlc1xuICAgICAqIHByb3BlcnRpZXMgYXJlIHRsLHRyLGJsLGJyIGFuZCBkZXNjcmliZSB0aGUgZm91ciBtYWluIGNvcm5lci5cbiAgICAgKiBlYWNoIHByb3BlcnR5IGlzIGFuIG9iamVjdCB3aXRoIHgsIHksIGluc3RhbmNlIG9mIEZhYnJpYy5Qb2ludC5cbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgZGVwZW5kcyBmcm9tIHRoaXMgcHJvcGVydGllczogd2lkdGgsIGhlaWdodCwgc2NhbGVYLCBzY2FsZVlcbiAgICAgKiBza2V3WCwgc2tld1ksIGFuZ2xlLCBzdHJva2VXaWR0aCwgdG9wLCBsZWZ0LlxuICAgICAqIFRob3NlIGNvb3JkaW5hdGVzIGFyZSB1c2VmdWwgdG8gdW5kZXJzdGFuZCB3aGVyZSBhbiBvYmplY3QgaXMuIFRoZXkgZ2V0IHVwZGF0ZWRcbiAgICAgKiB3aXRoIG9Db29yZHMgYnV0IHRoZXkgZG8gbm90IG5lZWQgdG8gYmUgdXBkYXRlZCB3aGVuIHpvb20gb3IgcGFubmluZyBjaGFuZ2UuXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGdldCB1cGRhdGVkIHdpdGggQG1ldGhvZCBzZXRDb29yZHMuXG4gICAgICogWW91IGNhbiBjYWxjdWxhdGUgdGhlbSB3aXRob3V0IHVwZGF0aW5nIHdpdGggQG1ldGhvZCBjYWxjQUNvb3JkcygpO1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFDb29yZHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBvYmplY3QncyBjb3JuZXIgcG9zaXRpb24gaW4gY2FudmFzIGVsZW1lbnQgY29vcmRpbmF0ZXMuXG4gICAgICogaW5jbHVkZXMgcGFkZGluZy4gVXNlZCBvZiBvYmplY3QgZGV0ZWN0aW9uLlxuICAgICAqIHNldCBhbmQgcmVmcmVzaGVkIHdpdGggc2V0Q29vcmRzLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxpbmVDb29yZHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBzdG9yYWdlIGZvciBvYmplY3QgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqL1xuICAgIG93bk1hdHJpeENhY2hlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogc3RvcmFnZSBmb3Igb2JqZWN0IGZ1bGwgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqL1xuICAgIG1hdHJpeENhY2hlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogY3VzdG9tIGNvbnRyb2xzIGludGVyZmFjZVxuICAgICAqIGNvbnRyb2xzIGFyZSBhZGRlZCBieSBkZWZhdWx0X2NvbnRyb2xzLmpzXG4gICAgICovXG4gICAgY29udHJvbHM6IHsgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBjb3JyZWN0IHNldCBvZiBjb29yZGluYXRlcyBmb3IgaW50ZXJzZWN0aW9uXG4gICAgICogdGhpcyB3aWxsIHJldHVybiBlaXRoZXIgYUNvb3JkcyBvciBsaW5lQ29vcmRzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWJzb2x1dGUgd2lsbCByZXR1cm4gYUNvb3JkcyBpZiB0cnVlIG9yIGxpbmVDb29yZHNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHt0bCwgdHIsIGJyLCBibH0gcG9pbnRzXG4gICAgICovXG4gICAgX2dldENvb3JkczogZnVuY3Rpb24oYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgaWYgKGNhbGN1bGF0ZSkge1xuICAgICAgICByZXR1cm4gKGFic29sdXRlID8gdGhpcy5jYWxjQUNvb3JkcygpIDogdGhpcy5jYWxjTGluZUNvb3JkcygpKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5hQ29vcmRzIHx8ICF0aGlzLmxpbmVDb29yZHMpIHtcbiAgICAgICAgdGhpcy5zZXRDb29yZHModHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGFic29sdXRlID8gdGhpcy5hQ29vcmRzIDogdGhpcy5saW5lQ29vcmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGNvcnJlY3Qgc2V0IG9mIGNvb3JkaW5hdGVzIGZvciBpbnRlcnNlY3Rpb25cbiAgICAgKiB0aGlzIHdpbGwgcmV0dXJuIGVpdGhlciBhQ29vcmRzIG9yIGxpbmVDb29yZHMuXG4gICAgICogVGhlIGNvb3JkcyBhcmUgcmV0dXJuZWQgaW4gYW4gYXJyYXkuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFt0bCwgdHIsIGJyLCBibF0gb2YgcG9pbnRzXG4gICAgICovXG4gICAgZ2V0Q29vcmRzOiBmdW5jdGlvbihhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICByZXR1cm4gYXJyYXlGcm9tQ29vcmRzKHRoaXMuX2dldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIGFuIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50VEwgdG9wLWxlZnQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludEJSIGJvdHRvbS1yaWdodCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaW50ZXJzZWN0cyB3aXRoIGFuIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICovXG4gICAgaW50ZXJzZWN0c1dpdGhSZWN0OiBmdW5jdGlvbihwb2ludFRMLCBwb2ludEJSLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSksXG4gICAgICAgICAgaW50ZXJzZWN0aW9uID0gZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RQb2x5Z29uUmVjdGFuZ2xlKFxuICAgICAgICAgICAgY29vcmRzLFxuICAgICAgICAgICAgcG9pbnRUTCxcbiAgICAgICAgICAgIHBvaW50QlJcbiAgICAgICAgICApO1xuICAgICAgcmV0dXJuIGludGVyc2VjdGlvbi5zdGF0dXMgPT09ICdJbnRlcnNlY3Rpb24nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbm90aGVyIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBPYmplY3QgdG8gdGVzdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbm90aGVyIG9iamVjdFxuICAgICAqL1xuICAgIGludGVyc2VjdHNXaXRoT2JqZWN0OiBmdW5jdGlvbihvdGhlciwgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0UG9seWdvblBvbHlnb24oXG4gICAgICAgIHRoaXMuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpLFxuICAgICAgICBvdGhlci5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24uc3RhdHVzID09PSAnSW50ZXJzZWN0aW9uJ1xuICAgICAgICB8fCBvdGhlci5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKVxuICAgICAgICB8fCB0aGlzLmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KG90aGVyLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgb2YgYW5vdGhlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgT2JqZWN0IHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgb2YgYW5vdGhlciBvYmplY3RcbiAgICAgKi9cbiAgICBpc0NvbnRhaW5lZFdpdGhpbk9iamVjdDogZnVuY3Rpb24ob3RoZXIsIGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSxcbiAgICAgICAgICBvdGhlckNvb3JkcyA9IGFic29sdXRlID8gb3RoZXIuYUNvb3JkcyA6IG90aGVyLmxpbmVDb29yZHMsXG4gICAgICAgICAgaSA9IDAsIGxpbmVzID0gb3RoZXIuX2dldEltYWdlTGluZXMob3RoZXJDb29yZHMpO1xuICAgICAgZm9yICg7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgaWYgKCFvdGhlci5jb250YWluc1BvaW50KHBvaW50c1tpXSwgbGluZXMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpcyBmdWxseSBjb250YWluZWQgd2l0aGluIGFyZWEgZm9ybWVkIGJ5IDIgcG9pbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50VEwgdG9wLWxlZnQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludEJSIGJvdHRvbS1yaWdodCBwb2ludCBvZiBhcmVhXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIGZvcm1lZCBieSAyIHBvaW50c1xuICAgICAqL1xuICAgIGlzQ29udGFpbmVkV2l0aGluUmVjdDogZnVuY3Rpb24ocG9pbnRUTCwgcG9pbnRCUiwgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KGFic29sdXRlLCBjYWxjdWxhdGUpO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBib3VuZGluZ1JlY3QubGVmdCA+PSBwb2ludFRMLnggJiZcbiAgICAgICAgYm91bmRpbmdSZWN0LmxlZnQgKyBib3VuZGluZ1JlY3Qud2lkdGggPD0gcG9pbnRCUi54ICYmXG4gICAgICAgIGJvdW5kaW5nUmVjdC50b3AgPj0gcG9pbnRUTC55ICYmXG4gICAgICAgIGJvdW5kaW5nUmVjdC50b3AgKyBib3VuZGluZ1JlY3QuaGVpZ2h0IDw9IHBvaW50QlIueVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFBvaW50IHRvIGNoZWNrIGFnYWluc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2xpbmVzXSBvYmplY3QgcmV0dXJuZWQgZnJvbSBAbWV0aG9kIF9nZXRJbWFnZUxpbmVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBwb2ludCBpcyBpbnNpZGUgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBsaW5lcywgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuX2dldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSxcbiAgICAgICAgICBsaW5lcyA9IGxpbmVzIHx8IHRoaXMuX2dldEltYWdlTGluZXMoY29vcmRzKSxcbiAgICAgICAgICB4UG9pbnRzID0gdGhpcy5fZmluZENyb3NzUG9pbnRzKHBvaW50LCBsaW5lcyk7XG4gICAgICAvLyBpZiB4UG9pbnRzIGlzIG9kZCB0aGVuIHBvaW50IGlzIGluc2lkZSB0aGUgb2JqZWN0XG4gICAgICByZXR1cm4gKHhQb2ludHMgIT09IDAgJiYgeFBvaW50cyAlIDIgPT09IDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGNhbnZhcyB3aXRoIGN1cnJlbnQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiB0aGUgY2hlY2sgaXMgZG9uZSBzdG9wcGluZyBhdCBmaXJzdCBwb2ludCB0aGF0IGFwcGVhcnMgb24gc2NyZWVuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5hQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgZnVsbHkgb3IgcGFydGlhbGx5IGNvbnRhaW5lZCB3aXRoaW4gY2FudmFzXG4gICAgICovXG4gICAgaXNPblNjcmVlbjogZnVuY3Rpb24oY2FsY3VsYXRlKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludFRMID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLnRsLCBwb2ludEJSID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLmJyO1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZ2V0Q29vcmRzKHRydWUsIGNhbGN1bGF0ZSk7XG4gICAgICAvLyBpZiBzb21lIHBvaW50IGlzIG9uIHNjcmVlbiwgdGhlIG9iamVjdCBpcyBvbiBzY3JlZW4uXG4gICAgICBpZiAocG9pbnRzLnNvbWUoZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50LnggPD0gcG9pbnRCUi54ICYmIHBvaW50LnggPj0gcG9pbnRUTC54ICYmXG4gICAgICAgIHBvaW50LnkgPD0gcG9pbnRCUi55ICYmIHBvaW50LnkgPj0gcG9pbnRUTC55O1xuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyBubyBwb2ludHMgb24gc2NyZWVuLCBjaGVjayBpbnRlcnNlY3Rpb24gd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlc1xuICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0c1dpdGhSZWN0KHBvaW50VEwsIHBvaW50QlIsIHRydWUsIGNhbGN1bGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY29udGFpbnNDZW50ZXJPZkNhbnZhcyhwb2ludFRMLCBwb2ludEJSLCBjYWxjdWxhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG9iamVjdCBjb250YWlucyB0aGUgbWlkcG9pbnQgYmV0d2VlbiBjYW52YXMgZXh0cmVtaXRpZXNcbiAgICAgKiBEb2VzIG5vdCBtYWtlIHNlbnNlIG91dHNpZGUgdGhlIGNvbnRleHQgb2YgaXNPblNjcmVlbiBhbmQgaXNQYXJ0aWFsbHlPblNjcmVlblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGYWJyaWMuUG9pbnR9IHBvaW50VEwgVG9wIExlZnQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5Qb2ludH0gcG9pbnRCUiBUb3AgUmlnaHQgcG9pbnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhbGN1bGF0ZSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBwb2ludFxuICAgICAqL1xuICAgIF9jb250YWluc0NlbnRlck9mQ2FudmFzOiBmdW5jdGlvbihwb2ludFRMLCBwb2ludEJSLCBjYWxjdWxhdGUpIHtcbiAgICAgIC8vIHdvcnN0IGNhc2Ugc2NlbmFyaW8gdGhlIG9iamVjdCBpcyBzbyBiaWcgdGhhdCBjb250YWlucyB0aGUgc2NyZWVuXG4gICAgICB2YXIgY2VudGVyUG9pbnQgPSB7IHg6IChwb2ludFRMLnggKyBwb2ludEJSLngpIC8gMiwgeTogKHBvaW50VEwueSArIHBvaW50QlIueSkgLyAyIH07XG4gICAgICBpZiAodGhpcy5jb250YWluc1BvaW50KGNlbnRlclBvaW50LCBudWxsLCB0cnVlLCBjYWxjdWxhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGlzIHBhcnRpYWxseSBjb250YWluZWQgd2l0aGluIHRoZSBjYW52YXMgd2l0aCBjdXJyZW50IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgcGFydGlhbGx5IGNvbnRhaW5lZCB3aXRoaW4gY2FudmFzXG4gICAgICovXG4gICAgaXNQYXJ0aWFsbHlPblNjcmVlbjogZnVuY3Rpb24oY2FsY3VsYXRlKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludFRMID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLnRsLCBwb2ludEJSID0gdGhpcy5jYW52YXMudnB0Q29vcmRzLmJyO1xuICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0c1dpdGhSZWN0KHBvaW50VEwsIHBvaW50QlIsIHRydWUsIGNhbGN1bGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgYWxsUG9pbnRzQXJlT3V0c2lkZSA9IHRoaXMuZ2V0Q29vcmRzKHRydWUsIGNhbGN1bGF0ZSkuZXZlcnkoZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIChwb2ludC54ID49IHBvaW50QlIueCB8fCBwb2ludC54IDw9IHBvaW50VEwueCkgJiZcbiAgICAgICAgKHBvaW50LnkgPj0gcG9pbnRCUi55IHx8IHBvaW50LnkgPD0gcG9pbnRUTC55KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFsbFBvaW50c0FyZU91dHNpZGUgJiYgdGhpcy5fY29udGFpbnNDZW50ZXJPZkNhbnZhcyhwb2ludFRMLCBwb2ludEJSLCBjYWxjdWxhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBvYmplY3QgZWRnZXMgaW4gaXQsIGdpdmVuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgY29ybmVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9Db29yZHMgQ29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBjb3JuZXJzXG4gICAgICovXG4gICAgX2dldEltYWdlTGluZXM6IGZ1bmN0aW9uKG9Db29yZHMpIHtcblxuICAgICAgdmFyIGxpbmVzID0ge1xuICAgICAgICB0b3BsaW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy50bCxcbiAgICAgICAgICBkOiBvQ29vcmRzLnRyXG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0bGluZToge1xuICAgICAgICAgIG86IG9Db29yZHMudHIsXG4gICAgICAgICAgZDogb0Nvb3Jkcy5iclxuICAgICAgICB9LFxuICAgICAgICBib3R0b21saW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy5icixcbiAgICAgICAgICBkOiBvQ29vcmRzLmJsXG4gICAgICAgIH0sXG4gICAgICAgIGxlZnRsaW5lOiB7XG4gICAgICAgICAgbzogb0Nvb3Jkcy5ibCxcbiAgICAgICAgICBkOiBvQ29vcmRzLnRsXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIC8vIGRlYnVnZ2luZ1xuICAgICAgLy8gaWYgKHRoaXMuY2FudmFzLmNvbnRleHRUb3ApIHtcbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5ib3R0b21saW5lLmQueCwgbGluZXMuYm90dG9tbGluZS5kLnksIDIsIDIpO1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmJvdHRvbWxpbmUuby54LCBsaW5lcy5ib3R0b21saW5lLm8ueSwgMiwgMik7XG4gICAgICAvL1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmxlZnRsaW5lLmQueCwgbGluZXMubGVmdGxpbmUuZC55LCAyLCAyKTtcbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5sZWZ0bGluZS5vLngsIGxpbmVzLmxlZnRsaW5lLm8ueSwgMiwgMik7XG4gICAgICAvL1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnRvcGxpbmUuZC54LCBsaW5lcy50b3BsaW5lLmQueSwgMiwgMik7XG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMudG9wbGluZS5vLngsIGxpbmVzLnRvcGxpbmUuby55LCAyLCAyKTtcbiAgICAgIC8vXG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMucmlnaHRsaW5lLmQueCwgbGluZXMucmlnaHRsaW5lLmQueSwgMiwgMik7XG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMucmlnaHRsaW5lLm8ueCwgbGluZXMucmlnaHRsaW5lLm8ueSwgMiwgMik7XG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVybiBsaW5lcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBkZXRlcm1pbmUgaG93IG1hbnkgY3Jvc3MgcG9pbnRzIGFyZSBiZXR3ZWVuIHRoZSA0IG9iamVjdCBlZGdlc1xuICAgICAqIGFuZCB0aGUgaG9yaXpvbnRhbCBsaW5lIGRldGVybWluZWQgYnkgYSBwb2ludCBvbiBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBQb2ludCB0byBjaGVja1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsaW5lcyBDb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IGJlaW5nIGV2YWx1YXRlZFxuICAgICAqL1xuICAgIC8vIHJlbW92ZSB5aSwgbm90IHVzZWQgYnV0IGxlZnQgY29kZSBoZXJlIGp1c3QgaW4gY2FzZS5cbiAgICBfZmluZENyb3NzUG9pbnRzOiBmdW5jdGlvbihwb2ludCwgbGluZXMpIHtcbiAgICAgIHZhciBiMSwgYjIsIGExLCBhMiwgeGksIC8vIHlpLFxuICAgICAgICAgIHhjb3VudCA9IDAsXG4gICAgICAgICAgaUxpbmU7XG5cbiAgICAgIGZvciAodmFyIGxpbmVLZXkgaW4gbGluZXMpIHtcbiAgICAgICAgaUxpbmUgPSBsaW5lc1tsaW5lS2V5XTtcbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDE6IGxpbmUgYmVsb3cgcG9pbnQuIG5vIGNyb3NzXG4gICAgICAgIGlmICgoaUxpbmUuby55IDwgcG9pbnQueSkgJiYgKGlMaW5lLmQueSA8IHBvaW50LnkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDI6IGxpbmUgYWJvdmUgcG9pbnQuIG5vIGNyb3NzXG4gICAgICAgIGlmICgoaUxpbmUuby55ID49IHBvaW50LnkpICYmIChpTGluZS5kLnkgPj0gcG9pbnQueSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpbWlzYXRpb24gMzogdmVydGljYWwgbGluZSBjYXNlXG4gICAgICAgIGlmICgoaUxpbmUuby54ID09PSBpTGluZS5kLngpICYmIChpTGluZS5vLnggPj0gcG9pbnQueCkpIHtcbiAgICAgICAgICB4aSA9IGlMaW5lLm8ueDtcbiAgICAgICAgICAvLyB5aSA9IHBvaW50Lnk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYjEgPSAwO1xuICAgICAgICAgIGIyID0gKGlMaW5lLmQueSAtIGlMaW5lLm8ueSkgLyAoaUxpbmUuZC54IC0gaUxpbmUuby54KTtcbiAgICAgICAgICBhMSA9IHBvaW50LnkgLSBiMSAqIHBvaW50Lng7XG4gICAgICAgICAgYTIgPSBpTGluZS5vLnkgLSBiMiAqIGlMaW5lLm8ueDtcblxuICAgICAgICAgIHhpID0gLShhMSAtIGEyKSAvIChiMSAtIGIyKTtcbiAgICAgICAgICAvLyB5aSA9IGExICsgYjEgKiB4aTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb250IGNvdW50IHhpIDwgcG9pbnQueCBjYXNlc1xuICAgICAgICBpZiAoeGkgPj0gcG9pbnQueCkge1xuICAgICAgICAgIHhjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbiA0OiBzcGVjaWZpYyBmb3Igc3F1YXJlIGltYWdlc1xuICAgICAgICBpZiAoeGNvdW50ID09PSAyKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB4Y291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29vcmRpbmF0ZXMgb2Ygb2JqZWN0J3MgYm91bmRpbmcgcmVjdGFuZ2xlIChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpXG4gICAgICogdGhlIGJveCBpcyBpbnRlbmRlZCBhcyBhbGlnbmVkIHRvIGF4aXMgb2YgY2FudmFzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3JkcyAvIC5hQ29vcmRzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24oYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpO1xuICAgICAgcmV0dXJuIHV0aWwubWFrZUJvdW5kaW5nQm94RnJvbVBvaW50cyhjb29yZHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdpZHRoIG9mIGFuIG9iamVjdCdzIGJvdW5kaW5nIGJveCBjb3VudGluZyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBiZWZvcmUgMi4wIGl0IHdhcyBuYW1lZCBnZXRXaWR0aCgpO1xuICAgICAqIEByZXR1cm4ge051bWJlcn0gd2lkdGggdmFsdWVcbiAgICAgKi9cbiAgICBnZXRTY2FsZWRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCkueDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBoZWlnaHQgb2YgYW4gb2JqZWN0IGJvdW5kaW5nIGJveCBjb3VudGluZyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBiZWZvcmUgMi4wIGl0IHdhcyBuYW1lZCBnZXRIZWlnaHQoKTtcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGhlaWdodCB2YWx1ZVxuICAgICAqL1xuICAgIGdldFNjYWxlZEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCkueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgc3VyZSB0aGUgc2NhbGUgaXMgdmFsaWQgYW5kIG1vZGlmaWVzIGl0IGlmIG5lY2Vzc2FyeVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIF9jb25zdHJhaW5TY2FsZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChNYXRoLmFicyh2YWx1ZSkgPCB0aGlzLm1pblNjYWxlTGltaXQpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgIHJldHVybiAtdGhpcy5taW5TY2FsZUxpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLm1pblNjYWxlTGltaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwLjAwMDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyBhbiBvYmplY3QgKGVxdWFsbHkgYnkgeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgU2NhbGUgZmFjdG9yXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldCgnc2NhbGVYJywgdmFsdWUpO1xuICAgICAgdGhpcy5fc2V0KCdzY2FsZVknLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRDb29yZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFuIG9iamVjdCB0byBhIGdpdmVuIHdpZHRoLCB3aXRoIHJlc3BlY3QgdG8gYm91bmRpbmcgYm94IChzY2FsaW5nIGJ5IHgveSBlcXVhbGx5KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBOZXcgd2lkdGggdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFic29sdXRlIGlnbm9yZSB2aWV3cG9ydFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGVUb1dpZHRoOiBmdW5jdGlvbih2YWx1ZSwgYWJzb2x1dGUpIHtcbiAgICAgIC8vIGFkanVzdCB0byBib3VuZGluZyByZWN0IGZhY3RvciBzbyB0aGF0IHJvdGF0ZWQgc2hhcGVzIHdvdWxkIGZpdCBhcyB3ZWxsXG4gICAgICB2YXIgYm91bmRpbmdSZWN0RmFjdG9yID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoYWJzb2x1dGUpLndpZHRoIC8gdGhpcy5nZXRTY2FsZWRXaWR0aCgpO1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGUodmFsdWUgLyB0aGlzLndpZHRoIC8gYm91bmRpbmdSZWN0RmFjdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGFuIG9iamVjdCB0byBhIGdpdmVuIGhlaWdodCwgd2l0aCByZXNwZWN0IHRvIGJvdW5kaW5nIGJveCAoc2NhbGluZyBieSB4L3kgZXF1YWxseSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgTmV3IGhlaWdodCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWJzb2x1dGUgaWdub3JlIHZpZXdwb3J0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsZVRvSGVpZ2h0OiBmdW5jdGlvbih2YWx1ZSwgYWJzb2x1dGUpIHtcbiAgICAgIC8vIGFkanVzdCB0byBib3VuZGluZyByZWN0IGZhY3RvciBzbyB0aGF0IHJvdGF0ZWQgc2hhcGVzIHdvdWxkIGZpdCBhcyB3ZWxsXG4gICAgICB2YXIgYm91bmRpbmdSZWN0RmFjdG9yID0gdGhpcy5nZXRCb3VuZGluZ1JlY3QoYWJzb2x1dGUpLmhlaWdodCAvIHRoaXMuZ2V0U2NhbGVkSGVpZ2h0KCk7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZSh2YWx1ZSAvIHRoaXMuaGVpZ2h0IC8gYm91bmRpbmdSZWN0RmFjdG9yKTtcbiAgICB9LFxuXG4gICAgY2FsY0xpbmVDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBwYWRkaW5nID0gdGhpcy5wYWRkaW5nLCBhbmdsZSA9IGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSksXG4gICAgICAgICAgY29zID0gdXRpbC5jb3MoYW5nbGUpLCBzaW4gPSB1dGlsLnNpbihhbmdsZSksXG4gICAgICAgICAgY29zUCA9IGNvcyAqIHBhZGRpbmcsIHNpblAgPSBzaW4gKiBwYWRkaW5nLCBjb3NQU2luUCA9IGNvc1AgKyBzaW5QLFxuICAgICAgICAgIGNvc1BNaW51c1NpblAgPSBjb3NQIC0gc2luUCwgYUNvb3JkcyA9IHRoaXMuY2FsY0FDb29yZHMoKTtcblxuICAgICAgdmFyIGxpbmVDb29yZHMgPSB7XG4gICAgICAgIHRsOiB0cmFuc2Zvcm1Qb2ludChhQ29vcmRzLnRsLCB2cHQpLFxuICAgICAgICB0cjogdHJhbnNmb3JtUG9pbnQoYUNvb3Jkcy50ciwgdnB0KSxcbiAgICAgICAgYmw6IHRyYW5zZm9ybVBvaW50KGFDb29yZHMuYmwsIHZwdCksXG4gICAgICAgIGJyOiB0cmFuc2Zvcm1Qb2ludChhQ29vcmRzLmJyLCB2cHQpLFxuICAgICAgfTtcblxuICAgICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgbGluZUNvb3Jkcy50bC54IC09IGNvc1BNaW51c1NpblA7XG4gICAgICAgIGxpbmVDb29yZHMudGwueSAtPSBjb3NQU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy50ci54ICs9IGNvc1BTaW5QO1xuICAgICAgICBsaW5lQ29vcmRzLnRyLnkgLT0gY29zUE1pbnVzU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy5ibC54IC09IGNvc1BTaW5QO1xuICAgICAgICBsaW5lQ29vcmRzLmJsLnkgKz0gY29zUE1pbnVzU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy5ici54ICs9IGNvc1BNaW51c1NpblA7XG4gICAgICAgIGxpbmVDb29yZHMuYnIueSArPSBjb3NQU2luUDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpbmVDb29yZHM7XG4gICAgfSxcblxuICAgIGNhbGNPQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByb3RhdGVNYXRyaXggPSB0aGlzLl9jYWxjUm90YXRlTWF0cml4KCksXG4gICAgICAgICAgdHJhbnNsYXRlTWF0cml4ID0gdGhpcy5fY2FsY1RyYW5zbGF0ZU1hdHJpeCgpLFxuICAgICAgICAgIHZwdCA9IHRoaXMuZ2V0Vmlld3BvcnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICBzdGFydE1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXModnB0LCB0cmFuc2xhdGVNYXRyaXgpLFxuICAgICAgICAgIGZpbmFsTWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyhzdGFydE1hdHJpeCwgcm90YXRlTWF0cml4KSxcbiAgICAgICAgICBmaW5hbE1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXMoZmluYWxNYXRyaXgsIFsxIC8gdnB0WzBdLCAwLCAwLCAxIC8gdnB0WzNdLCAwLCAwXSksXG4gICAgICAgICAgZGltID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKSxcbiAgICAgICAgICBjb29yZHMgPSB7fTtcbiAgICAgIHRoaXMuZm9yRWFjaENvbnRyb2woZnVuY3Rpb24oY29udHJvbCwga2V5LCBmYWJyaWNPYmplY3QpIHtcbiAgICAgICAgY29vcmRzW2tleV0gPSBjb250cm9sLnBvc2l0aW9uSGFuZGxlcihkaW0sIGZpbmFsTWF0cml4LCBmYWJyaWNPYmplY3QpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGRlYnVnIGNvZGVcbiAgICAgIC8vIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIC8vIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgIGNhbnZhcy5jb250ZXh0VG9wLmNsZWFyUmVjdCgwLCAwLCA3MDAsIDcwMCk7XG4gICAgICAvLyAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxTdHlsZSA9ICdncmVlbic7XG4gICAgICAvLyAgIE9iamVjdC5rZXlzKGNvb3JkcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIC8vICAgICB2YXIgY29udHJvbCA9IGNvb3Jkc1trZXldO1xuICAgICAgLy8gICAgIGNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGNvbnRyb2wueCwgY29udHJvbC55LCAzLCAzKTtcbiAgICAgIC8vICAgfSk7XG4gICAgICAvLyB9LCA1MCk7XG4gICAgICByZXR1cm4gY29vcmRzO1xuICAgIH0sXG5cbiAgICBjYWxjQUNvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcm90YXRlTWF0cml4ID0gdGhpcy5fY2FsY1JvdGF0ZU1hdHJpeCgpLFxuICAgICAgICAgIHRyYW5zbGF0ZU1hdHJpeCA9IHRoaXMuX2NhbGNUcmFuc2xhdGVNYXRyaXgoKSxcbiAgICAgICAgICBmaW5hbE1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXModHJhbnNsYXRlTWF0cml4LCByb3RhdGVNYXRyaXgpLFxuICAgICAgICAgIGRpbSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLFxuICAgICAgICAgIHcgPSBkaW0ueCAvIDIsIGggPSBkaW0ueSAvIDI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBjb3JuZXJzXG4gICAgICAgIHRsOiB0cmFuc2Zvcm1Qb2ludCh7IHg6IC13LCB5OiAtaCB9LCBmaW5hbE1hdHJpeCksXG4gICAgICAgIHRyOiB0cmFuc2Zvcm1Qb2ludCh7IHg6IHcsIHk6IC1oIH0sIGZpbmFsTWF0cml4KSxcbiAgICAgICAgYmw6IHRyYW5zZm9ybVBvaW50KHsgeDogLXcsIHk6IGggfSwgZmluYWxNYXRyaXgpLFxuICAgICAgICBicjogdHJhbnNmb3JtUG9pbnQoeyB4OiB3LCB5OiBoIH0sIGZpbmFsTWF0cml4KVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjb3JuZXIgYW5kIGNvbnRyb2xzIHBvc2l0aW9uIGNvb3JkaW5hdGVzIGJhc2VkIG9uIGN1cnJlbnQgYW5nbGUsIHdpZHRoIGFuZCBoZWlnaHQsIGxlZnQgYW5kIHRvcC5cbiAgICAgKiBvQ29vcmRzIGFyZSB1c2VkIHRvIGZpbmQgdGhlIGNvcm5lcnNcbiAgICAgKiBhQ29vcmRzIGFyZSB1c2VkIHRvIHF1aWNrbHkgZmluZCBhbiBvYmplY3Qgb24gdGhlIGNhbnZhc1xuICAgICAqIGxpbmVDb29yZHMgYXJlIHVzZWQgdG8gcXVpY2tseSBmaW5kIG9iamVjdCBkdXJpbmcgcG9pbnRlciBldmVudHMuXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmFicmljanMvZmFicmljLmpzL3dpa2kvV2hlbi10by1jYWxsLXNldENvb3Jkc30gYW5kIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1nb3RjaGFzfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcENvcm5lcnNdIHNraXAgY2FsY3VsYXRpb24gb2Ygb0Nvb3Jkcy5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvb3JkczogZnVuY3Rpb24oc2tpcENvcm5lcnMpIHtcbiAgICAgIHRoaXMuYUNvb3JkcyA9IHRoaXMuY2FsY0FDb29yZHMoKTtcbiAgICAgIC8vIGluIGNhc2Ugd2UgYXJlIGluIGEgZ3JvdXAsIGZvciBob3cgdGhlIGlubmVyIGdyb3VwIHRhcmdldCBjaGVjayB3b3JrcyxcbiAgICAgIC8vIGxpbmVDb29yZHMgYXJlIGV4YWN0bHkgYUNvb3Jkcy4gU2luY2UgdGhlIHZwdCBnZXRzIGFic29yYmVkIGJ5IHRoZSBub3JtYWxpemVkIHBvaW50ZXIuXG4gICAgICB0aGlzLmxpbmVDb29yZHMgPSB0aGlzLmdyb3VwID8gdGhpcy5hQ29vcmRzIDogdGhpcy5jYWxjTGluZUNvb3JkcygpO1xuICAgICAgaWYgKHNraXBDb3JuZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgLy8gc2V0IGNvb3JkaW5hdGVzIG9mIHRoZSBkcmFnZ2FibGUgYm94ZXMgaW4gdGhlIGNvcm5lcnMgdXNlZCB0byBzY2FsZS9yb3RhdGUgdGhlIGltYWdlXG4gICAgICB0aGlzLm9Db29yZHMgPSB0aGlzLmNhbGNPQ29vcmRzKCk7XG4gICAgICB0aGlzLl9zZXRDb3JuZXJDb29yZHMgJiYgdGhpcy5fc2V0Q29ybmVyQ29vcmRzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHJvdGF0aW9uIG1hdHJpeCBvZiBhbiBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gcm90YXRpb24gbWF0cml4IGZvciB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgX2NhbGNSb3RhdGVNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHV0aWwuY2FsY1JvdGF0ZU1hdHJpeCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIHRoZSB0cmFuc2xhdGlvbiBtYXRyaXggZm9yIGFuIG9iamVjdCB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gcm90YXRpb24gbWF0cml4IGZvciB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgX2NhbGNUcmFuc2xhdGVNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgIHJldHVybiBbMSwgMCwgMCwgMSwgY2VudGVyLngsIGNlbnRlci55XTtcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtTWF0cml4S2V5OiBmdW5jdGlvbihza2lwR3JvdXApIHtcbiAgICAgIHZhciBzZXAgPSAnXycsIHByZWZpeCA9ICcnO1xuICAgICAgaWYgKCFza2lwR3JvdXAgJiYgdGhpcy5ncm91cCkge1xuICAgICAgICBwcmVmaXggPSB0aGlzLmdyb3VwLnRyYW5zZm9ybU1hdHJpeEtleShza2lwR3JvdXApICsgc2VwO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBwcmVmaXggKyB0aGlzLnRvcCArIHNlcCArIHRoaXMubGVmdCArIHNlcCArIHRoaXMuc2NhbGVYICsgc2VwICsgdGhpcy5zY2FsZVkgK1xuICAgICAgICBzZXAgKyB0aGlzLnNrZXdYICsgc2VwICsgdGhpcy5za2V3WSArIHNlcCArIHRoaXMuYW5nbGUgKyBzZXAgKyB0aGlzLm9yaWdpblggKyBzZXAgKyB0aGlzLm9yaWdpblkgK1xuICAgICAgICBzZXAgKyB0aGlzLndpZHRoICsgc2VwICsgdGhpcy5oZWlnaHQgKyBzZXAgKyB0aGlzLnN0cm9rZVdpZHRoICsgdGhpcy5mbGlwWCArIHRoaXMuZmxpcFk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0cmFuc2Zvcm0gbWF0cml4IHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbnMgZnJvbSB0aGVcbiAgICAgKiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBHcm91cF0gcmV0dXJuIHRyYW5zZm9ybSBtYXRyaXggZm9yIG9iamVjdCBub3QgY291bnRpbmcgcGFyZW50IHRyYW5zZm9ybWF0aW9uc1xuICAgICAqIFRoZXJlIGFyZSBzb21lIHNpdHVhdGlvbiBpbiB3aGljaCB0aGlzIGlzIHVzZWZ1bCB0byBhdm9pZCB0aGUgZmFrZSByb3RhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gdHJhbnNmb3JtIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNhbGNUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uKHNraXBHcm91cCkge1xuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuY2FsY093bk1hdHJpeCgpO1xuICAgICAgaWYgKHNraXBHcm91cCB8fCAhdGhpcy5ncm91cCkge1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHRoaXMudHJhbnNmb3JtTWF0cml4S2V5KHNraXBHcm91cCksIGNhY2hlID0gdGhpcy5tYXRyaXhDYWNoZSB8fCAodGhpcy5tYXRyaXhDYWNoZSA9IHt9KTtcbiAgICAgIGlmIChjYWNoZS5rZXkgPT09IGtleSkge1xuICAgICAgICByZXR1cm4gY2FjaGUudmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICBtYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHRoaXMuZ3JvdXAuY2FsY1RyYW5zZm9ybU1hdHJpeChmYWxzZSksIG1hdHJpeCk7XG4gICAgICB9XG4gICAgICBjYWNoZS5rZXkgPSBrZXk7XG4gICAgICBjYWNoZS52YWx1ZSA9IG1hdHJpeDtcbiAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0cmFuc2Zvcm0gbWF0cml4IHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbnMgZnJvbSB0aGVcbiAgICAgKiBvYmplY3QncyBwcm9wZXJ0aWVzLCB0aGlzIG1hdHJpeCBkb2VzIG5vdCBpbmNsdWRlIHRoZSBncm91cCB0cmFuc2Zvcm1hdGlvblxuICAgICAqIEByZXR1cm4ge0FycmF5fSB0cmFuc2Zvcm0gbWF0cml4IGZvciB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgY2FsY093bk1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy50cmFuc2Zvcm1NYXRyaXhLZXkodHJ1ZSksIGNhY2hlID0gdGhpcy5vd25NYXRyaXhDYWNoZSB8fCAodGhpcy5vd25NYXRyaXhDYWNoZSA9IHt9KTtcbiAgICAgIGlmIChjYWNoZS5rZXkgPT09IGtleSkge1xuICAgICAgICByZXR1cm4gY2FjaGUudmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgdE1hdHJpeCA9IHRoaXMuX2NhbGNUcmFuc2xhdGVNYXRyaXgoKSxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgYW5nbGU6IHRoaXMuYW5nbGUsXG4gICAgICAgICAgICB0cmFuc2xhdGVYOiB0TWF0cml4WzRdLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogdE1hdHJpeFs1XSxcbiAgICAgICAgICAgIHNjYWxlWDogdGhpcy5zY2FsZVgsXG4gICAgICAgICAgICBzY2FsZVk6IHRoaXMuc2NhbGVZLFxuICAgICAgICAgICAgc2tld1g6IHRoaXMuc2tld1gsXG4gICAgICAgICAgICBza2V3WTogdGhpcy5za2V3WSxcbiAgICAgICAgICAgIGZsaXBYOiB0aGlzLmZsaXBYLFxuICAgICAgICAgICAgZmxpcFk6IHRoaXMuZmxpcFksXG4gICAgICAgICAgfTtcbiAgICAgIGNhY2hlLmtleSA9IGtleTtcbiAgICAgIGNhY2hlLnZhbHVlID0gdXRpbC5jb21wb3NlTWF0cml4KG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGNhY2hlLnZhbHVlO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgZGltZW5zaW9ucyBmcm9tIGl0cyBwcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC54IHdpZHRoIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnkgaGVpZ2h0IGRpbWVuc2lvblxuICAgICAqL1xuICAgIF9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgICAgICB3ID0gdGhpcy53aWR0aCArIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGggPSB0aGlzLmhlaWdodCArIHN0cm9rZVdpZHRoO1xuICAgICAgcmV0dXJuIHsgeDogdywgeTogaCB9O1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgYm91bmRpbmcgYm94IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllcyBzY2FsZSwgc2tldy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2tld1gsIGEgdmFsdWUgdG8gb3ZlcnJpZGUgY3VycmVudCBza2V3WFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WSwgYSB2YWx1ZSB0byBvdmVycmlkZSBjdXJyZW50IHNrZXdZXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC54IHdpZHRoIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnkgaGVpZ2h0IGRpbWVuc2lvblxuICAgICAqL1xuICAgIF9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnM6IGZ1bmN0aW9uKHNrZXdYLCBza2V3WSkge1xuICAgICAgaWYgKHR5cGVvZiBza2V3WCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2tld1ggPSB0aGlzLnNrZXdYO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBza2V3WSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2tld1kgPSB0aGlzLnNrZXdZO1xuICAgICAgfVxuICAgICAgdmFyIGRpbWVuc2lvbnMsIGRpbVgsIGRpbVksXG4gICAgICAgICAgbm9Ta2V3ID0gc2tld1ggPT09IDAgJiYgc2tld1kgPT09IDA7XG5cbiAgICAgIGlmICh0aGlzLnN0cm9rZVVuaWZvcm0pIHtcbiAgICAgICAgZGltWCA9IHRoaXMud2lkdGg7XG4gICAgICAgIGRpbVkgPSB0aGlzLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkaW1lbnNpb25zID0gdGhpcy5fZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zKCk7XG4gICAgICAgIGRpbVggPSBkaW1lbnNpb25zLng7XG4gICAgICAgIGRpbVkgPSBkaW1lbnNpb25zLnk7XG4gICAgICB9XG4gICAgICBpZiAobm9Ta2V3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZURpbWVuc2lvbnMoZGltWCAqIHRoaXMuc2NhbGVYLCBkaW1ZICogdGhpcy5zY2FsZVkpO1xuICAgICAgfVxuICAgICAgdmFyIGJib3ggPSB1dGlsLnNpemVBZnRlclRyYW5zZm9ybShkaW1YLCBkaW1ZLCB7XG4gICAgICAgIHNjYWxlWDogdGhpcy5zY2FsZVgsXG4gICAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVksXG4gICAgICAgIHNrZXdYOiBza2V3WCxcbiAgICAgICAgc2tld1k6IHNrZXdZLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVEaW1lbnNpb25zKGJib3gueCwgYmJveC55KTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGJvdW5kaW5nIGJveCBkaW1lbnNpb25zIGZyb20gaXRzIHByb3BlcnRpZXMgc2NhbGUsIHNrZXcuXG4gICAgICogQHBhcmFtIE51bWJlciB3aWR0aCB3aWR0aCBvZiB0aGUgYmJveFxuICAgICAqIEBwYXJhbSBOdW1iZXIgaGVpZ2h0IGhlaWdodCBvZiB0aGUgYmJveFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueCBmaW5hbGl6ZWQgd2lkdGggZGltZW5zaW9uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueSBmaW5hbGl6ZWQgaGVpZ2h0IGRpbWVuc2lvblxuICAgICAqL1xuICAgIF9maW5hbGl6ZURpbWVuc2lvbnM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0cm9rZVVuaWZvcm0gP1xuICAgICAgICB7IHg6IHdpZHRoICsgdGhpcy5zdHJva2VXaWR0aCwgeTogaGVpZ2h0ICsgdGhpcy5zdHJva2VXaWR0aCB9XG4gICAgICAgIDpcbiAgICAgICAgeyB4OiB3aWR0aCwgeTogaGVpZ2h0IH07XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQ2FsY3VsYXRlIG9iamVjdCBkaW1lbnNpb25zIGZvciBjb250cm9scyBib3gsIGluY2x1ZGluZyBwYWRkaW5nIGFuZCBjYW52YXMgem9vbS5cbiAgICAgKiBhbmQgYWN0aXZlIHNlbGVjdGlvblxuICAgICAqIHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkgIHtcbiAgICAgIHZhciB2cHQgPSB0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCksXG4gICAgICAgICAgZGltID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKCksXG4gICAgICAgICAgcCA9IHRyYW5zZm9ybVBvaW50KGRpbSwgdnB0LCB0cnVlKTtcbiAgICAgIHJldHVybiBwLnNjYWxhckFkZCgyICogdGhpcy5wYWRkaW5nKTtcbiAgICB9LFxuICB9KTtcbn0pKCk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB0byB0aGUgYm90dG9tIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2VuZFRvQmFjazogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnNlbmRUb0JhY2suY2FsbCh0aGlzLmdyb3VwLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLnNlbmRUb0JhY2sodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGJyaW5nVG9Gcm9udDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLmJyaW5nVG9Gcm9udC5jYWxsKHRoaXMuZ3JvdXAsIHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMuYnJpbmdUb0Zyb250KHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IGRvd24gaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgYmVoaW5kIG5leHQgbG93ZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNlbmRCYWNrd2FyZHM6IGZ1bmN0aW9uKGludGVyc2VjdGluZykge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZW5kQmFja3dhcmRzLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLnNlbmRCYWNrd2FyZHModGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCB1cCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVyc2VjdGluZ10gSWYgYHRydWVgLCBzZW5kIG9iamVjdCBpbiBmcm9udCBvZiBuZXh0IHVwcGVyIGludGVyc2VjdGluZyBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBicmluZ0ZvcndhcmQ6IGZ1bmN0aW9uKGludGVyc2VjdGluZykge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5icmluZ0ZvcndhcmQuY2FsbCh0aGlzLmdyb3VwLCB0aGlzLCBpbnRlcnNlY3RpbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMuYnJpbmdGb3J3YXJkKHRoaXMsIGludGVyc2VjdGluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gc3BlY2lmaWVkIGxldmVsIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IE5ldyBwb3NpdGlvbiBvZiBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBtb3ZlVG86IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgaWYgKHRoaXMuZ3JvdXAgJiYgdGhpcy5ncm91cC50eXBlICE9PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUubW92ZVRvLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXMubW92ZVRvKHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5cbi8qIF9UT19TVkdfU1RBUlRfICovXG4oZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIGdldFN2Z0NvbG9yU3RyaW5nKHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHByb3AgKyAnOiBub25lOyAnO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZS50b0xpdmUpIHtcbiAgICAgIHJldHVybiBwcm9wICsgJzogdXJsKCNTVkdJRF8nICsgdmFsdWUuaWQgKyAnKTsgJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHZhbHVlKSxcbiAgICAgICAgICBzdHIgPSBwcm9wICsgJzogJyArIGNvbG9yLnRvUmdiKCkgKyAnOyAnLFxuICAgICAgICAgIG9wYWNpdHkgPSBjb2xvci5nZXRBbHBoYSgpO1xuICAgICAgaWYgKG9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgLy9jaGFuZ2UgdGhlIGNvbG9yIGluIHJnYiArIG9wYWNpdHlcbiAgICAgICAgc3RyICs9IHByb3AgKyAnLW9wYWNpdHk6ICcgKyBvcGFjaXR5LnRvU3RyaW5nKCkgKyAnOyAnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1cblxuICB2YXIgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwU2hhZG93IGEgYm9vbGVhbiB0byBza2lwIHNoYWRvdyBmaWx0ZXIgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1N0eWxlczogZnVuY3Rpb24oc2tpcFNoYWRvdykge1xuXG4gICAgICB2YXIgZmlsbFJ1bGUgPSB0aGlzLmZpbGxSdWxlID8gdGhpcy5maWxsUnVsZSA6ICdub256ZXJvJyxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGggPyB0aGlzLnN0cm9rZVdpZHRoIDogJzAnLFxuICAgICAgICAgIHN0cm9rZURhc2hBcnJheSA9IHRoaXMuc3Ryb2tlRGFzaEFycmF5ID8gdGhpcy5zdHJva2VEYXNoQXJyYXkuam9pbignICcpIDogJ25vbmUnLFxuICAgICAgICAgIHN0cm9rZURhc2hPZmZzZXQgPSB0aGlzLnN0cm9rZURhc2hPZmZzZXQgPyB0aGlzLnN0cm9rZURhc2hPZmZzZXQgOiAnMCcsXG4gICAgICAgICAgc3Ryb2tlTGluZUNhcCA9IHRoaXMuc3Ryb2tlTGluZUNhcCA/IHRoaXMuc3Ryb2tlTGluZUNhcCA6ICdidXR0JyxcbiAgICAgICAgICBzdHJva2VMaW5lSm9pbiA9IHRoaXMuc3Ryb2tlTGluZUpvaW4gPyB0aGlzLnN0cm9rZUxpbmVKb2luIDogJ21pdGVyJyxcbiAgICAgICAgICBzdHJva2VNaXRlckxpbWl0ID0gdGhpcy5zdHJva2VNaXRlckxpbWl0ID8gdGhpcy5zdHJva2VNaXRlckxpbWl0IDogJzQnLFxuICAgICAgICAgIG9wYWNpdHkgPSB0eXBlb2YgdGhpcy5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJyA/IHRoaXMub3BhY2l0eSA6ICcxJyxcbiAgICAgICAgICB2aXNpYmlsaXR5ID0gdGhpcy52aXNpYmxlID8gJycgOiAnIHZpc2liaWxpdHk6IGhpZGRlbjsnLFxuICAgICAgICAgIGZpbHRlciA9IHNraXBTaGFkb3cgPyAnJyA6IHRoaXMuZ2V0U3ZnRmlsdGVyKCksXG4gICAgICAgICAgZmlsbCA9IGdldFN2Z0NvbG9yU3RyaW5nKCdmaWxsJywgdGhpcy5maWxsKSxcbiAgICAgICAgICBzdHJva2UgPSBnZXRTdmdDb2xvclN0cmluZygnc3Ryb2tlJywgdGhpcy5zdHJva2UpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzdHJva2UsXG4gICAgICAgICdzdHJva2Utd2lkdGg6ICcsIHN0cm9rZVdpZHRoLCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheTogJywgc3Ryb2tlRGFzaEFycmF5LCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVjYXA6ICcsIHN0cm9rZUxpbmVDYXAsICc7ICcsXG4gICAgICAgICdzdHJva2UtZGFzaG9mZnNldDogJywgc3Ryb2tlRGFzaE9mZnNldCwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1saW5lam9pbjogJywgc3Ryb2tlTGluZUpvaW4sICc7ICcsXG4gICAgICAgICdzdHJva2UtbWl0ZXJsaW1pdDogJywgc3Ryb2tlTWl0ZXJMaW1pdCwgJzsgJyxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgJ2ZpbGwtcnVsZTogJywgZmlsbFJ1bGUsICc7ICcsXG4gICAgICAgICdvcGFjaXR5OiAnLCBvcGFjaXR5LCAnOycsXG4gICAgICAgIGZpbHRlcixcbiAgICAgICAgdmlzaWJpbGl0eVxuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIHRoZSBvYmplY3QgZnJvbSB3aGljaCB0byByZXRyaWV2ZSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB1c2VXaGl0ZVNwYWNlIGEgYm9vbGVhbiB0byBpbmNsdWRlIGFuIGFkZGl0aW9uYWwgYXR0cmlidXRlIGluIHRoZSBzdHlsZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnU3BhblN0eWxlczogZnVuY3Rpb24oc3R5bGUsIHVzZVdoaXRlU3BhY2UpIHtcbiAgICAgIHZhciB0ZXJtID0gJzsgJztcbiAgICAgIHZhciBmb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseSA/XG4gICAgICAgICdmb250LWZhbWlseTogJyArICgoKHN0eWxlLmZvbnRGYW1pbHkuaW5kZXhPZignXFwnJykgPT09IC0xICYmIHN0eWxlLmZvbnRGYW1pbHkuaW5kZXhPZignXCInKSA9PT0gLTEpID9cbiAgICAgICAgICAnXFwnJyArIHN0eWxlLmZvbnRGYW1pbHkgICsgJ1xcJycgOiBzdHlsZS5mb250RmFtaWx5KSkgKyB0ZXJtIDogJyc7XG4gICAgICB2YXIgc3Ryb2tlV2lkdGggPSBzdHlsZS5zdHJva2VXaWR0aCA/ICdzdHJva2Utd2lkdGg6ICcgKyBzdHlsZS5zdHJva2VXaWR0aCArIHRlcm0gOiAnJyxcbiAgICAgICAgICBmb250RmFtaWx5ID0gZm9udEZhbWlseSxcbiAgICAgICAgICBmb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplID8gJ2ZvbnQtc2l6ZTogJyArIHN0eWxlLmZvbnRTaXplICsgJ3B4JyArIHRlcm0gOiAnJyxcbiAgICAgICAgICBmb250U3R5bGUgPSBzdHlsZS5mb250U3R5bGUgPyAnZm9udC1zdHlsZTogJyArIHN0eWxlLmZvbnRTdHlsZSArIHRlcm0gOiAnJyxcbiAgICAgICAgICBmb250V2VpZ2h0ID0gc3R5bGUuZm9udFdlaWdodCA/ICdmb250LXdlaWdodDogJyArIHN0eWxlLmZvbnRXZWlnaHQgKyB0ZXJtIDogJycsXG4gICAgICAgICAgZmlsbCA9IHN0eWxlLmZpbGwgPyBnZXRTdmdDb2xvclN0cmluZygnZmlsbCcsIHN0eWxlLmZpbGwpIDogJycsXG4gICAgICAgICAgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlID8gZ2V0U3ZnQ29sb3JTdHJpbmcoJ3N0cm9rZScsIHN0eWxlLnN0cm9rZSkgOiAnJyxcbiAgICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9IHRoaXMuZ2V0U3ZnVGV4dERlY29yYXRpb24oc3R5bGUpLFxuICAgICAgICAgIGRlbHRhWSA9IHN0eWxlLmRlbHRhWSA/ICdiYXNlbGluZS1zaGlmdDogJyArICgtc3R5bGUuZGVsdGFZKSArICc7ICcgOiAnJztcbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbikge1xuICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9ICd0ZXh0LWRlY29yYXRpb246ICcgKyB0ZXh0RGVjb3JhdGlvbiArIHRlcm07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIGZvbnRGYW1pbHksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICBmb250U3R5bGUsXG4gICAgICAgIGZvbnRXZWlnaHQsXG4gICAgICAgIHRleHREZWNvcmF0aW9uLFxuICAgICAgICBmaWxsLFxuICAgICAgICBkZWx0YVksXG4gICAgICAgIHVzZVdoaXRlU3BhY2UgPyAnd2hpdGUtc3BhY2U6IHByZTsgJyA6ICcnXG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRleHQtZGVjb3JhdGlvbiBwcm9wZXJ0eSBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSB0aGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gcmV0cmlldmUgc3R5bGUgcHJvcGVydGllc1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdUZXh0RGVjb3JhdGlvbjogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHJldHVybiBbJ292ZXJsaW5lJywgJ3VuZGVybGluZScsICdsaW5lLXRocm91Z2gnXS5maWx0ZXIoZnVuY3Rpb24oZGVjb3JhdGlvbikge1xuICAgICAgICByZXR1cm4gc3R5bGVbZGVjb3JhdGlvbi5yZXBsYWNlKCctJywgJycpXTtcbiAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBmaWx0ZXIgZm9yIHN2ZyBzaGFkb3dcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnRmlsdGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYWRvdyA/ICdmaWx0ZXI6IHVybCgjU1ZHSURfJyArIHRoaXMuc2hhZG93LmlkICsgJyk7JyA6ICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlkIGF0dHJpYnV0ZSBmb3Igc3ZnIG91dHB1dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdDb21tb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRoaXMuaWQgPyAnaWQ9XCInICsgdGhpcy5pZCArICdcIiAnIDogJycsXG4gICAgICAgIHRoaXMuY2xpcFBhdGggPyAnY2xpcC1wYXRoPVwidXJsKCMnICsgdGhpcy5jbGlwUGF0aC5jbGlwUGF0aElkICsgJylcIiAnIDogJycsXG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRyYW5zZm9ybS1zdHJpbmcgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZSB0aGUgZnVsbCB0cmFuc2Zvcm0gb3IgdGhlIHNpbmdsZSBvYmplY3Qgb25lLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdUcmFuc2Zvcm06IGZ1bmN0aW9uKGZ1bGwsIGFkZGl0aW9uYWxUcmFuc2Zvcm0pIHtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBmdWxsID8gdGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCkgOiB0aGlzLmNhbGNPd25NYXRyaXgoKSxcbiAgICAgICAgICBzdmdUcmFuc2Zvcm0gPSAndHJhbnNmb3JtPVwiJyArIGZhYnJpYy51dGlsLm1hdHJpeFRvU1ZHKHRyYW5zZm9ybSk7XG4gICAgICByZXR1cm4gc3ZnVHJhbnNmb3JtICtcbiAgICAgICAgKGFkZGl0aW9uYWxUcmFuc2Zvcm0gfHwgJycpICsgJ1wiICc7XG4gICAgfSxcblxuICAgIF9zZXRTVkdCZzogZnVuY3Rpb24odGV4dEJnUmVjdHMpIHtcbiAgICAgIGlmICh0aGlzLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcbiAgICAgICAgdGV4dEJnUmVjdHMucHVzaChcbiAgICAgICAgICAnXFx0XFx0PHJlY3QgJyxcbiAgICAgICAgICB0aGlzLl9nZXRGaWxsQXR0cmlidXRlcyh0aGlzLmJhY2tncm91bmRDb2xvciksXG4gICAgICAgICAgJyB4PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKC10aGlzLndpZHRoIC8gMiwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgJ1wiIHk9XCInLFxuICAgICAgICAgIHRvRml4ZWQoLXRoaXMuaGVpZ2h0IC8gMiwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgJ1wiIHdpZHRoPVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKHRoaXMud2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIiBoZWlnaHQ9XCInLFxuICAgICAgICAgIHRvRml4ZWQodGhpcy5oZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIj48L3JlY3Q+XFxuJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cCh0aGlzLl90b1NWRyhyZXZpdmVyKSwgeyByZXZpdmVyOiByZXZpdmVyIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyBjbGlwUGF0aCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0NsaXBQYXRoU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICByZXR1cm4gJ1xcdCcgKyB0aGlzLl9jcmVhdGVCYXNlQ2xpcFBhdGhTVkdNYXJrdXAodGhpcy5fdG9TVkcocmV2aXZlciksIHsgcmV2aXZlcjogcmV2aXZlciB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQmFzZUNsaXBQYXRoU1ZHTWFya3VwOiBmdW5jdGlvbihvYmplY3RNYXJrdXAsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdmFyIHJldml2ZXIgPSBvcHRpb25zLnJldml2ZXIsXG4gICAgICAgICAgYWRkaXRpb25hbFRyYW5zZm9ybSA9IG9wdGlvbnMuYWRkaXRpb25hbFRyYW5zZm9ybSB8fCAnJyxcbiAgICAgICAgICBjb21tb25QaWVjZXMgPSBbXG4gICAgICAgICAgICB0aGlzLmdldFN2Z1RyYW5zZm9ybSh0cnVlLCBhZGRpdGlvbmFsVHJhbnNmb3JtKSxcbiAgICAgICAgICAgIHRoaXMuZ2V0U3ZnQ29tbW9ucygpLFxuICAgICAgICAgIF0uam9pbignJyksXG4gICAgICAgICAgLy8gaW5zZXJ0IGNvbW1vbnMgaW4gdGhlIG1hcmt1cCwgc3R5bGUgYW5kIHN2Z0NvbW1vbnNcbiAgICAgICAgICBpbmRleCA9IG9iamVjdE1hcmt1cC5pbmRleE9mKCdDT01NT05fUEFSVFMnKTtcbiAgICAgIG9iamVjdE1hcmt1cFtpbmRleF0gPSBjb21tb25QaWVjZXM7XG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIob2JqZWN0TWFya3VwLmpvaW4oJycpKSA6IG9iamVjdE1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlQmFzZVNWR01hcmt1cDogZnVuY3Rpb24ob2JqZWN0TWFya3VwLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBub1N0eWxlID0gb3B0aW9ucy5ub1N0eWxlLFxuICAgICAgICAgIHJldml2ZXIgPSBvcHRpb25zLnJldml2ZXIsXG4gICAgICAgICAgc3R5bGVJbmZvID0gbm9TdHlsZSA/ICcnIDogJ3N0eWxlPVwiJyArIHRoaXMuZ2V0U3ZnU3R5bGVzKCkgKyAnXCIgJyxcbiAgICAgICAgICBzaGFkb3dJbmZvID0gb3B0aW9ucy53aXRoU2hhZG93ID8gJ3N0eWxlPVwiJyArIHRoaXMuZ2V0U3ZnRmlsdGVyKCkgKyAnXCIgJyA6ICcnLFxuICAgICAgICAgIGNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aCxcbiAgICAgICAgICB2ZWN0b3JFZmZlY3QgPSB0aGlzLnN0cm9rZVVuaWZvcm0gPyAndmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiICcgOiAnJyxcbiAgICAgICAgICBhYnNvbHV0ZUNsaXBQYXRoID0gY2xpcFBhdGggJiYgY2xpcFBhdGguYWJzb2x1dGVQb3NpdGlvbmVkLFxuICAgICAgICAgIHN0cm9rZSA9IHRoaXMuc3Ryb2tlLCBmaWxsID0gdGhpcy5maWxsLCBzaGFkb3cgPSB0aGlzLnNoYWRvdyxcbiAgICAgICAgICBjb21tb25QaWVjZXMsIG1hcmt1cCA9IFtdLCBjbGlwUGF0aE1hcmt1cCxcbiAgICAgICAgICAvLyBpbnNlcnQgY29tbW9ucyBpbiB0aGUgbWFya3VwLCBzdHlsZSBhbmQgc3ZnQ29tbW9uc1xuICAgICAgICAgIGluZGV4ID0gb2JqZWN0TWFya3VwLmluZGV4T2YoJ0NPTU1PTl9QQVJUUycpLFxuICAgICAgICAgIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSBvcHRpb25zLmFkZGl0aW9uYWxUcmFuc2Zvcm07XG4gICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgY2xpcFBhdGguY2xpcFBhdGhJZCA9ICdDTElQUEFUSF8nICsgZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgICBjbGlwUGF0aE1hcmt1cCA9ICc8Y2xpcFBhdGggaWQ9XCInICsgY2xpcFBhdGguY2xpcFBhdGhJZCArICdcIiA+XFxuJyArXG4gICAgICAgICAgY2xpcFBhdGgudG9DbGlwUGF0aFNWRyhyZXZpdmVyKSArXG4gICAgICAgICAgJzwvY2xpcFBhdGg+XFxuJztcbiAgICAgIH1cbiAgICAgIGlmIChhYnNvbHV0ZUNsaXBQYXRoKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8ZyAnLCBzaGFkb3dJbmZvLCB0aGlzLmdldFN2Z0NvbW1vbnMoKSwgJyA+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8ZyAnLFxuICAgICAgICB0aGlzLmdldFN2Z1RyYW5zZm9ybShmYWxzZSksXG4gICAgICAgICFhYnNvbHV0ZUNsaXBQYXRoID8gc2hhZG93SW5mbyArIHRoaXMuZ2V0U3ZnQ29tbW9ucygpIDogJycsXG4gICAgICAgICcgPlxcbidcbiAgICAgICk7XG4gICAgICBjb21tb25QaWVjZXMgPSBbXG4gICAgICAgIHN0eWxlSW5mbyxcbiAgICAgICAgdmVjdG9yRWZmZWN0LFxuICAgICAgICBub1N0eWxlID8gJycgOiB0aGlzLmFkZFBhaW50T3JkZXIoKSwgJyAnLFxuICAgICAgICBhZGRpdGlvbmFsVHJhbnNmb3JtID8gJ3RyYW5zZm9ybT1cIicgKyBhZGRpdGlvbmFsVHJhbnNmb3JtICsgJ1wiICcgOiAnJyxcbiAgICAgIF0uam9pbignJyk7XG4gICAgICBvYmplY3RNYXJrdXBbaW5kZXhdID0gY29tbW9uUGllY2VzO1xuICAgICAgaWYgKGZpbGwgJiYgZmlsbC50b0xpdmUpIHtcbiAgICAgICAgbWFya3VwLnB1c2goZmlsbC50b1NWRyh0aGlzKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3Ryb2tlICYmIHN0cm9rZS50b0xpdmUpIHtcbiAgICAgICAgbWFya3VwLnB1c2goc3Ryb2tlLnRvU1ZHKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaGFkb3cpIHtcbiAgICAgICAgbWFya3VwLnB1c2goc2hhZG93LnRvU1ZHKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICBtYXJrdXAucHVzaChjbGlwUGF0aE1hcmt1cCk7XG4gICAgICB9XG4gICAgICBtYXJrdXAucHVzaChvYmplY3RNYXJrdXAuam9pbignJykpO1xuICAgICAgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcbiAgICAgIGFic29sdXRlQ2xpcFBhdGggJiYgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcbiAgICAgIHJldHVybiByZXZpdmVyID8gcmV2aXZlcihtYXJrdXAuam9pbignJykpIDogbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBhZGRQYWludE9yZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhaW50Rmlyc3QgIT09ICdmaWxsJyA/ICcgcGFpbnQtb3JkZXI9XCInICsgdGhpcy5wYWludEZpcnN0ICsgJ1wiICcgOiAnJztcbiAgICB9XG4gIH0pO1xufSkoKTtcbi8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIG9yaWdpbmFsU2V0ID0gJ3N0YXRlUHJvcGVydGllcyc7XG5cbiAgLypcbiAgICBEZXBlbmRzIG9uIGBzdGF0ZVByb3BlcnRpZXNgXG4gICovXG4gIGZ1bmN0aW9uIHNhdmVQcm9wcyhvcmlnaW4sIGRlc3RpbmF0aW9uLCBwcm9wcykge1xuICAgIHZhciB0bXBPYmogPSB7IH0sIGRlZXAgPSB0cnVlO1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgdG1wT2JqW3Byb3BdID0gb3JpZ2luW3Byb3BdO1xuICAgIH0pO1xuXG4gICAgZXh0ZW5kKG9yaWdpbltkZXN0aW5hdGlvbl0sIHRtcE9iaiwgZGVlcCk7XG4gIH1cblxuICBmdW5jdGlvbiBfaXNFcXVhbChvcmlnVmFsdWUsIGN1cnJlbnRWYWx1ZSwgZmlyc3RQYXNzKSB7XG4gICAgaWYgKG9yaWdWYWx1ZSA9PT0gY3VycmVudFZhbHVlKSB7XG4gICAgICAvLyBpZiB0aGUgb2JqZWN0cyBhcmUgaWRlbnRpY2FsLCByZXR1cm5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9yaWdWYWx1ZSkpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpIHx8IG9yaWdWYWx1ZS5sZW5ndGggIT09IGN1cnJlbnRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9yaWdWYWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIV9pc0VxdWFsKG9yaWdWYWx1ZVtpXSwgY3VycmVudFZhbHVlW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9yaWdWYWx1ZSAmJiB0eXBlb2Ygb3JpZ1ZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcmlnVmFsdWUpLCBrZXk7XG4gICAgICBpZiAoIWN1cnJlbnRWYWx1ZSB8fFxuICAgICAgICAgIHR5cGVvZiBjdXJyZW50VmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgKCFmaXJzdFBhc3MgJiYga2V5cy5sZW5ndGggIT09IE9iamVjdC5rZXlzKGN1cnJlbnRWYWx1ZSkubGVuZ3RoKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIC8vIHNpbmNlIGNsaXBQYXRoIGlzIGluIHRoZSBzdGF0ZWZ1bGwgY2FjaGUgbGlzdCBhbmQgdGhlIGNsaXBQYXRoIG9iamVjdHNcbiAgICAgICAgLy8gd291bGQgYmUgaXRlcmF0ZWQgYXMgYW4gb2JqZWN0LCB0aGlzIHdvdWxkIGxlYWQgdG8gcG9zc2libGUgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGNvbXBhcmUgdGhvc2UuXG4gICAgICAgIGlmIChrZXkgPT09ICdjYW52YXMnIHx8IGtleSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX2lzRXF1YWwob3JpZ1ZhbHVlW2tleV0sIGN1cnJlbnRWYWx1ZVtrZXldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3Qgc3RhdGUgKG9uZSBvZiBpdHMgc3RhdGUgcHJvcGVydGllcykgd2FzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5U2V0XSBvcHRpb25hbCBuYW1lIGZvciB0aGUgc2V0IG9mIHByb3BlcnR5IHdlIHdhbnQgdG8gc2F2ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgaW5zdGFuY2UnIHN0YXRlIGhhcyBjaGFuZ2VkIHNpbmNlIGB7QGxpbmsgZmFicmljLk9iamVjdCNzYXZlU3RhdGV9YCB3YXMgY2FsbGVkXG4gICAgICovXG4gICAgaGFzU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbihwcm9wZXJ0eVNldCkge1xuICAgICAgcHJvcGVydHlTZXQgPSBwcm9wZXJ0eVNldCB8fCBvcmlnaW5hbFNldDtcbiAgICAgIHZhciBkYXNoZWRQcm9wZXJ0eVNldCA9ICdfJyArIHByb3BlcnR5U2V0O1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXNbZGFzaGVkUHJvcGVydHlTZXRdKS5sZW5ndGggPCB0aGlzW3Byb3BlcnR5U2V0XS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gIV9pc0VxdWFsKHRoaXNbZGFzaGVkUHJvcGVydHlTZXRdLCB0aGlzLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2F2ZXMgc3RhdGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGBzdGF0ZVByb3BlcnRpZXNgIGFycmF5IHRvIGluY2x1ZGUgd2hlbiBzYXZpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgc2F2ZVN0YXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvcGVydHlTZXQgPSBvcHRpb25zICYmIG9wdGlvbnMucHJvcGVydHlTZXQgfHwgb3JpZ2luYWxTZXQsXG4gICAgICAgICAgZGVzdGluYXRpb24gPSAnXycgKyBwcm9wZXJ0eVNldDtcbiAgICAgIGlmICghdGhpc1tkZXN0aW5hdGlvbl0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dXBTdGF0ZShvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHNhdmVQcm9wcyh0aGlzLCBkZXN0aW5hdGlvbiwgdGhpc1twcm9wZXJ0eVNldF0pO1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zdGF0ZVByb3BlcnRpZXMpIHtcbiAgICAgICAgc2F2ZVByb3BzKHRoaXMsIGRlc3RpbmF0aW9uLCBvcHRpb25zLnN0YXRlUHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dXBzIHN0YXRlIG9mIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggYWRkaXRpb25hbCBgc3RhdGVQcm9wZXJ0aWVzYCBhcnJheSB0byBpbmNsdWRlIHdoZW4gc2F2aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNldHVwU3RhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgfTtcbiAgICAgIHZhciBwcm9wZXJ0eVNldCA9IG9wdGlvbnMucHJvcGVydHlTZXQgfHwgb3JpZ2luYWxTZXQ7XG4gICAgICBvcHRpb25zLnByb3BlcnR5U2V0ID0gcHJvcGVydHlTZXQ7XG4gICAgICB0aGlzWydfJyArIHByb3BlcnR5U2V0XSA9IHsgfTtcbiAgICAgIHRoaXMuc2F2ZVN0YXRlKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucztcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoaWNoIGNvcm5lciBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciBUaGUgcG9pbnRlciBpbmRpY2F0aW5nIHRoZSBtb3VzZSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge1N0cmluZ3xCb29sZWFufSBjb3JuZXIgY29kZSAodGwsIHRyLCBibCwgYnIsIGV0Yy4pLCBvciBmYWxzZSBpZiBub3RoaW5nIGlzIGZvdW5kXG4gICAgICovXG4gICAgX2ZpbmRUYXJnZXRDb3JuZXI6IGZ1bmN0aW9uKHBvaW50ZXIsIGZvclRvdWNoKSB7XG4gICAgICAvLyBvYmplY3RzIGluIGdyb3VwLCBhbnlraW5kLCBhcmUgbm90IHNlbGYgbW9kaWZpY2FibGUsXG4gICAgICAvLyBtdXN0IG5vdCByZXR1cm4gYW4gaG92ZXJlZCBjb3JuZXIuXG4gICAgICBpZiAoIXRoaXMuaGFzQ29udHJvbHMgfHwgdGhpcy5ncm91cCB8fCAoIXRoaXMuY2FudmFzIHx8IHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3QgIT09IHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4ID0gcG9pbnRlci54LFxuICAgICAgICAgIGV5ID0gcG9pbnRlci55LFxuICAgICAgICAgIHhQb2ludHMsXG4gICAgICAgICAgbGluZXMsIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm9Db29yZHMpLFxuICAgICAgICAgIGogPSBrZXlzLmxlbmd0aCAtIDEsIGk7XG4gICAgICB0aGlzLl9fY29ybmVyID0gMDtcblxuICAgICAgLy8gY3ljbGUgaW4gcmV2ZXJzZSBvcmRlciBzbyB3ZSBwaWNrIGZpcnN0IHRoZSBvbmUgb24gdG9wXG4gICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgaSA9IGtleXNbal07XG4gICAgICAgIGlmICghdGhpcy5pc0NvbnRyb2xWaXNpYmxlKGkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lcyA9IHRoaXMuX2dldEltYWdlTGluZXMoZm9yVG91Y2ggPyB0aGlzLm9Db29yZHNbaV0udG91Y2hDb3JuZXIgOiB0aGlzLm9Db29yZHNbaV0uY29ybmVyKTtcbiAgICAgICAgLy8gLy8gZGVidWdnaW5nXG4gICAgICAgIC8vXG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMuYm90dG9tbGluZS5kLngsIGxpbmVzLmJvdHRvbWxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5ib3R0b21saW5lLm8ueCwgbGluZXMuYm90dG9tbGluZS5vLnksIDIsIDIpO1xuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmxlZnRsaW5lLmQueCwgbGluZXMubGVmdGxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5sZWZ0bGluZS5vLngsIGxpbmVzLmxlZnRsaW5lLm8ueSwgMiwgMik7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMudG9wbGluZS5kLngsIGxpbmVzLnRvcGxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy50b3BsaW5lLm8ueCwgbGluZXMudG9wbGluZS5vLnksIDIsIDIpO1xuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnJpZ2h0bGluZS5kLngsIGxpbmVzLnJpZ2h0bGluZS5kLnksIDIsIDIpO1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnJpZ2h0bGluZS5vLngsIGxpbmVzLnJpZ2h0bGluZS5vLnksIDIsIDIpO1xuXG4gICAgICAgIHhQb2ludHMgPSB0aGlzLl9maW5kQ3Jvc3NQb2ludHMoeyB4OiBleCwgeTogZXkgfSwgbGluZXMpO1xuICAgICAgICBpZiAoeFBvaW50cyAhPT0gMCAmJiB4UG9pbnRzICUgMiA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuX19jb3JuZXIgPSBpO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGxzIGEgZnVuY3Rpb24gZm9yIGVhY2ggY29udHJvbC4gVGhlIGZ1bmN0aW9uIGdldHMgY2FsbGVkLFxuICAgICAqIHdpdGggdGhlIGNvbnRyb2wsIHRoZSBvYmplY3QgdGhhdCBpcyBjYWxsaW5nIHRoZSBpdGVyYXRvciBhbmQgdGhlIGNvbnRyb2wncyBrZXlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgdGhlIGNvbnRyb2xzIG92ZXJcbiAgICAgKi9cbiAgICBmb3JFYWNoQ29udHJvbDogZnVuY3Rpb24oZm4pIHtcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5jb250cm9scykge1xuICAgICAgICBmbih0aGlzLmNvbnRyb2xzW2ldLCBpLCB0aGlzKTtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBkcmFnZ2FibGUgYm94ZXMgaW4gdGhlIGNvcm5lcnMgb2ZcbiAgICAgKiB0aGUgaW1hZ2UgdXNlZCB0byBzY2FsZS9yb3RhdGUgaXQuXG4gICAgICogbm90ZTogaWYgd2Ugd291bGQgc3dpdGNoIHRvIFJPVU5EIGNvcm5lciBhcmVhLCBhbGwgb2YgdGhpcyB3b3VsZCBkaXNhcHBlYXIuXG4gICAgICogZXZlcnl0aGluZyB3b3VsZCByZXNvbHZlIHRvIGEgc2luZ2xlIHBvaW50IGFuZCBhIHB5dGhhZ29yZWFuIHRoZW9yZW0gZm9yIHRoZSBkaXN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldENvcm5lckNvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5vQ29vcmRzO1xuXG4gICAgICBmb3IgKHZhciBjb250cm9sIGluIGNvb3Jkcykge1xuICAgICAgICB2YXIgY29udHJvbE9iamVjdCA9IHRoaXMuY29udHJvbHNbY29udHJvbF07XG4gICAgICAgIGNvb3Jkc1tjb250cm9sXS5jb3JuZXIgPSBjb250cm9sT2JqZWN0LmNhbGNDb3JuZXJDb29yZHMoXG4gICAgICAgICAgdGhpcy5hbmdsZSwgdGhpcy5jb3JuZXJTaXplLCBjb29yZHNbY29udHJvbF0ueCwgY29vcmRzW2NvbnRyb2xdLnksIGZhbHNlKTtcbiAgICAgICAgY29vcmRzW2NvbnRyb2xdLnRvdWNoQ29ybmVyID0gY29udHJvbE9iamVjdC5jYWxjQ29ybmVyQ29vcmRzKFxuICAgICAgICAgIHRoaXMuYW5nbGUsIHRoaXMudG91Y2hDb3JuZXJTaXplLCBjb29yZHNbY29udHJvbF0ueCwgY29vcmRzW2NvbnRyb2xdLnksIHRydWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGNvbG9yZWQgbGF5ZXIgYmVoaW5kIHRoZSBvYmplY3QsIGluc2lkZSBpdHMgc2VsZWN0aW9uIGJvcmRlcnMuXG4gICAgICogUmVxdWlyZXMgcHVibGljIG9wdGlvbnM6IHBhZGRpbmcsIHNlbGVjdGlvbkJhY2tncm91bmRDb2xvclxuICAgICAqIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIGNvbnRleHQgaXMgdHJhbnNmb3JtZWRcbiAgICAgKiBoYXMgY2hlY2tzIHRvIGJlIHNraXBwZWQgd2hlbiB0aGUgb2JqZWN0IGlzIG9uIGEgc3RhdGljQ2FudmFzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdTZWxlY3Rpb25CYWNrZ3JvdW5kOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IgfHxcbiAgICAgICAgKHRoaXMuY2FudmFzICYmICF0aGlzLmNhbnZhcy5pbnRlcmFjdGl2ZSkgfHxcbiAgICAgICAgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLl9hY3RpdmVPYmplY3QgIT09IHRoaXMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSwgd2ggPSB0aGlzLl9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9ucygpLFxuICAgICAgICAgIHZwdCA9IHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgY3R4LnRyYW5zbGF0ZShjZW50ZXIueCwgY2VudGVyLnkpO1xuICAgICAgY3R4LnNjYWxlKDEgLyB2cHRbMF0sIDEgLyB2cHRbM10pO1xuICAgICAgY3R4LnJvdGF0ZShkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdCgtd2gueCAvIDIsIC13aC55IC8gMiwgd2gueCwgd2gueSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvcmRlcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94LlxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBwcm9wZXJ0aWVzOiB3aWR0aCwgaGVpZ2h0XG4gICAgICogUmVxdWlyZXMgcHVibGljIG9wdGlvbnM6IHBhZGRpbmcsIGJvcmRlckNvbG9yXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVPdmVycmlkZSBvYmplY3QgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZHJhd0JvcmRlcnM6IGZ1bmN0aW9uKGN0eCwgc3R5bGVPdmVycmlkZSkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICB2YXIgd2ggPSB0aGlzLl9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9ucygpLFxuICAgICAgICAgIHN0cm9rZVdpZHRoID0gdGhpcy5ib3JkZXJTY2FsZUZhY3RvcixcbiAgICAgICAgICB3aWR0aCA9IHdoLnggKyBzdHJva2VXaWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSB3aC55ICsgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgaGFzQ29udHJvbHMgPSB0eXBlb2Ygc3R5bGVPdmVycmlkZS5oYXNDb250cm9scyAhPT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgICAgc3R5bGVPdmVycmlkZS5oYXNDb250cm9scyA6IHRoaXMuaGFzQ29udHJvbHMsXG4gICAgICAgICAgc2hvdWxkU3Ryb2tlID0gZmFsc2U7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmJvcmRlckNvbG9yIHx8IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHN0eWxlT3ZlcnJpZGUuYm9yZGVyRGFzaEFycmF5IHx8IHRoaXMuYm9yZGVyRGFzaEFycmF5KTtcblxuICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgIC13aWR0aCAvIDIsXG4gICAgICAgIC1oZWlnaHQgLyAyLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuXG4gICAgICBpZiAoaGFzQ29udHJvbHMpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmZvckVhY2hDb250cm9sKGZ1bmN0aW9uKGNvbnRyb2wsIGtleSwgZmFicmljT2JqZWN0KSB7XG4gICAgICAgICAgLy8gaW4gdGhpcyBtb21lbnQsIHRoZSBjdHggaXMgY2VudGVyZWQgb24gdGhlIG9iamVjdC5cbiAgICAgICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBhYm92ZSBmdW5jdGlvbiBhcmUgdGhlIHNpemUgb2YgdGhlIGJib3guXG4gICAgICAgICAgaWYgKGNvbnRyb2wud2l0aENvbm5lY3Rpb24gJiYgY29udHJvbC5nZXRWaXNpYmlsaXR5KGZhYnJpY09iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgLy8gcmVzZXQgbW92ZW1lbnQgZm9yIGVhY2ggY29udHJvbFxuICAgICAgICAgICAgc2hvdWxkU3Ryb2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oY29udHJvbC54ICogd2lkdGgsIGNvbnRyb2wueSAqIGhlaWdodCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKFxuICAgICAgICAgICAgICBjb250cm9sLnggKiB3aWR0aCArIGNvbnRyb2wub2Zmc2V0WCxcbiAgICAgICAgICAgICAgY29udHJvbC55ICogaGVpZ2h0ICsgY29udHJvbC5vZmZzZXRZXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzaG91bGRTdHJva2UpIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYm9yZGVycyBvZiBhbiBvYmplY3QncyBib3VuZGluZyBib3ggd2hlbiBpdCBpcyBpbnNpZGUgYSBncm91cC5cbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgcHJvcGVydGllczogd2lkdGgsIGhlaWdodFxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBvcHRpb25zOiBwYWRkaW5nLCBib3JkZXJDb2xvclxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgb2JqZWN0IHJlcHJlc2VudGluZyBjdXJyZW50IG9iamVjdCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdCb3JkZXJzSW5Hcm91cDogZnVuY3Rpb24oY3R4LCBvcHRpb25zLCBzdHlsZU92ZXJyaWRlKSB7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICAgIHZhciBiYm94ID0gZmFicmljLnV0aWwuc2l6ZUFmdGVyVHJhbnNmb3JtKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBvcHRpb25zKSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgc3Ryb2tlVW5pZm9ybSA9IHRoaXMuc3Ryb2tlVW5pZm9ybSxcbiAgICAgICAgICBib3JkZXJTY2FsZUZhY3RvciA9IHRoaXMuYm9yZGVyU2NhbGVGYWN0b3IsXG4gICAgICAgICAgd2lkdGggPVxuICAgICAgICAgICAgYmJveC54ICsgc3Ryb2tlV2lkdGggKiAoc3Ryb2tlVW5pZm9ybSA/IHRoaXMuY2FudmFzLmdldFpvb20oKSA6IG9wdGlvbnMuc2NhbGVYKSArIGJvcmRlclNjYWxlRmFjdG9yLFxuICAgICAgICAgIGhlaWdodCA9XG4gICAgICAgICAgICBiYm94LnkgKyBzdHJva2VXaWR0aCAqIChzdHJva2VVbmlmb3JtID8gdGhpcy5jYW52YXMuZ2V0Wm9vbSgpIDogb3B0aW9ucy5zY2FsZVkpICsgYm9yZGVyU2NhbGVGYWN0b3I7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCBzdHlsZU92ZXJyaWRlLmJvcmRlckRhc2hBcnJheSB8fCB0aGlzLmJvcmRlckRhc2hBcnJheSk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmJvcmRlckNvbG9yIHx8IHRoaXMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguc3Ryb2tlUmVjdChcbiAgICAgICAgLXdpZHRoIC8gMixcbiAgICAgICAgLWhlaWdodCAvIDIsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgICk7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgY29ybmVycyBvZiBhbiBvYmplY3QncyBib3VuZGluZyBib3guXG4gICAgICogUmVxdWlyZXMgcHVibGljIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHRcbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogY29ybmVyU2l6ZSwgcGFkZGluZ1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdDb250cm9sczogZnVuY3Rpb24oY3R4LCBzdHlsZU92ZXJyaWRlKSB7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgcmV0aW5hU2NhbGluZyA9IHRoaXMuY2FudmFzLmdldFJldGluYVNjYWxpbmcoKSwgbWF0cml4LCBwO1xuICAgICAgY3R4LnNldFRyYW5zZm9ybShyZXRpbmFTY2FsaW5nLCAwLCAwLCByZXRpbmFTY2FsaW5nLCAwLCAwKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmNvcm5lckNvbG9yIHx8IHRoaXMuY29ybmVyQ29sb3I7XG4gICAgICBpZiAoIXRoaXMudHJhbnNwYXJlbnRDb3JuZXJzKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlT3ZlcnJpZGUuY29ybmVyU3Ryb2tlQ29sb3IgfHwgdGhpcy5jb3JuZXJTdHJva2VDb2xvcjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgc3R5bGVPdmVycmlkZS5jb3JuZXJEYXNoQXJyYXkgfHwgdGhpcy5jb3JuZXJEYXNoQXJyYXkpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIC8vIGZhYnJpY0pTIGRvZXMgbm90IHJlYWxseSBzdXBwb3J0IGRyYXdpbmcgY29udHJvbHMgaW5zaWRlIGdyb3VwcyxcbiAgICAgICAgLy8gdGhpcyBwaWVjZSBvZiBjb2RlIGhlcmUgaGVscHMgaGF2aW5nIGF0IGxlYXN0IHRoZSBjb250cm9sIGluIHBsYWNlcy5cbiAgICAgICAgLy8gSWYgYW4gYXBwbGljYXRpb24gbmVlZHMgdG8gc2hvdyBzb21lIG9iamVjdHMgYXMgc2VsZWN0ZWQgYmVjYXVzZSBvZiBzb21lIFVJIHN0YXRlXG4gICAgICAgIC8vIGNhbiBzdGlsbCBjYWxsIE9iamVjdC5fcmVuZGVyQ29udHJvbHMoKSBvbiBhbnkgb2JqZWN0IHRoZXkgZGVzaXJlLCBpbmRlcGVuZGVudGx5IG9mIGdyb3Vwcy5cbiAgICAgICAgLy8gdXNpbmcgbm8gcGFkZGluZywgY2lyY3VsYXIgY29udHJvbHMgYW5kIGhpZGluZyB0aGUgcm90YXRpbmcgY3Vyc29yIGlzIGhpZ2x5IHN1Z2dlc3RlZCxcbiAgICAgICAgbWF0cml4ID0gdGhpcy5ncm91cC5jYWxjVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZvckVhY2hDb250cm9sKGZ1bmN0aW9uKGNvbnRyb2wsIGtleSwgZmFicmljT2JqZWN0KSB7XG4gICAgICAgIHAgPSBmYWJyaWNPYmplY3Qub0Nvb3Jkc1trZXldO1xuICAgICAgICBpZiAoY29udHJvbC5nZXRWaXNpYmlsaXR5KGZhYnJpY09iamVjdCwga2V5KSkge1xuICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgIHAgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwLCBtYXRyaXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sLnJlbmRlcihjdHgsIHAueCwgcC55LCBzdHlsZU92ZXJyaWRlLCBmYWJyaWNPYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBjb250cm9sIGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udHJvbEtleSBUaGUga2V5IG9mIHRoZSBjb250cm9sLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICd0bCcsICd0cicsICdicicsICdibCcsICdtbCcsICdtdCcsICdtcicsICdtYicsICdtdHInLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgY29udHJvbCBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBpc0NvbnRyb2xWaXNpYmxlOiBmdW5jdGlvbihjb250cm9sS2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250cm9sc1tjb250cm9sS2V5XSAmJiB0aGlzLmNvbnRyb2xzW2NvbnRyb2xLZXldLmdldFZpc2liaWxpdHkodGhpcywgY29udHJvbEtleSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHNwZWNpZmllZCBjb250cm9sLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb250cm9sS2V5IFRoZSBrZXkgb2YgdGhlIGNvbnRyb2wuIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3RsJywgJ3RyJywgJ2JyJywgJ2JsJywgJ21sJywgJ210JywgJ21yJywgJ21iJywgJ210cicuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIHRydWUgdG8gc2V0IHRoZSBzcGVjaWZpZWQgY29udHJvbCB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldENvbnRyb2xWaXNpYmxlOiBmdW5jdGlvbihjb250cm9sS2V5LCB2aXNpYmxlKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbnRyb2xzVmlzaWJpbGl0eSkge1xuICAgICAgICB0aGlzLl9jb250cm9sc1Zpc2liaWxpdHkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbnRyb2xzVmlzaWJpbGl0eVtjb250cm9sS2V5XSA9IHZpc2libGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiBvYmplY3QgY29udHJvbHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmxdIHRydWUgdG8gZW5hYmxlIHRoZSBib3R0b20tbGVmdCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5icl0gdHJ1ZSB0byBlbmFibGUgdGhlIGJvdHRvbS1yaWdodCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYl0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS1ib3R0b20gY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWxdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtbGVmdCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tcl0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS1yaWdodCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdF0gdHJ1ZSB0byBlbmFibGUgdGhlIG1pZGRsZS10b3AgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGxdIHRydWUgdG8gZW5hYmxlIHRoZSB0b3AtbGVmdCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cl0gdHJ1ZSB0byBlbmFibGUgdGhlIHRvcC1yaWdodCBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdHJdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtdG9wLXJvdGF0ZSBjb250cm9sLCBmYWxzZSB0byBkaXNhYmxlIGl0XG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRDb250cm9sc1Zpc2liaWxpdHk6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICBmb3IgKHZhciBwIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZXRDb250cm9sVmlzaWJsZShwLCBvcHRpb25zW3BdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkIGV2ZXJ5IHRpbWUgX2Rpc2NhcmRBY3RpdmVPYmplY3Qgb3IgX3NldEFjdGl2ZU9iamVjdFxuICAgICAqIHRyeSB0byB0byBkZXNlbGVjdCB0aGlzIG9iamVjdC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSwgdGhlIHByb2Nlc3MgaXMgY2FuY2VsbGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIHNlbnQgZnJvbSB0aGUgdXBwZXIgZnVuY3Rpb25zXG4gICAgICogQHBhcmFtIHtFdmVudH0gW29wdGlvbnMuZV0gZXZlbnQgaWYgdGhlIHByb2Nlc3MgaXMgZ2VuZXJhdGVkIGJ5IGFuIGV2ZW50XG4gICAgICovXG4gICAgb25EZXNlbGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpbXBsZW1lbnRlZCBieSBzdWItY2xhc3NlcywgYXMgbmVlZGVkLlxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkIGV2ZXJ5IHRpbWUgX2Rpc2NhcmRBY3RpdmVPYmplY3Qgb3IgX3NldEFjdGl2ZU9iamVjdFxuICAgICAqIHRyeSB0byB0byBzZWxlY3QgdGhpcyBvYmplY3QuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIHRoZSBwcm9jZXNzIGlzIGNhbmNlbGxlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBzZW50IGZyb20gdGhlIHVwcGVyIGZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtvcHRpb25zLmVdIGV2ZW50IGlmIHRoZSBwcm9jZXNzIGlzIGdlbmVyYXRlZCBieSBhbiBldmVudFxuICAgICAqL1xuICAgIG9uU2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGltcGxlbWVudGVkIGJ5IHN1Yi1jbGFzc2VzLCBhcyBuZWVkZWQuXG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIEFuaW1hdGlvbiBkdXJhdGlvbiAoaW4gbXMpIGZvciBmeCogbWV0aG9kc1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIEZYX0RVUkFUSU9OOiA1MDAsXG5cbiAgLyoqXG4gICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSB3aXRoIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrc10gQ2FsbGJhY2tzIG9iamVjdCB3aXRoIG9wdGlvbmFsIFwib25Db21wbGV0ZVwiIGFuZC9vciBcIm9uQ2hhbmdlXCIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ29tcGxldGVdIEludm9rZWQgb24gY29tcGxldGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ2hhbmdlXSBJbnZva2VkIG9uIGV2ZXJ5IHN0ZXAgb2YgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5BbmltYXRpb25Db250ZXh0fSBjb250ZXh0XG4gICAqL1xuICBmeENlbnRlck9iamVjdEg6IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgc3RhcnRWYWx1ZTogb2JqZWN0LmxlZnQsXG4gICAgICBlbmRWYWx1ZTogdGhpcy5nZXRDZW50ZXJQb2ludCgpLngsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCdsZWZ0JywgdmFsdWUpO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IHdpdGggYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tzXSBDYWxsYmFja3Mgb2JqZWN0IHdpdGggb3B0aW9uYWwgXCJvbkNvbXBsZXRlXCIgYW5kL29yIFwib25DaGFuZ2VcIiBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkFuaW1hdGlvbkNvbnRleHR9IGNvbnRleHRcbiAgICovXG4gIGZ4Q2VudGVyT2JqZWN0VjogZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzIHx8IHsgfTtcblxuICAgIHZhciBlbXB0eSA9IGZ1bmN0aW9uKCkgeyB9LFxuICAgICAgICBvbkNvbXBsZXRlID0gY2FsbGJhY2tzLm9uQ29tcGxldGUgfHwgZW1wdHksXG4gICAgICAgIG9uQ2hhbmdlID0gY2FsbGJhY2tzLm9uQ2hhbmdlIHx8IGVtcHR5LFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gZmFicmljLnV0aWwuYW5pbWF0ZSh7XG4gICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICBzdGFydFZhbHVlOiBvYmplY3QudG9wLFxuICAgICAgZW5kVmFsdWU6IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKS55LFxuICAgICAgZHVyYXRpb246IHRoaXMuRlhfRFVSQVRJT04sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgb2JqZWN0LnNldCgndG9wJywgdmFsdWUpO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGBmYWJyaWMuQ2FudmFzI3JlbW92ZWAgYnV0IGFuaW1hdGVkXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byByZW1vdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja3NdIENhbGxiYWNrcyBvYmplY3Qgd2l0aCBvcHRpb25hbCBcIm9uQ29tcGxldGVcIiBhbmQvb3IgXCJvbkNoYW5nZVwiIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNvbXBsZXRlXSBJbnZva2VkIG9uIGNvbXBsZXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNoYW5nZV0gSW52b2tlZCBvbiBldmVyeSBzdGVwIG9mIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQW5pbWF0aW9uQ29udGV4dH0gY29udGV4dFxuICAgKi9cbiAgZnhSZW1vdmU6IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgc3RhcnRWYWx1ZTogb2JqZWN0Lm9wYWNpdHksXG4gICAgICBlbmRWYWx1ZTogMCxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLkZYX0RVUkFUSU9OLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIG9iamVjdC5zZXQoJ29wYWNpdHknLCB2YWx1ZSk7XG4gICAgICAgIF90aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgICAgb25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnJlbW92ZShvYmplY3QpO1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5PYmplY3QucHJvdG90eXBlICovIHtcbiAgLyoqXG4gICAqIEFuaW1hdGVzIG9iamVjdCdzIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBhbmltYXRlIChpZiBzdHJpbmcpIG9yIHByb3BlcnRpZXMgdG8gYW5pbWF0ZSAoaWYgb2JqZWN0KVxuICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHZhbHVlIFZhbHVlIHRvIGFuaW1hdGUgcHJvcGVydHkgdG8gKGlmIHN0cmluZyB3YXMgZ2l2ZW4gZmlyc3QpIG9yIG9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjYW5pbWF0aW9ufVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQW5pbWF0aW9uQ29udGV4dCB8IGZhYnJpYy5BbmltYXRpb25Db250ZXh0W119IGFuaW1hdGlvbiBjb250ZXh0IChvciBhbiBhcnJheSBpZiBwYXNzZWQgbXVsdGlwbGUgcHJvcGVydGllcylcbiAgICpcbiAgICogQXMgb2JqZWN0IOKAlCBtdWx0aXBsZSBwcm9wZXJ0aWVzXG4gICAqXG4gICAqIG9iamVjdC5hbmltYXRlKHsgbGVmdDogLi4uLCB0b3A6IC4uLiB9KTtcbiAgICogb2JqZWN0LmFuaW1hdGUoeyBsZWZ0OiAuLi4sIHRvcDogLi4uIH0sIHsgZHVyYXRpb246IC4uLiB9KTtcbiAgICpcbiAgICogQXMgc3RyaW5nIOKAlCBvbmUgcHJvcGVydHlcbiAgICpcbiAgICogb2JqZWN0LmFuaW1hdGUoJ2xlZnQnLCAuLi4pO1xuICAgKiBvYmplY3QuYW5pbWF0ZSgnbGVmdCcsIHsgZHVyYXRpb246IC4uLiB9KTtcbiAgICpcbiAgICovXG4gIGFuaW1hdGU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgcHJvcHNUb0FuaW1hdGUgPSBbXSwgcHJvcCwgc2tpcENhbGxiYWNrcywgb3V0ID0gW107XG4gICAgICBmb3IgKHByb3AgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgIHByb3BzVG9BbmltYXRlLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcHJvcHNUb0FuaW1hdGUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcHJvcCA9IHByb3BzVG9BbmltYXRlW2ldO1xuICAgICAgICBza2lwQ2FsbGJhY2tzID0gaSAhPT0gbGVuIC0gMTtcbiAgICAgICAgb3V0LnB1c2godGhpcy5fYW5pbWF0ZShwcm9wLCBhcmd1bWVudHNbMF1bcHJvcF0sIGFyZ3VtZW50c1sxXSwgc2tpcENhbGxiYWNrcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIGFuaW1hdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRvIFZhbHVlIHRvIGFuaW1hdGUgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwQ2FsbGJhY2tzXSBXaGVuIHRydWUsIGNhbGxiYWNrcyBsaWtlIG9uY2hhbmdlIGFuZCBvbmNvbXBsZXRlIGFyZSBub3QgaW52b2tlZFxuICAgKi9cbiAgX2FuaW1hdGU6IGZ1bmN0aW9uKHByb3BlcnR5LCB0bywgb3B0aW9ucywgc2tpcENhbGxiYWNrcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsIHByb3BQYWlyO1xuXG4gICAgdG8gPSB0by50b1N0cmluZygpO1xuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0geyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKH5wcm9wZXJ0eS5pbmRleE9mKCcuJykpIHtcbiAgICAgIHByb3BQYWlyID0gcHJvcGVydHkuc3BsaXQoJy4nKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcElzQ29sb3IgPVxuICAgICAgX3RoaXMuY29sb3JQcm9wZXJ0aWVzLmluZGV4T2YocHJvcGVydHkpID4gLTEgfHxcbiAgICAgIChwcm9wUGFpciAmJiBfdGhpcy5jb2xvclByb3BlcnRpZXMuaW5kZXhPZihwcm9wUGFpclsxXSkgPiAtMSk7XG5cbiAgICB2YXIgY3VycmVudFZhbHVlID0gcHJvcFBhaXJcbiAgICAgID8gdGhpcy5nZXQocHJvcFBhaXJbMF0pW3Byb3BQYWlyWzFdXVxuICAgICAgOiB0aGlzLmdldChwcm9wZXJ0eSk7XG5cbiAgICBpZiAoISgnZnJvbScgaW4gb3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMuZnJvbSA9IGN1cnJlbnRWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXByb3BJc0NvbG9yKSB7XG4gICAgICBpZiAofnRvLmluZGV4T2YoJz0nKSkge1xuICAgICAgICB0byA9IGN1cnJlbnRWYWx1ZSArIHBhcnNlRmxvYXQodG8ucmVwbGFjZSgnPScsICcnKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdG8gPSBwYXJzZUZsb2F0KHRvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX29wdGlvbnMgPSB7XG4gICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICBzdGFydFZhbHVlOiBvcHRpb25zLmZyb20sXG4gICAgICBlbmRWYWx1ZTogdG8sXG4gICAgICBieVZhbHVlOiBvcHRpb25zLmJ5LFxuICAgICAgZWFzaW5nOiBvcHRpb25zLmVhc2luZyxcbiAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgYWJvcnQ6IG9wdGlvbnMuYWJvcnQgJiYgZnVuY3Rpb24odmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5hYm9ydC5jYWxsKF90aGlzLCB2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKTtcbiAgICAgIH0sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHByb3BQYWlyKSB7XG4gICAgICAgICAgX3RoaXNbcHJvcFBhaXJbMF1dW3Byb3BQYWlyWzFdXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIF90aGlzLnNldChwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMub25DaGFuZ2UgJiYgb3B0aW9ucy5vbkNoYW5nZSh2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKTtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiAodmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcykge1xuICAgICAgICBpZiAoc2tpcENhbGxiYWNrcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLnNldENvb3JkcygpO1xuICAgICAgICBvcHRpb25zLm9uQ29tcGxldGUgJiYgb3B0aW9ucy5vbkNvbXBsZXRlKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAocHJvcElzQ29sb3IpIHtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5hbmltYXRlQ29sb3IoX29wdGlvbnMuc3RhcnRWYWx1ZSwgX29wdGlvbnMuZW5kVmFsdWUsIF9vcHRpb25zLmR1cmF0aW9uLCBfb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGZhYnJpYy51dGlsLmFuaW1hdGUoX29wdGlvbnMpO1xuICAgIH1cbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICBjb29yZFByb3BzID0geyB4MTogMSwgeDI6IDEsIHkxOiAxLCB5MjogMSB9O1xuXG4gIGlmIChmYWJyaWMuTGluZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuTGluZSBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogTGluZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkxpbmVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuTGluZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkxpbmUgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5MaW5lLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2xpbmUnLFxuXG4gICAgLyoqXG4gICAgICogeCB2YWx1ZSBvciBmaXJzdCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHgxOiAwLFxuXG4gICAgLyoqXG4gICAgICogeSB2YWx1ZSBvciBmaXJzdCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHkxOiAwLFxuXG4gICAgLyoqXG4gICAgICogeCB2YWx1ZSBvciBzZWNvbmQgbGluZSBlZGdlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB4MjogMCxcblxuICAgIC8qKlxuICAgICAqIHkgdmFsdWUgb3Igc2Vjb25kIGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeTI6IDAsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3gxJywgJ3gyJywgJ3kxJywgJ3kyJyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwb2ludHNdIEFycmF5IG9mIHBvaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuTGluZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcG9pbnRzID0gWzAsIDAsIDAsIDBdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLnNldCgneDEnLCBwb2ludHNbMF0pO1xuICAgICAgdGhpcy5zZXQoJ3kxJywgcG9pbnRzWzFdKTtcbiAgICAgIHRoaXMuc2V0KCd4MicsIHBvaW50c1syXSk7XG4gICAgICB0aGlzLnNldCgneTInLCBwb2ludHNbM10pO1xuXG4gICAgICB0aGlzLl9zZXRXaWR0aEhlaWdodChvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnNcbiAgICAgKi9cbiAgICBfc2V0V2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB0aGlzLndpZHRoID0gTWF0aC5hYnModGhpcy54MiAtIHRoaXMueDEpO1xuICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLmFicyh0aGlzLnkyIC0gdGhpcy55MSk7XG5cbiAgICAgIHRoaXMubGVmdCA9ICdsZWZ0JyBpbiBvcHRpb25zXG4gICAgICAgID8gb3B0aW9ucy5sZWZ0XG4gICAgICAgIDogdGhpcy5fZ2V0TGVmdFRvT3JpZ2luWCgpO1xuXG4gICAgICB0aGlzLnRvcCA9ICd0b3AnIGluIG9wdGlvbnNcbiAgICAgICAgPyBvcHRpb25zLnRvcFxuICAgICAgICA6IHRoaXMuX2dldFRvcFRvT3JpZ2luWSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXQnLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgY29vcmRQcm9wc1trZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLl9zZXRXaWR0aEhlaWdodCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBsZWZ0VG9PcmlnaW5YIERpc3RhbmNlIGZyb20gbGVmdCBlZGdlIG9mIGNhbnZhcyB0byBvcmlnaW5YIG9mIExpbmUuXG4gICAgICovXG4gICAgX2dldExlZnRUb09yaWdpblg6IG1ha2VFZGdlVG9PcmlnaW5HZXR0ZXIoXG4gICAgICB7IC8vIHByb3BlcnR5IG5hbWVzXG4gICAgICAgIG9yaWdpbjogJ29yaWdpblgnLFxuICAgICAgICBheGlzMTogJ3gxJyxcbiAgICAgICAgYXhpczI6ICd4MicsXG4gICAgICAgIGRpbWVuc2lvbjogJ3dpZHRoJ1xuICAgICAgfSxcbiAgICAgIHsgLy8gcG9zc2libGUgdmFsdWVzIG9mIG9yaWdpblxuICAgICAgICBuZWFyZXN0OiAnbGVmdCcsXG4gICAgICAgIGNlbnRlcjogJ2NlbnRlcicsXG4gICAgICAgIGZhcnRoZXN0OiAncmlnaHQnXG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB0b3BUb09yaWdpblkgRGlzdGFuY2UgZnJvbSB0b3AgZWRnZSBvZiBjYW52YXMgdG8gb3JpZ2luWSBvZiBMaW5lLlxuICAgICAqL1xuICAgIF9nZXRUb3BUb09yaWdpblk6IG1ha2VFZGdlVG9PcmlnaW5HZXR0ZXIoXG4gICAgICB7IC8vIHByb3BlcnR5IG5hbWVzXG4gICAgICAgIG9yaWdpbjogJ29yaWdpblknLFxuICAgICAgICBheGlzMTogJ3kxJyxcbiAgICAgICAgYXhpczI6ICd5MicsXG4gICAgICAgIGRpbWVuc2lvbjogJ2hlaWdodCdcbiAgICAgIH0sXG4gICAgICB7IC8vIHBvc3NpYmxlIHZhbHVlcyBvZiBvcmlnaW5cbiAgICAgICAgbmVhcmVzdDogJ3RvcCcsXG4gICAgICAgIGNlbnRlcjogJ2NlbnRlcicsXG4gICAgICAgIGZhcnRoZXN0OiAnYm90dG9tJ1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuXG4gICAgICB2YXIgcCA9IHRoaXMuY2FsY0xpbmVQb2ludHMoKTtcbiAgICAgIGN0eC5tb3ZlVG8ocC54MSwgcC55MSk7XG4gICAgICBjdHgubGluZVRvKHAueDIsIHAueTIpO1xuXG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aDtcblxuICAgICAgLy8gVE9ETzogdGVzdCB0aGlzXG4gICAgICAvLyBtYWtlIHN1cmUgc2V0dGluZyBcImZpbGxcIiBjaGFuZ2VzIGNvbG9yIG9mIGEgbGluZVxuICAgICAgLy8gKGJ5IGNvcHlpbmcgZmlsbFN0eWxlIHRvIHN0cm9rZVN0eWxlLCBzaW5jZSBsaW5lIGlzIHN0cm9rZWQsIG5vdCBmaWxsZWQpXG4gICAgICB2YXIgb3JpZ1N0cm9rZVN0eWxlID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2UgfHwgY3R4LmZpbGxTdHlsZTtcbiAgICAgIHRoaXMuc3Ryb2tlICYmIHRoaXMuX3JlbmRlclN0cm9rZShjdHgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3JpZ1N0cm9rZVN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGhlbHBlciBmb3Igc3ZnIGltcG9ydC4gaXQgcmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBvYmplY3QgaW4gdGhlIHN2Z1xuICAgICAqIHVudHJhbnNmb3JtZWQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIHBvaW50IGZyb20gZWxlbWVudCBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIF9maW5kQ2VudGVyRnJvbUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKHRoaXMueDEgKyB0aGlzLngyKSAvIDIsXG4gICAgICAgIHk6ICh0aGlzLnkxICsgdGhpcy55MikgLyAyLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIHRvT2JqZWN0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSksIHRoaXMuY2FsY0xpbmVQb2ludHMoKSk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQ2FsY3VsYXRlIG9iamVjdCBkaW1lbnNpb25zIGZyb20gaXRzIHByb3BlcnRpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRpbSA9IHRoaXMuY2FsbFN1cGVyKCdfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zJyk7XG4gICAgICBpZiAodGhpcy5zdHJva2VMaW5lQ2FwID09PSAnYnV0dCcpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPT09IDApIHtcbiAgICAgICAgICBkaW0ueSAtPSB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgIGRpbS54IC09IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkaW07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlY2FsY3VsYXRlcyBsaW5lIHBvaW50cyBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjYWxjTGluZVBvaW50czogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeE11bHQgPSB0aGlzLngxIDw9IHRoaXMueDIgPyAtMSA6IDEsXG4gICAgICAgICAgeU11bHQgPSB0aGlzLnkxIDw9IHRoaXMueTIgPyAtMSA6IDEsXG4gICAgICAgICAgeDEgPSAoeE11bHQgKiB0aGlzLndpZHRoICogMC41KSxcbiAgICAgICAgICB5MSA9ICh5TXVsdCAqIHRoaXMuaGVpZ2h0ICogMC41KSxcbiAgICAgICAgICB4MiA9ICh4TXVsdCAqIHRoaXMud2lkdGggKiAtMC41KSxcbiAgICAgICAgICB5MiA9ICh5TXVsdCAqIHRoaXMuaGVpZ2h0ICogLTAuNSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeDI6IHgyLFxuICAgICAgICB5MTogeTEsXG4gICAgICAgIHkyOiB5MlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuY2FsY0xpbmVQb2ludHMoKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8bGluZSAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ3gxPVwiJywgcC54MSxcbiAgICAgICAgJ1wiIHkxPVwiJywgcC55MSxcbiAgICAgICAgJ1wiIHgyPVwiJywgcC54MixcbiAgICAgICAgJ1wiIHkyPVwiJywgcC55MixcbiAgICAgICAgJ1wiIC8+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5MaW5lLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkxpbmVcbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjTGluZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5MaW5lLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoJ3gxIHkxIHgyIHkyJy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuTGluZSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5MaW5lXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIGFmdGVyIHBhcnNpbmdcbiAgICovXG4gIGZhYnJpYy5MaW5lLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5MaW5lLkFUVFJJQlVURV9OQU1FUyksXG4gICAgICAgIHBvaW50cyA9IFtcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLngxIHx8IDAsXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy55MSB8fCAwLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMueDIgfHwgMCxcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLnkyIHx8IDBcbiAgICAgICAgXTtcbiAgICBjYWxsYmFjayhuZXcgZmFicmljLkxpbmUocG9pbnRzLCBleHRlbmQocGFyc2VkQXR0cmlidXRlcywgb3B0aW9ucykpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuTGluZSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuTGluZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICovXG4gIGZhYnJpYy5MaW5lLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gX2NhbGxiYWNrKGluc3RhbmNlKSB7XG4gICAgICBkZWxldGUgaW5zdGFuY2UucG9pbnRzO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soaW5zdGFuY2UpO1xuICAgIH07XG4gICAgdmFyIG9wdGlvbnMgPSBjbG9uZShvYmplY3QsIHRydWUpO1xuICAgIG9wdGlvbnMucG9pbnRzID0gW29iamVjdC54MSwgb2JqZWN0LnkxLCBvYmplY3QueDIsIG9iamVjdC55Ml07XG4gICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnTGluZScsIG9wdGlvbnMsIF9jYWxsYmFjaywgJ3BvaW50cycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyBhIGZ1bmN0aW9uIHRoYXQgY2FsY3VsYXRlcyBkaXN0YW5jZSBmcm9tIGNhbnZhcyBlZGdlIHRvIExpbmUgb3JpZ2luLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZUVkZ2VUb09yaWdpbkdldHRlcihwcm9wZXJ0eU5hbWVzLCBvcmlnaW5WYWx1ZXMpIHtcbiAgICB2YXIgb3JpZ2luID0gcHJvcGVydHlOYW1lcy5vcmlnaW4sXG4gICAgICAgIGF4aXMxID0gcHJvcGVydHlOYW1lcy5heGlzMSxcbiAgICAgICAgYXhpczIgPSBwcm9wZXJ0eU5hbWVzLmF4aXMyLFxuICAgICAgICBkaW1lbnNpb24gPSBwcm9wZXJ0eU5hbWVzLmRpbWVuc2lvbixcbiAgICAgICAgbmVhcmVzdCA9IG9yaWdpblZhbHVlcy5uZWFyZXN0LFxuICAgICAgICBjZW50ZXIgPSBvcmlnaW5WYWx1ZXMuY2VudGVyLFxuICAgICAgICBmYXJ0aGVzdCA9IG9yaWdpblZhbHVlcy5mYXJ0aGVzdDtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5nZXQob3JpZ2luKSkge1xuICAgICAgICBjYXNlIG5lYXJlc3Q6XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZ2V0KGF4aXMxKSwgdGhpcy5nZXQoYXhpczIpKTtcbiAgICAgICAgY2FzZSBjZW50ZXI6XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZ2V0KGF4aXMxKSwgdGhpcy5nZXQoYXhpczIpKSArICgwLjUgKiB0aGlzLmdldChkaW1lbnNpb24pKTtcbiAgICAgICAgY2FzZSBmYXJ0aGVzdDpcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5nZXQoYXhpczEpLCB0aGlzLmdldChheGlzMikpO1xuICAgICAgfVxuICAgIH07XG5cbiAgfVxuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucztcblxuICBpZiAoZmFicmljLkNpcmNsZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuQ2lyY2xlIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQ2lyY2xlIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuQ2lyY2xlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkNpcmNsZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkNpcmNsZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLkNpcmNsZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdjaXJjbGUnLFxuXG4gICAgLyoqXG4gICAgICogUmFkaXVzIG9mIHRoaXMgY2lyY2xlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByYWRpdXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBkZWdyZWVzIG9mIHN0YXJ0IG9mIHRoZSBjaXJjbGUuXG4gICAgICogcHJvYmFibHkgd2lsbCBjaGFuZ2UgdG8gZGVncmVlcyBpbiBuZXh0IG1ham9yIHZlcnNpb25cbiAgICAgKiBAdHlwZSBOdW1iZXIgMCAtIDM1OVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogRW5kIGFuZ2xlIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBwcm9iYWJseSB3aWxsIGNoYW5nZSB0byBkZWdyZWVzIGluIG5leHQgbWFqb3IgdmVyc2lvblxuICAgICAqIEB0eXBlIE51bWJlciAxIC0gMzYwXG4gICAgICogQGRlZmF1bHQgMzYwXG4gICAgICovXG4gICAgZW5kQW5nbGU6IDM2MCxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnKSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2lyY2xlfSB0aGlzQXJnXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXQnLCBrZXksIHZhbHVlKTtcblxuICAgICAgaWYgKGtleSA9PT0gJ3JhZGl1cycpIHtcbiAgICAgICAgdGhpcy5zZXRSYWRpdXModmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIFsncmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSkpO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN2Z1N0cmluZywgeCA9IDAsIHkgPSAwLFxuICAgICAgICAgIGFuZ2xlID0gKHRoaXMuZW5kQW5nbGUgLSB0aGlzLnN0YXJ0QW5nbGUpICUgMzYwO1xuXG4gICAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgICAgc3ZnU3RyaW5nID0gW1xuICAgICAgICAgICc8Y2lyY2xlICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAgICdjeD1cIicgKyB4ICsgJ1wiIGN5PVwiJyArIHkgKyAnXCIgJyxcbiAgICAgICAgICAncj1cIicsIHRoaXMucmFkaXVzLFxuICAgICAgICAgICdcIiAvPlxcbidcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgc3RhcnQgPSBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuc3RhcnRBbmdsZSksXG4gICAgICAgICAgICBlbmQgPSBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuZW5kQW5nbGUpLFxuICAgICAgICAgICAgcmFkaXVzID0gdGhpcy5yYWRpdXMsXG4gICAgICAgICAgICBzdGFydFggPSBmYWJyaWMudXRpbC5jb3Moc3RhcnQpICogcmFkaXVzLFxuICAgICAgICAgICAgc3RhcnRZID0gZmFicmljLnV0aWwuc2luKHN0YXJ0KSAqIHJhZGl1cyxcbiAgICAgICAgICAgIGVuZFggPSBmYWJyaWMudXRpbC5jb3MoZW5kKSAqIHJhZGl1cyxcbiAgICAgICAgICAgIGVuZFkgPSBmYWJyaWMudXRpbC5zaW4oZW5kKSAqIHJhZGl1cyxcbiAgICAgICAgICAgIGxhcmdlRmxhZyA9IGFuZ2xlID4gMTgwID8gJzEnIDogJzAnO1xuICAgICAgICBzdmdTdHJpbmcgPSBbXG4gICAgICAgICAgJzxwYXRoIGQ9XCJNICcgKyBzdGFydFggKyAnICcgKyBzdGFydFksXG4gICAgICAgICAgJyBBICcgKyByYWRpdXMgKyAnICcgKyByYWRpdXMsXG4gICAgICAgICAgJyAwICcsICtsYXJnZUZsYWcgKyAnIDEnLCAnICcgKyBlbmRYICsgJyAnICsgZW5kWSxcbiAgICAgICAgICAnXCIgJywgJ0NPTU1PTl9QQVJUUycsICcgLz5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3ZnU3RyaW5nO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmMoXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMucmFkaXVzLFxuICAgICAgICBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuc3RhcnRBbmdsZSksXG4gICAgICAgIGRlZ3JlZXNUb1JhZGlhbnModGhpcy5lbmRBbmdsZSksXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaG9yaXpvbnRhbCByYWRpdXMgb2YgYW4gb2JqZWN0IChhY2NvcmRpbmcgdG8gaG93IGFuIG9iamVjdCBpcyBzY2FsZWQpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJhZGl1c1g6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdyYWRpdXMnKSAqIHRoaXMuZ2V0KCdzY2FsZVgnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB2ZXJ0aWNhbCByYWRpdXMgb2YgYW4gb2JqZWN0IChhY2NvcmRpbmcgdG8gaG93IGFuIG9iamVjdCBpcyBzY2FsZWQpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJhZGl1c1k6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdyYWRpdXMnKSAqIHRoaXMuZ2V0KCdzY2FsZVknKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyByYWRpdXMgb2YgYW4gb2JqZWN0IChhbmQgdXBkYXRlcyB3aWR0aCBhY2NvcmRpbmdseSlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2lyY2xlfSB0aGlzQXJnXG4gICAgICovXG4gICAgc2V0UmFkaXVzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5yYWRpdXMgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzLnNldCgnd2lkdGgnLCB2YWx1ZSAqIDIpLnNldCgnaGVpZ2h0JywgdmFsdWUgKiAyKTtcbiAgICB9LFxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5DaXJjbGUuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ2lyY2xlXG4gICAqIEBzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNDaXJjbGVFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuQ2lyY2xlLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoJ2N4IGN5IHInLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuQ2lyY2xlfSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5DaXJjbGVcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBPcHRpb25zIGNhbGxiYWNrIGludm9rZWQgYWZ0ZXIgcGFyc2luZyBpcyBmaW5pc2hlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB2YWx1ZSBvZiBgcmAgYXR0cmlidXRlIGlzIG1pc3Npbmcgb3IgaW52YWxpZFxuICAgKi9cbiAgZmFicmljLkNpcmNsZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5DaXJjbGUuQVRUUklCVVRFX05BTUVTKTtcblxuICAgIGlmICghaXNWYWxpZFJhZGl1cyhwYXJzZWRBdHRyaWJ1dGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSBvZiBgcmAgYXR0cmlidXRlIGlzIHJlcXVpcmVkIGFuZCBjYW4gbm90IGJlIG5lZ2F0aXZlJyk7XG4gICAgfVxuXG4gICAgcGFyc2VkQXR0cmlidXRlcy5sZWZ0ID0gKHBhcnNlZEF0dHJpYnV0ZXMubGVmdCB8fCAwKSAtIHBhcnNlZEF0dHJpYnV0ZXMucmFkaXVzO1xuICAgIHBhcnNlZEF0dHJpYnV0ZXMudG9wID0gKHBhcnNlZEF0dHJpYnV0ZXMudG9wIHx8IDApIC0gcGFyc2VkQXR0cmlidXRlcy5yYWRpdXM7XG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5DaXJjbGUocGFyc2VkQXR0cmlidXRlcykpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNWYWxpZFJhZGl1cyhhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuICgoJ3JhZGl1cycgaW4gYXR0cmlidXRlcykgJiYgKGF0dHJpYnV0ZXMucmFkaXVzID49IDApKTtcbiAgfVxuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuQ2lyY2xlfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ2lyY2xlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBmaXJzdCBhcmd1bWVudFxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgZmFicmljLkNpcmNsZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0NpcmNsZScsIG9iamVjdCwgY2FsbGJhY2spO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5UcmlhbmdsZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuVHJpYW5nbGUgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWFuZ2xlIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuVHJpYW5nbGVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuVHJpYW5nbGV9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlRyaWFuZ2xlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuVHJpYW5nbGUgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5UcmlhbmdsZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICd0cmlhbmdsZScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBpcyBzZXQgdG8gMTAwIHRvIGNvbXBlbnNhdGUgdGhlIG9sZCBpbml0aWFsaXplIGNvZGUgdGhhdCB3YXMgc2V0dGluZyBpdCB0byAxMDBcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHdpZHRoOiAxMDAsXG5cbiAgICAvKipcbiAgICAgKiBIZWlnaHQgaXMgc2V0IHRvIDEwMCB0byBjb21wZW5zYXRlIHRoZSBvbGQgaW5pdGlhbGl6ZSBjb2RlIHRoYXQgd2FzIHNldHRpbmcgaXQgdG8gMTAwXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBoZWlnaHQ6IDEwMCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHdpZHRoQnkyID0gdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgaGVpZ2h0QnkyID0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKC13aWR0aEJ5MiwgaGVpZ2h0QnkyKTtcbiAgICAgIGN0eC5saW5lVG8oMCwgLWhlaWdodEJ5Mik7XG4gICAgICBjdHgubGluZVRvKHdpZHRoQnkyLCBoZWlnaHRCeTIpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgd2lkdGhCeTIgPSB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgICBoZWlnaHRCeTIgPSB0aGlzLmhlaWdodCAvIDIsXG4gICAgICAgICAgcG9pbnRzID0gW1xuICAgICAgICAgICAgLXdpZHRoQnkyICsgJyAnICsgaGVpZ2h0QnkyLFxuICAgICAgICAgICAgJzAgJyArIC1oZWlnaHRCeTIsXG4gICAgICAgICAgICB3aWR0aEJ5MiArICcgJyArIGhlaWdodEJ5MlxuICAgICAgICAgIF0uam9pbignLCcpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxwb2x5Z29uICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAncG9pbnRzPVwiJywgcG9pbnRzLFxuICAgICAgICAnXCIgLz4nXG4gICAgICBdO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuVHJpYW5nbGV9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UcmlhbmdsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICovXG4gIGZhYnJpYy5UcmlhbmdsZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdUcmlhbmdsZScsIG9iamVjdCwgY2FsbGJhY2spO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBwaUJ5MiAgID0gTWF0aC5QSSAqIDI7XG5cbiAgaWYgKGZhYnJpYy5FbGxpcHNlKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5FbGxpcHNlIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogRWxsaXBzZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkVsbGlwc2VcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuRWxsaXBzZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkVsbGlwc2UgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5FbGxpcHNlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2VsbGlwc2UnLFxuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCByYWRpdXNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJ4OiAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCByYWRpdXNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJ5OiAgIDAsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3J4JywgJ3J5JyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldCgncngnLCBvcHRpb25zICYmIG9wdGlvbnMucnggfHwgMCk7XG4gICAgICB0aGlzLnNldCgncnknLCBvcHRpb25zICYmIG9wdGlvbnMucnkgfHwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuXG4gICAgICAgIGNhc2UgJ3J4JzpcbiAgICAgICAgICB0aGlzLnJ4ID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5zZXQoJ3dpZHRoJywgdmFsdWUgKiAyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyeSc6XG4gICAgICAgICAgdGhpcy5yeSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc2V0KCdoZWlnaHQnLCB2YWx1ZSAqIDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBob3Jpem9udGFsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Ung6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdyeCcpICogdGhpcy5nZXQoJ3NjYWxlWCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFZlcnRpY2FsIHJhZGl1cyBvZiBhbiBvYmplY3QgKGFjY29yZGluZyB0byBob3cgYW4gb2JqZWN0IGlzIHNjYWxlZClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Unk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdyeScpICogdGhpcy5nZXQoJ3NjYWxlWScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgWydyeCcsICdyeSddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxlbGxpcHNlICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAnY3g9XCIwXCIgY3k9XCIwXCIgJyxcbiAgICAgICAgJ3J4PVwiJywgdGhpcy5yeCxcbiAgICAgICAgJ1wiIHJ5PVwiJywgdGhpcy5yeSxcbiAgICAgICAgJ1wiIC8+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAwLCB0aGlzLnJ5IC8gdGhpcy5yeCwgMCwgMCk7XG4gICAgICBjdHguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnJ4LFxuICAgICAgICAwLFxuICAgICAgICBwaUJ5MixcbiAgICAgICAgZmFsc2UpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSB7QGxpbmsgZmFicmljLkVsbGlwc2UuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNFbGxpcHNlRWxlbWVudFxuICAgKi9cbiAgZmFicmljLkVsbGlwc2UuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgnY3ggY3kgcnggcnknLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuRWxsaXBzZX0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbnMgY2FsbGJhY2sgaW52b2tlZCBhZnRlciBwYXJzaW5nIGlzIGZpbmlzaGVkXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5FbGxpcHNlfVxuICAgKi9cbiAgZmFicmljLkVsbGlwc2UuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5FbGxpcHNlLkFUVFJJQlVURV9OQU1FUyk7XG5cbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgPSAocGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDApIC0gcGFyc2VkQXR0cmlidXRlcy5yeDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLnRvcCA9IChwYXJzZWRBdHRyaWJ1dGVzLnRvcCB8fCAwKSAtIHBhcnNlZEF0dHJpYnV0ZXMucnk7XG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5FbGxpcHNlKHBhcnNlZEF0dHJpYnV0ZXMpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkVsbGlwc2V9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBmaXJzdCBhcmd1bWVudFxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgZmFicmljLkVsbGlwc2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdFbGxpcHNlJywgb2JqZWN0LCBjYWxsYmFjayk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQ7XG5cbiAgaWYgKGZhYnJpYy5SZWN0KSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5SZWN0IGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN0YW5nbGUgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5SZWN0XG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlJlY3R9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlJlY3QjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5SZWN0ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuUmVjdC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWYgc3RhdGUgb2YgYW4gb2JqZWN0IGlzIGNoYW5nZWQgKHtAbGluayBmYWJyaWMuT2JqZWN0I2hhc1N0YXRlQ2hhbmdlZH0pXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KCdyeCcsICdyeScpLFxuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdyZWN0JyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgYm9yZGVyIHJhZGl1c1xuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcng6ICAgMCxcblxuICAgIC8qKlxuICAgICAqIFZlcnRpY2FsIGJvcmRlciByYWRpdXNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJ5OiAgIDAsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3J4JywgJ3J5JyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5faW5pdFJ4UnkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgcngvcnkgYXR0cmlidXRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRSeFJ5OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnJ4ICYmICF0aGlzLnJ5KSB7XG4gICAgICAgIHRoaXMucnkgPSB0aGlzLnJ4O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5yeSAmJiAhdGhpcy5yeCkge1xuICAgICAgICB0aGlzLnJ4ID0gdGhpcy5yeTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG5cbiAgICAgIC8vIDF4MSBjYXNlICh1c2VkIGluIHNwcmF5IGJydXNoKSBvcHRpbWl6YXRpb24gd2FzIHJlbW92ZWQgYmVjYXVzZVxuICAgICAgLy8gd2l0aCBjYWNoaW5nIGFuZCBoaWdoZXIgem9vbSBsZXZlbCB0aGlzIG1ha2VzIG1vcmUgZGFtYWdlIHRoYW4gaGVscFxuXG4gICAgICB2YXIgcnggPSB0aGlzLnJ4ID8gTWF0aC5taW4odGhpcy5yeCwgdGhpcy53aWR0aCAvIDIpIDogMCxcbiAgICAgICAgICByeSA9IHRoaXMucnkgPyBNYXRoLm1pbih0aGlzLnJ5LCB0aGlzLmhlaWdodCAvIDIpIDogMCxcbiAgICAgICAgICB3ID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQsXG4gICAgICAgICAgeCA9IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgICB5ID0gLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgICBpc1JvdW5kZWQgPSByeCAhPT0gMCB8fCByeSAhPT0gMCxcbiAgICAgICAgICAvKiBcIm1hZ2ljIG51bWJlclwiIGZvciBiZXppZXIgYXBwcm94aW1hdGlvbnMgb2YgYXJjcyAoaHR0cDovL2l0Yy5rdHUubHQvaXRjMzU0L1Jpc2t1czM1NC5wZGYpICovXG4gICAgICAgICAgayA9IDEgLSAwLjU1MjI4NDc0OTg7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGN0eC5tb3ZlVG8oeCArIHJ4LCB5KTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgdyAtIHJ4LCB5KTtcbiAgICAgIGlzUm91bmRlZCAmJiBjdHguYmV6aWVyQ3VydmVUbyh4ICsgdyAtIGsgKiByeCwgeSwgeCArIHcsIHkgKyBrICogcnksIHggKyB3LCB5ICsgcnkpO1xuXG4gICAgICBjdHgubGluZVRvKHggKyB3LCB5ICsgaCAtIHJ5KTtcbiAgICAgIGlzUm91bmRlZCAmJiBjdHguYmV6aWVyQ3VydmVUbyh4ICsgdywgeSArIGggLSBrICogcnksIHggKyB3IC0gayAqIHJ4LCB5ICsgaCwgeCArIHcgLSByeCwgeSArIGgpO1xuXG4gICAgICBjdHgubGluZVRvKHggKyByeCwgeSArIGgpO1xuICAgICAgaXNSb3VuZGVkICYmIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyBrICogcngsIHkgKyBoLCB4LCB5ICsgaCAtIGsgKiByeSwgeCwgeSArIGggLSByeSk7XG5cbiAgICAgIGN0eC5saW5lVG8oeCwgeSArIHJ5KTtcbiAgICAgIGlzUm91bmRlZCAmJiBjdHguYmV6aWVyQ3VydmVUbyh4LCB5ICsgayAqIHJ5LCB4ICsgayAqIHJ4LCB5LCB4ICsgcngsIHkpO1xuXG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgWydyeCcsICdyeSddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSAtdGhpcy53aWR0aCAvIDIsIHkgPSAtdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJzxyZWN0ICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAneD1cIicsIHgsICdcIiB5PVwiJywgeSxcbiAgICAgICAgJ1wiIHJ4PVwiJywgdGhpcy5yeCwgJ1wiIHJ5PVwiJywgdGhpcy5yeSxcbiAgICAgICAgJ1wiIHdpZHRoPVwiJywgdGhpcy53aWR0aCwgJ1wiIGhlaWdodD1cIicsIHRoaXMuaGVpZ2h0LFxuICAgICAgICAnXCIgLz5cXG4nXG4gICAgICBdO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSBgZmFicmljLlJlY3QuZnJvbUVsZW1lbnRgKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUmVjdFxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjUmVjdEVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5SZWN0LkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoJ3ggeSByeCByeSB3aWR0aCBoZWlnaHQnLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuUmVjdH0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUmVjdFxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIGFmdGVyIHBhcnNpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLlJlY3QuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG5cbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlJlY3QuQVRUUklCVVRFX05BTUVTKTtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgPSBwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgfHwgMDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLnRvcCAgPSBwYXJzZWRBdHRyaWJ1dGVzLnRvcCAgfHwgMDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmhlaWdodCAgPSBwYXJzZWRBdHRyaWJ1dGVzLmhlaWdodCB8fCAwO1xuICAgIHBhcnNlZEF0dHJpYnV0ZXMud2lkdGggID0gcGFyc2VkQXR0cmlidXRlcy53aWR0aCB8fCAwO1xuICAgIHZhciByZWN0ID0gbmV3IGZhYnJpYy5SZWN0KGV4dGVuZCgob3B0aW9ucyA/IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvcHRpb25zKSA6IHsgfSksIHBhcnNlZEF0dHJpYnV0ZXMpKTtcbiAgICByZWN0LnZpc2libGUgPSByZWN0LnZpc2libGUgJiYgcmVjdC53aWR0aCA+IDAgJiYgcmVjdC5oZWlnaHQgPiAwO1xuICAgIGNhbGxiYWNrKHJlY3QpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuUmVjdH0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUmVjdCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuUmVjdC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdSZWN0Jywgb2JqZWN0LCBjYWxsYmFjayk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBtaW4gPSBmYWJyaWMudXRpbC5hcnJheS5taW4sXG4gICAgICBtYXggPSBmYWJyaWMudXRpbC5hcnJheS5tYXgsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIHByb2plY3RTdHJva2VPblBvaW50cyA9IGZhYnJpYy51dGlsLnByb2plY3RTdHJva2VPblBvaW50cztcblxuICBpZiAoZmFicmljLlBvbHlsaW5lKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Qb2x5bGluZSBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUG9seWxpbmUgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5Qb2x5bGluZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5Qb2x5bGluZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuUG9seWxpbmUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncG9seWxpbmUnLFxuXG4gICAgLyoqXG4gICAgICogUG9pbnRzIGFycmF5XG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBvaW50czogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFdBUk5JTkc6IEZlYXR1cmUgaW4gcHJvZ3Jlc3NcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGV4YWN0IGJvdW5kaW5nIGJveCB0YWtpbmcgaW4gYWNjb3VudCBzdHJva2VXaWR0aCBvbiBhY3V0ZSBhbmdsZXNcbiAgICAgKiB0aGlzIHdpbGwgYmUgdHVybmVkIHRvIHRydWUgYnkgZGVmYXVsdCBvbiBmYWJyaWMgNi4wXG4gICAgICogbWF5YmUgd2lsbCBiZSBsZWZ0IGluIGFzIGFuIG9wdGltaXphdGlvbiBzaW5jZSBjYWxjdWxhdGlvbnMgbWF5IGJlIHNsb3dcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGV4YWN0Qm91bmRpbmdCb3g6IGZhbHNlLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdwb2ludHMnKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIEFycmF5IG9mIHBvaW50cyAod2hlcmUgZWFjaCBwb2ludCBpcyBhbiBvYmplY3Qgd2l0aCB4IGFuZCB5KVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9seWxpbmV9IHRoaXNBcmdcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwb2x5ID0gbmV3IGZhYnJpYy5Qb2x5bGluZShbXG4gICAgICogICAgIHsgeDogMTAsIHk6IDEwIH0sXG4gICAgICogICAgIHsgeDogNTAsIHk6IDMwIH0sXG4gICAgICogICAgIHsgeDogNDAsIHk6IDcwIH0sXG4gICAgICogICAgIHsgeDogNjAsIHk6IDUwIH0sXG4gICAgICogICAgIHsgeDogMTAwLCB5OiAxNTAgfSxcbiAgICAgKiAgICAgeyB4OiA0MCwgeTogMTAwIH1cbiAgICAgKiAgIF0sIHtcbiAgICAgKiAgIHN0cm9rZTogJ3JlZCcsXG4gICAgICogICBsZWZ0OiAxMDAsXG4gICAgICogICB0b3A6IDEwMFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB0aGlzLnBvaW50cyA9IHBvaW50cyB8fCBbXTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbkRpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Byb2plY3RTdHJva2VPblBvaW50czogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHByb2plY3RTdHJva2VPblBvaW50cyh0aGlzLnBvaW50cywgdGhpcywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIF9zZXRQb3NpdGlvbkRpbWVuc2lvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYWxjRGltID0gdGhpcy5fY2FsY0RpbWVuc2lvbnMob3B0aW9ucyksIGNvcnJlY3RMZWZ0VG9wLFxuICAgICAgICAgIGNvcnJlY3RTaXplID0gdGhpcy5leGFjdEJvdW5kaW5nQm94ID8gdGhpcy5zdHJva2VXaWR0aCA6IDA7XG4gICAgICB0aGlzLndpZHRoID0gY2FsY0RpbS53aWR0aCAtIGNvcnJlY3RTaXplO1xuICAgICAgdGhpcy5oZWlnaHQgPSBjYWxjRGltLmhlaWdodCAtIGNvcnJlY3RTaXplO1xuICAgICAgaWYgKCFvcHRpb25zLmZyb21TVkcpIHtcbiAgICAgICAgY29ycmVjdExlZnRUb3AgPSB0aGlzLnRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW4oXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gdGhpcyBsb29rcyBiYWQsIGJ1dCBpcyBvbmUgd2F5IHRvIGtlZXAgaXQgb3B0aW9uYWwgZm9yIG5vdy5cbiAgICAgICAgICAgIHg6IGNhbGNEaW0ubGVmdCAtIHRoaXMuc3Ryb2tlV2lkdGggLyAyICsgY29ycmVjdFNpemUgLyAyLFxuICAgICAgICAgICAgeTogY2FsY0RpbS50b3AgLSB0aGlzLnN0cm9rZVdpZHRoIC8gMiArIGNvcnJlY3RTaXplIC8gMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2xlZnQnLFxuICAgICAgICAgICd0b3AnLFxuICAgICAgICAgIHRoaXMub3JpZ2luWCxcbiAgICAgICAgICB0aGlzLm9yaWdpbllcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sZWZ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmxlZnQgPSBvcHRpb25zLmZyb21TVkcgPyBjYWxjRGltLmxlZnQgOiBjb3JyZWN0TGVmdFRvcC54O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRvcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy50b3AgPSBvcHRpb25zLmZyb21TVkcgPyBjYWxjRGltLnRvcCA6IGNvcnJlY3RMZWZ0VG9wLnk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhdGhPZmZzZXQgPSB7XG4gICAgICAgIHg6IGNhbGNEaW0ubGVmdCArIHRoaXMud2lkdGggLyAyICsgY29ycmVjdFNpemUgLyAyLFxuICAgICAgICB5OiBjYWxjRGltLnRvcCArIHRoaXMuaGVpZ2h0IC8gMiArIGNvcnJlY3RTaXplIC8gMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb2x5Z29uIG1pbiBhbmQgbWF4IHBvaW50IGZyb20gcG9pbnRzIGFycmF5LFxuICAgICAqIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQgdG8gbWVhc3VyZSB0aGVcbiAgICAgKiBwb2x5Z29uIHNpemVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC5sZWZ0IFggY29vcmRpbmF0ZSBvZiB0aGUgcG9seWdvbiBsZWZ0bW9zdCBwb2ludFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LnRvcCBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb24gdG9wbW9zdCBwb2ludFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LndpZHRoIGRpc3RhbmNlIGJldHdlZW4gWCBjb29yZGluYXRlcyBvZiB0aGUgcG9seWdvbiBsZWZ0bW9zdCBhbmQgcmlnaHRtb3N0IHBvaW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QuaGVpZ2h0IGRpc3RhbmNlIGJldHdlZW4gWSBjb29yZGluYXRlcyBvZiB0aGUgcG9seWdvbiB0b3Btb3N0IGFuZCBib3R0b21tb3N0IHBvaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY0RpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5leGFjdEJvdW5kaW5nQm94ID8gdGhpcy5fcHJvamVjdFN0cm9rZU9uUG9pbnRzKCkgOiB0aGlzLnBvaW50cyxcbiAgICAgICAgICBtaW5YID0gbWluKHBvaW50cywgJ3gnKSB8fCAwLFxuICAgICAgICAgIG1pblkgPSBtaW4ocG9pbnRzLCAneScpIHx8IDAsXG4gICAgICAgICAgbWF4WCA9IG1heChwb2ludHMsICd4JykgfHwgMCxcbiAgICAgICAgICBtYXhZID0gbWF4KHBvaW50cywgJ3knKSB8fCAwLFxuICAgICAgICAgIHdpZHRoID0gKG1heFggLSBtaW5YKSxcbiAgICAgICAgICBoZWlnaHQgPSAobWF4WSAtIG1pblkpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBtaW5YLFxuICAgICAgICB0b3A6IG1pblksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB7XG4gICAgICAgIHBvaW50czogdGhpcy5wb2ludHMuY29uY2F0KClcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb2ludHMgPSBbXSwgZGlmZlggPSB0aGlzLnBhdGhPZmZzZXQueCwgZGlmZlkgPSB0aGlzLnBhdGhPZmZzZXQueSxcbiAgICAgICAgICBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnRzLnB1c2goXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLnBvaW50c1tpXS54IC0gZGlmZlgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnLCcsXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLnBvaW50c1tpXS55IC0gZGlmZlksIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnICdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8JyArIHRoaXMudHlwZSArICcgJywgJ0NPTU1PTl9QQVJUUycsXG4gICAgICAgICdwb2ludHM9XCInLCBwb2ludHMuam9pbignJyksXG4gICAgICAgICdcIiAvPlxcbidcbiAgICAgIF07XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgY29tbW9uUmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBwb2ludCwgbGVuID0gdGhpcy5wb2ludHMubGVuZ3RoLFxuICAgICAgICAgIHggPSB0aGlzLnBhdGhPZmZzZXQueCxcbiAgICAgICAgICB5ID0gdGhpcy5wYXRoT2Zmc2V0Lnk7XG5cbiAgICAgIGlmICghbGVuIHx8IGlzTmFOKHRoaXMucG9pbnRzW2xlbiAtIDFdLnkpKSB7XG4gICAgICAgIC8vIGRvIG5vdCBkcmF3IGlmIG5vIHBvaW50cyBvciBvZGQgcG9pbnRzXG4gICAgICAgIC8vIE5hTiBjb21lcyBmcm9tIHBhcnNlRmxvYXQgb2YgYSBlbXB0eSBzdHJpbmcgaW4gcGFyc2VyXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8odGhpcy5wb2ludHNbMF0ueCAtIHgsIHRoaXMucG9pbnRzWzBdLnkgLSB5KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSB0aGlzLnBvaW50c1tpXTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludC54IC0geCwgcG9pbnQueSAtIHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmNvbW1vblJlbmRlcihjdHgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXhpdHkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHkgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdwb2ludHMnKS5sZW5ndGg7XG4gICAgfVxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5Qb2x5bGluZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5bGluZVxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjUG9seWxpbmVFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUG9seWxpbmUuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5Qb2x5bGluZSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5bGluZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5Qb2x5bGluZS5mcm9tRWxlbWVudEdlbmVyYXRvciA9IGZ1bmN0aW9uKF9jbGFzcykge1xuICAgIHJldHVybiBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgcG9pbnRzID0gZmFicmljLnBhcnNlUG9pbnRzQXR0cmlidXRlKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwb2ludHMnKSksXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljW19jbGFzc10uQVRUUklCVVRFX05BTUVTKTtcbiAgICAgIHBhcnNlZEF0dHJpYnV0ZXMuZnJvbVNWRyA9IHRydWU7XG4gICAgICBjYWxsYmFjayhuZXcgZmFicmljW19jbGFzc10ocG9pbnRzLCBleHRlbmQocGFyc2VkQXR0cmlidXRlcywgb3B0aW9ucykpKTtcbiAgICB9O1xuICB9O1xuXG4gIGZhYnJpYy5Qb2x5bGluZS5mcm9tRWxlbWVudCA9IGZhYnJpYy5Qb2x5bGluZS5mcm9tRWxlbWVudEdlbmVyYXRvcignUG9seWxpbmUnKTtcblxuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5Qb2x5bGluZSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUGF0aCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuUG9seWxpbmUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUG9seWxpbmUnLCBvYmplY3QsIGNhbGxiYWNrLCAncG9pbnRzJyk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0ge30pLFxuICAgICAgcHJvamVjdFN0cm9rZU9uUG9pbnRzID0gZmFicmljLnV0aWwucHJvamVjdFN0cm9rZU9uUG9pbnRzO1xuXG4gIGlmIChmYWJyaWMuUG9seWdvbikge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUG9seWdvbiBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUG9seWdvbiBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBvbHlnb25cbiAgICogQGV4dGVuZHMgZmFicmljLlBvbHlsaW5lXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5Qb2x5Z29uI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuUG9seWdvbiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5Qb2x5bGluZSwgLyoqIEBsZW5kcyBmYWJyaWMuUG9seWdvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdwb2x5Z29uJyxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Byb2plY3RTdHJva2VPblBvaW50czogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHByb2plY3RTdHJva2VPblBvaW50cyh0aGlzLnBvaW50cywgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmNvbW1vblJlbmRlcihjdHgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IGBmYWJyaWMuUG9seWdvbi5mcm9tRWxlbWVudGApXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Qb2x5Z29uXG4gICAqIEBzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zaGFwZXMuaHRtbCNQb2x5Z29uRWxlbWVudFxuICAgKi9cbiAgZmFicmljLlBvbHlnb24uQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdCgpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuUG9seWdvbn0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWdvblxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIGFmdGVyIHBhcnNpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLlBvbHlnb24uZnJvbUVsZW1lbnQgPSBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnRHZW5lcmF0b3IoJ1BvbHlnb24nKTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuUG9seWdvbiBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWdvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5QYXRoIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUG9seWdvbicsIG9iamVjdCwgY2FsbGJhY2ssICdwb2ludHMnKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4LFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lLFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQ7XG5cbiAgaWYgKGZhYnJpYy5QYXRoKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5QYXRoIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXRoIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUGF0aFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI3BhdGhfYW5kX3BhdGhncm91cH1cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlBhdGgjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5QYXRoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuUGF0aC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdwYXRoJyxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHBhdGggcG9pbnRzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhdGg6IG51bGwsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3BhdGgnLCAnZmlsbFJ1bGUnKSxcblxuICAgIHN0YXRlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzLmNvbmNhdCgncGF0aCcpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gcGF0aCBQYXRoIGRhdGEgKHNlcXVlbmNlIG9mIGNvb3JkaW5hdGVzIGFuZCBjb3JyZXNwb25kaW5nIFwiY29tbWFuZFwiIHRva2VucylcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBhdGh9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGNsb25lKG9wdGlvbnMgfHwge30pO1xuICAgICAgZGVsZXRlIG9wdGlvbnMucGF0aDtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9zZXRQYXRoKHBhdGggfHwgW10sIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gcGF0aCBQYXRoIGRhdGEgKHNlcXVlbmNlIG9mIGNvb3JkaW5hdGVzIGFuZCBjb3JyZXNwb25kaW5nIFwiY29tbWFuZFwiIHRva2VucylcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAqL1xuICAgIF9zZXRQYXRoOiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5wYXRoID0gZmFicmljLnV0aWwubWFrZVBhdGhTaW1wbGVyKFxuICAgICAgICBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IGZhYnJpYy51dGlsLnBhcnNlUGF0aChwYXRoKVxuICAgICAgKTtcblxuICAgICAgZmFicmljLlBvbHlsaW5lLnByb3RvdHlwZS5fc2V0UG9zaXRpb25EaW1lbnNpb25zLmNhbGwodGhpcywgb3B0aW9ucyB8fCB7fSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBwYXRoIG9uXG4gICAgICovXG4gICAgX3JlbmRlclBhdGhDb21tYW5kczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgY3VycmVudCwgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICAgICAgICAgIHN1YnBhdGhTdGFydFggPSAwLFxuICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSAwLFxuICAgICAgICAgIHggPSAwLCAvLyBjdXJyZW50IHhcbiAgICAgICAgICB5ID0gMCwgLy8gY3VycmVudCB5XG4gICAgICAgICAgY29udHJvbFggPSAwLCAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeFxuICAgICAgICAgIGNvbnRyb2xZID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHlcbiAgICAgICAgICBsID0gLXRoaXMucGF0aE9mZnNldC54LFxuICAgICAgICAgIHQgPSAtdGhpcy5wYXRoT2Zmc2V0Lnk7XG5cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucGF0aC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLnBhdGhbaV07XG5cbiAgICAgICAgc3dpdGNoIChjdXJyZW50WzBdKSB7IC8vIGZpcnN0IGxldHRlclxuXG4gICAgICAgICAgY2FzZSAnTCc6IC8vIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ00nOiAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IHg7XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRZID0geTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQyc6IC8vIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgICAgIHggKyBsLFxuICAgICAgICAgICAgICB5ICsgdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgICAgICBjdXJyZW50WzNdICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFs0XSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gY3VycmVudFszXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgIHggPSBzdWJwYXRoU3RhcnRYO1xuICAgICAgICAgICAgeSA9IHN1YnBhdGhTdGFydFk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgcGF0aCBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fcmVuZGVyUGF0aENvbW1hbmRzKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuUGF0aCAoJyArIHRoaXMuY29tcGxleGl0eSgpICtcbiAgICAgICAgJyk6IHsgXCJ0b3BcIjogJyArIHRoaXMudG9wICsgJywgXCJsZWZ0XCI6ICcgKyB0aGlzLmxlZnQgKyAnIH0+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICBwYXRoOiB0aGlzLnBhdGgubWFwKGZ1bmN0aW9uKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uc2xpY2UoKTsgfSksXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXRhbGVzcyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0RhdGFsZXNzT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgbyA9IHRoaXMudG9PYmplY3QoWydzb3VyY2VQYXRoJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICAgIGlmIChvLnNvdXJjZVBhdGgpIHtcbiAgICAgICAgZGVsZXRlIG8ucGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXRoID0gZmFicmljLnV0aWwuam9pblBhdGgodGhpcy5wYXRoKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8cGF0aCAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ2Q9XCInLCBwYXRoLFxuICAgICAgICAnXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiICcsXG4gICAgICAgICcvPlxcbidcbiAgICAgIF07XG4gICAgfSxcblxuICAgIF9nZXRPZmZzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRpZ2l0cyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcbiAgICAgIHJldHVybiAnIHRyYW5zbGF0ZSgnICsgdG9GaXhlZCgtdGhpcy5wYXRoT2Zmc2V0LngsIGRpZ2l0cykgKyAnLCAnICtcbiAgICAgICAgICB0b0ZpeGVkKC10aGlzLnBhdGhPZmZzZXQueSwgZGlnaXRzKSArICcpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgY2xpcFBhdGggcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9DbGlwUGF0aFNWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSB0aGlzLl9nZXRPZmZzZXRUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybiAnXFx0JyArIHRoaXMuX2NyZWF0ZUJhc2VDbGlwUGF0aFNWR01hcmt1cChcbiAgICAgICAgdGhpcy5fdG9TVkcoKSwgeyByZXZpdmVyOiByZXZpdmVyLCBhZGRpdGlvbmFsVHJhbnNmb3JtOiBhZGRpdGlvbmFsVHJhbnNmb3JtIH1cbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgYWRkaXRpb25hbFRyYW5zZm9ybSA9IHRoaXMuX2dldE9mZnNldFRyYW5zZm9ybSgpO1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAodGhpcy5fdG9TVkcoKSwgeyByZXZpdmVyOiByZXZpdmVyLCBhZGRpdGlvbmFsVHJhbnNmb3JtOiBhZGRpdGlvbmFsVHJhbnNmb3JtICB9KTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBudW1iZXIgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2UgY29tcGxleGl0eVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eSBvZiB0aGlzIGluc3RhbmNlXG4gICAgICovXG4gICAgY29tcGxleGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY0RpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYVggPSBbXSxcbiAgICAgICAgICBhWSA9IFtdLFxuICAgICAgICAgIGN1cnJlbnQsIC8vIGN1cnJlbnQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICBzdWJwYXRoU3RhcnRYID0gMCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRZID0gMCxcbiAgICAgICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgICAgIGJvdW5kcztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucGF0aC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLnBhdGhbaV07XG5cbiAgICAgICAgc3dpdGNoIChjdXJyZW50WzBdKSB7IC8vIGZpcnN0IGxldHRlclxuXG4gICAgICAgICAgY2FzZSAnTCc6IC8vIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBib3VuZHMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTSc6IC8vIG1vdmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRYID0geDtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFkgPSB5O1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgICAgICBjdXJyZW50WzZdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICBib3VuZHMgPSBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlKHgsIHksXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB4ID0gY3VycmVudFszXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgIHggPSBzdWJwYXRoU3RhcnRYO1xuICAgICAgICAgICAgeSA9IHN1YnBhdGhTdGFydFk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBib3VuZHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICBhWC5wdXNoKHBvaW50LngpO1xuICAgICAgICAgIGFZLnB1c2gocG9pbnQueSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhWC5wdXNoKHgpO1xuICAgICAgICBhWS5wdXNoKHkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWluWCA9IG1pbihhWCkgfHwgMCxcbiAgICAgICAgICBtaW5ZID0gbWluKGFZKSB8fCAwLFxuICAgICAgICAgIG1heFggPSBtYXgoYVgpIHx8IDAsXG4gICAgICAgICAgbWF4WSA9IG1heChhWSkgfHwgMCxcbiAgICAgICAgICBkZWx0YVggPSBtYXhYIC0gbWluWCxcbiAgICAgICAgICBkZWx0YVkgPSBtYXhZIC0gbWluWTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbWluWCxcbiAgICAgICAgdG9wOiBtaW5ZLFxuICAgICAgICB3aWR0aDogZGVsdGFYLFxuICAgICAgICBoZWlnaHQ6IGRlbHRhWVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5QYXRoIGZyb20gYW4gb2JqZWN0XG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5QYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUGF0aCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuUGF0aC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNvdXJjZVBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgcGF0aFVybCA9IG9iamVjdC5zb3VyY2VQYXRoO1xuICAgICAgZmFicmljLmxvYWRTVkdGcm9tVVJMKHBhdGhVcmwsIGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgICB2YXIgcGF0aCA9IGVsZW1lbnRzWzBdO1xuICAgICAgICBwYXRoLnNldE9wdGlvbnMob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5jbGlwUGF0aCkge1xuICAgICAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKFtvYmplY3QuY2xpcFBhdGhdLCBmdW5jdGlvbihlbGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgICAgICAgIHBhdGguY2xpcFBhdGggPSBlbGl2ZW5lZE9iamVjdHNbMF07XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhwYXRoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUGF0aCcsIG9iamVjdCwgY2FsbGJhY2ssICdwYXRoJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSBgZmFicmljLlBhdGguZnJvbUVsZW1lbnRgKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUGF0aC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KFsnZCddKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuUGF0aCBmcm9tIGFuIFNWRyA8cGF0aD4gZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gT3B0aW9ucyBjYWxsYmFjayBpbnZva2VkIGFmdGVyIHBhcnNpbmcgaXMgZmluaXNoZWRcbiAgICovXG4gIGZhYnJpYy5QYXRoLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLlBhdGguQVRUUklCVVRFX05BTUVTKTtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLmZyb21TVkcgPSB0cnVlO1xuICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuUGF0aChwYXJzZWRBdHRyaWJ1dGVzLmQsIGV4dGVuZChwYXJzZWRBdHRyaWJ1dGVzLCBvcHRpb25zKSkpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBtaW4gPSBmYWJyaWMudXRpbC5hcnJheS5taW4sXG4gICAgICBtYXggPSBmYWJyaWMudXRpbC5hcnJheS5tYXg7XG5cbiAgaWYgKGZhYnJpYy5Hcm91cCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHcm91cCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkdyb3VwXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQG1peGVzIGZhYnJpYy5Db2xsZWN0aW9uXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI2dyb3Vwc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkdyb3VwI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuR3JvdXAgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCBmYWJyaWMuQ29sbGVjdGlvbiwgLyoqIEBsZW5kcyBmYWJyaWMuR3JvdXAucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnZ3JvdXAnLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2Ygc3Ryb2tlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VXaWR0aDogMCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBjbGljaywgbW91c2VvdmVyLCBtb3VzZW91dCBldmVudHMgJiBob3ZlckN1cnNvciBzaG91bGQgYWxzbyBjaGVjayBmb3Igc3VidGFyZ2V0c1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN1YlRhcmdldENoZWNrOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBhcmUgY29udGFpbmVyLCBkbyBub3QgcmVuZGVyIGFueXRoaW5nIG9uIHRoZXlyIG93biwgZW5jZSBubyBjYWNoZSBwcm9wZXJ0aWVzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNhY2hlUHJvcGVydGllczogW10sXG5cbiAgICAvKipcbiAgICAgKiBzZXRPbkdyb3VwIGlzIGEgbWV0aG9kIHVzZWQgZm9yIFRleHRCb3ggdGhhdCBpcyBubyBtb3JlIHVzZWQgc2luY2UgMi4wLjAgVGhlIGJlaGF2aW9yIGlzIHN0aWxsXG4gICAgICogYXZhaWxhYmxlIHNldHRpbmcgdGhpcyBib29sZWFuIHRvIHRydWUuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdXNlU2V0T25Hcm91cDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RzIEdyb3VwIG9iamVjdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaXNBbHJlYWR5R3JvdXBlZF0gaWYgdHJ1ZSwgb2JqZWN0cyBoYXZlIGJlZW4gZ3JvdXBlZCBhbHJlYWR5LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9iamVjdHMsIG9wdGlvbnMsIGlzQWxyZWFkeUdyb3VwZWQpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgLy8gaWYgb2JqZWN0cyBlbmNsb3NlZCBpbiBhIGdyb3VwIGhhdmUgYmVlbiBncm91cGVkIGFscmVhZHksXG4gICAgICAvLyB3ZSBjYW5ub3QgY2hhbmdlIHByb3BlcnRpZXMgb2Ygb2JqZWN0cy5cbiAgICAgIC8vIFRodXMgd2UgbmVlZCB0byBzZXQgb3B0aW9ucyB0byBncm91cCB3aXRob3V0IG9iamVjdHMsXG4gICAgICBpc0FscmVhZHlHcm91cGVkICYmIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9vYmplY3RzID0gb2JqZWN0cyB8fCBbXTtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5ncm91cCA9IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNBbHJlYWR5R3JvdXBlZCkge1xuICAgICAgICB2YXIgY2VudGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmNlbnRlclBvaW50O1xuICAgICAgICAvLyB3ZSB3YW50IHRvIHNldCBvcmlnaW5zIGJlZm9yZSBjYWxjdWxhdGluZyB0aGUgYm91bmRpbmcgYm94LlxuICAgICAgICAvLyBzbyB0aGF0IHRoZSB0b3BsZWZ0IGNhbiBiZSBzZXQgd2l0aCB0aGF0IGluIG1pbmQuXG4gICAgICAgIC8vIGlmIHNwZWNpZmljIHRvcCBhbmQgbGVmdCBhcmUgcGFzc2VkLCBhcmUgb3ZlcndyaXR0ZW4gbGF0ZXJcbiAgICAgICAgLy8gd2l0aCB0aGUgY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucylcbiAgICAgICAgaWYgKG9wdGlvbnMub3JpZ2luWCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcmlnaW5YID0gb3B0aW9ucy5vcmlnaW5YO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm9yaWdpblkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3JpZ2luWSA9IG9wdGlvbnMub3JpZ2luWTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBjb21pbmcgZnJvbSBzdmcgaSBkbyBub3Qgd2FudCB0byBjYWxjIGJvdW5kcy5cbiAgICAgICAgLy8gaSBhc3N1bWUgd2lkdGggYW5kIGhlaWdodCBhcmUgcGFzc2VkIGFsb25nIG9wdGlvbnNcbiAgICAgICAgY2VudGVyIHx8IHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0Nvb3JkcyhjZW50ZXIpO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5jZW50ZXJQb2ludDtcbiAgICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl91cGRhdGVPYmplY3RzQUNvb3JkcygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVPYmplY3RzQUNvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2tpcENvbnRyb2xzID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApe1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLnNldENvb3Jkcyhza2lwQ29udHJvbHMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDb29yZHNDaGFuZ2VdIGlmIHRydWUsIGNvb3JkaW5hdGVzIG9mIG9iamVjdHMgZW5jbG9zZWQgaW4gYSBncm91cCBkbyBub3QgY2hhbmdlXG4gICAgICovXG4gICAgX3VwZGF0ZU9iamVjdHNDb29yZHM6IGZ1bmN0aW9uKGNlbnRlcikge1xuICAgICAgdmFyIGNlbnRlciA9IGNlbnRlciB8fCB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKXtcbiAgICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0Q29vcmRzKHRoaXMuX29iamVjdHNbaV0sIGNlbnRlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBjZW50ZXIsIGN1cnJlbnQgY2VudGVyIG9mIGdyb3VwLlxuICAgICAqL1xuICAgIF91cGRhdGVPYmplY3RDb29yZHM6IGZ1bmN0aW9uKG9iamVjdCwgY2VudGVyKSB7XG4gICAgICB2YXIgb2JqZWN0TGVmdCA9IG9iamVjdC5sZWZ0LFxuICAgICAgICAgIG9iamVjdFRvcCA9IG9iamVjdC50b3AsXG4gICAgICAgICAgc2tpcENvbnRyb2xzID0gdHJ1ZTtcblxuICAgICAgb2JqZWN0LnNldCh7XG4gICAgICAgIGxlZnQ6IG9iamVjdExlZnQgLSBjZW50ZXIueCxcbiAgICAgICAgdG9wOiBvYmplY3RUb3AgLSBjZW50ZXIueVxuICAgICAgfSk7XG4gICAgICBvYmplY3QuZ3JvdXAgPSB0aGlzO1xuICAgICAgb2JqZWN0LnNldENvb3Jkcyhza2lwQ29udHJvbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbmF0aW9uIG9mIGEgZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5Hcm91cDogKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArICcpPic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gb2JqZWN0IHRvIGEgZ3JvdXA7IFRoZW4gcmVjYWxjdWxhdGVzIGdyb3VwJ3MgZGltZW5zaW9uLCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFkZFdpdGhVcGRhdGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIG5lc3RlZCA9ICEhdGhpcy5ncm91cDtcbiAgICAgIHRoaXMuX3Jlc3RvcmVPYmplY3RzU3RhdGUoKTtcbiAgICAgIGZhYnJpYy51dGlsLnJlc2V0T2JqZWN0VHJhbnNmb3JtKHRoaXMpO1xuICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICBpZiAobmVzdGVkKSB7XG4gICAgICAgICAgLy8gaWYgdGhpcyBncm91cCBpcyBpbnNpZGUgYW5vdGhlciBncm91cCwgd2UgbmVlZCB0byBwcmUgdHJhbnNmb3JtIHRoZSBvYmplY3RcbiAgICAgICAgICBmYWJyaWMudXRpbC5yZW1vdmVUcmFuc2Zvcm1Gcm9tT2JqZWN0KG9iamVjdCwgdGhpcy5ncm91cC5jYWxjVHJhbnNmb3JtTWF0cml4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgICBvYmplY3QuZ3JvdXAgPSB0aGlzO1xuICAgICAgICBvYmplY3QuX3NldCgnY2FudmFzJywgdGhpcy5jYW52YXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2FsY0JvdW5kcygpO1xuICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0Nvb3JkcygpO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICBpZiAobmVzdGVkKSB7XG4gICAgICAgIHRoaXMuZ3JvdXAuYWRkV2l0aFVwZGF0ZSgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBvYmplY3QgZnJvbSBhIGdyb3VwOyBUaGVuIHJlY2FsY3VsYXRlcyBncm91cCdzIGRpbWVuc2lvbiwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW1vdmVXaXRoVXBkYXRlOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHRoaXMuX3Jlc3RvcmVPYmplY3RzU3RhdGUoKTtcbiAgICAgIGZhYnJpYy51dGlsLnJlc2V0T2JqZWN0VHJhbnNmb3JtKHRoaXMpO1xuXG4gICAgICB0aGlzLnJlbW92ZShvYmplY3QpO1xuICAgICAgdGhpcy5fY2FsY0JvdW5kcygpO1xuICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0Nvb3JkcygpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uT2JqZWN0QWRkZWQ6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICBvYmplY3QuZ3JvdXAgPSB0aGlzO1xuICAgICAgb2JqZWN0Ll9zZXQoJ2NhbnZhcycsIHRoaXMuY2FudmFzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25PYmplY3RSZW1vdmVkOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgZGVsZXRlIG9iamVjdC5ncm91cDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMudXNlU2V0T25Hcm91cCkge1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5zZXRPbkdyb3VwKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnY2FudmFzJykge1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5fc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5fc2V0LmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBfaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSB0aGlzLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgdmFyIG9ianNUb09iamVjdCA9IHRoaXMuX29iamVjdHNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgcmV0dXJuICFvYmouZXhjbHVkZUZyb21FeHBvcnQ7XG4gICAgICAgIH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHZhciBvcmlnaW5hbERlZmF1bHRzID0gb2JqLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IF9pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgICB2YXIgX29iaiA9IG9iai50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgICAgICBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBvcmlnaW5hbERlZmF1bHRzO1xuICAgICAgICAgIHJldHVybiBfb2JqO1xuICAgICAgICB9KTtcbiAgICAgIHZhciBvYmogPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgb2JqLm9iamVjdHMgPSBvYmpzVG9PYmplY3Q7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZSwgaW4gZGF0YWxlc3MgbW9kZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0RhdGFsZXNzT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgb2Jqc1RvT2JqZWN0LCBzb3VyY2VQYXRoID0gdGhpcy5zb3VyY2VQYXRoO1xuICAgICAgaWYgKHNvdXJjZVBhdGgpIHtcbiAgICAgICAgb2Jqc1RvT2JqZWN0ID0gc291cmNlUGF0aDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgX2luY2x1ZGVEZWZhdWx0VmFsdWVzID0gdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgb2Jqc1RvT2JqZWN0ID0gdGhpcy5fb2JqZWN0cy5tYXAoZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgdmFyIG9yaWdpbmFsRGVmYXVsdHMgPSBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgICAgb2JqLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gX2luY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICAgIHZhciBfb2JqID0gb2JqLnRvRGF0YWxlc3NPYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgICAgb2JqLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gb3JpZ2luYWxEZWZhdWx0cztcbiAgICAgICAgICByZXR1cm4gX29iajtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUudG9EYXRhbGVzc09iamVjdC5jYWxsKHRoaXMsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgb2JqLm9iamVjdHMgPSBvYmpzVG9PYmplY3Q7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGluc3RhbmNlIG9uIGEgZ2l2ZW4gY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgaW5zdGFuY2Ugb25cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtRG9uZSA9IHRydWU7XG4gICAgICB0aGlzLmNhbGxTdXBlcigncmVuZGVyJywgY3R4KTtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybURvbmUgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaWRlIGlmIHRoZSBvYmplY3Qgc2hvdWxkIGNhY2hlIG9yIG5vdC4gQ3JlYXRlIGl0cyBvd24gY2FjaGUgbGV2ZWxcbiAgICAgKiBuZWVkc0l0c093bkNhY2hlIHNob3VsZCBiZSB1c2VkIHdoZW4gdGhlIG9iamVjdCBkcmF3aW5nIG1ldGhvZCByZXF1aXJlc1xuICAgICAqIGEgY2FjaGUgc3RlcC4gTm9uZSBvZiB0aGUgZmFicmljIGNsYXNzZXMgcmVxdWlyZXMgaXQuXG4gICAgICogR2VuZXJhbGx5IHlvdSBkbyBub3QgY2FjaGUgb2JqZWN0cyBpbiBncm91cHMgYmVjYXVzZSB0aGUgZ3JvdXAgaXMgYWxyZWFkeSBjYWNoZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzaG91bGRDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3duQ2FjaGUgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zaG91bGRDYWNoZS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKG93bkNhY2hlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX29iamVjdHNbaV0ud2lsbERyYXdTaGFkb3coKSkge1xuICAgICAgICAgICAgdGhpcy5vd25DYWNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3duQ2FjaGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgb2JqZWN0IG9yIGEgY2hpbGQgb2JqZWN0IHdpbGwgY2FzdCBhIHNoYWRvd1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgd2lsbERyYXdTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGZhYnJpYy5PYmplY3QucHJvdG90eXBlLndpbGxEcmF3U2hhZG93LmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodGhpcy5fb2JqZWN0c1tpXS53aWxsRHJhd1NoYWRvdygpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBncm91cCBvciBpdHMgcGFyZW50IGdyb3VwIGFyZSBjYWNoaW5nLCByZWN1cnNpdmVseSB1cFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNPbkFDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vd25DYWNoaW5nIHx8ICh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAuaXNPbkFDYWNoZSgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgZHJhd2luZyBvcGVyYXRpb24gZm9yIGFuIG9iamVjdCBvbiBhIHNwZWNpZmllZCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIGRyYXdPYmplY3Q6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5yZW5kZXIoY3R4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RyYXdDbGlwUGF0aChjdHgsIHRoaXMuY2xpcFBhdGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjYWNoZSBpcyBkaXJ0eVxuICAgICAqL1xuICAgIGlzQ2FjaGVEaXJ0eTogZnVuY3Rpb24oc2tpcENhbnZhcykge1xuICAgICAgaWYgKHRoaXMuY2FsbFN1cGVyKCdpc0NhY2hlRGlydHknLCBza2lwQ2FudmFzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zdGF0ZWZ1bGxDYWNoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodGhpcy5fb2JqZWN0c1tpXS5pc0NhY2hlRGlydHkodHJ1ZSkpIHtcbiAgICAgICAgICBpZiAodGhpcy5fY2FjaGVDYW52YXMpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZ3JvdXAgaGFzIG5vdCBhIGNhY2hlIGNhbnZhcyB0aGVyZSBpcyBub3RoaW5nIHRvIGNsZWFuXG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuY2FjaGVXaWR0aCAvIHRoaXMuem9vbVgsIHkgPSB0aGlzLmNhY2hlSGVpZ2h0IC8gdGhpcy56b29tWTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlQ29udGV4dC5jbGVhclJlY3QoLXggLyAyLCAteSAvIDIsIHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBzdGF0ZSBvZiBlYWNoIG9mIGdyb3VwIG9iamVjdHMgKG9yaWdpbmFsIHN0YXRlIGlzIHRoYXQgd2hpY2ggd2FzIGJlZm9yZSBncm91cCB3YXMgY3JlYXRlZCkuXG4gICAgICogaWYgdGhlIG5lc3RlZCBib29sZWFuIGlzIHRydWUsIHRoZSBvcmlnaW5hbCBzdGF0ZSB3aWxsIGJlIHJlc3RvcmVkIGp1c3QgZm9yIHRoZVxuICAgICAqIGZpcnN0IGdyb3VwIGFuZCBub3QgZm9yIGFsbCB0aGUgZ3JvdXAgY2hhaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVzdGVkIHRlbGwgdGhlIGZ1bmN0aW9uIHRvIHJlc3RvcmUgb2JqZWN0IHN0YXRlIHVwIHRvIHRoZSBwYXJlbnQgZ3JvdXAgYW5kIG5vdCBtb3JlXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9yZXN0b3JlT2JqZWN0c1N0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBncm91cE1hdHJpeCA9IHRoaXMuY2FsY093bk1hdHJpeCgpO1xuICAgICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAvLyBpbnN0ZWFkIG9mIHVzaW5nIF90aGlzID0gdGhpcztcbiAgICAgICAgZmFicmljLnV0aWwuYWRkVHJhbnNmb3JtVG9PYmplY3Qob2JqZWN0LCBncm91cE1hdHJpeCk7XG4gICAgICAgIGRlbGV0ZSBvYmplY3QuZ3JvdXA7XG4gICAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGEgZ3JvdXAgKHJlc3RvcmluZyBzdGF0ZSBvZiBpdHMgb2JqZWN0cylcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAvLyB3aGVuIGdyb3VwIGlzIGRlc3Ryb3llZCBvYmplY3RzIG5lZWRzIHRvIGdldCBhIHJlcGFpbnQgdG8gYmUgZXZlbnR1YWxseVxuICAgICAgLy8gZGlzcGxheWVkIG9uIGNhbnZhcy5cbiAgICAgIHRoaXMuX29iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0LnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc3RvcmVPYmplY3RzU3RhdGUoKTtcbiAgICB9LFxuXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2Rpc3Bvc2UnKTtcbiAgICAgIHRoaXMuZm9yRWFjaE9iamVjdChmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5kaXNwb3NlICYmIG9iamVjdC5kaXNwb3NlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbWFrZSBhIGdyb3VwIGFuIGFjdGl2ZSBzZWxlY3Rpb24sIHJlbW92ZSB0aGUgZ3JvdXAgZnJvbSBjYW52YXNcbiAgICAgKiB0aGUgZ3JvdXAgaGFzIHRvIGJlIG9uIGNhbnZhcyBmb3IgdGhpcyB0byB3b3JrLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5BY3RpdmVTZWxlY3Rpb259IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdG9BY3RpdmVTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5vYmplY3RzO1xuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKFtdKTtcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi5zZXQob3B0aW9ucyk7XG4gICAgICBhY3RpdmVTZWxlY3Rpb24udHlwZSA9ICdhY3RpdmVTZWxlY3Rpb24nO1xuICAgICAgY2FudmFzLnJlbW92ZSh0aGlzKTtcbiAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0Lmdyb3VwID0gYWN0aXZlU2VsZWN0aW9uO1xuICAgICAgICBvYmplY3QuZGlydHkgPSB0cnVlO1xuICAgICAgICBjYW52YXMuYWRkKG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIGFjdGl2ZVNlbGVjdGlvbi5jYW52YXMgPSBjYW52YXM7XG4gICAgICBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHMgPSBvYmplY3RzO1xuICAgICAgY2FudmFzLl9hY3RpdmVPYmplY3QgPSBhY3RpdmVTZWxlY3Rpb247XG4gICAgICBhY3RpdmVTZWxlY3Rpb24uc2V0Q29vcmRzKCk7XG4gICAgICByZXR1cm4gYWN0aXZlU2VsZWN0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhIGdyb3VwIChyZXN0b3Jpbmcgc3RhdGUgb2YgaXRzIG9iamVjdHMpXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHVuZ3JvdXBPbkNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzdG9yZU9iamVjdHNTdGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGNvb3JkaW5hdGVzIG9mIGFsbCBvYmplY3RzIGluc2lkZSBncm91cFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRPYmplY3RzQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBza2lwQ29udHJvbHMgPSB0cnVlO1xuICAgICAgdGhpcy5mb3JFYWNoT2JqZWN0KGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKHNraXBDb250cm9scyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYWxjQm91bmRzOiBmdW5jdGlvbihvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgIHZhciBhWCA9IFtdLFxuICAgICAgICAgIGFZID0gW10sXG4gICAgICAgICAgbywgcHJvcCwgY29vcmRzLFxuICAgICAgICAgIHByb3BzID0gWyd0cicsICdicicsICdibCcsICd0bCddLFxuICAgICAgICAgIGkgPSAwLCBpTGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGgsXG4gICAgICAgICAgaiwgakxlbiA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgZm9yICggOyBpIDwgaUxlbjsgKytpKSB7XG4gICAgICAgIG8gPSB0aGlzLl9vYmplY3RzW2ldO1xuICAgICAgICBjb29yZHMgPSBvLmNhbGNBQ29vcmRzKCk7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqKyspIHtcbiAgICAgICAgICBwcm9wID0gcHJvcHNbal07XG4gICAgICAgICAgYVgucHVzaChjb29yZHNbcHJvcF0ueCk7XG4gICAgICAgICAgYVkucHVzaChjb29yZHNbcHJvcF0ueSk7XG4gICAgICAgIH1cbiAgICAgICAgby5hQ29vcmRzID0gY29vcmRzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9nZXRCb3VuZHMoYVgsIGFZLCBvbmx5V2lkdGhIZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGFYLCBhWSwgb25seVdpZHRoSGVpZ2h0KSB7XG4gICAgICB2YXIgbWluWFkgPSBuZXcgZmFicmljLlBvaW50KG1pbihhWCksIG1pbihhWSkpLFxuICAgICAgICAgIG1heFhZID0gbmV3IGZhYnJpYy5Qb2ludChtYXgoYVgpLCBtYXgoYVkpKSxcbiAgICAgICAgICB0b3AgPSBtaW5YWS55IHx8IDAsIGxlZnQgPSBtaW5YWS54IHx8IDAsXG4gICAgICAgICAgd2lkdGggPSAobWF4WFkueCAtIG1pblhZLngpIHx8IDAsXG4gICAgICAgICAgaGVpZ2h0ID0gKG1heFhZLnkgLSBtaW5YWS55KSB8fCAwO1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBpZiAoIW9ubHlXaWR0aEhlaWdodCkge1xuICAgICAgICAvLyB0aGUgYm91bmRpbmcgYm94IGFsd2F5cyBmaW5kcyB0aGUgdG9wbGVmdCBtb3N0IGNvcm5lci5cbiAgICAgICAgLy8gd2hhdGV2ZXIgaXMgdGhlIGdyb3VwIG9yaWdpbiwgd2Ugc2V0IHVwIGhlcmUgdGhlIGxlZnQvdG9wIHBvc2l0aW9uLlxuICAgICAgICB0aGlzLnNldFBvc2l0aW9uQnlPcmlnaW4oeyB4OiBsZWZ0LCB5OiB0b3AgfSwgJ2xlZnQnLCAndG9wJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgc3ZnU3RyaW5nID0gWyc8ZyAnLCAnQ09NTU9OX1BBUlRTJywgJyA+XFxuJ107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN2Z1N0cmluZy5wdXNoKCdcXHRcXHQnLCB0aGlzLl9vYmplY3RzW2ldLnRvU1ZHKHJldml2ZXIpKTtcbiAgICAgIH1cbiAgICAgIHN2Z1N0cmluZy5wdXNoKCc8L2c+XFxuJyk7XG4gICAgICByZXR1cm4gc3ZnU3RyaW5nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0eWxlcy1zdHJpbmcgZm9yIHN2Zy1leHBvcnQsIHNwZWNpZmljIHZlcnNpb24gZm9yIGdyb3VwXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1N0eWxlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3BhY2l0eSA9IHR5cGVvZiB0aGlzLm9wYWNpdHkgIT09ICd1bmRlZmluZWQnICYmIHRoaXMub3BhY2l0eSAhPT0gMSA/XG4gICAgICAgICAgICAnb3BhY2l0eTogJyArIHRoaXMub3BhY2l0eSArICc7JyA6ICcnLFxuICAgICAgICAgIHZpc2liaWxpdHkgPSB0aGlzLnZpc2libGUgPyAnJyA6ICcgdmlzaWJpbGl0eTogaGlkZGVuOyc7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBvcGFjaXR5LFxuICAgICAgICB0aGlzLmdldFN2Z0ZpbHRlcigpLFxuICAgICAgICB2aXNpYmlsaXR5XG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyBjbGlwUGF0aCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b0NsaXBQYXRoU1ZHOiBmdW5jdGlvbihyZXZpdmVyKSB7XG4gICAgICB2YXIgc3ZnU3RyaW5nID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN2Z1N0cmluZy5wdXNoKCdcXHQnLCB0aGlzLl9vYmplY3RzW2ldLnRvQ2xpcFBhdGhTVkcocmV2aXZlcikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQmFzZUNsaXBQYXRoU1ZHTWFya3VwKHN2Z1N0cmluZywgeyByZXZpdmVyOiByZXZpdmVyIH0pO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHtAbGluayBmYWJyaWMuR3JvdXB9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Hcm91cFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYSBncm91cCBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZ3JvdXAgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLkdyb3VwLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9iamVjdHMgPSBvYmplY3Qub2JqZWN0cyxcbiAgICAgICAgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvYmplY3QsIHRydWUpO1xuICAgIGRlbGV0ZSBvcHRpb25zLm9iamVjdHM7XG4gICAgaWYgKHR5cGVvZiBvYmplY3RzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gaXQgaGFzIHRvIGJlIGFuIHVybCBvciBzb21ldGhpbmcgd2VudCB3cm9uZy5cbiAgICAgIGZhYnJpYy5sb2FkU1ZHRnJvbVVSTChvYmplY3RzLCBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIGdyb3VwID0gZmFicmljLnV0aWwuZ3JvdXBTVkdFbGVtZW50cyhlbGVtZW50cywgb2JqZWN0LCBvYmplY3RzKTtcbiAgICAgICAgdmFyIGNsaXBQYXRoID0gb3B0aW9ucy5jbGlwUGF0aDtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2xpcFBhdGg7XG4gICAgICAgIGdyb3VwLnNldChvcHRpb25zKTtcbiAgICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMoW2NsaXBQYXRoXSwgZnVuY3Rpb24oZWxpdmVuZWRPYmplY3RzKSB7XG4gICAgICAgICAgICBncm91cC5jbGlwUGF0aCA9IGVsaXZlbmVkT2JqZWN0c1swXTtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGdyb3VwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhncm91cCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhvYmplY3RzLCBmdW5jdGlvbiAoZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdEVubGl2YWJsZXMob2JqZWN0LCBvcHRpb25zLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5ldyBmYWJyaWMuR3JvdXAoZW5saXZlbmVkT2JqZWN0cywgb3B0aW9ucywgdHJ1ZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogR3JvdXAgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb25cbiAgICogQGV4dGVuZHMgZmFicmljLkdyb3VwXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI2dyb3Vwc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkFjdGl2ZVNlbGVjdGlvbiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkFjdGl2ZVNlbGVjdGlvbiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5Hcm91cCwgLyoqIEBsZW5kcyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2FjdGl2ZVNlbGVjdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RzIEFjdGl2ZVNlbGVjdGlvbiBvYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9iamVjdHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IG9iamVjdHMgfHwgW107XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0uZ3JvdXAgPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vcmlnaW5YKSB7XG4gICAgICAgIHRoaXMub3JpZ2luWCA9IG9wdGlvbnMub3JpZ2luWDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm9yaWdpblkpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5ZID0gb3B0aW9ucy5vcmlnaW5ZO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2FsY0JvdW5kcygpO1xuICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0Nvb3JkcygpO1xuICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRlIGFjdGl2ZVNlbGVjdGlvbiB0byBhIG5vcm1hbCBncm91cCxcbiAgICAgKiBIaWdoIGxldmVsIGZ1bmN0aW9uIHRoYXQgYXV0b21hdGljYWxseSBhZGRzIGl0IHRvIGNhbnZhcyBhc1xuICAgICAqIGFjdGl2ZSBvYmplY3QuIG5vIGV2ZW50cyBmaXJlZC5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9XG4gICAgICovXG4gICAgdG9Hcm91cDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMuY29uY2F0KCk7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcyk7XG4gICAgICB2YXIgbmV3R3JvdXAgPSBuZXcgZmFicmljLkdyb3VwKFtdKTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLnR5cGU7XG4gICAgICBuZXdHcm91cC5zZXQob3B0aW9ucyk7XG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5jYW52YXMucmVtb3ZlKG9iamVjdCk7XG4gICAgICAgIG9iamVjdC5ncm91cCA9IG5ld0dyb3VwO1xuICAgICAgfSk7XG4gICAgICBuZXdHcm91cC5fb2JqZWN0cyA9IG9iamVjdHM7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBuZXdHcm91cDtcbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIGNhbnZhcy5hZGQobmV3R3JvdXApO1xuICAgICAgY2FudmFzLl9hY3RpdmVPYmplY3QgPSBuZXdHcm91cDtcbiAgICAgIG5ld0dyb3VwLnNldENvb3JkcygpO1xuICAgICAgcmV0dXJuIG5ld0dyb3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiByZXR1cm5zIHRydWUsIGRlc2VsZWN0aW9uIGlzIGNhbmNlbGxlZC5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBbY2FuY2VsXVxuICAgICAqL1xuICAgIG9uRGVzZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICcjPGZhYnJpYy5BY3RpdmVTZWxlY3Rpb246ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgKyAnKT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGUgaWYgdGhlIG9iamVjdCBzaG91bGQgY2FjaGUgb3Igbm90LiBDcmVhdGUgaXRzIG93biBjYWNoZSBsZXZlbFxuICAgICAqIG9iamVjdENhY2hpbmcgaXMgYSBnbG9iYWwgZmxhZywgd2lucyBvdmVyIGV2ZXJ5dGhpbmdcbiAgICAgKiBuZWVkc0l0c093bkNhY2hlIHNob3VsZCBiZSB1c2VkIHdoZW4gdGhlIG9iamVjdCBkcmF3aW5nIG1ldGhvZCByZXF1aXJlc1xuICAgICAqIGEgY2FjaGUgc3RlcC4gTm9uZSBvZiB0aGUgZmFicmljIGNsYXNzZXMgcmVxdWlyZXMgaXQuXG4gICAgICogR2VuZXJhbGx5IHlvdSBkbyBub3QgY2FjaGUgb2JqZWN0cyBpbiBncm91cHMgYmVjYXVzZSB0aGUgZ3JvdXAgb3V0c2lkZSBpcyBjYWNoZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzaG91bGRDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgZ3JvdXAgb3IgaXRzIHBhcmVudCBncm91cCBhcmUgY2FjaGluZywgcmVjdXJzaXZlbHkgdXBcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzT25BQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGNvbnRyb2xzIGFuZCBib3JkZXJzIGZvciB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVPdmVycmlkZV0gcHJvcGVydGllcyB0byBvdmVycmlkZSB0aGUgb2JqZWN0IHN0eWxlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjaGlsZHJlbk92ZXJyaWRlXSBwcm9wZXJ0aWVzIHRvIG92ZXJyaWRlIHRoZSBjaGlsZHJlbiBvdmVycmlkZXNcbiAgICAgKi9cbiAgICBfcmVuZGVyQ29udHJvbHM6IGZ1bmN0aW9uKGN0eCwgc3R5bGVPdmVycmlkZSwgY2hpbGRyZW5PdmVycmlkZSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuaXNNb3ZpbmcgPyB0aGlzLmJvcmRlck9wYWNpdHlXaGVuTW92aW5nIDogMTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfcmVuZGVyQ29udHJvbHMnLCBjdHgsIHN0eWxlT3ZlcnJpZGUpO1xuICAgICAgY2hpbGRyZW5PdmVycmlkZSA9IGNoaWxkcmVuT3ZlcnJpZGUgfHwgeyB9O1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZHJlbk92ZXJyaWRlLmhhc0NvbnRyb2xzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjaGlsZHJlbk92ZXJyaWRlLmhhc0NvbnRyb2xzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbk92ZXJyaWRlLmZvckFjdGl2ZVNlbGVjdGlvbiA9IHRydWU7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLl9yZW5kZXJDb250cm9scyhjdHgsIGNoaWxkcmVuT3ZlcnJpZGUpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkFjdGl2ZVNlbGVjdGlvbn0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkFjdGl2ZVNlbGVjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYSBncm91cCBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gQWN0aXZlU2VsZWN0aW9uIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24uZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhvYmplY3Qub2JqZWN0cywgZnVuY3Rpb24oZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgZGVsZXRlIG9iamVjdC5vYmplY3RzO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobmV3IGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24oZW5saXZlbmVkT2JqZWN0cywgb2JqZWN0LCB0cnVlKSk7XG4gICAgfSk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kO1xuXG4gIGlmICghZ2xvYmFsLmZhYnJpYykge1xuICAgIGdsb2JhbC5mYWJyaWMgPSB7IH07XG4gIH1cblxuICBpZiAoZ2xvYmFsLmZhYnJpYy5JbWFnZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuSW1hZ2UgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbWFnZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjaW1hZ2VzfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5JbWFnZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2ltYWdlJyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIGEgc3Ryb2tlLlxuICAgICAqIEZvciBpbWFnZSBxdWFsaXR5IGEgc3Ryb2tlIG11bHRpcGxlIG9mIDIgZ2l2ZXMgYmV0dGVyIHJlc3VsdHMuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VXaWR0aDogMCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2FsbGluZyB7QGxpbmsgZmFicmljLkltYWdlLmdldFNyY30sIHJldHVybiB2YWx1ZSBmcm9tIGVsZW1lbnQgc3JjIHdpdGggYGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzcmMnKWAuXG4gICAgICogVGhpcyBhbGxvd3MgZm9yIHJlbGF0aXZlIHVybHMgYXMgaW1hZ2Ugc3JjLlxuICAgICAqIEBzaW5jZSAyLjcuMFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNyY0Zyb21BdHRyaWJ1dGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIGNvbnRhaW5zIGxhc3QgdmFsdWUgb2Ygc2NhbGVYIHRvIGRldGVjdFxuICAgICAqIGlmIHRoZSBJbWFnZSBnb3QgcmVzaXplZCBhZnRlciB0aGUgbGFzdCBSZW5kZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBfbGFzdFNjYWxlWDogMSxcblxuICAgIC8qKlxuICAgICAqIHByaXZhdGVcbiAgICAgKiBjb250YWlucyBsYXN0IHZhbHVlIG9mIHNjYWxlWSB0byBkZXRlY3RcbiAgICAgKiBpZiB0aGUgSW1hZ2UgZ290IHJlc2l6ZWQgYWZ0ZXIgdGhlIGxhc3QgUmVuZGVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgX2xhc3RTY2FsZVk6IDEsXG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlXG4gICAgICogY29udGFpbnMgbGFzdCB2YWx1ZSBvZiBzY2FsaW5nIGFwcGxpZWQgYnkgdGhlIGFwcGx5IGZpbHRlciBjaGFpblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIF9maWx0ZXJTY2FsaW5nWDogMSxcblxuICAgIC8qKlxuICAgICAqIHByaXZhdGVcbiAgICAgKiBjb250YWlucyBsYXN0IHZhbHVlIG9mIHNjYWxpbmcgYXBwbGllZCBieSB0aGUgYXBwbHkgZmlsdGVyIGNoYWluXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgX2ZpbHRlclNjYWxpbmdZOiAxLFxuXG4gICAgLyoqXG4gICAgICogbWluaW11bSBzY2FsZSBmYWN0b3IgdW5kZXIgd2hpY2ggYW55IHJlc2l6ZUZpbHRlciBpcyB0cmlnZ2VyZWQgdG8gcmVzaXplIHRoZSBpbWFnZVxuICAgICAqIDAgd2lsbCBkaXNhYmxlIHRoZSBhdXRvbWF0aWMgcmVzaXplLiAxIHdpbGwgdHJpZ2dlciBhdXRvbWF0aWNhbGx5IGFsd2F5cy5cbiAgICAgKiBudW1iZXIgYmlnZ2VyIHRoYW4gMSBhcmUgbm90IGltcGxlbWVudGVkIHlldC5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBtaW5pbXVtU2NhbGVUcmlnZ2VyOiAwLjUsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZlxuICAgICAqIHN0YXRlIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkICh7QGxpbmsgZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWR9KVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzLmNvbmNhdCgnY3JvcFgnLCAnY3JvcFknKSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmIGNhY2hlIG5lZWRzIHJlZnJlc2hcbiAgICAgKiBUaG9zZSBwcm9wZXJ0aWVzIGFyZSBjaGVja2VkIGJ5IHN0YXRlZnVsbENhY2hlIE9OICggb3IgbGF6eSBtb2RlIGlmIHdlIHdhbnQgKSBvciBmcm9tIHNpbmdsZVxuICAgICAqIGNhbGxzIHRvIE9iamVjdC5zZXQoa2V5LCB2YWx1ZSkuIElmIHRoZSBrZXkgaXMgaW4gdGhpcyBsaXN0LCB0aGUgb2JqZWN0IGlzIG1hcmtlZCBhcyBkaXJ0eVxuICAgICAqIGFuZCByZWZyZXNoZWQgYXQgdGhlIG5leHQgcmVuZGVyXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ2Nyb3BYJywgJ2Nyb3BZJyksXG5cbiAgICAvKipcbiAgICAgKiBrZXkgdXNlZCB0byByZXRyaWV2ZSB0aGUgdGV4dHVyZSByZXByZXNlbnRpbmcgdGhpcyBpbWFnZVxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2FjaGVLZXk6ICcnLFxuXG4gICAgLyoqXG4gICAgICogSW1hZ2UgY3JvcCBpbiBwaXhlbHMgZnJvbSBvcmlnaW5hbCBpbWFnZSBzaXplLlxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3JvcFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbWFnZSBjcm9wIGluIHBpeGVscyBmcm9tIG9yaWdpbmFsIGltYWdlIHNpemUuXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjcm9wWTogMCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgY2FudmFzIHdpbGwgdXNlIGltYWdlIHNtb290aGluZyB3aGVuIHBhaW50aW5nIHRoaXMgaW1hZ2UuXG4gICAgICogQWxzbyBpbmZsdWVuY2UgaWYgdGhlIGNhY2hlQ2FudmFzIGZvciB0aGlzIGltYWdlIHVzZXMgaW1hZ2VTbW9vdGhpbmdcbiAgICAgKiBAc2luY2UgNC4wLjAtYmV0YS4xMVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGltYWdlU21vb3RoaW5nOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBJbWFnZSBjYW4gYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbnkgY2FudmFzIGRyYXdhYmxlIG9yIGEgc3RyaW5nLlxuICAgICAqIFRoZSBzdHJpbmcgc2hvdWxkIGJlIGEgdXJsIGFuZCB3aWxsIGJlIGxvYWRlZCBhcyBhbiBpbWFnZS5cbiAgICAgKiBDYW52YXMgYW5kIEltYWdlIGVsZW1lbnQgd29yayBvdXQgb2YgdGhlIGJveCwgd2hpbGUgdmlkZW9zIHJlcXVpcmUgZXh0cmEgY29kZSB0byB3b3JrLlxuICAgICAqIFBsZWFzZSBjaGVjayB2aWRlbyBlbGVtZW50IGV2ZW50cyBmb3Igc2Vla2luZy5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQgfCBTdHJpbmd9IGVsZW1lbnQgSW1hZ2UgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgYWZ0ZXIgZXZlbnR1YWwgZmlsdGVycyBhcHBsaWVkLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdGhpcy5maWx0ZXJzID0gW107XG4gICAgICB0aGlzLmNhY2hlS2V5ID0gJ3RleHR1cmUnICsgZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGltYWdlIGVsZW1lbnQgd2hpY2ggdGhpcyBpbnN0YW5jZSBpZiBiYXNlZCBvblxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEltYWdlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50IHx8IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGltYWdlIGVsZW1lbnQgZm9yIHRoaXMgaW5zdGFuY2UgdG8gYSBzcGVjaWZpZWQgb25lLlxuICAgICAqIElmIGZpbHRlcnMgZGVmaW5lZCB0aGV5IGFyZSBhcHBsaWVkIHRvIG5ldyBpbWFnZS5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBjYW52YXMucmVuZGVyQWxsYCBhbmQgYG9iamVjdC5zZXRDb29yZHNgIGFmdGVyIHJlcGxhY2luZywgdG8gcmVuZGVyIG5ldyBpbWFnZSBhbmQgdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLnJlbW92ZVRleHR1cmUodGhpcy5jYWNoZUtleSk7XG4gICAgICB0aGlzLnJlbW92ZVRleHR1cmUodGhpcy5jYWNoZUtleSArICdfZmlsdGVyZWQnKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5fb3JpZ2luYWxFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX2luaXRDb25maWcob3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5maWx0ZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0aGlzLmFwcGx5RmlsdGVycygpO1xuICAgICAgfVxuICAgICAgLy8gcmVzaXplRmlsdGVycyB3b3JrIG9uIHRoZSBhbHJlYWR5IGZpbHRlcmVkIGNvcHkuXG4gICAgICAvLyB3ZSBuZWVkIHRvIGFwcGx5IHJlc2l6ZUZpbHRlcnMgQUZURVIgbm9ybWFsIGZpbHRlcnMuXG4gICAgICAvLyBhcHBseVJlc2l6ZUZpbHRlcnMgaXMgcnVuIG1vcmUgb2Z0ZW4gdGhhbiBub3JtYWwgZmlsdGVyc1xuICAgICAgLy8gYW5kIGlzIHRyaWdnZXJlZCBieSB1c2VyIGludGVyYWN0aW9ucyByYXRoZXIgdGhhbiBkZXYgY29kZVxuICAgICAgaWYgKHRoaXMucmVzaXplRmlsdGVyKSB7XG4gICAgICAgIHRoaXMuYXBwbHlSZXNpemVGaWx0ZXJzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgc2luZ2xlIHRleHR1cmUgaWYgaW4gd2ViZ2wgbW9kZVxuICAgICAqL1xuICAgIHJlbW92ZVRleHR1cmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGJhY2tlbmQgPSBmYWJyaWMuZmlsdGVyQmFja2VuZDtcbiAgICAgIGlmIChiYWNrZW5kICYmIGJhY2tlbmQuZXZpY3RDYWNoZXNGb3JLZXkpIHtcbiAgICAgICAgYmFja2VuZC5ldmljdENhY2hlc0ZvcktleShrZXkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdGV4dHVyZXMsIHJlZmVyZW5jZSB0byBlbGVtZW50cyBhbmQgZXZlbnR1YWxseSBKU0RPTSBjbGVhbnVwXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2Rpc3Bvc2UnKTtcbiAgICAgIHRoaXMucmVtb3ZlVGV4dHVyZSh0aGlzLmNhY2hlS2V5KTtcbiAgICAgIHRoaXMucmVtb3ZlVGV4dHVyZSh0aGlzLmNhY2hlS2V5ICsgJ19maWx0ZXJlZCcpO1xuICAgICAgdGhpcy5fY2FjaGVDb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgWydfb3JpZ2luYWxFbGVtZW50JywgJ19lbGVtZW50JywgJ19maWx0ZXJlZEVsJywgJ19jYWNoZUNhbnZhcyddLmZvckVhY2goKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgZmFicmljLnV0aWwuY2xlYW5VcEpzZG9tTm9kZSh0aGlzW2VsZW1lbnRdKTtcbiAgICAgICAgdGhpc1tlbGVtZW50XSA9IHVuZGVmaW5lZDtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNyb3NzT3JpZ2luIHZhbHVlIChvZiB0aGUgY29ycmVzcG9uZGluZyBpbWFnZSBlbGVtZW50KVxuICAgICAqL1xuICAgIGdldENyb3NzT3JpZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbEVsZW1lbnQgJiYgKHRoaXMuX29yaWdpbmFsRWxlbWVudC5jcm9zc09yaWdpbiB8fCBudWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvcmlnaW5hbCBzaXplIG9mIGFuIGltYWdlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3Qgd2l0aCBcIndpZHRoXCIgYW5kIFwiaGVpZ2h0XCIgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdldE9yaWdpbmFsU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGVsZW1lbnQubmF0dXJhbFdpZHRoIHx8IGVsZW1lbnQud2lkdGgsXG4gICAgICAgIGhlaWdodDogZWxlbWVudC5uYXR1cmFsSGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfc3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VXaWR0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdyA9IHRoaXMud2lkdGggLyAyLCBoID0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbygtdywgLWgpO1xuICAgICAgY3R4LmxpbmVUbyh3LCAtaCk7XG4gICAgICBjdHgubGluZVRvKHcsIGgpO1xuICAgICAgY3R4LmxpbmVUbygtdywgaCk7XG4gICAgICBjdHgubGluZVRvKC13LCAtaCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBmaWx0ZXJzID0gW107XG5cbiAgICAgIHRoaXMuZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlck9iaikge1xuICAgICAgICBpZiAoZmlsdGVyT2JqKSB7XG4gICAgICAgICAgZmlsdGVycy5wdXNoKGZpbHRlck9iai50b09iamVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgb2JqZWN0ID0gZXh0ZW5kKFxuICAgICAgICB0aGlzLmNhbGxTdXBlcihcbiAgICAgICAgICAndG9PYmplY3QnLFxuICAgICAgICAgIFsnY3JvcFgnLCAnY3JvcFknXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSlcbiAgICAgICAgKSwge1xuICAgICAgICAgIHNyYzogdGhpcy5nZXRTcmMoKSxcbiAgICAgICAgICBjcm9zc09yaWdpbjogdGhpcy5nZXRDcm9zc09yaWdpbigpLFxuICAgICAgICAgIGZpbHRlcnM6IGZpbHRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMucmVzaXplRmlsdGVyKSB7XG4gICAgICAgIG9iamVjdC5yZXNpemVGaWx0ZXIgPSB0aGlzLnJlc2l6ZUZpbHRlci50b09iamVjdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGFuIGltYWdlIGhhcyBjcm9wIGFwcGxpZWQsIGluc3BlY3RpbmcgdmFsdWVzIG9mIGNyb3BYLGNyb3BZLHdpZHRoLGhlaWdodC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc0Nyb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JvcFggfHwgdGhpcy5jcm9wWSB8fCB0aGlzLndpZHRoIDwgdGhpcy5fZWxlbWVudC53aWR0aCB8fCB0aGlzLmhlaWdodCA8IHRoaXMuX2VsZW1lbnQuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdmdTdHJpbmcgPSBbXSwgaW1hZ2VNYXJrdXAgPSBbXSwgc3Ryb2tlU3ZnLCBlbGVtZW50ID0gdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICB4ID0gLXRoaXMud2lkdGggLyAyLCB5ID0gLXRoaXMuaGVpZ2h0IC8gMiwgY2xpcFBhdGggPSAnJywgaW1hZ2VSZW5kZXJpbmcgPSAnJztcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNDcm9wKCkpIHtcbiAgICAgICAgdmFyIGNsaXBQYXRoSWQgPSBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgICAgIHN2Z1N0cmluZy5wdXNoKFxuICAgICAgICAgICc8Y2xpcFBhdGggaWQ9XCJpbWFnZUNyb3BfJyArIGNsaXBQYXRoSWQgKyAnXCI+XFxuJyxcbiAgICAgICAgICAnXFx0PHJlY3QgeD1cIicgKyB4ICsgJ1wiIHk9XCInICsgeSArICdcIiB3aWR0aD1cIicgKyB0aGlzLndpZHRoICsgJ1wiIGhlaWdodD1cIicgKyB0aGlzLmhlaWdodCArICdcIiAvPlxcbicsXG4gICAgICAgICAgJzwvY2xpcFBhdGg+XFxuJ1xuICAgICAgICApO1xuICAgICAgICBjbGlwUGF0aCA9ICcgY2xpcC1wYXRoPVwidXJsKCNpbWFnZUNyb3BfJyArIGNsaXBQYXRoSWQgKyAnKVwiICc7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaW1hZ2VTbW9vdGhpbmcpIHtcbiAgICAgICAgaW1hZ2VSZW5kZXJpbmcgPSAnXCIgaW1hZ2UtcmVuZGVyaW5nPVwib3B0aW1pemVTcGVlZCc7XG4gICAgICB9XG4gICAgICBpbWFnZU1hcmt1cC5wdXNoKCdcXHQ8aW1hZ2UgJywgJ0NPTU1PTl9QQVJUUycsICd4bGluazpocmVmPVwiJywgdGhpcy5nZXRTdmdTcmModHJ1ZSksXG4gICAgICAgICdcIiB4PVwiJywgeCAtIHRoaXMuY3JvcFgsICdcIiB5PVwiJywgeSAtIHRoaXMuY3JvcFksXG4gICAgICAgIC8vIHdlJ3JlIGVzc2VudGlhbGx5IG1vdmluZyBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24gZnJvbSB0b3AvbGVmdCBjb3JuZXIgdG8gdGhlIGNlbnRlciBvZiB0aGUgc2hhcGVcbiAgICAgICAgLy8gYnkgd3JhcHBpbmcgaXQgaW4gY29udGFpbmVyIDxnPiBlbGVtZW50IHdpdGggYWN0dWFsIHRyYW5zZm9ybWF0aW9uLCB0aGVuIG9mZnNldHRpbmcgb2JqZWN0IHRvIHRoZSB0b3AvbGVmdFxuICAgICAgICAvLyBzbyB0aGF0IG9iamVjdCdzIGNlbnRlciBhbGlnbnMgd2l0aCBjb250YWluZXIncyBsZWZ0L3RvcFxuICAgICAgICAnXCIgd2lkdGg9XCInLCBlbGVtZW50LndpZHRoIHx8IGVsZW1lbnQubmF0dXJhbFdpZHRoLFxuICAgICAgICAnXCIgaGVpZ2h0PVwiJywgZWxlbWVudC5oZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQsXG4gICAgICAgIGltYWdlUmVuZGVyaW5nLFxuICAgICAgICAnXCInLCBjbGlwUGF0aCxcbiAgICAgICAgJz48L2ltYWdlPlxcbicpO1xuXG4gICAgICBpZiAodGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VEYXNoQXJyYXkpIHtcbiAgICAgICAgdmFyIG9yaWdGaWxsID0gdGhpcy5maWxsO1xuICAgICAgICB0aGlzLmZpbGwgPSBudWxsO1xuICAgICAgICBzdHJva2VTdmcgPSBbXG4gICAgICAgICAgJ1xcdDxyZWN0ICcsXG4gICAgICAgICAgJ3g9XCInLCB4LCAnXCIgeT1cIicsIHksXG4gICAgICAgICAgJ1wiIHdpZHRoPVwiJywgdGhpcy53aWR0aCwgJ1wiIGhlaWdodD1cIicsIHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICdcIiBzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKCksXG4gICAgICAgICAgJ1wiLz5cXG4nXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuZmlsbCA9IG9yaWdGaWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFpbnRGaXJzdCAhPT0gJ2ZpbGwnKSB7XG4gICAgICAgIHN2Z1N0cmluZyA9IHN2Z1N0cmluZy5jb25jYXQoc3Ryb2tlU3ZnLCBpbWFnZU1hcmt1cCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3ZnU3RyaW5nID0gc3ZnU3RyaW5nLmNvbmNhdChpbWFnZU1hcmt1cCwgc3Ryb2tlU3ZnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdmdTdHJpbmc7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc291cmNlIG9mIGFuIGltYWdlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmaWx0ZXJlZCBpbmRpY2F0ZXMgaWYgdGhlIHNyYyBpcyBuZWVkZWQgZm9yIHN2Z1xuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU291cmNlIG9mIGFuIGltYWdlXG4gICAgICovXG4gICAgZ2V0U3JjOiBmdW5jdGlvbihmaWx0ZXJlZCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBmaWx0ZXJlZCA/IHRoaXMuX2VsZW1lbnQgOiB0aGlzLl9vcmlnaW5hbEVsZW1lbnQ7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC50b0RhdGFVUkwpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC50b0RhdGFVUkwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNyY0Zyb21BdHRyaWJ1dGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LnNyYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNyYyB8fCAnJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzb3VyY2Ugb2YgYW4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFNvdXJjZSBzdHJpbmcgKFVSTClcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIGlzIGludm9rZWQgd2hlbiBpbWFnZSBoYXMgYmVlbiBsb2FkZWQgKGFuZCBhbGwgZmlsdGVycyBoYXZlIGJlZW4gYXBwbGllZClcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiB2YWx1ZSAob25lIG9mIFwiXCIsIFwiYW5vbnltb3VzXCIsIFwidXNlLWNyZWRlbnRpYWxzXCIpXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzXG4gICAgICogQHJldHVybiB7ZmFicmljLkltYWdlfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFNyYzogZnVuY3Rpb24oc3JjLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgZmFicmljLnV0aWwubG9hZEltYWdlKHNyYywgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudChpbWcsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zZXRXaWR0aEhlaWdodCgpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh0aGlzLCBpc0Vycm9yKTtcbiAgICAgIH0sIHRoaXMsIG9wdGlvbnMgJiYgb3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuSW1hZ2U6IHsgc3JjOiBcIicgKyB0aGlzLmdldFNyYygpICsgJ1wiIH0+JztcbiAgICB9LFxuXG4gICAgYXBwbHlSZXNpemVGaWx0ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLnJlc2l6ZUZpbHRlcixcbiAgICAgICAgICBtaW5pbXVtU2NhbGUgPSB0aGlzLm1pbmltdW1TY2FsZVRyaWdnZXIsXG4gICAgICAgICAgb2JqZWN0U2NhbGUgPSB0aGlzLmdldFRvdGFsT2JqZWN0U2NhbGluZygpLFxuICAgICAgICAgIHNjYWxlWCA9IG9iamVjdFNjYWxlLnNjYWxlWCxcbiAgICAgICAgICBzY2FsZVkgPSBvYmplY3RTY2FsZS5zY2FsZVksXG4gICAgICAgICAgZWxlbWVudFRvRmlsdGVyID0gdGhpcy5fZmlsdGVyZWRFbCB8fCB0aGlzLl9vcmlnaW5hbEVsZW1lbnQ7XG4gICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICB0aGlzLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZmlsdGVyIHx8IChzY2FsZVggPiBtaW5pbXVtU2NhbGUgJiYgc2NhbGVZID4gbWluaW11bVNjYWxlKSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFRvRmlsdGVyO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IDE7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdZID0gMTtcbiAgICAgICAgdGhpcy5fbGFzdFNjYWxlWCA9IHNjYWxlWDtcbiAgICAgICAgdGhpcy5fbGFzdFNjYWxlWSA9IHNjYWxlWTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFmYWJyaWMuZmlsdGVyQmFja2VuZCkge1xuICAgICAgICBmYWJyaWMuZmlsdGVyQmFja2VuZCA9IGZhYnJpYy5pbml0RmlsdGVyQmFja2VuZCgpO1xuICAgICAgfVxuICAgICAgdmFyIGNhbnZhc0VsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLFxuICAgICAgICAgIGNhY2hlS2V5ID0gdGhpcy5fZmlsdGVyZWRFbCA/ICh0aGlzLmNhY2hlS2V5ICsgJ19maWx0ZXJlZCcpIDogdGhpcy5jYWNoZUtleSxcbiAgICAgICAgICBzb3VyY2VXaWR0aCA9IGVsZW1lbnRUb0ZpbHRlci53aWR0aCwgc291cmNlSGVpZ2h0ID0gZWxlbWVudFRvRmlsdGVyLmhlaWdodDtcbiAgICAgIGNhbnZhc0VsLndpZHRoID0gc291cmNlV2lkdGg7XG4gICAgICBjYW52YXNFbC5oZWlnaHQgPSBzb3VyY2VIZWlnaHQ7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gY2FudmFzRWw7XG4gICAgICB0aGlzLl9sYXN0U2NhbGVYID0gZmlsdGVyLnNjYWxlWCA9IHNjYWxlWDtcbiAgICAgIHRoaXMuX2xhc3RTY2FsZVkgPSBmaWx0ZXIuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQuYXBwbHlGaWx0ZXJzKFxuICAgICAgICBbZmlsdGVyXSwgZWxlbWVudFRvRmlsdGVyLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LCB0aGlzLl9lbGVtZW50LCBjYWNoZUtleSk7XG4gICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IGNhbnZhc0VsLndpZHRoIC8gdGhpcy5fb3JpZ2luYWxFbGVtZW50LndpZHRoO1xuICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1kgPSBjYW52YXNFbC5oZWlnaHQgLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlcnMgYXNzaWduZWQgdG8gdGhpcyBpbWFnZSAoZnJvbSBcImZpbHRlcnNcIiBhcnJheSkgb3IgZnJvbSBmaWx0ZXIgcGFyYW1cbiAgICAgKiBAbWV0aG9kIGFwcGx5RmlsdGVyc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgdG8gYmUgYXBwbGllZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yUmVzaXppbmcgc3BlY2lmeSBpZiB0aGUgZmlsdGVyIG9wZXJhdGlvbiBpcyBhIHJlc2l6ZSBvcGVyYXRpb25cbiAgICAgKiBAcmV0dXJuIHt0aGlzQXJnfSByZXR1cm4gdGhlIGZhYnJpYy5JbWFnZSBvYmplY3RcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzKSB7XG5cbiAgICAgIGZpbHRlcnMgPSBmaWx0ZXJzIHx8IHRoaXMuZmlsdGVycyB8fCBbXTtcbiAgICAgIGZpbHRlcnMgPSBmaWx0ZXJzLmZpbHRlcihmdW5jdGlvbihmaWx0ZXIpIHsgcmV0dXJuIGZpbHRlciAmJiAhZmlsdGVyLmlzTmV1dHJhbFN0YXRlKCk7IH0pO1xuICAgICAgdGhpcy5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG5cbiAgICAgIC8vIG5lZWRzIHRvIGNsZWFyIG91dCBvciBXRUJHTCB3aWxsIG5vdCByZXNpemUgY29ycmVjdGx5XG4gICAgICB0aGlzLnJlbW92ZVRleHR1cmUodGhpcy5jYWNoZUtleSArICdfZmlsdGVyZWQnKTtcblxuICAgICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSB0aGlzLl9vcmlnaW5hbEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2ZpbHRlcmVkRWwgPSBudWxsO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IDE7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdZID0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbWdFbGVtZW50ID0gdGhpcy5fb3JpZ2luYWxFbGVtZW50LFxuICAgICAgICAgIHNvdXJjZVdpZHRoID0gaW1nRWxlbWVudC5uYXR1cmFsV2lkdGggfHwgaW1nRWxlbWVudC53aWR0aCxcbiAgICAgICAgICBzb3VyY2VIZWlnaHQgPSBpbWdFbGVtZW50Lm5hdHVyYWxIZWlnaHQgfHwgaW1nRWxlbWVudC5oZWlnaHQ7XG5cbiAgICAgIGlmICh0aGlzLl9lbGVtZW50ID09PSB0aGlzLl9vcmlnaW5hbEVsZW1lbnQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgaXMgdGhlIHNhbWUgd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgZWxlbWVudFxuICAgICAgICB2YXIgY2FudmFzRWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAgIGNhbnZhc0VsLndpZHRoID0gc291cmNlV2lkdGg7XG4gICAgICAgIGNhbnZhc0VsLmhlaWdodCA9IHNvdXJjZUhlaWdodDtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGNhbnZhc0VsO1xuICAgICAgICB0aGlzLl9maWx0ZXJlZEVsID0gY2FudmFzRWw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gY2xlYXIgdGhlIGV4aXN0aW5nIGVsZW1lbnQgdG8gZ2V0IG5ldyBmaWx0ZXIgZGF0YVxuICAgICAgICAvLyBhbHNvIGRlcmVmZXJlbmNlIHRoZSBldmVudHVhbCByZXNpemVkIF9lbGVtZW50XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSB0aGlzLl9maWx0ZXJlZEVsO1xuICAgICAgICB0aGlzLl9maWx0ZXJlZEVsLmdldENvbnRleHQoJzJkJykuY2xlYXJSZWN0KDAsIDAsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgICAgICAvLyB3ZSBhbHNvIG5lZWQgdG8gcmVzaXplIGFnYWluIGF0IG5leHQgcmVuZGVyQWxsLCBzbyByZW1vdmUgc2F2ZWQgX2xhc3RTY2FsZVgvWVxuICAgICAgICB0aGlzLl9sYXN0U2NhbGVYID0gMTtcbiAgICAgICAgdGhpcy5fbGFzdFNjYWxlWSA9IDE7XG4gICAgICB9XG4gICAgICBpZiAoIWZhYnJpYy5maWx0ZXJCYWNrZW5kKSB7XG4gICAgICAgIGZhYnJpYy5maWx0ZXJCYWNrZW5kID0gZmFicmljLmluaXRGaWx0ZXJCYWNrZW5kKCk7XG4gICAgICB9XG4gICAgICBmYWJyaWMuZmlsdGVyQmFja2VuZC5hcHBseUZpbHRlcnMoXG4gICAgICAgIGZpbHRlcnMsIHRoaXMuX29yaWdpbmFsRWxlbWVudCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGhpcy5fZWxlbWVudCwgdGhpcy5jYWNoZUtleSk7XG4gICAgICBpZiAodGhpcy5fb3JpZ2luYWxFbGVtZW50LndpZHRoICE9PSB0aGlzLl9lbGVtZW50LndpZHRoIHx8XG4gICAgICAgIHRoaXMuX29yaWdpbmFsRWxlbWVudC5oZWlnaHQgIT09IHRoaXMuX2VsZW1lbnQuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdYID0gdGhpcy5fZWxlbWVudC53aWR0aCAvIHRoaXMuX29yaWdpbmFsRWxlbWVudC53aWR0aDtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1kgPSB0aGlzLl9lbGVtZW50LmhlaWdodCAvIHRoaXMuX29yaWdpbmFsRWxlbWVudC5oZWlnaHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBmYWJyaWMudXRpbC5zZXRJbWFnZVNtb290aGluZyhjdHgsIHRoaXMuaW1hZ2VTbW9vdGhpbmcpO1xuICAgICAgaWYgKHRoaXMuaXNNb3ZpbmcgIT09IHRydWUgJiYgdGhpcy5yZXNpemVGaWx0ZXIgJiYgdGhpcy5fbmVlZHNSZXNpemUoKSkge1xuICAgICAgICB0aGlzLmFwcGx5UmVzaXplRmlsdGVycygpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3Ryb2tlKGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFpbnQgdGhlIGNhY2hlZCBjb3B5IG9mIHRoZSBvYmplY3Qgb24gdGhlIHRhcmdldCBjb250ZXh0LlxuICAgICAqIGl0IHdpbGwgc2V0IHRoZSBpbWFnZVNtb290aGluZyBmb3IgdGhlIGRyYXcgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIGRyYXdDYWNoZU9uQ2FudmFzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGZhYnJpYy51dGlsLnNldEltYWdlU21vb3RoaW5nKGN0eCwgdGhpcy5pbWFnZVNtb290aGluZyk7XG4gICAgICBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5kcmF3Q2FjaGVPbkNhbnZhcy5jYWxsKHRoaXMsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZSBpZiB0aGUgb2JqZWN0IHNob3VsZCBjYWNoZSBvciBub3QuIENyZWF0ZSBpdHMgb3duIGNhY2hlIGxldmVsXG4gICAgICogbmVlZHNJdHNPd25DYWNoZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBvYmplY3QgZHJhd2luZyBtZXRob2QgcmVxdWlyZXNcbiAgICAgKiBhIGNhY2hlIHN0ZXAuIE5vbmUgb2YgdGhlIGZhYnJpYyBjbGFzc2VzIHJlcXVpcmVzIGl0LlxuICAgICAqIEdlbmVyYWxseSB5b3UgZG8gbm90IGNhY2hlIG9iamVjdHMgaW4gZ3JvdXBzIGJlY2F1c2UgdGhlIGdyb3VwIG91dHNpZGUgaXMgY2FjaGVkLlxuICAgICAqIFRoaXMgaXMgdGhlIHNwZWNpYWwgaW1hZ2UgdmVyc2lvbiB3aGVyZSB3ZSB3b3VsZCBsaWtlIHRvIGF2b2lkIGNhY2hpbmcgd2hlcmUgcG9zc2libGUuXG4gICAgICogRXNzZW50aWFsbHkgaW1hZ2VzIGRvIG5vdCBiZW5lZml0IGZyb20gY2FjaGluZy4gVGhleSBtYXkgcmVxdWlyZSBjYWNoaW5nLCBhbmQgaW4gdGhhdFxuICAgICAqIGNhc2Ugd2UgZG8gaXQuIEFsc28gY2FjaGluZyBhbiBpbWFnZSB1c3VhbGx5IGVuZHMgaW4gYSBsb3NzIG9mIGRldGFpbHMuXG4gICAgICogQSBmdWxsIHBlcmZvcm1hbmNlIGF1ZGl0IHNob3VsZCBiZSBkb25lLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmVlZHNJdHNPd25DYWNoZSgpO1xuICAgIH0sXG5cbiAgICBfcmVuZGVyRmlsbDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgZWxlbWVudFRvRHJhdyA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgICBpZiAoIWVsZW1lbnRUb0RyYXcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNjYWxlWCA9IHRoaXMuX2ZpbHRlclNjYWxpbmdYLCBzY2FsZVkgPSB0aGlzLl9maWx0ZXJTY2FsaW5nWSxcbiAgICAgICAgICB3ID0gdGhpcy53aWR0aCwgaCA9IHRoaXMuaGVpZ2h0LCBtaW4gPSBNYXRoLm1pbiwgbWF4ID0gTWF0aC5tYXgsXG4gICAgICAgICAgLy8gY3JvcCB2YWx1ZXMgY2Fubm90IGJlIGxlc3NlciB0aGFuIDAuXG4gICAgICAgICAgY3JvcFggPSBtYXgodGhpcy5jcm9wWCwgMCksIGNyb3BZID0gbWF4KHRoaXMuY3JvcFksIDApLFxuICAgICAgICAgIGVsV2lkdGggPSBlbGVtZW50VG9EcmF3Lm5hdHVyYWxXaWR0aCB8fCBlbGVtZW50VG9EcmF3LndpZHRoLFxuICAgICAgICAgIGVsSGVpZ2h0ID0gZWxlbWVudFRvRHJhdy5uYXR1cmFsSGVpZ2h0IHx8IGVsZW1lbnRUb0RyYXcuaGVpZ2h0LFxuICAgICAgICAgIHNYID0gY3JvcFggKiBzY2FsZVgsXG4gICAgICAgICAgc1kgPSBjcm9wWSAqIHNjYWxlWSxcbiAgICAgICAgICAvLyB0aGUgd2lkdGggaGVpZ2h0IGNhbm5vdCBleGNlZWQgZWxlbWVudCB3aWR0aC9oZWlnaHQsIHN0YXJ0aW5nIGZyb20gdGhlIGNyb3Agb2Zmc2V0LlxuICAgICAgICAgIHNXID0gbWluKHcgKiBzY2FsZVgsIGVsV2lkdGggLSBzWCksXG4gICAgICAgICAgc0ggPSBtaW4oaCAqIHNjYWxlWSwgZWxIZWlnaHQgLSBzWSksXG4gICAgICAgICAgeCA9IC13IC8gMiwgeSA9IC1oIC8gMixcbiAgICAgICAgICBtYXhEZXN0VyA9IG1pbih3LCBlbFdpZHRoIC8gc2NhbGVYIC0gY3JvcFgpLFxuICAgICAgICAgIG1heERlc3RIID0gbWluKGgsIGVsSGVpZ2h0IC8gc2NhbGVZIC0gY3JvcFkpO1xuXG4gICAgICBlbGVtZW50VG9EcmF3ICYmIGN0eC5kcmF3SW1hZ2UoZWxlbWVudFRvRHJhdywgc1gsIHNZLCBzVywgc0gsIHgsIHksIG1heERlc3RXLCBtYXhEZXN0SCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG5lZWRlZCB0byBjaGVjayBpZiBpbWFnZSBuZWVkcyByZXNpemVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9uZWVkc1Jlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLmdldFRvdGFsT2JqZWN0U2NhbGluZygpO1xuICAgICAgcmV0dXJuIChzY2FsZS5zY2FsZVggIT09IHRoaXMuX2xhc3RTY2FsZVggfHwgc2NhbGUuc2NhbGVZICE9PSB0aGlzLl9sYXN0U2NhbGVZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzZXRXaWR0aEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldCh0aGlzLmdldE9yaWdpbmFsU2l6ZSgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIEltYWdlIGNsYXNzJ3MgaW5pdGlhbGl6YXRpb24gbWV0aG9kLiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5XG4gICAgICogY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxTdHJpbmd9IGVsZW1lbnQgVGhlIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2V0RWxlbWVudChmYWJyaWMudXRpbC5nZXRCeUlkKGVsZW1lbnQpLCBvcHRpb25zKTtcbiAgICAgIGZhYnJpYy51dGlsLmFkZENsYXNzKHRoaXMuZ2V0RWxlbWVudCgpLCBmYWJyaWMuSW1hZ2UuQ1NTX0NBTlZBUyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9pbml0Q29uZmlnOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHRoaXMuX3NldFdpZHRoSGVpZ2h0KG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcnMgdG8gYmUgaW5pdGlhbGl6ZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbGwgZmFicmljLkltYWdlLmZpbHRlcnMgaW5zdGFuY2VzIGFyZSBjcmVhdGVkXG4gICAgICovXG4gICAgX2luaXRGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGZpbHRlcnMgJiYgZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMoZmlsdGVycywgZnVuY3Rpb24oZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZE9iamVjdHMpO1xuICAgICAgICB9LCAnZmFicmljLkltYWdlLmZpbHRlcnMnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFNldCB0aGUgd2lkdGggYW5kIHRoZSBoZWlnaHQgb2YgdGhlIGltYWdlIG9iamVjdCwgdXNpbmcgdGhlIGVsZW1lbnQgb3IgdGhlXG4gICAgICogb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCB3aXRoIHdpZHRoL2hlaWdodCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgX3NldFdpZHRoSGVpZ2h0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHZhciBlbCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgICAgdGhpcy53aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgZWwubmF0dXJhbFdpZHRoIHx8IGVsLndpZHRoIHx8IDA7XG4gICAgICB0aGlzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IGVsLm5hdHVyYWxIZWlnaHQgfHwgZWwuaGVpZ2h0IHx8IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBvZmZzZXQgZm9yIGNlbnRlciBhbmQgc2NhbGUgZmFjdG9yIGZvciB0aGUgaW1hZ2UgaW4gb3JkZXIgdG8gcmVzcGVjdFxuICAgICAqIHRoZSBwcmVzZXJ2ZUFzcGVjdFJhdGlvIGF0dHJpYnV0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcEFSID0gZmFicmljLnV0aWwucGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlKHRoaXMucHJlc2VydmVBc3BlY3RSYXRpbyB8fCAnJyksXG4gICAgICAgICAgcldpZHRoID0gdGhpcy5fZWxlbWVudC53aWR0aCwgckhlaWdodCA9IHRoaXMuX2VsZW1lbnQuaGVpZ2h0LFxuICAgICAgICAgIHNjYWxlWCA9IDEsIHNjYWxlWSA9IDEsIG9mZnNldExlZnQgPSAwLCBvZmZzZXRUb3AgPSAwLCBjcm9wWCA9IDAsIGNyb3BZID0gMCxcbiAgICAgICAgICBvZmZzZXQsIHBXaWR0aCA9IHRoaXMud2lkdGgsIHBIZWlnaHQgPSB0aGlzLmhlaWdodCwgcGFyc2VkQXR0cmlidXRlcyA9IHsgd2lkdGg6IHBXaWR0aCwgaGVpZ2h0OiBwSGVpZ2h0IH07XG4gICAgICBpZiAocEFSICYmIChwQVIuYWxpZ25YICE9PSAnbm9uZScgfHwgcEFSLmFsaWduWSAhPT0gJ25vbmUnKSkge1xuICAgICAgICBpZiAocEFSLm1lZXRPclNsaWNlID09PSAnbWVldCcpIHtcbiAgICAgICAgICBzY2FsZVggPSBzY2FsZVkgPSBmYWJyaWMudXRpbC5maW5kU2NhbGVUb0ZpdCh0aGlzLl9lbGVtZW50LCBwYXJzZWRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICBvZmZzZXQgPSAocFdpZHRoIC0gcldpZHRoICogc2NhbGVYKSAvIDI7XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblggPT09ICdNaW4nKSB7XG4gICAgICAgICAgICBvZmZzZXRMZWZ0ID0gLW9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblggPT09ICdNYXgnKSB7XG4gICAgICAgICAgICBvZmZzZXRMZWZ0ID0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXQgPSAocEhlaWdodCAtIHJIZWlnaHQgKiBzY2FsZVkpIC8gMjtcbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01pbicpIHtcbiAgICAgICAgICAgIG9mZnNldFRvcCA9IC1vZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwQVIuYWxpZ25ZID09PSAnTWF4Jykge1xuICAgICAgICAgICAgb2Zmc2V0VG9wID0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocEFSLm1lZXRPclNsaWNlID09PSAnc2xpY2UnKSB7XG4gICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gZmFicmljLnV0aWwuZmluZFNjYWxlVG9Db3Zlcih0aGlzLl9lbGVtZW50LCBwYXJzZWRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICBvZmZzZXQgPSByV2lkdGggLSBwV2lkdGggLyBzY2FsZVg7XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblggPT09ICdNaWQnKSB7XG4gICAgICAgICAgICBjcm9wWCA9IG9mZnNldCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWF4Jykge1xuICAgICAgICAgICAgY3JvcFggPSBvZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9mZnNldCA9IHJIZWlnaHQgLSBwSGVpZ2h0IC8gc2NhbGVZO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25ZID09PSAnTWlkJykge1xuICAgICAgICAgICAgY3JvcFkgPSBvZmZzZXQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIGNyb3BZID0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByV2lkdGggPSBwV2lkdGggLyBzY2FsZVg7XG4gICAgICAgICAgckhlaWdodCA9IHBIZWlnaHQgLyBzY2FsZVk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzY2FsZVggPSBwV2lkdGggLyByV2lkdGg7XG4gICAgICAgIHNjYWxlWSA9IHBIZWlnaHQgLyBySGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHJXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBySGVpZ2h0LFxuICAgICAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiBzY2FsZVksXG4gICAgICAgIG9mZnNldExlZnQ6IG9mZnNldExlZnQsXG4gICAgICAgIG9mZnNldFRvcDogb2Zmc2V0VG9wLFxuICAgICAgICBjcm9wWDogY3JvcFgsXG4gICAgICAgIGNyb3BZOiBjcm9wWVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IENTUyBjbGFzcyBuYW1lIGZvciBjYW52YXNcbiAgICogQHN0YXRpY1xuICAgKiBAdHlwZSBTdHJpbmdcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5DU1NfQ0FOVkFTID0gJ2NhbnZhcy1pbWcnO1xuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgZ2V0U3JjXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5wcm90b3R5cGUuZ2V0U3ZnU3JjID0gZmFicmljLkltYWdlLnByb3RvdHlwZS5nZXRTcmM7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZmFicmljLkltYWdlIGZyb20gaXRzIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGltYWdlIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24oX29iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgb2JqZWN0ID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKF9vYmplY3QpO1xuICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZShvYmplY3Quc3JjLCBmdW5jdGlvbihpbWcsIGlzRXJyb3IpIHtcbiAgICAgIGlmIChpc0Vycm9yKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLl9pbml0RmlsdGVycy5jYWxsKG9iamVjdCwgb2JqZWN0LmZpbHRlcnMsIGZ1bmN0aW9uKGZpbHRlcnMpIHtcbiAgICAgICAgb2JqZWN0LmZpbHRlcnMgPSBmaWx0ZXJzIHx8IFtdO1xuICAgICAgICBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLl9pbml0RmlsdGVycy5jYWxsKG9iamVjdCwgW29iamVjdC5yZXNpemVGaWx0ZXJdLCBmdW5jdGlvbihyZXNpemVGaWx0ZXJzKSB7XG4gICAgICAgICAgb2JqZWN0LnJlc2l6ZUZpbHRlciA9IHJlc2l6ZUZpbHRlcnNbMF07XG4gICAgICAgICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdEVubGl2YWJsZXMob2JqZWN0LCBvYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBmYWJyaWMuSW1hZ2UoaW1nLCBvYmplY3QpO1xuICAgICAgICAgICAgY2FsbGJhY2soaW1hZ2UsIGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LCBudWxsLCBvYmplY3QuY3Jvc3NPcmlnaW4pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBmcm9tIGFuIFVSTCBzdHJpbmdcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCB0byBjcmVhdGUgYW4gaW1hZ2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGNyZWF0ZWQgKG5ld2x5IGNyZWF0ZWQgaW1hZ2UgaXMgcGFzc2VkIGFzIGEgZmlyc3QgYXJndW1lbnQpLiBTZWNvbmQgYXJndW1lbnQgaXMgYSBib29sZWFuIGluZGljYXRpbmcgaWYgYW4gZXJyb3Igb2NjdXJyZWQgb3Igbm90LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2ltZ09wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZnJvbVVSTCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2ssIGltZ09wdGlvbnMpIHtcbiAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2UodXJsLCBmdW5jdGlvbihpbWcsIGlzRXJyb3IpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5ldyBmYWJyaWMuSW1hZ2UoaW1nLCBpbWdPcHRpb25zKSwgaXNFcnJvcik7XG4gICAgfSwgbnVsbCwgaW1nT3B0aW9ucyAmJiBpbWdPcHRpb25zLmNyb3NzT3JpZ2luKTtcbiAgfTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5JbWFnZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3N0cnVjdC5odG1sI0ltYWdlRWxlbWVudH1cbiAgICovXG4gIGZhYnJpYy5JbWFnZS5BVFRSSUJVVEVfTkFNRVMgPVxuICAgIGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoXG4gICAgICAneCB5IHdpZHRoIGhlaWdodCBwcmVzZXJ2ZUFzcGVjdFJhdGlvIHhsaW5rOmhyZWYgY3Jvc3NPcmlnaW4gaW1hZ2UtcmVuZGVyaW5nJy5zcGxpdCgnICcpXG4gICAgKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkltYWdlfSBpbnN0YW5jZSBmcm9tIGFuIFNWRyBlbGVtZW50XG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gZmFicmljLkltYWdlIG9iamVjdCBpcyBjcmVhdGVkXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuSW1hZ2UuQVRUUklCVVRFX05BTUVTKTtcbiAgICBmYWJyaWMuSW1hZ2UuZnJvbVVSTChwYXJzZWRBdHRyaWJ1dGVzWyd4bGluazpocmVmJ10sIGNhbGxiYWNrLFxuICAgICAgZXh0ZW5kKChvcHRpb25zID8gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9wdGlvbnMpIDogeyB9KSwgcGFyc2VkQXR0cmlidXRlcykpO1xuICB9O1xuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGUgdmFsdWVcbiAgICovXG4gIF9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFuZ2xlID0gdGhpcy5hbmdsZSAlIDM2MDtcbiAgICBpZiAoYW5nbGUgPiAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgoYW5nbGUgLSAxKSAvIDkwKSAqIDkwO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5yb3VuZChhbmdsZSAvIDkwKSAqIDkwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTdHJhaWdodGVucyBhbiBvYmplY3QgKHJvdGF0aW5nIGl0IGZyb20gY3VycmVudCBhbmdsZSB0byBvbmUgb2YgMCwgOTAsIDE4MCwgMjcwLCBldGMuIGRlcGVuZGluZyBvbiB3aGljaCBpcyBjbG9zZXIpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc3RyYWlnaHRlbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRlKHRoaXMuX2dldEFuZ2xlVmFsdWVGb3JTdHJhaWdodGVuKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIHtAbGluayBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdHJhaWdodGVufSBidXQgd2l0aCBhbmltYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGNhbGxiYWNrcyBPYmplY3Qgd2l0aCBjYWxsYmFjayBmdW5jdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNvbXBsZXRlXSBJbnZva2VkIG9uIGNvbXBsZXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNoYW5nZV0gSW52b2tlZCBvbiBldmVyeSBzdGVwIG9mIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqL1xuICBmeFN0cmFpZ2h0ZW46IGZ1bmN0aW9uKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgc3RhcnRWYWx1ZTogdGhpcy5nZXQoJ2FuZ2xlJyksXG4gICAgICBlbmRWYWx1ZTogdGhpcy5fZ2V0QW5nbGVWYWx1ZUZvclN0cmFpZ2h0ZW4oKSxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLkZYX0RVUkFUSU9OLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIF90aGlzLnJvdGF0ZSh2YWx1ZSk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLnNldENvb3JkcygpO1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59KTtcblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIFN0cmFpZ2h0ZW5zIG9iamVjdCwgdGhlbiByZXJlbmRlcnMgY2FudmFzXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzdHJhaWdodGVuXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc3RyYWlnaHRlbk9iamVjdDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIG9iamVjdC5zdHJhaWdodGVuKCk7XG4gICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMge0BsaW5rIGZhYnJpYy5DYW52YXMucHJvdG90eXBlLnN0cmFpZ2h0ZW5PYmplY3R9LCBidXQgYW5pbWF0ZWRcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHN0cmFpZ2h0ZW5cbiAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgKi9cbiAgZnhTdHJhaWdodGVuT2JqZWN0OiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdC5meFN0cmFpZ2h0ZW4oe1xuICAgICAgb25DaGFuZ2U6IHRoaXMucmVxdWVzdFJlbmRlckFsbEJvdW5kXG4gICAgfSk7XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFRlc3RzIGlmIHdlYmdsIHN1cHBvcnRzIGNlcnRhaW4gcHJlY2lzaW9uXG4gICAqIEBwYXJhbSB7V2ViR0x9IENhbnZhcyBXZWJHTCBjb250ZXh0IHRvIHRlc3Qgb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IFByZWNpc2lvbiB0byB0ZXN0IGNhbiBiZSBhbnkgb2YgZm9sbG93aW5nOiAnbG93cCcsICdtZWRpdW1wJywgJ2hpZ2hwJ1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgdXNlcidzIGJyb3dzZXIgV2ViR0wgc3VwcG9ydHMgZ2l2ZW4gcHJlY2lzaW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gdGVzdFByZWNpc2lvbihnbCwgcHJlY2lzaW9uKXtcbiAgICB2YXIgZnJhZ21lbnRTb3VyY2UgPSAncHJlY2lzaW9uICcgKyBwcmVjaXNpb24gKyAnIGZsb2F0O1xcbnZvaWQgbWFpbigpe30nO1xuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgIGdsLnNoYWRlclNvdXJjZShmcmFnbWVudFNoYWRlciwgZnJhZ21lbnRTb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdtZW50U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGUgd2hldGhlciB0aGlzIGZpbHRlcmluZyBiYWNrZW5kIGlzIHN1cHBvcnRlZCBieSB0aGUgdXNlcidzIGJyb3dzZXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aWxlU2l6ZSBjaGVjayBpZiB0aGUgdGlsZVNpemUgaXMgc3VwcG9ydGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSB1c2VyJ3MgYnJvd3NlciBzdXBwb3J0cyBXZWJHTC5cbiAgICovXG4gIGZhYnJpYy5pc1dlYmdsU3VwcG9ydGVkID0gZnVuY3Rpb24odGlsZVNpemUpIHtcbiAgICBpZiAoZmFicmljLmlzTGlrZWx5Tm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aWxlU2l6ZSA9IHRpbGVTaXplIHx8IGZhYnJpYy5XZWJnbEZpbHRlckJhY2tlbmQucHJvdG90eXBlLnRpbGVTaXplO1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnKSB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJyk7XG4gICAgdmFyIGlzU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgaWYgKGdsKSB7XG4gICAgICBmYWJyaWMubWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSk7XG4gICAgICBpc1N1cHBvcnRlZCA9IGZhYnJpYy5tYXhUZXh0dXJlU2l6ZSA+PSB0aWxlU2l6ZTtcbiAgICAgIHZhciBwcmVjaXNpb25zID0gWydoaWdocCcsICdtZWRpdW1wJywgJ2xvd3AnXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKXtcbiAgICAgICAgaWYgKHRlc3RQcmVjaXNpb24oZ2wsIHByZWNpc2lvbnNbaV0pKXtcbiAgICAgICAgICBmYWJyaWMud2ViR2xQcmVjaXNpb24gPSBwcmVjaXNpb25zW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmlzU3VwcG9ydGVkID0gaXNTdXBwb3J0ZWQ7XG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICB9O1xuXG4gIGZhYnJpYy5XZWJnbEZpbHRlckJhY2tlbmQgPSBXZWJnbEZpbHRlckJhY2tlbmQ7XG5cbiAgLyoqXG4gICAqIFdlYkdMIGZpbHRlciBiYWNrZW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gV2ViZ2xGaWx0ZXJCYWNrZW5kKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnRpbGVTaXplKSB7XG4gICAgICB0aGlzLnRpbGVTaXplID0gb3B0aW9ucy50aWxlU2l6ZTtcbiAgICB9XG4gICAgdGhpcy5zZXR1cEdMQ29udGV4dCh0aGlzLnRpbGVTaXplLCB0aGlzLnRpbGVTaXplKTtcbiAgICB0aGlzLmNhcHR1cmVHUFVJbmZvKCk7XG4gIH07XG5cbiAgV2ViZ2xGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLldlYmdsRmlsdGVyQmFja2VuZC5wcm90b3R5cGUgKi8ge1xuXG4gICAgdGlsZVNpemU6IDIwNDgsXG5cbiAgICAvKipcbiAgICAgKiBFeHBlcmltZW50YWwuIFRoaXMgb2JqZWN0IGlzIGEgc29ydCBvZiByZXBvc2l0b3J5IG9mIGhlbHAgbGF5ZXJzIHVzZWQgdG8gYXZvaWRcbiAgICAgKiBvZiByZWNyZWF0aW5nIHRoZW0gZHVyaW5nIGZyZXF1ZW50IGZpbHRlcmluZy4gSWYgeW91IGFyZSBwcmV2aWV3aW5nIGEgZmlsdGVyIHdpdGhcbiAgICAgKiBhIHNsaWRlciB5b3UgcHJvYmFibHkgZG8gbm90IHdhbnQgdG8gY3JlYXRlIGhlbHAgbGF5ZXJzIGV2ZXJ5IGZpbHRlciBzdGVwLlxuICAgICAqIGluIHRoaXMgb2JqZWN0IHRoZXJlIHdpbGwgYmUgYXBwZW5kZWQgc29tZSBjYW52YXNlcywgY3JlYXRlZCBvbmNlLCByZXNpemVkIHNvbWV0aW1lc1xuICAgICAqIGNsZWFyZWQgbmV2ZXIuIENsZWFyaW5nIGlzIGxlZnQgdG8gdGhlIGRldmVsb3Blci5cbiAgICAgKiovXG4gICAgcmVzb3VyY2VzOiB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0dXAgYSBXZWJHTCBjb250ZXh0IHN1aXRhYmxlIGZvciBmaWx0ZXJpbmcsIGFuZCBiaW5kIGFueSBuZWVkZWQgZXZlbnQgaGFuZGxlcnMuXG4gICAgICovXG4gICAgc2V0dXBHTENvbnRleHQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5jcmVhdGVXZWJHTENhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgdGhpcy5hUG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxLCAxLCAwLCAxLCAxXSk7XG4gICAgICB0aGlzLmNob29zZUZhc3Rlc3RDb3B5R0xUbzJETWV0aG9kKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQaWNrIGEgbWV0aG9kIHRvIGNvcHkgZGF0YSBmcm9tIEdMIGNvbnRleHQgdG8gMmQgY2FudmFzLiAgSW4gc29tZSBicm93c2VycyB1c2luZ1xuICAgICAqIHB1dEltYWdlRGF0YSBpcyBmYXN0ZXIgdGhhbiBkcmF3SW1hZ2UgZm9yIHRoYXQgc3BlY2lmaWMgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGNob29zZUZhc3Rlc3RDb3B5R0xUbzJETWV0aG9kOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgY2FuTWVhc3VyZVBlcmYgPSB0eXBlb2Ygd2luZG93LnBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJywgY2FuVXNlSW1hZ2VEYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEltYWdlRGF0YSgxLCAxKTtcbiAgICAgICAgY2FuVXNlSW1hZ2VEYXRhID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNhblVzZUltYWdlRGF0YSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICB2YXIgY2FuVXNlQXJyYXlCdWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICB2YXIgY2FuVXNlVWludDhDbGFtcGVkID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJztcblxuICAgICAgaWYgKCEoY2FuTWVhc3VyZVBlcmYgJiYgY2FuVXNlSW1hZ2VEYXRhICYmIGNhblVzZUFycmF5QnVmZmVyICYmIGNhblVzZVVpbnQ4Q2xhbXBlZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0Q2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICB2YXIgaW1hZ2VCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgIGlmIChmYWJyaWMuZm9yY2VHTFB1dEltYWdlRGF0YSkge1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyID0gaW1hZ2VCdWZmZXI7XG4gICAgICAgIHRoaXMuY29weUdMVG8yRCA9IGNvcHlHTFRvMkRQdXRJbWFnZURhdGE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB0ZXN0Q29udGV4dCA9IHtcbiAgICAgICAgaW1hZ2VCdWZmZXI6IGltYWdlQnVmZmVyLFxuICAgICAgICBkZXN0aW5hdGlvbldpZHRoOiB3aWR0aCxcbiAgICAgICAgZGVzdGluYXRpb25IZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgdGFyZ2V0Q2FudmFzOiB0YXJnZXRDYW52YXNcbiAgICAgIH07XG4gICAgICB2YXIgc3RhcnRUaW1lLCBkcmF3SW1hZ2VUaW1lLCBwdXRJbWFnZURhdGFUaW1lO1xuICAgICAgdGFyZ2V0Q2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICB0YXJnZXRDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICBzdGFydFRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb3B5R0xUbzJERHJhd0ltYWdlLmNhbGwodGVzdENvbnRleHQsIHRoaXMuZ2wsIHRlc3RDb250ZXh0KTtcbiAgICAgIGRyYXdJbWFnZVRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgIHN0YXJ0VGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvcHlHTFRvMkRQdXRJbWFnZURhdGEuY2FsbCh0ZXN0Q29udGV4dCwgdGhpcy5nbCwgdGVzdENvbnRleHQpO1xuICAgICAgcHV0SW1hZ2VEYXRhVGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgaWYgKGRyYXdJbWFnZVRpbWUgPiBwdXRJbWFnZURhdGFUaW1lKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VCdWZmZXIgPSBpbWFnZUJ1ZmZlcjtcbiAgICAgICAgdGhpcy5jb3B5R0xUbzJEID0gY29weUdMVG8yRFB1dEltYWdlRGF0YTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmNvcHlHTFRvMkQgPSBjb3B5R0xUbzJERHJhd0ltYWdlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjYW52YXMgZWxlbWVudCBhbmQgYXNzb2NpYXRlZCBXZWJHTCBjb250ZXh0IGFuZCBhdHRhY2hlcyB0aGVtIGFzXG4gICAgICogY2xhc3MgcHJvcGVydGllcyB0byB0aGUgR0xGaWx0ZXJCYWNrZW5kIGNsYXNzLlxuICAgICAqL1xuICAgIGNyZWF0ZVdlYkdMQ2FudmFzOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgY2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdmFyIGdsT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICAgICAgICAgIGRlcHRoOiBmYWxzZSxcbiAgICAgICAgICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgICAgICAgICAgYW50aWFsaWFzOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBnbE9wdGlvbnMpO1xuICAgICAgaWYgKCFnbCkge1xuICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBnbE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKCFnbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgICAgLy8gdGhpcyBjYW52YXMgY2FuIGZpcmUgd2ViZ2xjb250ZXh0bG9zdCBhbmQgd2ViZ2xjb250ZXh0cmVzdG9yZWRcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5nbCA9IGdsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBhcHBseSB0aGUgcmVxdWVzdGVkIGZpbHRlcnMgdG8gdGhlIHNvdXJjZSBwcm92aWRlZCwgZHJhd2luZyB0aGUgZmlsdGVyZWQgb3V0cHV0XG4gICAgICogdG8gdGhlIHByb3ZpZGVkIHRhcmdldCBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzIFRoZSBmaWx0ZXJzIHRvIGFwcGx5LlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gc291cmNlIFRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgc291cmNlIGlucHV0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgc291cmNlIGlucHV0LlxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IHRhcmdldENhbnZhcyBUaGUgZGVzdGluYXRpb24gZm9yIGZpbHRlcmVkIG91dHB1dCB0byBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3x1bmRlZmluZWR9IGNhY2hlS2V5IEEga2V5IHVzZWQgdG8gY2FjaGUgcmVzb3VyY2VzIHJlbGF0ZWQgdG8gdGhlIHNvdXJjZS4gSWZcbiAgICAgKiBvbWl0dGVkLCBjYWNoaW5nIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgKi9cbiAgICBhcHBseUZpbHRlcnM6IGZ1bmN0aW9uKGZpbHRlcnMsIHNvdXJjZSwgd2lkdGgsIGhlaWdodCwgdGFyZ2V0Q2FudmFzLCBjYWNoZUtleSkge1xuICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgIHZhciBjYWNoZWRUZXh0dXJlO1xuICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgIGNhY2hlZFRleHR1cmUgPSB0aGlzLmdldENhY2hlZFRleHR1cmUoY2FjaGVLZXksIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICB2YXIgcGlwZWxpbmVTdGF0ZSA9IHtcbiAgICAgICAgb3JpZ2luYWxXaWR0aDogc291cmNlLndpZHRoIHx8IHNvdXJjZS5vcmlnaW5hbFdpZHRoLFxuICAgICAgICBvcmlnaW5hbEhlaWdodDogc291cmNlLmhlaWdodCB8fCBzb3VyY2Uub3JpZ2luYWxIZWlnaHQsXG4gICAgICAgIHNvdXJjZVdpZHRoOiB3aWR0aCxcbiAgICAgICAgc291cmNlSGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGRlc3RpbmF0aW9uV2lkdGg6IHdpZHRoLFxuICAgICAgICBkZXN0aW5hdGlvbkhlaWdodDogaGVpZ2h0LFxuICAgICAgICBjb250ZXh0OiBnbCxcbiAgICAgICAgc291cmNlVGV4dHVyZTogdGhpcy5jcmVhdGVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCAhY2FjaGVkVGV4dHVyZSAmJiBzb3VyY2UpLFxuICAgICAgICB0YXJnZXRUZXh0dXJlOiB0aGlzLmNyZWF0ZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQpLFxuICAgICAgICBvcmlnaW5hbFRleHR1cmU6IGNhY2hlZFRleHR1cmUgfHxcbiAgICAgICAgICB0aGlzLmNyZWF0ZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsICFjYWNoZWRUZXh0dXJlICYmIHNvdXJjZSksXG4gICAgICAgIHBhc3NlczogZmlsdGVycy5sZW5ndGgsXG4gICAgICAgIHdlYmdsOiB0cnVlLFxuICAgICAgICBhUG9zaXRpb246IHRoaXMuYVBvc2l0aW9uLFxuICAgICAgICBwcm9ncmFtQ2FjaGU6IHRoaXMucHJvZ3JhbUNhY2hlLFxuICAgICAgICBwYXNzOiAwLFxuICAgICAgICBmaWx0ZXJCYWNrZW5kOiB0aGlzLFxuICAgICAgICB0YXJnZXRDYW52YXM6IHRhcmdldENhbnZhc1xuICAgICAgfTtcbiAgICAgIHZhciB0ZW1wRmJvID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGVtcEZibyk7XG4gICAgICBmaWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oZmlsdGVyKSB7IGZpbHRlciAmJiBmaWx0ZXIuYXBwbHlUbyhwaXBlbGluZVN0YXRlKTsgfSk7XG4gICAgICByZXNpemVDYW52YXNJZk5lZWRlZChwaXBlbGluZVN0YXRlKTtcbiAgICAgIHRoaXMuY29weUdMVG8yRChnbCwgcGlwZWxpbmVTdGF0ZSk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgIGdsLmRlbGV0ZVRleHR1cmUocGlwZWxpbmVTdGF0ZS5zb3VyY2VUZXh0dXJlKTtcbiAgICAgIGdsLmRlbGV0ZVRleHR1cmUocGlwZWxpbmVTdGF0ZS50YXJnZXRUZXh0dXJlKTtcbiAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRlbXBGYm8pO1xuICAgICAgdGFyZ2V0Q2FudmFzLmdldENvbnRleHQoJzJkJykuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgcmV0dXJuIHBpcGVsaW5lU3RhdGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGFjaCBldmVudCBsaXN0ZW5lcnMsIHJlbW92ZSByZWZlcmVuY2VzLCBhbmQgY2xlYW4gdXAgY2FjaGVzLlxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFyV2ViR0xDYWNoZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2lwZSBvdXQgV2ViR0wtcmVsYXRlZCBjYWNoZXMuXG4gICAgICovXG4gICAgY2xlYXJXZWJHTENhY2hlczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnByb2dyYW1DYWNoZSA9IHt9O1xuICAgICAgdGhpcy50ZXh0dXJlQ2FjaGUgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgV2ViR0wgdGV4dHVyZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBBY2NlcHRzIHNwZWNpZmljIGRpbWVuc2lvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgdGV4dHVyZSB0byBvciBhIHNvdXJjZSBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY29udGV4dCB0byB1c2UgZm9yIGNyZWF0aW5nIHRoZSB0ZXh0dXJlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggdG8gaW5pdGlhbGl6ZSB0aGUgdGV4dHVyZSBhdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgdG8gaW5pdGlhbGl6ZSB0aGUgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHRleHR1cmVJbWFnZVNvdXJjZSBBIHNvdXJjZSBmb3IgdGhlIHRleHR1cmUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZmlsdGVyVHlwZSBnbC5ORUFSRVNUIG9yIGdsLkxJTkVBUiB1c3VhbGx5LCB3ZWJnbCBudW1lcmkgY29uc3RhbnRzXG4gICAgICogQHJldHVybnMge1dlYkdMVGV4dHVyZX1cbiAgICAgKi9cbiAgICBjcmVhdGVUZXh0dXJlOiBmdW5jdGlvbihnbCwgd2lkdGgsIGhlaWdodCwgdGV4dHVyZUltYWdlU291cmNlLCBmaWx0ZXJUeXBlKSB7XG4gICAgICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlclR5cGUgfHwgZ2wuTkVBUkVTVCk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyVHlwZSB8fCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBpZiAodGV4dHVyZUltYWdlU291cmNlKSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGV4dHVyZUltYWdlU291cmNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHdpZHRoLCBoZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbiBiZSBvcHRpb25hbGx5IHVzZWQgdG8gZ2V0IGEgdGV4dHVyZSBmcm9tIHRoZSBjYWNoZSBhcnJheVxuICAgICAqXG4gICAgICogSWYgYW4gZXhpc3RpbmcgdGV4dHVyZSBpcyBub3QgZm91bmQsIGEgbmV3IHRleHR1cmUgaXMgY3JlYXRlZCBhbmQgY2FjaGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVuaXF1ZUlkIEEgY2FjaGUga2V5IHRvIHVzZSB0byBmaW5kIGFuIGV4aXN0aW5nIHRleHR1cmUuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSB0ZXh0dXJlSW1hZ2VTb3VyY2UgQSBzb3VyY2UgdG8gdXNlIHRvIGNyZWF0ZSB0aGVcbiAgICAgKiB0ZXh0dXJlIGNhY2hlIGVudHJ5IGlmIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgICAqL1xuICAgIGdldENhY2hlZFRleHR1cmU6IGZ1bmN0aW9uKHVuaXF1ZUlkLCB0ZXh0dXJlSW1hZ2VTb3VyY2UpIHtcbiAgICAgIGlmICh0aGlzLnRleHR1cmVDYWNoZVt1bmlxdWVJZF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZUNhY2hlW3VuaXF1ZUlkXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZShcbiAgICAgICAgICB0aGlzLmdsLCB0ZXh0dXJlSW1hZ2VTb3VyY2Uud2lkdGgsIHRleHR1cmVJbWFnZVNvdXJjZS5oZWlnaHQsIHRleHR1cmVJbWFnZVNvdXJjZSk7XG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlW3VuaXF1ZUlkXSA9IHRleHR1cmU7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBvdXQgY2FjaGVkIHJlc291cmNlcyByZWxhdGVkIHRvIGEgc291cmNlIGltYWdlIHRoYXQgaGFzIGJlZW5cbiAgICAgKiBmaWx0ZXJlZCBwcmV2aW91c2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNhY2hlS2V5IFRoZSBjYWNoZSBrZXkgcHJvdmlkZWQgd2hlbiB0aGUgc291cmNlIGltYWdlIHdhcyBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBldmljdENhY2hlc0ZvcktleTogZnVuY3Rpb24oY2FjaGVLZXkpIHtcbiAgICAgIGlmICh0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV0pIHtcbiAgICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV07XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvcHlHTFRvMkQ6IGNvcHlHTFRvMkREcmF3SW1hZ2UsXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIGV4dHJhY3QgR1BVIGluZm9ybWF0aW9uIHN0cmluZ3MgZnJvbSBhIFdlYkdMIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBVc2VmdWwgaW5mb3JtYXRpb24gd2hlbiBkZWJ1Z2dpbmcgb3IgYmxhY2tsaXN0aW5nIHNwZWNpZmljIEdQVXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIEdQVSBpbmZvIG9iamVjdCB3aXRoIHJlbmRlcmVyIGFuZCB2ZW5kb3Igc3RyaW5ncy5cbiAgICAgKi9cbiAgICBjYXB0dXJlR1BVSW5mbzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5ncHVJbmZvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdwdUluZm87XG4gICAgICB9XG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsLCBncHVJbmZvID0geyByZW5kZXJlcjogJycsIHZlbmRvcjogJycgfTtcbiAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgcmV0dXJuIGdwdUluZm87XG4gICAgICB9XG4gICAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvJyk7XG4gICAgICBpZiAoZXh0KSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IGdsLmdldFBhcmFtZXRlcihleHQuVU5NQVNLRURfUkVOREVSRVJfV0VCR0wpO1xuICAgICAgICB2YXIgdmVuZG9yID0gZ2wuZ2V0UGFyYW1ldGVyKGV4dC5VTk1BU0tFRF9WRU5ET1JfV0VCR0wpO1xuICAgICAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgICAgICBncHVJbmZvLnJlbmRlcmVyID0gcmVuZGVyZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVuZG9yKSB7XG4gICAgICAgICAgZ3B1SW5mby52ZW5kb3IgPSB2ZW5kb3IudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5ncHVJbmZvID0gZ3B1SW5mbztcbiAgICAgIHJldHVybiBncHVJbmZvO1xuICAgIH0sXG4gIH07XG59KSgpO1xuXG5mdW5jdGlvbiByZXNpemVDYW52YXNJZk5lZWRlZChwaXBlbGluZVN0YXRlKSB7XG4gIHZhciB0YXJnZXRDYW52YXMgPSBwaXBlbGluZVN0YXRlLnRhcmdldENhbnZhcyxcbiAgICAgIHdpZHRoID0gdGFyZ2V0Q2FudmFzLndpZHRoLCBoZWlnaHQgPSB0YXJnZXRDYW52YXMuaGVpZ2h0LFxuICAgICAgZFdpZHRoID0gcGlwZWxpbmVTdGF0ZS5kZXN0aW5hdGlvbldpZHRoLFxuICAgICAgZEhlaWdodCA9IHBpcGVsaW5lU3RhdGUuZGVzdGluYXRpb25IZWlnaHQ7XG5cbiAgaWYgKHdpZHRoICE9PSBkV2lkdGggfHwgaGVpZ2h0ICE9PSBkSGVpZ2h0KSB7XG4gICAgdGFyZ2V0Q2FudmFzLndpZHRoID0gZFdpZHRoO1xuICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBkSGVpZ2h0O1xuICB9XG59XG5cbi8qKlxuICogQ29weSBhbiBpbnB1dCBXZWJHTCBjYW52YXMgb24gdG8gYW4gb3V0cHV0IDJEIGNhbnZhcy5cbiAqXG4gKiBUaGUgV2ViR0wgY2FudmFzIGlzIGFzc3VtZWQgdG8gYmUgdXBzaWRlIGRvd24sIHdpdGggdGhlIHRvcC1sZWZ0IHBpeGVsIG9mIHRoZVxuICogZGVzaXJlZCBvdXRwdXQgaW1hZ2UgYXBwZWFyaW5nIGluIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2YgdGhlIFdlYkdMIGNhbnZhcy5cbiAqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gc291cmNlQ29udGV4dCBUaGUgV2ViR0wgY29udGV4dCB0byBjb3B5IGZyb20uXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSB0YXJnZXRDYW52YXMgVGhlIDJEIHRhcmdldCBjYW52YXMgdG8gY29weSBvbiB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwaXBlbGluZVN0YXRlIFRoZSAyRCB0YXJnZXQgY2FudmFzIHRvIGNvcHkgb24gdG8uXG4gKi9cbmZ1bmN0aW9uIGNvcHlHTFRvMkREcmF3SW1hZ2UoZ2wsIHBpcGVsaW5lU3RhdGUpIHtcbiAgdmFyIGdsQ2FudmFzID0gZ2wuY2FudmFzLCB0YXJnZXRDYW52YXMgPSBwaXBlbGluZVN0YXRlLnRhcmdldENhbnZhcyxcbiAgICAgIGN0eCA9IHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjdHgudHJhbnNsYXRlKDAsIHRhcmdldENhbnZhcy5oZWlnaHQpOyAvLyBtb3ZlIGl0IGRvd24gYWdhaW5cbiAgY3R4LnNjYWxlKDEsIC0xKTsgLy8gdmVydGljYWwgZmxpcFxuICAvLyB3aGVyZSBpcyBteSBpbWFnZSBvbiB0aGUgYmlnIGdsY2FudmFzP1xuICB2YXIgc291cmNlWSA9IGdsQ2FudmFzLmhlaWdodCAtIHRhcmdldENhbnZhcy5oZWlnaHQ7XG4gIGN0eC5kcmF3SW1hZ2UoZ2xDYW52YXMsIDAsIHNvdXJjZVksIHRhcmdldENhbnZhcy53aWR0aCwgdGFyZ2V0Q2FudmFzLmhlaWdodCwgMCwgMCxcbiAgICB0YXJnZXRDYW52YXMud2lkdGgsIHRhcmdldENhbnZhcy5oZWlnaHQpO1xufVxuXG4vKipcbiAqIENvcHkgYW4gaW5wdXQgV2ViR0wgY2FudmFzIG9uIHRvIGFuIG91dHB1dCAyRCBjYW52YXMgdXNpbmcgMmQgY2FudmFzJyBwdXRJbWFnZURhdGFcbiAqIEFQSS4gTWVhc3VyYWJseSBmYXN0ZXIgdGhhbiB1c2luZyBjdHguZHJhd0ltYWdlIGluIEZpcmVmb3ggKHZlcnNpb24gNTQgb24gT1NYIFNpZXJyYSkuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IHNvdXJjZUNvbnRleHQgVGhlIFdlYkdMIGNvbnRleHQgdG8gY29weSBmcm9tLlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gdGFyZ2V0Q2FudmFzIFRoZSAyRCB0YXJnZXQgY2FudmFzIHRvIGNvcHkgb24gdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gcGlwZWxpbmVTdGF0ZSBUaGUgMkQgdGFyZ2V0IGNhbnZhcyB0byBjb3B5IG9uIHRvLlxuICovXG5mdW5jdGlvbiBjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhKGdsLCBwaXBlbGluZVN0YXRlKSB7XG4gIHZhciB0YXJnZXRDYW52YXMgPSBwaXBlbGluZVN0YXRlLnRhcmdldENhbnZhcywgY3R4ID0gdGFyZ2V0Q2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICBkV2lkdGggPSBwaXBlbGluZVN0YXRlLmRlc3RpbmF0aW9uV2lkdGgsXG4gICAgICBkSGVpZ2h0ID0gcGlwZWxpbmVTdGF0ZS5kZXN0aW5hdGlvbkhlaWdodCxcbiAgICAgIG51bUJ5dGVzID0gZFdpZHRoICogZEhlaWdodCAqIDQ7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciB1OCA9IG5ldyBVaW50OEFycmF5KHRoaXMuaW1hZ2VCdWZmZXIsIDAsIG51bUJ5dGVzKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciB1OENsYW1wZWQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkodGhpcy5pbWFnZUJ1ZmZlciwgMCwgbnVtQnl0ZXMpO1xuXG4gIGdsLnJlYWRQaXhlbHMoMCwgMCwgZFdpZHRoLCBkSGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB1OCk7XG4gIHZhciBpbWdEYXRhID0gbmV3IEltYWdlRGF0YSh1OENsYW1wZWQsIGRXaWR0aCwgZEhlaWdodCk7XG4gIGN0eC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG59XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cbiAgZmFicmljLkNhbnZhczJkRmlsdGVyQmFja2VuZCA9IENhbnZhczJkRmlsdGVyQmFja2VuZDtcblxuICAvKipcbiAgICogQ2FudmFzIDJEIGZpbHRlciBiYWNrZW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2FudmFzMmRGaWx0ZXJCYWNrZW5kKCkge307XG5cbiAgQ2FudmFzMmRGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkNhbnZhczJkRmlsdGVyQmFja2VuZC5wcm90b3R5cGUgKi8ge1xuICAgIGV2aWN0Q2FjaGVzRm9yS2V5OiBub29wLFxuICAgIGRpc3Bvc2U6IG5vb3AsXG4gICAgY2xlYXJXZWJHTENhY2hlczogbm9vcCxcblxuICAgIC8qKlxuICAgICAqIEV4cGVyaW1lbnRhbC4gVGhpcyBvYmplY3QgaXMgYSBzb3J0IG9mIHJlcG9zaXRvcnkgb2YgaGVscCBsYXllcnMgdXNlZCB0byBhdm9pZFxuICAgICAqIG9mIHJlY3JlYXRpbmcgdGhlbSBkdXJpbmcgZnJlcXVlbnQgZmlsdGVyaW5nLiBJZiB5b3UgYXJlIHByZXZpZXdpbmcgYSBmaWx0ZXIgd2l0aFxuICAgICAqIGEgc2xpZGVyIHlvdSBwcm9iYWJseSBkbyBub3Qgd2FudCB0byBjcmVhdGUgaGVscCBsYXllcnMgZXZlcnkgZmlsdGVyIHN0ZXAuXG4gICAgICogaW4gdGhpcyBvYmplY3QgdGhlcmUgd2lsbCBiZSBhcHBlbmRlZCBzb21lIGNhbnZhc2VzLCBjcmVhdGVkIG9uY2UsIHJlc2l6ZWQgc29tZXRpbWVzXG4gICAgICogY2xlYXJlZCBuZXZlci4gQ2xlYXJpbmcgaXMgbGVmdCB0byB0aGUgZGV2ZWxvcGVyLlxuICAgICAqKi9cbiAgICByZXNvdXJjZXM6IHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSBhIHNldCBvZiBmaWx0ZXJzIGFnYWluc3QgYSBzb3VyY2UgaW1hZ2UgYW5kIGRyYXcgdGhlIGZpbHRlcmVkIG91dHB1dFxuICAgICAqIHRvIHRoZSBwcm92aWRlZCBkZXN0aW5hdGlvbiBjYW52YXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VuaGFuY2VkRmlsdGVyfSBmaWx0ZXJzIFRoZSBmaWx0ZXIgdG8gYXBwbHkuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBzb3VyY2VFbGVtZW50IFRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZVdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgc291cmNlIGlucHV0LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2VIZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgc291cmNlIGlucHV0LlxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IHRhcmdldENhbnZhcyBUaGUgZGVzdGluYXRpb24gZm9yIGZpbHRlcmVkIG91dHB1dCB0byBiZSBkcmF3bi5cbiAgICAgKi9cbiAgICBhcHBseUZpbHRlcnM6IGZ1bmN0aW9uKGZpbHRlcnMsIHNvdXJjZUVsZW1lbnQsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsIHRhcmdldENhbnZhcykge1xuICAgICAgdmFyIGN0eCA9IHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmRyYXdJbWFnZShzb3VyY2VFbGVtZW50LCAwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQpO1xuICAgICAgdmFyIG9yaWdpbmFsSW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgIHZhciBwaXBlbGluZVN0YXRlID0ge1xuICAgICAgICBzb3VyY2VXaWR0aDogc291cmNlV2lkdGgsXG4gICAgICAgIHNvdXJjZUhlaWdodDogc291cmNlSGVpZ2h0LFxuICAgICAgICBpbWFnZURhdGE6IGltYWdlRGF0YSxcbiAgICAgICAgb3JpZ2luYWxFbDogc291cmNlRWxlbWVudCxcbiAgICAgICAgb3JpZ2luYWxJbWFnZURhdGE6IG9yaWdpbmFsSW1hZ2VEYXRhLFxuICAgICAgICBjYW52YXNFbDogdGFyZ2V0Q2FudmFzLFxuICAgICAgICBjdHg6IGN0eCxcbiAgICAgICAgZmlsdGVyQmFja2VuZDogdGhpcyxcbiAgICAgIH07XG4gICAgICBmaWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oZmlsdGVyKSB7IGZpbHRlci5hcHBseVRvKHBpcGVsaW5lU3RhdGUpOyB9KTtcbiAgICAgIGlmIChwaXBlbGluZVN0YXRlLmltYWdlRGF0YS53aWR0aCAhPT0gc291cmNlV2lkdGggfHwgcGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEuaGVpZ2h0ICE9PSBzb3VyY2VIZWlnaHQpIHtcbiAgICAgICAgdGFyZ2V0Q2FudmFzLndpZHRoID0gcGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEud2lkdGg7XG4gICAgICAgIHRhcmdldENhbnZhcy5oZWlnaHQgPSBwaXBlbGluZVN0YXRlLmltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgIHJldHVybiBwaXBlbGluZVN0YXRlO1xuICAgIH0sXG5cbiAgfTtcbn0pKCk7XG5cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gKiBAbWVtYmVyT2YgZmFicmljLkltYWdlXG4gKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiNpbWFnZV9maWx0ZXJzfVxuICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICovXG5mYWJyaWMuSW1hZ2UgPSBmYWJyaWMuSW1hZ2UgfHwgeyB9O1xuZmFicmljLkltYWdlLmZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyB8fCB7IH07XG5cbi8qKlxuICogUm9vdCBmaWx0ZXIgY2xhc3MgZnJvbSB3aGljaCBhbGwgZmlsdGVyIGNsYXNzZXMgaW5oZXJpdCBmcm9tXG4gKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gKi9cbmZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcygvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogRmlsdGVyIHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHR5cGU6ICdCYXNlRmlsdGVyJyxcblxuICAvKipcbiAgICogQXJyYXkgb2YgYXR0cmlidXRlcyB0byBzZW5kIHdpdGggYnVmZmVycy4gZG8gbm90IG1vZGlmeVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB2ZXJ0ZXhTb3VyY2U6ICdhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XFxuJyArXG4gICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICd2VGV4Q29vcmQgPSBhUG9zaXRpb247XFxuJyArXG4gICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiAqIDIuMCAtIDEuMCwgMC4wLCAxLjApO1xcbicgK1xuICAgICd9JyxcblxuICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICdnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgJ30nLFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgZmlsdGVyJ3MgcHJvcGVydGllcyBmcm9tIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgdGhpc1twcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyIHByb2dyYW0uXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdG8gdXNlIGZvciBzaGFkZXIgY29tcGlsYXRpb24uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmcmFnbWVudFNvdXJjZSBmcmFnbWVudFNoYWRlciBzb3VyY2UgZm9yIGNvbXBpbGF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2ZXJ0ZXhTb3VyY2UgdmVydGV4U2hhZGVyIHNvdXJjZSBmb3IgY29tcGlsYXRpb25cbiAgICovXG4gIGNyZWF0ZVByb2dyYW06IGZ1bmN0aW9uKGdsLCBmcmFnbWVudFNvdXJjZSwgdmVydGV4U291cmNlKSB7XG4gICAgZnJhZ21lbnRTb3VyY2UgPSBmcmFnbWVudFNvdXJjZSB8fCB0aGlzLmZyYWdtZW50U291cmNlO1xuICAgIHZlcnRleFNvdXJjZSA9IHZlcnRleFNvdXJjZSB8fCB0aGlzLnZlcnRleFNvdXJjZTtcbiAgICBpZiAoZmFicmljLndlYkdsUHJlY2lzaW9uICE9PSAnaGlnaHAnKXtcbiAgICAgIGZyYWdtZW50U291cmNlID0gZnJhZ21lbnRTb3VyY2UucmVwbGFjZShcbiAgICAgICAgL3ByZWNpc2lvbiBoaWdocCBmbG9hdC9nLFxuICAgICAgICAncHJlY2lzaW9uICcgKyBmYWJyaWMud2ViR2xQcmVjaXNpb24gKyAnIGZsb2F0J1xuICAgICAgKTtcbiAgICB9XG4gICAgdmFyIHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCB2ZXJ0ZXhTb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXRlbXBsYXRlXG4gICAgICAgICdWZXJ0ZXggc2hhZGVyIGNvbXBpbGUgZXJyb3IgZm9yICcgKyB0aGlzLnR5cGUgKyAnOiAnICtcbiAgICAgICAgZ2wuZ2V0U2hhZGVySW5mb0xvZyh2ZXJ0ZXhTaGFkZXIpXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgIGdsLnNoYWRlclNvdXJjZShmcmFnbWVudFNoYWRlciwgZnJhZ21lbnRTb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdtZW50U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci10ZW1wbGF0ZVxuICAgICAgICAnRnJhZ21lbnQgc2hhZGVyIGNvbXBpbGUgZXJyb3IgZm9yICcgKyB0aGlzLnR5cGUgKyAnOiAnICtcbiAgICAgICAgZ2wuZ2V0U2hhZGVySW5mb0xvZyhmcmFnbWVudFNoYWRlcilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItdGVtcGxhdGVcbiAgICAgICAgJ1NoYWRlciBsaW5rIGVycm9yIGZvciBcIiR7dGhpcy50eXBlfVwiICcgK1xuICAgICAgICBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgYXR0cmlidXRlTG9jYXRpb25zID0gdGhpcy5nZXRBdHRyaWJ1dGVMb2NhdGlvbnMoZ2wsIHByb2dyYW0pO1xuICAgIHZhciB1bmlmb3JtTG9jYXRpb25zID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb25zKGdsLCBwcm9ncmFtKSB8fCB7IH07XG4gICAgdW5pZm9ybUxvY2F0aW9ucy51U3RlcFcgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTdGVwVycpO1xuICAgIHVuaWZvcm1Mb2NhdGlvbnMudVN0ZXBIID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U3RlcEgnKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgIGF0dHJpYnV0ZUxvY2F0aW9uczogYXR0cmlidXRlTG9jYXRpb25zLFxuICAgICAgdW5pZm9ybUxvY2F0aW9uczogdW5pZm9ybUxvY2F0aW9uc1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG1hcCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gV2ViR0xBdHRyaWJ1dGVMb2NhdGlvbiBvYmplY3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoZSBzaGFkZXIgcHJvZ3JhbSBmcm9tIHdoaWNoIHRvIHRha2UgYXR0cmlidXRlIGxvY2F0aW9ucy5cbiAgICogQHJldHVybnMge09iamVjdH0gQSBtYXAgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGF0dHJpYnV0ZSBsb2NhdGlvbnMuXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVMb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFQb3NpdGlvbjogZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FQb3NpdGlvbicpLFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG1hcCBvZiB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHMuXG4gICAqXG4gICAqIEludGVuZGVkIHRvIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGUgc2hhZGVyIHByb2dyYW0gZnJvbSB3aGljaCB0byB0YWtlIHVuaWZvcm0gbG9jYXRpb25zLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBIG1hcCBvZiB1bmlmb3JtIG5hbWVzIHRvIHVuaWZvcm0gbG9jYXRpb25zLlxuICAgKi9cbiAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24gKC8qIGdsLCBwcm9ncmFtICovKSB7XG4gICAgLy8gaW4gY2FzZSBpIGRvIG5vdCBuZWVkIGFueSBzcGVjaWFsIHVuaWZvcm0gaSBuZWVkIHRvIHJldHVybiBhbiBlbXB0eSBvYmplY3RcbiAgICByZXR1cm4geyB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZW5kIGF0dHJpYnV0ZSBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtIG9uIHRoZSBHUFUuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZUxvY2F0aW9ucyBBIG1hcCBvZiBzaGFkZXIgYXR0cmlidXRlIG5hbWVzIHRvIHRoZWlyIGxvY2F0aW9ucy5cbiAgICovXG4gIHNlbmRBdHRyaWJ1dGVEYXRhOiBmdW5jdGlvbihnbCwgYXR0cmlidXRlTG9jYXRpb25zLCBhUG9zaXRpb25EYXRhKSB7XG4gICAgdmFyIGF0dHJpYnV0ZUxvY2F0aW9uID0gYXR0cmlidXRlTG9jYXRpb25zLmFQb3NpdGlvbjtcbiAgICB2YXIgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cmlidXRlTG9jYXRpb24pO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0cmlidXRlTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGFQb3NpdGlvbkRhdGEsIGdsLlNUQVRJQ19EUkFXKTtcbiAgfSxcblxuICBfc2V0dXBGcmFtZUJ1ZmZlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBnbCA9IG9wdGlvbnMuY29udGV4dCwgd2lkdGgsIGhlaWdodDtcbiAgICBpZiAob3B0aW9ucy5wYXNzZXMgPiAxKSB7XG4gICAgICB3aWR0aCA9IG9wdGlvbnMuZGVzdGluYXRpb25XaWR0aDtcbiAgICAgIGhlaWdodCA9IG9wdGlvbnMuZGVzdGluYXRpb25IZWlnaHQ7XG4gICAgICBpZiAob3B0aW9ucy5zb3VyY2VXaWR0aCAhPT0gd2lkdGggfHwgb3B0aW9ucy5zb3VyY2VIZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKG9wdGlvbnMudGFyZ2V0VGV4dHVyZSk7XG4gICAgICAgIG9wdGlvbnMudGFyZ2V0VGV4dHVyZSA9IG9wdGlvbnMuZmlsdGVyQmFja2VuZC5jcmVhdGVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgb3B0aW9ucy50YXJnZXRUZXh0dXJlLCAwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBkcmF3IGxhc3QgZmlsdGVyIG9uIGNhbnZhcyBhbmQgbm90IHRvIGZyYW1lYnVmZmVyLlxuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgIGdsLmZpbmlzaCgpO1xuICAgIH1cbiAgfSxcblxuICBfc3dhcFRleHR1cmVzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5wYXNzZXMtLTtcbiAgICBvcHRpb25zLnBhc3MrKztcbiAgICB2YXIgdGVtcCA9IG9wdGlvbnMudGFyZ2V0VGV4dHVyZTtcbiAgICBvcHRpb25zLnRhcmdldFRleHR1cmUgPSBvcHRpb25zLnNvdXJjZVRleHR1cmU7XG4gICAgb3B0aW9ucy5zb3VyY2VUZXh0dXJlID0gdGVtcDtcbiAgfSxcblxuICAvKipcbiAgICogR2VuZXJpYyBpc05ldXRyYWwgaW1wbGVtZW50YXRpb24gZm9yIG9uZSBwYXJhbWV0ZXIgYmFzZWQgZmlsdGVycy5cbiAgICogVXNlZCBvbmx5IGluIGltYWdlIGFwcGx5RmlsdGVycyB0byBkaXNjYXJkIGZpbHRlcnMgdGhhdCB3aWxsIG5vdCBoYXZlIGFuIGVmZmVjdFxuICAgKiBvbiB0aGUgaW1hZ2VcbiAgICogT3RoZXIgZmlsdGVycyBtYXkgbmVlZCB0aGVpciBvd24gdmVyc2lvbiAoIENvbG9yTWF0cml4LCBIdWVSb3RhdGlvbiwgZ2FtbWEsIENvbXBvc2VkRmlsdGVyIClcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICoqL1xuICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24oLyogb3B0aW9ucyAqLykge1xuICAgIHZhciBtYWluID0gdGhpcy5tYWluUGFyYW1ldGVyLFxuICAgICAgICBfY2xhc3MgPSBmYWJyaWMuSW1hZ2UuZmlsdGVyc1t0aGlzLnR5cGVdLnByb3RvdHlwZTtcbiAgICBpZiAobWFpbikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX2NsYXNzW21haW5dKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gX2NsYXNzW21haW5dLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIGlmICh0aGlzW21haW5dW2ldICE9PSBfY2xhc3NbbWFpbl1baV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9jbGFzc1ttYWluXSA9PT0gdGhpc1ttYWluXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBseSB0aGlzIGZpbHRlciB0byB0aGUgaW5wdXQgaW1hZ2UgZGF0YSBwcm92aWRlZC5cbiAgICpcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHVzZSBXZWJHTCBvciBDYW52YXMyRCBiYXNlZCBvbiB0aGUgb3B0aW9ucy53ZWJnbCBmbGFnLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYXNzZXMgVGhlIG51bWJlciBvZiBmaWx0ZXJzIHJlbWFpbmluZyB0byBiZSBleGVjdXRlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMud2ViZ2wgV2hldGhlciB0byB1c2Ugd2ViZ2wgdG8gcmVuZGVyIHRoZSBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnNvdXJjZVRleHR1cmUgVGhlIHRleHR1cmUgc2V0dXAgYXMgdGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMudGFyZ2V0VGV4dHVyZSBUaGUgdGV4dHVyZSB3aGVyZSBmaWx0ZXJlZCBvdXRwdXQgc2hvdWxkIGJlIGRyYXduLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAqL1xuICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMud2ViZ2wpIHtcbiAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgIHRoaXMuX3N3YXBUZXh0dXJlcyhvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmFwcGx5VG8yZChvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgKi9cbiAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KHRoaXMudHlwZSkpIHtcbiAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW3RoaXMudHlwZV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW3RoaXMudHlwZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGx5IHRoaXMgZmlsdGVyIHVzaW5nIHdlYmdsLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYXNzZXMgVGhlIG51bWJlciBvZiBmaWx0ZXJzIHJlbWFpbmluZyB0byBiZSBleGVjdXRlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMud2ViZ2wgV2hldGhlciB0byB1c2Ugd2ViZ2wgdG8gcmVuZGVyIHRoZSBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLm9yaWdpbmFsVGV4dHVyZSBUaGUgdGV4dHVyZSBvZiB0aGUgb3JpZ2luYWwgaW5wdXQgaW1hZ2UuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnNvdXJjZVRleHR1cmUgVGhlIHRleHR1cmUgc2V0dXAgYXMgdGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMudGFyZ2V0VGV4dHVyZSBUaGUgdGV4dHVyZSB3aGVyZSBmaWx0ZXJlZCBvdXRwdXQgc2hvdWxkIGJlIGRyYXduLlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAqL1xuICBhcHBseVRvV2ViR0w6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZ2wgPSBvcHRpb25zLmNvbnRleHQ7XG4gICAgdmFyIHNoYWRlciA9IHRoaXMucmV0cmlldmVTaGFkZXIob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMucGFzcyA9PT0gMCAmJiBvcHRpb25zLm9yaWdpbmFsVGV4dHVyZSkge1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgb3B0aW9ucy5vcmlnaW5hbFRleHR1cmUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG9wdGlvbnMuc291cmNlVGV4dHVyZSk7XG4gICAgfVxuICAgIGdsLnVzZVByb2dyYW0oc2hhZGVyLnByb2dyYW0pO1xuICAgIHRoaXMuc2VuZEF0dHJpYnV0ZURhdGEoZ2wsIHNoYWRlci5hdHRyaWJ1dGVMb2NhdGlvbnMsIG9wdGlvbnMuYVBvc2l0aW9uKTtcblxuICAgIGdsLnVuaWZvcm0xZihzaGFkZXIudW5pZm9ybUxvY2F0aW9ucy51U3RlcFcsIDEgLyBvcHRpb25zLnNvdXJjZVdpZHRoKTtcbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVuaWZvcm1Mb2NhdGlvbnMudVN0ZXBILCAxIC8gb3B0aW9ucy5zb3VyY2VIZWlnaHQpO1xuXG4gICAgdGhpcy5zZW5kVW5pZm9ybURhdGEoZ2wsIHNoYWRlci51bmlmb3JtTG9jYXRpb25zKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBvcHRpb25zLmRlc3RpbmF0aW9uV2lkdGgsIG9wdGlvbnMuZGVzdGluYXRpb25IZWlnaHQpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICB9LFxuXG4gIGJpbmRBZGRpdGlvbmFsVGV4dHVyZTogZnVuY3Rpb24oZ2wsIHRleHR1cmUsIHRleHR1cmVVbml0KSB7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0ZXh0dXJlVW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgLy8gcmVzZXQgYWN0aXZlIHRleHR1cmUgdG8gMCBhcyB1c3VhbFxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICB9LFxuXG4gIHVuYmluZEFkZGl0aW9uYWxUZXh0dXJlOiBmdW5jdGlvbihnbCwgdGV4dHVyZVVuaXQpIHtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKHRleHR1cmVVbml0KTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgfSxcblxuICBnZXRNYWluUGFyYW1ldGVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpc1t0aGlzLm1haW5QYXJhbWV0ZXJdO1xuICB9LFxuXG4gIHNldE1haW5QYXJhbWV0ZXI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpc1t0aGlzLm1haW5QYXJhbWV0ZXJdID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlbmQgdW5pZm9ybSBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtIG9uIHRoZSBHUFUuXG4gICAqXG4gICAqIEludGVuZGVkIHRvIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlcy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzaGFkZXIgdW5pZm9ybSBuYW1lcyB0byB0aGVpciBsb2NhdGlvbnMuXG4gICAqL1xuICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKC8qIGdsLCB1bmlmb3JtTG9jYXRpb25zICovKSB7XG4gICAgLy8gSW50ZW50aW9uYWxseSBsZWZ0IGJsYW5rLiAgT3ZlcnJpZGUgbWUgaW4gc3ViY2xhc3Nlcy5cbiAgfSxcblxuICAvKipcbiAgICogSWYgbmVlZGVkIGJ5IGEgMmQgZmlsdGVyLCB0aGlzIGZ1bmN0aW9ucyBjYW4gY3JlYXRlIGFuIGhlbHBlciBjYW52YXMgdG8gYmUgdXNlZFxuICAgKiByZW1lbWJlciB0aGF0IG9wdGlvbnMudGFyZ2V0Q2FudmFzIGlzIGF2YWlsYWJsZSBmb3IgdXNlIHRpbGwgZW5kIG9mIGNoYWluLlxuICAgKi9cbiAgY3JlYXRlSGVscExheWVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmhlbHBMYXllcikge1xuICAgICAgdmFyIGhlbHBMYXllciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgaGVscExheWVyLndpZHRoID0gb3B0aW9ucy5zb3VyY2VXaWR0aDtcbiAgICAgIGhlbHBMYXllci5oZWlnaHQgPSBvcHRpb25zLnNvdXJjZUhlaWdodDtcbiAgICAgIG9wdGlvbnMuaGVscExheWVyID0gaGVscExheWVyO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICovXG4gIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2JqZWN0ID0geyB0eXBlOiB0aGlzLnR5cGUgfSwgbWFpblAgPSB0aGlzLm1haW5QYXJhbWV0ZXI7XG4gICAgaWYgKG1haW5QKSB7XG4gICAgICBvYmplY3RbbWFpblBdID0gdGhpc1ttYWluUF07XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gSlNPTlxuICAgKi9cbiAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAvLyBkZWxlZ2F0ZSwgbm90IGFsaWFzXG4gICAgcmV0dXJuIHRoaXMudG9PYmplY3QoKTtcbiAgfVxufSk7XG5cbmZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVyc1tvYmplY3QudHlwZV0ob2JqZWN0KTtcbiAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZmlsdGVyKTtcbiAgcmV0dXJuIGZpbHRlcjtcbn07XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29sb3IgTWF0cml4IGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXhcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXgjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAc2VlIHtATGluayBodHRwOi8vd3d3LndlYndhc3AuY28udWsvdHV0b3JpYWxzLzIxOS9Db2xvcl9NYXRyaXhfRmlsdGVyLnBocH1cbiAgICogQHNlZSB7QExpbmsgaHR0cDovL3Bob2Jvc2xhYi5vcmcvbG9nLzIwMTMvMTEvZmFzdC1pbWFnZS1maWx0ZXJzLXdpdGgtd2ViZ2x9XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPktvZGFjaHJvbWUgZmlsdGVyPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4KHtcbiAgICogIG1hdHJpeDogW1xuICAgICAgIDEuMTI4NTU4MjM5NjU5MzUyNSwgLTAuMzk2NzM4MjI4MzYwMTM0OCwgLTAuMDM5OTI1NTkxNzI5MjE3OTMsIDAsIDYzLjcyOTU4NzYyMTk2NTAyLFxuICAgICAgIC0wLjE2NDA0MzM5OTYyMjQ0NjE2LCAxLjA4MzUyNTE1NjYyOTEzMDQsIC0wLjA1NDk4ODA1MTE1NjMzMTMyLCAwLCAyNC43MzI0MDc4OTY3MDYyMDMsXG4gICAgICAgLTAuMTY3ODYwMTA3MDYxNTU3NjMsIC0wLjU2MDM0MTYyNzc2OTUyNDgsIDEuNjAxNDg1MDc2MTk2NDk0MywgMCwgMzUuNjI5ODI4MDc0NjA5NDYsXG4gICAgICAgMCwgMCwgMCwgMSwgMFxuICAgICAgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkNvbG9yTWF0cml4ID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQ29sb3JNYXRyaXgnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd1bmlmb3JtIG1hdDQgdUNvbG9yTWF0cml4O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjNCB1Q29uc3RhbnRzO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdjb2xvciAqPSB1Q29sb3JNYXRyaXg7XFxuJyArXG4gICAgICAgICdjb2xvciArPSB1Q29uc3RhbnRzO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvcm1hdHJpeCBmb3IgcGl4ZWxzLlxuICAgICAqIGFycmF5IG9mIDIwIGZsb2F0cy4gTnVtYmVycyBpbiBwb3NpdGlvbnMgNCwgOSwgMTQsIDE5IGxvb3NlIG1lYW5pbmdcbiAgICAgKiBvdXRzaWRlIHRoZSAtMSwgMSByYW5nZS5cbiAgICAgKiAwLjAwMzkyMTU2ODYgaXMgdGhlIHBhcnQgb2YgMSB0aGF0IGdldCB0cmFuc2xhdGVkIHRvIDEgaW4gMmRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRyaXggYXJyYXkgb2YgMjAgbnVtYmVycy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1hdHJpeDogW1xuICAgICAgMSwgMCwgMCwgMCwgMCxcbiAgICAgIDAsIDEsIDAsIDAsIDAsXG4gICAgICAwLCAwLCAxLCAwLCAwLFxuICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF0sXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnbWF0cml4JyxcblxuICAgIC8qKlxuICAgICAqIExvY2sgdGhlIGNvbG9ybWF0cml4IG9uIHRoZSBjb2xvciBwYXJ0LCBza2lwcGluZyBhbHBoYSwgbWFpbmx5IGZvciBub24gd2ViZ2wgc2NlbmFyaW9cbiAgICAgKiB0byBzYXZlIHNvbWUgY2FsY3VsYXRpb25cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGNvbG9yc09ubHk6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgLy8gY3JlYXRlIGEgbmV3IGFycmF5IGluc3RlYWQgbXV0YXRpbmcgdGhlIHByb3RvdHlwZSB3aXRoIHB1c2hcbiAgICAgIHRoaXMubWF0cml4ID0gdGhpcy5tYXRyaXguc2xpY2UoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBDb2xvck1hdHJpeCBvcGVyYXRpb24gdG8gYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4QXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGlMZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBtID0gdGhpcy5tYXRyaXgsXG4gICAgICAgICAgciwgZywgYiwgYSwgaSwgY29sb3JzT25seSA9IHRoaXMuY29sb3JzT25seTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGlMZW47IGkgKz0gNCkge1xuICAgICAgICByID0gZGF0YVtpXTtcbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBiID0gZGF0YVtpICsgMl07XG4gICAgICAgIGlmIChjb2xvcnNPbmx5KSB7XG4gICAgICAgICAgZGF0YVtpXSA9IHIgKiBtWzBdICsgZyAqIG1bMV0gKyBiICogbVsyXSArIG1bNF0gKiAyNTU7XG4gICAgICAgICAgZGF0YVtpICsgMV0gPSByICogbVs1XSArIGcgKiBtWzZdICsgYiAqIG1bN10gKyBtWzldICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDJdID0gciAqIG1bMTBdICsgZyAqIG1bMTFdICsgYiAqIG1bMTJdICsgbVsxNF0gKiAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYSA9IGRhdGFbaSArIDNdO1xuICAgICAgICAgIGRhdGFbaV0gPSByICogbVswXSArIGcgKiBtWzFdICsgYiAqIG1bMl0gKyBhICogbVszXSArIG1bNF0gKiAyNTU7XG4gICAgICAgICAgZGF0YVtpICsgMV0gPSByICogbVs1XSArIGcgKiBtWzZdICsgYiAqIG1bN10gKyBhICogbVs4XSArIG1bOV0gKiAyNTU7XG4gICAgICAgICAgZGF0YVtpICsgMl0gPSByICogbVsxMF0gKyBnICogbVsxMV0gKyBiICogbVsxMl0gKyBhICogbVsxM10gKyBtWzE0XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAzXSA9IHIgKiBtWzE1XSArIGcgKiBtWzE2XSArIGIgKiBtWzE3XSArIGEgKiBtWzE4XSArIG1bMTldICogMjU1O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1Q29sb3JNYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUNvbG9yTWF0cml4JyksXG4gICAgICAgIHVDb25zdGFudHM6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUNvbnN0YW50cycpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgdmFyIG0gPSB0aGlzLm1hdHJpeCxcbiAgICAgICAgICBtYXRyaXggPSBbXG4gICAgICAgICAgICBtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLFxuICAgICAgICAgICAgbVs1XSwgbVs2XSwgbVs3XSwgbVs4XSxcbiAgICAgICAgICAgIG1bMTBdLCBtWzExXSwgbVsxMl0sIG1bMTNdLFxuICAgICAgICAgICAgbVsxNV0sIG1bMTZdLCBtWzE3XSwgbVsxOF1cbiAgICAgICAgICBdLFxuICAgICAgICAgIGNvbnN0YW50cyA9IFttWzRdLCBtWzldLCBtWzE0XSwgbVsxOV1dO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih1bmlmb3JtTG9jYXRpb25zLnVDb2xvck1hdHJpeCwgZmFsc2UsIG1hdHJpeCk7XG4gICAgICBnbC51bmlmb3JtNGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUNvbnN0YW50cywgY29uc3RhbnRzKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGZ1bmN0aW9uIHRvIGludm9rZSBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXh9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeC5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEJyaWdodG5lc3MgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3MjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3Moe1xuICAgKiAgIGJyaWdodG5lc3M6IDAuMDVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5CcmlnaHRuZXNzID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3MucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdCcmlnaHRuZXNzJyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIGJyaWdodG5lc3MgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdUJyaWdodG5lc3M7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnY29sb3IucmdiICs9IHVCcmlnaHRuZXNzO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBCcmlnaHRuZXNzIHZhbHVlLCBmcm9tIC0xIHRvIDEuXG4gICAgICogdHJhbnNsYXRlZCB0byAtMjU1IHRvIDI1NSBmb3IgMmRcbiAgICAgKiAwLjAwMzkyMTU2ODYgaXMgdGhlIHBhcnQgb2YgMSB0aGF0IGdldCB0cmFuc2xhdGVkIHRvIDEgaW4gMmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYnJpZ2h0bmVzc1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYnJpZ2h0bmVzczogMCxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIHRoZSBwcm9wZXJ0eSB0aGF0IGlzIHRoZSBmaWx0ZXIgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1haW5QYXJhbWV0ZXI6ICdicmlnaHRuZXNzJyxcblxuICAgIC8qKlxuICAgICogQXBwbHkgdGhlIEJyaWdodG5lc3Mgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgKlxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmJyaWdodG5lc3MgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgYnJpZ2h0bmVzcyA9IE1hdGgucm91bmQodGhpcy5icmlnaHRuZXNzICogMjU1KTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2ldID0gZGF0YVtpXSArIGJyaWdodG5lc3M7XG4gICAgICAgIGRhdGFbaSArIDFdID0gZGF0YVtpICsgMV0gKyBicmlnaHRuZXNzO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IGRhdGFbaSArIDJdICsgYnJpZ2h0bmVzcztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVCcmlnaHRuZXNzOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VCcmlnaHRuZXNzJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51QnJpZ2h0bmVzcywgdGhpcy5icmlnaHRuZXNzKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3N9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3NcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJyaWdodG5lc3MuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBBZGFwdGVkIGZyb20gPGEgaHJlZj1cImh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NhbnZhcy9pbWFnZWZpbHRlcnMvXCI+aHRtbDVyb2NrcyBhcnRpY2xlPC9hPlxuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlNoYXJwZW4gZmlsdGVyPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZSh7XG4gICAqICAgbWF0cml4OiBbIDAsIC0xLCAgMCxcbiAgICogICAgICAgICAgICAtMSwgIDUsIC0xLFxuICAgKiAgICAgICAgICAgICAwLCAtMSwgIDAgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+Qmx1ciBmaWx0ZXI8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBtYXRyaXg6IFsgMS85LCAxLzksIDEvOSxcbiAgICogICAgICAgICAgICAgMS85LCAxLzksIDEvOSxcbiAgICogICAgICAgICAgICAgMS85LCAxLzksIDEvOSBdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWJvc3MgZmlsdGVyPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZSh7XG4gICAqICAgbWF0cml4OiBbIDEsICAgMSwgIDEsXG4gICAqICAgICAgICAgICAgIDEsIDAuNywgLTEsXG4gICAqICAgICAgICAgICAgLTEsICAtMSwgLTEgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1ib3NzIGZpbHRlciB3aXRoIG9wYXF1ZW5lc3M8L2NhcHRpb24+XG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlKHtcbiAgICogICBvcGFxdWU6IHRydWUsXG4gICAqICAgbWF0cml4OiBbIDEsICAgMSwgIDEsXG4gICAqICAgICAgICAgICAgIDEsIDAuNywgLTEsXG4gICAqICAgICAgICAgICAgLTEsICAtMSwgLTEgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG4gIGZpbHRlcnMuQ29udm9sdXRlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0NvbnZvbHV0ZScsXG5cbiAgICAvKlxuICAgICAqIE9wYXF1ZSB2YWx1ZSAodHJ1ZS9mYWxzZSlcbiAgICAgKi9cbiAgICBvcGFxdWU6IGZhbHNlLFxuXG4gICAgLypcbiAgICAgKiBtYXRyaXggZm9yIHRoZSBmaWx0ZXIsIG1heCA5eDlcbiAgICAgKi9cbiAgICBtYXRyaXg6IFswLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwXSxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIGJyaWdodG5lc3MgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiB7XG4gICAgICBDb252b2x1dGVfM18xOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbOV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDMuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgMy4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDEpLCB1U3RlcEggKiAoaCAtIDEpKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKSAqIHVNYXRyaXhbaW50KGggKiAzLjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfM18wOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbOV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMSk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDMuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgMy4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDEuMCksIHVTdGVwSCAqIChoIC0gMS4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvci5yZ2IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpLnJnYiAqIHVNYXRyaXhbaW50KGggKiAzLjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGFscGhhID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpLmE7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYSA9IGFscGhhO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfNV8xOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbMjVdO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDApO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA1LjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDUuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAyLjApLCB1U3RlcEggKiAoaCAtIDIuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpICogdU1hdHJpeFtpbnQoaCAqIDUuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV81XzA6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFsyNV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMSk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDUuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNS4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDIuMCksIHVTdGVwSCAqIChoIC0gMi4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvci5yZ2IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpLnJnYiAqIHVNYXRyaXhbaW50KGggKiA1LjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGFscGhhID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpLmE7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYSA9IGFscGhhO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfN18xOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbNDldO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDApO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA3LjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDcuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAzLjApLCB1U3RlcEggKiAoaCAtIDMuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpICogdU1hdHJpeFtpbnQoaCAqIDcuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV83XzA6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs0OV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMSk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDcuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgNy4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDMuMCksIHVTdGVwSCAqIChoIC0gMy4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvci5yZ2IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpLnJnYiAqIHVNYXRyaXhbaW50KGggKiA3LjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGFscGhhID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpLmE7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYSA9IGFscGhhO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfOV8xOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbODFdO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDApO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA5LjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDkuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSA0LjApLCB1U3RlcEggKiAoaCAtIDQuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpICogdU1hdHJpeFtpbnQoaCAqIDkuMCArIHcpXTtcXG4nICtcbiAgICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIENvbnZvbHV0ZV85XzA6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdU1hdHJpeFs4MV07XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMSk7XFxuJyArXG4gICAgICAgICAgJ2ZvciAoZmxvYXQgaCA9IDAuMDsgaCA8IDkuMDsgaCs9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAnZm9yIChmbG9hdCB3ID0gMC4wOyB3IDwgOS4wOyB3Kz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICAgJ3ZlYzIgbWF0cml4UG9zID0gdmVjMih1U3RlcFcgKiAodyAtIDQuMCksIHVTdGVwSCAqIChoIC0gNC4wKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvci5yZ2IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyBtYXRyaXhQb3MpLnJnYiAqIHVNYXRyaXhbaW50KGggKiA5LjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGFscGhhID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpLmE7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYSA9IGFscGhhO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vcGFxdWU9ZmFsc2VdIE9wYXF1ZSB2YWx1ZSAodHJ1ZS9mYWxzZSlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5tYXRyaXhdIEZpbHRlciBtYXRyaXhcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAqL1xuICAgIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgc2l6ZSA9IE1hdGguc3FydCh0aGlzLm1hdHJpeC5sZW5ndGgpO1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgc2l6ZSArICdfJyArICh0aGlzLm9wYXF1ZSA/IDEgOiAwKTtcbiAgICAgIHZhciBzaGFkZXJTb3VyY2UgPSB0aGlzLmZyYWdtZW50U291cmNlW2NhY2hlS2V5XTtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIHNoYWRlclNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQnJpZ2h0bmVzcyBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgd2VpZ2h0cyA9IHRoaXMubWF0cml4LFxuICAgICAgICAgIHNpZGUgPSBNYXRoLnJvdW5kKE1hdGguc3FydCh3ZWlnaHRzLmxlbmd0aCkpLFxuICAgICAgICAgIGhhbGZTaWRlID0gTWF0aC5mbG9vcihzaWRlIC8gMiksXG4gICAgICAgICAgc3cgPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICAgICAgc2ggPSBpbWFnZURhdGEuaGVpZ2h0LFxuICAgICAgICAgIG91dHB1dCA9IG9wdGlvbnMuY3R4LmNyZWF0ZUltYWdlRGF0YShzdywgc2gpLFxuICAgICAgICAgIGRzdCA9IG91dHB1dC5kYXRhLFxuICAgICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIGRlc3RpbmF0aW9uIGltYWdlIHBpeGVsc1xuICAgICAgICAgIGFscGhhRmFjID0gdGhpcy5vcGFxdWUgPyAxIDogMCxcbiAgICAgICAgICByLCBnLCBiLCBhLCBkc3RPZmYsXG4gICAgICAgICAgc2N4LCBzY3ksIHNyY09mZiwgd3QsXG4gICAgICAgICAgeCwgeSwgY3gsIGN5O1xuXG4gICAgICBmb3IgKHkgPSAwOyB5IDwgc2g7IHkrKykge1xuICAgICAgICBmb3IgKHggPSAwOyB4IDwgc3c7IHgrKykge1xuICAgICAgICAgIGRzdE9mZiA9ICh5ICogc3cgKyB4KSAqIDQ7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSB3ZWlnaGVkIHN1bSBvZiB0aGUgc291cmNlIGltYWdlIHBpeGVscyB0aGF0XG4gICAgICAgICAgLy8gZmFsbCB1bmRlciB0aGUgY29udm9sdXRpb24gbWF0cml4XG4gICAgICAgICAgciA9IDA7IGcgPSAwOyBiID0gMDsgYSA9IDA7XG5cbiAgICAgICAgICBmb3IgKGN5ID0gMDsgY3kgPCBzaWRlOyBjeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGN4ID0gMDsgY3ggPCBzaWRlOyBjeCsrKSB7XG4gICAgICAgICAgICAgIHNjeSA9IHkgKyBjeSAtIGhhbGZTaWRlO1xuICAgICAgICAgICAgICBzY3ggPSB4ICsgY3ggLSBoYWxmU2lkZTtcblxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgIGlmIChzY3kgPCAwIHx8IHNjeSA+PSBzaCB8fCBzY3ggPCAwIHx8IHNjeCA+PSBzdykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3JjT2ZmID0gKHNjeSAqIHN3ICsgc2N4KSAqIDQ7XG4gICAgICAgICAgICAgIHd0ID0gd2VpZ2h0c1tjeSAqIHNpZGUgKyBjeF07XG5cbiAgICAgICAgICAgICAgciArPSBkYXRhW3NyY09mZl0gKiB3dDtcbiAgICAgICAgICAgICAgZyArPSBkYXRhW3NyY09mZiArIDFdICogd3Q7XG4gICAgICAgICAgICAgIGIgKz0gZGF0YVtzcmNPZmYgKyAyXSAqIHd0O1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICAgIGlmICghYWxwaGFGYWMpIHtcbiAgICAgICAgICAgICAgICBhICs9IGRhdGFbc3JjT2ZmICsgM10gKiB3dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkc3RbZHN0T2ZmXSA9IHI7XG4gICAgICAgICAgZHN0W2RzdE9mZiArIDFdID0gZztcbiAgICAgICAgICBkc3RbZHN0T2ZmICsgMl0gPSBiO1xuICAgICAgICAgIGlmICghYWxwaGFGYWMpIHtcbiAgICAgICAgICAgIGRzdFtkc3RPZmYgKyAzXSA9IGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHN0W2RzdE9mZiArIDNdID0gZGF0YVtkc3RPZmYgKyAzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuaW1hZ2VEYXRhID0gb3V0cHV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdU1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1TWF0cml4JyksXG4gICAgICAgIHVPcGFxdWU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndU9wYXF1ZScpLFxuICAgICAgICB1SGFsZlNpemU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUhhbGZTaXplJyksXG4gICAgICAgIHVTaXplOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTaXplJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWZ2KHVuaWZvcm1Mb2NhdGlvbnMudU1hdHJpeCwgdGhpcy5tYXRyaXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBvcGFxdWU6IHRoaXMub3BhcXVlLFxuICAgICAgICBtYXRyaXg6IHRoaXMubWF0cml4XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogR3JheXNjYWxlIGltYWdlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGUoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkdyYXlzY2FsZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdHcmF5c2NhbGUnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIGF2ZXJhZ2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGF2ZXJhZ2UgPSAoY29sb3IuciArIGNvbG9yLmIgKyBjb2xvci5nKSAvIDMuMDtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNChhdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjb2xvci5hKTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgbGlnaHRuZXNzOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGludCB1TW9kZTtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICdmbG9hdCBhdmVyYWdlID0gKG1heChtYXgoY29sLnIsIGNvbC5nKSxjb2wuYikgKyBtaW4obWluKGNvbC5yLCBjb2wuZyksY29sLmIpKSAvIDIuMDtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNChhdmVyYWdlLCBhdmVyYWdlLCBhdmVyYWdlLCBjb2wuYSk7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIGx1bWlub3NpdHk6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gaW50IHVNb2RlO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2wgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IGF2ZXJhZ2UgPSAwLjIxICogY29sLnIgKyAwLjcyICogY29sLmcgKyAwLjA3ICogY29sLmI7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY29sLmEpO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogR3JheXNjYWxlIG1vZGUsIGJldHdlZW4gJ2F2ZXJhZ2UnLCAnbGlnaHRuZXNzJywgJ2x1bWlub3NpdHknXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1vZGU6ICdhdmVyYWdlJyxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdtb2RlJyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBHcmF5c2NhbGUgb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSxcbiAgICAgICAgICBsZW4gPSBkYXRhLmxlbmd0aCwgdmFsdWUsXG4gICAgICAgICAgbW9kZSA9IHRoaXMubW9kZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBpZiAobW9kZSA9PT0gJ2F2ZXJhZ2UnKSB7XG4gICAgICAgICAgdmFsdWUgPSAoZGF0YVtpXSArIGRhdGFbaSArIDFdICsgZGF0YVtpICsgMl0pIC8gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnbGlnaHRuZXNzJykge1xuICAgICAgICAgIHZhbHVlID0gKE1hdGgubWluKGRhdGFbaV0sIGRhdGFbaSArIDFdLCBkYXRhW2kgKyAyXSkgK1xuICAgICAgICAgICAgTWF0aC5tYXgoZGF0YVtpXSwgZGF0YVtpICsgMV0sIGRhdGFbaSArIDJdKSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdsdW1pbm9zaXR5Jykge1xuICAgICAgICAgIHZhbHVlID0gMC4yMSAqIGRhdGFbaV0gKyAwLjcyICogZGF0YVtpICsgMV0gKyAwLjA3ICogZGF0YVtpICsgMl07XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtpXSA9IHZhbHVlO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IHZhbHVlO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgdGhpcy5tb2RlO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgdmFyIHNoYWRlclNvdXJjZSA9IHRoaXMuZnJhZ21lbnRTb3VyY2VbdGhpcy5tb2RlXTtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgc2hhZGVyU291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1TW9kZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1TW9kZScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgLy8gZGVmYXVsdCBhdmVyYWdlIG1vZGUuXG4gICAgICB2YXIgbW9kZSA9IDE7XG4gICAgICBnbC51bmlmb3JtMWkodW5pZm9ybUxvY2F0aW9ucy51TW9kZSwgbW9kZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyYXlzY2FsZSBmaWx0ZXIgaXNOZXV0cmFsU3RhdGUgaW1wbGVtZW50YXRpb25cbiAgICAgKiBUaGUgZmlsdGVyIGlzIG5ldmVyIG5ldXRyYWxcbiAgICAgKiBvbiB0aGUgaW1hZ2VcbiAgICAgKiovXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogSW52ZXJ0IGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnQoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuSW52ZXJ0ID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0ludmVydCcsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGludCB1SW52ZXJ0O1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2lmICh1SW52ZXJ0ID09IDEpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAgLSBjb2xvci5yLDEuMCAtY29sb3IuZywxLjAgLWNvbG9yLmIsY29sb3IuYSk7XFxuJyArXG4gICAgICAgICd9IGVsc2Uge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBpbnZlcnQuIGlmIGZhbHNlLCBkb2VzIG5vdGhpbmdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGludmVydFxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW52ZXJ0OiB0cnVlLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ2ludmVydCcsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgSW52ZXJ0IG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGksXG4gICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IDI1NSAtIGRhdGFbaV07XG4gICAgICAgIGRhdGFbaSArIDFdID0gMjU1IC0gZGF0YVtpICsgMV07XG4gICAgICAgIGRhdGFbaSArIDJdID0gMjU1IC0gZGF0YVtpICsgMl07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludmVydCBmaWx0ZXIgaXNOZXV0cmFsU3RhdGUgaW1wbGVtZW50YXRpb25cbiAgICAgKiBVc2VkIG9ubHkgaW4gaW1hZ2UgYXBwbHlGaWx0ZXJzIHRvIGRpc2NhcmQgZmlsdGVycyB0aGF0IHdpbGwgbm90IGhhdmUgYW4gZWZmZWN0XG4gICAgICogb24gdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiovXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmludmVydDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVJbnZlcnQ6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUludmVydCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFpKHVuaWZvcm1Mb2NhdGlvbnMudUludmVydCwgdGhpcy5pbnZlcnQpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0fSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnRcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydC5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogTm9pc2UgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2Uoe1xuICAgKiAgIG5vaXNlOiA3MDBcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuICBmaWx0ZXJzLk5vaXNlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnTm9pc2UnLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgbm9pc2UgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdU5vaXNlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVNlZWQ7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICdmbG9hdCByYW5kKHZlYzIgY28sIGZsb2F0IHNlZWQsIGZsb2F0IHZTY2FsZSkge1xcbicgK1xuICAgICAgICAncmV0dXJuIGZyYWN0KHNpbihkb3QoY28ueHkgKiB2U2NhbGUgLHZlYzIoMTIuOTg5OCAsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMgKiAoc2VlZCArIDAuMDEpIC8gMi4wKTtcXG4nICtcbiAgICAgICd9XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnJnYiArPSAoMC41IC0gcmFuZCh2VGV4Q29vcmQsIHVTZWVkLCAwLjEgLyB1U3RlcEgpKSAqIHVOb2lzZTtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgdGhlIHByb3BlcnR5IHRoYXQgaXMgdGhlIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWFpblBhcmFtZXRlcjogJ25vaXNlJyxcblxuICAgIC8qKlxuICAgICAqIE5vaXNlIHZhbHVlLCBmcm9tXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5vaXNlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBub2lzZTogMCxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCcmlnaHRuZXNzIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMubm9pc2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgbm9pc2UgPSB0aGlzLm5vaXNlLCByYW5kO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgcmFuZCA9ICgwLjUgLSBNYXRoLnJhbmRvbSgpKSAqIG5vaXNlO1xuXG4gICAgICAgIGRhdGFbaV0gKz0gcmFuZDtcbiAgICAgICAgZGF0YVtpICsgMV0gKz0gcmFuZDtcbiAgICAgICAgZGF0YVtpICsgMl0gKz0gcmFuZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVOb2lzZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Tm9pc2UnKSxcbiAgICAgICAgdVNlZWQ6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNlZWQnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVOb2lzZSwgdGhpcy5ub2lzZSAvIDI1NSk7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51U2VlZCwgTWF0aC5yYW5kb20oKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIG5vaXNlOiB0aGlzLm5vaXNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2V9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogUGl4ZWxhdGUgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGUoe1xuICAgKiAgIGJsb2Nrc2l6ZTogOFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLlBpeGVsYXRlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnUGl4ZWxhdGUnLFxuXG4gICAgYmxvY2tzaXplOiA0LFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ2Jsb2Nrc2l6ZScsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBQaXhlbGF0ZSBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1QmxvY2tzaXplO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBIO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAnZmxvYXQgYmxvY2tXID0gdUJsb2Nrc2l6ZSAqIHVTdGVwVztcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGJsb2NrSCA9IHVCbG9ja3NpemUgKiB1U3RlcFc7XFxuJyArXG4gICAgICAgICdpbnQgcG9zWCA9IGludCh2VGV4Q29vcmQueCAvIGJsb2NrVyk7XFxuJyArXG4gICAgICAgICdpbnQgcG9zWSA9IGludCh2VGV4Q29vcmQueSAvIGJsb2NrSCk7XFxuJyArXG4gICAgICAgICdmbG9hdCBmcG9zWCA9IGZsb2F0KHBvc1gpO1xcbicgK1xuICAgICAgICAnZmxvYXQgZnBvc1kgPSBmbG9hdChwb3NZKTtcXG4nICtcbiAgICAgICAgJ3ZlYzIgc3F1YXJlQ29vcmRzID0gdmVjMihmcG9zWCAqIGJsb2NrVywgZnBvc1kgKiBibG9ja0gpO1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgc3F1YXJlQ29vcmRzKTtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIFBpeGVsYXRlIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBpTGVuID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICBqTGVuID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGluZGV4LCBpLCBqLCByLCBnLCBiLCBhLFxuICAgICAgICAgIF9pLCBfaiwgX2lMZW4sIF9qTGVuO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaUxlbjsgaSArPSB0aGlzLmJsb2Nrc2l6ZSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSB0aGlzLmJsb2Nrc2l6ZSkge1xuXG4gICAgICAgICAgaW5kZXggPSAoaSAqIDQpICogakxlbiArIChqICogNCk7XG5cbiAgICAgICAgICByID0gZGF0YVtpbmRleF07XG4gICAgICAgICAgZyA9IGRhdGFbaW5kZXggKyAxXTtcbiAgICAgICAgICBiID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgIGEgPSBkYXRhW2luZGV4ICsgM107XG5cbiAgICAgICAgICBfaUxlbiA9IE1hdGgubWluKGkgKyB0aGlzLmJsb2Nrc2l6ZSwgaUxlbik7XG4gICAgICAgICAgX2pMZW4gPSBNYXRoLm1pbihqICsgdGhpcy5ibG9ja3NpemUsIGpMZW4pO1xuICAgICAgICAgIGZvciAoX2kgPSBpOyBfaSA8IF9pTGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBmb3IgKF9qID0gajsgX2ogPCBfakxlbjsgX2orKykge1xuICAgICAgICAgICAgICBpbmRleCA9IChfaSAqIDQpICogakxlbiArIChfaiAqIDQpO1xuICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IHI7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAxXSA9IGc7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAyXSA9IGI7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXggKyAzXSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlIHdoZW4gdGhlIGZpbHRlciBpcyBub3QgZ29ubmEgYXBwbHkgY2hhbmdlcyB0byB0aGUgaW1hZ2VcbiAgICAgKiovXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmxvY2tzaXplID09PSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUJsb2Nrc2l6ZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1QmxvY2tzaXplJyksXG4gICAgICAgIHVTdGVwVzogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U3RlcFcnKSxcbiAgICAgICAgdVN0ZXBIOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTdGVwSCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudUJsb2Nrc2l6ZSwgdGhpcy5ibG9ja3NpemUpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB3aGl0ZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvcih7XG4gICAqICAgdGhyZXNob2xkOiAwLjIsXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5SZW1vdmVDb2xvciA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvci5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1JlbW92ZUNvbG9yJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRvIHJlbW92ZSwgaW4gYW55IGZvcm1hdCB1bmRlcnN0b29kIGJ5IGZhYnJpYy5Db2xvci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29sb3I6ICcjRkZGRkZGJyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIGJyaWdodG5lc3MgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjNCB1TG93O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjNCB1SGlnaDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2lmKGFsbChncmVhdGVyVGhhbihnbF9GcmFnQ29sb3IucmdiLHVMb3cucmdiKSkgJiYgYWxsKGdyZWF0ZXJUaGFuKHVIaWdoLnJnYixnbF9GcmFnQ29sb3IucmdiKSkpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSAwLjA7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBkaXN0YW5jZSB0byBhY3R1YWwgY29sb3IsIGFzIHZhbHVlIHVwIG9yIGRvd24gZnJvbSBlYWNoIHIsZyxiXG4gICAgICogYmV0d2VlbiAwIGFuZCAxXG4gICAgICoqL1xuICAgIGRpc3RhbmNlOiAwLjAyLFxuXG4gICAgLyoqXG4gICAgICogRm9yIGNvbG9yIHRvIHJlbW92ZSBpbnNpZGUgZGlzdGFuY2UsIHVzZSBhbHBoYSBjaGFubmVsIGZvciBhIHNtb290aGVyIGRlbGV0aW9uXG4gICAgICogTk9UIElNUExFTUVOVEVEIFlFVFxuICAgICAqKi9cbiAgICB1c2VBbHBoYTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVXaGl0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbG9yPSNSUkdHQkJdIFRocmVzaG9sZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kaXN0YW5jZT0xMF0gRGlzdGFuY2UgdmFsdWVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVyIHRvIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaSxcbiAgICAgICAgICBkaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2UgKiAyNTUsXG4gICAgICAgICAgciwgZywgYixcbiAgICAgICAgICBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGxvd0MgPSBbXG4gICAgICAgICAgICBzb3VyY2VbMF0gLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsxXSAtIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzJdIC0gZGlzdGFuY2UsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBoaWdoQyA9IFtcbiAgICAgICAgICAgIHNvdXJjZVswXSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzFdICsgZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMl0gKyBkaXN0YW5jZSxcbiAgICAgICAgICBdO1xuXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgICBpZiAociA+IGxvd0NbMF0gJiZcbiAgICAgICAgICAgIGcgPiBsb3dDWzFdICYmXG4gICAgICAgICAgICBiID4gbG93Q1syXSAmJlxuICAgICAgICAgICAgciA8IGhpZ2hDWzBdICYmXG4gICAgICAgICAgICBnIDwgaGlnaENbMV0gJiZcbiAgICAgICAgICAgIGIgPCBoaWdoQ1syXSkge1xuICAgICAgICAgIGRhdGFbaSArIDNdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUxvdzogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1TG93JyksXG4gICAgICAgIHVIaWdoOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VIaWdoJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBkaXN0YW5jZSA9IHBhcnNlRmxvYXQodGhpcy5kaXN0YW5jZSksXG4gICAgICAgICAgbG93QyA9IFtcbiAgICAgICAgICAgIDAgKyBzb3VyY2VbMF0gLyAyNTUgLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIDAgKyBzb3VyY2VbMV0gLyAyNTUgLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIDAgKyBzb3VyY2VbMl0gLyAyNTUgLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICBdLFxuICAgICAgICAgIGhpZ2hDID0gW1xuICAgICAgICAgICAgc291cmNlWzBdIC8gMjU1ICsgZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMV0gLyAyNTUgKyBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsyXSAvIDI1NSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgMVxuICAgICAgICAgIF07XG4gICAgICBnbC51bmlmb3JtNGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUxvdywgbG93Qyk7XG4gICAgICBnbC51bmlmb3JtNGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUhpZ2gsIGhpZ2hDKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgIGRpc3RhbmNlOiB0aGlzLmRpc3RhbmNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3J9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZVdoaXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvci5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICB2YXIgbWF0cmljZXMgPSB7XG4gICAgQnJvd25pZTogW1xuICAgICAgMC41OTk3MCwwLjM0NTUzLC0wLjI3MDgyLDAsMC4xODYsXG4gICAgICAtMC4wMzc3MCwwLjg2MDk1LDAuMTUwNTksMCwtMC4xNDQ5LFxuICAgICAgMC4yNDExMywtMC4wNzQ0MSwwLjQ0OTcyLDAsLTAuMDI5NjUsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIFZpbnRhZ2U6IFtcbiAgICAgIDAuNjI3OTMsMC4zMjAyMSwtMC4wMzk2NSwwLDAuMDM3ODQsXG4gICAgICAwLjAyNTc4LDAuNjQ0MTEsMC4wMzI1OSwwLDAuMDI5MjYsXG4gICAgICAwLjA0NjYwLC0wLjA4NTEyLDAuNTI0MTYsMCwwLjAyMDIzLFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBLb2RhY2hyb21lOiBbXG4gICAgICAxLjEyODU1LC0wLjM5NjczLC0wLjAzOTkyLDAsMC4yNDk5MSxcbiAgICAgIC0wLjE2NDA0LDEuMDgzNTIsLTAuMDU0OTgsMCwwLjA5Njk4LFxuICAgICAgLTAuMTY3ODYsLTAuNTYwMzQsMS42MDE0OCwwLDAuMTM5NzIsXG4gICAgICAwLDAsMCwxLDBcbiAgICBdLFxuICAgIFRlY2huaWNvbG9yOiBbXG4gICAgICAxLjkxMjUyLC0wLjg1NDUzLC0wLjA5MTU1LDAsMC4wNDYyNCxcbiAgICAgIC0wLjMwODc4LDEuNzY1ODksLTAuMTA2MDEsMCwtMC4yNzU4OSxcbiAgICAgIC0wLjIzMTEwLC0wLjc1MDE4LDEuODQ3NTksMCwwLjEyMTM3LFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBQb2xhcm9pZDogW1xuICAgICAgMS40MzgsLTAuMDYyLC0wLjA2MiwwLDAsXG4gICAgICAtMC4xMjIsMS4zNzgsLTAuMTIyLDAsMCxcbiAgICAgIC0wLjAxNiwtMC4wMTYsMS40ODMsMCwwLFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBTZXBpYTogW1xuICAgICAgMC4zOTMsIDAuNzY5LCAwLjE4OSwgMCwgMCxcbiAgICAgIDAuMzQ5LCAwLjY4NiwgMC4xNjgsIDAsIDAsXG4gICAgICAwLjI3MiwgMC41MzQsIDAuMTMxLCAwLCAwLFxuICAgICAgMCwgMCwgMCwgMSwgMFxuICAgIF0sXG4gICAgQmxhY2tXaGl0ZTogW1xuICAgICAgMS41LCAxLjUsIDEuNSwgMCwgLTEsXG4gICAgICAxLjUsIDEuNSwgMS41LCAwLCAtMSxcbiAgICAgIDEuNSwgMS41LCAxLjUsIDAsIC0xLFxuICAgICAgMCwgMCwgMCwgMSwgMCxcbiAgICBdXG4gIH07XG5cbiAgZm9yICh2YXIga2V5IGluIG1hdHJpY2VzKSB7XG4gICAgZmlsdGVyc1trZXldID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5Db2xvck1hdHJpeCwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TZXBpYS5wcm90b3R5cGUgKi8ge1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpbHRlciB0eXBlXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAgICogQGRlZmF1bHRcbiAgICAgICAqL1xuICAgICAgdHlwZToga2V5LFxuXG4gICAgICAvKipcbiAgICAgICAqIENvbG9ybWF0cml4IGZvciB0aGUgZWZmZWN0XG4gICAgICAgKiBhcnJheSBvZiAyMCBmbG9hdHMuIE51bWJlcnMgaW4gcG9zaXRpb25zIDQsIDksIDE0LCAxOSBsb29zZSBtZWFuaW5nXG4gICAgICAgKiBvdXRzaWRlIHRoZSAtMSwgMSByYW5nZS5cbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBhcnJheSBvZiAyMCBudW1iZXJzLlxuICAgICAgICogQGRlZmF1bHRcbiAgICAgICAqL1xuICAgICAgbWF0cml4OiBtYXRyaWNlc1trZXldLFxuXG4gICAgICAvKipcbiAgICAgICAqIExvY2sgdGhlIG1hdHJpeCBleHBvcnQgZm9yIHRoaXMga2luZCBvZiBzdGF0aWMsIHBhcmFtZXRlciBsZXNzIGZpbHRlcnMuXG4gICAgICAgKi9cbiAgICAgIG1haW5QYXJhbWV0ZXI6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKiBMb2NrIHRoZSBjb2xvcm1hdHJpeCBvbiB0aGUgY29sb3IgcGFydCwgc2tpcHBpbmcgYWxwaGFcbiAgICAgICAqL1xuICAgICAgY29sb3JzT25seTogdHJ1ZSxcblxuICAgIH0pO1xuICAgIGZhYnJpYy5JbWFnZS5maWx0ZXJzW2tleV0uZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcbiAgfVxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQ29sb3IgQmxlbmQgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVyLkJsZW5kQ29sb3JcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yKHtcbiAgICogIGNvbG9yOiAnIzAwMCcsXG4gICAqICBtb2RlOiAnbXVsdGlwbHknXG4gICAqIH0pO1xuICAgKlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2Uoe1xuICAgKiAgaW1hZ2U6IGZhYnJpY0ltYWdlT2JqZWN0LFxuICAgKiAgbW9kZTogJ211bHRpcGx5JyxcbiAgICogIGFscGhhOiAwLjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuXG4gIGZpbHRlcnMuQmxlbmRDb2xvciA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZC5wcm90b3R5cGUgKi8ge1xuICAgIHR5cGU6ICdCbGVuZENvbG9yJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRvIG1ha2UgdGhlIGJsZW5kIG9wZXJhdGlvbiB3aXRoLiBkZWZhdWx0IHRvIGEgcmVkZGlzaCBjb2xvciBzaW5jZSBibGFjayBvciB3aGl0ZVxuICAgICAqIGdpdmVzIGFsd2F5cyBzdHJvbmcgcmVzdWx0LlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICoqL1xuICAgIGNvbG9yOiAnI0Y5NUM2MycsXG5cbiAgICAvKipcbiAgICAgKiBCbGVuZCBtb2RlIGZvciB0aGUgZmlsdGVyOiBvbmUgb2YgbXVsdGlwbHksIGFkZCwgZGlmZiwgc2NyZWVuLCBzdWJ0cmFjdCxcbiAgICAgKiBkYXJrZW4sIGxpZ2h0ZW4sIG92ZXJsYXksIGV4Y2x1c2lvbiwgdGludC5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqKi9cbiAgICBtb2RlOiAnbXVsdGlwbHknLFxuXG4gICAgLyoqXG4gICAgICogYWxwaGEgdmFsdWUuIHJlcHJlc2VudCB0aGUgc3RyZW5ndGggb2YgdGhlIGJsZW5kIGNvbG9yIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqKi9cbiAgICBhbHBoYTogMSxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIE11bHRpcGx5IHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZToge1xuICAgICAgbXVsdGlwbHk6ICdnbF9GcmFnQ29sb3IucmdiICo9IHVDb2xvci5yZ2I7XFxuJyxcbiAgICAgIHNjcmVlbjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSAxLjAgLSAoMS4wIC0gZ2xfRnJhZ0NvbG9yLnJnYikgKiAoMS4wIC0gdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIGFkZDogJ2dsX0ZyYWdDb2xvci5yZ2IgKz0gdUNvbG9yLnJnYjtcXG4nLFxuICAgICAgZGlmZjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSBhYnMoZ2xfRnJhZ0NvbG9yLnJnYiAtIHVDb2xvci5yZ2IpO1xcbicsXG4gICAgICBzdWJ0cmFjdDogJ2dsX0ZyYWdDb2xvci5yZ2IgLT0gdUNvbG9yLnJnYjtcXG4nLFxuICAgICAgbGlnaHRlbjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSBtYXgoZ2xfRnJhZ0NvbG9yLnJnYiwgdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIGRhcmtlbjogJ2dsX0ZyYWdDb2xvci5yZ2IgPSBtaW4oZ2xfRnJhZ0NvbG9yLnJnYiwgdUNvbG9yLnJnYik7XFxuJyxcbiAgICAgIGV4Y2x1c2lvbjogJ2dsX0ZyYWdDb2xvci5yZ2IgKz0gdUNvbG9yLnJnYiAtIDIuMCAqICh1Q29sb3IucmdiICogZ2xfRnJhZ0NvbG9yLnJnYik7XFxuJyxcbiAgICAgIG92ZXJsYXk6ICdpZiAodUNvbG9yLnIgPCAwLjUpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLnIgKj0gMi4wICogdUNvbG9yLnI7XFxuJyArXG4gICAgICAgICd9IGVsc2Uge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuciA9IDEuMCAtIDIuMCAqICgxLjAgLSBnbF9GcmFnQ29sb3IucikgKiAoMS4wIC0gdUNvbG9yLnIpO1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgICAnaWYgKHVDb2xvci5nIDwgMC41KSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5nICo9IDIuMCAqIHVDb2xvci5nO1xcbicgK1xuICAgICAgICAnfSBlbHNlIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmcgPSAxLjAgLSAyLjAgKiAoMS4wIC0gZ2xfRnJhZ0NvbG9yLmcpICogKDEuMCAtIHVDb2xvci5nKTtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ2lmICh1Q29sb3IuYiA8IDAuNSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYiAqPSAyLjAgKiB1Q29sb3IuYjtcXG4nICtcbiAgICAgICAgJ30gZWxzZSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5iID0gMS4wIC0gMi4wICogKDEuMCAtIGdsX0ZyYWdDb2xvci5iKSAqICgxLjAgLSB1Q29sb3IuYik7XFxuJyArXG4gICAgICAgICd9XFxuJyxcbiAgICAgIHRpbnQ6ICdnbF9GcmFnQ29sb3IucmdiICo9ICgxLjAgLSB1Q29sb3IuYSk7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IucmdiICs9IHVDb2xvci5yZ2I7XFxuJyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYnVpbGQgdGhlIGZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIGZpbHRlcnMsIGpvaW5pbmcgdGhlIGNvbW1vbiBwYXJ0IHdpdGhcbiAgICAgKiB0aGUgc3BlY2lmaWMgb25lLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlIHRoZSBtb2RlIG9mIHRoZSBmaWx0ZXIsIGEga2V5IG9mIHRoaXMuZnJhZ21lbnRTb3VyY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBzb3VyY2UgdG8gYmUgY29tcGlsZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ1aWxkU291cmNlOiBmdW5jdGlvbihtb2RlKSB7XG4gICAgICByZXR1cm4gJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAgICdpZiAoY29sb3IuYSA+IDAuMCkge1xcbicgK1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFNvdXJjZVttb2RlXSArXG4gICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ30nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgdGhpcy5tb2RlLCBzaGFkZXJTb3VyY2U7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICBzaGFkZXJTb3VyY2UgPSB0aGlzLmJ1aWxkU291cmNlKHRoaXMubW9kZSk7XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIHNoYWRlclNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQmxlbmQgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpTGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgdHIsIHRnLCB0YixcbiAgICAgICAgICByLCBnLCBiLFxuICAgICAgICAgIHNvdXJjZSwgYWxwaGExID0gMSAtIHRoaXMuYWxwaGE7XG5cbiAgICAgIHNvdXJjZSA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcikuZ2V0U291cmNlKCk7XG4gICAgICB0ciA9IHNvdXJjZVswXSAqIHRoaXMuYWxwaGE7XG4gICAgICB0ZyA9IHNvdXJjZVsxXSAqIHRoaXMuYWxwaGE7XG4gICAgICB0YiA9IHNvdXJjZVsyXSAqIHRoaXMuYWxwaGE7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaUxlbjsgaSArPSA0KSB7XG5cbiAgICAgICAgciA9IGRhdGFbaV07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgY2FzZSAnbXVsdGlwbHknOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgKiB0ciAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyAqIHRnIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiICogdGIgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdzY3JlZW4nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IDI1NSAtICgyNTUgLSByKSAqICgyNTUgLSB0cikgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IDI1NSAtICgyNTUgLSBnKSAqICgyNTUgLSB0ZykgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IDI1NSAtICgyNTUgLSBiKSAqICgyNTUgLSB0YikgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgKyB0cjtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyArIHRnO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiICsgdGI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkaWZmJzpcbiAgICAgICAgICBjYXNlICdkaWZmZXJlbmNlJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLmFicyhyIC0gdHIpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBNYXRoLmFicyhnIC0gdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLmFicyhiIC0gdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc3VidHJhY3QnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgLSB0cjtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyAtIHRnO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiIC0gdGI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkYXJrZW4nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IE1hdGgubWluKHIsIHRyKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTWF0aC5taW4oZywgdGcpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBNYXRoLm1pbihiLCB0Yik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdsaWdodGVuJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLm1heChyLCB0cik7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IE1hdGgubWF4KGcsIHRnKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5tYXgoYiwgdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb3ZlcmxheSc6XG4gICAgICAgICAgICBkYXRhW2ldID0gdHIgPCAxMjggPyAoMiAqIHIgKiB0ciAvIDI1NSkgOiAoMjU1IC0gMiAqICgyNTUgLSByKSAqICgyNTUgLSB0cikgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSB0ZyA8IDEyOCA/ICgyICogZyAqIHRnIC8gMjU1KSA6ICgyNTUgLSAyICogKDI1NSAtIGcpICogKDI1NSAtIHRnKSAvIDI1NSk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IHRiIDwgMTI4ID8gKDIgKiBiICogdGIgLyAyNTUpIDogKDI1NSAtIDIgKiAoMjU1IC0gYikgKiAoMjU1IC0gdGIpIC8gMjU1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2V4Y2x1c2lvbic6XG4gICAgICAgICAgICBkYXRhW2ldID0gdHIgKyByIC0gKCgyICogdHIgKiByKSAvIDI1NSk7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IHRnICsgZyAtICgoMiAqIHRnICogZykgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSB0YiArIGIgLSAoKDIgKiB0YiAqIGIpIC8gMjU1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RpbnQnOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHRyICsgciAqIGFscGhhMTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gdGcgKyBnICogYWxwaGExO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSB0YiArIGIgKiBhbHBoYTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVDb2xvcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29sb3InKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpO1xuICAgICAgc291cmNlWzBdID0gdGhpcy5hbHBoYSAqIHNvdXJjZVswXSAvIDI1NTtcbiAgICAgIHNvdXJjZVsxXSA9IHRoaXMuYWxwaGEgKiBzb3VyY2VbMV0gLyAyNTU7XG4gICAgICBzb3VyY2VbMl0gPSB0aGlzLmFscGhhICogc291cmNlWzJdIC8gMjU1O1xuICAgICAgc291cmNlWzNdID0gdGhpcy5hbHBoYTtcbiAgICAgIGdsLnVuaWZvcm00ZnYodW5pZm9ybUxvY2F0aW9ucy51Q29sb3IsIHNvdXJjZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGFscGhhOiB0aGlzLmFscGhhXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZENvbG9yLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEltYWdlIEJsZW5kIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlci5CbGVuZEltYWdlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvcih7XG4gICAqICBjb2xvcjogJyMwMDAnLFxuICAgKiAgbW9kZTogJ211bHRpcGx5J1xuICAgKiB9KTtcbiAgICpcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlKHtcbiAgICogIGltYWdlOiBmYWJyaWNJbWFnZU9iamVjdCxcbiAgICogIG1vZGU6ICdtdWx0aXBseScsXG4gICAqICBhbHBoYTogMC41XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cblxuICBmaWx0ZXJzLkJsZW5kSW1hZ2UgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZS5wcm90b3R5cGUgKi8ge1xuICAgIHR5cGU6ICdCbGVuZEltYWdlJyxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRvIG1ha2UgdGhlIGJsZW5kIG9wZXJhdGlvbiB3aXRoLiBkZWZhdWx0IHRvIGEgcmVkZGlzaCBjb2xvciBzaW5jZSBibGFjayBvciB3aGl0ZVxuICAgICAqIGdpdmVzIGFsd2F5cyBzdHJvbmcgcmVzdWx0LlxuICAgICAqKi9cbiAgICBpbWFnZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEJsZW5kIG1vZGUgZm9yIHRoZSBmaWx0ZXIgKG9uZSBvZiBcIm11bHRpcGx5XCIsIFwibWFza1wiKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICoqL1xuICAgIG1vZGU6ICdtdWx0aXBseScsXG5cbiAgICAvKipcbiAgICAgKiBhbHBoYSB2YWx1ZS4gcmVwcmVzZW50IHRoZSBzdHJlbmd0aCBvZiB0aGUgYmxlbmQgaW1hZ2Ugb3BlcmF0aW9uLlxuICAgICAqIG5vdCBpbXBsZW1lbnRlZC5cbiAgICAgKiovXG4gICAgYWxwaGE6IDEsXG5cbiAgICB2ZXJ0ZXhTb3VyY2U6ICdhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkMjtcXG4nICtcbiAgICAgICd1bmlmb3JtIG1hdDMgdVRyYW5zZm9ybU1hdHJpeDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2VGV4Q29vcmQgPSBhUG9zaXRpb247XFxuJyArXG4gICAgICAgICd2VGV4Q29vcmQyID0gKHVUcmFuc2Zvcm1NYXRyaXggKiB2ZWMzKGFQb3NpdGlvbiwgMS4wKSkueHk7XFxuJyArXG4gICAgICAgICdnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uICogMi4wIC0gMS4wLCAwLjAsIDEuMCk7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBNdWx0aXBseSBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIG11bHRpcGx5OiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1SW1hZ2U7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHZlYzQgdUNvbG9yO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQyO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yMiA9IHRleHR1cmUyRCh1SW1hZ2UsIHZUZXhDb29yZDIpO1xcbicgK1xuICAgICAgICAgICdjb2xvci5yZ2JhICo9IGNvbG9yMi5yZ2JhO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgbWFzazogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdUltYWdlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkMjtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvcjIgPSB0ZXh0dXJlMkQodUltYWdlLCB2VGV4Q29vcmQyKTtcXG4nICtcbiAgICAgICAgICAnY29sb3IuYSA9IGNvbG9yMi5hO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNhY2hlS2V5ID0gdGhpcy50eXBlICsgJ18nICsgdGhpcy5tb2RlO1xuICAgICAgdmFyIHNoYWRlclNvdXJjZSA9IHRoaXMuZnJhZ21lbnRTb3VyY2VbdGhpcy5tb2RlXTtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIHNoYWRlclNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICBhcHBseVRvV2ViR0w6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIC8vIGxvYWQgdGV4dHVyZSB0byBibGVuZC5cbiAgICAgIHZhciBnbCA9IG9wdGlvbnMuY29udGV4dCxcbiAgICAgICAgICB0ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKG9wdGlvbnMuZmlsdGVyQmFja2VuZCwgdGhpcy5pbWFnZSk7XG4gICAgICB0aGlzLmJpbmRBZGRpdGlvbmFsVGV4dHVyZShnbCwgdGV4dHVyZSwgZ2wuVEVYVFVSRTEpO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2FwcGx5VG9XZWJHTCcsIG9wdGlvbnMpO1xuICAgICAgdGhpcy51bmJpbmRBZGRpdGlvbmFsVGV4dHVyZShnbCwgZ2wuVEVYVFVSRTEpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVUZXh0dXJlOiBmdW5jdGlvbihiYWNrZW5kLCBpbWFnZSkge1xuICAgICAgcmV0dXJuIGJhY2tlbmQuZ2V0Q2FjaGVkVGV4dHVyZShpbWFnZS5jYWNoZUtleSwgaW1hZ2UuX2VsZW1lbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYSB0cmFuc2Zvcm1NYXRyaXggdG8gYWRhcHQgdGhlIGltYWdlIHRvIGJsZW5kIG92ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIGNhbGN1bGF0ZU1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlLFxuICAgICAgICAgIHdpZHRoID0gaW1hZ2UuX2VsZW1lbnQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gaW1hZ2UuX2VsZW1lbnQuaGVpZ2h0O1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgMSAvIGltYWdlLnNjYWxlWCwgMCwgMCxcbiAgICAgICAgMCwgMSAvIGltYWdlLnNjYWxlWSwgMCxcbiAgICAgICAgLWltYWdlLmxlZnQgLyB3aWR0aCwgLWltYWdlLnRvcCAvIGhlaWdodCwgMVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJsZW5kIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIHJlc291cmNlcyA9IG9wdGlvbnMuZmlsdGVyQmFja2VuZC5yZXNvdXJjZXMsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpTGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgd2lkdGggPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICB0ciwgdGcsIHRiLCB0YSxcbiAgICAgICAgICByLCBnLCBiLCBhLFxuICAgICAgICAgIGNhbnZhczEsIGNvbnRleHQsIGltYWdlID0gdGhpcy5pbWFnZSwgYmxlbmREYXRhO1xuXG4gICAgICBpZiAoIXJlc291cmNlcy5ibGVuZEltYWdlKSB7XG4gICAgICAgIHJlc291cmNlcy5ibGVuZEltYWdlID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgfVxuICAgICAgY2FudmFzMSA9IHJlc291cmNlcy5ibGVuZEltYWdlO1xuICAgICAgY29udGV4dCA9IGNhbnZhczEuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGlmIChjYW52YXMxLndpZHRoICE9PSB3aWR0aCB8fCBjYW52YXMxLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgIGNhbnZhczEud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzMS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LnNldFRyYW5zZm9ybShpbWFnZS5zY2FsZVgsIDAsIDAsIGltYWdlLnNjYWxlWSwgaW1hZ2UubGVmdCwgaW1hZ2UudG9wKTtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLl9lbGVtZW50LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGJsZW5kRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlMZW47IGkgKz0gNCkge1xuXG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgYSA9IGRhdGFbaSArIDNdO1xuXG4gICAgICAgIHRyID0gYmxlbmREYXRhW2ldO1xuICAgICAgICB0ZyA9IGJsZW5kRGF0YVtpICsgMV07XG4gICAgICAgIHRiID0gYmxlbmREYXRhW2kgKyAyXTtcbiAgICAgICAgdGEgPSBibGVuZERhdGFbaSArIDNdO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICAgICAgY2FzZSAnbXVsdGlwbHknOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHIgKiB0ciAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gZyAqIHRnIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBiICogdGIgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAzXSA9IGEgKiB0YSAvIDI1NTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21hc2snOlxuICAgICAgICAgICAgZGF0YVtpICsgM10gPSB0YTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1VHJhbnNmb3JtTWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VUcmFuc2Zvcm1NYXRyaXgnKSxcbiAgICAgICAgdUltYWdlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VJbWFnZScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuY2FsY3VsYXRlTWF0cml4KCk7XG4gICAgICBnbC51bmlmb3JtMWkodW5pZm9ybUxvY2F0aW9ucy51SW1hZ2UsIDEpOyAvLyB0ZXh0dXJlIHVuaXQgMS5cbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodW5pZm9ybUxvY2F0aW9ucy51VHJhbnNmb3JtTWF0cml4LCBmYWxzZSwgbWF0cml4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgaW1hZ2U6IHRoaXMuaW1hZ2UgJiYgdGhpcy5pbWFnZS50b09iamVjdCgpLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGFscGhhOiB0aGlzLmFscGhhXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZhYnJpYy5JbWFnZS5mcm9tT2JqZWN0KG9iamVjdC5pbWFnZSwgZnVuY3Rpb24oaW1hZ2UpIHtcbiAgICAgIHZhciBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9iamVjdCk7XG4gICAgICBvcHRpb25zLmltYWdlID0gaW1hZ2U7XG4gICAgICBjYWxsYmFjayhuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZShvcHRpb25zKSk7XG4gICAgfSk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksIHBvdyA9IE1hdGgucG93LCBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICBzcXJ0ID0gTWF0aC5zcXJ0LCBhYnMgPSBNYXRoLmFicywgcm91bmQgPSBNYXRoLnJvdW5kLCBzaW4gPSBNYXRoLnNpbixcbiAgICAgIGNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBSZXNpemUgaW1hZ2UgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZSgpO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgKi9cbiAgZmlsdGVycy5SZXNpemUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnUmVzaXplJyxcblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZSB0eXBlXG4gICAgICogZm9yIHdlYmdsIHJlc2l6ZVR5cGUgaXMganVzdCBsYW5jem9zLCBmb3IgY2FudmFzMmQgY2FuIGJlOlxuICAgICAqIGJpbGluZWFyLCBoZXJtaXRlLCBzbGljZUhhY2ssIGxhbmN6b3MuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlc2l6ZVR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJlc2l6ZVR5cGU6ICdoZXJtaXRlJyxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIGZhY3RvciBmb3IgcmVzaXppbmcsIHggYXhpc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVhcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNjYWxlWDogMSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIGZhY3RvciBmb3IgcmVzaXppbmcsIHkgYXhpc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVlcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNjYWxlWTogMSxcblxuICAgIC8qKlxuICAgICAqIExhbmN6b3NMb2JlcyBwYXJhbWV0ZXIgZm9yIGxhbmN6b3MgZmlsdGVyLCB2YWxpZCBmb3IgcmVzaXplVHlwZSBsYW5jem9zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxhbmN6b3NMb2Jlc1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbGFuY3pvc0xvYmVzOiAzLFxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdURlbHRhOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VEZWx0YScpLFxuICAgICAgICB1VGFwczogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1VGFwcycpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTJmdih1bmlmb3JtTG9jYXRpb25zLnVEZWx0YSwgdGhpcy5ob3Jpem9udGFsID8gWzEgLyB0aGlzLndpZHRoLCAwXSA6IFswLCAxIC8gdGhpcy5oZWlnaHRdKTtcbiAgICAgIGdsLnVuaWZvcm0xZnYodW5pZm9ybUxvY2F0aW9ucy51VGFwcywgdGhpcy50YXBzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBmaWx0ZXJXaW5kb3cgPSB0aGlzLmdldEZpbHRlcldpbmRvdygpLCBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIGZpbHRlcldpbmRvdztcbiAgICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHRoaXMuZ2VuZXJhdGVTaGFkZXIoZmlsdGVyV2luZG93KTtcbiAgICAgICAgb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCwgZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9LFxuXG4gICAgZ2V0RmlsdGVyV2luZG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMudGVtcFNjYWxlO1xuICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmxhbmN6b3NMb2JlcyAvIHNjYWxlKTtcbiAgICB9LFxuXG4gICAgZ2V0VGFwczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbG9iZUZ1bmN0aW9uID0gdGhpcy5sYW5jem9zQ3JlYXRlKHRoaXMubGFuY3pvc0xvYmVzKSwgc2NhbGUgPSB0aGlzLnRlbXBTY2FsZSxcbiAgICAgICAgICBmaWx0ZXJXaW5kb3cgPSB0aGlzLmdldEZpbHRlcldpbmRvdygpLCB0YXBzID0gbmV3IEFycmF5KGZpbHRlcldpbmRvdyk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBmaWx0ZXJXaW5kb3c7IGkrKykge1xuICAgICAgICB0YXBzW2kgLSAxXSA9IGxvYmVGdW5jdGlvbihpICogc2NhbGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHZlcnRleCBhbmQgc2hhZGVyIHNvdXJjZXMgZnJvbSB0aGUgbmVjZXNzYXJ5IHN0ZXBzIG51bWJlcnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZmlsdGVyV2luZG93XG4gICAgICovXG4gICAgZ2VuZXJhdGVTaGFkZXI6IGZ1bmN0aW9uKGZpbHRlcldpbmRvdykge1xuICAgICAgdmFyIG9mZnNldHMgPSBuZXcgQXJyYXkoZmlsdGVyV2luZG93KSxcbiAgICAgICAgICBmcmFnbWVudFNoYWRlciA9IHRoaXMuZnJhZ21lbnRTb3VyY2VUT1AsIGZpbHRlcldpbmRvdztcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gZmlsdGVyV2luZG93OyBpKyspIHtcbiAgICAgICAgb2Zmc2V0c1tpIC0gMV0gPSBpICsgJy4wICogdURlbHRhJztcbiAgICAgIH1cblxuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJ3VuaWZvcm0gZmxvYXQgdVRhcHNbJyArIGZpbHRlcldpbmRvdyArICddO1xcbic7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAndm9pZCBtYWluKCkge1xcbic7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAnICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbic7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAnICBmbG9hdCBzdW0gPSAxLjA7XFxuJztcblxuICAgICAgb2Zmc2V0cy5mb3JFYWNoKGZ1bmN0aW9uKG9mZnNldCwgaSkge1xuICAgICAgICBmcmFnbWVudFNoYWRlciArPSAnICBjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArICcgKyBvZmZzZXQgKyAnKSAqIHVUYXBzWycgKyBpICsgJ107XFxuJztcbiAgICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgLSAnICsgb2Zmc2V0ICsgJykgKiB1VGFwc1snICsgaSArICddO1xcbic7XG4gICAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIHN1bSArPSAyLjAgKiB1VGFwc1snICsgaSArICddO1xcbic7XG4gICAgICB9KTtcbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIGdsX0ZyYWdDb2xvciA9IGNvbG9yIC8gc3VtO1xcbic7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAnfSc7XG4gICAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG4gICAgfSxcblxuICAgIGZyYWdtZW50U291cmNlVE9QOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjMiB1RGVsdGE7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nLFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIHJlc2l6ZSBmaWx0ZXIgdG8gdGhlIGltYWdlXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHVzZSBXZWJHTCBvciBDYW52YXMyRCBiYXNlZCBvbiB0aGUgb3B0aW9ucy53ZWJnbCBmbGFnLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYXNzZXMgVGhlIG51bWJlciBvZiBmaWx0ZXJzIHJlbWFpbmluZyB0byBiZSBleGVjdXRlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy53ZWJnbCBXaGV0aGVyIHRvIHVzZSB3ZWJnbCB0byByZW5kZXIgdGhlIGZpbHRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlIFRoZSB0ZXh0dXJlIHNldHVwIGFzIHRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMudGFyZ2V0VGV4dHVyZSBUaGUgdGV4dHVyZSB3aGVyZSBmaWx0ZXJlZCBvdXRwdXQgc2hvdWxkIGJlIGRyYXduLlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLndlYmdsKSB7XG4gICAgICAgIG9wdGlvbnMucGFzc2VzKys7XG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRpb25zLnNvdXJjZVdpZHRoO1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSB0cnVlO1xuICAgICAgICB0aGlzLmRXID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoICogdGhpcy5zY2FsZVgpO1xuICAgICAgICB0aGlzLmRIID0gb3B0aW9ucy5zb3VyY2VIZWlnaHQ7XG4gICAgICAgIHRoaXMudGVtcFNjYWxlID0gdGhpcy5kVyAvIHRoaXMud2lkdGg7XG4gICAgICAgIHRoaXMudGFwcyA9IHRoaXMuZ2V0VGFwcygpO1xuICAgICAgICBvcHRpb25zLmRlc3RpbmF0aW9uV2lkdGggPSB0aGlzLmRXO1xuICAgICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLnNvdXJjZVdpZHRoID0gb3B0aW9ucy5kZXN0aW5hdGlvbldpZHRoO1xuXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5zb3VyY2VIZWlnaHQ7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRIID0gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHRoaXMuc2NhbGVZKTtcbiAgICAgICAgdGhpcy50ZW1wU2NhbGUgPSB0aGlzLmRIIC8gdGhpcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMudGFwcyA9IHRoaXMuZ2V0VGFwcygpO1xuICAgICAgICBvcHRpb25zLmRlc3RpbmF0aW9uSGVpZ2h0ID0gdGhpcy5kSDtcbiAgICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3N3YXBUZXh0dXJlcyhvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5zb3VyY2VIZWlnaHQgPSBvcHRpb25zLmRlc3RpbmF0aW9uSGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwbHlUbzJkKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY2FsZVggPT09IDEgJiYgdGhpcy5zY2FsZVkgPT09IDE7XG4gICAgfSxcblxuICAgIGxhbmN6b3NDcmVhdGU6IGZ1bmN0aW9uKGxvYmVzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoeCA+PSBsb2JlcyB8fCB4IDw9IC1sb2Jlcykge1xuICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPCAxLjE5MjA5MjkwRS0wNyAmJiB4ID4gLTEuMTkyMDkyOTBFLTA3KSB7XG4gICAgICAgICAgcmV0dXJuIDEuMDtcbiAgICAgICAgfVxuICAgICAgICB4ICo9IE1hdGguUEk7XG4gICAgICAgIHZhciB4eCA9IHggLyBsb2JlcztcbiAgICAgICAgcmV0dXJuIChzaW4oeCkgLyB4KSAqIHNpbih4eCkgLyB4eDtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsdGVyIHRvIGNhbnZhcyBlbGVtZW50XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVlcbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBzY2FsZVggPSB0aGlzLnNjYWxlWCxcbiAgICAgICAgICBzY2FsZVkgPSB0aGlzLnNjYWxlWTtcblxuICAgICAgdGhpcy5yY3BTY2FsZVggPSAxIC8gc2NhbGVYO1xuICAgICAgdGhpcy5yY3BTY2FsZVkgPSAxIC8gc2NhbGVZO1xuXG4gICAgICB2YXIgb1cgPSBpbWFnZURhdGEud2lkdGgsIG9IID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICBkVyA9IHJvdW5kKG9XICogc2NhbGVYKSwgZEggPSByb3VuZChvSCAqIHNjYWxlWSksXG4gICAgICAgICAgbmV3RGF0YTtcblxuICAgICAgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ3NsaWNlSGFjaycpIHtcbiAgICAgICAgbmV3RGF0YSA9IHRoaXMuc2xpY2VCeVR3byhvcHRpb25zLCBvVywgb0gsIGRXLCBkSCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnJlc2l6ZVR5cGUgPT09ICdoZXJtaXRlJykge1xuICAgICAgICBuZXdEYXRhID0gdGhpcy5oZXJtaXRlRmFzdFJlc2l6ZShvcHRpb25zLCBvVywgb0gsIGRXLCBkSCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnJlc2l6ZVR5cGUgPT09ICdiaWxpbmVhcicpIHtcbiAgICAgICAgbmV3RGF0YSA9IHRoaXMuYmlsaW5lYXJGaWx0ZXJpbmcob3B0aW9ucywgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnbGFuY3pvcycpIHtcbiAgICAgICAgbmV3RGF0YSA9IHRoaXMubGFuY3pvc1Jlc2l6ZShvcHRpb25zLCBvVywgb0gsIGRXLCBkSCk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLmltYWdlRGF0YSA9IG5ld0RhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBzbGljZUJ5VHdvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBzbGljZUJ5VHdvOiBmdW5jdGlvbihvcHRpb25zLCBvVywgb0gsIGRXLCBkSCkge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIG11bHQgPSAwLjUsIGRvbmVXID0gZmFsc2UsIGRvbmVIID0gZmFsc2UsIHN0ZXBXID0gb1cgKiBtdWx0LFxuICAgICAgICAgIHN0ZXBIID0gb0ggKiBtdWx0LCByZXNvdXJjZXMgPSBmYWJyaWMuZmlsdGVyQmFja2VuZC5yZXNvdXJjZXMsXG4gICAgICAgICAgdG1wQ2FudmFzLCBjdHgsIHNYID0gMCwgc1kgPSAwLCBkWCA9IG9XLCBkWSA9IDA7XG4gICAgICBpZiAoIXJlc291cmNlcy5zbGljZUJ5VHdvKSB7XG4gICAgICAgIHJlc291cmNlcy5zbGljZUJ5VHdvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB9XG4gICAgICB0bXBDYW52YXMgPSByZXNvdXJjZXMuc2xpY2VCeVR3bztcbiAgICAgIGlmICh0bXBDYW52YXMud2lkdGggPCBvVyAqIDEuNSB8fCB0bXBDYW52YXMuaGVpZ2h0IDwgb0gpIHtcbiAgICAgICAgdG1wQ2FudmFzLndpZHRoID0gb1cgKiAxLjU7XG4gICAgICAgIHRtcENhbnZhcy5oZWlnaHQgPSBvSDtcbiAgICAgIH1cbiAgICAgIGN0eCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBvVyAqIDEuNSwgb0gpO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuXG4gICAgICBkVyA9IGZsb29yKGRXKTtcbiAgICAgIGRIID0gZmxvb3IoZEgpO1xuXG4gICAgICB3aGlsZSAoIWRvbmVXIHx8ICFkb25lSCkge1xuICAgICAgICBvVyA9IHN0ZXBXO1xuICAgICAgICBvSCA9IHN0ZXBIO1xuICAgICAgICBpZiAoZFcgPCBmbG9vcihzdGVwVyAqIG11bHQpKSB7XG4gICAgICAgICAgc3RlcFcgPSBmbG9vcihzdGVwVyAqIG11bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHN0ZXBXID0gZFc7XG4gICAgICAgICAgZG9uZVcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkSCA8IGZsb29yKHN0ZXBIICogbXVsdCkpIHtcbiAgICAgICAgICBzdGVwSCA9IGZsb29yKHN0ZXBIICogbXVsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3RlcEggPSBkSDtcbiAgICAgICAgICBkb25lSCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0bXBDYW52YXMsIHNYLCBzWSwgb1csIG9ILCBkWCwgZFksIHN0ZXBXLCBzdGVwSCk7XG4gICAgICAgIHNYID0gZFg7XG4gICAgICAgIHNZID0gZFk7XG4gICAgICAgIGRZICs9IHN0ZXBIO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN0eC5nZXRJbWFnZURhdGEoc1gsIHNZLCBkVywgZEgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgbGFuY3pvc1Jlc2l6ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb1cgT3JpZ2luYWwgV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb0ggT3JpZ2luYWwgSGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRXIERlc3RpbmF0aW9uIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRIIERlc3RpbmF0aW9uIEhlaWdodFxuICAgICAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gICAgICovXG4gICAgbGFuY3pvc1Jlc2l6ZTogZnVuY3Rpb24ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpIHtcblxuICAgICAgZnVuY3Rpb24gcHJvY2Vzcyh1KSB7XG4gICAgICAgIHZhciB2LCBpLCB3ZWlnaHQsIGlkeCwgYSwgcmVkLCBncmVlbixcbiAgICAgICAgICAgIGJsdWUsIGFscGhhLCBmWCwgZlk7XG4gICAgICAgIGNlbnRlci54ID0gKHUgKyAwLjUpICogcmF0aW9YO1xuICAgICAgICBpY2VudGVyLnggPSBmbG9vcihjZW50ZXIueCk7XG4gICAgICAgIGZvciAodiA9IDA7IHYgPCBkSDsgdisrKSB7XG4gICAgICAgICAgY2VudGVyLnkgPSAodiArIDAuNSkgKiByYXRpb1k7XG4gICAgICAgICAgaWNlbnRlci55ID0gZmxvb3IoY2VudGVyLnkpO1xuICAgICAgICAgIGEgPSAwOyByZWQgPSAwOyBncmVlbiA9IDA7IGJsdWUgPSAwOyBhbHBoYSA9IDA7XG4gICAgICAgICAgZm9yIChpID0gaWNlbnRlci54IC0gcmFuZ2UyWDsgaSA8PSBpY2VudGVyLnggKyByYW5nZTJYOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID49IG9XKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZlggPSBmbG9vcigxMDAwICogYWJzKGkgLSBjZW50ZXIueCkpO1xuICAgICAgICAgICAgaWYgKCFjYWNoZUxhbmNbZlhdKSB7XG4gICAgICAgICAgICAgIGNhY2hlTGFuY1tmWF0gPSB7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaWNlbnRlci55IC0gcmFuZ2UyWTsgaiA8PSBpY2VudGVyLnkgKyByYW5nZTJZOyBqKyspIHtcbiAgICAgICAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gb0gpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmWSA9IGZsb29yKDEwMDAgKiBhYnMoaiAtIGNlbnRlci55KSk7XG4gICAgICAgICAgICAgIGlmICghY2FjaGVMYW5jW2ZYXVtmWV0pIHtcbiAgICAgICAgICAgICAgICBjYWNoZUxhbmNbZlhdW2ZZXSA9IGxhbmN6b3Moc3FydChwb3coZlggKiByY3BSYXRpb1gsIDIpICsgcG93KGZZICogcmNwUmF0aW9ZLCAyKSkgLyAxMDAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3ZWlnaHQgPSBjYWNoZUxhbmNbZlhdW2ZZXTtcbiAgICAgICAgICAgICAgaWYgKHdlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZHggPSAoaiAqIG9XICsgaSkgKiA0O1xuICAgICAgICAgICAgICAgIGEgKz0gd2VpZ2h0O1xuICAgICAgICAgICAgICAgIHJlZCArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeF07XG4gICAgICAgICAgICAgICAgZ3JlZW4gKz0gd2VpZ2h0ICogc3JjRGF0YVtpZHggKyAxXTtcbiAgICAgICAgICAgICAgICBibHVlICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4ICsgMl07XG4gICAgICAgICAgICAgICAgYWxwaGEgKz0gd2VpZ2h0ICogc3JjRGF0YVtpZHggKyAzXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZHggPSAodiAqIGRXICsgdSkgKiA0O1xuICAgICAgICAgIGRlc3REYXRhW2lkeF0gPSByZWQgLyBhO1xuICAgICAgICAgIGRlc3REYXRhW2lkeCArIDFdID0gZ3JlZW4gLyBhO1xuICAgICAgICAgIGRlc3REYXRhW2lkeCArIDJdID0gYmx1ZSAvIGE7XG4gICAgICAgICAgZGVzdERhdGFbaWR4ICsgM10gPSBhbHBoYSAvIGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKyt1IDwgZFcpIHtcbiAgICAgICAgICByZXR1cm4gcHJvY2Vzcyh1KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVzdEltZztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3JjRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgZGVzdEltZyA9IG9wdGlvbnMuY3R4LmNyZWF0ZUltYWdlRGF0YShkVywgZEgpLFxuICAgICAgICAgIGRlc3REYXRhID0gZGVzdEltZy5kYXRhLFxuICAgICAgICAgIGxhbmN6b3MgPSB0aGlzLmxhbmN6b3NDcmVhdGUodGhpcy5sYW5jem9zTG9iZXMpLFxuICAgICAgICAgIHJhdGlvWCA9IHRoaXMucmNwU2NhbGVYLCByYXRpb1kgPSB0aGlzLnJjcFNjYWxlWSxcbiAgICAgICAgICByY3BSYXRpb1ggPSAyIC8gdGhpcy5yY3BTY2FsZVgsIHJjcFJhdGlvWSA9IDIgLyB0aGlzLnJjcFNjYWxlWSxcbiAgICAgICAgICByYW5nZTJYID0gY2VpbChyYXRpb1ggKiB0aGlzLmxhbmN6b3NMb2JlcyAvIDIpLFxuICAgICAgICAgIHJhbmdlMlkgPSBjZWlsKHJhdGlvWSAqIHRoaXMubGFuY3pvc0xvYmVzIC8gMiksXG4gICAgICAgICAgY2FjaGVMYW5jID0geyB9LCBjZW50ZXIgPSB7IH0sIGljZW50ZXIgPSB7IH07XG5cbiAgICAgIHJldHVybiBwcm9jZXNzKDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBiaWxpbmVhckZpbHRlcmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb1cgT3JpZ2luYWwgV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb0ggT3JpZ2luYWwgSGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRXIERlc3RpbmF0aW9uIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRIIERlc3RpbmF0aW9uIEhlaWdodFxuICAgICAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gICAgICovXG4gICAgYmlsaW5lYXJGaWx0ZXJpbmc6IGZ1bmN0aW9uKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKSB7XG4gICAgICB2YXIgYSwgYiwgYywgZCwgeCwgeSwgaSwgaiwgeERpZmYsIHlEaWZmLCBjaG5sLFxuICAgICAgICAgIGNvbG9yLCBvZmZzZXQgPSAwLCBvcmlnUGl4LCByYXRpb1ggPSB0aGlzLnJjcFNjYWxlWCxcbiAgICAgICAgICByYXRpb1kgPSB0aGlzLnJjcFNjYWxlWSxcbiAgICAgICAgICB3NCA9IDQgKiAob1cgLSAxKSwgaW1nID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgcGl4ZWxzID0gaW1nLmRhdGEsIGRlc3RJbWFnZSA9IG9wdGlvbnMuY3R4LmNyZWF0ZUltYWdlRGF0YShkVywgZEgpLFxuICAgICAgICAgIGRlc3RQaXhlbHMgPSBkZXN0SW1hZ2UuZGF0YTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBkSDsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBkVzsgaisrKSB7XG4gICAgICAgICAgeCA9IGZsb29yKHJhdGlvWCAqIGopO1xuICAgICAgICAgIHkgPSBmbG9vcihyYXRpb1kgKiBpKTtcbiAgICAgICAgICB4RGlmZiA9IHJhdGlvWCAqIGogLSB4O1xuICAgICAgICAgIHlEaWZmID0gcmF0aW9ZICogaSAtIHk7XG4gICAgICAgICAgb3JpZ1BpeCA9IDQgKiAoeSAqIG9XICsgeCk7XG5cbiAgICAgICAgICBmb3IgKGNobmwgPSAwOyBjaG5sIDwgNDsgY2hubCsrKSB7XG4gICAgICAgICAgICBhID0gcGl4ZWxzW29yaWdQaXggKyBjaG5sXTtcbiAgICAgICAgICAgIGIgPSBwaXhlbHNbb3JpZ1BpeCArIDQgKyBjaG5sXTtcbiAgICAgICAgICAgIGMgPSBwaXhlbHNbb3JpZ1BpeCArIHc0ICsgY2hubF07XG4gICAgICAgICAgICBkID0gcGl4ZWxzW29yaWdQaXggKyB3NCArIDQgKyBjaG5sXTtcbiAgICAgICAgICAgIGNvbG9yID0gYSAqICgxIC0geERpZmYpICogKDEgLSB5RGlmZikgKyBiICogeERpZmYgKiAoMSAtIHlEaWZmKSArXG4gICAgICAgICAgICAgICAgICAgIGMgKiB5RGlmZiAqICgxIC0geERpZmYpICsgZCAqIHhEaWZmICogeURpZmY7XG4gICAgICAgICAgICBkZXN0UGl4ZWxzW29mZnNldCsrXSA9IGNvbG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc3RJbWFnZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaGVybWl0ZUZhc3RSZXNpemVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIGhlcm1pdGVGYXN0UmVzaXplOiBmdW5jdGlvbihvcHRpb25zLCBvVywgb0gsIGRXLCBkSCkge1xuICAgICAgdmFyIHJhdGlvVyA9IHRoaXMucmNwU2NhbGVYLCByYXRpb0ggPSB0aGlzLnJjcFNjYWxlWSxcbiAgICAgICAgICByYXRpb1dIYWxmID0gY2VpbChyYXRpb1cgLyAyKSxcbiAgICAgICAgICByYXRpb0hIYWxmID0gY2VpbChyYXRpb0ggLyAyKSxcbiAgICAgICAgICBpbWcgPSBvcHRpb25zLmltYWdlRGF0YSwgZGF0YSA9IGltZy5kYXRhLFxuICAgICAgICAgIGltZzIgPSBvcHRpb25zLmN0eC5jcmVhdGVJbWFnZURhdGEoZFcsIGRIKSwgZGF0YTIgPSBpbWcyLmRhdGE7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRIOyBqKyspIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkVzsgaSsrKSB7XG4gICAgICAgICAgdmFyIHgyID0gKGkgKyBqICogZFcpICogNCwgd2VpZ2h0ID0gMCwgd2VpZ2h0cyA9IDAsIHdlaWdodHNBbHBoYSA9IDAsXG4gICAgICAgICAgICAgIGd4UiA9IDAsIGd4RyA9IDAsIGd4QiA9IDAsIGd4QSA9IDAsIGNlbnRlclkgPSAoaiArIDAuNSkgKiByYXRpb0g7XG4gICAgICAgICAgZm9yICh2YXIgeXkgPSBmbG9vcihqICogcmF0aW9IKTsgeXkgPCAoaiArIDEpICogcmF0aW9IOyB5eSsrKSB7XG4gICAgICAgICAgICB2YXIgZHkgPSBhYnMoY2VudGVyWSAtICh5eSArIDAuNSkpIC8gcmF0aW9ISGFsZixcbiAgICAgICAgICAgICAgICBjZW50ZXJYID0gKGkgKyAwLjUpICogcmF0aW9XLCB3MCA9IGR5ICogZHk7XG4gICAgICAgICAgICBmb3IgKHZhciB4eCA9IGZsb29yKGkgKiByYXRpb1cpOyB4eCA8IChpICsgMSkgKiByYXRpb1c7IHh4KyspIHtcbiAgICAgICAgICAgICAgdmFyIGR4ID0gYWJzKGNlbnRlclggLSAoeHggKyAwLjUpKSAvIHJhdGlvV0hhbGYsXG4gICAgICAgICAgICAgICAgICB3ID0gc3FydCh3MCArIGR4ICogZHgpO1xuICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGggKi9cbiAgICAgICAgICAgICAgaWYgKHcgPiAxICYmIHcgPCAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vaGVybWl0ZSBmaWx0ZXJcbiAgICAgICAgICAgICAgd2VpZ2h0ID0gMiAqIHcgKiB3ICogdyAtIDMgKiB3ICogdyArIDE7XG4gICAgICAgICAgICAgIGlmICh3ZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgZHggPSA0ICogKHh4ICsgeXkgKiBvVyk7XG4gICAgICAgICAgICAgICAgLy9hbHBoYVxuICAgICAgICAgICAgICAgIGd4QSArPSB3ZWlnaHQgKiBkYXRhW2R4ICsgM107XG4gICAgICAgICAgICAgICAgd2VpZ2h0c0FscGhhICs9IHdlaWdodDtcbiAgICAgICAgICAgICAgICAvL2NvbG9yc1xuICAgICAgICAgICAgICAgIGlmIChkYXRhW2R4ICsgM10gPCAyNTUpIHtcbiAgICAgICAgICAgICAgICAgIHdlaWdodCA9IHdlaWdodCAqIGRhdGFbZHggKyAzXSAvIDI1MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ3hSICs9IHdlaWdodCAqIGRhdGFbZHhdO1xuICAgICAgICAgICAgICAgIGd4RyArPSB3ZWlnaHQgKiBkYXRhW2R4ICsgMV07XG4gICAgICAgICAgICAgICAgZ3hCICs9IHdlaWdodCAqIGRhdGFbZHggKyAyXTtcbiAgICAgICAgICAgICAgICB3ZWlnaHRzICs9IHdlaWdodDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1kZXB0aCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhMlt4Ml0gPSBneFIgLyB3ZWlnaHRzO1xuICAgICAgICAgIGRhdGEyW3gyICsgMV0gPSBneEcgLyB3ZWlnaHRzO1xuICAgICAgICAgIGRhdGEyW3gyICsgMl0gPSBneEIgLyB3ZWlnaHRzO1xuICAgICAgICAgIGRhdGEyW3gyICsgM10gPSBneEEgLyB3ZWlnaHRzQWxwaGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbWcyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBzY2FsZVg6IHRoaXMuc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHRoaXMuc2NhbGVZLFxuICAgICAgICByZXNpemVUeXBlOiB0aGlzLnJlc2l6ZVR5cGUsXG4gICAgICAgIGxhbmN6b3NMb2JlczogdGhpcy5sYW5jem9zTG9iZXNcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIENvbnRyYXN0IGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3RcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0KHtcbiAgICogICBjb250cmFzdDogMC4yNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkNvbnRyYXN0ID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQ29udHJhc3QnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1Q29udHJhc3Q7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnZmxvYXQgY29udHJhc3RGID0gMS4wMTUgKiAodUNvbnRyYXN0ICsgMS4wKSAvICgxLjAgKiAoMS4wMTUgLSB1Q29udHJhc3QpKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnJnYiA9IGNvbnRyYXN0RiAqIChjb2xvci5yZ2IgLSAwLjUpICsgMC41O1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBjb250cmFzdCB2YWx1ZSwgcmFuZ2UgZnJvbSAtMSB0byAxLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb250cmFzdFxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBjb250cmFzdDogMCxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdjb250cmFzdCcsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbnRyYXN0PTBdIFZhbHVlIHRvIGNvbnRyYXN0IHRoZSBpbWFnZSB1cCAoLTEuLi4xKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICAqIEFwcGx5IHRoZSBDb250cmFzdCBvcGVyYXRpb24gdG8gYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAgKlxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4QXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuY29udHJhc3QgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLCBpLCBsZW4sXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBjb250cmFzdCA9IE1hdGguZmxvb3IodGhpcy5jb250cmFzdCAqIDI1NSksXG4gICAgICAgICAgY29udHJhc3RGID0gMjU5ICogKGNvbnRyYXN0ICsgMjU1KSAvICgyNTUgKiAoMjU5IC0gY29udHJhc3QpKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSBjb250cmFzdEYgKiAoZGF0YVtpXSAtIDEyOCkgKyAxMjg7XG4gICAgICAgIGRhdGFbaSArIDFdID0gY29udHJhc3RGICogKGRhdGFbaSArIDFdIC0gMTI4KSArIDEyODtcbiAgICAgICAgZGF0YVtpICsgMl0gPSBjb250cmFzdEYgKiAoZGF0YVtpICsgMl0gLSAxMjgpICsgMTI4O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUNvbnRyYXN0OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VDb250cmFzdCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudUNvbnRyYXN0LCB0aGlzLmNvbnRyYXN0KTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0fSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFNhdHVyYXRlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uKHtcbiAgICogICBzYXR1cmF0aW9uOiAxXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuU2F0dXJhdGlvbiA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnU2F0dXJhdGlvbicsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVTYXR1cmF0aW9uO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IHJnTWF4ID0gbWF4KGNvbG9yLnIsIGNvbG9yLmcpO1xcbicgK1xuICAgICAgICAnZmxvYXQgcmdiTWF4ID0gbWF4KHJnTWF4LCBjb2xvci5iKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnIgKz0gcmdiTWF4ICE9IGNvbG9yLnIgPyAocmdiTWF4IC0gY29sb3IucikgKiB1U2F0dXJhdGlvbiA6IDAuMDA7XFxuJyArXG4gICAgICAgICdjb2xvci5nICs9IHJnYk1heCAhPSBjb2xvci5nID8gKHJnYk1heCAtIGNvbG9yLmcpICogdVNhdHVyYXRpb24gOiAwLjAwO1xcbicgK1xuICAgICAgICAnY29sb3IuYiArPSByZ2JNYXggIT0gY29sb3IuYiA/IChyZ2JNYXggLSBjb2xvci5iKSAqIHVTYXR1cmF0aW9uIDogMC4wMDtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogU2F0dXJhdGlvbiB2YWx1ZSwgZnJvbSAtMSB0byAxLlxuICAgICAqIEluY3JlYXNlcy9kZWNyZWFzZXMgdGhlIGNvbG9yIHNhdHVyYXRpb24uXG4gICAgICogQSB2YWx1ZSBvZiAwIGhhcyBubyBlZmZlY3QuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNhdHVyYXRpb25cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNhdHVyYXRpb246IDAsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnc2F0dXJhdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNhdHVyYXRlPTBdIFZhbHVlIHRvIHNhdHVyYXRlIHRoZSBpbWFnZSAoLTEuLi4xKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIFNhdHVyYXRpb24gb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5zYXR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGFkanVzdCA9IC10aGlzLnNhdHVyYXRpb24sIGksIG1heDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KGRhdGFbaV0sIGRhdGFbaSArIDFdLCBkYXRhW2kgKyAyXSk7XG4gICAgICAgIGRhdGFbaV0gKz0gbWF4ICE9PSBkYXRhW2ldID8gKG1heCAtIGRhdGFbaV0pICogYWRqdXN0IDogMDtcbiAgICAgICAgZGF0YVtpICsgMV0gKz0gbWF4ICE9PSBkYXRhW2kgKyAxXSA/IChtYXggLSBkYXRhW2kgKyAxXSkgKiBhZGp1c3QgOiAwO1xuICAgICAgICBkYXRhW2kgKyAyXSArPSBtYXggIT09IGRhdGFbaSArIDJdID8gKG1heCAtIGRhdGFbaSArIDJdKSAqIGFkanVzdCA6IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1U2F0dXJhdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2F0dXJhdGlvbicpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudVNhdHVyYXRpb24sIC10aGlzLnNhdHVyYXRpb24pO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbn0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGVcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb24uZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFZpYnJhbmNlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuVmlicmFuY2VcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuVmlicmFuY2UjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlZpYnJhbmNlKHtcbiAgICogICB2aWJyYW5jZTogMVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLlZpYnJhbmNlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlZpYnJhbmNlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnVmlicmFuY2UnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1VmlicmFuY2U7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnZmxvYXQgbWF4ID0gbWF4KGNvbG9yLnIsIG1heChjb2xvci5nLCBjb2xvci5iKSk7XFxuJyArXG4gICAgICAgICdmbG9hdCBhdmcgPSAoY29sb3IuciArIGNvbG9yLmcgKyBjb2xvci5iKSAvIDMuMDtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGFtdCA9IChhYnMobWF4IC0gYXZnKSAqIDIuMCkgKiB1VmlicmFuY2U7XFxuJyArXG4gICAgICAgICdjb2xvci5yICs9IG1heCAhPSBjb2xvci5yID8gKG1heCAtIGNvbG9yLnIpICogYW10IDogMC4wMDtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmcgKz0gbWF4ICE9IGNvbG9yLmcgPyAobWF4IC0gY29sb3IuZykgKiBhbXQgOiAwLjAwO1xcbicgK1xuICAgICAgICAnY29sb3IuYiArPSBtYXggIT0gY29sb3IuYiA/IChtYXggLSBjb2xvci5iKSAqIGFtdCA6IDAuMDA7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIFZpYnJhbmNlIHZhbHVlLCBmcm9tIC0xIHRvIDEuXG4gICAgICogSW5jcmVhc2VzL2RlY3JlYXNlcyB0aGUgc2F0dXJhdGlvbiBvZiBtb3JlIG11dGVkIGNvbG9ycyB3aXRoIGxlc3MgZWZmZWN0IG9uIHNhdHVyYXRlZCBjb2xvcnMuXG4gICAgICogQSB2YWx1ZSBvZiAwIGhhcyBubyBlZmZlY3QuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZpYnJhbmNlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB2aWJyYW5jZTogMCxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICd2aWJyYW5jZScsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5WaWJyYW5jZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpYnJhbmNlPTBdIFZpYnJhbmNlIHZhbHVlIGZvciB0aGUgaW1hZ2UgKGJldHdlZW4gLTEgYW5kIDEpXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgVmlicmFuY2Ugb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy52aWJyYW5jZSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBhZGp1c3QgPSAtdGhpcy52aWJyYW5jZSwgaSwgbWF4LCBhdmcsIGFtdDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KGRhdGFbaV0sIGRhdGFbaSArIDFdLCBkYXRhW2kgKyAyXSk7XG4gICAgICAgIGF2ZyA9IChkYXRhW2ldICsgZGF0YVtpICsgMV0gKyBkYXRhW2kgKyAyXSkgLyAzO1xuICAgICAgICBhbXQgPSAoKE1hdGguYWJzKG1heCAtIGF2ZykgKiAyIC8gMjU1KSAqIGFkanVzdCk7XG4gICAgICAgIGRhdGFbaV0gKz0gbWF4ICE9PSBkYXRhW2ldID8gKG1heCAtIGRhdGFbaV0pICogYW10IDogMDtcbiAgICAgICAgZGF0YVtpICsgMV0gKz0gbWF4ICE9PSBkYXRhW2kgKyAxXSA/IChtYXggLSBkYXRhW2kgKyAxXSkgKiBhbXQgOiAwO1xuICAgICAgICBkYXRhW2kgKyAyXSArPSBtYXggIT09IGRhdGFbaSArIDJdID8gKG1heCAtIGRhdGFbaSArIDJdKSAqIGFtdCA6IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1VmlicmFuY2U6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVZpYnJhbmNlJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51VmlicmFuY2UsIC10aGlzLnZpYnJhbmNlKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLlZpYnJhbmNlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5WaWJyYW5jZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuVmlicmFuY2UuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEJsdXIgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbHVyXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsdXIjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsdXIoe1xuICAgKiAgIGJsdXI6IDAuNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG4gIGZpbHRlcnMuQmx1ciA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbHVyLnByb3RvdHlwZSAqLyB7XG5cbiAgICB0eXBlOiAnQmx1cicsXG5cbiAgICAvKlxuJ2dsX0ZyYWdDb2xvciA9IHZlYzQoMC4wKTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTcgKiB1RGVsdGEpKjAuMDA0NDI5OTEyMTA1NTExMzI2NTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTYgKiB1RGVsdGEpKjAuMDA4OTU3ODEyMTE3OTQ7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC01ICogdURlbHRhKSowLjAyMTU5NjM4NjYwNTM7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC00ICogdURlbHRhKSowLjA0NDM2ODMzMzg3MTg7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC0zICogdURlbHRhKSowLjA3NzY3NDQyMTk5MzM7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC0yICogdURlbHRhKSowLjExNTg3NjYyMTEwNTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgLTEgKiB1RGVsdGEpKjAuMTQ3MzA4MDU2MTIxOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgICAgICAgICAgICAgICkqMC4xNTk1NzY5MTIxNjE7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDEgKiB1RGVsdGEpKjAuMTQ3MzA4MDU2MTIxOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAyICogdURlbHRhKSowLjExNTg3NjYyMTEwNTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgMyAqIHVEZWx0YSkqMC4wNzc2NzQ0MjE5OTMzOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyA0ICogdURlbHRhKSowLjA0NDM2ODMzMzg3MTg7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDUgKiB1RGVsdGEpKjAuMDIxNTk2Mzg2NjA1MzsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgNiAqIHVEZWx0YSkqMC4wMDg5NTc4MTIxMTc5NDsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgNyAqIHVEZWx0YSkqMC4wMDQ0Mjk5MTIxMDU1MTEzMjY1OycsXG4qL1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjMiB1RGVsdGE7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICdjb25zdCBmbG9hdCBuU2FtcGxlcyA9IDE1LjA7XFxuJyArXG4gICAgICAndmVjMyB2M29mZnNldCA9IHZlYzMoMTIuOTg5OCwgNzguMjMzLCAxNTEuNzE4Mik7XFxuJyArXG4gICAgICAnZmxvYXQgcmFuZG9tKHZlYzMgc2NhbGUpIHtcXG4nICtcbiAgICAgICAgLyogdXNlIHRoZSBmcmFnbWVudCBwb3NpdGlvbiBmb3IgYSBkaWZmZXJlbnQgc2VlZCBwZXItcGl4ZWwgKi9cbiAgICAgICAgJ3JldHVybiBmcmFjdChzaW4oZG90KGdsX0ZyYWdDb29yZC54eXosIHNjYWxlKSkgKiA0Mzc1OC41NDUzKTtcXG4nICtcbiAgICAgICd9XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IHRvdGFsID0gMC4wO1xcbicgK1xuICAgICAgICAnZmxvYXQgb2Zmc2V0ID0gcmFuZG9tKHYzb2Zmc2V0KTtcXG4nICtcbiAgICAgICAgJ2ZvciAoZmxvYXQgdCA9IC1uU2FtcGxlczsgdCA8PSBuU2FtcGxlczsgdCsrKSB7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IHBlcmNlbnQgPSAodCArIG9mZnNldCAtIDAuNSkgLyBuU2FtcGxlcztcXG4nICtcbiAgICAgICAgICAnZmxvYXQgd2VpZ2h0ID0gMS4wIC0gYWJzKHBlcmNlbnQpO1xcbicgK1xuICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIHVEZWx0YSAqIHBlcmNlbnQpICogd2VpZ2h0O1xcbicgK1xuICAgICAgICAgICd0b3RhbCArPSB3ZWlnaHQ7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvciAvIHRvdGFsO1xcbicgK1xuICAgICAgJ30nLFxuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4gICAgLyoqXG4gICAgICogYmx1ciB2YWx1ZSwgaW4gcGVyY2VudGFnZSBvZiBpbWFnZSBkaW1lbnNpb25zLlxuICAgICAqIHNwZWNpZmljIHRvIGtlZXAgdGhlIGltYWdlIGJsdXIgY29uc3RhbnQgYXQgZGlmZmVyZW50IHJlc29sdXRpb25zXG4gICAgICogcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgYmx1cjogMCxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdibHVyJyxcblxuICAgIGFwcGx5VG86IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLndlYmdsKSB7XG4gICAgICAgIC8vIHRoaXMgYXNwZWN0UmF0aW8gaXMgdXNlZCB0byBnaXZlIHRoZSBzYW1lIGJsdXIgdG8gdmVydGljYWwgYW5kIGhvcml6b250YWxcbiAgICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IG9wdGlvbnMuc291cmNlV2lkdGggLyBvcHRpb25zLnNvdXJjZUhlaWdodDtcbiAgICAgICAgb3B0aW9ucy5wYXNzZXMrKztcbiAgICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3N3YXBUZXh0dXJlcyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5hcHBseVRvMmQob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgLy8gcGFpbnQgY2FudmFzRWwgd2l0aCBjdXJyZW50IGltYWdlIGRhdGEuXG4gICAgICAvL29wdGlvbnMuY3R4LnB1dEltYWdlRGF0YShvcHRpb25zLmltYWdlRGF0YSwgMCwgMCk7XG4gICAgICBvcHRpb25zLmltYWdlRGF0YSA9IHRoaXMuc2ltcGxlQmx1cihvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgc2ltcGxlQmx1cjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHJlc291cmNlcyA9IG9wdGlvbnMuZmlsdGVyQmFja2VuZC5yZXNvdXJjZXMsIGNhbnZhczEsIGNhbnZhczIsXG4gICAgICAgICAgd2lkdGggPSBvcHRpb25zLmltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBvcHRpb25zLmltYWdlRGF0YS5oZWlnaHQ7XG5cbiAgICAgIGlmICghcmVzb3VyY2VzLmJsdXJMYXllcjEpIHtcbiAgICAgICAgcmVzb3VyY2VzLmJsdXJMYXllcjEgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAgIHJlc291cmNlcy5ibHVyTGF5ZXIyID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgfVxuICAgICAgY2FudmFzMSA9IHJlc291cmNlcy5ibHVyTGF5ZXIxO1xuICAgICAgY2FudmFzMiA9IHJlc291cmNlcy5ibHVyTGF5ZXIyO1xuICAgICAgaWYgKGNhbnZhczEud2lkdGggIT09IHdpZHRoIHx8IGNhbnZhczEuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgY2FudmFzMi53aWR0aCA9IGNhbnZhczEud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzMi5oZWlnaHQgPSBjYW52YXMxLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIH1cbiAgICAgIHZhciBjdHgxID0gY2FudmFzMS5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIGN0eDIgPSBjYW52YXMyLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgICAgblNhbXBsZXMgPSAxNSxcbiAgICAgICAgICByYW5kb20sIHBlcmNlbnQsIGosIGksXG4gICAgICAgICAgYmx1ciA9IHRoaXMuYmx1ciAqIDAuMDYgKiAwLjU7XG5cbiAgICAgIC8vIGxvYWQgZmlyc3QgY2FudmFzXG4gICAgICBjdHgxLnB1dEltYWdlRGF0YShvcHRpb25zLmltYWdlRGF0YSwgMCwgMCk7XG4gICAgICBjdHgyLmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgZm9yIChpID0gLW5TYW1wbGVzOyBpIDw9IG5TYW1wbGVzOyBpKyspIHtcbiAgICAgICAgcmFuZG9tID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpIC8gNDtcbiAgICAgICAgcGVyY2VudCA9IGkgLyBuU2FtcGxlcztcbiAgICAgICAgaiA9IGJsdXIgKiBwZXJjZW50ICogd2lkdGggKyByYW5kb207XG4gICAgICAgIGN0eDIuZ2xvYmFsQWxwaGEgPSAxIC0gTWF0aC5hYnMocGVyY2VudCk7XG4gICAgICAgIGN0eDIuZHJhd0ltYWdlKGNhbnZhczEsIGosIHJhbmRvbSk7XG4gICAgICAgIGN0eDEuZHJhd0ltYWdlKGNhbnZhczIsIDAsIDApO1xuICAgICAgICBjdHgyLmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgY3R4Mi5jbGVhclJlY3QoMCwgMCwgY2FudmFzMi53aWR0aCwgY2FudmFzMi5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gLW5TYW1wbGVzOyBpIDw9IG5TYW1wbGVzOyBpKyspIHtcbiAgICAgICAgcmFuZG9tID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpIC8gNDtcbiAgICAgICAgcGVyY2VudCA9IGkgLyBuU2FtcGxlcztcbiAgICAgICAgaiA9IGJsdXIgKiBwZXJjZW50ICogaGVpZ2h0ICsgcmFuZG9tO1xuICAgICAgICBjdHgyLmdsb2JhbEFscGhhID0gMSAtIE1hdGguYWJzKHBlcmNlbnQpO1xuICAgICAgICBjdHgyLmRyYXdJbWFnZShjYW52YXMxLCByYW5kb20sIGopO1xuICAgICAgICBjdHgxLmRyYXdJbWFnZShjYW52YXMyLCAwLCAwKTtcbiAgICAgICAgY3R4Mi5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIGN0eDIuY2xlYXJSZWN0KDAsIDAsIGNhbnZhczIud2lkdGgsIGNhbnZhczIuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuY3R4LmRyYXdJbWFnZShjYW52YXMxLCAwLCAwKTtcbiAgICAgIHZhciBuZXdJbWFnZURhdGEgPSBvcHRpb25zLmN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzMS53aWR0aCwgY2FudmFzMS5oZWlnaHQpO1xuICAgICAgY3R4MS5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICBjdHgxLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMxLndpZHRoLCBjYW52YXMxLmhlaWdodCk7XG4gICAgICByZXR1cm4gbmV3SW1hZ2VEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVsdGE6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndURlbHRhJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgZGVsdGEgPSB0aGlzLmNob29zZVJpZ2h0RGVsdGEoKTtcbiAgICAgIGdsLnVuaWZvcm0yZnYodW5pZm9ybUxvY2F0aW9ucy5kZWx0YSwgZGVsdGEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjaG9vc2UgcmlnaHQgdmFsdWUgb2YgaW1hZ2UgcGVyY2VudGFnZSB0byBibHVyIHdpdGhcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGEgbnVtZXJpYyBhcnJheSB3aXRoIGRlbHRhIHZhbHVlc1xuICAgICAqL1xuICAgIGNob29zZVJpZ2h0RGVsdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJsdXJTY2FsZSA9IDEsIGRlbHRhID0gWzAsIDBdLCBibHVyO1xuICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAodGhpcy5hc3BlY3RSYXRpbyA+IDEpIHtcbiAgICAgICAgICAvLyBpbWFnZSBpcyB3aWRlLCBpIHdhbnQgdG8gc2hyaW5rIHJhZGl1cyBob3Jpem9udGFsXG4gICAgICAgICAgYmx1clNjYWxlID0gMSAvIHRoaXMuYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5hc3BlY3RSYXRpbyA8IDEpIHtcbiAgICAgICAgICAvLyBpbWFnZSBpcyB0YWxsLCBpIHdhbnQgdG8gc2hyaW5rIHJhZGl1cyB2ZXJ0aWNhbFxuICAgICAgICAgIGJsdXJTY2FsZSA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJsdXIgPSBibHVyU2NhbGUgKiB0aGlzLmJsdXIgKiAwLjEyO1xuICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkge1xuICAgICAgICBkZWx0YVswXSA9IGJsdXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGVsdGFbMV0gPSBibHVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhIEpTT04gZGVmaW5pdGlvbiBvZiBhIEJsdXJGaWx0ZXIgaW50byBhIGNvbmNyZXRlIGluc3RhbmNlLlxuICAgKi9cbiAgZmlsdGVycy5CbHVyLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBHYW1tYSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYSh7XG4gICAqICAgZ2FtbWE6IFsxLCAwLjUsIDIuMV1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5HYW1tYSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0dhbW1hJyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gdmVjMyB1R2FtbWE7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAndmVjMyBjb3JyZWN0aW9uID0gKDEuMCAvIHVHYW1tYSk7XFxuJyArXG4gICAgICAgICdjb2xvci5yID0gcG93KGNvbG9yLnIsIGNvcnJlY3Rpb24ucik7XFxuJyArXG4gICAgICAgICdjb2xvci5nID0gcG93KGNvbG9yLmcsIGNvcnJlY3Rpb24uZyk7XFxuJyArXG4gICAgICAgICdjb2xvci5iID0gcG93KGNvbG9yLmIsIGNvcnJlY3Rpb24uYik7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3IuYTtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEdhbW1hIGFycmF5IHZhbHVlLCBmcm9tIDAuMDEgdG8gMi4yLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGdhbW1hXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBnYW1tYTogWzEsIDEsIDFdLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgdGhlIHByb3BlcnR5IHRoYXQgaXMgdGhlIGZpbHRlciBwYXJhbWV0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbWFpblBhcmFtZXRlcjogJ2dhbW1hJyxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZ2FtbWEgPSBbMSwgMSwgMV07XG4gICAgICBmaWx0ZXJzLkJhc2VGaWx0ZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEdhbW1hIG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSwgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGdhbW1hID0gdGhpcy5nYW1tYSwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgckludiA9IDEgLyBnYW1tYVswXSwgZ0ludiA9IDEgLyBnYW1tYVsxXSxcbiAgICAgICAgICBiSW52ID0gMSAvIGdhbW1hWzJdLCBpO1xuXG4gICAgICBpZiAoIXRoaXMuclZhbHMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuclZhbHMgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5nVmFscyA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLmJWYWxzID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gLSBwcmUtY29tcHV0ZSBhIGxvb2stdXAgdGFibGUgZm9yIGVhY2ggY29sb3IgY2hhbm5lbFxuICAgICAgLy8gaW5zdGVhZCBvZiBwZXJmb3JtaW5nIHRoZXNlIHBvdyBjYWxscyBmb3IgZWFjaCBwaXhlbCBpbiB0aGUgaW1hZ2UuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSAyNTY7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLnJWYWxzW2ldID0gTWF0aC5wb3coaSAvIDI1NSwgckludikgKiAyNTU7XG4gICAgICAgIHRoaXMuZ1ZhbHNbaV0gPSBNYXRoLnBvdyhpIC8gMjU1LCBnSW52KSAqIDI1NTtcbiAgICAgICAgdGhpcy5iVmFsc1tpXSA9IE1hdGgucG93KGkgLyAyNTUsIGJJbnYpICogMjU1O1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2ldID0gdGhpcy5yVmFsc1tkYXRhW2ldXTtcbiAgICAgICAgZGF0YVtpICsgMV0gPSB0aGlzLmdWYWxzW2RhdGFbaSArIDFdXTtcbiAgICAgICAgZGF0YVtpICsgMl0gPSB0aGlzLmJWYWxzW2RhdGFbaSArIDJdXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVHYW1tYTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1R2FtbWEnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0zZnYodW5pZm9ybUxvY2F0aW9ucy51R2FtbWEsIHRoaXMuZ2FtbWEpO1xuICAgIH0sXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWF9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYS5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQSBjb250YWluZXIgY2xhc3MgdGhhdCBrbm93cyBob3cgdG8gYXBwbHkgYSBzZXF1ZW5jZSBvZiBmaWx0ZXJzIHRvIGFuIGlucHV0IGltYWdlLlxuICAgKi9cbiAgZmlsdGVycy5Db21wb3NlZCA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db21wb3NlZC5wcm90b3R5cGUgKi8ge1xuXG4gICAgdHlwZTogJ0NvbXBvc2VkJyxcblxuICAgIC8qKlxuICAgICAqIEEgbm9uIHNwYXJzZSBhcnJheSBvZiBmaWx0ZXJzIHRvIGFwcGx5XG4gICAgICovXG4gICAgc3ViRmlsdGVyczogW10sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgLy8gY3JlYXRlIGEgbmV3IGFycmF5IGluc3RlYWQgbXV0YXRpbmcgdGhlIHByb3RvdHlwZSB3aXRoIHB1c2hcbiAgICAgIHRoaXMuc3ViRmlsdGVycyA9IHRoaXMuc3ViRmlsdGVycy5zbGljZSgwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhpcyBjb250YWluZXIncyBmaWx0ZXJzIHRvIHRoZSBpbnB1dCBpbWFnZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgYXBwbGllZC5cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zLnBhc3NlcyArPSB0aGlzLnN1YkZpbHRlcnMubGVuZ3RoIC0gMTtcbiAgICAgIHRoaXMuc3ViRmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICBmaWx0ZXIuYXBwbHlUbyhvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhpcyBmaWx0ZXIgaW50byBKU09OLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gQSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZmlsdGVyLlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIHN1YkZpbHRlcnM6IHRoaXMuc3ViRmlsdGVycy5tYXAoZnVuY3Rpb24oZmlsdGVyKSB7IHJldHVybiBmaWx0ZXIudG9PYmplY3QoKTsgfSksXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLnN1YkZpbHRlcnMuc29tZShmdW5jdGlvbihmaWx0ZXIpIHsgcmV0dXJuICFmaWx0ZXIuaXNOZXV0cmFsU3RhdGUoKTsgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgYSBKU09OIGRlZmluaXRpb24gb2YgYSBDb21wb3NlZEZpbHRlciBpbnRvIGEgY29uY3JldGUgaW5zdGFuY2UuXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db21wb3NlZC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBmaWx0ZXJzID0gb2JqZWN0LnN1YkZpbHRlcnMgfHwgW10sXG4gICAgICAgIHN1YkZpbHRlcnMgPSBmaWx0ZXJzLm1hcChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzW2ZpbHRlci50eXBlXShmaWx0ZXIpO1xuICAgICAgICB9KSxcbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQ29tcG9zZWQoeyBzdWJGaWx0ZXJzOiBzdWJGaWx0ZXJzIH0pO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogSHVlUm90YXRpb24gZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb24oe1xuICAgKiAgIHJvdGF0aW9uOiAtMC41XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuSHVlUm90YXRpb24gPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkNvbG9yTWF0cml4LCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnSHVlUm90YXRpb24nLFxuXG4gICAgLyoqXG4gICAgICogSHVlUm90YXRpb24gdmFsdWUsIGZyb20gLTEgdG8gMS5cbiAgICAgKiB0aGUgdW5pdCBpcyByYWRpYW5zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG15UGFyYW1ldGVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByb3RhdGlvbjogMCxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIHRoZSBwcm9wZXJ0eSB0aGF0IGlzIHRoZSBmaWx0ZXIgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1haW5QYXJhbWV0ZXI6ICdyb3RhdGlvbicsXG5cbiAgICBjYWxjdWxhdGVNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJhZCA9IHRoaXMucm90YXRpb24gKiBNYXRoLlBJLCBjb3MgPSBmYWJyaWMudXRpbC5jb3MocmFkKSwgc2luID0gZmFicmljLnV0aWwuc2luKHJhZCksXG4gICAgICAgICAgYVRoaXJkID0gMSAvIDMsIGFUaGlyZFNxdFNpbiA9IE1hdGguc3FydChhVGhpcmQpICogc2luLCBPbmVNaW51c0NvcyA9IDEgLSBjb3M7XG4gICAgICB0aGlzLm1hdHJpeCA9IFtcbiAgICAgICAgMSwgMCwgMCwgMCwgMCxcbiAgICAgICAgMCwgMSwgMCwgMCwgMCxcbiAgICAgICAgMCwgMCwgMSwgMCwgMCxcbiAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgICAgXTtcbiAgICAgIHRoaXMubWF0cml4WzBdID0gY29zICsgT25lTWludXNDb3MgLyAzO1xuICAgICAgdGhpcy5tYXRyaXhbMV0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyAtIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzJdID0gYVRoaXJkICogT25lTWludXNDb3MgKyBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFs1XSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zICsgYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbNl0gPSBjb3MgKyBhVGhpcmQgKiBPbmVNaW51c0NvcztcbiAgICAgIHRoaXMubWF0cml4WzddID0gYVRoaXJkICogT25lTWludXNDb3MgLSBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFsxMF0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyAtIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzExXSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zICsgYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbMTJdID0gY29zICsgYVRoaXJkICogT25lTWludXNDb3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEh1ZVJvdGF0aW9uIGlzTmV1dHJhbFN0YXRlIGltcGxlbWVudGF0aW9uXG4gICAgICogVXNlZCBvbmx5IGluIGltYWdlIGFwcGx5RmlsdGVycyB0byBkaXNjYXJkIGZpbHRlcnMgdGhhdCB3aWxsIG5vdCBoYXZlIGFuIGVmZmVjdFxuICAgICAqIG9uIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICoqL1xuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGN1bGF0ZU1hdHJpeCgpO1xuICAgICAgcmV0dXJuIGZpbHRlcnMuQmFzZUZpbHRlci5wcm90b3R5cGUuaXNOZXV0cmFsU3RhdGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhpcyBmaWx0ZXIgdG8gdGhlIGlucHV0IGltYWdlIGRhdGEgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gdXNlIFdlYkdMIG9yIENhbnZhczJEIGJhc2VkIG9uIHRoZSBvcHRpb25zLndlYmdsIGZsYWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGV4ZWN1dGVkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLndlYmdsIFdoZXRoZXIgdG8gdXNlIHdlYmdsIHRvIHJlbmRlciB0aGUgZmlsdGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnNvdXJjZVRleHR1cmUgVGhlIHRleHR1cmUgc2V0dXAgYXMgdGhlIHNvdXJjZSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy50YXJnZXRUZXh0dXJlIFRoZSB0ZXh0dXJlIHdoZXJlIGZpbHRlcmVkIG91dHB1dCBzaG91bGQgYmUgZHJhd24uXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxjdWxhdGVNYXRyaXgoKTtcbiAgICAgIGZpbHRlcnMuQmFzZUZpbHRlci5wcm90b3R5cGUuYXBwbHlUby5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbn0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb25cbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lO1xuXG4gIGlmIChmYWJyaWMuVGV4dCkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuVGV4dCBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYWRkaXRpb25hbFByb3BzID1cbiAgICAoJ2ZvbnRGYW1pbHkgZm9udFdlaWdodCBmb250U2l6ZSB0ZXh0IHVuZGVybGluZSBvdmVybGluZSBsaW5ldGhyb3VnaCcgK1xuICAgICcgdGV4dEFsaWduIGZvbnRTdHlsZSBsaW5lSGVpZ2h0IHRleHRCYWNrZ3JvdW5kQ29sb3IgY2hhclNwYWNpbmcgc3R5bGVzJyArXG4gICAgJyBkaXJlY3Rpb24gcGF0aCBwYXRoU3RhcnRPZmZzZXQgcGF0aFNpZGUgcGF0aEFsaWduJykuc3BsaXQoJyAnKTtcblxuICAvKipcbiAgICogVGV4dCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlRleHRcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiN0ZXh0fVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuVGV4dCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRleHQgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5UZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIHdoaWNoIHdoZW4gc2V0IGNhdXNlIG9iamVjdCB0byBjaGFuZ2UgZGltZW5zaW9uc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHM6IFtcbiAgICAgICdmb250U2l6ZScsXG4gICAgICAnZm9udFdlaWdodCcsXG4gICAgICAnZm9udEZhbWlseScsXG4gICAgICAnZm9udFN0eWxlJyxcbiAgICAgICdsaW5lSGVpZ2h0JyxcbiAgICAgICd0ZXh0JyxcbiAgICAgICdjaGFyU3BhY2luZycsXG4gICAgICAndGV4dEFsaWduJyxcbiAgICAgICdzdHlsZXMnLFxuICAgICAgJ3BhdGgnLFxuICAgICAgJ3BhdGhTdGFydE9mZnNldCcsXG4gICAgICAncGF0aFNpZGUnLFxuICAgICAgJ3BhdGhBbGlnbidcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVOZXdsaW5lOiAvXFxyP1xcbi8sXG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyByZWd1bGFyIGV4cHJlc3Npb24gdG8gZmlsdGVyIGZvciB3aGl0ZXNwYWNlcyB0aGF0IGlzIG5vdCBhIG5ldyBsaW5lLlxuICAgICAqIE1vc3RseSB1c2VkIHdoZW4gdGV4dCBpcyAnanVzdGlmeScgYWxpZ25lZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZVNwYWNlc0FuZFRhYnM6IC9bIFxcdFxccl0vZyxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaWx0ZXIgZm9yIHdoaXRlc3BhY2UgdGhhdCBpcyBub3QgYSBuZXcgbGluZS5cbiAgICAgKiBNb3N0bHkgdXNlZCB3aGVuIHRleHQgaXMgJ2p1c3RpZnknIGFsaWduZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVTcGFjZUFuZFRhYjogL1sgXFx0XFxyXS8sXG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyByZWd1bGFyIGV4cHJlc3Npb24gdG8gZmlsdGVyIGNvbnNlY3V0aXZlIGdyb3VwcyBvZiBub24gc3BhY2VzLlxuICAgICAqIE1vc3RseSB1c2VkIHdoZW4gdGV4dCBpcyAnanVzdGlmeScgYWxpZ25lZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZVdvcmRzOiAvXFxTKy9nLFxuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICAgICAgICAgICAgICAgICAndGV4dCcsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHNpemUgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRTaXplOiAgICAgICAgICAgICA0MCxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgd2VpZ2h0IChlLmcuIGJvbGQsIG5vcm1hbCwgNDAwLCA2MDAsIDgwMClcbiAgICAgKiBAdHlwZSB7KE51bWJlcnxTdHJpbmcpfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udFdlaWdodDogICAgICAgICAgICdub3JtYWwnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBmYW1pbHlcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRGYW1pbHk6ICAgICAgICAgICAnVGltZXMgTmV3IFJvbWFuJyxcblxuICAgIC8qKlxuICAgICAqIFRleHQgZGVjb3JhdGlvbiB1bmRlcmxpbmUuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdW5kZXJsaW5lOiAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRleHQgZGVjb3JhdGlvbiBvdmVybGluZS5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvdmVybGluZTogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGRlY29yYXRpb24gbGluZXRocm91Z2guXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbGluZXRocm91Z2g6ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBhbGlnbm1lbnQuIFBvc3NpYmxlIHZhbHVlczogXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIiwgXCJqdXN0aWZ5XCIsXG4gICAgICogXCJqdXN0aWZ5LWxlZnRcIiwgXCJqdXN0aWZ5LWNlbnRlclwiIG9yIFwianVzdGlmeS1yaWdodFwiLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdGV4dEFsaWduOiAgICAgICAgICAgICdsZWZ0JyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgc3R5bGUgLiBQb3NzaWJsZSB2YWx1ZXM6IFwiXCIsIFwibm9ybWFsXCIsIFwiaXRhbGljXCIgb3IgXCJvYmxpcXVlXCIuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmb250U3R5bGU6ICAgICAgICAgICAgJ25vcm1hbCcsXG5cbiAgICAvKipcbiAgICAgKiBMaW5lIGhlaWdodFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbGluZUhlaWdodDogICAgICAgICAgIDEuMTYsXG5cbiAgICAvKipcbiAgICAgKiBTdXBlcnNjcmlwdCBzY2hlbWEgb2JqZWN0IChtaW5pbXVtIG92ZXJsYXApXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN1cGVyc2NyaXB0OiB7XG4gICAgICBzaXplOiAgICAgIDAuNjAsIC8vIGZvbnRTaXplIGZhY3RvclxuICAgICAgYmFzZWxpbmU6IC0wLjM1ICAvLyBiYXNlbGluZS1zaGlmdCBmYWN0b3IgKHVwd2FyZHMpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmlwdCBzY2hlbWEgb2JqZWN0IChtaW5pbXVtIG92ZXJsYXApXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN1YnNjcmlwdDoge1xuICAgICAgc2l6ZTogICAgICAwLjYwLCAvLyBmb250U2l6ZSBmYWN0b3JcbiAgICAgIGJhc2VsaW5lOiAgMC4xMSAgLy8gYmFzZWxpbmUtc2hpZnQgZmFjdG9yIChkb3dud2FyZHMpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJhY2tncm91bmQgY29sb3Igb2YgdGV4dCBsaW5lc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdGV4dEJhY2tncm91bmRDb2xvcjogICcnLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWZcbiAgICAgKiBzdGF0ZSBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoe0BsaW5rIGZhYnJpYy5PYmplY3QjaGFzU3RhdGVDaGFuZ2VkfSlcbiAgICAgKiBhcyB3ZWxsIGFzIGZvciBoaXN0b3J5ICh1bmRvL3JlZG8pIHB1cnBvc2VzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdGF0ZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoYWRkaXRpb25hbFByb3BzKSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmIGNhY2hlIG5lZWRzIHJlZnJlc2hcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdChhZGRpdGlvbmFsUHJvcHMpLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkZWZpbmVkLCBhbiBvYmplY3QgaXMgcmVuZGVyZWQgdmlhIHN0cm9rZSBhbmQgdGhpcyBwcm9wZXJ0eSBzcGVjaWZpZXMgaXRzIGNvbG9yLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgd2FzIG5hbWVkIFwic3Ryb2tlU3R5bGVcIiB1bnRpbCB2MS4xLjZcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZTogICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IG9iamVjdCByZXByZXNlbnRpbmcgc2hhZG93IG9mIHRoaXMgc2hhcGUuXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSB3YXMgbmFtZWQgXCJ0ZXh0U2hhZG93XCIgKFN0cmluZykgdW50aWwgdjEuMi4xMVxuICAgICAqIEB0eXBlIGZhYnJpYy5TaGFkb3dcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNoYWRvdzogICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogZmFicmljLlBhdGggdGhhdCB0aGUgdGV4dCBzaG91bGQgZm9sbG93LlxuICAgICAqIHNpbmNlIDQuNi4wIHRoZSBwYXRoIHdpbGwgYmUgZHJhd24gYXV0b21hdGljYWxseS5cbiAgICAgKiBpZiB5b3Ugd2FudCB0byBtYWtlIHRoZSBwYXRoIHZpc2libGUsIGdpdmUgaXQgYSBzdHJva2UgYW5kIHN0cm9rZVdpZHRoIG9yIGZpbGwgdmFsdWVcbiAgICAgKiBpZiB5b3Ugd2FudCBpdCB0byBiZSBoaWRkZW4sIGFzc2lnbiB2aXNpYmxlID0gZmFsc2UgdG8gdGhlIHBhdGguXG4gICAgICogVGhpcyBmZWF0dXJlIGlzIGluIEJFVEEsIGFuZCBTVkcgaW1wb3J0L2V4cG9ydCBpcyBub3QgeWV0IHN1cHBvcnRlZC5cbiAgICAgKiBAdHlwZSBmYWJyaWMuUGF0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHRleHRQYXRoID0gbmV3IGZhYnJpYy5UZXh0KCdUZXh0IG9uIGEgcGF0aCcsIHtcbiAgICAgKiAgICAgdG9wOiAxNTAsXG4gICAgICogICAgIGxlZnQ6IDE1MCxcbiAgICAgKiAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgKiAgICAgY2hhclNwYWNpbmc6IC01MCxcbiAgICAgKiAgICAgcGF0aDogbmV3IGZhYnJpYy5QYXRoKCdNIDAgMCBDIDUwIC0xMDAgMTUwIC0xMDAgMjAwIDAnLCB7XG4gICAgICogICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgKiAgICAgICAgIHZpc2libGU6IGZhbHNlXG4gICAgICogICAgIH0pLFxuICAgICAqICAgICBwYXRoU2lkZTogJ2xlZnQnLFxuICAgICAqICAgICBwYXRoU3RhcnRPZmZzZXQ6IDBcbiAgICAgKiB9KTtcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhdGg6ICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE9mZnNldCBhbW91bnQgZm9yIHRleHQgcGF0aCBzdGFydGluZyBwb3NpdGlvblxuICAgICAqIE9ubHkgdXNlZCB3aGVuIHRleHQgaGFzIGEgcGF0aFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGF0aFN0YXJ0T2Zmc2V0OiAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGljaCBzaWRlIG9mIHRoZSBwYXRoIHRoZSB0ZXh0IHNob3VsZCBiZSBkcmF3biBvbi5cbiAgICAgKiBPbmx5IHVzZWQgd2hlbiB0ZXh0IGhhcyBhIHBhdGhcbiAgICAgKiBAdHlwZSB7U3RyaW5nfSAnbGVmdHxyaWdodCdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhdGhTaWRlOiAgICAgICAgICAgICAgICdsZWZ0JyxcblxuICAgIC8qKlxuICAgICAqIEhvdyB0ZXh0IGlzIGFsaWduZWQgdG8gdGhlIHBhdGguIFRoaXMgcHJvcGVydHkgZGV0ZXJtaW5lc1xuICAgICAqIHRoZSBwZXJwZW5kaWN1bGFyIHBvc2l0aW9uIG9mIGVhY2ggY2hhcmFjdGVyIHJlbGF0aXZlIHRvIHRoZSBwYXRoLlxuICAgICAqIChvbmUgb2YgXCJiYXNlbGluZVwiLCBcImNlbnRlclwiLCBcImFzY2VuZGVyXCIsIFwiZGVzY2VuZGVyXCIpXG4gICAgICogVGhpcyBmZWF0dXJlIGlzIGluIEJFVEEsIGFuZCBpdHMgYmVoYXZpb3IgbWF5IGNoYW5nZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGF0aEFsaWduOiAgICAgICAgICAgICAgICdiYXNlbGluZScsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9mb250U2l6ZUZyYWN0aW9uOiAwLjIyMixcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb2Zmc2V0czoge1xuICAgICAgdW5kZXJsaW5lOiAwLjEwLFxuICAgICAgbGluZXRocm91Z2g6IC0wLjMxNSxcbiAgICAgIG92ZXJsaW5lOiAtMC44OFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IExpbmUgcHJvcG9ydGlvbiB0byBmb250IFNpemUgKGluIHBpeGVscylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIF9mb250U2l6ZU11bHQ6ICAgICAgICAgICAgIDEuMTMsXG5cbiAgICAvKipcbiAgICAgKiBhZGRpdGlvbmFsIHNwYWNlIGJldHdlZW4gY2hhcmFjdGVyc1xuICAgICAqIGV4cHJlc3NlZCBpbiB0aG91c2FuZHMgb2YgZW0gdW5pdFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2hhclNwYWNpbmc6ICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgY29udGFpbmluZyBjaGFyYWN0ZXIgc3R5bGVzIC0gdG9wLWxldmVsIHByb3BlcnRpZXMgLT4gbGluZSBudW1iZXJzLFxuICAgICAqIDJuZC1sZXZlbCBwcm9wZXJ0aWVzIC0gY2hhcmFjdGVyIG51bWJlcnNcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0eWxlczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byBhIGNvbnRleHQgdG8gbWVhc3VyZSB0ZXh0IGNoYXIgb3IgY291cGxlIG9mIGNoYXJzXG4gICAgICogdGhlIGNhY2hlQ29udGV4dCBvZiB0aGUgY2FudmFzIHdpbGwgYmUgdXNlZCBvciBhIGZyZXNobHkgY3JlYXRlZCBvbmUgaWYgdGhlIG9iamVjdCBpcyBub3Qgb24gY2FudmFzXG4gICAgICogb25jZSBjcmVhdGVkIGl0IHdpbGwgYmUgcmVmZXJlbmNlZCBvbiBmYWJyaWMuX21lYXN1cmluZ0NvbnRleHQgdG8gYXZvaWQgY3JlYXRpbmcgYSBjYW52YXMgZm9yIGV2ZXJ5XG4gICAgICogdGV4dCBvYmplY3QgY3JlYXRlZC5cbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgX21lYXN1cmluZ0NvbnRleHQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBCYXNlbGluZSBzaGlmdCwgc3R5bGVzIG9ubHksIGtlZXAgYXQgMCBmb3IgdGhlIG1haW4gdGV4dCBvYmplY3RcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZGVsdGFZOiAwLFxuXG4gICAgLyoqXG4gICAgICogV0FSTklORzogRVhQRVJJTUVOVEFMLiBOT1QgU1VQUE9SVEVEIFlFVFxuICAgICAqIGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSB0ZXh0LlxuICAgICAqIFRoaXMgaGFzIHRvIGJlIHNldCBtYW51YWxseSB0b2dldGhlciB3aXRoIHRleHRBbGlnbiBhbmQgb3JpZ2luWCBmb3IgcHJvcGVyXG4gICAgICogZXhwZXJpZW5jZS5cbiAgICAgKiBzb21lIGludGVyZXN0aW5nIGxpbmsgZm9yIHRoZSBmdXR1cmVcbiAgICAgKiBodHRwczovL3d3dy53My5vcmcvSW50ZXJuYXRpb25hbC9xdWVzdGlvbnMvcWEtYmlkaS11bmljb2RlLWNvbnRyb2xzXG4gICAgICogQHNpbmNlIDQuNS4wXG4gICAgICogQHR5cGUge1N0cmluZ30gJ2x0cnxydGwnXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBkaXJlY3Rpb246ICdsdHInLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcHJvcGVydGllcyB0aGF0IGRlZmluZSBhIHN0eWxlIHVuaXQgKG9mICdzdHlsZXMnKS5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBfc3R5bGVQcm9wZXJ0aWVzOiBbXG4gICAgICAnc3Ryb2tlJyxcbiAgICAgICdzdHJva2VXaWR0aCcsXG4gICAgICAnZmlsbCcsXG4gICAgICAnZm9udEZhbWlseScsXG4gICAgICAnZm9udFNpemUnLFxuICAgICAgJ2ZvbnRXZWlnaHQnLFxuICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAndW5kZXJsaW5lJyxcbiAgICAgICdvdmVybGluZScsXG4gICAgICAnbGluZXRocm91Z2gnLFxuICAgICAgJ2RlbHRhWScsXG4gICAgICAndGV4dEJhY2tncm91bmRDb2xvcicsXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIGNvbnRhaW5zIGNoYXJhY3RlcnMgYm91bmRpbmcgYm94ZXNcbiAgICAgKi9cbiAgICBfX2NoYXJCb3VuZHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogdXNlIHRoaXMgc2l6ZSB3aGVuIG1lYXN1cmluZyB0ZXh0LiBUbyBhdm9pZCBJRTExIHJvdW5kaW5nIGVycm9yc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENBQ0hFX0ZPTlRfU0laRTogNDAwLFxuXG4gICAgLyoqXG4gICAgICogY29udGFpbnMgdGhlIG1pbiB0ZXh0IHdpZHRoIHRvIGF2b2lkIGdldHRpbmcgMFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBNSU5fVEVYVF9XSURUSDogMixcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGV4dCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbih0ZXh0LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLnN0eWxlcyA9IG9wdGlvbnMgPyAob3B0aW9ucy5zdHlsZXMgfHwgeyB9KSA6IHsgfTtcbiAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICB0aGlzLl9fc2tpcERpbWVuc2lvbiA9IHRydWU7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICB0aGlzLnNldFBhdGhJbmZvKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fc2tpcERpbWVuc2lvbiA9IGZhbHNlO1xuICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMuc2V0dXBTdGF0ZSh7IHByb3BlcnR5U2V0OiAnX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzJyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdGV4dCBoYXMgYSBwYXRoLCBpdCB3aWxsIGFkZCB0aGUgZXh0cmEgaW5mb3JtYXRpb24gbmVlZGVkXG4gICAgICogZm9yIHBhdGggYW5kIHRleHQgY2FsY3VsYXRpb25zXG4gICAgICogQHJldHVybiB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXRQYXRoSW5mbzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHBhdGguc2VnbWVudHNJbmZvID0gZmFicmljLnV0aWwuZ2V0UGF0aFNlZ21lbnRzSW5mbyhwYXRoLnBhdGgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBjb250ZXh0IGZvciBtZWFzdXJlbWVudCBvZiB0ZXh0IHN0cmluZy5cbiAgICAgKiBpZiBjcmVhdGVkIGl0IGdldHMgc3RvcmVkIGZvciByZXVzZVxuICAgICAqIHRoaXMgaXMgZm9yIGludGVybmFsIHVzZSwgcGxlYXNlIGRvIG5vdCB1c2UgaXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICovXG4gICAgZ2V0TWVhc3VyaW5nQ29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpZiB3ZSBkaWQgbm90IHJldHVybiB3ZSBoYXZlIHRvIG1lYXN1cmUgc29tZXRoaW5nLlxuICAgICAgaWYgKCFmYWJyaWMuX21lYXN1cmluZ0NvbnRleHQpIHtcbiAgICAgICAgZmFicmljLl9tZWFzdXJpbmdDb250ZXh0ID0gdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuY29udGV4dENhY2hlIHx8XG4gICAgICAgICAgZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFicmljLl9tZWFzdXJpbmdDb250ZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIERpdmlkZXMgdGV4dCBpbnRvIGxpbmVzIG9mIHRleHQgYW5kIGxpbmVzIG9mIGdyYXBoZW1lcy5cbiAgICAgKi9cbiAgICBfc3BsaXRUZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuZXdMaW5lcyA9IHRoaXMuX3NwbGl0VGV4dEludG9MaW5lcyh0aGlzLnRleHQpO1xuICAgICAgdGhpcy50ZXh0TGluZXMgPSBuZXdMaW5lcy5saW5lcztcbiAgICAgIHRoaXMuX3RleHRMaW5lcyA9IG5ld0xpbmVzLmdyYXBoZW1lTGluZXM7XG4gICAgICB0aGlzLl91bndyYXBwZWRUZXh0TGluZXMgPSBuZXdMaW5lcy5fdW53cmFwcGVkTGluZXM7XG4gICAgICB0aGlzLl90ZXh0ID0gbmV3TGluZXMuZ3JhcGhlbWVUZXh0O1xuICAgICAgcmV0dXJuIG5ld0xpbmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIG9yIHVwZGF0ZSB0ZXh0IGRpbWVuc2lvbnMuXG4gICAgICogVXBkYXRlcyB0aGlzLndpZHRoIGFuZCB0aGlzLmhlaWdodCB3aXRoIHRoZSBwcm9wZXIgdmFsdWVzLlxuICAgICAqIERvZXMgbm90IHJldHVybiBkaW1lbnNpb25zLlxuICAgICAqL1xuICAgIGluaXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9fc2tpcERpbWVuc2lvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zcGxpdFRleHQoKTtcbiAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoKTtcbiAgICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMucGF0aC53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnBhdGguaGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbGNUZXh0V2lkdGgoKSB8fCB0aGlzLmN1cnNvcldpZHRoIHx8IHRoaXMuTUlOX1RFWFRfV0lEVEg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYWxjVGV4dEhlaWdodCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dEFsaWduLmluZGV4T2YoJ2p1c3RpZnknKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gb25jZSB0ZXh0IGlzIG1lYXN1cmVkIHdlIG5lZWQgdG8gbWFrZSBzcGFjZSBmYXR0ZXIgdG8gbWFrZSBqdXN0aWZpZWQgdGV4dC5cbiAgICAgICAgdGhpcy5lbmxhcmdlU3BhY2VzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNhdmVTdGF0ZSh7IHByb3BlcnR5U2V0OiAnX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzJyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5sYXJnZSBzcGFjZSBib3hlcyBhbmQgc2hpZnQgdGhlIG90aGVyc1xuICAgICAqL1xuICAgIGVubGFyZ2VTcGFjZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRpZmZTcGFjZSwgY3VycmVudExpbmVXaWR0aCwgbnVtYmVyT2ZTcGFjZXMsIGFjY3VtdWxhdGVkU3BhY2UsIGxpbmUsIGNoYXJCb3VuZCwgc3BhY2VzO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodGhpcy50ZXh0QWxpZ24gIT09ICdqdXN0aWZ5JyAmJiAoaSA9PT0gbGVuIC0gMSB8fCB0aGlzLmlzRW5kT2ZXcmFwcGluZyhpKSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhY2N1bXVsYXRlZFNwYWNlID0gMDtcbiAgICAgICAgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXTtcbiAgICAgICAgY3VycmVudExpbmVXaWR0aCA9IHRoaXMuZ2V0TGluZVdpZHRoKGkpO1xuICAgICAgICBpZiAoY3VycmVudExpbmVXaWR0aCA8IHRoaXMud2lkdGggJiYgKHNwYWNlcyA9IHRoaXMudGV4dExpbmVzW2ldLm1hdGNoKHRoaXMuX3JlU3BhY2VzQW5kVGFicykpKSB7XG4gICAgICAgICAgbnVtYmVyT2ZTcGFjZXMgPSBzcGFjZXMubGVuZ3RoO1xuICAgICAgICAgIGRpZmZTcGFjZSA9ICh0aGlzLndpZHRoIC0gY3VycmVudExpbmVXaWR0aCkgLyBudW1iZXJPZlNwYWNlcztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDw9IGpsZW47IGorKykge1xuICAgICAgICAgICAgY2hhckJvdW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbaV1bal07XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVTcGFjZUFuZFRhYi50ZXN0KGxpbmVbal0pKSB7XG4gICAgICAgICAgICAgIGNoYXJCb3VuZC53aWR0aCArPSBkaWZmU3BhY2U7XG4gICAgICAgICAgICAgIGNoYXJCb3VuZC5rZXJuZWRXaWR0aCArPSBkaWZmU3BhY2U7XG4gICAgICAgICAgICAgIGNoYXJCb3VuZC5sZWZ0ICs9IGFjY3VtdWxhdGVkU3BhY2U7XG4gICAgICAgICAgICAgIGFjY3VtdWxhdGVkU3BhY2UgKz0gZGlmZlNwYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGNoYXJCb3VuZC5sZWZ0ICs9IGFjY3VtdWxhdGVkU3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiB0aGUgdGV4dCBsaW5lIGlzIGVuZGVkIHdpdGggYW4gaGFyZCBicmVha1xuICAgICAqIHRleHQgYW5kIGl0ZXh0IGRvIG5vdCBoYXZlIHdyYXBwaW5nLCByZXR1cm4gZmFsc2VcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW5kT2ZXcmFwcGluZzogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICByZXR1cm4gbGluZUluZGV4ID09PSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoIC0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGEgbGluZSBoYXMgYSBsaW5lYnJlYWsgYW5kIHNvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgaXQgd2hlbiBtb3ZpbmdcbiAgICAgKiBhbmQgY291bnRpbmcgc3R5bGUuXG4gICAgICogSXQgcmV0dXJuIGFsd2F5cyBmb3IgdGV4dCBhbmQgSXRleHQuXG4gICAgICogQHJldHVybiBOdW1iZXJcbiAgICAgKi9cbiAgICBtaXNzaW5nTmV3bGluZU9mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0ZXh0IG9iamVjdFxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuVGV4dCAoJyArIHRoaXMuY29tcGxleGl0eSgpICtcbiAgICAgICAgJyk6IHsgXCJ0ZXh0XCI6IFwiJyArIHRoaXMudGV4dCArICdcIiwgXCJmb250RmFtaWx5XCI6IFwiJyArIHRoaXMuZm9udEZhbWlseSArICdcIiB9Pic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGltZW5zaW9uIGFuZCB0aGUgem9vbSBsZXZlbCBuZWVkZWQgdG8gY3JlYXRlIGEgY2FjaGUgY2FudmFzXG4gICAgICogYmlnIGVub3VnaCB0byBob3N0IHRoZSBvYmplY3QgdG8gYmUgY2FjaGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbS54IHdpZHRoIG9mIG9iamVjdCB0byBiZSBjYWNoZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltLnkgaGVpZ2h0IG9mIG9iamVjdCB0byBiZSBjYWNoZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uaGVpZ2h0IGhlaWdodCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqL1xuICAgIF9nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRpbXMgPSB0aGlzLmNhbGxTdXBlcignX2dldENhY2hlQ2FudmFzRGltZW5zaW9ucycpO1xuICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5mb250U2l6ZTtcbiAgICAgIGRpbXMud2lkdGggKz0gZm9udFNpemUgKiBkaW1zLnpvb21YO1xuICAgICAgZGltcy5oZWlnaHQgKz0gZm9udFNpemUgKiBkaW1zLnpvb21ZO1xuICAgICAgcmV0dXJuIGRpbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICBwYXRoICYmICFwYXRoLmlzTm90VmlzaWJsZSgpICYmIHBhdGguX3JlbmRlcihjdHgpO1xuICAgICAgdGhpcy5fc2V0VGV4dFN0eWxlcyhjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dExpbmVzQmFja2dyb3VuZChjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dERlY29yYXRpb24oY3R4LCAndW5kZXJsaW5lJyk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0KGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0RGVjb3JhdGlvbihjdHgsICdvdmVybGluZScpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dERlY29yYXRpb24oY3R4LCAnbGluZXRocm91Z2gnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKHRoaXMucGFpbnRGaXJzdCA9PT0gJ3N0cm9rZScpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dFN0cm9rZShjdHgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0RmlsbChjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRGaWxsKGN0eCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRTdHJva2UoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmb250IHBhcmFtZXRlciBvZiB0aGUgY29udGV4dCB3aXRoIHRoZSBvYmplY3QgcHJvcGVydGllcyBvciB3aXRoIGNoYXJTdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY2hhclN0eWxlXSBvYmplY3Qgd2l0aCBmb250IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NoYXJTdHlsZS5mb250RmFtaWx5XSBGb250IEZhbWlseVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY2hhclN0eWxlLmZvbnRTaXplXSBGb250IHNpemUgaW4gcGl4ZWxzLiAoIHdpdGhvdXQgcHggc3VmZml4IClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NoYXJTdHlsZS5mb250V2VpZ2h0XSBGb250IHdlaWdodFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhclN0eWxlLmZvbnRTdHlsZV0gRm9udCBzdHlsZSAoaXRhbGljfG5vcm1hbClcbiAgICAgKi9cbiAgICBfc2V0VGV4dFN0eWxlczogZnVuY3Rpb24oY3R4LCBjaGFyU3R5bGUsIGZvck1lYXN1cmluZykge1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljYWwnO1xuICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMucGF0aEFsaWduKSB7XG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2FzY2VuZGVyJzpcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Rlc2NlbmRlcic6XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LmZvbnQgPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24oY2hhclN0eWxlLCBmb3JNZWFzdXJpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgYW5kIHJldHVybiB0aGUgdGV4dCBXaWR0aCBtZWFzdXJpbmcgZWFjaCBsaW5lLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTWF4aW11bSB3aWR0aCBvZiBmYWJyaWMuVGV4dCBvYmplY3RcbiAgICAgKi9cbiAgICBjYWxjVGV4dFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXhXaWR0aCA9IHRoaXMuZ2V0TGluZVdpZHRoKDApO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50TGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgoaSk7XG4gICAgICAgIGlmIChjdXJyZW50TGluZVdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICBtYXhXaWR0aCA9IGN1cnJlbnRMaW5lV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXhXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE1ldGhvZCBuYW1lIChcImZpbGxUZXh0XCIgb3IgXCJzdHJva2VUZXh0XCIpXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lIFRleHQgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBwb3NpdGlvbiBvZiB0ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgcG9zaXRpb24gb2YgdGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lIGluIGEgdGV4dFxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0TGluZTogZnVuY3Rpb24obWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJDaGFycyhtZXRob2QsIGN0eCwgbGluZSwgbGVmdCwgdG9wLCBsaW5lSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSB0ZXh0IGJhY2tncm91bmQgZm9yIGxpbmVzLCB0YWtpbmcgY2FyZSBvZiBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0TGluZXNCYWNrZ3JvdW5kOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy50ZXh0QmFja2dyb3VuZENvbG9yICYmICF0aGlzLnN0eWxlSGFzKCd0ZXh0QmFja2dyb3VuZENvbG9yJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhlaWdodE9mTGluZSxcbiAgICAgICAgICBsaW5lTGVmdE9mZnNldCwgb3JpZ2luYWxGaWxsID0gY3R4LmZpbGxTdHlsZSxcbiAgICAgICAgICBsaW5lLCBsYXN0Q29sb3IsXG4gICAgICAgICAgbGVmdE9mZnNldCA9IHRoaXMuX2dldExlZnRPZmZzZXQoKSxcbiAgICAgICAgICBsaW5lVG9wT2Zmc2V0ID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksXG4gICAgICAgICAgYm94U3RhcnQgPSAwLCBib3hXaWR0aCA9IDAsIGNoYXJCb3gsIGN1cnJlbnRDb2xvciwgcGF0aCA9IHRoaXMucGF0aCxcbiAgICAgICAgICBkcmF3U3RhcnQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaGVpZ2h0T2ZMaW5lID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSk7XG4gICAgICAgIGlmICghdGhpcy50ZXh0QmFja2dyb3VuZENvbG9yICYmICF0aGlzLnN0eWxlSGFzKCd0ZXh0QmFja2dyb3VuZENvbG9yJywgaSkpIHtcbiAgICAgICAgICBsaW5lVG9wT2Zmc2V0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldO1xuICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpO1xuICAgICAgICBib3hXaWR0aCA9IDA7XG4gICAgICAgIGJveFN0YXJ0ID0gMDtcbiAgICAgICAgbGFzdENvbG9yID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCAwLCAndGV4dEJhY2tncm91bmRDb2xvcicpO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgICAgY2hhckJveCA9IHRoaXMuX19jaGFyQm91bmRzW2ldW2pdO1xuICAgICAgICAgIGN1cnJlbnRDb2xvciA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgaiwgJ3RleHRCYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY2hhckJveC5yZW5kZXJMZWZ0LCBjaGFyQm94LnJlbmRlclRvcCk7XG4gICAgICAgICAgICBjdHgucm90YXRlKGNoYXJCb3guYW5nbGUpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgICAgIGN1cnJlbnRDb2xvciAmJiBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgIC1jaGFyQm94LndpZHRoIC8gMixcbiAgICAgICAgICAgICAgLWhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodCAqICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbiksXG4gICAgICAgICAgICAgIGNoYXJCb3gud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRDb2xvciAhPT0gbGFzdENvbG9yKSB7XG4gICAgICAgICAgICBkcmF3U3RhcnQgPSBsZWZ0T2Zmc2V0ICsgbGluZUxlZnRPZmZzZXQgKyBib3hTdGFydDtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgICAgICAgZHJhd1N0YXJ0ID0gdGhpcy53aWR0aCAtIGRyYXdTdGFydCAtIGJveFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhc3RDb2xvcjtcbiAgICAgICAgICAgIGxhc3RDb2xvciAmJiBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgIGRyYXdTdGFydCxcbiAgICAgICAgICAgICAgbGluZVRvcE9mZnNldCxcbiAgICAgICAgICAgICAgYm94V2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJveFN0YXJ0ID0gY2hhckJveC5sZWZ0O1xuICAgICAgICAgICAgYm94V2lkdGggPSBjaGFyQm94LndpZHRoO1xuICAgICAgICAgICAgbGFzdENvbG9yID0gY3VycmVudENvbG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50Q29sb3IgJiYgIXBhdGgpIHtcbiAgICAgICAgICBkcmF3U3RhcnQgPSBsZWZ0T2Zmc2V0ICsgbGluZUxlZnRPZmZzZXQgKyBib3hTdGFydDtcbiAgICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgICAgICBkcmF3U3RhcnQgPSB0aGlzLndpZHRoIC0gZHJhd1N0YXJ0IC0gYm94V2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgZHJhd1N0YXJ0LFxuICAgICAgICAgICAgbGluZVRvcE9mZnNldCxcbiAgICAgICAgICAgIGJveFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0T2ZMaW5lIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lVG9wT2Zmc2V0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcmlnaW5hbEZpbGw7XG4gICAgICAvLyBpZiB0aGVyZSBpcyB0ZXh0IGJhY2tncm91bmQgY29sb3Igbm9cbiAgICAgIC8vIG90aGVyIHNoYWRvd3Mgc2hvdWxkIGJlIGNhc3RlZFxuICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlY2wgc3R5bGUgZGVjbGFyYXRpb24gZm9yIGNhY2hlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlY2wuZm9udEZhbWlseSBmb250RmFtaWx5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRlY2wuZm9udFN0eWxlIGZvbnRTdHlsZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWNsLmZvbnRXZWlnaHQgZm9udFdlaWdodFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gcmVmZXJlbmNlIHRvIGNhY2hlXG4gICAgICovXG4gICAgZ2V0Rm9udENhY2hlOiBmdW5jdGlvbihkZWNsKSB7XG4gICAgICB2YXIgZm9udEZhbWlseSA9IGRlY2wuZm9udEZhbWlseS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKCFmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldKSB7XG4gICAgICAgIGZhYnJpYy5jaGFyV2lkdGhzQ2FjaGVbZm9udEZhbWlseV0gPSB7IH07XG4gICAgICB9XG4gICAgICB2YXIgY2FjaGUgPSBmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldLFxuICAgICAgICAgIGNhY2hlUHJvcCA9IGRlY2wuZm9udFN0eWxlLnRvTG93ZXJDYXNlKCkgKyAnXycgKyAoZGVjbC5mb250V2VpZ2h0ICsgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoIWNhY2hlW2NhY2hlUHJvcF0pIHtcbiAgICAgICAgY2FjaGVbY2FjaGVQcm9wXSA9IHsgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWNoZVtjYWNoZVByb3BdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtZWFzdXJlIGFuZCByZXR1cm4gdGhlIHdpZHRoIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci5cbiAgICAgKiBwb3NzaWJseSBvdmVycmlkZGVuIHRvIGFjY29tbW9kYXRlIGRpZmZlcmVudCBtZWFzdXJlIGxvZ2ljIG9yXG4gICAgICogdG8gaG9vayBzb21lIGV4dGVybmFsIGxpYiBmb3IgY2hhcmFjdGVyIG1lYXN1cmVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gX2NoYXIsIGNoYXIgdG8gYmUgbWVhc3VyZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhclN0eWxlIHN0eWxlIG9mIGNoYXIgdG8gYmUgbWVhc3VyZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3ByZXZpb3VzQ2hhcl0gcHJldmlvdXMgY2hhclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJldkNoYXJTdHlsZV0gc3R5bGUgb2YgcHJldmlvdXMgY2hhclxuICAgICAqL1xuICAgIF9tZWFzdXJlQ2hhcjogZnVuY3Rpb24oX2NoYXIsIGNoYXJTdHlsZSwgcHJldmlvdXNDaGFyLCBwcmV2Q2hhclN0eWxlKSB7XG4gICAgICAvLyBmaXJzdCBpIHRyeSB0byByZXR1cm4gZnJvbSBjYWNoZVxuICAgICAgdmFyIGZvbnRDYWNoZSA9IHRoaXMuZ2V0Rm9udENhY2hlKGNoYXJTdHlsZSksIGZvbnREZWNsYXJhdGlvbiA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbihjaGFyU3R5bGUpLFxuICAgICAgICAgIHByZXZpb3VzRm9udERlY2xhcmF0aW9uID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKHByZXZDaGFyU3R5bGUpLCBjb3VwbGUgPSBwcmV2aW91c0NoYXIgKyBfY2hhcixcbiAgICAgICAgICBzdHlsZXNBcmVFcXVhbCA9IGZvbnREZWNsYXJhdGlvbiA9PT0gcHJldmlvdXNGb250RGVjbGFyYXRpb24sIHdpZHRoLCBjb3VwbGVXaWR0aCwgcHJldmlvdXNXaWR0aCxcbiAgICAgICAgICBmb250TXVsdGlwbGllciA9IGNoYXJTdHlsZS5mb250U2l6ZSAvIHRoaXMuQ0FDSEVfRk9OVF9TSVpFLCBrZXJuZWRXaWR0aDtcblxuICAgICAgaWYgKHByZXZpb3VzQ2hhciAmJiBmb250Q2FjaGVbcHJldmlvdXNDaGFyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByZXZpb3VzV2lkdGggPSBmb250Q2FjaGVbcHJldmlvdXNDaGFyXTtcbiAgICAgIH1cbiAgICAgIGlmIChmb250Q2FjaGVbX2NoYXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2VybmVkV2lkdGggPSB3aWR0aCA9IGZvbnRDYWNoZVtfY2hhcl07XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVzQXJlRXF1YWwgJiYgZm9udENhY2hlW2NvdXBsZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb3VwbGVXaWR0aCA9IGZvbnRDYWNoZVtjb3VwbGVdO1xuICAgICAgICBrZXJuZWRXaWR0aCA9IGNvdXBsZVdpZHRoIC0gcHJldmlvdXNXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHByZXZpb3VzV2lkdGggPT09IHVuZGVmaW5lZCB8fCBjb3VwbGVXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmdldE1lYXN1cmluZ0NvbnRleHQoKTtcbiAgICAgICAgLy8gc2VuZCBhIFRSVUUgdG8gc3BlY2lmeSBtZWFzdXJpbmcgZm9udCBzaXplIENBQ0hFX0ZPTlRfU0laRVxuICAgICAgICB0aGlzLl9zZXRUZXh0U3R5bGVzKGN0eCwgY2hhclN0eWxlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtlcm5lZFdpZHRoID0gd2lkdGggPSBjdHgubWVhc3VyZVRleHQoX2NoYXIpLndpZHRoO1xuICAgICAgICBmb250Q2FjaGVbX2NoYXJdID0gd2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAocHJldmlvdXNXaWR0aCA9PT0gdW5kZWZpbmVkICYmIHN0eWxlc0FyZUVxdWFsICYmIHByZXZpb3VzQ2hhcikge1xuICAgICAgICBwcmV2aW91c1dpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KHByZXZpb3VzQ2hhcikud2lkdGg7XG4gICAgICAgIGZvbnRDYWNoZVtwcmV2aW91c0NoYXJdID0gcHJldmlvdXNXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZXNBcmVFcXVhbCAmJiBjb3VwbGVXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHdlIGNhbiBtZWFzdXJlIHRoZSBrZXJuaW5nIGNvdXBsZSBhbmQgc3VidHJhY3QgdGhlIHdpZHRoIG9mIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXJcbiAgICAgICAgY291cGxlV2lkdGggPSBjdHgubWVhc3VyZVRleHQoY291cGxlKS53aWR0aDtcbiAgICAgICAgZm9udENhY2hlW2NvdXBsZV0gPSBjb3VwbGVXaWR0aDtcbiAgICAgICAga2VybmVkV2lkdGggPSBjb3VwbGVXaWR0aCAtIHByZXZpb3VzV2lkdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB3aWR0aDogd2lkdGggKiBmb250TXVsdGlwbGllciwga2VybmVkV2lkdGg6IGtlcm5lZFdpZHRoICogZm9udE11bHRpcGxpZXIgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgaGVpZ2h0IG9mIGNoYXJhY3RlciBhdCBnaXZlbiBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lIHRoZSBsaW5lIGluZGV4IG51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBfY2hhciB0aGUgY2hhcmFjdGVyIGluZGV4IG51bWJlclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gZm9udFNpemUgb2YgdGhlIGNoYXJhY3RlclxuICAgICAqL1xuICAgIGdldEhlaWdodE9mQ2hhcjogZnVuY3Rpb24obGluZSwgX2NoYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmUsIF9jaGFyLCAnZm9udFNpemUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbWVhc3VyZSBhIHRleHQgbGluZSBtZWFzdXJpbmcgYWxsIGNoYXJhY3RlcnMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBsaW5lIG51bWJlclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGluZSB3aWR0aFxuICAgICAqL1xuICAgIG1lYXN1cmVMaW5lOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBsaW5lSW5mbyA9IHRoaXMuX21lYXN1cmVMaW5lKGxpbmVJbmRleCk7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCkge1xuICAgICAgICBsaW5lSW5mby53aWR0aCAtPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lSW5mby53aWR0aCA8IDApIHtcbiAgICAgICAgbGluZUluZm8ud2lkdGggPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmVJbmZvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBtZWFzdXJlIGV2ZXJ5IGdyYXBoZW1lIG9mIGEgbGluZSwgcG9wdWxhdGluZyBfX2NoYXJCb3VuZHNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qud2lkdGggdG90YWwgd2lkdGggb2YgY2hhcmFjdGVyc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LndpZHRoT2ZTcGFjZXMgbGVuZ3RoIG9mIGNoYXJzIHRoYXQgbWF0Y2ggdGhpcy5fcmVTcGFjZXNBbmRUYWJzXG4gICAgICovXG4gICAgX21lYXN1cmVMaW5lOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciB3aWR0aCA9IDAsIGksIGdyYXBoZW1lLCBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0sIHByZXZHcmFwaGVtZSxcbiAgICAgICAgICBncmFwaGVtZUluZm8sIG51bU9mU3BhY2VzID0gMCwgbGluZUJvdW5kcyA9IG5ldyBBcnJheShsaW5lLmxlbmd0aCksXG4gICAgICAgICAgcG9zaXRpb25JblBhdGggPSAwLCBzdGFydGluZ1BvaW50LCB0b3RhbFBhdGhMZW5ndGgsIHBhdGggPSB0aGlzLnBhdGgsXG4gICAgICAgICAgcmV2ZXJzZSA9IHRoaXMucGF0aFNpZGUgPT09ICdyaWdodCc7XG5cbiAgICAgIHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF0gPSBsaW5lQm91bmRzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JhcGhlbWUgPSBsaW5lW2ldO1xuICAgICAgICBncmFwaGVtZUluZm8gPSB0aGlzLl9nZXRHcmFwaGVtZUJveChncmFwaGVtZSwgbGluZUluZGV4LCBpLCBwcmV2R3JhcGhlbWUpO1xuICAgICAgICBsaW5lQm91bmRzW2ldID0gZ3JhcGhlbWVJbmZvO1xuICAgICAgICB3aWR0aCArPSBncmFwaGVtZUluZm8ua2VybmVkV2lkdGg7XG4gICAgICAgIHByZXZHcmFwaGVtZSA9IGdyYXBoZW1lO1xuICAgICAgfVxuICAgICAgLy8gdGhpcyBsYXRlc3QgYm91bmQgYm94IHJlcHJlc2VudCB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlIGxpbmVcbiAgICAgIC8vIHRvIHNpbXBsaWZ5IGN1cnNvciBoYW5kbGluZyBpbiBpbnRlcmFjdGl2ZSBtb2RlLlxuICAgICAgbGluZUJvdW5kc1tpXSA9IHtcbiAgICAgICAgbGVmdDogZ3JhcGhlbWVJbmZvID8gZ3JhcGhlbWVJbmZvLmxlZnQgKyBncmFwaGVtZUluZm8ud2lkdGggOiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAga2VybmVkV2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogdGhpcy5mb250U2l6ZVxuICAgICAgfTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHRvdGFsUGF0aExlbmd0aCA9IHBhdGguc2VnbWVudHNJbmZvW3BhdGguc2VnbWVudHNJbmZvLmxlbmd0aCAtIDFdLmxlbmd0aDtcbiAgICAgICAgc3RhcnRpbmdQb2ludCA9IGZhYnJpYy51dGlsLmdldFBvaW50T25QYXRoKHBhdGgucGF0aCwgMCwgcGF0aC5zZWdtZW50c0luZm8pO1xuICAgICAgICBzdGFydGluZ1BvaW50LnggKz0gcGF0aC5wYXRoT2Zmc2V0Lng7XG4gICAgICAgIHN0YXJ0aW5nUG9pbnQueSArPSBwYXRoLnBhdGhPZmZzZXQueTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnRleHRBbGlnbikge1xuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgcG9zaXRpb25JblBhdGggPSByZXZlcnNlID8gKHRvdGFsUGF0aExlbmd0aCAtIHdpZHRoKSA6IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgcG9zaXRpb25JblBhdGggPSAodG90YWxQYXRoTGVuZ3RoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHBvc2l0aW9uSW5QYXRoID0gcmV2ZXJzZSA/IDAgOiAodG90YWxQYXRoTGVuZ3RoIC0gd2lkdGgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy90b2RvIC0gYWRkIHN1cHBvcnQgZm9yIGp1c3RpZnlcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbkluUGF0aCArPSB0aGlzLnBhdGhTdGFydE9mZnNldCAqIChyZXZlcnNlID8gLTEgOiAxKTtcbiAgICAgICAgZm9yIChpID0gcmV2ZXJzZSA/IGxpbmUubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgICAgcmV2ZXJzZSA/IGkgPj0gMCA6IGkgPCBsaW5lLmxlbmd0aDtcbiAgICAgICAgICByZXZlcnNlID8gaS0tIDogaSsrKSB7XG4gICAgICAgICAgZ3JhcGhlbWVJbmZvID0gbGluZUJvdW5kc1tpXTtcbiAgICAgICAgICBpZiAocG9zaXRpb25JblBhdGggPiB0b3RhbFBhdGhMZW5ndGgpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uSW5QYXRoICU9IHRvdGFsUGF0aExlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocG9zaXRpb25JblBhdGggPCAwKSB7XG4gICAgICAgICAgICBwb3NpdGlvbkluUGF0aCArPSB0b3RhbFBhdGhMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGl0IHdvdWxkIHByb2JhYmx5IG11Y2ggZmFzdGVyIHRvIHNlbmQgYWxsIHRoZSBncmFwaGVtZSBwb3NpdGlvbiBmb3IgYSBsaW5lXG4gICAgICAgICAgLy8gYW5kIGNhbGN1bGF0ZSBwYXRoIHBvc2l0aW9uL2FuZ2xlIGF0IG9uY2UuXG4gICAgICAgICAgdGhpcy5fc2V0R3JhcGhlbWVPblBhdGgocG9zaXRpb25JblBhdGgsIGdyYXBoZW1lSW5mbywgc3RhcnRpbmdQb2ludCk7XG4gICAgICAgICAgcG9zaXRpb25JblBhdGggKz0gZ3JhcGhlbWVJbmZvLmtlcm5lZFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyB3aWR0aDogd2lkdGgsIG51bU9mU3BhY2VzOiBudW1PZlNwYWNlcyB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGFuZ2xlICBhbmQgdGhlIGxlZnQsdG9wIHBvc2l0aW9uIG9mIHRoZSBjaGFyIHRoYXQgZm9sbG93IGEgcGF0aC5cbiAgICAgKiBJdCBhcHBlbmRzIGl0IHRvIGdyYXBoZW1lSW5mbyB0byBiZSByZXVzZWQgbGF0ZXIgYXQgcmVuZGVyaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb25JblBhdGggdG8gYmUgbWVhc3VyZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhlbWVJbmZvIGN1cnJlbnQgZ3JhcGhlbWUgYm94IGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXJ0aW5nUG9pbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50XG4gICAgICovXG4gICAgX3NldEdyYXBoZW1lT25QYXRoOiBmdW5jdGlvbihwb3NpdGlvbkluUGF0aCwgZ3JhcGhlbWVJbmZvLCBzdGFydGluZ1BvaW50KSB7XG4gICAgICB2YXIgY2VudGVyUG9zaXRpb24gPSBwb3NpdGlvbkluUGF0aCArIGdyYXBoZW1lSW5mby5rZXJuZWRXaWR0aCAvIDIsXG4gICAgICAgICAgcGF0aCA9IHRoaXMucGF0aDtcblxuICAgICAgLy8gd2UgYXJlIGF0IGN1cnJlbnRQb3NpdGlvbk9uUGF0aC4gd2Ugd2FudCB0byBrbm93IHdoYXQgcG9pbnQgb24gdGhlIHBhdGggaXMuXG4gICAgICB2YXIgaW5mbyA9IGZhYnJpYy51dGlsLmdldFBvaW50T25QYXRoKHBhdGgucGF0aCwgY2VudGVyUG9zaXRpb24sIHBhdGguc2VnbWVudHNJbmZvKTtcbiAgICAgIGdyYXBoZW1lSW5mby5yZW5kZXJMZWZ0ID0gaW5mby54IC0gc3RhcnRpbmdQb2ludC54O1xuICAgICAgZ3JhcGhlbWVJbmZvLnJlbmRlclRvcCA9IGluZm8ueSAtIHN0YXJ0aW5nUG9pbnQueTtcbiAgICAgIGdyYXBoZW1lSW5mby5hbmdsZSA9IGluZm8uYW5nbGUgKyAodGhpcy5wYXRoU2lkZSA9PT0gICdyaWdodCcgPyBNYXRoLlBJIDogMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1lYXN1cmUgYW5kIHJldHVybiB0aGUgaW5mbyBvZiBhIHNpbmdsZSBncmFwaGVtZS5cbiAgICAgKiBuZWVkcyB0aGUgdGhlIGluZm8gb2YgcHJldmlvdXMgZ3JhcGhlbWVzIGFscmVhZHkgZmlsbGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JhcGhlbWUgdG8gYmUgbWVhc3VyZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGluZGV4IG9mIHRoZSBsaW5lIHdoZXJlIHRoZSBjaGFyIGlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBwb3NpdGlvbiBpbiB0aGUgbGluZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJldkdyYXBoZW1lXSBjaGFyYWN0ZXIgcHJlY2VkaW5nIHRoZSBvbmUgdG8gYmUgbWVhc3VyZWRcbiAgICAgKi9cbiAgICBfZ2V0R3JhcGhlbWVCb3g6IGZ1bmN0aW9uKGdyYXBoZW1lLCBsaW5lSW5kZXgsIGNoYXJJbmRleCwgcHJldkdyYXBoZW1lLCBza2lwTGVmdCkge1xuICAgICAgdmFyIHN0eWxlID0gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICAgIHByZXZTdHlsZSA9IHByZXZHcmFwaGVtZSA/IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4IC0gMSkgOiB7IH0sXG4gICAgICAgICAgaW5mbyA9IHRoaXMuX21lYXN1cmVDaGFyKGdyYXBoZW1lLCBzdHlsZSwgcHJldkdyYXBoZW1lLCBwcmV2U3R5bGUpLFxuICAgICAgICAgIGtlcm5lZFdpZHRoID0gaW5mby5rZXJuZWRXaWR0aCxcbiAgICAgICAgICB3aWR0aCA9IGluZm8ud2lkdGgsIGNoYXJTcGFjaW5nO1xuXG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCkge1xuICAgICAgICBjaGFyU3BhY2luZyA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgICB3aWR0aCArPSBjaGFyU3BhY2luZztcbiAgICAgICAga2VybmVkV2lkdGggKz0gY2hhclNwYWNpbmc7XG4gICAgICB9XG5cbiAgICAgIHZhciBib3ggPSB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgaGVpZ2h0OiBzdHlsZS5mb250U2l6ZSxcbiAgICAgICAga2VybmVkV2lkdGg6IGtlcm5lZFdpZHRoLFxuICAgICAgICBkZWx0YVk6IHN0eWxlLmRlbHRhWSxcbiAgICAgIH07XG4gICAgICBpZiAoY2hhckluZGV4ID4gMCAmJiAhc2tpcExlZnQpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtjaGFySW5kZXggLSAxXTtcbiAgICAgICAgYm94LmxlZnQgPSBwcmV2aW91c0JveC5sZWZ0ICsgcHJldmlvdXNCb3gud2lkdGggKyBpbmZvLmtlcm5lZFdpZHRoIC0gaW5mby53aWR0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBib3g7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBoZWlnaHQgb2YgbGluZSBhdCAnbGluZUluZGV4J1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggaW5kZXggb2YgbGluZSB0byBjYWxjdWxhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0SGVpZ2h0T2ZMaW5lOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9fbGluZUhlaWdodHNbbGluZUluZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2xpbmVIZWlnaHRzW2xpbmVJbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0sXG4gICAgICAgICAgLy8gY2hhciAwIGlzIG1lYXN1cmVkIGJlZm9yZSB0aGUgbGluZSBjeWNsZSBiZWNhdXNlIGl0IG5uZWRzIHRvIGNoYXJcbiAgICAgICAgICAvLyBlbXB0eWxpbmVzXG4gICAgICAgICAgbWF4SGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkNoYXIobGluZUluZGV4LCAwKTtcbiAgICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBsaW5lLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG1heEhlaWdodCA9IE1hdGgubWF4KHRoaXMuZ2V0SGVpZ2h0T2ZDaGFyKGxpbmVJbmRleCwgaSksIG1heEhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fbGluZUhlaWdodHNbbGluZUluZGV4XSA9IG1heEhlaWdodCAqIHRoaXMubGluZUhlaWdodCAqIHRoaXMuX2ZvbnRTaXplTXVsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRleHQgYm94IGhlaWdodFxuICAgICAqL1xuICAgIGNhbGNUZXh0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lSGVpZ2h0LCBoZWlnaHQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsaW5lSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSk7XG4gICAgICAgIGhlaWdodCArPSAoaSA9PT0gbGVuIC0gMSA/IGxpbmVIZWlnaHQgLyB0aGlzLmxpbmVIZWlnaHQgOiBsaW5lSGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMZWZ0IG9mZnNldFxuICAgICAqL1xuICAgIF9nZXRMZWZ0T2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbiA9PT0gJ2x0cicgPyAtdGhpcy53aWR0aCAvIDIgOiB0aGlzLndpZHRoIC8gMjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRvcCBvZmZzZXRcbiAgICAgKi9cbiAgICBfZ2V0VG9wT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAtdGhpcy5oZWlnaHQgLyAyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE1ldGhvZCBuYW1lIChcImZpbGxUZXh0XCIgb3IgXCJzdHJva2VUZXh0XCIpXG4gICAgICovXG4gICAgX3JlbmRlclRleHRDb21tb246IGZ1bmN0aW9uKGN0eCwgbWV0aG9kKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIGxpbmVIZWlnaHRzID0gMCwgbGVmdCA9IHRoaXMuX2dldExlZnRPZmZzZXQoKSwgdG9wID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKSxcbiAgICAgICAgICAgIG1heEhlaWdodCA9IGhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodCxcbiAgICAgICAgICAgIGxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChpKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dExpbmUoXG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIGN0eCxcbiAgICAgICAgICB0aGlzLl90ZXh0TGluZXNbaV0sXG4gICAgICAgICAgbGVmdCArIGxlZnRPZmZzZXQsXG4gICAgICAgICAgdG9wICsgbGluZUhlaWdodHMgKyBtYXhIZWlnaHQsXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgICBsaW5lSGVpZ2h0cyArPSBoZWlnaHRPZkxpbmU7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dEZpbGw6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLmZpbGwgJiYgIXRoaXMuc3R5bGVIYXMoJ2ZpbGwnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlbmRlclRleHRDb21tb24oY3R4LCAnZmlsbFRleHQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHRTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCghdGhpcy5zdHJva2UgfHwgdGhpcy5zdHJva2VXaWR0aCA9PT0gMCkgJiYgdGhpcy5pc0VtcHR5U3R5bGVzKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaGFkb3cgJiYgIXRoaXMuc2hhZG93LmFmZmVjdFN0cm9rZSkge1xuICAgICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICAgIH1cblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgdGhpcy5zdHJva2VEYXNoQXJyYXkpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dENvbW1vbihjdHgsICdzdHJva2VUZXh0Jyk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgZmlsbFRleHQgb3Igc3Ryb2tlVGV4dC5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGluZSBDb250ZW50IG9mIHRoZSBsaW5lLCBzcGxpdHRlZCBpbiBhbiBhcnJheSBieSBncmFwaGVtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKi9cbiAgICBfcmVuZGVyQ2hhcnM6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCkge1xuICAgICAgLy8gc2V0IHByb3BlciBsaW5lIG9mZnNldFxuICAgICAgdmFyIGxpbmVIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShsaW5lSW5kZXgpLFxuICAgICAgICAgIGlzSnVzdGlmeSA9IHRoaXMudGV4dEFsaWduLmluZGV4T2YoJ2p1c3RpZnknKSAhPT0gLTEsXG4gICAgICAgICAgYWN0dWFsU3R5bGUsXG4gICAgICAgICAgbmV4dFN0eWxlLFxuICAgICAgICAgIGNoYXJzVG9SZW5kZXIgPSAnJyxcbiAgICAgICAgICBjaGFyQm94LFxuICAgICAgICAgIGJveFdpZHRoID0gMCxcbiAgICAgICAgICB0aW1lVG9SZW5kZXIsXG4gICAgICAgICAgcGF0aCA9IHRoaXMucGF0aCxcbiAgICAgICAgICBzaG9ydEN1dCA9ICFpc0p1c3RpZnkgJiYgdGhpcy5jaGFyU3BhY2luZyA9PT0gMCAmJiB0aGlzLmlzRW1wdHlTdHlsZXMobGluZUluZGV4KSAmJiAhcGF0aCxcbiAgICAgICAgICBpc0x0ciA9IHRoaXMuZGlyZWN0aW9uID09PSAnbHRyJywgc2lnbiA9IHRoaXMuZGlyZWN0aW9uID09PSAnbHRyJyA/IDEgOiAtMSxcbiAgICAgICAgICBkcmF3aW5nTGVmdCwgY3VycmVudERpcmVjdGlvbiA9IGN0eC5jYW52YXMuZ2V0QXR0cmlidXRlKCdkaXInKTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBpZiAoY3VycmVudERpcmVjdGlvbiAhPT0gdGhpcy5kaXJlY3Rpb24pIHtcbiAgICAgICAgY3R4LmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2RpcicsIGlzTHRyID8gJ2x0cicgOiAncnRsJyk7XG4gICAgICAgIGN0eC5kaXJlY3Rpb24gPSBpc0x0ciA/ICdsdHInIDogJ3J0bCc7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBpc0x0ciA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICB9XG4gICAgICB0b3AgLT0gbGluZUhlaWdodCAqIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24gLyB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICBpZiAoc2hvcnRDdXQpIHtcbiAgICAgICAgLy8gcmVuZGVyIGFsbCB0aGUgbGluZSBpbiBvbmUgcGFzcyB3aXRob3V0IGNoZWNraW5nXG4gICAgICAgIC8vIGRyYXdpbmdMZWZ0ID0gaXNMdHIgPyBsZWZ0IDogbGVmdCAtIHRoaXMuZ2V0TGluZVdpZHRoKGxpbmVJbmRleCk7XG4gICAgICAgIHRoaXMuX3JlbmRlckNoYXIobWV0aG9kLCBjdHgsIGxpbmVJbmRleCwgMCwgbGluZS5qb2luKCcnKSwgbGVmdCwgdG9wLCBsaW5lSGVpZ2h0KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmUubGVuZ3RoIC0gMTsgaSA8PSBsZW47IGkrKykge1xuICAgICAgICB0aW1lVG9SZW5kZXIgPSBpID09PSBsZW4gfHwgdGhpcy5jaGFyU3BhY2luZyB8fCBwYXRoO1xuICAgICAgICBjaGFyc1RvUmVuZGVyICs9IGxpbmVbaV07XG4gICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2ldO1xuICAgICAgICBpZiAoYm94V2lkdGggPT09IDApIHtcbiAgICAgICAgICBsZWZ0ICs9IHNpZ24gKiAoY2hhckJveC5rZXJuZWRXaWR0aCAtIGNoYXJCb3gud2lkdGgpO1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNKdXN0aWZ5ICYmICF0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcmVTcGFjZUFuZFRhYi50ZXN0KGxpbmVbaV0pKSB7XG4gICAgICAgICAgICB0aW1lVG9SZW5kZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIC8vIGlmIHdlIGhhdmUgY2hhclNwYWNpbmcsIHdlIHJlbmRlciBjaGFyIGJ5IGNoYXJcbiAgICAgICAgICBhY3R1YWxTdHlsZSA9IGFjdHVhbFN0eWxlIHx8IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSk7XG4gICAgICAgICAgbmV4dFN0eWxlID0gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBpICsgMSk7XG4gICAgICAgICAgdGltZVRvUmVuZGVyID0gZmFicmljLnV0aWwuaGFzU3R5bGVDaGFuZ2VkKGFjdHVhbFN0eWxlLCBuZXh0U3R5bGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNoYXJCb3gucmVuZGVyTGVmdCwgY2hhckJveC5yZW5kZXJUb3ApO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShjaGFyQm94LmFuZ2xlKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckNoYXIobWV0aG9kLCBjdHgsIGxpbmVJbmRleCwgaSwgY2hhcnNUb1JlbmRlciwgLWJveFdpZHRoIC8gMiwgMCwgbGluZUhlaWdodCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRyYXdpbmdMZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckNoYXIobWV0aG9kLCBjdHgsIGxpbmVJbmRleCwgaSwgY2hhcnNUb1JlbmRlciwgZHJhd2luZ0xlZnQsIHRvcCwgbGluZUhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoYXJzVG9SZW5kZXIgPSAnJztcbiAgICAgICAgICBhY3R1YWxTdHlsZSA9IG5leHRTdHlsZTtcbiAgICAgICAgICBsZWZ0ICs9IHNpZ24gKiBib3hXaWR0aDtcbiAgICAgICAgICBib3hXaWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gdHJ5IHRvIHBhdGNoIHRoZSBtaXNzaW5nIGdyYWRpZW50VHJhbnNmb3JtIG9uIGNhbnZhcyBncmFkaWVudHMuXG4gICAgICogdHJhbnNmb3JtaW5nIGEgY29udGV4dCB0byB0cmFuc2Zvcm0gdGhlIGdyYWRpZW50LCBpcyBnb2luZyB0byB0cmFuc2Zvcm0gdGhlIHN0cm9rZSB0b28uXG4gICAgICogd2Ugd2FudCB0byB0cmFuc2Zvcm0gdGhlIGdyYWRpZW50IGJ1dCBub3QgdGhlIHN0cm9rZSBvcGVyYXRpb24sIHNvIHdlIGNyZWF0ZVxuICAgICAqIGEgdHJhbnNmb3JtZWQgZ3JhZGllbnQgb24gYSBwYXR0ZXJuIGFuZCB0aGVuIHdlIHVzZSB0aGUgcGF0dGVybiBpbnN0ZWFkIG9mIHRoZSBncmFkaWVudC5cbiAgICAgKiB0aGlzIG1ldGhvZCBoYXMgZHJhd2JhY2tzOiBpcyBzbG93LCBpcyBpbiBsb3cgcmVzb2x1dGlvbiwgbmVlZHMgYSBwYXRjaCBmb3Igd2hlbiB0aGUgc2l6ZVxuICAgICAqIGlzIGxpbWl0ZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5HcmFkaWVudH0gZmlsbGVyIGEgZmFicmljIGdyYWRpZW50IGluc3RhbmNlXG4gICAgICogQHJldHVybiB7Q2FudmFzUGF0dGVybn0gYSBwYXR0ZXJuIHRvIHVzZSBhcyBmaWxsL3N0cm9rZSBzdHlsZVxuICAgICAqL1xuICAgIF9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybVRleHQ6IGZ1bmN0aW9uKGZpbGxlcikge1xuICAgICAgdmFyIHBDYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksIHBDdHgsXG4gICAgICAgICAgLy8gVE9ETzogdmVyaWZ5IGNvbXBhdGliaWxpdHkgd2l0aCBzdHJva2VVbmlmb3JtXG4gICAgICAgICAgd2lkdGggPSB0aGlzLndpZHRoICsgdGhpcy5zdHJva2VXaWR0aCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgcENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBwQ3R4ID0gcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgcEN0eC5iZWdpblBhdGgoKTsgcEN0eC5tb3ZlVG8oMCwgMCk7IHBDdHgubGluZVRvKHdpZHRoLCAwKTsgcEN0eC5saW5lVG8od2lkdGgsIGhlaWdodCk7XG4gICAgICBwQ3R4LmxpbmVUbygwLCBoZWlnaHQpOyBwQ3R4LmNsb3NlUGF0aCgpO1xuICAgICAgcEN0eC50cmFuc2xhdGUod2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICAgIHBDdHguZmlsbFN0eWxlID0gZmlsbGVyLnRvTGl2ZShwQ3R4KTtcbiAgICAgIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKHBDdHgsIGZpbGxlcik7XG4gICAgICBwQ3R4LmZpbGwoKTtcbiAgICAgIHJldHVybiBwQ3R4LmNyZWF0ZVBhdHRlcm4ocENhbnZhcywgJ25vLXJlcGVhdCcpO1xuICAgIH0sXG5cbiAgICBoYW5kbGVGaWxsZXI6IGZ1bmN0aW9uKGN0eCwgcHJvcGVydHksIGZpbGxlcikge1xuICAgICAgdmFyIG9mZnNldFgsIG9mZnNldFk7XG4gICAgICBpZiAoZmlsbGVyLnRvTGl2ZSkge1xuICAgICAgICBpZiAoZmlsbGVyLmdyYWRpZW50VW5pdHMgPT09ICdwZXJjZW50YWdlJyB8fCBmaWxsZXIuZ3JhZGllbnRUcmFuc2Zvcm0gfHwgZmlsbGVyLnBhdHRlcm5UcmFuc2Zvcm0pIHtcbiAgICAgICAgICAvLyBuZWVkIHRvIHRyYW5zZm9ybSBncmFkaWVudCBpbiBhIHBhdHRlcm4uXG4gICAgICAgICAgLy8gdGhpcyBpcyBhIHNsb3cgcHJvY2Vzcy4gSWYgeW91IGFyZSBoaXR0aW5nIHRoaXMgY29kZXBhdGgsIGFuZCB0aGUgb2JqZWN0XG4gICAgICAgICAgLy8gaXMgbm90IHVzaW5nIGNhY2hpbmcsIHlvdSBzaG91bGQgY29uc2lkZXIgc3dpdGNoaW5nIGl0IG9uLlxuICAgICAgICAgIC8vIHdlIG5lZWQgYSBjYW52YXMgYXMgYmlnIGFzIHRoZSBjdXJyZW50IG9iamVjdCBjYWNoaW5nIGNhbnZhcy5cbiAgICAgICAgICBvZmZzZXRYID0gLXRoaXMud2lkdGggLyAyO1xuICAgICAgICAgIG9mZnNldFkgPSAtdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICAgIGN0eC50cmFuc2xhdGUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgICAgY3R4W3Byb3BlcnR5XSA9IHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtVGV4dChmaWxsZXIpO1xuICAgICAgICAgIHJldHVybiB7IG9mZnNldFg6IG9mZnNldFgsIG9mZnNldFk6IG9mZnNldFkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBpcyBhIHNpbXBsZSBncmFkaWVudCBvciBwYXR0ZXJuXG4gICAgICAgICAgY3R4W3Byb3BlcnR5XSA9IGZpbGxlci50b0xpdmUoY3R4LCB0aGlzKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0oY3R4LCBmaWxsZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaXMgYSBjb2xvclxuICAgICAgICBjdHhbcHJvcGVydHldID0gZmlsbGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgb2Zmc2V0WDogMCwgb2Zmc2V0WTogMCB9O1xuICAgIH0sXG5cbiAgICBfc2V0U3Ryb2tlU3R5bGVzOiBmdW5jdGlvbihjdHgsIGRlY2wpIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBkZWNsLnN0cm9rZVdpZHRoO1xuICAgICAgY3R4LmxpbmVDYXAgPSB0aGlzLnN0cm9rZUxpbmVDYXA7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB0aGlzLnN0cm9rZURhc2hPZmZzZXQ7XG4gICAgICBjdHgubGluZUpvaW4gPSB0aGlzLnN0cm9rZUxpbmVKb2luO1xuICAgICAgY3R4Lm1pdGVyTGltaXQgPSB0aGlzLnN0cm9rZU1pdGVyTGltaXQ7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVGaWxsZXIoY3R4LCAnc3Ryb2tlU3R5bGUnLCBkZWNsLnN0cm9rZSk7XG4gICAgfSxcblxuICAgIF9zZXRGaWxsU3R5bGVzOiBmdW5jdGlvbihjdHgsIGRlY2wpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZUZpbGxlcihjdHgsICdmaWxsU3R5bGUnLCBkZWNsLmZpbGwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gX2NoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVIZWlnaHQgSGVpZ2h0IG9mIHRoZSBsaW5lXG4gICAgICovXG4gICAgX3JlbmRlckNoYXI6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIGNoYXJJbmRleCwgX2NoYXIsIGxlZnQsIHRvcCkge1xuICAgICAgdmFyIGRlY2wgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSxcbiAgICAgICAgICBmdWxsRGVjbCA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSxcbiAgICAgICAgICBzaG91bGRGaWxsID0gbWV0aG9kID09PSAnZmlsbFRleHQnICYmIGZ1bGxEZWNsLmZpbGwsXG4gICAgICAgICAgc2hvdWxkU3Ryb2tlID0gbWV0aG9kID09PSAnc3Ryb2tlVGV4dCcgJiYgZnVsbERlY2wuc3Ryb2tlICYmIGZ1bGxEZWNsLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIGZpbGxPZmZzZXRzLCBzdHJva2VPZmZzZXRzO1xuXG4gICAgICBpZiAoIXNob3VsZFN0cm9rZSAmJiAhc2hvdWxkRmlsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICBzaG91bGRGaWxsICYmIChmaWxsT2Zmc2V0cyA9IHRoaXMuX3NldEZpbGxTdHlsZXMoY3R4LCBmdWxsRGVjbCkpO1xuICAgICAgc2hvdWxkU3Ryb2tlICYmIChzdHJva2VPZmZzZXRzID0gdGhpcy5fc2V0U3Ryb2tlU3R5bGVzKGN0eCwgZnVsbERlY2wpKTtcblxuICAgICAgY3R4LmZvbnQgPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24oZnVsbERlY2wpO1xuXG5cbiAgICAgIGlmIChkZWNsICYmIGRlY2wudGV4dEJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWNsICYmIGRlY2wuZGVsdGFZKSB7XG4gICAgICAgIHRvcCArPSBkZWNsLmRlbHRhWTtcbiAgICAgIH1cbiAgICAgIHNob3VsZEZpbGwgJiYgY3R4LmZpbGxUZXh0KF9jaGFyLCBsZWZ0IC0gZmlsbE9mZnNldHMub2Zmc2V0WCwgdG9wIC0gZmlsbE9mZnNldHMub2Zmc2V0WSk7XG4gICAgICBzaG91bGRTdHJva2UgJiYgY3R4LnN0cm9rZVRleHQoX2NoYXIsIGxlZnQgLSBzdHJva2VPZmZzZXRzLm9mZnNldFgsIHRvcCAtIHN0cm9rZU9mZnNldHMub2Zmc2V0WSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUdXJucyB0aGUgY2hhcmFjdGVyIGludG8gYSAnc3VwZXJpb3IgZmlndXJlJyAoaS5lLiAnc3VwZXJzY3JpcHQnKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBzZWxlY3Rpb24gc3RhcnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIHNlbGVjdGlvbiBlbmRcbiAgICAgKiBAcmV0dXJucyB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0U3VwZXJzY3JpcHQ6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRTY3JpcHQoc3RhcnQsIGVuZCwgdGhpcy5zdXBlcnNjcmlwdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIHRoZSBjaGFyYWN0ZXIgaW50byBhbiAnaW5mZXJpb3IgZmlndXJlJyAoaS5lLiAnc3Vic2NyaXB0JylcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgc2VsZWN0aW9uIHN0YXJ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBzZWxlY3Rpb24gZW5kXG4gICAgICogQHJldHVybnMge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFN1YnNjcmlwdDogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFNjcmlwdChzdGFydCwgZW5kLCB0aGlzLnN1YnNjcmlwdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgJ3NjaGVtYScgYXQgZ2l2ZW4gcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBzZWxlY3Rpb24gc3RhcnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIHNlbGVjdGlvbiBlbmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NoZW1hXG4gICAgICogQHJldHVybnMge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIF9zZXRTY3JpcHQ6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHNjaGVtYSkge1xuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzdGFydCwgdHJ1ZSksXG4gICAgICAgICAgZm9udFNpemUgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgsICdmb250U2l6ZScpLFxuICAgICAgICAgIGR5ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4LCAnZGVsdGFZJyksXG4gICAgICAgICAgc3R5bGUgPSB7IGZvbnRTaXplOiBmb250U2l6ZSAqIHNjaGVtYS5zaXplLCBkZWx0YVk6IGR5ICsgZm9udFNpemUgKiBzY2hlbWEuYmFzZWxpbmUgfTtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uU3R5bGVzKHN0eWxlLCBzdGFydCwgZW5kKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggaW5kZXggdGV4dCBsaW5lXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMaW5lIGxlZnQgb2Zmc2V0XG4gICAgICovXG4gICAgX2dldExpbmVMZWZ0T2Zmc2V0OiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLmdldExpbmVXaWR0aChsaW5lSW5kZXgpLFxuICAgICAgICAgIGxpbmVEaWZmID0gdGhpcy53aWR0aCAtIGxpbmVXaWR0aCwgdGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ24sIGRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uLFxuICAgICAgICAgIGlzRW5kT2ZXcmFwcGluZywgbGVmdE9mZnNldCA9IDAsIGlzRW5kT2ZXcmFwcGluZyA9IHRoaXMuaXNFbmRPZldyYXBwaW5nKGxpbmVJbmRleCk7XG4gICAgICBpZiAodGV4dEFsaWduID09PSAnanVzdGlmeSdcbiAgICAgICAgfHwgKHRleHRBbGlnbiA9PT0gJ2p1c3RpZnktY2VudGVyJyAmJiAhaXNFbmRPZldyYXBwaW5nKVxuICAgICAgICB8fCAodGV4dEFsaWduID09PSAnanVzdGlmeS1yaWdodCcgJiYgIWlzRW5kT2ZXcmFwcGluZylcbiAgICAgICAgfHwgKHRleHRBbGlnbiA9PT0gJ2p1c3RpZnktbGVmdCcgJiYgIWlzRW5kT2ZXcmFwcGluZylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGxlZnRPZmZzZXQgPSBsaW5lRGlmZiAvIDI7XG4gICAgICB9XG4gICAgICBpZiAodGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIGxlZnRPZmZzZXQgPSBsaW5lRGlmZjtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdqdXN0aWZ5LWNlbnRlcicpIHtcbiAgICAgICAgbGVmdE9mZnNldCA9IGxpbmVEaWZmIC8gMjtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdqdXN0aWZ5LXJpZ2h0Jykge1xuICAgICAgICBsZWZ0T2Zmc2V0ID0gbGluZURpZmY7XG4gICAgICB9XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICBsZWZ0T2Zmc2V0IC09IGxpbmVEaWZmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnRPZmZzZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NsZWFyQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX2xpbmVXaWR0aHMgPSBbXTtcbiAgICAgIHRoaXMuX19saW5lSGVpZ2h0cyA9IFtdO1xuICAgICAgdGhpcy5fX2NoYXJCb3VuZHMgPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2hvdWxkQ2xlYXIgPSB0aGlzLl9mb3JjZUNsZWFyQ2FjaGU7XG4gICAgICBzaG91bGRDbGVhciB8fCAoc2hvdWxkQ2xlYXIgPSB0aGlzLmhhc1N0YXRlQ2hhbmdlZCgnX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzJykpO1xuICAgICAgaWYgKHNob3VsZENsZWFyKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaG91bGRDbGVhcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZSBhIHNpbmdsZSBsaW5lIGdpdmVuIGl0cyBpbmRleC4gVXNlZCB0byBjYWxjdWxhdGUgdGhlIGluaXRpYWxcbiAgICAgKiB0ZXh0IGJvdW5kaW5nIGJveC4gVGhlIHZhbHVlcyBhcmUgY2FsY3VsYXRlZCBhbmQgc3RvcmVkIGluIF9fbGluZVdpZHRocyBjYWNoZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggbGluZSBudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExpbmUgd2lkdGhcbiAgICAgKi9cbiAgICBnZXRMaW5lV2lkdGg6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2xpbmVXaWR0aHNbbGluZUluZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmVJbmZvID0gdGhpcy5tZWFzdXJlTGluZShsaW5lSW5kZXgpO1xuICAgICAgdmFyIHdpZHRoID0gbGluZUluZm8ud2lkdGg7XG4gICAgICB0aGlzLl9fbGluZVdpZHRoc1tsaW5lSW5kZXhdID0gd2lkdGg7XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIF9nZXRXaWR0aE9mQ2hhclNwYWNpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udFNpemUgKiB0aGlzLmNoYXJTcGFjaW5nIC8gMTAwMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHZhbHVlIG9mIHByb3BlcnR5IGF0IGdpdmVuIGNoYXJhY3RlciBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggdGhlIGxpbmUgbnVtYmVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCB0aGUgY2hhcmFjdGVyIG51bWJlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSB0aGUgcHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm5zIHRoZSB2YWx1ZSBvZiAncHJvcGVydHknXG4gICAgICovXG4gICAgZ2V0VmFsdWVPZlByb3BlcnR5QXQ6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIGNoYXJTdHlsZSA9IHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXgpO1xuICAgICAgaWYgKGNoYXJTdHlsZSAmJiB0eXBlb2YgY2hhclN0eWxlW3Byb3BlcnR5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJTdHlsZVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1twcm9wZXJ0eV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0RGVjb3JhdGlvbjogZnVuY3Rpb24oY3R4LCB0eXBlKSB7XG4gICAgICBpZiAoIXRoaXNbdHlwZV0gJiYgIXRoaXMuc3R5bGVIYXModHlwZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGhlaWdodE9mTGluZSwgc2l6ZSwgX3NpemUsXG4gICAgICAgICAgbGluZUxlZnRPZmZzZXQsIGR5LCBfZHksXG4gICAgICAgICAgbGluZSwgbGFzdERlY29yYXRpb24sXG4gICAgICAgICAgbGVmdE9mZnNldCA9IHRoaXMuX2dldExlZnRPZmZzZXQoKSxcbiAgICAgICAgICB0b3BPZmZzZXQgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKSwgdG9wLFxuICAgICAgICAgIGJveFN0YXJ0LCBib3hXaWR0aCwgY2hhckJveCwgY3VycmVudERlY29yYXRpb24sXG4gICAgICAgICAgbWF4SGVpZ2h0LCBjdXJyZW50RmlsbCwgbGFzdEZpbGwsIHBhdGggPSB0aGlzLnBhdGgsXG4gICAgICAgICAgY2hhclNwYWNpbmcgPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKSxcbiAgICAgICAgICBvZmZzZXRZID0gdGhpcy5vZmZzZXRzW3R5cGVdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGhlaWdodE9mTGluZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgICBpZiAoIXRoaXNbdHlwZV0gJiYgIXRoaXMuc3R5bGVIYXModHlwZSwgaSkpIHtcbiAgICAgICAgICB0b3BPZmZzZXQgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbaV07XG4gICAgICAgIG1heEhlaWdodCA9IGhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodDtcbiAgICAgICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChpKTtcbiAgICAgICAgYm94U3RhcnQgPSAwO1xuICAgICAgICBib3hXaWR0aCA9IDA7XG4gICAgICAgIGxhc3REZWNvcmF0aW9uID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCAwLCB0eXBlKTtcbiAgICAgICAgbGFzdEZpbGwgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsICdmaWxsJyk7XG4gICAgICAgIHRvcCA9IHRvcE9mZnNldCArIG1heEhlaWdodCAqICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbik7XG4gICAgICAgIHNpemUgPSB0aGlzLmdldEhlaWdodE9mQ2hhcihpLCAwKTtcbiAgICAgICAgZHkgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsICdkZWx0YVknKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tpXVtqXTtcbiAgICAgICAgICBjdXJyZW50RGVjb3JhdGlvbiA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgaiwgdHlwZSk7XG4gICAgICAgICAgY3VycmVudEZpbGwgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosICdmaWxsJyk7XG4gICAgICAgICAgX3NpemUgPSB0aGlzLmdldEhlaWdodE9mQ2hhcihpLCBqKTtcbiAgICAgICAgICBfZHkgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosICdkZWx0YVknKTtcbiAgICAgICAgICBpZiAocGF0aCAmJiBjdXJyZW50RGVjb3JhdGlvbiAmJiBjdXJyZW50RmlsbCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYXN0RmlsbDtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY2hhckJveC5yZW5kZXJMZWZ0LCBjaGFyQm94LnJlbmRlclRvcCk7XG4gICAgICAgICAgICBjdHgucm90YXRlKGNoYXJCb3guYW5nbGUpO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAtY2hhckJveC5rZXJuZWRXaWR0aCAvIDIsXG4gICAgICAgICAgICAgIG9mZnNldFkgKiBfc2l6ZSArIF9keSxcbiAgICAgICAgICAgICAgY2hhckJveC5rZXJuZWRXaWR0aCxcbiAgICAgICAgICAgICAgdGhpcy5mb250U2l6ZSAvIDE1XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAoY3VycmVudERlY29yYXRpb24gIT09IGxhc3REZWNvcmF0aW9uIHx8IGN1cnJlbnRGaWxsICE9PSBsYXN0RmlsbCB8fCBfc2l6ZSAhPT0gc2l6ZSB8fCBfZHkgIT09IGR5KVxuICAgICAgICAgICAgJiYgYm94V2lkdGggPiAwXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgZHJhd1N0YXJ0ID0gbGVmdE9mZnNldCArIGxpbmVMZWZ0T2Zmc2V0ICsgYm94U3RhcnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgICAgICAgIGRyYXdTdGFydCA9IHRoaXMud2lkdGggLSBkcmF3U3RhcnQgLSBib3hXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0RGVjb3JhdGlvbiAmJiBsYXN0RmlsbCkge1xuICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFzdEZpbGw7XG4gICAgICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgICBkcmF3U3RhcnQsXG4gICAgICAgICAgICAgICAgdG9wICsgb2Zmc2V0WSAqIHNpemUgKyBkeSxcbiAgICAgICAgICAgICAgICBib3hXaWR0aCxcbiAgICAgICAgICAgICAgICB0aGlzLmZvbnRTaXplIC8gMTVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJveFN0YXJ0ID0gY2hhckJveC5sZWZ0O1xuICAgICAgICAgICAgYm94V2lkdGggPSBjaGFyQm94LndpZHRoO1xuICAgICAgICAgICAgbGFzdERlY29yYXRpb24gPSBjdXJyZW50RGVjb3JhdGlvbjtcbiAgICAgICAgICAgIGxhc3RGaWxsID0gY3VycmVudEZpbGw7XG4gICAgICAgICAgICBzaXplID0gX3NpemU7XG4gICAgICAgICAgICBkeSA9IF9keTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZHJhd1N0YXJ0ID0gbGVmdE9mZnNldCArIGxpbmVMZWZ0T2Zmc2V0ICsgYm94U3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgICBkcmF3U3RhcnQgPSB0aGlzLndpZHRoIC0gZHJhd1N0YXJ0IC0gYm94V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGN1cnJlbnRGaWxsO1xuICAgICAgICBjdXJyZW50RGVjb3JhdGlvbiAmJiBjdXJyZW50RmlsbCAmJiBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgZHJhd1N0YXJ0LFxuICAgICAgICAgIHRvcCArIG9mZnNldFkgKiBzaXplICsgZHksXG4gICAgICAgICAgYm94V2lkdGggLSBjaGFyU3BhY2luZyxcbiAgICAgICAgICB0aGlzLmZvbnRTaXplIC8gMTVcbiAgICAgICAgKTtcbiAgICAgICAgdG9wT2Zmc2V0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZXJlIGlzIHRleHQgYmFja2dyb3VuZCBjb2xvciBub1xuICAgICAgLy8gb3RoZXIgc2hhZG93cyBzaG91bGQgYmUgY2FzdGVkXG4gICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGZvbnQgZGVjbGFyYXRpb24gc3RyaW5nIGZvciBjYW52YXMgY29udGV4dFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVPYmplY3RdIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGZvbnQgZGVjbGFyYXRpb24gZm9ybWF0dGVkIGZvciBjYW52YXMgY29udGV4dC5cbiAgICAgKi9cbiAgICBfZ2V0Rm9udERlY2xhcmF0aW9uOiBmdW5jdGlvbihzdHlsZU9iamVjdCwgZm9yTWVhc3VyaW5nKSB7XG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZU9iamVjdCB8fCB0aGlzLCBmYW1pbHkgPSB0aGlzLmZvbnRGYW1pbHksXG4gICAgICAgICAgZm9udElzR2VuZXJpYyA9IGZhYnJpYy5UZXh0LmdlbmVyaWNGb250cy5pbmRleE9mKGZhbWlseS50b0xvd2VyQ2FzZSgpKSA+IC0xO1xuICAgICAgdmFyIGZvbnRGYW1pbHkgPSBmYW1pbHkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgZmFtaWx5LmluZGV4T2YoJ1xcJycpID4gLTEgfHwgZmFtaWx5LmluZGV4T2YoJywnKSA+IC0xIHx8XG4gICAgICBmYW1pbHkuaW5kZXhPZignXCInKSA+IC0xIHx8IGZvbnRJc0dlbmVyaWNcbiAgICAgICAgPyBzdHlsZS5mb250RmFtaWx5IDogJ1wiJyArIHN0eWxlLmZvbnRGYW1pbHkgKyAnXCInO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLy8gbm9kZS1jYW52YXMgbmVlZHMgXCJ3ZWlnaHQgc3R5bGVcIiwgd2hpbGUgYnJvd3NlcnMgbmVlZCBcInN0eWxlIHdlaWdodFwiXG4gICAgICAgIC8vIHZlcmlmeSBpZiB0aGlzIGNhbiBiZSBmaXhlZCBpbiBKU0RPTVxuICAgICAgICAoZmFicmljLmlzTGlrZWx5Tm9kZSA/IHN0eWxlLmZvbnRXZWlnaHQgOiBzdHlsZS5mb250U3R5bGUpLFxuICAgICAgICAoZmFicmljLmlzTGlrZWx5Tm9kZSA/IHN0eWxlLmZvbnRTdHlsZSA6IHN0eWxlLmZvbnRXZWlnaHQpLFxuICAgICAgICBmb3JNZWFzdXJpbmcgPyB0aGlzLkNBQ0hFX0ZPTlRfU0laRSArICdweCcgOiBzdHlsZS5mb250U2l6ZSArICdweCcsXG4gICAgICAgIGZvbnRGYW1pbHlcbiAgICAgIF0uam9pbignICcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRleHQgaW5zdGFuY2Ugb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgLy8gZG8gbm90IHJlbmRlciBpZiBvYmplY3QgaXMgbm90IHZpc2libGVcbiAgICAgIGlmICghdGhpcy52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5za2lwT2Zmc2NyZWVuICYmICF0aGlzLmdyb3VwICYmICF0aGlzLmlzT25TY3JlZW4oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdyZW5kZXInLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZXh0IGFzIGFuIGFycmF5IG9mIGxpbmVzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRleHQgdG8gc3BsaXRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IExpbmVzIGluIHRoZSB0ZXh0XG4gICAgICovXG4gICAgX3NwbGl0VGV4dEludG9MaW5lczogZnVuY3Rpb24odGV4dCkge1xuICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCh0aGlzLl9yZU5ld2xpbmUpLFxuICAgICAgICAgIG5ld0xpbmVzID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCksXG4gICAgICAgICAgbmV3TGluZSA9IFsnXFxuJ10sXG4gICAgICAgICAgbmV3VGV4dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdMaW5lc1tpXSA9IGZhYnJpYy51dGlsLnN0cmluZy5ncmFwaGVtZVNwbGl0KGxpbmVzW2ldKTtcbiAgICAgICAgbmV3VGV4dCA9IG5ld1RleHQuY29uY2F0KG5ld0xpbmVzW2ldLCBuZXdMaW5lKTtcbiAgICAgIH1cbiAgICAgIG5ld1RleHQucG9wKCk7XG4gICAgICByZXR1cm4geyBfdW53cmFwcGVkTGluZXM6IG5ld0xpbmVzLCBsaW5lczogbGluZXMsIGdyYXBoZW1lVGV4dDogbmV3VGV4dCwgZ3JhcGhlbWVMaW5lczogbmV3TGluZXMgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIGFsbFByb3BlcnRpZXMgPSBhZGRpdGlvbmFsUHJvcHMuY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgdmFyIG9iaiA9IHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIGFsbFByb3BlcnRpZXMpO1xuICAgICAgb2JqLnN0eWxlcyA9IGZhYnJpYy51dGlsLnN0eWxlc1RvQXJyYXkodGhpcy5zdHlsZXMsIHRoaXMudGV4dCk7XG4gICAgICBpZiAob2JqLnBhdGgpIHtcbiAgICAgICAgb2JqLnBhdGggPSB0aGlzLnBhdGgudG9PYmplY3QoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgcHJvcGVydHkgdG8gYSBnaXZlbiB2YWx1ZS4gV2hlbiBjaGFuZ2luZyBwb3NpdGlvbi9kaW1lbnNpb24gLXJlbGF0ZWQgcHJvcGVydGllcyAobGVmdCwgdG9wLCBzY2FsZSwgYW5nbGUsIGV0Yy4pIGBzZXRgIGRvZXMgbm90IHVwZGF0ZSBwb3NpdGlvbiBvZiBvYmplY3QncyBib3JkZXJzL2NvbnRyb2xzLiBJZiB5b3UgbmVlZCB0byB1cGRhdGUgdGhvc2UsIGNhbGwgYHNldENvb3JkcygpYC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGtleSBQcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCAoaWYgb2JqZWN0LCBpdGVyYXRlIG92ZXIgdGhlIG9iamVjdCBwcm9wZXJ0aWVzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSAoaWYgZnVuY3Rpb24sIHRoZSB2YWx1ZSBpcyBwYXNzZWQgaW50byBpdCBhbmQgaXRzIHJldHVybiB2YWx1ZSBpcyB1c2VkIGFzIGEgbmV3IG9uZSlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ3NldCcsIGtleSwgdmFsdWUpO1xuICAgICAgdmFyIG5lZWRzRGltcyA9IGZhbHNlO1xuICAgICAgdmFyIGlzQWRkaW5nUGF0aCA9IGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIF9rZXkgaW4ga2V5KSB7XG4gICAgICAgICAgaWYgKF9rZXkgPT09ICdwYXRoJykge1xuICAgICAgICAgICAgdGhpcy5zZXRQYXRoSW5mbygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZWVkc0RpbXMgPSBuZWVkc0RpbXMgfHwgdGhpcy5fZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMuaW5kZXhPZihfa2V5KSAhPT0gLTE7XG4gICAgICAgICAgaXNBZGRpbmdQYXRoID0gaXNBZGRpbmdQYXRoIHx8IF9rZXkgPT09ICdwYXRoJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5lZWRzRGltcyA9IHRoaXMuX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG4gICAgICAgIGlzQWRkaW5nUGF0aCA9IGtleSA9PT0gJ3BhdGgnO1xuICAgICAgfVxuICAgICAgaWYgKGlzQWRkaW5nUGF0aCkge1xuICAgICAgICB0aGlzLnNldFBhdGhJbmZvKCk7XG4gICAgICB9XG4gICAgICBpZiAobmVlZHNEaW1zKSB7XG4gICAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXhpdHkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHlcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuVGV4dC5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqIEBzZWU6IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy90ZXh0Lmh0bWwjVGV4dEVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5UZXh0LkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoXG4gICAgJ3ggeSBkeCBkeSBmb250LWZhbWlseSBmb250LXN0eWxlIGZvbnQtd2VpZ2h0IGZvbnQtc2l6ZSBsZXR0ZXItc3BhY2luZyB0ZXh0LWRlY29yYXRpb24gdGV4dC1hbmNob3InLnNwbGl0KCcgJykpO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IFNWRyBmb250IHNpemVcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRcbiAgICovXG4gIGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRSA9IDE2O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhYnJpYy5UZXh0IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnQgKDxiPm5vdCB5ZXQgaW1wbGVtZW50ZWQ8L2I+KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvbiBpbnZva2VkIGFmdGVyIHBhcnNpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLlRleHQuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cblxuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuVGV4dC5BVFRSSUJVVEVfTkFNRVMpLFxuICAgICAgICBwYXJzZWRBbmNob3IgPSBwYXJzZWRBdHRyaWJ1dGVzLnRleHRBbmNob3IgfHwgJ2xlZnQnO1xuICAgIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKChvcHRpb25zID8gY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKTtcblxuICAgIG9wdGlvbnMudG9wID0gb3B0aW9ucy50b3AgfHwgMDtcbiAgICBvcHRpb25zLmxlZnQgPSBvcHRpb25zLmxlZnQgfHwgMDtcbiAgICBpZiAocGFyc2VkQXR0cmlidXRlcy50ZXh0RGVjb3JhdGlvbikge1xuICAgICAgdmFyIHRleHREZWNvcmF0aW9uID0gcGFyc2VkQXR0cmlidXRlcy50ZXh0RGVjb3JhdGlvbjtcbiAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCd1bmRlcmxpbmUnKSAhPT0gLTEpIHtcbiAgICAgICAgb3B0aW9ucy51bmRlcmxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRleHREZWNvcmF0aW9uLmluZGV4T2YoJ292ZXJsaW5lJykgIT09IC0xKSB7XG4gICAgICAgIG9wdGlvbnMub3ZlcmxpbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRleHREZWNvcmF0aW9uLmluZGV4T2YoJ2xpbmUtdGhyb3VnaCcpICE9PSAtMSkge1xuICAgICAgICBvcHRpb25zLmxpbmV0aHJvdWdoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBvcHRpb25zLnRleHREZWNvcmF0aW9uO1xuICAgIH1cbiAgICBpZiAoJ2R4JyBpbiBwYXJzZWRBdHRyaWJ1dGVzKSB7XG4gICAgICBvcHRpb25zLmxlZnQgKz0gcGFyc2VkQXR0cmlidXRlcy5keDtcbiAgICB9XG4gICAgaWYgKCdkeScgaW4gcGFyc2VkQXR0cmlidXRlcykge1xuICAgICAgb3B0aW9ucy50b3AgKz0gcGFyc2VkQXR0cmlidXRlcy5keTtcbiAgICB9XG4gICAgaWYgKCEoJ2ZvbnRTaXplJyBpbiBvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucy5mb250U2l6ZSA9IGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRTtcbiAgICB9XG5cbiAgICB2YXIgdGV4dENvbnRlbnQgPSAnJztcblxuICAgIC8vIFRoZSBYTUwgaXMgbm90IHByb3Blcmx5IHBhcnNlZCBpbiBJRTkgc28gYSB3b3JrYXJvdW5kIHRvIGdldFxuICAgIC8vIHRleHRDb250ZW50IGlzIHRocm91Z2ggZmlyc3RDaGlsZC5kYXRhLiBBbm90aGVyIHdvcmthcm91bmQgd291bGQgYmVcbiAgICAvLyB0byBjb252ZXJ0IFhNTCBsb2FkZWQgZnJvbSBhIGZpbGUgdG8gYmUgY29udmVydGVkIHVzaW5nIERPTVBhcnNlciAoc2FtZSB3YXkgbG9hZFNWR0Zyb21TdHJpbmcoKSBkb2VzKVxuICAgIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZWxlbWVudCkpIHtcbiAgICAgIGlmICgnZmlyc3RDaGlsZCcgaW4gZWxlbWVudCAmJiBlbGVtZW50LmZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCdkYXRhJyBpbiBlbGVtZW50LmZpcnN0Q2hpbGQgJiYgZWxlbWVudC5maXJzdENoaWxkLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICB0ZXh0Q29udGVudCA9IGVsZW1lbnQuZmlyc3RDaGlsZC5kYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGV4dENvbnRlbnQgPSBlbGVtZW50LnRleHRDb250ZW50O1xuICAgIH1cblxuICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQucmVwbGFjZSgvXlxccyt8XFxzKyR8XFxuKy9nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgIHZhciBvcmlnaW5hbFN0cm9rZVdpZHRoID0gb3B0aW9ucy5zdHJva2VXaWR0aDtcbiAgICBvcHRpb25zLnN0cm9rZVdpZHRoID0gMDtcblxuICAgIHZhciB0ZXh0ID0gbmV3IGZhYnJpYy5UZXh0KHRleHRDb250ZW50LCBvcHRpb25zKSxcbiAgICAgICAgdGV4dEhlaWdodFNjYWxlRmFjdG9yID0gdGV4dC5nZXRTY2FsZWRIZWlnaHQoKSAvIHRleHQuaGVpZ2h0LFxuICAgICAgICBsaW5lSGVpZ2h0RGlmZiA9ICh0ZXh0LmhlaWdodCArIHRleHQuc3Ryb2tlV2lkdGgpICogdGV4dC5saW5lSGVpZ2h0IC0gdGV4dC5oZWlnaHQsXG4gICAgICAgIHNjYWxlZERpZmYgPSBsaW5lSGVpZ2h0RGlmZiAqIHRleHRIZWlnaHRTY2FsZUZhY3RvcixcbiAgICAgICAgdGV4dEhlaWdodCA9IHRleHQuZ2V0U2NhbGVkSGVpZ2h0KCkgKyBzY2FsZWREaWZmLFxuICAgICAgICBvZmZYID0gMDtcbiAgICAvKlxuICAgICAgQWRqdXN0IHBvc2l0aW9uaW5nOlxuICAgICAgICB4L3kgYXR0cmlidXRlcyBpbiBTVkcgY29ycmVzcG9uZCB0byB0aGUgYm90dG9tLWxlZnQgY29ybmVyIG9mIHRleHQgYm91bmRpbmcgYm94XG4gICAgICAgIGZhYnJpYyBvdXRwdXQgYnkgZGVmYXVsdCBhdCB0b3AsIGxlZnQuXG4gICAgKi9cbiAgICBpZiAocGFyc2VkQW5jaG9yID09PSAnY2VudGVyJykge1xuICAgICAgb2ZmWCA9IHRleHQuZ2V0U2NhbGVkV2lkdGgoKSAvIDI7XG4gICAgfVxuICAgIGlmIChwYXJzZWRBbmNob3IgPT09ICdyaWdodCcpIHtcbiAgICAgIG9mZlggPSB0ZXh0LmdldFNjYWxlZFdpZHRoKCk7XG4gICAgfVxuICAgIHRleHQuc2V0KHtcbiAgICAgIGxlZnQ6IHRleHQubGVmdCAtIG9mZlgsXG4gICAgICB0b3A6IHRleHQudG9wIC0gKHRleHRIZWlnaHQgLSB0ZXh0LmZvbnRTaXplICogKDAuMDcgKyB0ZXh0Ll9mb250U2l6ZUZyYWN0aW9uKSkgLyB0ZXh0LmxpbmVIZWlnaHQsXG4gICAgICBzdHJva2VXaWR0aDogdHlwZW9mIG9yaWdpbmFsU3Ryb2tlV2lkdGggIT09ICd1bmRlZmluZWQnID8gb3JpZ2luYWxTdHJva2VXaWR0aCA6IDEsXG4gICAgfSk7XG4gICAgY2FsbGJhY2sodGV4dCk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlRleHQgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBwbGFpbiBqcyBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuVGV4dCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuVGV4dC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBvYmplY3RDb3B5ID0gY2xvbmUob2JqZWN0KSwgcGF0aCA9IG9iamVjdC5wYXRoO1xuICAgIGRlbGV0ZSBvYmplY3RDb3B5LnBhdGg7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1RleHQnLCBvYmplY3RDb3B5LCBmdW5jdGlvbih0ZXh0SW5zdGFuY2UpIHtcbiAgICAgIHRleHRJbnN0YW5jZS5zdHlsZXMgPSBmYWJyaWMudXRpbC5zdHlsZXNGcm9tQXJyYXkob2JqZWN0LnN0eWxlcywgb2JqZWN0LnRleHQpO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUGF0aCcsIHBhdGgsIGZ1bmN0aW9uKHBhdGhJbnN0YW5jZSkge1xuICAgICAgICAgIHRleHRJbnN0YW5jZS5zZXQoJ3BhdGgnLCBwYXRoSW5zdGFuY2UpO1xuICAgICAgICAgIGNhbGxiYWNrKHRleHRJbnN0YW5jZSk7XG4gICAgICAgIH0sICdwYXRoJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sodGV4dEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9LCAndGV4dCcpO1xuICB9O1xuXG4gIGZhYnJpYy5UZXh0LmdlbmVyaWNGb250cyA9IFsnc2Fucy1zZXJpZicsICdzZXJpZicsICdjdXJzaXZlJywgJ2ZhbnRhc3knLCAnbW9ub3NwYWNlJ107XG5cbiAgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzICYmIGZhYnJpYy51dGlsLmNyZWF0ZUFjY2Vzc29ycyhmYWJyaWMuVGV4dCk7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5UZXh0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBoYXMgbm8gc3R5bGluZyBvciBubyBzdHlsaW5nIGluIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggLCBsaW5lSW5kZXggaXMgb24gd3JhcHBlZCBsaW5lcy5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHlTdHlsZXM6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGluZUluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiAhdGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB0eXBlb2YgbGluZUluZGV4ID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc3R5bGVzIDogeyBsaW5lOiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdIH07XG4gICAgICBmb3IgKHZhciBwMSBpbiBvYmopIHtcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gb2JqW3AxXSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgIGZvciAodmFyIHAzIGluIG9ialtwMV1bcDJdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBoYXMgYSBzdHlsZSBwcm9wZXJ0eSBvciBoYXMgaXQgaW5hIHNwZWNpZmllZCBsaW5lXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGRldGVjdCBpZiBhIHRleHQgd2lsbCB1c2UgYSBwYXJ0aWN1bGFyIHByb3BlcnR5IG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgdG8gY2hlY2sgZm9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCB0byBjaGVjayB0aGUgc3R5bGUgb25cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0eWxlSGFzOiBmdW5jdGlvbihwcm9wZXJ0eSwgbGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzIHx8ICFwcm9wZXJ0eSB8fCBwcm9wZXJ0eSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsaW5lSW5kZXggIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB0eXBlb2YgbGluZUluZGV4ID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc3R5bGVzIDogeyAwOiB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdIH07XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gb2JqW3AxXSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW3AxXVtwMl1bcHJvcGVydHldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGNoYXJhY3RlcnMgaW4gYSB0ZXh0IGhhdmUgYSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eVxuICAgICAqIHdob3NlIHZhbHVlIG1hdGNoZXMgdGhlIHRleHRib3gncyB2YWx1ZSBmb3IgdGhhdCBwcm9wZXJ0eS4gIElmIHNvLFxuICAgICAqIHRoZSBjaGFyYWN0ZXItbGV2ZWwgcHJvcGVydHkgaXMgZGVsZXRlZC4gIElmIHRoZSBjaGFyYWN0ZXJcbiAgICAgKiBoYXMgbm8gb3RoZXIgcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbHNvIGRlbGV0ZWQuICBGaW5hbGx5LFxuICAgICAqIGlmIHRoZSBsaW5lIGNvbnRhaW5pbmcgdGhhdCBjaGFyYWN0ZXIgaGFzIG5vIG90aGVyIGNoYXJhY3RlcnNcbiAgICAgKiB0aGVuIGl0IGFsc28gaXMgZGVsZXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkgdG8gY29tcGFyZSBiZXR3ZWVuIGNoYXJhY3RlcnMgYW5kIHRleHQuXG4gICAgICovXG4gICAgY2xlYW5TdHlsZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMgfHwgIXByb3BlcnR5IHx8IHByb3BlcnR5ID09PSAnJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdGhpcy5zdHlsZXMsIHN0eWxlc0NvdW50ID0gMCwgbGV0dGVyQ291bnQsIHN0eWxlUHJvcGVydHlWYWx1ZSxcbiAgICAgICAgICBhbGxTdHlsZU9iamVjdFByb3BlcnRpZXNNYXRjaCA9IHRydWUsIGdyYXBoZW1lQ291bnQgPSAwLCBzdHlsZU9iamVjdDtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgZm9yICh2YXIgcDEgaW4gb2JqKSB7XG4gICAgICAgIGxldHRlckNvdW50ID0gMDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGZvciAodmFyIHAyIGluIG9ialtwMV0pIHtcbiAgICAgICAgICB2YXIgc3R5bGVPYmplY3QgPSBvYmpbcDFdW3AyXSxcbiAgICAgICAgICAgICAgc3R5bGVQcm9wZXJ0eUhhc0JlZW5TZXQgPSBzdHlsZU9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSk7XG5cbiAgICAgICAgICBzdHlsZXNDb3VudCsrO1xuXG4gICAgICAgICAgaWYgKHN0eWxlUHJvcGVydHlIYXNCZWVuU2V0KSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgICBzdHlsZVByb3BlcnR5VmFsdWUgPSBzdHlsZU9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdHlsZU9iamVjdFtwcm9wZXJ0eV0gIT09IHN0eWxlUHJvcGVydHlWYWx1ZSkge1xuICAgICAgICAgICAgICBhbGxTdHlsZU9iamVjdFByb3BlcnRpZXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3R5bGVPYmplY3RbcHJvcGVydHldID09PSB0aGlzW3Byb3BlcnR5XSkge1xuICAgICAgICAgICAgICBkZWxldGUgc3R5bGVPYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFsbFN0eWxlT2JqZWN0UHJvcGVydGllc01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHN0eWxlT2JqZWN0KS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGxldHRlckNvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG9ialtwMV1bcDJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZXR0ZXJDb3VudCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmpbcDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBpZiBldmVyeSBncmFwaGVtZSBoYXMgdGhlIHNhbWUgc3R5bGUgc2V0IHRoZW5cbiAgICAgIC8vIGRlbGV0ZSB0aG9zZSBzdHlsZXMgYW5kIHNldCBpdCBvbiB0aGUgcGFyZW50XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBncmFwaGVtZUNvdW50ICs9IHRoaXMuX3RleHRMaW5lc1tpXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2ggJiYgc3R5bGVzQ291bnQgPT09IGdyYXBoZW1lQ291bnQpIHtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBzdHlsZVByb3BlcnR5VmFsdWU7XG4gICAgICAgIHRoaXMucmVtb3ZlU3R5bGUocHJvcGVydHkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzdHlsZSBwcm9wZXJ0eSBvciBwcm9wZXJ0aWVzIGZyb20gYWxsIGluZGl2aWR1YWwgY2hhcmFjdGVyIHN0eWxlc1xuICAgICAqIGluIGEgdGV4dCBvYmplY3QuICBEZWxldGVzIHRoZSBjaGFyYWN0ZXIgc3R5bGUgb2JqZWN0IGlmIGl0IGNvbnRhaW5zIG5vIG90aGVyIHN0eWxlXG4gICAgICogcHJvcHMuICBEZWxldGVzIGEgbGluZSBzdHlsZSBvYmplY3QgaWYgaXQgY29udGFpbnMgbm8gb3RoZXIgY2hhcmFjdGVyIHN0eWxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wcyBUaGUgcHJvcGVydHkgdG8gcmVtb3ZlIGZyb20gY2hhcmFjdGVyIHN0eWxlcy5cbiAgICAgKi9cbiAgICByZW1vdmVTdHlsZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMgfHwgIXByb3BlcnR5IHx8IHByb3BlcnR5ID09PSAnJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gdGhpcy5zdHlsZXMsIGxpbmUsIGxpbmVOdW0sIGNoYXJOdW07XG4gICAgICBmb3IgKGxpbmVOdW0gaW4gb2JqKSB7XG4gICAgICAgIGxpbmUgPSBvYmpbbGluZU51bV07XG4gICAgICAgIGZvciAoY2hhck51bSBpbiBsaW5lKSB7XG4gICAgICAgICAgZGVsZXRlIGxpbmVbY2hhck51bV1bcHJvcGVydHldO1xuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhsaW5lW2NoYXJOdW1dKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsaW5lW2NoYXJOdW1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobGluZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIG9ialtsaW5lTnVtXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9leHRlbmRTdHlsZXM6IGZ1bmN0aW9uKGluZGV4LCBzdHlsZXMpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oaW5kZXgpO1xuXG4gICAgICBpZiAoIXRoaXMuX2dldExpbmVTdHlsZShsb2MubGluZUluZGV4KSkge1xuICAgICAgICB0aGlzLl9zZXRMaW5lU3R5bGUobG9jLmxpbmVJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4KSkge1xuICAgICAgICB0aGlzLl9zZXRTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgsIHt9KTtcbiAgICAgIH1cblxuICAgICAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCh0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgpLCBzdHlsZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIDJkIHJlcHJlc2VudGF0aW9uIChsaW5lSW5kZXggYW5kIGNoYXJJbmRleCkgb2YgY3Vyc29yIChvciBzZWxlY3Rpb24gc3RhcnQpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzZWxlY3Rpb25TdGFydF0gT3B0aW9uYWwgaW5kZXguIFdoZW4gbm90IGdpdmVuLCBjdXJyZW50IHNlbGVjdGlvblN0YXJ0IGlzIHVzZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcFdyYXBwaW5nXSBjb25zaWRlciB0aGUgbG9jYXRpb24gZm9yIHVud3JhcHBlZCBsaW5lcy4gdXNlZnVsIHRvIG1hbmFnZSBzdHlsZXMuXG4gICAgICovXG4gICAgZ2V0MkRDdXJzb3JMb2NhdGlvbjogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQsIHNraXBXcmFwcGluZykge1xuICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rpb25TdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgfVxuICAgICAgdmFyIGxpbmVzID0gc2tpcFdyYXBwaW5nID8gdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzIDogdGhpcy5fdGV4dExpbmVzLFxuICAgICAgICAgIGxlbiA9IGxpbmVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0IDw9IGxpbmVzW2ldLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lSW5kZXg6IGksXG4gICAgICAgICAgICBjaGFySW5kZXg6IHNlbGVjdGlvblN0YXJ0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb25TdGFydCAtPSBsaW5lc1tpXS5sZW5ndGggKyB0aGlzLm1pc3NpbmdOZXdsaW5lT2Zmc2V0KGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZUluZGV4OiBpIC0gMSxcbiAgICAgICAgY2hhckluZGV4OiBsaW5lc1tpIC0gMV0ubGVuZ3RoIDwgc2VsZWN0aW9uU3RhcnQgPyBsaW5lc1tpIC0gMV0ubGVuZ3RoIDogc2VsZWN0aW9uU3RhcnRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgc3R5bGUgb2YgYSBjdXJyZW50IHNlbGVjdGlvbi9jdXJzb3IgKGF0IHRoZSBzdGFydCBwb3NpdGlvbilcbiAgICAgKiBpZiBzdGFydEluZGV4IG9yIGVuZEluZGV4IGFyZSBub3QgcHJvdmlkZWQsIHNlbGVjdGlvblN0YXJ0IG9yIHNlbGVjdGlvbkVuZCB3aWxsIGJlIHVzZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydEluZGV4XSBTdGFydCBpbmRleCB0byBnZXQgc3R5bGVzIGF0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRJbmRleF0gRW5kIGluZGV4IHRvIGdldCBzdHlsZXMgYXQsIGlmIG5vdCBzcGVjaWZpZWQgc2VsZWN0aW9uRW5kIG9yIHN0YXJ0SW5kZXggKyAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29tcGxldGVdIGdldCBmdWxsIHN0eWxlIG9yIG5vdFxuICAgICAqIEByZXR1cm4ge0FycmF5fSBzdHlsZXMgYW4gYXJyYXkgd2l0aCBvbmUsIHplcm8gb3IgbW9yZSBTdHlsZSBvYmplY3RzXG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uU3R5bGVzOiBmdW5jdGlvbihzdGFydEluZGV4LCBlbmRJbmRleCwgY29tcGxldGUpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RhcnRJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQgfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZW5kSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVuZEluZGV4ID0gdGhpcy5zZWxlY3Rpb25FbmQgfHwgc3RhcnRJbmRleDtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xuICAgICAgICBzdHlsZXMucHVzaCh0aGlzLmdldFN0eWxlQXRQb3NpdGlvbihpLCBjb21wbGV0ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBzdHlsZSBvZiBhIGN1cnJlbnQgc2VsZWN0aW9uL2N1cnNvciBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAgdG8gZ2V0IHN0eWxlcyBhdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXBsZXRlXSBmdWxsIHN0eWxlIGlmIHRydWVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHN0eWxlIFN0eWxlIG9iamVjdCBhdCBhIHNwZWNpZmllZCBpbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0U3R5bGVBdFBvc2l0aW9uOiBmdW5jdGlvbihwb3NpdGlvbiwgY29tcGxldGUpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24ocG9zaXRpb24pLFxuICAgICAgICAgIHN0eWxlID0gY29tcGxldGUgPyB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4KSA6XG4gICAgICAgICAgICB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgpO1xuICAgICAgcmV0dXJuIHN0eWxlIHx8IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHN0eWxlIG9mIGEgY3VycmVudCBzZWxlY3Rpb24sIGlmIG5vIHNlbGVjdGlvbiBleGlzdCwgZG8gbm90IHNldCBhbnl0aGluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlc10gU3R5bGVzIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRJbmRleF0gU3RhcnQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kSW5kZXhdIEVuZCBpbmRleCB0byBnZXQgc3R5bGVzIGF0LCBpZiBub3Qgc3BlY2lmaWVkIHNlbGVjdGlvbkVuZCBvciBzdGFydEluZGV4ICsgMVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25TdHlsZXM6IGZ1bmN0aW9uKHN0eWxlcywgc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RhcnRJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQgfHwgMDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZW5kSW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVuZEluZGV4ID0gdGhpcy5zZWxlY3Rpb25FbmQgfHwgc3RhcnRJbmRleDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xuICAgICAgICB0aGlzLl9leHRlbmRTdHlsZXMoaSwgc3R5bGVzKTtcbiAgICAgIH1cbiAgICAgIC8qIG5vdCBpbmNsdWRlZCBpbiBfZXh0ZW5kU3R5bGVzIHRvIGF2b2lkIGNsZWFyaW5nIGNhY2hlIG1vcmUgdGhhbiBvbmNlICovXG4gICAgICB0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgcmVmZXJlbmNlLCBub3QgYSBjbG9uZSwgb2YgdGhlIHN0eWxlIG9iamVjdCBmb3IgYSBnaXZlbiBjaGFyYWN0ZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgb2JqZWN0XG4gICAgICovXG4gICAgX2dldFN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICB2YXIgbGluZVN0eWxlID0gdGhpcy5zdHlsZXMgJiYgdGhpcy5zdHlsZXNbbGluZUluZGV4XTtcbiAgICAgIGlmICghbGluZVN0eWxlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmVTdHlsZVtjaGFySW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBuZXcgb2JqZWN0IHRoYXQgY29udGFpbnMgYWxsIHRoZSBzdHlsZSBwcm9wZXJ0eSBmb3IgYSBjaGFyYWN0ZXJcbiAgICAgKiB0aGUgb2JqZWN0IHJldHVybmVkIGlzIG5ld2x5IGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IG9mIHRoZSBsaW5lIHdoZXJlIHRoZSBjaGFyYWN0ZXIgaXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IHBvc2l0aW9uIG9mIHRoZSBjaGFyYWN0ZXIgb24gdGhlIGxpbmVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHN0eWxlIG9iamVjdFxuICAgICAqL1xuICAgIGdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIHZhciBzdHlsZSA9IHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHx8IHsgfSxcbiAgICAgICAgICBzdHlsZU9iamVjdCA9IHsgfSwgcHJvcDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc3R5bGVQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByb3AgPSB0aGlzLl9zdHlsZVByb3BlcnRpZXNbaV07XG4gICAgICAgIHN0eWxlT2JqZWN0W3Byb3BdID0gdHlwZW9mIHN0eWxlW3Byb3BdID09PSAndW5kZWZpbmVkJyA/IHRoaXNbcHJvcF0gOiBzdHlsZVtwcm9wXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZU9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgc3R5bGUpIHtcbiAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XSA9IHN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGVsZXRlU3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBpZiB0aGUgbGluZSBleGlzdHMgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuc3R5bGVzW2xpbmVJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbGluZSBzdHlsZSB0byBhbiBlbXB0eSBvYmplY3Qgc28gdGhhdCBpcyBpbml0aWFsaXplZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRMaW5lU3R5bGU6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XSA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGVsZXRlTGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBwYXJzZURlY29yYXRpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdC50ZXh0RGVjb3JhdGlvbikge1xuICAgICAgb2JqZWN0LnRleHREZWNvcmF0aW9uLmluZGV4T2YoJ3VuZGVybGluZScpID4gLTEgJiYgKG9iamVjdC51bmRlcmxpbmUgPSB0cnVlKTtcbiAgICAgIG9iamVjdC50ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdsaW5lLXRocm91Z2gnKSA+IC0xICYmIChvYmplY3QubGluZXRocm91Z2ggPSB0cnVlKTtcbiAgICAgIG9iamVjdC50ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdvdmVybGluZScpID4gLTEgJiYgKG9iamVjdC5vdmVybGluZSA9IHRydWUpO1xuICAgICAgZGVsZXRlIG9iamVjdC50ZXh0RGVjb3JhdGlvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSVRleHQgY2xhc3MgKGludHJvZHVjZWQgaW4gPGI+djEuNDwvYj4pIEV2ZW50cyBhcmUgYWxzbyBmaXJlZCB3aXRoIFwidGV4dDpcIlxuICAgKiBwcmVmaXggd2hlbiBvYnNlcnZpbmcgY2FudmFzLlxuICAgKiBAY2xhc3MgZmFicmljLklUZXh0XG4gICAqIEBleHRlbmRzIGZhYnJpYy5UZXh0XG4gICAqIEBtaXhlcyBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKlxuICAgKiBAZmlyZXMgY2hhbmdlZFxuICAgKiBAZmlyZXMgc2VsZWN0aW9uOmNoYW5nZWRcbiAgICogQGZpcmVzIGVkaXRpbmc6ZW50ZXJlZFxuICAgKiBAZmlyZXMgZWRpdGluZzpleGl0ZWRcbiAgICpcbiAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JVGV4dCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKlxuICAgKiA8cD5TdXBwb3J0ZWQga2V5IGNvbWJpbmF0aW9uczo8L3A+XG4gICAqIDxwcmU+XG4gICAqICAgTW92ZSBjdXJzb3I6ICAgICAgICAgICAgICAgICAgICBsZWZ0LCByaWdodCwgdXAsIGRvd25cbiAgICogICBTZWxlY3QgY2hhcmFjdGVyOiAgICAgICAgICAgICAgIHNoaWZ0ICsgbGVmdCwgc2hpZnQgKyByaWdodFxuICAgKiAgIFNlbGVjdCB0ZXh0IHZlcnRpY2FsbHk6ICAgICAgICAgc2hpZnQgKyB1cCwgc2hpZnQgKyBkb3duXG4gICAqICAgTW92ZSBjdXJzb3IgYnkgd29yZDogICAgICAgICAgICBhbHQgKyBsZWZ0LCBhbHQgKyByaWdodFxuICAgKiAgIFNlbGVjdCB3b3JkczogICAgICAgICAgICAgICAgICAgc2hpZnQgKyBhbHQgKyBsZWZ0LCBzaGlmdCArIGFsdCArIHJpZ2h0XG4gICAqICAgTW92ZSBjdXJzb3IgdG8gbGluZSBzdGFydC9lbmQ6ICBjbWQgKyBsZWZ0LCBjbWQgKyByaWdodCBvciBob21lLCBlbmRcbiAgICogICBTZWxlY3QgdGlsbCBzdGFydC9lbmQgb2YgbGluZTogIGNtZCArIHNoaWZ0ICsgbGVmdCwgY21kICsgc2hpZnQgKyByaWdodCBvciBzaGlmdCArIGhvbWUsIHNoaWZ0ICsgZW5kXG4gICAqICAgSnVtcCB0byBzdGFydC9lbmQgb2YgdGV4dDogICAgICBjbWQgKyB1cCwgY21kICsgZG93blxuICAgKiAgIFNlbGVjdCB0aWxsIHN0YXJ0L2VuZCBvZiB0ZXh0OiAgY21kICsgc2hpZnQgKyB1cCwgY21kICsgc2hpZnQgKyBkb3duIG9yIHNoaWZ0ICsgcGdVcCwgc2hpZnQgKyBwZ0Rvd25cbiAgICogICBEZWxldGUgY2hhcmFjdGVyOiAgICAgICAgICAgICAgIGJhY2tzcGFjZVxuICAgKiAgIERlbGV0ZSB3b3JkOiAgICAgICAgICAgICAgICAgICAgYWx0ICsgYmFja3NwYWNlXG4gICAqICAgRGVsZXRlIGxpbmU6ICAgICAgICAgICAgICAgICAgICBjbWQgKyBiYWNrc3BhY2VcbiAgICogICBGb3J3YXJkIGRlbGV0ZTogICAgICAgICAgICAgICAgIGRlbGV0ZVxuICAgKiAgIENvcHkgdGV4dDogICAgICAgICAgICAgICAgICAgICAgY3RybC9jbWQgKyBjXG4gICAqICAgUGFzdGUgdGV4dDogICAgICAgICAgICAgICAgICAgICBjdHJsL2NtZCArIHZcbiAgICogICBDdXQgdGV4dDogICAgICAgICAgICAgICAgICAgICAgIGN0cmwvY21kICsgeFxuICAgKiAgIFNlbGVjdCBlbnRpcmUgdGV4dDogICAgICAgICAgICAgY3RybC9jbWQgKyBhXG4gICAqICAgUXVpdCBlZGl0aW5nICAgICAgICAgICAgICAgICAgICB0YWIgb3IgZXNjXG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiA8cD5TdXBwb3J0ZWQgbW91c2UvdG91Y2ggY29tYmluYXRpb248L3A+XG4gICAqIDxwcmU+XG4gICAqICAgUG9zaXRpb24gY3Vyc29yOiAgICAgICAgICAgICAgICBjbGljay90b3VjaFxuICAgKiAgIENyZWF0ZSBzZWxlY3Rpb246ICAgICAgICAgICAgICAgY2xpY2svdG91Y2ggJiBkcmFnXG4gICAqICAgQ3JlYXRlIHNlbGVjdGlvbjogICAgICAgICAgICAgICBjbGljayAmIHNoaWZ0ICsgY2xpY2tcbiAgICogICBTZWxlY3Qgd29yZDogICAgICAgICAgICAgICAgICAgIGRvdWJsZSBjbGlja1xuICAgKiAgIFNlbGVjdCBsaW5lOiAgICAgICAgICAgICAgICAgICAgdHJpcGxlIGNsaWNrXG4gICAqIDwvcHJlPlxuICAgKi9cbiAgZmFicmljLklUZXh0ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLlRleHQsIGZhYnJpYy5PYnNlcnZhYmxlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdpLXRleHQnLFxuXG4gICAgLyoqXG4gICAgICogSW5kZXggd2hlcmUgdGV4dCBzZWxlY3Rpb24gc3RhcnRzIChvciB3aGVyZSBjdXJzb3IgaXMgd2hlbiB0aGVyZSBpcyBubyBzZWxlY3Rpb24pXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25TdGFydDogMCxcblxuICAgIC8qKlxuICAgICAqIEluZGV4IHdoZXJlIHRleHQgc2VsZWN0aW9uIGVuZHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkVuZDogMCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHRleHQgc2VsZWN0aW9uXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25Db2xvcjogJ3JnYmEoMTcsMTE5LDI1NSwwLjMpJyxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRleHQgaXMgaW4gZWRpdGluZyBtb2RlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaXNFZGl0aW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGEgdGV4dCBjYW4gYmUgZWRpdGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZWRpdGFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBCb3JkZXIgY29sb3Igb2YgdGV4dCBvYmplY3Qgd2hpbGUgaXQncyBpbiBlZGl0aW5nIG1vZGVcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGVkaXRpbmdCb3JkZXJDb2xvcjogJ3JnYmEoMTAyLDE1MywyNTUsMC4yNSknLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgY3Vyc29yIChpbiBweClcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGN1cnNvcldpZHRoOiAyLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2YgdGV4dCBjdXJzb3IgY29sb3IgaW4gZWRpdGluZyBtb2RlLlxuICAgICAqIGlmIG5vdCBzZXQgKGRlZmF1bHQpIHdpbGwgdGFrZSBjb2xvciBmcm9tIHRoZSB0ZXh0LlxuICAgICAqIGlmIHNldCB0byBhIGNvbG9yIHZhbHVlIHRoYXQgZmFicmljIGNhbiB1bmRlcnN0YW5kLCBpdCB3aWxsXG4gICAgICogYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBjb2xvciBvZiB0aGUgdGV4dCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGN1cnNvckNvbG9yOiAnJyxcblxuICAgIC8qKlxuICAgICAqIERlbGF5IGJldHdlZW4gY3Vyc29yIGJsaW5rIChpbiBtcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGN1cnNvckRlbGF5OiAxMDAwLFxuXG4gICAgLyoqXG4gICAgICogRHVyYXRpb24gb2YgY3Vyc29yIGZhZGVpbiAoaW4gbXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JEdXJhdGlvbjogNjAwLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgaW50ZXJuYWwgdGV4dCBjaGFyIHdpZHRocyBjYW4gYmUgY2FjaGVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2FjaGluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIERPTSBjb250YWluZXIgdG8gYXBwZW5kIHRoZSBoaWRkZW5UZXh0YXJlYS5cbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBhdHRhY2hpbmcgdG8gdGhlIGRvY3VtZW50LmJvZHkuXG4gICAgICogVXNlZnVsIHRvIHJlZHVjZSBsYWdnaXNoIHJlZHJhdyBvZiB0aGUgZnVsbCBkb2N1bWVudC5ib2R5IHRyZWUgYW5kXG4gICAgICogYWxzbyB3aXRoIG1vZGFscyBldmVudCBjYXB0dXJpbmcgdGhhdCB3b24ndCBsZXQgdGhlIHRleHRhcmVhIHRha2UgZm9jdXMuXG4gICAgICogQHR5cGUgSFRNTEVsZW1lbnRcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhpZGRlblRleHRhcmVhQ29udGFpbmVyOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVTcGFjZTogL1xcc3xcXG4vLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3VycmVudEN1cnNvck9wYWNpdHk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZWxlY3Rpb25EaXJlY3Rpb246IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hYm9ydEN1cnNvckFuaW1hdGlvbjogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9fd2lkdGhPZlNwYWNlOiBbXSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBzIGRldGVybWluaW5nIHdoZW4gdGhlIHRleHQgaXMgaW4gY29tcG9zaXRpb24sIHNvIHRoYXQgdGhlIGN1cnNvclxuICAgICAqIHJlbmRlcmluZyBpcyBhbHRlcmVkLlxuICAgICAqL1xuICAgIGluQ29tcG9zaXRpb25Nb2RlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGV4dCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24odGV4dCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCB0ZXh0LCBvcHRpb25zKTtcbiAgICAgIHRoaXMuaW5pdEJlaGF2aW9yKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc2VsZWN0aW9uIHN0YXJ0IChsZWZ0IGJvdW5kYXJ5IG9mIGEgc2VsZWN0aW9uKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCB0byBzZXQgc2VsZWN0aW9uIHN0YXJ0IHRvXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uU3RhcnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpbmRleCA9IE1hdGgubWF4KGluZGV4LCAwKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuZEZpcmUoJ3NlbGVjdGlvblN0YXJ0JywgaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGlvbiBlbmQgKHJpZ2h0IGJvdW5kYXJ5IG9mIGEgc2VsZWN0aW9uKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBJbmRleCB0byBzZXQgc2VsZWN0aW9uIGVuZCB0b1xuICAgICAqL1xuICAgIHNldFNlbGVjdGlvbkVuZDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHRoaXMudGV4dC5sZW5ndGgpO1xuICAgICAgdGhpcy5fdXBkYXRlQW5kRmlyZSgnc2VsZWN0aW9uRW5kJywgaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAnc2VsZWN0aW9uU3RhcnQnIG9yICdzZWxlY3Rpb25FbmQnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IG5ldyBwb3NpdGlvbiBvZiBwcm9wZXJ0eVxuICAgICAqL1xuICAgIF91cGRhdGVBbmRGaXJlOiBmdW5jdGlvbihwcm9wZXJ0eSwgaW5kZXgpIHtcbiAgICAgIGlmICh0aGlzW3Byb3BlcnR5XSAhPT0gaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBpbmRleDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIHRoZSBldmVuIG9mIHNlbGVjdGlvbiBjaGFuZ2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZVNlbGVjdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2hhbmdlZCcpO1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuZmlyZSgndGV4dDpzZWxlY3Rpb246Y2hhbmdlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRleHQgZGltZW5zaW9ucy4gUmVuZGVyIGFsbCB0ZXh0IG9uIGdpdmVuIGNvbnRleHRcbiAgICAgKiBvciBvbiBhIG9mZnNjcmVlbiBjYW52YXMgdG8gZ2V0IHRoZSB0ZXh0IHdpZHRoIHdpdGggbWVhc3VyZVRleHQuXG4gICAgICogVXBkYXRlcyB0aGlzLndpZHRoIGFuZCB0aGlzLmhlaWdodCB3aXRoIHRoZSBwcm9wZXIgdmFsdWVzLlxuICAgICAqIERvZXMgbm90IHJldHVybiBkaW1lbnNpb25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc0VkaXRpbmcgJiYgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0RGltZW5zaW9ucycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdyZW5kZXInLCBjdHgpO1xuICAgICAgLy8gY2xlYXIgdGhlIGN1cnNvck9mZnNldENhY2hlLCBzbyB3ZSBlbnN1cmUgdG8gY2FsY3VsYXRlIG9uY2UgcGVyIHJlbmRlckN1cnNvclxuICAgICAgLy8gdGhlIGNvcnJlY3QgcG9zaXRpb24gYnV0IG5vdCBhdCBldmVyeSBjdXJzb3IgYW5pbWF0aW9uLlxuICAgICAgdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IHsgfTtcbiAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3JlbmRlcicsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgYW5kIGNsZWFuIHRoZSBjb250ZXh0VG9wXG4gICAgICovXG4gICAgY2xlYXJDb250ZXh0VG9wOiBmdW5jdGlvbihza2lwUmVzdG9yZSkge1xuICAgICAgaWYgKCF0aGlzLmlzRWRpdGluZyB8fCAhdGhpcy5jYW52YXMgfHwgIXRoaXMuY2FudmFzLmNvbnRleHRUb3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsIHYgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oY3R4KTtcbiAgICAgIHRoaXMuX2NsZWFyVGV4dEFyZWEoY3R4KTtcbiAgICAgIHNraXBSZXN0b3JlIHx8IGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGN1cnNvciBvciBzZWxlY3Rpb24gKGRlcGVuZGluZyBvbiB3aGF0IGV4aXN0cylcbiAgICAgKiBpdCBkb2VzIG9uIHRoZSBjb250ZXh0VG9wLiBJZiBjb250ZXh0VG9wIGlzIG5vdCBhdmFpbGFibGUsIGRvIG5vdGhpbmcuXG4gICAgICovXG4gICAgcmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmlzRWRpdGluZyB8fCAhdGhpcy5jYW52YXMgfHwgIXRoaXMuY2FudmFzLmNvbnRleHRUb3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGJvdW5kYXJpZXMgPSB0aGlzLl9nZXRDdXJzb3JCb3VuZGFyaWVzKCksXG4gICAgICAgICAgY3R4ID0gdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKHRydWUpO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHRoaXMucmVuZGVyQ3Vyc29yKGJvdW5kYXJpZXMsIGN0eCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW5kZXJTZWxlY3Rpb24oYm91bmRhcmllcywgY3R4KTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIF9jbGVhclRleHRBcmVhOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIC8vIHdlIGFkZCA0IHBpeGVsLCB0byBiZSBzdXJlIHRvIGRvIG5vdCBsZWF2ZSBhbnkgcGl4ZWwgb3V0XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoICsgNCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyA0O1xuICAgICAgY3R4LmNsZWFyUmVjdCgtd2lkdGggLyAyLCAtaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3Vyc29yIGJvdW5kYXJpZXMgKGxlZnQsIHRvcCwgbGVmdE9mZnNldCwgdG9wT2Zmc2V0KVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gY2hhcnMgQXJyYXkgb2YgY2hhcmFjdGVyc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlT2ZCb3VuZGFyaWVzXG4gICAgICovXG4gICAgX2dldEN1cnNvckJvdW5kYXJpZXM6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cbiAgICAgIC8vIGxlZnQvdG9wIGFyZSBsZWZ0L3RvcCBvZiBlbnRpcmUgdGV4dCBib3hcbiAgICAgIC8vIGxlZnRPZmZzZXQvdG9wT2Zmc2V0IGFyZSBvZmZzZXQgZnJvbSB0aGF0IGxlZnQvdG9wIHBvaW50IG9mIGEgdGV4dCBib3hcblxuICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVmdCA9IHRoaXMuX2dldExlZnRPZmZzZXQoKSxcbiAgICAgICAgICB0b3AgPSB0aGlzLl9nZXRUb3BPZmZzZXQoKSxcbiAgICAgICAgICBvZmZzZXRzID0gdGhpcy5fZ2V0Q3Vyc29yQm91bmRhcmllc09mZnNldHMocG9zaXRpb24pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgIGxlZnRPZmZzZXQ6IG9mZnNldHMubGVmdCxcbiAgICAgICAgdG9wT2Zmc2V0OiBvZmZzZXRzLnRvcFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q3Vyc29yQm91bmRhcmllc09mZnNldHM6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICBpZiAodGhpcy5jdXJzb3JPZmZzZXRDYWNoZSAmJiAndG9wJyBpbiB0aGlzLmN1cnNvck9mZnNldENhY2hlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvck9mZnNldENhY2hlO1xuICAgICAgfVxuICAgICAgdmFyIGxpbmVMZWZ0T2Zmc2V0LFxuICAgICAgICAgIGxpbmVJbmRleCxcbiAgICAgICAgICBjaGFySW5kZXgsXG4gICAgICAgICAgdG9wT2Zmc2V0ID0gMCxcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gMCxcbiAgICAgICAgICBib3VuZGFyaWVzLFxuICAgICAgICAgIGN1cnNvclBvc2l0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHBvc2l0aW9uKTtcbiAgICAgIGNoYXJJbmRleCA9IGN1cnNvclBvc2l0aW9uLmNoYXJJbmRleDtcbiAgICAgIGxpbmVJbmRleCA9IGN1cnNvclBvc2l0aW9uLmxpbmVJbmRleDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZUluZGV4OyBpKyspIHtcbiAgICAgICAgdG9wT2Zmc2V0ICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgfVxuICAgICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lSW5kZXgpO1xuICAgICAgdmFyIGJvdW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtjaGFySW5kZXhdO1xuICAgICAgYm91bmQgJiYgKGxlZnRPZmZzZXQgPSBib3VuZC5sZWZ0KTtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwICYmIGNoYXJJbmRleCA9PT0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0ubGVuZ3RoKSB7XG4gICAgICAgIGxlZnRPZmZzZXQgLT0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICB9XG4gICAgICBib3VuZGFyaWVzID0ge1xuICAgICAgICB0b3A6IHRvcE9mZnNldCxcbiAgICAgICAgbGVmdDogbGluZUxlZnRPZmZzZXQgKyAobGVmdE9mZnNldCA+IDAgPyBsZWZ0T2Zmc2V0IDogMCksXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICBib3VuZGFyaWVzLmxlZnQgKj0gLTE7XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnNvck9mZnNldENhY2hlID0gYm91bmRhcmllcztcbiAgICAgIHJldHVybiB0aGlzLmN1cnNvck9mZnNldENhY2hlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGN1cnNvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3VuZGFyaWVzXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0cmFuc2Zvcm1lZCBjb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKi9cbiAgICByZW5kZXJDdXJzb3I6IGZ1bmN0aW9uKGJvdW5kYXJpZXMsIGN0eCkge1xuICAgICAgdmFyIGN1cnNvckxvY2F0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKCksXG4gICAgICAgICAgbGluZUluZGV4ID0gY3Vyc29yTG9jYXRpb24ubGluZUluZGV4LFxuICAgICAgICAgIGNoYXJJbmRleCA9IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCA+IDAgPyBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXggLSAxIDogMCxcbiAgICAgICAgICBjaGFySGVpZ2h0ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsaW5lSW5kZXgsIGNoYXJJbmRleCwgJ2ZvbnRTaXplJyksXG4gICAgICAgICAgbXVsdGlwbGllciA9IHRoaXMuc2NhbGVYICogdGhpcy5jYW52YXMuZ2V0Wm9vbSgpLFxuICAgICAgICAgIGN1cnNvcldpZHRoID0gdGhpcy5jdXJzb3JXaWR0aCAvIG11bHRpcGxpZXIsXG4gICAgICAgICAgdG9wT2Zmc2V0ID0gYm91bmRhcmllcy50b3BPZmZzZXQsXG4gICAgICAgICAgZHkgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZGVsdGFZJyk7XG4gICAgICB0b3BPZmZzZXQgKz0gKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKSAqIHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGxpbmVJbmRleCkgLyB0aGlzLmxpbmVIZWlnaHRcbiAgICAgICAgLSBjaGFySGVpZ2h0ICogKDEgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKTtcblxuICAgICAgaWYgKHRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJTZWxlY3Rpb24oYm91bmRhcmllcywgY3R4KTtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmN1cnNvckNvbG9yIHx8IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZUluZGV4LCBjaGFySW5kZXgsICdmaWxsJyk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLl9faXNNb3VzZWRvd24gPyAxIDogdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHk7XG4gICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgIGJvdW5kYXJpZXMubGVmdCArIGJvdW5kYXJpZXMubGVmdE9mZnNldCAtIGN1cnNvcldpZHRoIC8gMixcbiAgICAgICAgdG9wT2Zmc2V0ICsgYm91bmRhcmllcy50b3AgKyBkeSxcbiAgICAgICAgY3Vyc29yV2lkdGgsXG4gICAgICAgIGNoYXJIZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRleHQgc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJvdW5kYXJpZXMgT2JqZWN0IHdpdGggbGVmdC90b3AvbGVmdE9mZnNldC90b3BPZmZzZXRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IHRyYW5zZm9ybWVkIGNvbnRleHQgdG8gZHJhdyBvblxuICAgICAqL1xuICAgIHJlbmRlclNlbGVjdGlvbjogZnVuY3Rpb24oYm91bmRhcmllcywgY3R4KSB7XG5cbiAgICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPyB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvblN0YXJ0IDogdGhpcy5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICBzZWxlY3Rpb25FbmQgPSB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID8gdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQgOiB0aGlzLnNlbGVjdGlvbkVuZCxcbiAgICAgICAgICBpc0p1c3RpZnkgPSB0aGlzLnRleHRBbGlnbi5pbmRleE9mKCdqdXN0aWZ5JykgIT09IC0xLFxuICAgICAgICAgIHN0YXJ0ID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHNlbGVjdGlvblN0YXJ0KSxcbiAgICAgICAgICBlbmQgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uRW5kKSxcbiAgICAgICAgICBzdGFydExpbmUgPSBzdGFydC5saW5lSW5kZXgsXG4gICAgICAgICAgZW5kTGluZSA9IGVuZC5saW5lSW5kZXgsXG4gICAgICAgICAgc3RhcnRDaGFyID0gc3RhcnQuY2hhckluZGV4IDwgMCA/IDAgOiBzdGFydC5jaGFySW5kZXgsXG4gICAgICAgICAgZW5kQ2hhciA9IGVuZC5jaGFySW5kZXggPCAwID8gMCA6IGVuZC5jaGFySW5kZXg7XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydExpbmU7IGkgPD0gZW5kTGluZTsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lT2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSkgfHwgMCxcbiAgICAgICAgICAgIGxpbmVIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKSxcbiAgICAgICAgICAgIHJlYWxMaW5lSGVpZ2h0ID0gMCwgYm94U3RhcnQgPSAwLCBib3hFbmQgPSAwO1xuXG4gICAgICAgIGlmIChpID09PSBzdGFydExpbmUpIHtcbiAgICAgICAgICBib3hTdGFydCA9IHRoaXMuX19jaGFyQm91bmRzW3N0YXJ0TGluZV1bc3RhcnRDaGFyXS5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID49IHN0YXJ0TGluZSAmJiBpIDwgZW5kTGluZSkge1xuICAgICAgICAgIGJveEVuZCA9IGlzSnVzdGlmeSAmJiAhdGhpcy5pc0VuZE9mV3JhcHBpbmcoaSkgPyB0aGlzLndpZHRoIDogdGhpcy5nZXRMaW5lV2lkdGgoaSkgfHwgNTsgLy8gV1RGIGlzIHRoaXMgNT9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpID09PSBlbmRMaW5lKSB7XG4gICAgICAgICAgaWYgKGVuZENoYXIgPT09IDApIHtcbiAgICAgICAgICAgIGJveEVuZCA9IHRoaXMuX19jaGFyQm91bmRzW2VuZExpbmVdW2VuZENoYXJdLmxlZnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoYXJTcGFjaW5nID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICAgICAgICBib3hFbmQgPSB0aGlzLl9fY2hhckJvdW5kc1tlbmRMaW5lXVtlbmRDaGFyIC0gMV0ubGVmdFxuICAgICAgICAgICAgICArIHRoaXMuX19jaGFyQm91bmRzW2VuZExpbmVdW2VuZENoYXIgLSAxXS53aWR0aCAtIGNoYXJTcGFjaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWFsTGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLmxpbmVIZWlnaHQgPCAxIHx8IChpID09PSBlbmRMaW5lICYmIHRoaXMubGluZUhlaWdodCA+IDEpKSB7XG4gICAgICAgICAgbGluZUhlaWdodCAvPSB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRyYXdTdGFydCA9IGJvdW5kYXJpZXMubGVmdCArIGxpbmVPZmZzZXQgKyBib3hTdGFydCxcbiAgICAgICAgICAgIGRyYXdXaWR0aCA9IGJveEVuZCAtIGJveFN0YXJ0LFxuICAgICAgICAgICAgZHJhd0hlaWdodCA9IGxpbmVIZWlnaHQsIGV4dHJhVG9wID0gMDtcbiAgICAgICAgaWYgKHRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb21wb3NpdGlvbkNvbG9yIHx8ICdibGFjayc7XG4gICAgICAgICAgZHJhd0hlaWdodCA9IDE7XG4gICAgICAgICAgZXh0cmFUb3AgPSBsaW5lSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLnNlbGVjdGlvbkNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgICBkcmF3U3RhcnQgPSB0aGlzLndpZHRoIC0gZHJhd1N0YXJ0IC0gZHJhd1dpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICBkcmF3U3RhcnQsXG4gICAgICAgICAgYm91bmRhcmllcy50b3AgKyBib3VuZGFyaWVzLnRvcE9mZnNldCArIGV4dHJhVG9wLFxuICAgICAgICAgIGRyYXdXaWR0aCxcbiAgICAgICAgICBkcmF3SGVpZ2h0KTtcbiAgICAgICAgYm91bmRhcmllcy50b3BPZmZzZXQgKz0gcmVhbExpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdG8ga25vdyB0aGUgaGVpZ2h0IG9mIHRoZSBjdXJzb3IuXG4gICAgICogdGhlIGN1cnJlbnRDaGFyIGlzIHRoZSBvbmUgdGhhdCBwcmVjZWRlcyB0aGUgY3Vyc29yXG4gICAgICogUmV0dXJucyBmb250U2l6ZSBvZiBjaGFyIGF0IHRoZSBjdXJyZW50IGN1cnNvclxuICAgICAqIFVudXNlZCBmcm9tIHRoZSBsaWJyYXJ5LCBpcyBmb3IgdGhlIGVuZCB1c2VyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBDaGFyYWN0ZXIgZm9udCBzaXplXG4gICAgICovXG4gICAgZ2V0Q3VycmVudENoYXJGb250U2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3AgPSB0aGlzLl9nZXRDdXJyZW50Q2hhckluZGV4KCk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChjcC5sLCBjcC5jLCAnZm9udFNpemUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGlnaCBsZXZlbCBmdW5jdGlvbiB0byBrbm93IHRoZSBjb2xvciBvZiB0aGUgY3Vyc29yLlxuICAgICAqIHRoZSBjdXJyZW50Q2hhciBpcyB0aGUgb25lIHRoYXQgcHJlY2VkZXMgdGhlIGN1cnNvclxuICAgICAqIFJldHVybnMgY29sb3IgKGZpbGwpIG9mIGNoYXIgYXQgdGhlIGN1cnJlbnQgY3Vyc29yXG4gICAgICogaWYgdGhlIHRleHQgb2JqZWN0IGhhcyBhIHBhdHRlcm4gb3IgZ3JhZGllbnQgZm9yIGZpbGxlciwgaXQgd2lsbCByZXR1cm4gdGhhdC5cbiAgICAgKiBVbnVzZWQgYnkgdGhlIGxpYnJhcnksIGlzIGZvciB0aGUgZW5kIHVzZXJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmcgfCBmYWJyaWMuR3JhZGllbnQgfCBmYWJyaWMuUGF0dGVybn0gQ2hhcmFjdGVyIGNvbG9yIChmaWxsKVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGFyQ29sb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNwID0gdGhpcy5fZ2V0Q3VycmVudENoYXJJbmRleCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoY3AubCwgY3AuYywgJ2ZpbGwnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3Vyc29yIHBvc2l0aW9uIGZvciB0aGUgZ2V0Q3VycmVudC4uIGZ1bmN0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEN1cnJlbnRDaGFySW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN1cnNvclBvc2l0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRydWUpLFxuICAgICAgICAgIGNoYXJJbmRleCA9IGN1cnNvclBvc2l0aW9uLmNoYXJJbmRleCA+IDAgPyBjdXJzb3JQb3NpdGlvbi5jaGFySW5kZXggLSAxIDogMDtcbiAgICAgIHJldHVybiB7IGw6IGN1cnNvclBvc2l0aW9uLmxpbmVJbmRleCwgYzogY2hhckluZGV4IH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuSVRleHQgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLklUZXh0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gaW52b2tlZCB3aXRoIG5ldyBpbnN0YW5jZSBhcyBhcmd1bWVudFxuICAgKi9cbiAgZmFicmljLklUZXh0LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0eWxlcyA9IGZhYnJpYy51dGlsLnN0eWxlc0Zyb21BcnJheShvYmplY3Quc3R5bGVzLCBvYmplY3QudGV4dCk7XG4gICAgLy9jb3B5IG9iamVjdCB0byBwcmV2ZW50IG11dGF0aW9uXG4gICAgdmFyIG9iakNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBvYmplY3QsIHsgc3R5bGVzOiBzdHlsZXMgfSk7XG4gICAgcGFyc2VEZWNvcmF0aW9uKG9iakNvcHkpO1xuICAgIGlmIChvYmpDb3B5LnN0eWxlcykge1xuICAgICAgZm9yICh2YXIgaSBpbiBvYmpDb3B5LnN0eWxlcykge1xuICAgICAgICBmb3IgKHZhciBqIGluIG9iakNvcHkuc3R5bGVzW2ldKSB7XG4gICAgICAgICAgcGFyc2VEZWNvcmF0aW9uKG9iakNvcHkuc3R5bGVzW2ldW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdJVGV4dCcsIG9iakNvcHksIGNhbGxiYWNrLCAndGV4dCcpO1xuICB9O1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLklUZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFsbCB0aGUgaW50ZXJhY3RpdmUgYmVoYXZpb3Igb2YgSVRleHRcbiAgICAgKi9cbiAgICBpbml0QmVoYXZpb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbml0QWRkZWRIYW5kbGVyKCk7XG4gICAgICB0aGlzLmluaXRSZW1vdmVkSGFuZGxlcigpO1xuICAgICAgdGhpcy5pbml0Q3Vyc29yU2VsZWN0aW9uSGFuZGxlcnMoKTtcbiAgICAgIHRoaXMuaW5pdERvdWJsZUNsaWNrU2ltdWxhdGlvbigpO1xuICAgICAgdGhpcy5tb3VzZU1vdmVIYW5kbGVyID0gdGhpcy5tb3VzZU1vdmVIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgfSxcblxuICAgIG9uRGVzZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc0VkaXRpbmcgJiYgdGhpcy5leGl0RWRpdGluZygpO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBcImFkZGVkXCIgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIGluaXRBZGRlZEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMub24oJ2FkZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBfdGhpcy5jYW52YXM7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICBpZiAoIWNhbnZhcy5faGFzSVRleHRIYW5kbGVycykge1xuICAgICAgICAgICAgY2FudmFzLl9oYXNJVGV4dEhhbmRsZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLl9pbml0Q2FudmFzSGFuZGxlcnMoY2FudmFzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcyA9IGNhbnZhcy5faVRleHRJbnN0YW5jZXMgfHwgW107XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcy5wdXNoKF90aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGluaXRSZW1vdmVkSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5vbigncmVtb3ZlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gX3RoaXMuY2FudmFzO1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcyA9IGNhbnZhcy5faVRleHRJbnN0YW5jZXMgfHwgW107XG4gICAgICAgICAgZmFicmljLnV0aWwucmVtb3ZlRnJvbUFycmF5KGNhbnZhcy5faVRleHRJbnN0YW5jZXMsIF90aGlzKTtcbiAgICAgICAgICBpZiAoY2FudmFzLl9pVGV4dEluc3RhbmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNhbnZhcy5faGFzSVRleHRIYW5kbGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUNhbnZhc0hhbmRsZXJzKGNhbnZhcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVnaXN0ZXIgY2FudmFzIGV2ZW50IHRvIG1hbmFnZSBleGl0aW5nIG9uIG90aGVyIGluc3RhbmNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRDYW52YXNIYW5kbGVyczogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICBjYW52YXMuX21vdXNlVXBJVGV4dEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNhbnZhcy5faVRleHRJbnN0YW5jZXMpIHtcbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBvYmouX19pc01vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2FudmFzLm9uKCdtb3VzZTp1cCcsIGNhbnZhcy5fbW91c2VVcElUZXh0SGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBjYW52YXMgZXZlbnQgdG8gbWFuYWdlIGV4aXRpbmcgb24gb3RoZXIgaW5zdGFuY2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlQ2FudmFzSGFuZGxlcnM6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgY2FudmFzLm9mZignbW91c2U6dXAnLCBjYW52YXMuX21vdXNlVXBJVGV4dEhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90aWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUgPSB0aGlzLl9hbmltYXRlQ3Vyc29yKHRoaXMsIDEsIHRoaXMuY3Vyc29yRHVyYXRpb24sICdfb25UaWNrQ29tcGxldGUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYW5pbWF0ZUN1cnNvcjogZnVuY3Rpb24ob2JqLCB0YXJnZXRPcGFjaXR5LCBkdXJhdGlvbiwgY29tcGxldGVNZXRob2QpIHtcblxuICAgICAgdmFyIHRpY2tTdGF0ZTtcblxuICAgICAgdGlja1N0YXRlID0ge1xuICAgICAgICBpc0Fib3J0ZWQ6IGZhbHNlLFxuICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5pc0Fib3J0ZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgb2JqLmFuaW1hdGUoJ19jdXJyZW50Q3Vyc29yT3BhY2l0eScsIHRhcmdldE9wYWNpdHksIHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIXRpY2tTdGF0ZS5pc0Fib3J0ZWQpIHtcbiAgICAgICAgICAgIG9ialtjb21wbGV0ZU1ldGhvZF0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBhbmltYXRlIGEgc2VsZWN0aW9uLCBvbmx5IGN1cnNvclxuICAgICAgICAgIGlmIChvYmouY2FudmFzICYmIG9iai5zZWxlY3Rpb25TdGFydCA9PT0gb2JqLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgb2JqLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRpY2tTdGF0ZS5pc0Fib3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRpY2tTdGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25UaWNrQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5fY3Vyc29yVGltZW91dDEpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2N1cnNvclRpbWVvdXQxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2N1cnNvclRpbWVvdXQxID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZSA9IF90aGlzLl9hbmltYXRlQ3Vyc29yKF90aGlzLCAwLCB0aGlzLmN1cnNvckR1cmF0aW9uIC8gMiwgJ190aWNrJyk7XG4gICAgICB9LCAxMDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBkZWxheWVkIGN1cnNvclxuICAgICAqL1xuICAgIGluaXREZWxheWVkQ3Vyc29yOiBmdW5jdGlvbihyZXN0YXJ0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIGRlbGF5ID0gcmVzdGFydCA/IDAgOiB0aGlzLmN1cnNvckRlbGF5O1xuXG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDE7XG4gICAgICB0aGlzLl9jdXJzb3JUaW1lb3V0MiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLl90aWNrKCk7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFib3J0cyBjdXJzb3IgYW5pbWF0aW9uIGFuZCBjbGVhcnMgYWxsIHRpbWVvdXRzXG4gICAgICovXG4gICAgYWJvcnRDdXJzb3JBbmltYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNob3VsZENsZWFyID0gdGhpcy5fY3VycmVudFRpY2tTdGF0ZSB8fCB0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUsXG4gICAgICAgICAgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICB0aGlzLl9jdXJyZW50VGlja1N0YXRlICYmIHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUuYWJvcnQoKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZSAmJiB0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUuYWJvcnQoKTtcblxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2N1cnNvclRpbWVvdXQxKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9jdXJzb3JUaW1lb3V0Mik7XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMDtcbiAgICAgIC8vIHRvIGNsZWFyIGp1c3QgaXRleHQgYXJlYSB3ZSBuZWVkIHRvIHRyYW5zZm9ybSB0aGUgY29udGV4dFxuICAgICAgLy8gaXQgbWF5IG5vdCBiZSB3b3J0aCBpdFxuICAgICAgaWYgKHNob3VsZENsZWFyICYmIGNhbnZhcykge1xuICAgICAgICBjYW52YXMuY2xlYXJDb250ZXh0KGNhbnZhcy5jb250ZXh0VG9wIHx8IGNhbnZhcy5jb250ZXh0Q29udGFpbmVyKTtcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGVudGlyZSB0ZXh0XG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5fdGV4dC5sZW5ndGg7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNlbGVjdGVkIHRleHRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWRUZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl90ZXh0LnNsaWNlKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kKS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBzdGFydCBvZiBjdXJyZW50IHdvcmQgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBDdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRXb3JkQm91bmRhcnlMZWZ0OiBmdW5jdGlvbihzdGFydEZyb20pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLCBpbmRleCA9IHN0YXJ0RnJvbSAtIDE7XG5cbiAgICAgIC8vIHJlbW92ZSBzcGFjZSBiZWZvcmUgY3Vyc29yIGZpcnN0XG4gICAgICBpZiAodGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSkge1xuICAgICAgICB3aGlsZSAodGhpcy5fcmVTcGFjZS50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSkge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIGluZGV4LS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgvXFxTLy50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSAmJiBpbmRleCA+IC0xKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tIC0gb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIGVuZCBvZiBjdXJyZW50IHdvcmQgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBDdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRXb3JkQm91bmRhcnlSaWdodDogZnVuY3Rpb24oc3RhcnRGcm9tKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgaW5kZXggPSBzdGFydEZyb207XG5cbiAgICAgIC8vIHJlbW92ZSBzcGFjZSBhZnRlciBjdXJzb3IgZmlyc3RcbiAgICAgIGlmICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pKSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKC9cXFMvLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pICYmIGluZGV4IDwgdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydEZyb20gKyBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbmV3IHNlbGVjdGlvbiBpbmRleCByZXByZXNlbnRpbmcgc3RhcnQgb2YgY3VycmVudCBsaW5lIGFjY29yZGluZyB0byBjdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb20gQ3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE5ldyBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kTGluZUJvdW5kYXJ5TGVmdDogZnVuY3Rpb24oc3RhcnRGcm9tKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMCwgaW5kZXggPSBzdGFydEZyb20gLSAxO1xuXG4gICAgICB3aGlsZSAoIS9cXG4vLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pICYmIGluZGV4ID4gLTEpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydEZyb20gLSBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbmV3IHNlbGVjdGlvbiBpbmRleCByZXByZXNlbnRpbmcgZW5kIG9mIGN1cnJlbnQgbGluZSBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIEN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZExpbmVCb3VuZGFyeVJpZ2h0OiBmdW5jdGlvbihzdGFydEZyb20pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLCBpbmRleCA9IHN0YXJ0RnJvbTtcblxuICAgICAgd2hpbGUgKCEvXFxuLy50ZXN0KHRoaXMuX3RleHRbaW5kZXhdKSAmJiBpbmRleCA8IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhcnRGcm9tICsgb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBpbmRleCBjb3JyZXNwb25kaW5nIHRvIGJlZ2lubmluZyBvciBlbmQgb2YgYSB3b3JkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlbGVjdGlvblN0YXJ0IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpcmVjdGlvbiAxIG9yIC0xXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBJbmRleCBvZiB0aGUgYmVnaW5uaW5nIG9yIGVuZCBvZiBhIHdvcmRcbiAgICAgKi9cbiAgICBzZWFyY2hXb3JkQm91bmRhcnk6IGZ1bmN0aW9uKHNlbGVjdGlvblN0YXJ0LCBkaXJlY3Rpb24pIHtcbiAgICAgIHZhciB0ZXh0ID0gdGhpcy5fdGV4dCxcbiAgICAgICAgICBpbmRleCAgICAgPSB0aGlzLl9yZVNwYWNlLnRlc3QodGV4dFtzZWxlY3Rpb25TdGFydF0pID8gc2VsZWN0aW9uU3RhcnQgLSAxIDogc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgX2NoYXIgICAgID0gdGV4dFtpbmRleF0sXG4gICAgICAgICAgLy8gd3JvbmdcbiAgICAgICAgICByZU5vbldvcmQgPSBmYWJyaWMucmVOb25Xb3JkO1xuXG4gICAgICB3aGlsZSAoIXJlTm9uV29yZC50ZXN0KF9jaGFyKSAmJiBpbmRleCA+IDAgJiYgaW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICBpbmRleCArPSBkaXJlY3Rpb247XG4gICAgICAgIF9jaGFyID0gdGV4dFtpbmRleF07XG4gICAgICB9XG4gICAgICBpZiAocmVOb25Xb3JkLnRlc3QoX2NoYXIpKSB7XG4gICAgICAgIGluZGV4ICs9IGRpcmVjdGlvbiA9PT0gMSA/IDAgOiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgd29yZCBiYXNlZCBvbiB0aGUgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VsZWN0aW9uU3RhcnQgSW5kZXggb2YgYSBjaGFyYWN0ZXJcbiAgICAgKi9cbiAgICBzZWxlY3RXb3JkOiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCkge1xuICAgICAgc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25TdGFydCB8fCB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgdmFyIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWFyY2hXb3JkQm91bmRhcnkoc2VsZWN0aW9uU3RhcnQsIC0xKSwgLyogc2VhcmNoIGJhY2t3YXJkcyAqL1xuICAgICAgICAgIG5ld1NlbGVjdGlvbkVuZCA9IHRoaXMuc2VhcmNoV29yZEJvdW5kYXJ5KHNlbGVjdGlvblN0YXJ0LCAxKTsgLyogc2VhcmNoIGZvcndhcmQgKi9cblxuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb25FbmQ7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyBhIGxpbmUgYmFzZWQgb24gdGhlIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlbGVjdGlvblN0YXJ0IEluZGV4IG9mIGEgY2hhcmFjdGVyXG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNlbGVjdExpbmU6IGZ1bmN0aW9uKHNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICBzZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvblN0YXJ0IHx8IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB2YXIgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLmZpbmRMaW5lQm91bmRhcnlMZWZ0KHNlbGVjdGlvblN0YXJ0KSxcbiAgICAgICAgICBuZXdTZWxlY3Rpb25FbmQgPSB0aGlzLmZpbmRMaW5lQm91bmRhcnlSaWdodChzZWxlY3Rpb25TdGFydCk7XG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uRW5kO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW50ZXJzIGVkaXRpbmcgc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZW50ZXJFZGl0aW5nOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy5pc0VkaXRpbmcgfHwgIXRoaXMuZWRpdGFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuY2FsY09mZnNldCgpO1xuICAgICAgICB0aGlzLmV4aXRFZGl0aW5nT25PdGhlcnModGhpcy5jYW52YXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG5cbiAgICAgIHRoaXMuaW5pdEhpZGRlblRleHRhcmVhKGUpO1xuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5mb2N1cygpO1xuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSA9IHRoaXMudGV4dDtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICB0aGlzLl9zYXZlRWRpdGluZ1Byb3BzKCk7XG4gICAgICB0aGlzLl9zZXRFZGl0aW5nUHJvcHMoKTtcbiAgICAgIHRoaXMuX3RleHRCZWZvcmVFZGl0ID0gdGhpcy50ZXh0O1xuXG4gICAgICB0aGlzLl90aWNrKCk7XG4gICAgICB0aGlzLmZpcmUoJ2VkaXRpbmc6ZW50ZXJlZCcpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OmVkaXRpbmc6ZW50ZXJlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgdGhpcy5pbml0TW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGV4aXRFZGl0aW5nT25PdGhlcnM6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgaWYgKGNhbnZhcy5faVRleHRJbnN0YW5jZXMpIHtcbiAgICAgICAgY2FudmFzLl9pVGV4dEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIG9iai5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChvYmouaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICBvYmouZXhpdEVkaXRpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBcIm1vdXNlbW92ZVwiIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cbiAgICBpbml0TW91c2VNb3ZlSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNhbnZhcy5vbignbW91c2U6bW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbW91c2VNb3ZlSGFuZGxlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLl9faXNNb3VzZWRvd24gfHwgIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gcmVnYWluIGZvY3VzXG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0aGlzLmhpZGRlblRleHRhcmVhICYmIHRoaXMuaGlkZGVuVGV4dGFyZWEuZm9jdXMoKTtcblxuICAgICAgdmFyIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy5nZXRTZWxlY3Rpb25TdGFydEZyb21Qb2ludGVyKG9wdGlvbnMuZSksXG4gICAgICAgICAgY3VycmVudFN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICBjdXJyZW50RW5kID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgICBpZiAoXG4gICAgICAgIChuZXdTZWxlY3Rpb25TdGFydCAhPT0gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24gfHwgY3VycmVudFN0YXJ0ID09PSBjdXJyZW50RW5kKVxuICAgICAgICAmJlxuICAgICAgICAoY3VycmVudFN0YXJ0ID09PSBuZXdTZWxlY3Rpb25TdGFydCB8fCBjdXJyZW50RW5kID09PSBuZXdTZWxlY3Rpb25TdGFydClcbiAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobmV3U2VsZWN0aW9uU3RhcnQgPiB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93bikge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd247XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IGN1cnJlbnRTdGFydCB8fCB0aGlzLnNlbGVjdGlvbkVuZCAhPT0gY3VycmVudEVuZCkge1xuICAgICAgICB0aGlzLnJlc3RhcnRDdXJzb3JJZk5lZWRlZCgpO1xuICAgICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldEVkaXRpbmdQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmhvdmVyQ3Vyc29yID0gJ3RleHQnO1xuXG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZGVmYXVsdEN1cnNvciA9IHRoaXMuY2FudmFzLm1vdmVDdXJzb3IgPSAndGV4dCc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSB0aGlzLmVkaXRpbmdCb3JkZXJDb2xvcjtcbiAgICAgIHRoaXMuaGFzQ29udHJvbHMgPSB0aGlzLnNlbGVjdGFibGUgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9ja01vdmVtZW50WCA9IHRoaXMubG9ja01vdmVtZW50WSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgZnJvbSB0ZXh0YXJlYSB0byBncmFwaGVtZSBpbmRleGVzXG4gICAgICovXG4gICAgZnJvbVN0cmluZ1RvR3JhcGhlbWVTZWxlY3Rpb246IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHRleHQpIHtcbiAgICAgIHZhciBzbWFsbGVyVGV4dFN0YXJ0ID0gdGV4dC5zbGljZSgwLCBzdGFydCksXG4gICAgICAgICAgZ3JhcGhlbWVTdGFydCA9IGZhYnJpYy51dGlsLnN0cmluZy5ncmFwaGVtZVNwbGl0KHNtYWxsZXJUZXh0U3RhcnQpLmxlbmd0aDtcbiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICAgIHJldHVybiB7IHNlbGVjdGlvblN0YXJ0OiBncmFwaGVtZVN0YXJ0LCBzZWxlY3Rpb25FbmQ6IGdyYXBoZW1lU3RhcnQgfTtcbiAgICAgIH1cbiAgICAgIHZhciBzbWFsbGVyVGV4dEVuZCA9IHRleHQuc2xpY2Uoc3RhcnQsIGVuZCksXG4gICAgICAgICAgZ3JhcGhlbWVFbmQgPSBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdChzbWFsbGVyVGV4dEVuZCkubGVuZ3RoO1xuICAgICAgcmV0dXJuIHsgc2VsZWN0aW9uU3RhcnQ6IGdyYXBoZW1lU3RhcnQsIHNlbGVjdGlvbkVuZDogZ3JhcGhlbWVTdGFydCArIGdyYXBoZW1lRW5kIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgZnJvbSBmYWJyaWMgdG8gdGV4dGFyZWEgdmFsdWVzXG4gICAgICovXG4gICAgZnJvbUdyYXBoZW1lVG9TdHJpbmdTZWxlY3Rpb246IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIF90ZXh0KSB7XG4gICAgICB2YXIgc21hbGxlclRleHRTdGFydCA9IF90ZXh0LnNsaWNlKDAsIHN0YXJ0KSxcbiAgICAgICAgICBncmFwaGVtZVN0YXJ0ID0gc21hbGxlclRleHRTdGFydC5qb2luKCcnKS5sZW5ndGg7XG4gICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICByZXR1cm4geyBzZWxlY3Rpb25TdGFydDogZ3JhcGhlbWVTdGFydCwgc2VsZWN0aW9uRW5kOiBncmFwaGVtZVN0YXJ0IH07XG4gICAgICB9XG4gICAgICB2YXIgc21hbGxlclRleHRFbmQgPSBfdGV4dC5zbGljZShzdGFydCwgZW5kKSxcbiAgICAgICAgICBncmFwaGVtZUVuZCA9IHNtYWxsZXJUZXh0RW5kLmpvaW4oJycpLmxlbmd0aDtcbiAgICAgIHJldHVybiB7IHNlbGVjdGlvblN0YXJ0OiBncmFwaGVtZVN0YXJ0LCBzZWxlY3Rpb25FbmQ6IGdyYXBoZW1lU3RhcnQgKyBncmFwaGVtZUVuZCB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVUZXh0YXJlYTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmN1cnNvck9mZnNldENhY2hlID0geyB9O1xuICAgICAgaWYgKCF0aGlzLmhpZGRlblRleHRhcmVhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5mcm9tR3JhcGhlbWVUb1N0cmluZ1NlbGVjdGlvbih0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCwgdGhpcy5fdGV4dCk7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb24uc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uLnNlbGVjdGlvbkVuZDtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlVGV4dGFyZWFQb3NpdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZUZyb21UZXh0QXJlYTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaGlkZGVuVGV4dGFyZWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IHsgfTtcbiAgICAgIHRoaXMudGV4dCA9IHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWU7XG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmZyb21TdHJpbmdUb0dyYXBoZW1lU2VsZWN0aW9uKFxuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvblN0YXJ0LCB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvbkVuZCwgdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSk7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb24uc2VsZWN0aW9uRW5kO1xuICAgICAgaWYgKCF0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb24uc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVRleHRhcmVhUG9zaXRpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0YXJlYVBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9jYWxjVGV4dGFyZWFQb3NpdGlvbigpO1xuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnN0eWxlLmxlZnQgPSBzdHlsZS5sZWZ0O1xuICAgICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnN0eWxlLnRvcCA9IHN0eWxlLnRvcDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHN0eWxlIGNvbnRhaW5zIHN0eWxlIGZvciBoaWRkZW5UZXh0YXJlYVxuICAgICAqL1xuICAgIF9jYWxjVGV4dGFyZWFQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDEsIHk6IDEgfTtcbiAgICAgIH1cbiAgICAgIHZhciBkZXNpcmVkUG9zaXRpb24gPSB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID8gdGhpcy5jb21wb3NpdGlvblN0YXJ0IDogdGhpcy5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICBib3VuZGFyaWVzID0gdGhpcy5fZ2V0Q3Vyc29yQm91bmRhcmllcyhkZXNpcmVkUG9zaXRpb24pLFxuICAgICAgICAgIGN1cnNvckxvY2F0aW9uID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKGRlc2lyZWRQb3NpdGlvbiksXG4gICAgICAgICAgbGluZUluZGV4ID0gY3Vyc29yTG9jYXRpb24ubGluZUluZGV4LFxuICAgICAgICAgIGNoYXJJbmRleCA9IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCxcbiAgICAgICAgICBjaGFySGVpZ2h0ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsaW5lSW5kZXgsIGNoYXJJbmRleCwgJ2ZvbnRTaXplJykgKiB0aGlzLmxpbmVIZWlnaHQsXG4gICAgICAgICAgbGVmdE9mZnNldCA9IGJvdW5kYXJpZXMubGVmdE9mZnNldCxcbiAgICAgICAgICBtID0gdGhpcy5jYWxjVHJhbnNmb3JtTWF0cml4KCksXG4gICAgICAgICAgcCA9IHtcbiAgICAgICAgICAgIHg6IGJvdW5kYXJpZXMubGVmdCArIGxlZnRPZmZzZXQsXG4gICAgICAgICAgICB5OiBib3VuZGFyaWVzLnRvcCArIGJvdW5kYXJpZXMudG9wT2Zmc2V0ICsgY2hhckhlaWdodFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmV0aW5hU2NhbGluZyA9IHRoaXMuY2FudmFzLmdldFJldGluYVNjYWxpbmcoKSxcbiAgICAgICAgICB1cHBlckNhbnZhcyA9IHRoaXMuY2FudmFzLnVwcGVyQ2FudmFzRWwsXG4gICAgICAgICAgdXBwZXJDYW52YXNXaWR0aCA9IHVwcGVyQ2FudmFzLndpZHRoIC8gcmV0aW5hU2NhbGluZyxcbiAgICAgICAgICB1cHBlckNhbnZhc0hlaWdodCA9IHVwcGVyQ2FudmFzLmhlaWdodCAvIHJldGluYVNjYWxpbmcsXG4gICAgICAgICAgbWF4V2lkdGggPSB1cHBlckNhbnZhc1dpZHRoIC0gY2hhckhlaWdodCxcbiAgICAgICAgICBtYXhIZWlnaHQgPSB1cHBlckNhbnZhc0hlaWdodCAtIGNoYXJIZWlnaHQsXG4gICAgICAgICAgc2NhbGVYID0gdXBwZXJDYW52YXMuY2xpZW50V2lkdGggLyB1cHBlckNhbnZhc1dpZHRoLFxuICAgICAgICAgIHNjYWxlWSA9IHVwcGVyQ2FudmFzLmNsaWVudEhlaWdodCAvIHVwcGVyQ2FudmFzSGVpZ2h0O1xuXG4gICAgICBwID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocCwgbSk7XG4gICAgICBwID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocCwgdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm0pO1xuICAgICAgcC54ICo9IHNjYWxlWDtcbiAgICAgIHAueSAqPSBzY2FsZVk7XG4gICAgICBpZiAocC54IDwgMCkge1xuICAgICAgICBwLnggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHAueCA+IG1heFdpZHRoKSB7XG4gICAgICAgIHAueCA9IG1heFdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHAueSA8IDApIHtcbiAgICAgICAgcC55ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChwLnkgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgcC55ID0gbWF4SGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgY2FudmFzIG9mZnNldCBvbiBkb2N1bWVudFxuICAgICAgcC54ICs9IHRoaXMuY2FudmFzLl9vZmZzZXQubGVmdDtcbiAgICAgIHAueSArPSB0aGlzLmNhbnZhcy5fb2Zmc2V0LnRvcDtcblxuICAgICAgcmV0dXJuIHsgbGVmdDogcC54ICsgJ3B4JywgdG9wOiBwLnkgKyAncHgnLCBmb250U2l6ZTogY2hhckhlaWdodCArICdweCcsIGNoYXJIZWlnaHQ6IGNoYXJIZWlnaHQgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2F2ZUVkaXRpbmdQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9zYXZlZFByb3BzID0ge1xuICAgICAgICBoYXNDb250cm9sczogdGhpcy5oYXNDb250cm9scyxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMuYm9yZGVyQ29sb3IsXG4gICAgICAgIGxvY2tNb3ZlbWVudFg6IHRoaXMubG9ja01vdmVtZW50WCxcbiAgICAgICAgbG9ja01vdmVtZW50WTogdGhpcy5sb2NrTW92ZW1lbnRZLFxuICAgICAgICBob3ZlckN1cnNvcjogdGhpcy5ob3ZlckN1cnNvcixcbiAgICAgICAgc2VsZWN0YWJsZTogdGhpcy5zZWxlY3RhYmxlLFxuICAgICAgICBkZWZhdWx0Q3Vyc29yOiB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5kZWZhdWx0Q3Vyc29yLFxuICAgICAgICBtb3ZlQ3Vyc29yOiB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5tb3ZlQ3Vyc29yXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXN0b3JlRWRpdGluZ1Byb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fc2F2ZWRQcm9wcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaG92ZXJDdXJzb3IgPSB0aGlzLl9zYXZlZFByb3BzLmhvdmVyQ3Vyc29yO1xuICAgICAgdGhpcy5oYXNDb250cm9scyA9IHRoaXMuX3NhdmVkUHJvcHMuaGFzQ29udHJvbHM7XG4gICAgICB0aGlzLmJvcmRlckNvbG9yID0gdGhpcy5fc2F2ZWRQcm9wcy5ib3JkZXJDb2xvcjtcbiAgICAgIHRoaXMuc2VsZWN0YWJsZSA9IHRoaXMuX3NhdmVkUHJvcHMuc2VsZWN0YWJsZTtcbiAgICAgIHRoaXMubG9ja01vdmVtZW50WCA9IHRoaXMuX3NhdmVkUHJvcHMubG9ja01vdmVtZW50WDtcbiAgICAgIHRoaXMubG9ja01vdmVtZW50WSA9IHRoaXMuX3NhdmVkUHJvcHMubG9ja01vdmVtZW50WTtcblxuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmRlZmF1bHRDdXJzb3IgPSB0aGlzLl9zYXZlZFByb3BzLmRlZmF1bHRDdXJzb3I7XG4gICAgICAgIHRoaXMuY2FudmFzLm1vdmVDdXJzb3IgPSB0aGlzLl9zYXZlZFByb3BzLm1vdmVDdXJzb3I7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4aXRzIGZyb20gZWRpdGluZyBzdGF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBleGl0RWRpdGluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXNUZXh0Q2hhbmdlZCA9ICh0aGlzLl90ZXh0QmVmb3JlRWRpdCAhPT0gdGhpcy50ZXh0KTtcbiAgICAgIHZhciBoaWRkZW5UZXh0YXJlYSA9IHRoaXMuaGlkZGVuVGV4dGFyZWE7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuXG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG5cbiAgICAgIGlmIChoaWRkZW5UZXh0YXJlYSkge1xuICAgICAgICBoaWRkZW5UZXh0YXJlYS5ibHVyICYmIGhpZGRlblRleHRhcmVhLmJsdXIoKTtcbiAgICAgICAgaGlkZGVuVGV4dGFyZWEucGFyZW50Tm9kZSAmJiBoaWRkZW5UZXh0YXJlYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGhpZGRlblRleHRhcmVhKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEgPSBudWxsO1xuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5fcmVzdG9yZUVkaXRpbmdQcm9wcygpO1xuICAgICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAwO1xuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZpcmUoJ2VkaXRpbmc6ZXhpdGVkJyk7XG4gICAgICBpc1RleHRDaGFuZ2VkICYmIHRoaXMuZmlyZSgnbW9kaWZpZWQnKTtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5vZmYoJ21vdXNlOm1vdmUnLCB0aGlzLm1vdXNlTW92ZUhhbmRsZXIpO1xuICAgICAgICB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OmVkaXRpbmc6ZXhpdGVkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgICAgIGlzVGV4dENoYW5nZWQgJiYgdGhpcy5jYW52YXMuZmlyZSgnb2JqZWN0Om1vZGlmaWVkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlRXh0cmFuZW91c1N0eWxlczogZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuc3R5bGVzKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGV4dExpbmVzW3Byb3BdKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhbmQgcmVmbG93IGEgc3R5bGUgYmxvY2sgZnJvbSBzdGFydCB0byBlbmQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IGxpbmVhciBzdGFydCBwb3NpdGlvbiBmb3IgcmVtb3ZhbCAoaW5jbHVkZWQgaW4gcmVtb3ZhbClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIGxpbmVhciBlbmQgcG9zaXRpb24gZm9yIHJlbW92YWwgKCBleGNsdWRlZCBmcm9tIHJlbW92YWwgKVxuICAgICAqL1xuICAgIHJlbW92ZVN0eWxlRnJvbVRvOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgY3Vyc29yU3RhcnQgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc3RhcnQsIHRydWUpLFxuICAgICAgICAgIGN1cnNvckVuZCA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihlbmQsIHRydWUpLFxuICAgICAgICAgIGxpbmVTdGFydCA9IGN1cnNvclN0YXJ0LmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFyU3RhcnQgPSBjdXJzb3JTdGFydC5jaGFySW5kZXgsXG4gICAgICAgICAgbGluZUVuZCA9IGN1cnNvckVuZC5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhckVuZCA9IGN1cnNvckVuZC5jaGFySW5kZXgsXG4gICAgICAgICAgaSwgc3R5bGVPYmo7XG4gICAgICBpZiAobGluZVN0YXJ0ICE9PSBsaW5lRW5kKSB7XG4gICAgICAgIC8vIHN0ZXAxIHJlbW92ZSB0aGUgdHJhaWxpbmcgb2YgbGluZVN0YXJ0XG4gICAgICAgIGlmICh0aGlzLnN0eWxlc1tsaW5lU3RhcnRdKSB7XG4gICAgICAgICAgZm9yIChpID0gY2hhclN0YXJ0OyBpIDwgdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzW2xpbmVTdGFydF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lU3RhcnRdW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwMiBtb3ZlIHRoZSB0cmFpbGluZyBvZiBsaW5lRW5kIHRvIGxpbmVTdGFydCBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVzW2xpbmVFbmRdKSB7XG4gICAgICAgICAgZm9yIChpID0gY2hhckVuZDsgaSA8IHRoaXMuX3Vud3JhcHBlZFRleHRMaW5lc1tsaW5lRW5kXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3R5bGVPYmogPSB0aGlzLnN0eWxlc1tsaW5lRW5kXVtpXTtcbiAgICAgICAgICAgIGlmIChzdHlsZU9iaikge1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lU3RhcnRdIHx8ICh0aGlzLnN0eWxlc1tsaW5lU3RhcnRdID0geyB9KTtcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbGluZVN0YXJ0XVtjaGFyU3RhcnQgKyBpIC0gY2hhckVuZF0gPSBzdHlsZU9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RlcDMgZGV0ZWN0cyBsaW5lcyB3aWxsIGJlIGNvbXBsZXRlbHkgcmVtb3ZlZC5cbiAgICAgICAgZm9yIChpID0gbGluZVN0YXJ0ICsgMTsgaSA8PSBsaW5lRW5kOyBpKyspIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RlcDQgc2hpZnQgcmVtYWluaW5nIGxpbmVzLlxuICAgICAgICB0aGlzLnNoaWZ0TGluZVN0eWxlcyhsaW5lRW5kLCBsaW5lU3RhcnQgLSBsaW5lRW5kKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyByZW1vdmUgYW5kIHNoaWZ0IGxlZnQgb24gdGhlIHNhbWUgbGluZVxuICAgICAgICBpZiAodGhpcy5zdHlsZXNbbGluZVN0YXJ0XSkge1xuICAgICAgICAgIHN0eWxlT2JqID0gdGhpcy5zdHlsZXNbbGluZVN0YXJ0XTtcbiAgICAgICAgICB2YXIgZGlmZiA9IGNoYXJFbmQgLSBjaGFyU3RhcnQsIG51bWVyaWNDaGFyLCBfY2hhcjtcbiAgICAgICAgICBmb3IgKGkgPSBjaGFyU3RhcnQ7IGkgPCBjaGFyRW5kOyBpKyspIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdHlsZU9ialtpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChfY2hhciBpbiB0aGlzLnN0eWxlc1tsaW5lU3RhcnRdKSB7XG4gICAgICAgICAgICBudW1lcmljQ2hhciA9IHBhcnNlSW50KF9jaGFyLCAxMCk7XG4gICAgICAgICAgICBpZiAobnVtZXJpY0NoYXIgPj0gY2hhckVuZCkge1xuICAgICAgICAgICAgICBzdHlsZU9ialtudW1lcmljQ2hhciAtIGRpZmZdID0gc3R5bGVPYmpbX2NoYXJdO1xuICAgICAgICAgICAgICBkZWxldGUgc3R5bGVPYmpbX2NoYXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaGlmdHMgbGluZSBzdHlsZXMgdXAgb3IgZG93blxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBDYW4gYW55IG51bWJlcj9cbiAgICAgKi9cbiAgICBzaGlmdExpbmVTdHlsZXM6IGZ1bmN0aW9uKGxpbmVJbmRleCwgb2Zmc2V0KSB7XG4gICAgICAvLyBzaGlmdCBhbGwgbGluZSBzdHlsZXMgYnkgb2Zmc2V0IHVwd2FyZCBvciBkb3dud2FyZFxuICAgICAgLy8gZG8gbm90IGNsb25lIGRlZXAuIHdlIG5lZWQgbmV3IGFycmF5LCBub3QgbmV3IHN0eWxlIG9iamVjdHNcbiAgICAgIHZhciBjbG9uZWRTdHlsZXMgPSBjbG9uZSh0aGlzLnN0eWxlcyk7XG4gICAgICBmb3IgKHZhciBsaW5lIGluIHRoaXMuc3R5bGVzKSB7XG4gICAgICAgIHZhciBudW1lcmljTGluZSA9IHBhcnNlSW50KGxpbmUsIDEwKTtcbiAgICAgICAgaWYgKG51bWVyaWNMaW5lID4gbGluZUluZGV4KSB7XG4gICAgICAgICAgdGhpcy5zdHlsZXNbbnVtZXJpY0xpbmUgKyBvZmZzZXRdID0gY2xvbmVkU3R5bGVzW251bWVyaWNMaW5lXTtcbiAgICAgICAgICBpZiAoIWNsb25lZFN0eWxlc1tudW1lcmljTGluZSAtIG9mZnNldF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tudW1lcmljTGluZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlc3RhcnRDdXJzb3JJZk5lZWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX2N1cnJlbnRUaWNrU3RhdGUgfHwgdGhpcy5fY3VycmVudFRpY2tTdGF0ZS5pc0Fib3J0ZWRcbiAgICAgICAgfHwgIXRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZSB8fCB0aGlzLl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUuaXNBYm9ydGVkXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgaW5zZXJ0aW9uIG9mIG1vcmUgY29uc2VjdXRpdmUgc3R5bGUgbGluZXMgZm9yIHdoZW4gb25lIG9yIG1vcmVcbiAgICAgKiBuZXdsaW5lcyBnZXRzIGFkZGVkIHRvIHRoZSB0ZXh0LiBTaW5jZSBjdXJyZW50IHN0eWxlIG5lZWRzIHRvIGJlIHNoaWZ0ZWRcbiAgICAgKiBmaXJzdCB3ZSBzaGlmdCB0aGUgY3VycmVudCBzdHlsZSBvZiB0aGUgbnVtYmVyIGxpbmVzIG5lZWRlZCwgdGhlbiB3ZSBhZGRcbiAgICAgKiBuZXcgbGluZXMgZnJvbSB0aGUgbGFzdCB0byB0aGUgZmlyc3QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4IEluZGV4IG9mIGEgY2hhclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBxdHkgbnVtYmVyIG9mIGxpbmVzIHRvIGFkZFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvcGllZFN0eWxlIEFycmF5IG9mIG9iamVjdHMgc3R5bGVzXG4gICAgICovXG4gICAgaW5zZXJ0TmV3bGluZVN0eWxlT2JqZWN0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgcXR5LCBjb3BpZWRTdHlsZSkge1xuICAgICAgdmFyIGN1cnJlbnRDaGFyU3R5bGUsXG4gICAgICAgICAgbmV3TGluZVN0eWxlcyA9IHt9LFxuICAgICAgICAgIHNvbWV0aGluZ0FkZGVkID0gZmFsc2UsXG4gICAgICAgICAgaXNFbmRPZkxpbmUgPSB0aGlzLl91bndyYXBwZWRUZXh0TGluZXNbbGluZUluZGV4XS5sZW5ndGggPT09IGNoYXJJbmRleDtcblxuICAgICAgcXR5IHx8IChxdHkgPSAxKTtcbiAgICAgIHRoaXMuc2hpZnRMaW5lU3R5bGVzKGxpbmVJbmRleCwgcXR5KTtcbiAgICAgIGlmICh0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIGN1cnJlbnRDaGFyU3R5bGUgPSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleCA9PT0gMCA/IGNoYXJJbmRleCA6IGNoYXJJbmRleCAtIDFdO1xuICAgICAgfVxuICAgICAgLy8gd2UgY2xvbmUgc3R5bGVzIG9mIGFsbCBjaGFyc1xuICAgICAgLy8gYWZ0ZXIgY3Vyc29yIG9udG8gdGhlIGN1cnJlbnQgbGluZVxuICAgICAgZm9yICh2YXIgaW5kZXggaW4gdGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICB2YXIgbnVtSW5kZXggPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgICAgICBpZiAobnVtSW5kZXggPj0gY2hhckluZGV4KSB7XG4gICAgICAgICAgc29tZXRoaW5nQWRkZWQgPSB0cnVlO1xuICAgICAgICAgIG5ld0xpbmVTdHlsZXNbbnVtSW5kZXggLSBjaGFySW5kZXhdID0gdGhpcy5zdHlsZXNbbGluZUluZGV4XVtpbmRleF07XG4gICAgICAgICAgLy8gcmVtb3ZlIGxpbmVzIGZyb20gdGhlIHByZXZpb3VzIGxpbmUgc2luY2UgdGhleSdyZSBvbiBhIG5ldyBsaW5lIG5vd1xuICAgICAgICAgIGlmICghKGlzRW5kT2ZMaW5lICYmIGNoYXJJbmRleCA9PT0gMCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZUNhcnJpZWRPdmVyID0gZmFsc2U7XG4gICAgICBpZiAoc29tZXRoaW5nQWRkZWQgJiYgIWlzRW5kT2ZMaW5lKSB7XG4gICAgICAgIC8vIGlmIGlzIGVuZCBvZiBsaW5lLCB0aGUgZXh0cmEgc3R5bGUgd2UgY29waWVkXG4gICAgICAgIC8vIGlzIHByb2JhYmx5IG5vdCBzb21ldGhpbmcgd2Ugd2FudFxuICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyBxdHldID0gbmV3TGluZVN0eWxlcztcbiAgICAgICAgc3R5bGVDYXJyaWVkT3ZlciA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVDYXJyaWVkT3Zlcikge1xuICAgICAgICAvLyBza2lwIHRoZSBsYXN0IGxpbmUgb2Ygc2luY2Ugd2UgYWxyZWFkeSBwcmVwYXJlZCBpdC5cbiAgICAgICAgcXR5LS07XG4gICAgICB9XG4gICAgICAvLyBmb3IgdGhlIGFsbCB0aGUgbGluZXMgb3IgYWxsIHRoZSBvdGhlciBsaW5lc1xuICAgICAgLy8gd2UgY2xvbmUgY3VycmVudCBjaGFyIHN0eWxlIG9udG8gdGhlIG5leHQgKG90aGVyd2lzZSBlbXB0eSkgbGluZVxuICAgICAgd2hpbGUgKHF0eSA+IDApIHtcbiAgICAgICAgaWYgKGNvcGllZFN0eWxlICYmIGNvcGllZFN0eWxlW3F0eSAtIDFdKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgcXR5XSA9IHsgMDogY2xvbmUoY29waWVkU3R5bGVbcXR5IC0gMV0pIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudENoYXJTdHlsZSkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIHF0eV0gPSB7IDA6IGNsb25lKGN1cnJlbnRDaGFyU3R5bGUpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVJbmRleCArIHF0eV07XG4gICAgICAgIH1cbiAgICAgICAgcXR5LS07XG4gICAgICB9XG4gICAgICB0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHN0eWxlIG9iamVjdCBmb3IgYSBnaXZlbiBsaW5lL2NoYXIgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IEluZGV4IG9mIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggSW5kZXggb2YgYSBjaGFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHF1YW50aXR5IG51bWJlciBTdHlsZSBvYmplY3QgdG8gaW5zZXJ0LCBpZiBnaXZlblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvcGllZFN0eWxlIGFycmF5IG9mIHN0eWxlIG9iamVjdHNcbiAgICAgKi9cbiAgICBpbnNlcnRDaGFyU3R5bGVPYmplY3Q6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBxdWFudGl0eSwgY29waWVkU3R5bGUpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJyZW50TGluZVN0eWxlcyAgICAgICA9IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0sXG4gICAgICAgICAgY3VycmVudExpbmVTdHlsZXNDbG9uZWQgPSBjdXJyZW50TGluZVN0eWxlcyA/IGNsb25lKGN1cnJlbnRMaW5lU3R5bGVzKSA6IHt9O1xuXG4gICAgICBxdWFudGl0eSB8fCAocXVhbnRpdHkgPSAxKTtcbiAgICAgIC8vIHNoaWZ0IGFsbCBjaGFyIHN0eWxlcyBieSBxdWFudGl0eSBmb3J3YXJkXG4gICAgICAvLyAwLDEsMiwzIC0+IChjaGFySW5kZXg9MikgLT4gMCwxLDMsNCAtPiAoaW5zZXJ0IDIpIC0+IDAsMSwyLDMsNFxuICAgICAgZm9yICh2YXIgaW5kZXggaW4gY3VycmVudExpbmVTdHlsZXNDbG9uZWQpIHtcbiAgICAgICAgdmFyIG51bWVyaWNJbmRleCA9IHBhcnNlSW50KGluZGV4LCAxMCk7XG4gICAgICAgIGlmIChudW1lcmljSW5kZXggPj0gY2hhckluZGV4KSB7XG4gICAgICAgICAgY3VycmVudExpbmVTdHlsZXNbbnVtZXJpY0luZGV4ICsgcXVhbnRpdHldID0gY3VycmVudExpbmVTdHlsZXNDbG9uZWRbbnVtZXJpY0luZGV4XTtcbiAgICAgICAgICAvLyBvbmx5IGRlbGV0ZSB0aGUgc3R5bGUgaWYgdGhlcmUgd2FzIG5vdGhpbmcgbW92ZWQgdGhlcmVcbiAgICAgICAgICBpZiAoIWN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkW251bWVyaWNJbmRleCAtIHF1YW50aXR5XSkge1xuICAgICAgICAgICAgZGVsZXRlIGN1cnJlbnRMaW5lU3R5bGVzW251bWVyaWNJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9mb3JjZUNsZWFyQ2FjaGUgPSB0cnVlO1xuICAgICAgaWYgKGNvcGllZFN0eWxlKSB7XG4gICAgICAgIHdoaWxlIChxdWFudGl0eS0tKSB7XG4gICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhjb3BpZWRTdHlsZVtxdWFudGl0eV0pLmxlbmd0aCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4XSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleCArIHF1YW50aXR5XSA9IGNsb25lKGNvcGllZFN0eWxlW3F1YW50aXR5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFjdXJyZW50TGluZVN0eWxlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmV3U3R5bGUgPSBjdXJyZW50TGluZVN0eWxlc1tjaGFySW5kZXggPyBjaGFySW5kZXggLSAxIDogMV07XG4gICAgICB3aGlsZSAobmV3U3R5bGUgJiYgcXVhbnRpdHktLSkge1xuICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleCArIHF1YW50aXR5XSA9IGNsb25lKG5ld1N0eWxlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBzdHlsZSBvYmplY3QocylcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbnNlcnRlZFRleHQgQ2hhcmFjdGVycyBhdCB0aGUgbG9jYXRpb24gd2hlcmUgc3R5bGUgaXMgaW5zZXJ0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgY3Vyc29yIGluZGV4IGZvciBpbnNlcnRpbmcgc3R5bGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29waWVkU3R5bGVdIGFycmF5IG9mIHN0eWxlIG9iamVjdHMgdG8gaW5zZXJ0LlxuICAgICAqL1xuICAgIGluc2VydE5ld1N0eWxlQmxvY2s6IGZ1bmN0aW9uKGluc2VydGVkVGV4dCwgc3RhcnQsIGNvcGllZFN0eWxlKSB7XG4gICAgICB2YXIgY3Vyc29yTG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHN0YXJ0LCB0cnVlKSxcbiAgICAgICAgICBhZGRlZExpbmVzID0gWzBdLCBsaW5lc0xlbmd0aCA9IDA7XG4gICAgICAvLyBnZXQgYW4gYXJyYXkgb2YgaG93IG1hbnkgY2hhciBwZXIgbGluZXMgYXJlIGJlaW5nIGFkZGVkLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnNlcnRlZFRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGluc2VydGVkVGV4dFtpXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBsaW5lc0xlbmd0aCsrO1xuICAgICAgICAgIGFkZGVkTGluZXNbbGluZXNMZW5ndGhdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhZGRlZExpbmVzW2xpbmVzTGVuZ3RoXSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBmb3IgdGhlIGZpcnN0IGxpbmUgY29weSB0aGUgc3R5bGUgZnJvbSB0aGUgY3VycmVudCBjaGFyIHBvc2l0aW9uLlxuICAgICAgaWYgKGFkZGVkTGluZXNbMF0gPiAwKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0Q2hhclN0eWxlT2JqZWN0KGN1cnNvckxvYy5saW5lSW5kZXgsIGN1cnNvckxvYy5jaGFySW5kZXgsIGFkZGVkTGluZXNbMF0sIGNvcGllZFN0eWxlKTtcbiAgICAgICAgY29waWVkU3R5bGUgPSBjb3BpZWRTdHlsZSAmJiBjb3BpZWRTdHlsZS5zbGljZShhZGRlZExpbmVzWzBdICsgMSk7XG4gICAgICB9XG4gICAgICBsaW5lc0xlbmd0aCAmJiB0aGlzLmluc2VydE5ld2xpbmVTdHlsZU9iamVjdChcbiAgICAgICAgY3Vyc29yTG9jLmxpbmVJbmRleCwgY3Vyc29yTG9jLmNoYXJJbmRleCArIGFkZGVkTGluZXNbMF0sIGxpbmVzTGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGluZXNMZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYWRkZWRMaW5lc1tpXSA+IDApIHtcbiAgICAgICAgICB0aGlzLmluc2VydENoYXJTdHlsZU9iamVjdChjdXJzb3JMb2MubGluZUluZGV4ICsgaSwgMCwgYWRkZWRMaW5lc1tpXSwgY29waWVkU3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvcGllZFN0eWxlKSB7XG4gICAgICAgICAgLy8gdGhpcyB0ZXN0IGlzIHJlcXVpcmVkIGluIG9yZGVyIHRvIGNsb3NlICM2ODQxXG4gICAgICAgICAgLy8gd2hlbiBhIHBhc3RlZCBidWZmZXIgYmVnaW5zIHdpdGggYSBuZXdsaW5lIHRoZW5cbiAgICAgICAgICAvLyB0aGlzLnN0eWxlc1tjdXJzb3JMb2MubGluZUluZGV4ICsgaV0gYW5kIGNvcGllZFN0eWxlWzBdXG4gICAgICAgICAgLy8gbWF5IGJlIHVuZGVmaW5lZCBmb3Igc29tZSByZWFzb25cbiAgICAgICAgICBpZiAodGhpcy5zdHlsZXNbY3Vyc29yTG9jLmxpbmVJbmRleCArIGldICYmIGNvcGllZFN0eWxlWzBdKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlc1tjdXJzb3JMb2MubGluZUluZGV4ICsgaV1bMF0gPSBjb3BpZWRTdHlsZVswXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29waWVkU3R5bGUgPSBjb3BpZWRTdHlsZSAmJiBjb3BpZWRTdHlsZS5zbGljZShhZGRlZExpbmVzW2ldICsgMSk7XG4gICAgICB9XG4gICAgICAvLyB3ZSB1c2UgaSBvdXRzaWRlIHRoZSBsb29wIHRvIGdldCBpdCBsaWtlIGxpbmVzTGVuZ3RoXG4gICAgICBpZiAoYWRkZWRMaW5lc1tpXSA+IDApIHtcbiAgICAgICAgdGhpcy5pbnNlcnRDaGFyU3R5bGVPYmplY3QoY3Vyc29yTG9jLmxpbmVJbmRleCArIGksIDAsIGFkZGVkTGluZXNbaV0sIGNvcGllZFN0eWxlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzZWxlY3Rpb25TdGFydCBhbmQgc2VsZWN0aW9uRW5kIGFjY29yZGluZyB0byB0aGUgbmV3IHBvc2l0aW9uIG9mIGN1cnNvclxuICAgICAqIG1pbWljIHRoZSBrZXkgLSBtb3VzZSBuYXZpZ2F0aW9uIHdoZW4gc2hpZnQgaXMgcHJlc3NlZC5cbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdDogZnVuY3Rpb24oc3RhcnQsIGVuZCwgbmV3U2VsZWN0aW9uKSB7XG4gICAgICBpZiAobmV3U2VsZWN0aW9uIDw9IHN0YXJ0KSB7XG4gICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb247XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChuZXdTZWxlY3Rpb24gPiBzdGFydCAmJiBuZXdTZWxlY3Rpb24gPCBlbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbmV3U2VsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBuZXdTZWxlY3Rpb24gaXMgPiBzZWxlY3Rpb24gc3RhcnQgYW5kIGVuZFxuICAgICAgICBpZiAoZW5kID09PSBzdGFydCkge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb247XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNldFNlbGVjdGlvbkluQm91bmRhcmllczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID4gbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0IDwgMCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbkVuZCA+IGxlbmd0aCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uRW5kIDwgMCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgXCJkYmNsaWNrXCIgZXZlbnQgaGFuZGxlclxuICAgKi9cbiAgaW5pdERvdWJsZUNsaWNrU2ltdWxhdGlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBmb3IgZG91YmxlIGNsaWNrXG4gICAgdGhpcy5fX2xhc3RDbGlja1RpbWUgPSArbmV3IERhdGUoKTtcblxuICAgIC8vIGZvciB0cmlwbGUgY2xpY2tcbiAgICB0aGlzLl9fbGFzdExhc3RDbGlja1RpbWUgPSArbmV3IERhdGUoKTtcblxuICAgIHRoaXMuX19sYXN0UG9pbnRlciA9IHsgfTtcblxuICAgIHRoaXMub24oJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGV2ZW50IGhhbmRsZXIgdG8gc2ltdWxhdGUgdHJpcGxlIGNsaWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fX25ld0NsaWNrVGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBuZXdQb2ludGVyID0gb3B0aW9ucy5wb2ludGVyO1xuICAgIGlmICh0aGlzLmlzVHJpcGxlQ2xpY2sobmV3UG9pbnRlcikpIHtcbiAgICAgIHRoaXMuZmlyZSgndHJpcGxlY2xpY2snLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX3N0b3BFdmVudChvcHRpb25zLmUpO1xuICAgIH1cbiAgICB0aGlzLl9fbGFzdExhc3RDbGlja1RpbWUgPSB0aGlzLl9fbGFzdENsaWNrVGltZTtcbiAgICB0aGlzLl9fbGFzdENsaWNrVGltZSA9IHRoaXMuX19uZXdDbGlja1RpbWU7XG4gICAgdGhpcy5fX2xhc3RQb2ludGVyID0gbmV3UG9pbnRlcjtcbiAgICB0aGlzLl9fbGFzdElzRWRpdGluZyA9IHRoaXMuaXNFZGl0aW5nO1xuICAgIHRoaXMuX19sYXN0U2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkO1xuICB9LFxuXG4gIGlzVHJpcGxlQ2xpY2s6IGZ1bmN0aW9uKG5ld1BvaW50ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fX25ld0NsaWNrVGltZSAtIHRoaXMuX19sYXN0Q2xpY2tUaW1lIDwgNTAwICYmXG4gICAgICAgIHRoaXMuX19sYXN0Q2xpY2tUaW1lIC0gdGhpcy5fX2xhc3RMYXN0Q2xpY2tUaW1lIDwgNTAwICYmXG4gICAgICAgIHRoaXMuX19sYXN0UG9pbnRlci54ID09PSBuZXdQb2ludGVyLnggJiZcbiAgICAgICAgdGhpcy5fX2xhc3RQb2ludGVyLnkgPT09IG5ld1BvaW50ZXIueTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdG9wRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbiAmJiBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBldmVudCBoYW5kbGVycyByZWxhdGVkIHRvIGN1cnNvciBvciBzZWxlY3Rpb25cbiAgICovXG4gIGluaXRDdXJzb3JTZWxlY3Rpb25IYW5kbGVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbml0TW91c2Vkb3duSGFuZGxlcigpO1xuICAgIHRoaXMuaW5pdE1vdXNldXBIYW5kbGVyKCk7XG4gICAgdGhpcy5pbml0Q2xpY2tzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgaGFuZGxlciBmb3IgZG91YmxlIGNsaWNrLCBzZWxlY3QgYSB3b3JkXG4gICAqL1xuICBkb3VibGVDbGlja0hhbmRsZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0V29yZCh0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIob3B0aW9ucy5lKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgaGFuZGxlciBmb3IgdHJpcGxlIGNsaWNrLCBzZWxlY3QgYSBsaW5lXG4gICAqL1xuICB0cmlwbGVDbGlja0hhbmRsZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0TGluZSh0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIob3B0aW9ucy5lKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGRvdWJsZSBhbmQgdHJpcGxlIGNsaWNrIGV2ZW50IGhhbmRsZXJzXG4gICAqL1xuICBpbml0Q2xpY2tzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdtb3VzZWRibGNsaWNrJywgdGhpcy5kb3VibGVDbGlja0hhbmRsZXIpO1xuICAgIHRoaXMub24oJ3RyaXBsZWNsaWNrJywgdGhpcy50cmlwbGVDbGlja0hhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXMgbmVlZGVkIG9uIF9tb3VzZURvd25cbiAgICogY2FuIGJlIG92ZXJyaWRkZW4gdG8gZG8gc29tZXRoaW5nIGRpZmZlcmVudC5cbiAgICogU2NvcGUgb2YgdGhpcyBpbXBsZW1lbnRhdGlvbiBpczogZmluZCB0aGUgY2xpY2sgcG9zaXRpb24sIHNldCBzZWxlY3Rpb25TdGFydFxuICAgKiBmaW5kIHNlbGVjdGlvbkVuZCwgaW5pdGlhbGl6ZSB0aGUgZHJhd2luZyBvZiBlaXRoZXIgY3Vyc29yIG9yIHNlbGVjdGlvbiBhcmVhXG4gICAqIGluaXRpYWxpemluZyBhIG1vdXNlZERvd24gb24gYSB0ZXh0IGFyZWEgd2lsbCBjYW5jZWwgZmFicmljanMga25vd2xlZGdlIG9mXG4gICAqIGN1cnJlbnQgY29tcG9zaXRpb25Nb2RlLiBJdCB3aWxsIGJlIHNldCB0byBmYWxzZS5cbiAgICovXG4gIF9tb3VzZURvd25IYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNhbnZhcyB8fCAhdGhpcy5lZGl0YWJsZSB8fCAob3B0aW9ucy5lLmJ1dHRvbiAmJiBvcHRpb25zLmUuYnV0dG9uICE9PSAxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX19pc01vdXNlZG93biA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZXRDdXJzb3JCeUNsaWNrKG9wdGlvbnMuZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93biA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBldmVudCBoYW5kbGVyIGZvciB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0aWVzIG5lZWRlZCBvbiBtb3VzZWRvd246YmVmb3JlXG4gICAqIGNhbiBiZSBvdmVycmlkZGVuIHRvIGRvIHNvbWV0aGluZyBkaWZmZXJlbnQuXG4gICAqIFNjb3BlIG9mIHRoaXMgaW1wbGVtZW50YXRpb24gaXM6IHZlcmlmeSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgc2VsZWN0ZWQgd2hlbiBtb3VzaW5nIGRvd25cbiAgICovXG4gIF9tb3VzZURvd25IYW5kbGVyQmVmb3JlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNhbnZhcyB8fCAhdGhpcy5lZGl0YWJsZSB8fCAob3B0aW9ucy5lLmJ1dHRvbiAmJiBvcHRpb25zLmUuYnV0dG9uICE9PSAxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB3ZSB3YW50IHRvIGF2b2lkIHRoYXQgYW4gb2JqZWN0IHRoYXQgd2FzIHNlbGVjdGVkIGFuZCB0aGVuIGJlY29tZXMgdW5zZWxlY3RhYmxlLFxuICAgIC8vIG1heSB0cmlnZ2VyIGVkaXRpbmcgbW9kZSBpbiBzb21lIHdheS5cbiAgICB0aGlzLnNlbGVjdGVkID0gdGhpcyA9PT0gdGhpcy5jYW52YXMuX2FjdGl2ZU9iamVjdDtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgXCJtb3VzZWRvd25cIiBldmVudCBoYW5kbGVyXG4gICAqL1xuICBpbml0TW91c2Vkb3duSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5fbW91c2VEb3duSGFuZGxlcik7XG4gICAgdGhpcy5vbignbW91c2Vkb3duOmJlZm9yZScsIHRoaXMuX21vdXNlRG93bkhhbmRsZXJCZWZvcmUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBcIm1vdXNldXBcIiBldmVudCBoYW5kbGVyXG4gICAqL1xuICBpbml0TW91c2V1cEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLm1vdXNlVXBIYW5kbGVyKTtcbiAgfSxcblxuICAvKipcbiAgICogc3RhbmRhcmQgaGFuZGxlciBmb3IgbW91c2UgdXAsIG92ZXJyaWRhYmxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBtb3VzZVVwSGFuZGxlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuX19pc01vdXNlZG93biA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5lZGl0YWJsZSB8fCB0aGlzLmdyb3VwIHx8XG4gICAgICAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb3B0aW9ucy50cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkKSB8fFxuICAgICAgKG9wdGlvbnMuZS5idXR0b24gJiYgb3B0aW9ucy5lLmJ1dHRvbiAhPT0gMSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHZhciBjdXJyZW50QWN0aXZlID0gdGhpcy5jYW52YXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIGlmIChjdXJyZW50QWN0aXZlICYmIGN1cnJlbnRBY3RpdmUgIT09IHRoaXMpIHtcbiAgICAgICAgLy8gYXZvaWQgcnVubmluZyB0aGlzIGxvZ2ljIHdoZW4gdGhlcmUgaXMgYW4gYWN0aXZlIG9iamVjdFxuICAgICAgICAvLyB0aGlzIGJlY2F1c2UgaXMgcG9zc2libGUgd2l0aCBzaGlmdCBjbGljayBhbmQgZmFzdCBjbGlja3MsXG4gICAgICAgIC8vIHRvIHJhcGlkbHkgZGVzZWxlY3QgYW5kIHJlc2VsZWN0IHRoaXMgb2JqZWN0IGFuZCB0cmlnZ2VyIGFuIGVudGVyRWRpdFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX19sYXN0U2VsZWN0ZWQgJiYgIXRoaXMuX19jb3JuZXIpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19sYXN0U2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW50ZXJFZGl0aW5nKG9wdGlvbnMuZSk7XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgdGhpcy5pbml0RGVsYXllZEN1cnNvcih0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIGN1cnNvciBsb2NhdGlvbiBpbiBhIHRleHQgZGVwZW5kaW5nIG9uIHBhc3NlZCBwb2ludGVyICh4L3kpIG9iamVjdFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgc2V0Q3Vyc29yQnlDbGljazogZnVuY3Rpb24oZSkge1xuICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIoZSksXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydCwgZW5kID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhcnRFbmRXaXRoU2hpZnQoc3RhcnQsIGVuZCwgbmV3U2VsZWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb247XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRWRpdGluZykge1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGluZGV4IG9mIGEgY2hhcmFjdGVyIGNvcnJlc3BvbmRpbmcgdG8gd2hlcmUgYW4gb2JqZWN0IHdhcyBjbGlja2VkXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqIEByZXR1cm4ge051bWJlcn0gSW5kZXggb2YgYSBjaGFyYWN0ZXJcbiAgICovXG4gIGdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgbW91c2VPZmZzZXQgPSB0aGlzLmdldExvY2FsUG9pbnRlcihlKSxcbiAgICAgICAgcHJldldpZHRoID0gMCxcbiAgICAgICAgd2lkdGggPSAwLFxuICAgICAgICBoZWlnaHQgPSAwLFxuICAgICAgICBjaGFySW5kZXggPSAwLFxuICAgICAgICBsaW5lSW5kZXggPSAwLFxuICAgICAgICBsaW5lTGVmdE9mZnNldCxcbiAgICAgICAgbGluZTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaGVpZ2h0IDw9IG1vdXNlT2Zmc2V0LnkpIHtcbiAgICAgICAgaGVpZ2h0ICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGxpbmVJbmRleCA9IGk7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGNoYXJJbmRleCArPSB0aGlzLl90ZXh0TGluZXNbaSAtIDFdLmxlbmd0aCArIHRoaXMubWlzc2luZ05ld2xpbmVPZmZzZXQoaSAtIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQobGluZUluZGV4KTtcbiAgICB3aWR0aCA9IGxpbmVMZWZ0T2Zmc2V0ICogdGhpcy5zY2FsZVg7XG4gICAgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdO1xuICAgIC8vIGhhbmRsaW5nIG9mIFJUTDogaW4gb3JkZXIgdG8gZ2V0IHRoaW5ncyB3b3JrIGNvcnJlY3RseSxcbiAgICAvLyB3ZSBhc3N1bWUgUlRMIHdyaXRpbmcgaXMgbWlycm9yZWQgY29tcGFyZWQgdG8gTFRSIHdyaXRpbmcuXG4gICAgLy8gc28gaW4gcG9zaXRpb24gZGV0ZWN0aW9uIHdlIG1pcnJvciB0aGUgWCBvZmZzZXQsIGFuZCB3aGVuIGlzIHRpbWVcbiAgICAvLyBvZiByZW5kZXJpbmcgaXQsIHdlIG1pcnJvciBpdCBhZ2Fpbi5cbiAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICBtb3VzZU9mZnNldC54ID0gdGhpcy53aWR0aCAqIHRoaXMuc2NhbGVYIC0gbW91c2VPZmZzZXQueCArIHdpZHRoO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICBwcmV2V2lkdGggPSB3aWR0aDtcbiAgICAgIC8vIGkgcmVtb3ZlZCBzb21ldGhpbmcgYWJvdXQgZmxpcFggaGVyZSwgY2hlY2suXG4gICAgICB3aWR0aCArPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2pdLmtlcm5lZFdpZHRoICogdGhpcy5zY2FsZVg7XG4gICAgICBpZiAod2lkdGggPD0gbW91c2VPZmZzZXQueCkge1xuICAgICAgICBjaGFySW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldE5ld1NlbGVjdGlvblN0YXJ0RnJvbU9mZnNldChtb3VzZU9mZnNldCwgcHJldldpZHRoLCB3aWR0aCwgY2hhckluZGV4LCBqbGVuKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXROZXdTZWxlY3Rpb25TdGFydEZyb21PZmZzZXQ6IGZ1bmN0aW9uKG1vdXNlT2Zmc2V0LCBwcmV2V2lkdGgsIHdpZHRoLCBpbmRleCwgamxlbikge1xuICAgIC8vIHdlIG5lZWQgTWF0aC5hYnMgYmVjYXVzZSB3aGVuIHdpZHRoIGlzIGFmdGVyIHRoZSBsYXN0IGNoYXIsIHRoZSBvZmZzZXQgaXMgZ2l2ZW4gYXMgMSwgd2hpbGUgaXMgMFxuICAgIHZhciBkaXN0YW5jZUJ0d0xhc3RDaGFyQW5kQ3Vyc29yID0gbW91c2VPZmZzZXQueCAtIHByZXZXaWR0aCxcbiAgICAgICAgZGlzdGFuY2VCdHdOZXh0Q2hhckFuZEN1cnNvciA9IHdpZHRoIC0gbW91c2VPZmZzZXQueCxcbiAgICAgICAgb2Zmc2V0ID0gZGlzdGFuY2VCdHdOZXh0Q2hhckFuZEN1cnNvciA+IGRpc3RhbmNlQnR3TGFzdENoYXJBbmRDdXJzb3IgfHxcbiAgICAgICAgICBkaXN0YW5jZUJ0d05leHRDaGFyQW5kQ3Vyc29yIDwgMCA/IDAgOiAxLFxuICAgICAgICBuZXdTZWxlY3Rpb25TdGFydCA9IGluZGV4ICsgb2Zmc2V0O1xuICAgIC8vIGlmIG9iamVjdCBpcyBob3Jpem9udGFsbHkgZmxpcHBlZCwgbWlycm9yIGN1cnNvciBsb2NhdGlvbiBmcm9tIHRoZSBlbmRcbiAgICBpZiAodGhpcy5mbGlwWCkge1xuICAgICAgbmV3U2VsZWN0aW9uU3RhcnQgPSBqbGVuIC0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKG5ld1NlbGVjdGlvblN0YXJ0ID4gdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgIG5ld1NlbGVjdGlvblN0YXJ0ID0gdGhpcy5fdGV4dC5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1NlbGVjdGlvblN0YXJ0O1xuICB9XG59KTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5JVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGhpZGRlbiB0ZXh0YXJlYSAobmVlZGVkIHRvIGJyaW5nIHVwIGtleWJvYXJkIGluIGlPUylcbiAgICovXG4gIGluaXRIaWRkZW5UZXh0YXJlYTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYSA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdhdXRvY2FwaXRhbGl6ZScsICdvZmYnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXV0b2NvcnJlY3QnLCAnb2ZmJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2F1dG9jb21wbGV0ZScsICdvZmYnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnc3BlbGxjaGVjaycsICdmYWxzZScpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdkYXRhLWZhYnJpYy1oaWRkZW50ZXh0YXJlYScsICcnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnd3JhcCcsICdvZmYnKTtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLl9jYWxjVGV4dGFyZWFQb3NpdGlvbigpO1xuICAgIC8vIGxpbmUtaGVpZ2h0OiAxcHg7IHdhcyByZW1vdmVkIGZyb20gdGhlIHN0eWxlIHRvIGZpeCB0aGlzOlxuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTg3MDk2NlxuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogJyArIHN0eWxlLnRvcCArXG4gICAgJzsgbGVmdDogJyArIHN0eWxlLmxlZnQgKyAnOyB6LWluZGV4OiAtOTk5OyBvcGFjaXR5OiAwOyB3aWR0aDogMXB4OyBoZWlnaHQ6IDFweDsgZm9udC1zaXplOiAxcHg7JyArXG4gICAgJyBwYWRkaW5nLXRvcDogJyArIHN0eWxlLmZvbnRTaXplICsgJzsnO1xuXG4gICAgaWYgKHRoaXMuaGlkZGVuVGV4dGFyZWFDb250YWluZXIpIHtcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWFDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5oaWRkZW5UZXh0YXJlYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmFicmljLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5oaWRkZW5UZXh0YXJlYSk7XG4gICAgfVxuXG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAna2V5dXAnLCB0aGlzLm9uS2V5VXAuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2lucHV0JywgdGhpcy5vbklucHV0LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb3B5JywgdGhpcy5jb3B5LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjdXQnLCB0aGlzLmNvcHkuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ3Bhc3RlJywgdGhpcy5wYXN0ZS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY29tcG9zaXRpb25zdGFydCcsIHRoaXMub25Db21wb3NpdGlvblN0YXJ0LmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb21wb3NpdGlvbnVwZGF0ZScsIHRoaXMub25Db21wb3NpdGlvblVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnY29tcG9zaXRpb25lbmQnLCB0aGlzLm9uQ29tcG9zaXRpb25FbmQuYmluZCh0aGlzKSk7XG5cbiAgICBpZiAoIXRoaXMuX2NsaWNrSGFuZGxlckluaXRpYWxpemVkICYmIHRoaXMuY2FudmFzKSB7XG4gICAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmNhbnZhcy51cHBlckNhbnZhc0VsLCAnY2xpY2snLCB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl9jbGlja0hhbmRsZXJJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBGb3IgZnVuY3Rpb25hbGl0aWVzIG9uIGtleURvd25cbiAgICogTWFwIGEgc3BlY2lhbCBrZXkgdG8gYSBmdW5jdGlvbiBvZiB0aGUgaW5zdGFuY2UvcHJvdG90eXBlXG4gICAqIElmIHlvdSBuZWVkIGRpZmZlcmVudCBiZWhhdmlvdXIgZm9yIEVTQyBvciBUQUIgb3IgYXJyb3dzLCB5b3UgaGF2ZSB0byBjaGFuZ2VcbiAgICogdGhpcyBtYXAgc2V0dGluZyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIHRoYXQgeW91IGJ1aWxkIG9uIHRoZSBmYWJyaWMuSXRleHQgb3JcbiAgICogeW91ciBwcm90b3R5cGUuXG4gICAqIHRoZSBtYXAgY2hhbmdlIHdpbGwgYWZmZWN0IGFsbCBJbnN0YW5jZXMgdW5sZXNzIHlvdSBuZWVkIGZvciBvbmx5IHNvbWUgdGV4dCBJbnN0YW5jZXNcbiAgICogaW4gdGhhdCBjYXNlIHlvdSBoYXZlIHRvIGNsb25lIHRoaXMgb2JqZWN0IGFuZCBhc3NpZ24geW91ciBJbnN0YW5jZS5cbiAgICogdGhpcy5rZXlzTWFwID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKHRoaXMua2V5c01hcCk7XG4gICAqIFRoZSBmdW5jdGlvbiBtdXN0IGJlIGluIGZhYnJpYy5JdGV4dC5wcm90b3R5cGUubXlGdW5jdGlvbiBBbmQgd2lsbCByZWNlaXZlIGV2ZW50IGFzIGFyZ3NbMF1cbiAgICovXG4gIGtleXNNYXA6IHtcbiAgICA5OiAgJ2V4aXRFZGl0aW5nJyxcbiAgICAyNzogJ2V4aXRFZGl0aW5nJyxcbiAgICAzMzogJ21vdmVDdXJzb3JVcCcsXG4gICAgMzQ6ICdtb3ZlQ3Vyc29yRG93bicsXG4gICAgMzU6ICdtb3ZlQ3Vyc29yUmlnaHQnLFxuICAgIDM2OiAnbW92ZUN1cnNvckxlZnQnLFxuICAgIDM3OiAnbW92ZUN1cnNvckxlZnQnLFxuICAgIDM4OiAnbW92ZUN1cnNvclVwJyxcbiAgICAzOTogJ21vdmVDdXJzb3JSaWdodCcsXG4gICAgNDA6ICdtb3ZlQ3Vyc29yRG93bicsXG4gIH0sXG5cbiAga2V5c01hcFJ0bDoge1xuICAgIDk6ICAnZXhpdEVkaXRpbmcnLFxuICAgIDI3OiAnZXhpdEVkaXRpbmcnLFxuICAgIDMzOiAnbW92ZUN1cnNvclVwJyxcbiAgICAzNDogJ21vdmVDdXJzb3JEb3duJyxcbiAgICAzNTogJ21vdmVDdXJzb3JMZWZ0JyxcbiAgICAzNjogJ21vdmVDdXJzb3JSaWdodCcsXG4gICAgMzc6ICdtb3ZlQ3Vyc29yUmlnaHQnLFxuICAgIDM4OiAnbW92ZUN1cnNvclVwJyxcbiAgICAzOTogJ21vdmVDdXJzb3JMZWZ0JyxcbiAgICA0MDogJ21vdmVDdXJzb3JEb3duJyxcbiAgfSxcblxuICAvKipcbiAgICogRm9yIGZ1bmN0aW9uYWxpdGllcyBvbiBrZXlVcCArIGN0cmwgfHwgY21kXG4gICAqL1xuICBjdHJsS2V5c01hcFVwOiB7XG4gICAgNjc6ICdjb3B5JyxcbiAgICA4ODogJ2N1dCdcbiAgfSxcblxuICAvKipcbiAgICogRm9yIGZ1bmN0aW9uYWxpdGllcyBvbiBrZXlEb3duICsgY3RybCB8fCBjbWRcbiAgICovXG4gIGN0cmxLZXlzTWFwRG93bjoge1xuICAgIDY1OiAnc2VsZWN0QWxsJ1xuICB9LFxuXG4gIG9uQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgIC8vIE5vIG5lZWQgdG8gdHJpZ2dlciBjbGljayBldmVudCBoZXJlLCBmb2N1cyBpcyBlbm91Z2ggdG8gaGF2ZSB0aGUga2V5Ym9hcmQgYXBwZWFyIG9uIEFuZHJvaWRcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhICYmIHRoaXMuaGlkZGVuVGV4dGFyZWEuZm9jdXMoKTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyBrZXlkb3duIGV2ZW50XG4gICAqIG9ubHkgdXNlZCBmb3IgYXJyb3dzIGFuZCBjb21iaW5hdGlvbiBvZiBtb2RpZmllciBrZXlzLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgb25LZXlEb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIga2V5TWFwID0gdGhpcy5kaXJlY3Rpb24gPT09ICdydGwnID8gdGhpcy5rZXlzTWFwUnRsIDogdGhpcy5rZXlzTWFwO1xuICAgIGlmIChlLmtleUNvZGUgaW4ga2V5TWFwKSB7XG4gICAgICB0aGlzW2tleU1hcFtlLmtleUNvZGVdXShlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGUua2V5Q29kZSBpbiB0aGlzLmN0cmxLZXlzTWFwRG93bikgJiYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpKSB7XG4gICAgICB0aGlzW3RoaXMuY3RybEtleXNNYXBEb3duW2Uua2V5Q29kZV1dKGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKGUua2V5Q29kZSA+PSAzMyAmJiBlLmtleUNvZGUgPD0gNDApIHtcbiAgICAgIC8vIGlmIGkgcHJlc3MgYW4gYXJyb3cga2V5IGp1c3QgdXBkYXRlIHNlbGVjdGlvblxuICAgICAgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA9IGZhbHNlO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleXVwIGV2ZW50XG4gICAqIFdlIGhhbmRsZSBLZXlVcCBiZWNhdXNlIGllMTEgYW5kIGVkZ2UgaGF2ZSBkaWZmaWN1bHRpZXMgY29weS9wYXN0aW5nXG4gICAqIGlmIGEgY29weS9jdXQgZXZlbnQgZmlyZWQsIGtleXVwIGlzIGRpc21pc3NlZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgb25LZXlVcDogZnVuY3Rpb24oZSkge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgdGhpcy5fY29weURvbmUgfHwgdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgdGhpcy5fY29weURvbmUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChlLmtleUNvZGUgaW4gdGhpcy5jdHJsS2V5c01hcFVwKSAmJiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkpIHtcbiAgICAgIHRoaXNbdGhpcy5jdHJsS2V5c01hcFVwW2Uua2V5Q29kZV1dKGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIG9uSW5wdXQgZXZlbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG9uSW5wdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZnJvbVBhc3RlID0gdGhpcy5mcm9tUGFzdGU7XG4gICAgdGhpcy5mcm9tUGFzdGUgPSBmYWxzZTtcbiAgICBlICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBkZWNpc2lvbnMgYWJvdXQgc3R5bGUgY2hhbmdlcy5cbiAgICB2YXIgbmV4dFRleHQgPSB0aGlzLl9zcGxpdFRleHRJbnRvTGluZXModGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSkuZ3JhcGhlbWVUZXh0LFxuICAgICAgICBjaGFyQ291bnQgPSB0aGlzLl90ZXh0Lmxlbmd0aCxcbiAgICAgICAgbmV4dENoYXJDb3VudCA9IG5leHRUZXh0Lmxlbmd0aCxcbiAgICAgICAgcmVtb3ZlZFRleHQsIGluc2VydGVkVGV4dCxcbiAgICAgICAgY2hhckRpZmYgPSBuZXh0Q2hhckNvdW50IC0gY2hhckNvdW50LFxuICAgICAgICBzZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kLFxuICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kLFxuICAgICAgICBjb3BpZWRTdHlsZSwgcmVtb3ZlRnJvbSwgcmVtb3ZlVG87XG4gICAgaWYgKHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWUgPT09ICcnKSB7XG4gICAgICB0aGlzLnN0eWxlcyA9IHsgfTtcbiAgICAgIHRoaXMudXBkYXRlRnJvbVRleHRBcmVhKCk7XG4gICAgICB0aGlzLmZpcmUoJ2NoYW5nZWQnKTtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0ZXh0YXJlYVNlbGVjdGlvbiA9IHRoaXMuZnJvbVN0cmluZ1RvR3JhcGhlbWVTZWxlY3Rpb24oXG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQsXG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlXG4gICAgKTtcbiAgICB2YXIgYmFja0RlbGV0ZSA9IHNlbGVjdGlvblN0YXJ0ID4gdGV4dGFyZWFTZWxlY3Rpb24uc2VsZWN0aW9uU3RhcnQ7XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICByZW1vdmVkVGV4dCA9IHRoaXMuX3RleHQuc2xpY2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICBjaGFyRGlmZiArPSBzZWxlY3Rpb25FbmQgLSBzZWxlY3Rpb25TdGFydDtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV4dENoYXJDb3VudCA8IGNoYXJDb3VudCkge1xuICAgICAgaWYgKGJhY2tEZWxldGUpIHtcbiAgICAgICAgcmVtb3ZlZFRleHQgPSB0aGlzLl90ZXh0LnNsaWNlKHNlbGVjdGlvbkVuZCArIGNoYXJEaWZmLCBzZWxlY3Rpb25FbmQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZWRUZXh0ID0gdGhpcy5fdGV4dC5zbGljZShzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uU3RhcnQgLSBjaGFyRGlmZik7XG4gICAgICB9XG4gICAgfVxuICAgIGluc2VydGVkVGV4dCA9IG5leHRUZXh0LnNsaWNlKHRleHRhcmVhU2VsZWN0aW9uLnNlbGVjdGlvbkVuZCAtIGNoYXJEaWZmLCB0ZXh0YXJlYVNlbGVjdGlvbi5zZWxlY3Rpb25FbmQpO1xuICAgIGlmIChyZW1vdmVkVGV4dCAmJiByZW1vdmVkVGV4dC5sZW5ndGgpIHtcbiAgICAgIGlmIChpbnNlcnRlZFRleHQubGVuZ3RoKSB7XG4gICAgICAgIC8vIGxldCdzIGNvcHkgc29tZSBzdHlsZSBiZWZvcmUgZGVsZXRpbmcuXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gY29weSB0aGUgc3R5bGUgYmVmb3JlIHRoZSBjdXJzb3IgT1IgdGhlIHN0eWxlIGF0IHRoZSBjdXJzb3IgaWYgc2VsZWN0aW9uXG4gICAgICAgIC8vIGlzIGJpZ2dlciB0aGFuIDAuXG4gICAgICAgIGNvcGllZFN0eWxlID0gdGhpcy5nZXRTZWxlY3Rpb25TdHlsZXMoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvblN0YXJ0ICsgMSwgZmFsc2UpO1xuICAgICAgICAvLyBub3cgZHVwbGljYXRlIHRoZSBzdHlsZSBvbmUgZm9yIGVhY2ggaW5zZXJ0ZWQgdGV4dC5cbiAgICAgICAgY29waWVkU3R5bGUgPSBpbnNlcnRlZFRleHQubWFwKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIHRoaXMgcmV0dXJuIGFuIGFycmF5IG9mIHJlZmVyZW5jZXMsIGJ1dCB0aGF0IGlzIGZpbmUgc2luY2Ugd2UgYXJlXG4gICAgICAgICAgLy8gY29weWluZyB0aGUgc3R5bGUgbGF0ZXIuXG4gICAgICAgICAgcmV0dXJuIGNvcGllZFN0eWxlWzBdO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVtb3ZlRnJvbSA9IHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICByZW1vdmVUbyA9IHNlbGVjdGlvbkVuZDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJhY2tEZWxldGUpIHtcbiAgICAgICAgLy8gZGV0ZWN0IGRpZmZlcmVuY2VzIGJldHdlZW4gZm9yd2FyZERlbGV0ZSBhbmQgYmFja0RlbGV0ZVxuICAgICAgICByZW1vdmVGcm9tID0gc2VsZWN0aW9uRW5kIC0gcmVtb3ZlZFRleHQubGVuZ3RoO1xuICAgICAgICByZW1vdmVUbyA9IHNlbGVjdGlvbkVuZDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZW1vdmVGcm9tID0gc2VsZWN0aW9uRW5kO1xuICAgICAgICByZW1vdmVUbyA9IHNlbGVjdGlvbkVuZCArIHJlbW92ZWRUZXh0Lmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8ocmVtb3ZlRnJvbSwgcmVtb3ZlVG8pO1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWRUZXh0Lmxlbmd0aCkge1xuICAgICAgaWYgKGZyb21QYXN0ZSAmJiBpbnNlcnRlZFRleHQuam9pbignJykgPT09IGZhYnJpYy5jb3BpZWRUZXh0ICYmICFmYWJyaWMuZGlzYWJsZVN0eWxlQ29weVBhc3RlKSB7XG4gICAgICAgIGNvcGllZFN0eWxlID0gZmFicmljLmNvcGllZFRleHRTdHlsZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5zZXJ0TmV3U3R5bGVCbG9jayhpbnNlcnRlZFRleHQsIHNlbGVjdGlvblN0YXJ0LCBjb3BpZWRTdHlsZSk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlRnJvbVRleHRBcmVhKCk7XG4gICAgdGhpcy5maXJlKCdjaGFuZ2VkJyk7XG4gICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5maXJlKCd0ZXh0OmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBDb21wb3NpdGlvbiBzdGFydFxuICAgKi9cbiAgb25Db21wb3NpdGlvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ29tcG9zaXRpb24gZW5kXG4gICAqL1xuICBvbkNvbXBvc2l0aW9uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gZmFsc2U7XG4gIH0sXG5cbiAgLy8gLyoqXG4gIC8vICAqIENvbXBvc2l0aW9uIHVwZGF0ZVxuICAvLyAgKi9cbiAgb25Db21wb3NpdGlvblVwZGF0ZTogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuY29tcG9zaXRpb25TdGFydCA9IGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0O1xuICAgIHRoaXMuY29tcG9zaXRpb25FbmQgPSBlLnRhcmdldC5zZWxlY3Rpb25FbmQ7XG4gICAgdGhpcy51cGRhdGVUZXh0YXJlYVBvc2l0aW9uKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvcGllcyBzZWxlY3RlZCB0ZXh0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIC8vZG8gbm90IGN1dC1jb3B5IGlmIG5vIHNlbGVjdGlvblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZhYnJpYy5jb3BpZWRUZXh0ID0gdGhpcy5nZXRTZWxlY3RlZFRleHQoKTtcbiAgICBpZiAoIWZhYnJpYy5kaXNhYmxlU3R5bGVDb3B5UGFzdGUpIHtcbiAgICAgIGZhYnJpYy5jb3BpZWRUZXh0U3R5bGUgPSB0aGlzLmdldFNlbGVjdGlvblN0eWxlcyh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZmFicmljLmNvcGllZFRleHRTdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX2NvcHlEb25lID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUGFzdGVzIHRleHRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIHBhc3RlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZyb21QYXN0ZSA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqIEByZXR1cm4ge09iamVjdH0gQ2xpcGJvYXJkIGRhdGEgb2JqZWN0XG4gICAqL1xuICBfZ2V0Q2xpcGJvYXJkRGF0YTogZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiAoZSAmJiBlLmNsaXBib2FyZERhdGEpIHx8IGZhYnJpYy53aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgdGhlIHdpZHRoIGluIHBpeGVscyBiZWZvcmUgdGhlIGN1cnNvciBvbiB0aGUgc2FtZSBsaW5lXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHdpZHRoQmVmb3JlQ3Vyc29yIHdpZHRoIGJlZm9yZSBjdXJzb3JcbiAgICovXG4gIF9nZXRXaWR0aEJlZm9yZUN1cnNvcjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICB2YXIgd2lkdGhCZWZvcmVDdXJzb3IgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lSW5kZXgpLCBib3VuZDtcblxuICAgIGlmIChjaGFySW5kZXggPiAwKSB7XG4gICAgICBib3VuZCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bY2hhckluZGV4IC0gMV07XG4gICAgICB3aWR0aEJlZm9yZUN1cnNvciArPSBib3VuZC5sZWZ0ICsgYm91bmQud2lkdGg7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aEJlZm9yZUN1cnNvcjtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyBzdGFydCBvZmZzZXQgb2YgYSBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1JpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldERvd25DdXJzb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICB2YXIgc2VsZWN0aW9uUHJvcCA9IHRoaXMuX2dldFNlbGVjdGlvbkZvck9mZnNldChlLCBpc1JpZ2h0KSxcbiAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uUHJvcCksXG4gICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleDtcbiAgICAvLyBpZiBvbiBsYXN0IGxpbmUsIGRvd24gY3Vyc29yIGdvZXMgdG8gZW5kIG9mIGxpbmVcbiAgICBpZiAobGluZUluZGV4ID09PSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoIC0gMSB8fCBlLm1ldGFLZXkgfHwgZS5rZXlDb2RlID09PSAzNCkge1xuICAgICAgLy8gbW92ZSB0byB0aGUgZW5kIG9mIGEgdGV4dFxuICAgICAgcmV0dXJuIHRoaXMuX3RleHQubGVuZ3RoIC0gc2VsZWN0aW9uUHJvcDtcbiAgICB9XG4gICAgdmFyIGNoYXJJbmRleCA9IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCxcbiAgICAgICAgd2lkdGhCZWZvcmVDdXJzb3IgPSB0aGlzLl9nZXRXaWR0aEJlZm9yZUN1cnNvcihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgIGluZGV4T25PdGhlckxpbmUgPSB0aGlzLl9nZXRJbmRleE9uTGluZShsaW5lSW5kZXggKyAxLCB3aWR0aEJlZm9yZUN1cnNvciksXG4gICAgICAgIHRleHRBZnRlckN1cnNvciA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLnNsaWNlKGNoYXJJbmRleCk7XG4gICAgcmV0dXJuIHRleHRBZnRlckN1cnNvci5sZW5ndGggKyBpbmRleE9uT3RoZXJMaW5lICsgMSArIHRoaXMubWlzc2luZ05ld2xpbmVPZmZzZXQobGluZUluZGV4KTtcbiAgfSxcblxuICAvKipcbiAgICogcHJpdmF0ZVxuICAgKiBIZWxwcyBmaW5kaW5nIGlmIHRoZSBvZmZzZXQgc2hvdWxkIGJlIGNvdW50ZWQgZnJvbSBTdGFydCBvciBFbmRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1JpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIF9nZXRTZWxlY3Rpb25Gb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICBpZiAoZS5zaGlmdEtleSAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCAmJiBpc1JpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0VXBDdXJzb3JPZmZzZXQ6IGZ1bmN0aW9uKGUsIGlzUmlnaHQpIHtcbiAgICB2YXIgc2VsZWN0aW9uUHJvcCA9IHRoaXMuX2dldFNlbGVjdGlvbkZvck9mZnNldChlLCBpc1JpZ2h0KSxcbiAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc2VsZWN0aW9uUHJvcCksXG4gICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleDtcbiAgICBpZiAobGluZUluZGV4ID09PSAwIHx8IGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDMzKSB7XG4gICAgICAvLyBpZiBvbiBmaXJzdCBsaW5lLCB1cCBjdXJzb3IgZ29lcyB0byBzdGFydCBvZiBsaW5lXG4gICAgICByZXR1cm4gLXNlbGVjdGlvblByb3A7XG4gICAgfVxuICAgIHZhciBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXgsXG4gICAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yID0gdGhpcy5fZ2V0V2lkdGhCZWZvcmVDdXJzb3IobGluZUluZGV4LCBjaGFySW5kZXgpLFxuICAgICAgICBpbmRleE9uT3RoZXJMaW5lID0gdGhpcy5fZ2V0SW5kZXhPbkxpbmUobGluZUluZGV4IC0gMSwgd2lkdGhCZWZvcmVDdXJzb3IpLFxuICAgICAgICB0ZXh0QmVmb3JlQ3Vyc29yID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0uc2xpY2UoMCwgY2hhckluZGV4KSxcbiAgICAgICAgbWlzc2luZ05ld2xpbmVPZmZzZXQgPSB0aGlzLm1pc3NpbmdOZXdsaW5lT2Zmc2V0KGxpbmVJbmRleCAtIDEpO1xuICAgIC8vIHJldHVybiBhIG5lZ2F0aXZlIG9mZnNldFxuICAgIHJldHVybiAtdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleCAtIDFdLmxlbmd0aFxuICAgICArIGluZGV4T25PdGhlckxpbmUgLSB0ZXh0QmVmb3JlQ3Vyc29yLmxlbmd0aCArICgxIC0gbWlzc2luZ05ld2xpbmVPZmZzZXQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmb3IgYSBnaXZlbiB3aWR0aCBpdCBmb3VuZHMgdGhlIG1hdGNoaW5nIGNoYXJhY3Rlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRJbmRleE9uTGluZTogZnVuY3Rpb24obGluZUluZGV4LCB3aWR0aCkge1xuXG4gICAgdmFyIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lSW5kZXgpLFxuICAgICAgICB3aWR0aE9mQ2hhcnNPbkxpbmUgPSBsaW5lTGVmdE9mZnNldCxcbiAgICAgICAgaW5kZXhPbkxpbmUgPSAwLCBjaGFyV2lkdGgsIGZvdW5kTWF0Y2g7XG5cbiAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICBjaGFyV2lkdGggPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2pdLndpZHRoO1xuICAgICAgd2lkdGhPZkNoYXJzT25MaW5lICs9IGNoYXJXaWR0aDtcbiAgICAgIGlmICh3aWR0aE9mQ2hhcnNPbkxpbmUgPiB3aWR0aCkge1xuICAgICAgICBmb3VuZE1hdGNoID0gdHJ1ZTtcbiAgICAgICAgdmFyIGxlZnRFZGdlID0gd2lkdGhPZkNoYXJzT25MaW5lIC0gY2hhcldpZHRoLFxuICAgICAgICAgICAgcmlnaHRFZGdlID0gd2lkdGhPZkNoYXJzT25MaW5lLFxuICAgICAgICAgICAgb2Zmc2V0RnJvbUxlZnRFZGdlID0gTWF0aC5hYnMobGVmdEVkZ2UgLSB3aWR0aCksXG4gICAgICAgICAgICBvZmZzZXRGcm9tUmlnaHRFZGdlID0gTWF0aC5hYnMocmlnaHRFZGdlIC0gd2lkdGgpO1xuXG4gICAgICAgIGluZGV4T25MaW5lID0gb2Zmc2V0RnJvbVJpZ2h0RWRnZSA8IG9mZnNldEZyb21MZWZ0RWRnZSA/IGogOiAoaiAtIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZWFjaGVkIGVuZFxuICAgIGlmICghZm91bmRNYXRjaCkge1xuICAgICAgaW5kZXhPbkxpbmUgPSBsaW5lLmxlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4T25MaW5lO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciBkb3duXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yRG93bjogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID49IHRoaXMuX3RleHQubGVuZ3RoICYmIHRoaXMuc2VsZWN0aW9uRW5kID49IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3JVcE9yRG93bignRG93bicsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgdXBcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JVcDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSAwICYmIHRoaXMuc2VsZWN0aW9uRW5kID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3JVcE9yRG93bignVXAnLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHVwIG9yIGRvd24sIGZpcmVzIHRoZSBldmVudHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiAnVXAnIG9yICdEb3duJ1xuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgX21vdmVDdXJzb3JVcE9yRG93bjogZnVuY3Rpb24oZGlyZWN0aW9uLCBlKSB7XG4gICAgLy8gZ2V0VXBDdXJzb3JPZmZzZXRcbiAgICAvLyBnZXREb3duQ3Vyc29yT2Zmc2V0XG4gICAgdmFyIGFjdGlvbiA9ICdnZXQnICsgZGlyZWN0aW9uICsgJ0N1cnNvck9mZnNldCcsXG4gICAgICAgIG9mZnNldCA9IHRoaXNbYWN0aW9uXShlLCB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdyaWdodCcpO1xuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLm1vdmVDdXJzb3JXaXRoU2hpZnQob2Zmc2V0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLm1vdmVDdXJzb3JXaXRob3V0U2hpZnQob2Zmc2V0KTtcbiAgICB9XG4gICAgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25JbkJvdW5kYXJpZXMoKTtcbiAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMTtcbiAgICAgIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHdpdGggc2hpZnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgbW92ZUN1cnNvcldpdGhTaGlmdDogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ2xlZnQnXG4gICAgICA/IHRoaXMuc2VsZWN0aW9uU3RhcnQgKyBvZmZzZXRcbiAgICAgIDogdGhpcy5zZWxlY3Rpb25FbmQgKyBvZmZzZXQ7XG4gICAgdGhpcy5zZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdCh0aGlzLnNlbGVjdGlvblN0YXJ0LCB0aGlzLnNlbGVjdGlvbkVuZCwgbmV3U2VsZWN0aW9uKTtcbiAgICByZXR1cm4gb2Zmc2V0ICE9PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgdXAgd2l0aG91dCBzaGlmdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBtb3ZlQ3Vyc29yV2l0aG91dFNoaWZ0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCArPSBvZmZzZXQ7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgKz0gb2Zmc2V0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0ICE9PSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgbGVmdFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvckxlZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gMCAmJiB0aGlzLnNlbGVjdGlvbkVuZCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQoJ0xlZnQnLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBhIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgX21vdmU6IGZ1bmN0aW9uKGUsIHByb3AsIGRpcmVjdGlvbikge1xuICAgIHZhciBuZXdWYWx1ZTtcbiAgICBpZiAoZS5hbHRLZXkpIHtcbiAgICAgIG5ld1ZhbHVlID0gdGhpc1snZmluZFdvcmRCb3VuZGFyeScgKyBkaXJlY3Rpb25dKHRoaXNbcHJvcF0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChlLm1ldGFLZXkgfHwgZS5rZXlDb2RlID09PSAzNSB8fCAgZS5rZXlDb2RlID09PSAzNiApIHtcbiAgICAgIG5ld1ZhbHVlID0gdGhpc1snZmluZExpbmVCb3VuZGFyeScgKyBkaXJlY3Rpb25dKHRoaXNbcHJvcF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXNbcHJvcF0gKz0gZGlyZWN0aW9uID09PSAnTGVmdCcgPyAtMSA6IDE7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpc1twcm9wXSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgIHRoaXNbcHJvcF0gPSBuZXdWYWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb3ZlTGVmdDogZnVuY3Rpb24oZSwgcHJvcCkge1xuICAgIHJldHVybiB0aGlzLl9tb3ZlKGUsIHByb3AsICdMZWZ0Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbW92ZVJpZ2h0OiBmdW5jdGlvbihlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vdmUoZSwgcHJvcCwgJ1JpZ2h0Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciBsZWZ0IHdpdGhvdXQga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgbW92ZUN1cnNvckxlZnRXaXRob3V0U2hpZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY2hhbmdlID0gdHJ1ZTtcbiAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAnbGVmdCc7XG5cbiAgICAvLyBvbmx5IG1vdmUgY3Vyc29yIHdoZW4gdGhlcmUgaXMgbm8gc2VsZWN0aW9uLFxuICAgIC8vIG90aGVyd2lzZSB3ZSBkaXNjYXJkIGl0LCBhbmQgbGVhdmUgY3Vyc29yIG9uIHNhbWUgcGxhY2VcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25FbmQgPT09IHRoaXMuc2VsZWN0aW9uU3RhcnQgJiYgdGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gMCkge1xuICAgICAgY2hhbmdlID0gdGhpcy5fbW92ZUxlZnQoZSwgJ3NlbGVjdGlvblN0YXJ0Jyk7XG5cbiAgICB9XG4gICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIHJldHVybiBjaGFuZ2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciBsZWZ0IHdoaWxlIGtlZXBpbmcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIG1vdmVDdXJzb3JMZWZ0V2l0aFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmVMZWZ0KGUsICdzZWxlY3Rpb25FbmQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gMCl7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZUxlZnQoZSwgJ3NlbGVjdGlvblN0YXJ0Jyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JSaWdodDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID49IHRoaXMuX3RleHQubGVuZ3RoICYmIHRoaXMuc2VsZWN0aW9uRW5kID49IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3JMZWZ0T3JSaWdodCgnUmlnaHQnLCBlKTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0IG9yIExlZnQsIGZpcmVzIGV2ZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gJ0xlZnQnLCAnUmlnaHQnXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBfbW92ZUN1cnNvckxlZnRPclJpZ2h0OiBmdW5jdGlvbihkaXJlY3Rpb24sIGUpIHtcbiAgICB2YXIgYWN0aW9uTmFtZSA9ICdtb3ZlQ3Vyc29yJyArIGRpcmVjdGlvbiArICdXaXRoJztcbiAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDE7XG5cbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgYWN0aW9uTmFtZSArPSAnU2hpZnQnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFjdGlvbk5hbWUgKz0gJ291dFNoaWZ0JztcbiAgICB9XG4gICAgaWYgKHRoaXNbYWN0aW9uTmFtZV0oZSkpIHtcbiAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIHJpZ2h0IHdoaWxlIGtlZXBpbmcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIG1vdmVDdXJzb3JSaWdodFdpdGhTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdsZWZ0JyAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmVSaWdodChlLCAnc2VsZWN0aW9uU3RhcnQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25FbmQgIT09IHRoaXMuX3RleHQubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAncmlnaHQnO1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmVSaWdodChlLCAnc2VsZWN0aW9uRW5kJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHQgd2l0aG91dCBrZWVwaW5nIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvclJpZ2h0V2l0aG91dFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG5cbiAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCA9PT0gdGhpcy5zZWxlY3Rpb25FbmQpIHtcbiAgICAgIGNoYW5nZWQgPSB0aGlzLl9tb3ZlUmlnaHQoZSwgJ3NlbGVjdGlvblN0YXJ0Jyk7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uRW5kO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBjaGFyYWN0ZXJzIGZyb20gc3RhcnQvZW5kXG4gICAqIHN0YXJ0L2VuZCBhciBwZXIgZ3JhcGhlbWUgcG9zaXRpb24gaW4gX3RleHQgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIGRlZmF1bHQgdG8gc3RhcnQgKyAxXG4gICAqL1xuICByZW1vdmVDaGFyczogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZW5kID0gc3RhcnQgKyAxO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZVN0eWxlRnJvbVRvKHN0YXJ0LCBlbmQpO1xuICAgIHRoaXMuX3RleHQuc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG4gICAgdGhpcy50ZXh0ID0gdGhpcy5fdGV4dC5qb2luKCcnKTtcbiAgICB0aGlzLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIH1cbiAgICB0aGlzLl9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGluc2VydCBjaGFyYWN0ZXJzIGF0IHN0YXJ0IHBvc2l0aW9uLCBiZWZvcmUgc3RhcnQgcG9zaXRpb24uXG4gICAqIHN0YXJ0ICBlcXVhbCAxIGl0IG1lYW5zIHRoZSB0ZXh0IGdldCBpbnNlcnRlZCBiZXR3ZWVuIGFjdHVhbCBncmFwaGVtZSAwIGFuZCAxXG4gICAqIGlmIHN0eWxlIGFycmF5IGlzIHByb3ZpZGVkLCBpdCBtdXN0IGJlIGFzIHRoZSBzYW1lIGxlbmd0aCBvZiB0ZXh0IGluIGdyYXBoZW1lc1xuICAgKiBpZiBlbmQgaXMgcHJvdmlkZWQgYW5kIGlzIGJpZ2dlciB0aGFuIHN0YXJ0LCBvbGQgdGV4dCBpcyByZXBsYWNlZC5cbiAgICogc3RhcnQvZW5kIGFyIHBlciBncmFwaGVtZSBwb3NpdGlvbiBpbiBfdGV4dCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGV4dCB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtBcnJheX0gc3R5bGUgYXJyYXkgb2Ygc3R5bGUgb2JqZWN0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBkZWZhdWx0IHRvIHN0YXJ0ICsgMVxuICAgKi9cbiAgaW5zZXJ0Q2hhcnM6IGZ1bmN0aW9uKHRleHQsIHN0eWxlLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG4gICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICB0aGlzLnJlbW92ZVN0eWxlRnJvbVRvKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICB2YXIgZ3JhcGhlbWVzID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQodGV4dCk7XG4gICAgdGhpcy5pbnNlcnROZXdTdHlsZUJsb2NrKGdyYXBoZW1lcywgc3RhcnQsIHN0eWxlKTtcbiAgICB0aGlzLl90ZXh0ID0gW10uY29uY2F0KHRoaXMuX3RleHQuc2xpY2UoMCwgc3RhcnQpLCBncmFwaGVtZXMsIHRoaXMuX3RleHQuc2xpY2UoZW5kKSk7XG4gICAgdGhpcy50ZXh0ID0gdGhpcy5fdGV4dC5qb2luKCcnKTtcbiAgICB0aGlzLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICB0aGlzLmluaXREaW1lbnNpb25zKCk7XG4gICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgIH1cbiAgICB0aGlzLl9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzKCk7XG4gIH0sXG5cbn0pO1xuXG5cbi8qIF9UT19TVkdfU1RBUlRfICovXG4oZnVuY3Rpb24oKSB7XG4gIHZhciB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIG11bHRpcGxlU3BhY2VzUmVnZXggPSAvICArL2c7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlRleHQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2Zmc2V0cyA9IHRoaXMuX2dldFNWR0xlZnRUb3BPZmZzZXRzKCksXG4gICAgICAgICAgdGV4dEFuZEJnID0gdGhpcy5fZ2V0U1ZHVGV4dEFuZEJnKG9mZnNldHMudGV4dFRvcCwgb2Zmc2V0cy50ZXh0TGVmdCk7XG4gICAgICByZXR1cm4gdGhpcy5fd3JhcFNWR1RleHRBbmRCZyh0ZXh0QW5kQmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAoXG4gICAgICAgIHRoaXMuX3RvU1ZHKCksXG4gICAgICAgIHsgcmV2aXZlcjogcmV2aXZlciwgbm9TdHlsZTogdHJ1ZSwgd2l0aFNoYWRvdzogdHJ1ZSB9XG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTVkdMZWZ0VG9wT2Zmc2V0czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0TGVmdDogLXRoaXMud2lkdGggLyAyLFxuICAgICAgICB0ZXh0VG9wOiAtdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICBsaW5lVG9wOiB0aGlzLmdldEhlaWdodE9mTGluZSgwKVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfd3JhcFNWR1RleHRBbmRCZzogZnVuY3Rpb24odGV4dEFuZEJnKSB7XG4gICAgICB2YXIgbm9TaGFkb3cgPSB0cnVlLFxuICAgICAgICAgIHRleHREZWNvcmF0aW9uID0gdGhpcy5nZXRTdmdUZXh0RGVjb3JhdGlvbih0aGlzKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRleHRBbmRCZy50ZXh0QmdSZWN0cy5qb2luKCcnKSxcbiAgICAgICAgJ1xcdFxcdDx0ZXh0IHhtbDpzcGFjZT1cInByZXNlcnZlXCIgJyxcbiAgICAgICAgKHRoaXMuZm9udEZhbWlseSA/ICdmb250LWZhbWlseT1cIicgKyB0aGlzLmZvbnRGYW1pbHkucmVwbGFjZSgvXCIvZywgJ1xcJycpICsgJ1wiICcgOiAnJyksXG4gICAgICAgICh0aGlzLmZvbnRTaXplID8gJ2ZvbnQtc2l6ZT1cIicgKyB0aGlzLmZvbnRTaXplICsgJ1wiICcgOiAnJyksXG4gICAgICAgICh0aGlzLmZvbnRTdHlsZSA/ICdmb250LXN0eWxlPVwiJyArIHRoaXMuZm9udFN0eWxlICsgJ1wiICcgOiAnJyksXG4gICAgICAgICh0aGlzLmZvbnRXZWlnaHQgPyAnZm9udC13ZWlnaHQ9XCInICsgdGhpcy5mb250V2VpZ2h0ICsgJ1wiICcgOiAnJyksXG4gICAgICAgICh0ZXh0RGVjb3JhdGlvbiA/ICd0ZXh0LWRlY29yYXRpb249XCInICsgdGV4dERlY29yYXRpb24gKyAnXCIgJyA6ICcnKSxcbiAgICAgICAgJ3N0eWxlPVwiJywgdGhpcy5nZXRTdmdTdHlsZXMobm9TaGFkb3cpLCAnXCInLCB0aGlzLmFkZFBhaW50T3JkZXIoKSwgJyA+JyxcbiAgICAgICAgdGV4dEFuZEJnLnRleHRTcGFucy5qb2luKCcnKSxcbiAgICAgICAgJzwvdGV4dD5cXG4nXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0ZXh0VG9wT2Zmc2V0IFRleHQgdG9wIG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0ZXh0TGVmdE9mZnNldCBUZXh0IGxlZnQgb2Zmc2V0XG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIF9nZXRTVkdUZXh0QW5kQmc6IGZ1bmN0aW9uKHRleHRUb3BPZmZzZXQsIHRleHRMZWZ0T2Zmc2V0KSB7XG4gICAgICB2YXIgdGV4dFNwYW5zID0gW10sXG4gICAgICAgICAgdGV4dEJnUmVjdHMgPSBbXSxcbiAgICAgICAgICBoZWlnaHQgPSB0ZXh0VG9wT2Zmc2V0LCBsaW5lT2Zmc2V0O1xuICAgICAgLy8gYm91bmRpbmctYm94IGJhY2tncm91bmRcbiAgICAgIHRoaXMuX3NldFNWR0JnKHRleHRCZ1JlY3RzKTtcblxuICAgICAgLy8gdGV4dCBhbmQgdGV4dC1iYWNrZ3JvdW5kXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpbmVPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChpKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dEJhY2tncm91bmRDb2xvciB8fCB0aGlzLnN0eWxlSGFzKCd0ZXh0QmFja2dyb3VuZENvbG9yJywgaSkpIHtcbiAgICAgICAgICB0aGlzLl9zZXRTVkdUZXh0TGluZUJnKHRleHRCZ1JlY3RzLCBpLCB0ZXh0TGVmdE9mZnNldCArIGxpbmVPZmZzZXQsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0U1ZHVGV4dExpbmVUZXh0KHRleHRTcGFucywgaSwgdGV4dExlZnRPZmZzZXQgKyBsaW5lT2Zmc2V0LCBoZWlnaHQpO1xuICAgICAgICBoZWlnaHQgKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHRTcGFuczogdGV4dFNwYW5zLFxuICAgICAgICB0ZXh0QmdSZWN0czogdGV4dEJnUmVjdHNcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVRleHRDaGFyU3BhbjogZnVuY3Rpb24oX2NoYXIsIHN0eWxlRGVjbCwgbGVmdCwgdG9wKSB7XG4gICAgICB2YXIgc2hvdWxkVXNlV2hpdGVzcGFjZSA9IF9jaGFyICE9PSBfY2hhci50cmltKCkgfHwgX2NoYXIubWF0Y2gobXVsdGlwbGVTcGFjZXNSZWdleCksXG4gICAgICAgICAgc3R5bGVQcm9wcyA9IHRoaXMuZ2V0U3ZnU3BhblN0eWxlcyhzdHlsZURlY2wsIHNob3VsZFVzZVdoaXRlc3BhY2UpLFxuICAgICAgICAgIGZpbGxTdHlsZXMgPSBzdHlsZVByb3BzID8gJ3N0eWxlPVwiJyArIHN0eWxlUHJvcHMgKyAnXCInIDogJycsXG4gICAgICAgICAgZHkgPSBzdHlsZURlY2wuZGVsdGFZLCBkeVNwYW4gPSAnJyxcbiAgICAgICAgICBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuICAgICAgaWYgKGR5KSB7XG4gICAgICAgIGR5U3BhbiA9ICcgZHk9XCInICsgdG9GaXhlZChkeSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnXCIgJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8dHNwYW4geD1cIicsIHRvRml4ZWQobGVmdCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksICdcIiB5PVwiJyxcbiAgICAgICAgdG9GaXhlZCh0b3AsIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnXCIgJywgZHlTcGFuLFxuICAgICAgICBmaWxsU3R5bGVzLCAnPicsXG4gICAgICAgIGZhYnJpYy51dGlsLnN0cmluZy5lc2NhcGVYbWwoX2NoYXIpLFxuICAgICAgICAnPC90c3Bhbj4nXG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBfc2V0U1ZHVGV4dExpbmVUZXh0OiBmdW5jdGlvbih0ZXh0U3BhbnMsIGxpbmVJbmRleCwgdGV4dExlZnRPZmZzZXQsIHRleHRUb3BPZmZzZXQpIHtcbiAgICAgIC8vIHNldCBwcm9wZXIgbGluZSBvZmZzZXRcbiAgICAgIHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUobGluZUluZGV4KSxcbiAgICAgICAgICBpc0p1c3RpZnkgPSB0aGlzLnRleHRBbGlnbi5pbmRleE9mKCdqdXN0aWZ5JykgIT09IC0xLFxuICAgICAgICAgIGFjdHVhbFN0eWxlLFxuICAgICAgICAgIG5leHRTdHlsZSxcbiAgICAgICAgICBjaGFyc1RvUmVuZGVyID0gJycsXG4gICAgICAgICAgY2hhckJveCwgc3R5bGUsXG4gICAgICAgICAgYm94V2lkdGggPSAwLFxuICAgICAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgICB0aW1lVG9SZW5kZXI7XG5cbiAgICAgIHRleHRUb3BPZmZzZXQgKz0gbGluZUhlaWdodCAqICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgLyB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZS5sZW5ndGggLSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIHRpbWVUb1JlbmRlciA9IGkgPT09IGxlbiB8fCB0aGlzLmNoYXJTcGFjaW5nO1xuICAgICAgICBjaGFyc1RvUmVuZGVyICs9IGxpbmVbaV07XG4gICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdW2ldO1xuICAgICAgICBpZiAoYm94V2lkdGggPT09IDApIHtcbiAgICAgICAgICB0ZXh0TGVmdE9mZnNldCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoIC0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94LndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSnVzdGlmeSAmJiAhdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdChsaW5lW2ldKSkge1xuICAgICAgICAgICAgdGltZVRvUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGNoYXJTcGFjaW5nLCB3ZSByZW5kZXIgY2hhciBieSBjaGFyXG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBhY3R1YWxTdHlsZSB8fCB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkpO1xuICAgICAgICAgIG5leHRTdHlsZSA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSArIDEpO1xuICAgICAgICAgIHRpbWVUb1JlbmRlciA9IGZhYnJpYy51dGlsLmhhc1N0eWxlQ2hhbmdlZChhY3R1YWxTdHlsZSwgbmV4dFN0eWxlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgc3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSkgfHwgeyB9O1xuICAgICAgICAgIHRleHRTcGFucy5wdXNoKHRoaXMuX2NyZWF0ZVRleHRDaGFyU3BhbihjaGFyc1RvUmVuZGVyLCBzdHlsZSwgdGV4dExlZnRPZmZzZXQsIHRleHRUb3BPZmZzZXQpKTtcbiAgICAgICAgICBjaGFyc1RvUmVuZGVyID0gJyc7XG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBuZXh0U3R5bGU7XG4gICAgICAgICAgdGV4dExlZnRPZmZzZXQgKz0gYm94V2lkdGg7XG4gICAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9wdXNoVGV4dEJnUmVjdDogZnVuY3Rpb24odGV4dEJnUmVjdHMsIGNvbG9yLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuICAgICAgdGV4dEJnUmVjdHMucHVzaChcbiAgICAgICAgJ1xcdFxcdDxyZWN0ICcsXG4gICAgICAgIHRoaXMuX2dldEZpbGxBdHRyaWJ1dGVzKGNvbG9yKSxcbiAgICAgICAgJyB4PVwiJyxcbiAgICAgICAgdG9GaXhlZChsZWZ0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiIHk9XCInLFxuICAgICAgICB0b0ZpeGVkKHRvcCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIiB3aWR0aD1cIicsXG4gICAgICAgIHRvRml4ZWQod2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCIgaGVpZ2h0PVwiJyxcbiAgICAgICAgdG9GaXhlZChoZWlnaHQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCI+PC9yZWN0PlxcbicpO1xuICAgIH0sXG5cbiAgICBfc2V0U1ZHVGV4dExpbmVCZzogZnVuY3Rpb24odGV4dEJnUmVjdHMsIGksIGxlZnRPZmZzZXQsIHRleHRUb3BPZmZzZXQpIHtcbiAgICAgIHZhciBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldLFxuICAgICAgICAgIGhlaWdodE9mTGluZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpIC8gdGhpcy5saW5lSGVpZ2h0LFxuICAgICAgICAgIGJveFdpZHRoID0gMCxcbiAgICAgICAgICBib3hTdGFydCA9IDAsXG4gICAgICAgICAgY2hhckJveCwgY3VycmVudENvbG9yLFxuICAgICAgICAgIGxhc3RDb2xvciA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ3RleHRCYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgY2hhckJveCA9IHRoaXMuX19jaGFyQm91bmRzW2ldW2pdO1xuICAgICAgICBjdXJyZW50Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICAgIGlmIChjdXJyZW50Q29sb3IgIT09IGxhc3RDb2xvcikge1xuICAgICAgICAgIGxhc3RDb2xvciAmJiB0aGlzLl9wdXNoVGV4dEJnUmVjdCh0ZXh0QmdSZWN0cywgbGFzdENvbG9yLCBsZWZ0T2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICB0ZXh0VG9wT2Zmc2V0LCBib3hXaWR0aCwgaGVpZ2h0T2ZMaW5lKTtcbiAgICAgICAgICBib3hTdGFydCA9IGNoYXJCb3gubGVmdDtcbiAgICAgICAgICBib3hXaWR0aCA9IGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgbGFzdENvbG9yID0gY3VycmVudENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnJlbnRDb2xvciAmJiB0aGlzLl9wdXNoVGV4dEJnUmVjdCh0ZXh0QmdSZWN0cywgY3VycmVudENvbG9yLCBsZWZ0T2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgIHRleHRUb3BPZmZzZXQsIGJveFdpZHRoLCBoZWlnaHRPZkxpbmUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZG9iZSBJbGx1c3RyYXRvciAoYXQgbGVhc3QgQ1M1KSBpcyB1bmFibGUgdG8gcmVuZGVyIHJnYmEoKS1iYXNlZCBmaWxsIHZhbHVlc1xuICAgICAqIHdlIHdvcmsgYXJvdW5kIGl0IGJ5IFwibW92aW5nXCIgYWxwaGEgY2hhbm5lbCBpbnRvIG9wYWNpdHkgYXR0cmlidXRlIGFuZCBzZXR0aW5nIGZpbGwncyBhbHBoYSB0byAxXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgX2dldEZpbGxBdHRyaWJ1dGVzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZpbGxDb2xvciA9ICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSA/IG5ldyBmYWJyaWMuQ29sb3IodmFsdWUpIDogJyc7XG4gICAgICBpZiAoIWZpbGxDb2xvciB8fCAhZmlsbENvbG9yLmdldFNvdXJjZSgpIHx8IGZpbGxDb2xvci5nZXRBbHBoYSgpID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnZmlsbD1cIicgKyB2YWx1ZSArICdcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ29wYWNpdHk9XCInICsgZmlsbENvbG9yLmdldEFscGhhKCkgKyAnXCIgZmlsbD1cIicgKyBmaWxsQ29sb3Iuc2V0QWxwaGEoMSkudG9SZ2IoKSArICdcIic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFNWR0xpbmVUb3BPZmZzZXQ6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgdmFyIGxpbmVUb3BPZmZzZXQgPSAwLCBsYXN0SGVpZ2h0ID0gMDtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZUluZGV4OyBqKyspIHtcbiAgICAgICAgbGluZVRvcE9mZnNldCArPSB0aGlzLmdldEhlaWdodE9mTGluZShqKTtcbiAgICAgIH1cbiAgICAgIGxhc3RIZWlnaHQgPSB0aGlzLmdldEhlaWdodE9mTGluZShqKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVUb3A6IGxpbmVUb3BPZmZzZXQsXG4gICAgICAgIG9mZnNldDogKHRoaXMuX2ZvbnRTaXplTXVsdCAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pICogbGFzdEhlaWdodCAvICh0aGlzLmxpbmVIZWlnaHQgKiB0aGlzLl9mb250U2l6ZU11bHQpXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0eWxlcy1zdHJpbmcgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBTaGFkb3cgYSBib29sZWFuIHRvIHNraXAgc2hhZG93IGZpbHRlciBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnU3R5bGVzOiBmdW5jdGlvbihza2lwU2hhZG93KSB7XG4gICAgICB2YXIgc3ZnU3R5bGUgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5nZXRTdmdTdHlsZXMuY2FsbCh0aGlzLCBza2lwU2hhZG93KTtcbiAgICAgIHJldHVybiBzdmdTdHlsZSArICcgd2hpdGUtc3BhY2U6IHByZTsnO1xuICAgIH0sXG4gIH0pO1xufSkoKTtcbi8qIF9UT19TVkdfRU5EXyAqL1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7fSk7XG5cbiAgLyoqXG4gICAqIFRleHRib3ggY2xhc3MsIGJhc2VkIG9uIElUZXh0LCBhbGxvd3MgdGhlIHVzZXIgdG8gcmVzaXplIHRoZSB0ZXh0IHJlY3RhbmdsZVxuICAgKiBhbmQgd3JhcHMgbGluZXMgYXV0b21hdGljYWxseS4gVGV4dGJveGVzIGhhdmUgdGhlaXIgWSBzY2FsaW5nIGxvY2tlZCwgdGhlXG4gICAqIHVzZXIgY2FuIG9ubHkgY2hhbmdlIHdpZHRoLiBIZWlnaHQgaXMgYWRqdXN0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiB0aGVcbiAgICogd3JhcHBpbmcgb2YgbGluZXMuXG4gICAqIEBjbGFzcyBmYWJyaWMuVGV4dGJveFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSVRleHRcbiAgICogQG1peGVzIGZhYnJpYy5PYnNlcnZhYmxlXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0Ym94fSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UZXh0Ym94I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuVGV4dGJveCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5JVGV4dCwgZmFicmljLk9ic2VydmFibGUsIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAndGV4dGJveCcsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIHdpZHRoIG9mIHRleHRib3gsIGluIHBpeGVscy5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1pbldpZHRoOiAyMCxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gY2FsY3VsYXRlZCB3aWR0aCBvZiBhIHRleHRib3gsIGluIHBpeGVscy5cbiAgICAgKiBmaXhlZCB0byAyIHNvIHRoYXQgYW4gZW1wdHkgdGV4dGJveCBjYW5ub3QgZ28gdG8gMFxuICAgICAqIGFuZCBpcyBzdGlsbCBzZWxlY3RhYmxlIHdpdGhvdXQgdGV4dC5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGR5bmFtaWNNaW5XaWR0aDogMixcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBhcnJheSBvZiB0ZXh0IHdyYXBwaW5nLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgX19jYWNoZWRMaW5lczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHN0YW5kYXJkIE9iamVjdCBjbGFzcyB2YWx1ZXNcbiAgICAgKi9cbiAgICBsb2NrU2NhbGluZ0ZsaXA6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBzdGFuZGFyZCBPYmplY3QgY2xhc3MgdmFsdWVzXG4gICAgICogVGV4dGJveCBuZWVkcyB0aGlzIG9uIGZhbHNlXG4gICAgICovXG4gICAgbm9TY2FsZUNhY2hlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgd2hpY2ggd2hlbiBzZXQgY2F1c2Ugb2JqZWN0IHRvIGNoYW5nZSBkaW1lbnNpb25zXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGltZW5zaW9uQWZmZWN0aW5nUHJvcHM6IGZhYnJpYy5UZXh0LnByb3RvdHlwZS5fZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMuY29uY2F0KCd3aWR0aCcpLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIHNwbGl0IHN0cmluZ3MgaW4gYnJlYWthYmxlIGxpbmVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfd29yZEpvaW5lcnM6IC9bIFxcdFxccl0vLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgYm9vbGVhbiBwcm9wZXJ0eSBpbiBvcmRlciB0byBzcGxpdCBzdHJpbmdzIHRoYXQgaGF2ZSBubyB3aGl0ZSBzcGFjZSBjb25jZXB0LlxuICAgICAqIHRoaXMgaXMgYSBjaGVhcCB3YXkgdG8gaGVscCB3aXRoIGNoaW5lc2UvamFwYW5lc2VcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDIuNi4wXG4gICAgICovXG4gICAgc3BsaXRCeUdyYXBoZW1lOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFVubGlrZSBzdXBlcmNsYXNzJ3MgdmVyc2lvbiBvZiB0aGlzIGZ1bmN0aW9uLCBUZXh0Ym94IGRvZXMgbm90IHVwZGF0ZVxuICAgICAqIGl0cyB3aWR0aC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGluaXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9fc2tpcERpbWVuc2lvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmlzRWRpdGluZyAmJiB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dFRvcCgpO1xuICAgICAgdGhpcy5fY2xlYXJDYWNoZSgpO1xuICAgICAgLy8gY2xlYXIgZHluYW1pY01pbldpZHRoIGFzIGl0IHdpbGwgYmUgZGlmZmVyZW50IGFmdGVyIHdlIHJlLXdyYXAgbGluZVxuICAgICAgdGhpcy5keW5hbWljTWluV2lkdGggPSAwO1xuICAgICAgLy8gd3JhcCBsaW5lc1xuICAgICAgdGhpcy5fc3R5bGVNYXAgPSB0aGlzLl9nZW5lcmF0ZVN0eWxlTWFwKHRoaXMuX3NwbGl0VGV4dCgpKTtcbiAgICAgIC8vIGlmIGFmdGVyIHdyYXBwaW5nLCB0aGUgd2lkdGggaXMgc21hbGxlciB0aGFuIGR5bmFtaWNNaW5XaWR0aCwgY2hhbmdlIHRoZSB3aWR0aCBhbmQgcmUtd3JhcFxuICAgICAgaWYgKHRoaXMuZHluYW1pY01pbldpZHRoID4gdGhpcy53aWR0aCkge1xuICAgICAgICB0aGlzLl9zZXQoJ3dpZHRoJywgdGhpcy5keW5hbWljTWluV2lkdGgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dEFsaWduLmluZGV4T2YoJ2p1c3RpZnknKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gb25jZSB0ZXh0IGlzIG1lYXN1cmVkIHdlIG5lZWQgdG8gbWFrZSBzcGFjZSBmYXR0ZXIgdG8gbWFrZSBqdXN0aWZpZWQgdGV4dC5cbiAgICAgICAgdGhpcy5lbmxhcmdlU3BhY2VzKCk7XG4gICAgICB9XG4gICAgICAvLyBjbGVhciBjYWNoZSBhbmQgcmUtY2FsY3VsYXRlIGhlaWdodFxuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbGNUZXh0SGVpZ2h0KCk7XG4gICAgICB0aGlzLnNhdmVTdGF0ZSh7IHByb3BlcnR5U2V0OiAnX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzJyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gb2JqZWN0IHRoYXQgdHJhbnNsYXRlcyB0aGUgc3R5bGUgb2JqZWN0IHNvIHRoYXQgaXQgaXNcbiAgICAgKiBicm9rZW4gdXAgYnkgdmlzdWFsIGxpbmVzIChuZXcgbGluZXMgYW5kIGF1dG9tYXRpYyB3cmFwcGluZykuXG4gICAgICogVGhlIG9yaWdpbmFsIHRleHQgc3R5bGVzIG9iamVjdCBpcyBicm9rZW4gdXAgYnkgYWN0dWFsIGxpbmVzIChuZXcgbGluZXMgb25seSksXG4gICAgICogd2hpY2ggaXMgb25seSBzdWZmaWNpZW50IGZvciBUZXh0IC8gSVRleHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZW5lcmF0ZVN0eWxlTWFwOiBmdW5jdGlvbih0ZXh0SW5mbykge1xuICAgICAgdmFyIHJlYWxMaW5lQ291bnQgICAgID0gMCxcbiAgICAgICAgICByZWFsTGluZUNoYXJDb3VudCA9IDAsXG4gICAgICAgICAgY2hhckNvdW50ICAgICAgICAgPSAwLFxuICAgICAgICAgIG1hcCAgICAgICAgICAgICAgID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dEluZm8uZ3JhcGhlbWVMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGV4dEluZm8uZ3JhcGhlbWVUZXh0W2NoYXJDb3VudF0gPT09ICdcXG4nICYmIGkgPiAwKSB7XG4gICAgICAgICAgcmVhbExpbmVDaGFyQ291bnQgPSAwO1xuICAgICAgICAgIGNoYXJDb3VudCsrO1xuICAgICAgICAgIHJlYWxMaW5lQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5zcGxpdEJ5R3JhcGhlbWUgJiYgdGhpcy5fcmVTcGFjZUFuZFRhYi50ZXN0KHRleHRJbmZvLmdyYXBoZW1lVGV4dFtjaGFyQ291bnRdKSAmJiBpID4gMCkge1xuICAgICAgICAgIC8vIHRoaXMgY2FzZSBkZWFscyB3aXRoIHNwYWNlJ3MgdGhhdCBhcmUgcmVtb3ZlZCBmcm9tIGVuZCBvZiBsaW5lcyB3aGVuIHdyYXBwaW5nXG4gICAgICAgICAgcmVhbExpbmVDaGFyQ291bnQrKztcbiAgICAgICAgICBjaGFyQ291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcFtpXSA9IHsgbGluZTogcmVhbExpbmVDb3VudCwgb2Zmc2V0OiByZWFsTGluZUNoYXJDb3VudCB9O1xuXG4gICAgICAgIGNoYXJDb3VudCArPSB0ZXh0SW5mby5ncmFwaGVtZUxpbmVzW2ldLmxlbmd0aDtcbiAgICAgICAgcmVhbExpbmVDaGFyQ291bnQgKz0gdGV4dEluZm8uZ3JhcGhlbWVMaW5lc1tpXS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaGFzIGEgc3R5bGUgcHJvcGVydHkgb3IgaGFzIGl0IG9uIGEgc3BlY2lmaWVkIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzdHlsZUhhczogZnVuY3Rpb24ocHJvcGVydHksIGxpbmVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX3N0eWxlTWFwICYmICF0aGlzLmlzV3JhcHBpbmcpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5UZXh0LnByb3RvdHlwZS5zdHlsZUhhcy5jYWxsKHRoaXMsIHByb3BlcnR5LCBsaW5lSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBubyBzdHlsaW5nIG9yIG5vIHN0eWxpbmcgaW4gYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCAsIGxpbmVJbmRleCBpcyBvbiB3cmFwcGVkIGxpbmVzLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IDAsIG5leHRMaW5lSW5kZXggPSBsaW5lSW5kZXggKyAxLCBuZXh0T2Zmc2V0LCBvYmosIHNob3VsZExpbWl0ID0gZmFsc2UsXG4gICAgICAgICAgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XSwgbWFwTmV4dExpbmUgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXggKyAxXTtcbiAgICAgIGlmIChtYXApIHtcbiAgICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICAgIG9mZnNldCA9IG1hcC5vZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAobWFwTmV4dExpbmUpIHtcbiAgICAgICAgbmV4dExpbmVJbmRleCA9IG1hcE5leHRMaW5lLmxpbmU7XG4gICAgICAgIHNob3VsZExpbWl0ID0gbmV4dExpbmVJbmRleCA9PT0gbGluZUluZGV4O1xuICAgICAgICBuZXh0T2Zmc2V0ID0gbWFwTmV4dExpbmUub2Zmc2V0O1xuICAgICAgfVxuICAgICAgb2JqID0gdHlwZW9mIGxpbmVJbmRleCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnN0eWxlcyA6IHsgbGluZTogdGhpcy5zdHlsZXNbbGluZUluZGV4XSB9O1xuICAgICAgZm9yICh2YXIgcDEgaW4gb2JqKSB7XG4gICAgICAgIGZvciAodmFyIHAyIGluIG9ialtwMV0pIHtcbiAgICAgICAgICBpZiAocDIgPj0gb2Zmc2V0ICYmICghc2hvdWxkTGltaXQgfHwgcDIgPCBuZXh0T2Zmc2V0KSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgICBmb3IgKHZhciBwMyBpbiBvYmpbcDFdW3AyXSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX3N0eWxlTWFwICYmICF0aGlzLmlzV3JhcHBpbmcpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICAgIGNoYXJJbmRleCA9IG1hcC5vZmZzZXQgKyBjaGFySW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ19nZXRTdHlsZURlY2xhcmF0aW9uJywgbGluZUluZGV4LCBjaGFySW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBzdHlsZSkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgIGNoYXJJbmRleCA9IG1hcC5vZmZzZXQgKyBjaGFySW5kZXg7XG5cbiAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4XSA9IHN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RlbGV0ZVN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgY2hhckluZGV4ID0gbWFwLm9mZnNldCArIGNoYXJJbmRleDtcbiAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHByb2JhYmx5IGJyb2tlbiBuZWVkIGEgZml4XG4gICAgICogUmV0dXJucyB0aGUgcmVhbCBzdHlsZSBsaW5lIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgd3JhcHBlZCBsaW5lSW5kZXggbGluZVxuICAgICAqIFVzZWQganVzdCB0byB2ZXJpZnkgaWYgdGhlIGxpbmUgZG9lcyBleGlzdCBvciBub3QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBpZiB0aGUgbGluZSBleGlzdHMgb3Igbm90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgcmV0dXJuICEhdGhpcy5zdHlsZXNbbWFwLmxpbmVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxpbmUgc3R5bGUgdG8gYW4gZW1wdHkgb2JqZWN0IHNvIHRoYXQgaXMgaW5pdGlhbGl6ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgdGhpcy5zdHlsZXNbbWFwLmxpbmVdID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdyYXBzIHRleHQgdXNpbmcgdGhlICd3aWR0aCcgcHJvcGVydHkgb2YgVGV4dGJveC4gRmlyc3QgdGhpcyBmdW5jdGlvblxuICAgICAqIHNwbGl0cyB0ZXh0IG9uIG5ld2xpbmVzLCBzbyB3ZSBwcmVzZXJ2ZSBuZXdsaW5lcyBlbnRlcmVkIGJ5IHRoZSB1c2VyLlxuICAgICAqIFRoZW4gaXQgd3JhcHMgZWFjaCBsaW5lIHVzaW5nIHRoZSB3aWR0aCBvZiB0aGUgVGV4dGJveCBieSBjYWxsaW5nXG4gICAgICogX3dyYXBMaW5lKCkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGluZXMgVGhlIHN0cmluZyBhcnJheSBvZiB0ZXh0IHRoYXQgaXMgc3BsaXQgaW50byBsaW5lc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXNpcmVkV2lkdGggd2lkdGggeW91IHdhbnQgdG8gd3JhcCB0b1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgbGluZXNcbiAgICAgKi9cbiAgICBfd3JhcFRleHQ6IGZ1bmN0aW9uKGxpbmVzLCBkZXNpcmVkV2lkdGgpIHtcbiAgICAgIHZhciB3cmFwcGVkID0gW10sIGk7XG4gICAgICB0aGlzLmlzV3JhcHBpbmcgPSB0cnVlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdyYXBwZWQgPSB3cmFwcGVkLmNvbmNhdCh0aGlzLl93cmFwTGluZShsaW5lc1tpXSwgaSwgZGVzaXJlZFdpZHRoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmlzV3JhcHBpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB3cmFwcGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gbWVhc3VyZSBhIHN0cmluZyBvZiB0ZXh0LCBnaXZlbiBpdHMgbGluZUluZGV4IGFuZCBjaGFySW5kZXggb2Zmc2V0XG4gICAgICogaXQgZ2V0cyBjYWxsZWQgd2hlbiBjaGFyQm91bmRzIGFyZSBub3QgYXZhaWxhYmxlIHlldC5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNoYXJPZmZzZXRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21lYXN1cmVXb3JkOiBmdW5jdGlvbih3b3JkLCBsaW5lSW5kZXgsIGNoYXJPZmZzZXQpIHtcbiAgICAgIHZhciB3aWR0aCA9IDAsIHByZXZHcmFwaGVtZSwgc2tpcExlZnQgPSB0cnVlO1xuICAgICAgY2hhck9mZnNldCA9IGNoYXJPZmZzZXQgfHwgMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB3b3JkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBib3ggPSB0aGlzLl9nZXRHcmFwaGVtZUJveCh3b3JkW2ldLCBsaW5lSW5kZXgsIGkgKyBjaGFyT2Zmc2V0LCBwcmV2R3JhcGhlbWUsIHNraXBMZWZ0KTtcbiAgICAgICAgd2lkdGggKz0gYm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICBwcmV2R3JhcGhlbWUgPSB3b3JkW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyBhIGxpbmUgb2YgdGV4dCB1c2luZyB0aGUgd2lkdGggb2YgdGhlIFRleHRib3ggYW5kIGEgY29udGV4dC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lIFRoZSBncmFwaGVtZSBhcnJheSB0aGF0IHJlcHJlc2VudCB0aGUgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzaXJlZFdpZHRoIHdpZHRoIHlvdSB3YW50IHRvIHdyYXAgdGhlIGxpbmUgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVzZXJ2ZWRTcGFjZSBzcGFjZSB0byByZW1vdmUgZnJvbSB3cmFwcGluZyBmb3IgY3VzdG9tIGZ1bmN0aW9uYWxpdGllc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgbGluZShzKSBpbnRvIHdoaWNoIHRoZSBnaXZlbiB0ZXh0IGlzIHdyYXBwZWRcbiAgICAgKiB0by5cbiAgICAgKi9cbiAgICBfd3JhcExpbmU6IGZ1bmN0aW9uKF9saW5lLCBsaW5lSW5kZXgsIGRlc2lyZWRXaWR0aCwgcmVzZXJ2ZWRTcGFjZSkge1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IDAsXG4gICAgICAgICAgc3BsaXRCeUdyYXBoZW1lID0gdGhpcy5zcGxpdEJ5R3JhcGhlbWUsXG4gICAgICAgICAgZ3JhcGhlbWVMaW5lcyA9IFtdLFxuICAgICAgICAgIGxpbmUgPSBbXSxcbiAgICAgICAgICAvLyBzcGFjZXMgaW4gZGlmZmVyZW50IGxhbmd1YWdlcz9cbiAgICAgICAgICB3b3JkcyA9IHNwbGl0QnlHcmFwaGVtZSA/IGZhYnJpYy51dGlsLnN0cmluZy5ncmFwaGVtZVNwbGl0KF9saW5lKSA6IF9saW5lLnNwbGl0KHRoaXMuX3dvcmRKb2luZXJzKSxcbiAgICAgICAgICB3b3JkID0gJycsXG4gICAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgICBpbmZpeCA9IHNwbGl0QnlHcmFwaGVtZSA/ICcnIDogJyAnLFxuICAgICAgICAgIHdvcmRXaWR0aCA9IDAsXG4gICAgICAgICAgaW5maXhXaWR0aCA9IDAsXG4gICAgICAgICAgbGFyZ2VzdFdvcmRXaWR0aCA9IDAsXG4gICAgICAgICAgbGluZUp1c3RTdGFydGVkID0gdHJ1ZSxcbiAgICAgICAgICBhZGRpdGlvbmFsU3BhY2UgPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKSxcbiAgICAgICAgICByZXNlcnZlZFNwYWNlID0gcmVzZXJ2ZWRTcGFjZSB8fCAwO1xuICAgICAgLy8gZml4IGEgZGlmZmVyZW5jZSBiZXR3ZWVuIHNwbGl0IGFuZCBncmFwaGVtZVNwbGl0XG4gICAgICBpZiAod29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHdvcmRzLnB1c2goW10pO1xuICAgICAgfVxuICAgICAgZGVzaXJlZFdpZHRoIC09IHJlc2VydmVkU3BhY2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGlmIHVzaW5nIHNwbGl0QnlHcmFwaGVtZSB3b3JkcyBhcmUgYWxyZWFkeSBpbiBncmFwaGVtZXMuXG4gICAgICAgIHdvcmQgPSBzcGxpdEJ5R3JhcGhlbWUgPyB3b3Jkc1tpXSA6IGZhYnJpYy51dGlsLnN0cmluZy5ncmFwaGVtZVNwbGl0KHdvcmRzW2ldKTtcbiAgICAgICAgd29yZFdpZHRoID0gdGhpcy5fbWVhc3VyZVdvcmQod29yZCwgbGluZUluZGV4LCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gd29yZC5sZW5ndGg7XG5cbiAgICAgICAgbGluZVdpZHRoICs9IGluZml4V2lkdGggKyB3b3JkV2lkdGggLSBhZGRpdGlvbmFsU3BhY2U7XG4gICAgICAgIGlmIChsaW5lV2lkdGggPiBkZXNpcmVkV2lkdGggJiYgIWxpbmVKdXN0U3RhcnRlZCkge1xuICAgICAgICAgIGdyYXBoZW1lTGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgICBsaW5lID0gW107XG4gICAgICAgICAgbGluZVdpZHRoID0gd29yZFdpZHRoO1xuICAgICAgICAgIGxpbmVKdXN0U3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbGluZVdpZHRoICs9IGFkZGl0aW9uYWxTcGFjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbGluZUp1c3RTdGFydGVkICYmICFzcGxpdEJ5R3JhcGhlbWUpIHtcbiAgICAgICAgICBsaW5lLnB1c2goaW5maXgpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSBsaW5lLmNvbmNhdCh3b3JkKTtcblxuICAgICAgICBpbmZpeFdpZHRoID0gc3BsaXRCeUdyYXBoZW1lID8gMCA6IHRoaXMuX21lYXN1cmVXb3JkKFtpbmZpeF0sIGxpbmVJbmRleCwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGxpbmVKdXN0U3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIGxhcmdlc3Qgd29yZFxuICAgICAgICBpZiAod29yZFdpZHRoID4gbGFyZ2VzdFdvcmRXaWR0aCkge1xuICAgICAgICAgIGxhcmdlc3RXb3JkV2lkdGggPSB3b3JkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaSAmJiBncmFwaGVtZUxpbmVzLnB1c2gobGluZSk7XG5cbiAgICAgIGlmIChsYXJnZXN0V29yZFdpZHRoICsgcmVzZXJ2ZWRTcGFjZSA+IHRoaXMuZHluYW1pY01pbldpZHRoKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY01pbldpZHRoID0gbGFyZ2VzdFdvcmRXaWR0aCAtIGFkZGl0aW9uYWxTcGFjZSArIHJlc2VydmVkU3BhY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JhcGhlbWVMaW5lcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIHRoZSB0ZXh0IGxpbmUgaXMgZW5kZWQgd2l0aCBhbiBoYXJkIGJyZWFrXG4gICAgICogdGV4dCBhbmQgaXRleHQgZG8gbm90IGhhdmUgd3JhcHBpbmcsIHJldHVybiBmYWxzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggdGV4dCB0byBzcGxpdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbmRPZldyYXBwaW5nOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4ICsgMV0pIHtcbiAgICAgICAgLy8gaXMgbGFzdCBsaW5lLCByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc3R5bGVNYXBbbGluZUluZGV4ICsgMV0ubGluZSAhPT0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XS5saW5lKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgbGFzdCBsaW5lIGJlZm9yZSBhIGxpbmUgYnJlYWssIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGEgbGluZSBoYXMgYSBsaW5lYnJlYWsgYW5kIHNvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgaXQgd2hlbiBtb3ZpbmdcbiAgICAgKiBhbmQgY291bnRpbmcgc3R5bGUuXG4gICAgICogQHJldHVybiBOdW1iZXJcbiAgICAgKi9cbiAgICBtaXNzaW5nTmV3bGluZU9mZnNldDogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAodGhpcy5zcGxpdEJ5R3JhcGhlbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFbmRPZldyYXBwaW5nKGxpbmVJbmRleCkgPyAxIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIEdldHMgbGluZXMgb2YgdGV4dCB0byByZW5kZXIgaW4gdGhlIFRleHRib3guIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlc1xuICAgICogdGV4dCB3cmFwcGluZyBvbiB0aGUgZmx5IGV2ZXJ5IHRpbWUgaXQgaXMgY2FsbGVkLlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGV4dCB0byBzcGxpdFxuICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBsaW5lcyBpbiB0aGUgVGV4dGJveC5cbiAgICAqIEBvdmVycmlkZVxuICAgICovXG4gICAgX3NwbGl0VGV4dEludG9MaW5lczogZnVuY3Rpb24odGV4dCkge1xuICAgICAgdmFyIG5ld1RleHQgPSBmYWJyaWMuVGV4dC5wcm90b3R5cGUuX3NwbGl0VGV4dEludG9MaW5lcy5jYWxsKHRoaXMsIHRleHQpLFxuICAgICAgICAgIGdyYXBoZW1lTGluZXMgPSB0aGlzLl93cmFwVGV4dChuZXdUZXh0LmxpbmVzLCB0aGlzLndpZHRoKSxcbiAgICAgICAgICBsaW5lcyA9IG5ldyBBcnJheShncmFwaGVtZUxpbmVzLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoZW1lTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGluZXNbaV0gPSBncmFwaGVtZUxpbmVzW2ldLmpvaW4oJycpO1xuICAgICAgfVxuICAgICAgbmV3VGV4dC5saW5lcyA9IGxpbmVzO1xuICAgICAgbmV3VGV4dC5ncmFwaGVtZUxpbmVzID0gZ3JhcGhlbWVMaW5lcztcbiAgICAgIHJldHVybiBuZXdUZXh0O1xuICAgIH0sXG5cbiAgICBnZXRNaW5XaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5taW5XaWR0aCwgdGhpcy5keW5hbWljTWluV2lkdGgpO1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlRXh0cmFuZW91c1N0eWxlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZXNUb0tlZXAgPSB7fTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5fc3R5bGVNYXApIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHRMaW5lc1twcm9wXSkge1xuICAgICAgICAgIGxpbmVzVG9LZWVwW3RoaXMuX3N0eWxlTWFwW3Byb3BdLmxpbmVdID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLnN0eWxlcykge1xuICAgICAgICBpZiAoIWxpbmVzVG9LZWVwW3Byb3BdKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQG1ldGhvZCB0b09iamVjdFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgWydtaW5XaWR0aCcsICdzcGxpdEJ5R3JhcGhlbWUnXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlRleHRib3ggaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRib3hcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuVGV4dGJveCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuVGV4dGJveC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBzdHlsZXMgPSBmYWJyaWMudXRpbC5zdHlsZXNGcm9tQXJyYXkob2JqZWN0LnN0eWxlcywgb2JqZWN0LnRleHQpO1xuICAgIC8vY29weSBvYmplY3QgdG8gcHJldmVudCBtdXRhdGlvblxuICAgIHZhciBvYmpDb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqZWN0LCB7IHN0eWxlczogc3R5bGVzIH0pO1xuICAgIHJldHVybiBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdUZXh0Ym94Jywgb2JqQ29weSwgY2FsbGJhY2ssICd0ZXh0Jyk7XG4gIH07XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBjb250cm9sc1V0aWxzID0gZmFicmljLmNvbnRyb2xzVXRpbHMsXG4gICAgICBzY2FsZVNrZXdTdHlsZUhhbmRsZXIgPSBjb250cm9sc1V0aWxzLnNjYWxlU2tld0N1cnNvclN0eWxlSGFuZGxlcixcbiAgICAgIHNjYWxlU3R5bGVIYW5kbGVyID0gY29udHJvbHNVdGlscy5zY2FsZUN1cnNvclN0eWxlSGFuZGxlcixcbiAgICAgIHNjYWxpbmdFcXVhbGx5ID0gY29udHJvbHNVdGlscy5zY2FsaW5nRXF1YWxseSxcbiAgICAgIHNjYWxpbmdZT3JTa2V3aW5nWCA9IGNvbnRyb2xzVXRpbHMuc2NhbGluZ1lPclNrZXdpbmdYLFxuICAgICAgc2NhbGluZ1hPclNrZXdpbmdZID0gY29udHJvbHNVdGlscy5zY2FsaW5nWE9yU2tld2luZ1ksXG4gICAgICBzY2FsZU9yU2tld0FjdGlvbk5hbWUgPSBjb250cm9sc1V0aWxzLnNjYWxlT3JTa2V3QWN0aW9uTmFtZSxcbiAgICAgIG9iamVjdENvbnRyb2xzID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUuY29udHJvbHM7XG5cbiAgb2JqZWN0Q29udHJvbHMubWwgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IC0wLjUsXG4gICAgeTogMCxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU2tld1N0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nWE9yU2tld2luZ1ksXG4gICAgZ2V0QWN0aW9uTmFtZTogc2NhbGVPclNrZXdBY3Rpb25OYW1lLFxuICB9KTtcblxuICBvYmplY3RDb250cm9scy5tciA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMC41LFxuICAgIHk6IDAsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVNrZXdTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ1hPclNrZXdpbmdZLFxuICAgIGdldEFjdGlvbk5hbWU6IHNjYWxlT3JTa2V3QWN0aW9uTmFtZSxcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMubWIgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IDAsXG4gICAgeTogMC41LFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTa2V3U3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdZT3JTa2V3aW5nWCxcbiAgICBnZXRBY3Rpb25OYW1lOiBzY2FsZU9yU2tld0FjdGlvbk5hbWUsXG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLm10ID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLFxuICAgIHk6IC0wLjUsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVNrZXdTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ1lPclNrZXdpbmdYLFxuICAgIGdldEFjdGlvbk5hbWU6IHNjYWxlT3JTa2V3QWN0aW9uTmFtZSxcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMudGwgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IC0wLjUsXG4gICAgeTogLTAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdFcXVhbGx5XG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLnRyID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLjUsXG4gICAgeTogLTAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdFcXVhbGx5XG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLmJsID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAtMC41LFxuICAgIHk6IDAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdFcXVhbGx5XG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLmJyID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLjUsXG4gICAgeTogMC41LFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ0VxdWFsbHlcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMubXRyID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLFxuICAgIHk6IC0wLjUsXG4gICAgYWN0aW9uSGFuZGxlcjogY29udHJvbHNVdGlscy5yb3RhdGlvbldpdGhTbmFwcGluZyxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IGNvbnRyb2xzVXRpbHMucm90YXRpb25TdHlsZUhhbmRsZXIsXG4gICAgb2Zmc2V0WTogLTQwLFxuICAgIHdpdGhDb25uZWN0aW9uOiB0cnVlLFxuICAgIGFjdGlvbk5hbWU6ICdyb3RhdGUnLFxuICB9KTtcblxuICBpZiAoZmFicmljLlRleHRib3gpIHtcbiAgICAvLyB0aGlzIGlzIGJyZWFraW5nIHRoZSBwcm90b3R5cGUgaW5oZXJpdGFuY2UsIG5vIHRpbWUgLyBpZGVhcyB0byBmaXggaXQuXG4gICAgLy8gaXMgaW1wb3J0YW50IHRvIGRvY3VtZW50IHRoYXQgaWYgeW91IHdhbnQgdG8gaGF2ZSBhbGwgb2JqZWN0cyB0byBoYXZlIGFcbiAgICAvLyBzcGVjaWZpYyBjdXN0b20gY29udHJvbCwgeW91IGhhdmUgdG8gYWRkIGl0IHRvIE9iamVjdCBwcm90b3R5cGUgYW5kIHRvIFRleHRib3hcbiAgICAvLyBwcm90b3R5cGUuIFRoZSBjb250cm9scyBhcmUgc2hhcmVkIGFzIHJlZmVyZW5jZXMuIFNvIGNoYW5nZXMgdG8gY29udHJvbCBgdHJgXG4gICAgLy8gY2FuIHN0aWxsIGFwcGx5IHRvIGFsbCBvYmplY3RzIGlmIG5lZWRlZC5cbiAgICB2YXIgdGV4dEJveENvbnRyb2xzID0gZmFicmljLlRleHRib3gucHJvdG90eXBlLmNvbnRyb2xzID0geyB9O1xuXG4gICAgdGV4dEJveENvbnRyb2xzLm10ciA9IG9iamVjdENvbnRyb2xzLm10cjtcbiAgICB0ZXh0Qm94Q29udHJvbHMudHIgPSBvYmplY3RDb250cm9scy50cjtcbiAgICB0ZXh0Qm94Q29udHJvbHMuYnIgPSBvYmplY3RDb250cm9scy5icjtcbiAgICB0ZXh0Qm94Q29udHJvbHMudGwgPSBvYmplY3RDb250cm9scy50bDtcbiAgICB0ZXh0Qm94Q29udHJvbHMuYmwgPSBvYmplY3RDb250cm9scy5ibDtcbiAgICB0ZXh0Qm94Q29udHJvbHMubXQgPSBvYmplY3RDb250cm9scy5tdDtcbiAgICB0ZXh0Qm94Q29udHJvbHMubWIgPSBvYmplY3RDb250cm9scy5tYjtcblxuICAgIHRleHRCb3hDb250cm9scy5tciA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgICB4OiAwLjUsXG4gICAgICB5OiAwLFxuICAgICAgYWN0aW9uSGFuZGxlcjogY29udHJvbHNVdGlscy5jaGFuZ2VXaWR0aCxcbiAgICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTa2V3U3R5bGVIYW5kbGVyLFxuICAgICAgYWN0aW9uTmFtZTogJ3Jlc2l6aW5nJyxcbiAgICB9KTtcblxuICAgIHRleHRCb3hDb250cm9scy5tbCA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgICB4OiAtMC41LFxuICAgICAgeTogMCxcbiAgICAgIGFjdGlvbkhhbmRsZXI6IGNvbnRyb2xzVXRpbHMuY2hhbmdlV2lkdGgsXG4gICAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU2tld1N0eWxlSGFuZGxlcixcbiAgICAgIGFjdGlvbk5hbWU6ICdyZXNpemluZycsXG4gICAgfSk7XG4gIH1cbn0pKCk7XG5cbiJdLCJuYW1lcyI6WyJmYWJyaWMiLCJ2ZXJzaW9uIiwiZXhwb3J0cyIsImRlZmluZSIsImFtZCIsImRvY3VtZW50IiwiSFRNTERvY3VtZW50IiwiRG9jdW1lbnQiLCJpbXBsZW1lbnRhdGlvbiIsImNyZWF0ZUhUTUxEb2N1bWVudCIsIndpbmRvdyIsImpzZG9tIiwicmVxdWlyZSIsInZpcnR1YWxXaW5kb3ciLCJKU0RPTSIsImRlY29kZVVSSUNvbXBvbmVudCIsImZlYXR1cmVzIiwiRmV0Y2hFeHRlcm5hbFJlc291cmNlcyIsInJlc291cmNlcyIsImpzZG9tSW1wbEZvcldyYXBwZXIiLCJpbXBsRm9yV3JhcHBlciIsIm5vZGVDYW52YXMiLCJDYW52YXMiLCJET01QYXJzZXIiLCJpc1RvdWNoU3VwcG9ydGVkIiwibmF2aWdhdG9yIiwibWF4VG91Y2hQb2ludHMiLCJpc0xpa2VseU5vZGUiLCJCdWZmZXIiLCJTSEFSRURfQVRUUklCVVRFUyIsIkRQSSIsInJlTnVtIiwiY29tbWFXc3AiLCJyZVBhdGhDb21tYW5kIiwicmVOb25Xb3JkIiwiZm9udFBhdGhzIiwiaU1hdHJpeCIsInN2Z05TIiwicGVyZkxpbWl0U2l6ZVRvdGFsIiwibWF4Q2FjaGVTaWRlTGltaXQiLCJtaW5DYWNoZVNpZGVMaW1pdCIsImNoYXJXaWR0aHNDYWNoZSIsInRleHR1cmVTaXplIiwiZGlzYWJsZVN0eWxlQ29weVBhc3RlIiwiZW5hYmxlR0xGaWx0ZXJpbmciLCJkZXZpY2VQaXhlbFJhdGlvIiwid2Via2l0RGV2aWNlUGl4ZWxSYXRpbyIsIm1vekRldmljZVBpeGVsUmF0aW8iLCJicm93c2VyU2hhZG93Qmx1ckNvbnN0YW50IiwiYXJjVG9TZWdtZW50c0NhY2hlIiwiYm91bmRzT2ZDdXJ2ZUNhY2hlIiwiY2FjaGVzQm91bmRzT2ZDdXJ2ZSIsImZvcmNlR0xQdXRJbWFnZURhdGEiLCJpbml0RmlsdGVyQmFja2VuZCIsImlzV2ViZ2xTdXBwb3J0ZWQiLCJjb25zb2xlIiwibG9nIiwibWF4VGV4dHVyZVNpemUiLCJXZWJnbEZpbHRlckJhY2tlbmQiLCJ0aWxlU2l6ZSIsIkNhbnZhczJkRmlsdGVyQmFja2VuZCIsIl9yZW1vdmVFdmVudExpc3RlbmVyIiwiZXZlbnROYW1lIiwiaGFuZGxlciIsIl9fZXZlbnRMaXN0ZW5lcnMiLCJldmVudExpc3RlbmVyIiwiaW5kZXhPZiIsInV0aWwiLCJhcnJheSIsImZpbGwiLCJvbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInByb3AiLCJwdXNoIiwiX29uY2UiLCJfaGFuZGxlciIsImFwcGx5Iiwib2ZmIiwiYmluZCIsIm9uY2UiLCJjYWxsIiwiZmlyZSIsIm9wdGlvbnMiLCJsaXN0ZW5lcnNGb3JFdmVudCIsImkiLCJsZW4iLCJmaWx0ZXIiLCJ2YWx1ZSIsIk9ic2VydmFibGUiLCJDb2xsZWN0aW9uIiwiX29iamVjdHMiLCJhZGQiLCJfb25PYmplY3RBZGRlZCIsInJlbmRlck9uQWRkUmVtb3ZlIiwicmVxdWVzdFJlbmRlckFsbCIsImluc2VydEF0Iiwib2JqZWN0IiwiaW5kZXgiLCJub25TcGxpY2luZyIsIm9iamVjdHMiLCJzcGxpY2UiLCJyZW1vdmUiLCJzb21ldGhpbmdSZW1vdmVkIiwiX29uT2JqZWN0UmVtb3ZlZCIsImZvckVhY2hPYmplY3QiLCJjYWxsYmFjayIsImNvbnRleHQiLCJnZXRPYmplY3RzIiwidHlwZSIsImNvbmNhdCIsIm8iLCJpdGVtIiwiaXNFbXB0eSIsInNpemUiLCJjb250YWlucyIsImRlZXAiLCJzb21lIiwib2JqIiwiY29tcGxleGl0eSIsInJlZHVjZSIsIm1lbW8iLCJjdXJyZW50IiwiQ29tbW9uTWV0aG9kcyIsIl9zZXRPcHRpb25zIiwic2V0IiwiX2luaXRHcmFkaWVudCIsImZpbGxlciIsInByb3BlcnR5IiwiY29sb3JTdG9wcyIsIkdyYWRpZW50IiwiX2luaXRQYXR0ZXJuIiwic291cmNlIiwiUGF0dGVybiIsIl9zZXRPYmplY3QiLCJfc2V0Iiwia2V5IiwidG9nZ2xlIiwiZ2V0IiwiZ2xvYmFsIiwic3FydCIsIk1hdGgiLCJhdGFuMiIsInBvdyIsIlBpQnkxODAiLCJQSSIsIlBpQnkyIiwiY29zIiwiYW5nbGUiLCJhbmdsZVNsaWNlIiwic2luIiwic2lnbiIsInJlbW92ZUZyb21BcnJheSIsImlkeCIsImdldFJhbmRvbUludCIsIm1pbiIsIm1heCIsImZsb29yIiwicmFuZG9tIiwiZGVncmVlc1RvUmFkaWFucyIsImRlZ3JlZXMiLCJyYWRpYW5zVG9EZWdyZWVzIiwicmFkaWFucyIsInJvdGF0ZVBvaW50IiwicG9pbnQiLCJvcmlnaW4iLCJuZXdQb2ludCIsIlBvaW50IiwieCIsInkiLCJ2Iiwicm90YXRlVmVjdG9yIiwiYWRkRXF1YWxzIiwidmVjdG9yIiwicngiLCJyeSIsImNyZWF0ZVZlY3RvciIsImZyb20iLCJ0byIsImNhbGNBbmdsZUJldHdlZW5WZWN0b3JzIiwiYSIsImIiLCJhY29zIiwiaHlwb3QiLCJnZXRIYXRWZWN0b3IiLCJtdWx0aXBseSIsImdldEJpc2VjdG9yIiwiQSIsIkIiLCJDIiwiQUIiLCJBQyIsImFscGhhIiwicm8iLCJwaGkiLCJwcm9qZWN0U3Ryb2tlT25Qb2ludHMiLCJwb2ludHMiLCJvcGVuUGF0aCIsImNvb3JkcyIsInMiLCJzdHJva2VXaWR0aCIsInN0cm9rZVVuaWZvcm1TY2FsYXIiLCJzdHJva2VVbmlmb3JtIiwic2NhbGVYIiwic2NhbGVZIiwiZ2V0U3Ryb2tlSGF0VmVjdG9yIiwic2NhbGFyIiwiZm9yRWFjaCIsInAiLCJiaXNlY3RvciIsImJpc2VjdG9yVmVjdG9yIiwibWl0ZXJWZWN0b3IiLCJzdHJva2VMaW5lSm9pbiIsInN0cm9rZU1pdGVyTGltaXQiLCJzdWJ0cmFjdCIsIlNRUlQyIiwidHJhbnNmb3JtUG9pbnQiLCJ0IiwiaWdub3JlT2Zmc2V0IiwibWFrZUJvdW5kaW5nQm94RnJvbVBvaW50cyIsInRyYW5zZm9ybSIsInhQb2ludHMiLCJtaW5YIiwibWF4WCIsIndpZHRoIiwieVBvaW50cyIsIm1pblkiLCJtYXhZIiwiaGVpZ2h0IiwibGVmdCIsInRvcCIsImludmVydFRyYW5zZm9ybSIsInIiLCJ0b0ZpeGVkIiwibnVtYmVyIiwiZnJhY3Rpb25EaWdpdHMiLCJwYXJzZUZsb2F0IiwiTnVtYmVyIiwicGFyc2VVbml0IiwiZm9udFNpemUiLCJ1bml0IiwiZXhlYyIsIlRleHQiLCJERUZBVUxUX1NWR19GT05UX1NJWkUiLCJmYWxzZUZ1bmN0aW9uIiwiZ2V0S2xhc3MiLCJuYW1lc3BhY2UiLCJzdHJpbmciLCJjYW1lbGl6ZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJyZXNvbHZlTmFtZXNwYWNlIiwiZ2V0U3ZnQXR0cmlidXRlcyIsImF0dHJpYnV0ZXMiLCJwYXJ0cyIsInNwbGl0IiwibG9hZEltYWdlIiwidXJsIiwiY3Jvc3NPcmlnaW4iLCJpbWciLCJjcmVhdGVJbWFnZSIsIm9uTG9hZENhbGxiYWNrIiwib25sb2FkIiwib25lcnJvciIsInNyYyIsInVuZGVmaW5lZCIsInN1YnN0cmluZyIsImxvYWRJbWFnZUluRG9tIiwiZGl2IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwicG9zaXRpb24iLCJhcHBlbmRDaGlsZCIsInF1ZXJ5U2VsZWN0b3IiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJlbmxpdmVuT2JqZWN0cyIsInJldml2ZXIiLCJlbmxpdmVuZWRPYmplY3RzIiwibnVtTG9hZGVkT2JqZWN0cyIsIm51bVRvdGFsT2JqZWN0cyIsIm9uTG9hZGVkIiwia2xhc3MiLCJmcm9tT2JqZWN0IiwiZXJyb3IiLCJlbmxpdmVuT2JqZWN0RW5saXZhYmxlcyIsImVubGl2ZW5Qcm9wcyIsIk9iamVjdCIsIkVOTElWRU5fUFJPUFMiLCJtYXAiLCJlbmxpdmVkUHJvcHMiLCJlbmxpdmVuUGF0dGVybnMiLCJwYXR0ZXJucyIsIm51bUxvYWRlZFBhdHRlcm5zIiwibnVtUGF0dGVybnMiLCJlbmxpdmVuZWRQYXR0ZXJucyIsInBhdHRlcm4iLCJncm91cFNWR0VsZW1lbnRzIiwiZWxlbWVudHMiLCJwYXRoIiwic291cmNlUGF0aCIsImNlbnRlclBvaW50IiwiR3JvdXAiLCJwb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzIiwiZGVzdGluYXRpb24iLCJwcm9wZXJ0aWVzIiwiQXJyYXkiLCJpc0FycmF5IiwiY3JlYXRlQ2FudmFzRWxlbWVudCIsImNvcHlDYW52YXNFbGVtZW50IiwiY2FudmFzIiwibmV3Q2FudmFzIiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsInRvRGF0YVVSTCIsImNhbnZhc0VsIiwiZm9ybWF0IiwicXVhbGl0eSIsIm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMiLCJpczJ4MiIsInFyRGVjb21wb3NlIiwiZGVub20iLCJza2V3WCIsInNrZXdZIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJjYWxjUm90YXRlTWF0cml4IiwidGhldGEiLCJjYWxjRGltZW5zaW9uc01hdHJpeCIsInNjYWxlTWF0cml4IiwiZmxpcFgiLCJmbGlwWSIsInRhbiIsImNvbXBvc2VNYXRyaXgiLCJtYXRyaXgiLCJyZXNldE9iamVjdFRyYW5zZm9ybSIsInRhcmdldCIsInJvdGF0ZSIsInNhdmVPYmplY3RUcmFuc2Zvcm0iLCJpc1RyYW5zcGFyZW50IiwiY3R4IiwidG9sZXJhbmNlIiwiX2lzVHJhbnNwYXJlbnQiLCJ0ZW1wIiwiaW1hZ2VEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwibCIsImRhdGEiLCJwYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGUiLCJhdHRyaWJ1dGUiLCJtZWV0T3JTbGljZSIsImFsaWduWCIsImFsaWduWSIsImFzcGVjdFJhdGlvQXR0cnMiLCJhbGlnbiIsInBvcCIsImNsZWFyRmFicmljRm9udENhY2hlIiwiZm9udEZhbWlseSIsInRvTG93ZXJDYXNlIiwibGltaXREaW1zQnlBcmVhIiwiYXIiLCJtYXhpbXVtQXJlYSIsInJvdWdoV2lkdGgiLCJwZXJmTGltaXRTaXplWSIsImNhcFZhbHVlIiwiZmluZFNjYWxlVG9GaXQiLCJmaW5kU2NhbGVUb0NvdmVyIiwibWF0cml4VG9TVkciLCJOVU1fRlJBQ1RJT05fRElHSVRTIiwiam9pbiIsInJlbW92ZVRyYW5zZm9ybUZyb21PYmplY3QiLCJpbnZlcnRlZCIsImZpbmFsVHJhbnNmb3JtIiwiY2FsY093bk1hdHJpeCIsImFwcGx5VHJhbnNmb3JtVG9PYmplY3QiLCJhZGRUcmFuc2Zvcm1Ub09iamVjdCIsImNlbnRlciIsInNldFBvc2l0aW9uQnlPcmlnaW4iLCJzaXplQWZ0ZXJUcmFuc2Zvcm0iLCJkaW1YIiwiZGltWSIsInRyYW5zZm9ybU1hdHJpeCIsImJib3giLCJtZXJnZUNsaXBQYXRocyIsImMxIiwiYzIiLCJjYWxjVHJhbnNmb3JtTWF0cml4IiwiY2xpcFBhdGgiLCJoYXNTdHlsZUNoYW5nZWQiLCJwcmV2U3R5bGUiLCJ0aGlzU3R5bGUiLCJmb3JUZXh0U3BhbnMiLCJzdHJva2UiLCJmb250V2VpZ2h0IiwiZm9udFN0eWxlIiwidGV4dEJhY2tncm91bmRDb2xvciIsImRlbHRhWSIsIm92ZXJsaW5lIiwidW5kZXJsaW5lIiwibGluZXRocm91Z2giLCJzdHlsZXNUb0FycmF5Iiwic3R5bGVzIiwidGV4dCIsImNsb25lIiwidGV4dExpbmVzIiwiY2hhckluZGV4Iiwic3R5bGVzQXJyYXkiLCJjIiwia2V5cyIsInN0eWxlQ2hhbmdlZCIsInN0YXJ0IiwiZW5kIiwic3R5bGVzRnJvbUFycmF5Iiwic3R5bGVJbmRleCIsInN0eWxlc09iamVjdCIsImFzc2lnbiIsIl9qb2luIiwicHJvdG90eXBlIiwiY29tbWFuZExlbmd0aHMiLCJtIiwiaCIsInEiLCJyZXBlYXRlZENvbW1hbmRzIiwiTSIsInNlZ21lbnRUb0JlemllciIsInRoMiIsInRoMyIsImNvc1RoIiwic2luVGgiLCJjeDEiLCJjeTEiLCJtVCIsImZyb21YIiwiZnJvbVkiLCJjb3N0aDIiLCJzaW50aDIiLCJjb3N0aDMiLCJzaW50aDMiLCJ0b1giLCJ0b1kiLCJjcDFYIiwiY3AxWSIsImNwMlgiLCJjcDJZIiwiYXJjVG9TZWdtZW50cyIsImxhcmdlIiwic3dlZXAiLCJyb3RhdGVYIiwidGgiLCJhYnMiLCJweCIsInB5IiwicngyIiwicnkyIiwicHkyIiwicHgyIiwicGwiLCJyb290IiwiY3giLCJjeSIsIm1UaGV0YSIsImNhbGNWZWN0b3JBbmdsZSIsImR0aGV0YSIsInNlZ21lbnRzIiwiY2VpbCIsInJlc3VsdCIsIm1EZWx0YSIsInV4IiwidXkiLCJ2eCIsInZ5IiwidGEiLCJ0YiIsImdldEJvdW5kc09mQ3VydmUiLCJ4MCIsInkwIiwieDEiLCJ5MSIsIngyIiwieTIiLCJ4MyIsInkzIiwiYXJnc1N0cmluZyIsInR2YWx1ZXMiLCJib3VuZHMiLCJ0MSIsInQyIiwiYjJhYyIsInNxcnRiMmFjIiwiaiIsImpsZW4iLCJtdCIsImZyb21BcmNUb0JlemllcnMiLCJmeCIsImZ5Iiwicm90IiwidHgiLCJ0eSIsInNlZ3NOb3JtIiwibWFrZVBhdGhTaW1wbGVyIiwiY29udmVydGVkIiwiZGVzdGluYXRpb25QYXRoIiwicHJldmlvdXMiLCJjb250cm9sWCIsImNvbnRyb2xZIiwiY2FsY0xpbmVMZW5ndGgiLCJDQjEiLCJDQjIiLCJDQjMiLCJDQjQiLCJnZXRQb2ludE9uQ3ViaWNCZXppZXJJdGVyYXRvciIsInAxeCIsInAxeSIsInAyeCIsInAyeSIsInAzeCIsInAzeSIsInA0eCIsInA0eSIsInBjdCIsImMzIiwiYzQiLCJnZXRUYW5nZW50Q3ViaWNJdGVyYXRvciIsImludlQiLCJ0YW5nZW50WCIsInRhbmdlbnRZIiwiUUIxIiwiUUIyIiwiUUIzIiwiZ2V0UG9pbnRPblF1YWRyYXRpY0Jlemllckl0ZXJhdG9yIiwiZ2V0VGFuZ2VudFF1YWRyYXRpY0l0ZXJhdG9yIiwicGF0aEl0ZXJhdG9yIiwiaXRlcmF0b3IiLCJ0ZW1wUCIsInRtcExlbiIsInBlcmMiLCJmaW5kUGVyY2VudGFnZUZvckRpc3RhbmNlIiwic2VnSW5mbyIsImRpc3RhbmNlIiwibmV4dExlbiIsIm5leHRTdGVwIiwiYW5nbGVGaW5kZXIiLCJsYXN0UGVyYyIsImdldFBhdGhTZWdtZW50c0luZm8iLCJ0b3RhbExlbmd0aCIsImluZm8iLCJ0ZW1wSW5mbyIsImNvbW1hbmQiLCJkZXN0WCIsImRlc3RZIiwiZ2V0UG9pbnRPblBhdGgiLCJpbmZvcyIsInNlZ1BlcmNlbnQiLCJzZWdtZW50IiwibGVycCIsInBhcnNlUGF0aCIsInBhdGhTdHJpbmciLCJjdXJyZW50UGF0aCIsInBhcnNlZCIsInJlIiwick51bWJlciIsInJOdW1iZXJDb21tYVdzcCIsInJGbGFnQ29tbWFXc3AiLCJyQXJjU2VxIiwicmVnQXJjQXJndW1lbnRTZXF1ZW5jZSIsIlJlZ0V4cCIsIm1hdGNoIiwiY29vcmRzU3RyIiwiY29vcmRzUGFyc2VkIiwidHJpbSIsImFyZ3MiLCJpc05hTiIsImNvbW1hbmRMZW5ndGgiLCJyZXBlYXRlZENvbW1hbmQiLCJrIiwia2xlbiIsImdldFNtb290aFBhdGhGcm9tUG9pbnRzIiwiY29ycmVjdGlvbiIsInAxIiwicDIiLCJtdWx0U2lnblgiLCJtdWx0U2lnblkiLCJtYW55UG9pbnRzIiwiZXEiLCJtaWRQb2ludCIsIm1pZFBvaW50RnJvbSIsInRyYW5zZm9ybVBhdGgiLCJwYXRoT2Zmc2V0IiwicGF0aFNlZ21lbnQiLCJuZXdTZWdtZW50Iiwiam9pblBhdGgiLCJwYXRoRGF0YSIsImludm9rZSIsIm1ldGhvZCIsImJ5UHJvcGVydHkiLCJmaW5kIiwidmFsdWUxIiwidmFsdWUyIiwiY29uZGl0aW9uIiwiZXh0ZW5kIiwiRWxlbWVudCIsImhhc093blByb3BlcnR5IiwicmVwbGFjZSIsImNoYXJhY3RlciIsImNhcGl0YWxpemUiLCJmaXJzdExldHRlck9ubHkiLCJlc2NhcGVYbWwiLCJncmFwaGVtZVNwbGl0IiwidGV4dHN0cmluZyIsImNociIsImdyYXBoZW1lcyIsImdldFdob2xlQ2hhciIsInN0ciIsImNvZGUiLCJjaGFyQ29kZUF0IiwibmV4dCIsInByZXYiLCJlbXB0eUZ1bmN0aW9uIiwiSVNfRE9OVEVOVU1fQlVHR1kiLCJ0b1N0cmluZyIsImFkZE1ldGhvZHMiLCJwYXJlbnQiLCJzdXBlcmNsYXNzIiwiY29uc3RydWN0b3IiLCJyZXR1cm5WYWx1ZSIsInZhbHVlT2YiLCJTdWJjbGFzcyIsImNhbGxTdXBlciIsIm1ldGhvZE5hbWUiLCJwYXJlbnRNZXRob2QiLCJfdGhpcyIsInN1cGVyQ2xhc3NNZXRob2QiLCJjcmVhdGVDbGFzcyIsInNoaWZ0IiwiaW5pdGlhbGl6ZSIsInN1YmNsYXNzZXMiLCJjb3VsZFVzZUF0dGFjaEV2ZW50IiwiYXR0YWNoRXZlbnQiLCJ0b3VjaEV2ZW50cyIsImFkZExpc3RlbmVyIiwiZWxlbWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJnZXRUb3VjaEluZm8iLCJldmVudCIsInRvdWNoUHJvcCIsImNoYW5nZWRUb3VjaGVzIiwiZ2V0UG9pbnRlciIsInNjcm9sbCIsImdldFNjcm9sbExlZnRUb3AiLCJfZXZ0IiwiY2xpZW50WCIsImNsaWVudFkiLCJpc1RvdWNoRXZlbnQiLCJwb2ludGVyVHlwZSIsInNldFN0eWxlIiwiZWxlbWVudFN0eWxlIiwiY3NzVGV4dCIsInNldE9wYWNpdHkiLCJub3JtYWxpemVkUHJvcGVydHkiLCJzdHlsZUZsb2F0Iiwic2V0UHJvcGVydHkiLCJwYXJzZUVsIiwic3VwcG9ydHNPcGFjaXR5Iiwib3BhY2l0eSIsInN1cHBvcnRzRmlsdGVycyIsInJlT3BhY2l0eSIsImVzIiwiY3VycmVudFN0eWxlIiwiaGFzTGF5b3V0Iiwiem9vbSIsInRlc3QiLCJfc2xpY2UiLCJnZXRCeUlkIiwiaWQiLCJnZXRFbGVtZW50QnlJZCIsInNsaWNlQ2FuQ29udmVydE5vZGVsaXN0cyIsInRvQXJyYXkiLCJhcnJheUxpa2UiLCJjaGlsZE5vZGVzIiwiZXJyIiwiYXJyIiwibWFrZUVsZW1lbnQiLCJ0YWdOYW1lIiwiZWwiLCJjbGFzc05hbWUiLCJodG1sRm9yIiwic2V0QXR0cmlidXRlIiwiYWRkQ2xhc3MiLCJ3cmFwRWxlbWVudCIsIndyYXBwZXIiLCJyZXBsYWNlQ2hpbGQiLCJkb2NFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiYm9keSIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJob3N0Iiwibm9kZVR5cGUiLCJnZXRFbGVtZW50T2Zmc2V0IiwiZG9jRWxlbSIsImRvYyIsIm93bmVyRG9jdW1lbnQiLCJib3giLCJvZmZzZXQiLCJzY3JvbGxMZWZ0VG9wIiwib2Zmc2V0QXR0cmlidXRlcyIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclRvcFdpZHRoIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nVG9wIiwiYXR0ciIsInBhcnNlSW50IiwiZ2V0RWxlbWVudFN0eWxlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50TGVmdCIsImNsaWVudFRvcCIsImRlZmF1bHRWaWV3IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInNlbGVjdFByb3AiLCJtYWtlRWxlbWVudFVuc2VsZWN0YWJsZSIsIm9uc2VsZWN0c3RhcnQiLCJ1bnNlbGVjdGFibGUiLCJtYWtlRWxlbWVudFNlbGVjdGFibGUiLCJnZXROb2RlQ2FudmFzIiwiaW1wbCIsIl9jYW52YXMiLCJfaW1hZ2UiLCJjbGVhblVwSnNkb21Ob2RlIiwiX2N1cnJlbnRTcmMiLCJfYXR0cmlidXRlcyIsIl9jbGFzc0xpc3QiLCJzZXRJbWFnZVNtb290aGluZyIsImltYWdlU21vb3RoaW5nRW5hYmxlZCIsIndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCIsIm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCIsIm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwib0ltYWdlU21vb3RoaW5nRW5hYmxlZCIsImFkZFBhcmFtVG9VcmwiLCJwYXJhbSIsImVtcHR5Rm4iLCJyZXF1ZXN0Iiwib25Db21wbGV0ZSIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwicGFyYW1ldGVycyIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsInNlbmQiLCJ3YXJuIiwiUlVOTklOR19BTklNQVRJT05TIiwiY2FuY2VsQWxsIiwiYW5pbWF0aW9ucyIsImFuaW1hdGlvbiIsImNhbmNlbCIsImNhbmNlbEJ5Q2FudmFzIiwiY2FuY2VsbGVkIiwiY2FuY2VsQnlUYXJnZXQiLCJmaW5kQW5pbWF0aW9uc0J5VGFyZ2V0IiwiZmluZEFuaW1hdGlvbkluZGV4IiwiY2FuY2VsRnVuYyIsImZpbmRBbmltYXRpb24iLCJub29wIiwiZGVmYXVsdEVhc2luZyIsImQiLCJhbmltYXRlIiwicmVtb3ZlRnJvbVJlZ2lzdHJ5IiwicnVubmluZ0FuaW1hdGlvbnMiLCJjdXJyZW50VmFsdWUiLCJzdGFydFZhbHVlIiwiY29tcGxldGlvblJhdGUiLCJkdXJhdGlvblJhdGUiLCJyZXF1ZXN0QW5pbUZyYW1lIiwidGltZXN0YW1wIiwiRGF0ZSIsImR1cmF0aW9uIiwiZmluaXNoIiwidGltZSIsIm9uQ2hhbmdlIiwiYWJvcnQiLCJlYXNpbmciLCJpc01hbnkiLCJlbmRWYWx1ZSIsImJ5VmFsdWUiLCJvblN0YXJ0IiwidGljayIsInRpY2t0aW1lIiwiY3VycmVudFRpbWUiLCJ0aW1lUGVyYyIsIl92YWx1ZSIsInZhbHVlUGVyYyIsIl9yZXF1ZXN0QW5pbUZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsIl9jYW5jZWxBbmltRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFyVGltZW91dCIsImNhbmNlbEFuaW1GcmFtZSIsImNhbGN1bGF0ZUNvbG9yIiwiYmVnaW4iLCJwb3MiLCJjb2xvciIsImFuaW1hdGVDb2xvciIsImZyb21Db2xvciIsInRvQ29sb3IiLCJzdGFydENvbG9yIiwiQ29sb3IiLCJnZXRTb3VyY2UiLCJlbmRDb2xvciIsIm9yaWdpbmFsT25Db21wbGV0ZSIsIm9yaWdpbmFsT25DaGFuZ2UiLCJwb3NWYWx1ZSIsImNvbG9yRWFzaW5nIiwibm9ybWFsaXplIiwiYXNpbiIsImVsYXN0aWMiLCJvcHRzIiwiZWFzZU91dEN1YmljIiwiZWFzZUluT3V0Q3ViaWMiLCJlYXNlSW5RdWFydCIsImVhc2VPdXRRdWFydCIsImVhc2VJbk91dFF1YXJ0IiwiZWFzZUluUXVpbnQiLCJlYXNlT3V0UXVpbnQiLCJlYXNlSW5PdXRRdWludCIsImVhc2VJblNpbmUiLCJlYXNlT3V0U2luZSIsImVhc2VJbk91dFNpbmUiLCJlYXNlSW5FeHBvIiwiZWFzZU91dEV4cG8iLCJlYXNlSW5PdXRFeHBvIiwiZWFzZUluQ2lyYyIsImVhc2VPdXRDaXJjIiwiZWFzZUluT3V0Q2lyYyIsImVhc2VJbkVsYXN0aWMiLCJlYXNlT3V0RWxhc3RpYyIsImVhc2VJbk91dEVsYXN0aWMiLCJlYXNlSW5CYWNrIiwiZWFzZU91dEJhY2siLCJlYXNlSW5PdXRCYWNrIiwiZWFzZUluQm91bmNlIiwiZWFzZU91dEJvdW5jZSIsImVhc2VJbk91dEJvdW5jZSIsImVhc2UiLCJlYXNlSW5RdWFkIiwiZWFzZU91dFF1YWQiLCJlYXNlSW5PdXRRdWFkIiwiZWFzZUluQ3ViaWMiLCJzdmdWYWxpZFRhZ05hbWVzIiwic3ZnVmlld0JveEVsZW1lbnRzIiwic3ZnSW52YWxpZEFuY2VzdG9ycyIsInN2Z1ZhbGlkUGFyZW50cyIsImF0dHJpYnV0ZXNNYXAiLCJkaXNwbGF5IiwidmlzaWJpbGl0eSIsImNvbG9yQXR0cmlidXRlcyIsImZTaXplIiwiY1BhdGgiLCJzdmdWYWxpZFRhZ05hbWVzUmVnRXgiLCJnZXRTdmdSZWdleCIsInN2Z1ZpZXdCb3hFbGVtZW50c1JlZ0V4Iiwic3ZnSW52YWxpZEFuY2VzdG9yc1JlZ0V4Iiwic3ZnVmFsaWRQYXJlbnRzUmVnRXgiLCJjc3NSdWxlcyIsImdyYWRpZW50RGVmcyIsImNsaXBQYXRocyIsIm5vcm1hbGl6ZUF0dHIiLCJub3JtYWxpemVWYWx1ZSIsInBhcmVudEF0dHJpYnV0ZXMiLCJwYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSIsInZpc2libGUiLCJmaWxsSW5kZXgiLCJzdHJva2VJbmRleCIsIl9zZXRTdHJva2VGaWxsT3BhY2l0eSIsInNldEFscGhhIiwiZ2V0QWxwaGEiLCJ0b1JnYmEiLCJfZ2V0TXVsdGlwbGVOb2RlcyIsIm5vZGVOYW1lcyIsIm5vZGVOYW1lIiwibm9kZUFycmF5Iiwibm9kZUxpc3QiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInJvdGF0ZU1hdHJpeCIsIm11bHRpcGxpZXJYIiwibXVsdGlwbGllclkiLCJza2V3TWF0cml4IiwidHJhbnNsYXRlTWF0cml4Iiwic2NhbGUiLCJ0cmFuc2xhdGUiLCJ0cmFuc2Zvcm1zIiwidHJhbnNmb3JtTGlzdCIsInJlVHJhbnNmb3JtTGlzdCIsInJlVHJhbnNmb3JtIiwiYXR0cmlidXRlVmFsdWUiLCJtYXRyaWNlcyIsIm9wZXJhdGlvbiIsImNvbWJpbmVkTWF0cml4IiwicGFyc2VTdHlsZVN0cmluZyIsIm9TdHlsZSIsImNodW5rIiwicGFpciIsInBhcnNlU3R5bGVPYmplY3QiLCJnZXRHbG9iYWxTdHlsZXNGb3JFbGVtZW50Iiwic3ZnVWlkIiwicnVsZSIsImVsZW1lbnRNYXRjaGVzUnVsZSIsInNlbGVjdG9ycyIsImZpcnN0TWF0Y2hpbmciLCJwYXJlbnRNYXRjaGluZyIsInNlbGVjdG9yTWF0Y2hlcyIsImRvZXNTb21lUGFyZW50TWF0Y2giLCJzZWxlY3RvciIsImNsYXNzTmFtZXMiLCJnZXRBdHRyaWJ1dGUiLCJtYXRjaGVyIiwiZWxlbWVudEJ5SWQiLCJub2RlIiwibm9kZWxpc3QiLCJwYXJzZVVzZURpcmVjdGl2ZXMiLCJ4bGlua0F0dHJpYnV0ZSIsInhsaW5rIiwiZWwyIiwiY2xvbmVOb2RlIiwiY3VycmVudFRyYW5zIiwib2xkTGVuZ3RoIiwiYXR0cnMiLCJhcHBseVZpZXdib3hUcmFuc2Zvcm0iLCJlbDMiLCJjcmVhdGVFbGVtZW50TlMiLCJzZXRBdHRyaWJ1dGVOUyIsIm5vZGVWYWx1ZSIsImZpcnN0Q2hpbGQiLCJyZW1vdmVBdHRyaWJ1dGUiLCJyZVZpZXdCb3hBdHRyVmFsdWUiLCJ2aWV3Qm94QXR0ciIsInZpZXdCb3hXaWR0aCIsInZpZXdCb3hIZWlnaHQiLCJ3aWR0aEF0dHIiLCJoZWlnaHRBdHRyIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsIm1pc3NpbmdWaWV3Qm94IiwibWlzc2luZ0RpbUF0dHIiLCJ0b0JlUGFyc2VkIiwicGFyc2VkRGltIiwid2lkdGhEaWZmIiwiaGVpZ2h0RGlmZiIsImhhc0FuY2VzdG9yV2l0aE5vZGVOYW1lIiwicGFyc2VTVkdEb2N1bWVudCIsInBhcnNpbmdPcHRpb25zIiwiX191aWQiLCJkZXNjZW5kYW50cyIsInNlbGVjdE5vZGVzIiwiZ2V0R3JhZGllbnREZWZzIiwiZ2V0Q1NTUnVsZXMiLCJwYXJzZUVsZW1lbnRzIiwiaW5zdGFuY2VzIiwicmVjdXJzaXZlbHlQYXJzZUdyYWRpZW50c1hsaW5rIiwiZ3JhZGllbnQiLCJncmFkaWVudHNBdHRycyIsInhsaW5rQXR0ciIsInhMaW5rIiwicmVmZXJlbmNlZEdyYWRpZW50IiwiaGFzQXR0cmlidXRlIiwiY2hpbGRyZW4iLCJyZWZlcmVuY2VDbG9uZSIsInJlRm9udERlY2xhcmF0aW9uIiwicGFyc2VGb250RGVjbGFyYXRpb24iLCJsaW5lSGVpZ2h0IiwidGFnQXJyYXkiLCJlbExpc3QiLCJwYXJzZUF0dHJpYnV0ZXMiLCJwYXJlbnRGb250U2l6ZSIsIm93bkF0dHJpYnV0ZXMiLCJjc3NBdHRycyIsInBhcnNlU3R5bGVBdHRyaWJ1dGUiLCJub3JtYWxpemVkQXR0ciIsIm5vcm1hbGl6ZWRWYWx1ZSIsIm5vcm1hbGl6ZWRTdHlsZSIsImZvbnQiLCJtZXJnZWRBdHRycyIsIkVsZW1lbnRzUGFyc2VyIiwicGFyc2UiLCJwYXJzZVBvaW50c0F0dHJpYnV0ZSIsInBhcnNlZFBvaW50cyIsImFsbFJ1bGVzIiwicnVsZXMiLCJzdHlsZUNvbnRlbnRzIiwidGV4dENvbnRlbnQiLCJydWxlT2JqIiwiZGVjbGFyYXRpb24iLCJwcm9wZXJ0eVZhbHVlUGFpcnMiLCJfcnVsZSIsImxvYWRTVkdGcm9tVVJMIiwieG1sIiwicmVzcG9uc2VYTUwiLCJyZXN1bHRzIiwiX29wdGlvbnMiLCJhbGxFbGVtZW50cyIsImxvYWRTVkdGcm9tU3RyaW5nIiwicGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwicmVnZXhVcmwiLCJwcm90byIsIm51bUVsZW1lbnRzIiwiY3JlYXRlT2JqZWN0cyIsImNyZWF0ZU9iamVjdCIsImZpbmRUYWciLCJmcm9tRWxlbWVudCIsImNyZWF0ZUNhbGxiYWNrIiwiY2hlY2tJZkRvbmUiLCJyZXNvbHZlR3JhZGllbnQiLCJJbWFnZSIsIl9vcmlnaW5hbEVsZW1lbnQiLCJfcmVtb3ZlVHJhbnNmb3JtTWF0cml4IiwicmVzb2x2ZUNsaXBQYXRoIiwiZXh0cmFjdFByb3BlcnR5RGVmaW5pdGlvbiIsInN0b3JhZ2UiLCJyZWdleCIsImxhc3RJbmRleCIsImdyYWRpZW50RGVmIiwib3BhY2l0eUF0dHIiLCJjcmVhdGVDbGlwUGF0aENhbGxiYWNrIiwiY29udGFpbmVyIiwiX25ld09iaiIsImZpbGxSdWxlIiwiY2xpcFJ1bGUiLCJ1c2luZ0VsZW1lbnQiLCJvYmpUcmFuc2Zvcm1JbnYiLCJnVHJhbnNmb3JtIiwiY2xpcFBhdGhUYWciLCJjbGlwUGF0aE93bmVyIiwidGhhdCIsInNjYWxhckFkZCIsInNjYWxhckFkZEVxdWFscyIsInN1YnRyYWN0RXF1YWxzIiwic2NhbGFyU3VidHJhY3QiLCJzY2FsYXJTdWJ0cmFjdEVxdWFscyIsIm11bHRpcGx5RXF1YWxzIiwiZGl2aWRlIiwiZGl2aWRlRXF1YWxzIiwibHQiLCJsdGUiLCJndCIsImd0ZSIsImRpc3RhbmNlRnJvbSIsImR4IiwiZHkiLCJzZXRYWSIsInNldFgiLCJzZXRZIiwic2V0RnJvbVBvaW50Iiwic3dhcCIsIkludGVyc2VjdGlvbiIsInN0YXR1cyIsImFwcGVuZFBvaW50IiwiYXBwZW5kUG9pbnRzIiwiaW50ZXJzZWN0TGluZUxpbmUiLCJhMSIsImEyIiwiYjEiLCJiMiIsInVhVCIsInViVCIsInVCIiwidWEiLCJ1YiIsImludGVyc2VjdExpbmVQb2x5Z29uIiwiaW50ZXIiLCJpbnRlcnNlY3RQb2x5Z29uUG9seWdvbiIsInBvaW50czEiLCJwb2ludHMyIiwiaW50ZXJzZWN0UG9seWdvblJlY3RhbmdsZSIsInIxIiwicjIiLCJ0b3BSaWdodCIsImJvdHRvbUxlZnQiLCJpbnRlcjEiLCJpbnRlcjIiLCJpbnRlcjMiLCJpbnRlcjQiLCJzZXRTb3VyY2UiLCJfdHJ5UGFyc2luZ0NvbG9yIiwiY29sb3JOYW1lTWFwIiwic291cmNlRnJvbUhleCIsInNvdXJjZUZyb21SZ2IiLCJzb3VyY2VGcm9tSHNsIiwiX3JnYlRvSHNsIiwiZyIsInJvdW5kIiwiX3NvdXJjZSIsInRvUmdiIiwidG9Ic2wiLCJoc2wiLCJ0b0hzbGEiLCJ0b0hleCIsInRvSGV4YSIsInRvR3JheXNjYWxlIiwiYXZlcmFnZSIsImN1cnJlbnRBbHBoYSIsInRvQmxhY2tXaGl0ZSIsInRocmVzaG9sZCIsIm92ZXJsYXlXaXRoIiwib3RoZXJDb2xvciIsIm90aGVyQWxwaGEiLCJvdGhlclNvdXJjZSIsInJlUkdCYSIsInJlSFNMYSIsInJlSGV4IiwiYWxpY2VibHVlIiwiYW50aXF1ZXdoaXRlIiwiYXF1YSIsImFxdWFtYXJpbmUiLCJhenVyZSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuY2hlZGFsbW9uZCIsImJsdWUiLCJibHVldmlvbGV0IiwiYnJvd24iLCJidXJseXdvb2QiLCJjYWRldGJsdWUiLCJjaGFydHJldXNlIiwiY2hvY29sYXRlIiwiY29yYWwiLCJjb3JuZmxvd2VyYmx1ZSIsImNvcm5zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJkYXJrYmx1ZSIsImRhcmtjeWFuIiwiZGFya2dvbGRlbnJvZCIsImRhcmtncmF5IiwiZGFya2dyZXkiLCJkYXJrZ3JlZW4iLCJkYXJra2hha2kiLCJkYXJrbWFnZW50YSIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya29yYW5nZSIsImRhcmtvcmNoaWQiLCJkYXJrcmVkIiwiZGFya3NhbG1vbiIsImRhcmtzZWFncmVlbiIsImRhcmtzbGF0ZWJsdWUiLCJkYXJrc2xhdGVncmF5IiwiZGFya3NsYXRlZ3JleSIsImRhcmt0dXJxdW9pc2UiLCJkYXJrdmlvbGV0IiwiZGVlcHBpbmsiLCJkZWVwc2t5Ymx1ZSIsImRpbWdyYXkiLCJkaW1ncmV5IiwiZG9kZ2VyYmx1ZSIsImZpcmVicmljayIsImZsb3JhbHdoaXRlIiwiZm9yZXN0Z3JlZW4iLCJmdWNoc2lhIiwiZ2FpbnNib3JvIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJncmF5IiwiZ3JleSIsImdyZWVuIiwiZ3JlZW55ZWxsb3ciLCJob25leWRldyIsImhvdHBpbmsiLCJpbmRpYW5yZWQiLCJpbmRpZ28iLCJpdm9yeSIsImtoYWtpIiwibGF2ZW5kZXIiLCJsYXZlbmRlcmJsdXNoIiwibGF3bmdyZWVuIiwibGVtb25jaGlmZm9uIiwibGlnaHRibHVlIiwibGlnaHRjb3JhbCIsImxpZ2h0Y3lhbiIsImxpZ2h0Z29sZGVucm9keWVsbG93IiwibGlnaHRncmF5IiwibGlnaHRncmV5IiwibGlnaHRncmVlbiIsImxpZ2h0cGluayIsImxpZ2h0c2FsbW9uIiwibGlnaHRzZWFncmVlbiIsImxpZ2h0c2t5Ymx1ZSIsImxpZ2h0c2xhdGVncmF5IiwibGlnaHRzbGF0ZWdyZXkiLCJsaWdodHN0ZWVsYmx1ZSIsImxpZ2h0eWVsbG93IiwibGltZSIsImxpbWVncmVlbiIsImxpbmVuIiwibWFnZW50YSIsIm1hcm9vbiIsIm1lZGl1bWFxdWFtYXJpbmUiLCJtZWRpdW1ibHVlIiwibWVkaXVtb3JjaGlkIiwibWVkaXVtcHVycGxlIiwibWVkaXVtc2VhZ3JlZW4iLCJtZWRpdW1zbGF0ZWJsdWUiLCJtZWRpdW1zcHJpbmdncmVlbiIsIm1lZGl1bXR1cnF1b2lzZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pZG5pZ2h0Ymx1ZSIsIm1pbnRjcmVhbSIsIm1pc3R5cm9zZSIsIm1vY2Nhc2luIiwibmF2YWpvd2hpdGUiLCJuYXZ5Iiwib2xkbGFjZSIsIm9saXZlIiwib2xpdmVkcmFiIiwib3JhbmdlIiwib3JhbmdlcmVkIiwib3JjaGlkIiwicGFsZWdvbGRlbnJvZCIsInBhbGVncmVlbiIsInBhbGV0dXJxdW9pc2UiLCJwYWxldmlvbGV0cmVkIiwicGFwYXlhd2hpcCIsInBlYWNocHVmZiIsInBlcnUiLCJwaW5rIiwicGx1bSIsInBvd2RlcmJsdWUiLCJwdXJwbGUiLCJyZWJlY2NhcHVycGxlIiwicmVkIiwicm9zeWJyb3duIiwicm95YWxibHVlIiwic2FkZGxlYnJvd24iLCJzYWxtb24iLCJzYW5keWJyb3duIiwic2VhZ3JlZW4iLCJzZWFzaGVsbCIsInNpZW5uYSIsInNpbHZlciIsInNreWJsdWUiLCJzbGF0ZWJsdWUiLCJzbGF0ZWdyYXkiLCJzbGF0ZWdyZXkiLCJzbm93Iiwic3ByaW5nZ3JlZW4iLCJzdGVlbGJsdWUiLCJ0ZWFsIiwidGhpc3RsZSIsInRvbWF0byIsInR1cnF1b2lzZSIsInZpb2xldCIsIndoZWF0Iiwid2hpdGUiLCJ3aGl0ZXNtb2tlIiwieWVsbG93IiwieWVsbG93Z3JlZW4iLCJodWUycmdiIiwiZnJvbVJnYiIsImZyb21Tb3VyY2UiLCJmcm9tUmdiYSIsImZyb21Ic2wiLCJmcm9tSHNsYSIsImZyb21IZXgiLCJpc1Nob3J0Tm90YXRpb24iLCJpc1JHQmEiLCJvQ29sb3IiLCJzY2FsZU1hcCIsInNrZXdNYXAiLCJjb250cm9scyIsIkxFRlQiLCJUT1AiLCJSSUdIVCIsIkJPVFRPTSIsIkNFTlRFUiIsIm9wcG9zaXRlIiwiYm90dG9tIiwicmlnaHQiLCJmaW5kQ29ybmVyUXVhZHJhbnQiLCJmYWJyaWNPYmplY3QiLCJjb250cm9sIiwiY29ybmVyQW5nbGUiLCJmaXJlRXZlbnQiLCJjYW52YXNPcHRpb25zIiwic2NhbGVJc1Byb3BvcnRpb25hbCIsImV2ZW50RGF0YSIsInVuaVNjYWxlS2V5IiwidW5pZm9ybUlzVG9nZ2xlZCIsInVuaWZvcm1TY2FsaW5nIiwiaXNUcmFuc2Zvcm1DZW50ZXJlZCIsIm9yaWdpblgiLCJvcmlnaW5ZIiwic2NhbGluZ0lzRm9yYmlkZGVuIiwiYnkiLCJzY2FsZVByb3BvcnRpb25hbGx5IiwibG9ja1giLCJsb2NrU2NhbGluZ1giLCJsb2NrWSIsImxvY2tTY2FsaW5nWSIsInNjYWxlQ3Vyc29yU3R5bGVIYW5kbGVyIiwibm90QWxsb3dlZCIsIm4iLCJza2V3Q3Vyc29yU3R5bGVIYW5kbGVyIiwibG9ja1NrZXdpbmdZIiwibG9ja1NrZXdpbmdYIiwic2NhbGVTa2V3Q3Vyc29yU3R5bGVIYW5kbGVyIiwiYWx0QWN0aW9uS2V5Iiwic2NhbGVPclNrZXdBY3Rpb25OYW1lIiwiaXNBbHRlcm5hdGl2ZSIsInJvdGF0aW9uU3R5bGVIYW5kbGVyIiwibG9ja1JvdGF0aW9uIiwiY3Vyc29yU3R5bGUiLCJjb21tb25FdmVudEluZm8iLCJlIiwicG9pbnRlciIsIndyYXBXaXRoRml4ZWRBbmNob3IiLCJhY3Rpb25IYW5kbGVyIiwiZ2V0Q2VudGVyUG9pbnQiLCJjb25zdHJhaW50IiwidHJhbnNsYXRlVG9PcmlnaW5Qb2ludCIsImFjdGlvblBlcmZvcm1lZCIsIndyYXBXaXRoRmlyZUV2ZW50IiwiZ2V0TG9jYWxQb2ludCIsImNvcm5lciIsImdldFpvb20iLCJwYWRkaW5nIiwibG9jYWxQb2ludCIsInRvTG9jYWxQb2ludCIsIm9mZnNldFgiLCJvZmZzZXRZIiwidGFyZ2V0SGFzT25lRmxpcCIsImNvbXBlbnNhdGVTY2FsZUZvclNrZXciLCJvcHBvc2l0ZVNrZXciLCJzY2FsZVRvQ29tcGVuc2F0ZSIsImF4aXMiLCJyZWZlcmVuY2UiLCJuZXdEaW0iLCJfZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zIiwibmV3VmFsdWUiLCJza2V3T2JqZWN0WCIsImRpbU5vU2tldyIsInRvdGFsU2tld1NpemUiLCJjdXJyZW50U2tldyIsIm5ld1NrZXciLCJoYXNTa2V3ZWQiLCJkaW1CZWZvcmVTa2V3aW5nIiwic2tld09iamVjdFkiLCJza2V3SGFuZGxlclgiLCJsb2NhbFBvaW50RnJvbUNlbnRlciIsImZpbmFsSGFuZGxlciIsInNrZXdIYW5kbGVyWSIsInJvdGF0aW9uV2l0aFNuYXBwaW5nIiwicGl2b3RQb2ludCIsImxhc3RBbmdsZSIsImV5IiwiZXgiLCJjdXJBbmdsZSIsImhhc1JvdGF0ZWQiLCJzbmFwQW5nbGUiLCJzbmFwVGhyZXNob2xkIiwicmlnaHRBbmdsZUxvY2tlZCIsImxlZnRBbmdsZUxvY2tlZCIsInNjYWxlT2JqZWN0IiwiZGltIiwiZm9yYmlkU2NhbGluZyIsInNpZ25YIiwic2lnblkiLCJnZXN0dXJlU2NhbGUiLCJsb2NrU2NhbGluZ0ZsaXAiLCJvcmlnaW5hbCIsIm9yaWdpbmFsRGlzdGFuY2UiLCJvbGRTY2FsZVgiLCJvbGRTY2FsZVkiLCJzY2FsZU9iamVjdEZyb21Db3JuZXIiLCJzY2FsZU9iamVjdFgiLCJzY2FsZU9iamVjdFkiLCJzY2FsaW5nWU9yU2tld2luZ1giLCJzY2FsaW5nWSIsInNjYWxpbmdYT3JTa2V3aW5nWSIsInNjYWxpbmdYIiwiY2hhbmdlV2lkdGgiLCJzdHJva2VQYWRkaW5nIiwibXVsdGlwbGllciIsIm9sZFdpZHRoIiwibmV3V2lkdGgiLCJkcmFnSGFuZGxlciIsIm5ld0xlZnQiLCJuZXdUb3AiLCJtb3ZlWCIsIm1vdmVZIiwic2NhbGluZ0VxdWFsbHkiLCJjb250cm9sc1V0aWxzIiwicmVuZGVyQ2lyY2xlQ29udHJvbCIsInN0eWxlT3ZlcnJpZGUiLCJ4U2l6ZSIsInNpemVYIiwiY29ybmVyU2l6ZSIsInlTaXplIiwic2l6ZVkiLCJ0cmFuc3BhcmVudENvcm5lcnMiLCJjb3JuZXJTdHJva2VDb2xvciIsIm15TGVmdCIsIm15VG9wIiwic2F2ZSIsImZpbGxTdHlsZSIsImNvcm5lckNvbG9yIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJiZWdpblBhdGgiLCJhcmMiLCJyZXN0b3JlIiwicmVuZGVyU3F1YXJlQ29udHJvbCIsInhTaXplQnkyIiwieVNpemVCeTIiLCJzdHJva2VSZWN0IiwiQ29udHJvbCIsImFjdGlvbk5hbWUiLCJ0b3VjaFNpemVYIiwidG91Y2hTaXplWSIsIndpdGhDb25uZWN0aW9uIiwibW91c2VEb3duSGFuZGxlciIsIm1vdXNlVXBIYW5kbGVyIiwiZ2V0QWN0aW9uSGFuZGxlciIsImdldE1vdXNlRG93bkhhbmRsZXIiLCJnZXRNb3VzZVVwSGFuZGxlciIsImN1cnNvclN0eWxlSGFuZGxlciIsImdldEFjdGlvbk5hbWUiLCJnZXRWaXNpYmlsaXR5IiwiY29udHJvbEtleSIsIm9iamVjdFZpc2liaWxpdHkiLCJfY29udHJvbHNWaXNpYmlsaXR5Iiwic2V0VmlzaWJpbGl0eSIsInBvc2l0aW9uSGFuZGxlciIsImZpbmFsTWF0cml4IiwiY2FsY0Nvcm5lckNvb3JkcyIsIm9iamVjdEFuZ2xlIiwib2JqZWN0Q29ybmVyU2l6ZSIsImNlbnRlclgiLCJjZW50ZXJZIiwiaXNUb3VjaCIsImNvc0hhbGZPZmZzZXQiLCJzaW5IYWxmT2Zmc2V0IiwiY29zSGFsZk9mZnNldENvbXAiLCJzaW5IYWxmT2Zmc2V0Q29tcCIsImNvbnRyb2xUcmlhbmdsZUFuZ2xlIiwiY29ybmVySHlwb3RlbnVzZSIsIm5ld1RoZXRhIiwibmV3VGhldGFDb21wIiwidGwiLCJ0ciIsImJsIiwiYnIiLCJyZW5kZXIiLCJjb3JuZXJTdHlsZSIsImdldENvbG9yU3RvcCIsImNvbG9yQWxwaGEiLCJrZXlWYWx1ZVBhaXJzIiwiZ2V0TGluZWFyQ29vcmRzIiwiZ2V0UmFkaWFsQ29vcmRzIiwiZ3JhZGllbnRUcmFuc2Zvcm0iLCJncmFkaWVudFVuaXRzIiwib3B0aW9uIiwiYWRkQ29sb3JTdG9wIiwidG9PYmplY3QiLCJwcm9wZXJ0aWVzVG9JbmNsdWRlIiwidG9TVkciLCJtYXJrdXAiLCJjb21tb25BdHRyaWJ1dGVzIiwibmVlZHNTd2FwIiwid2l0aFZpZXdwb3J0IiwiYWRkaXRpb25hbFRyYW5zZm9ybSIsInNvcnQiLCJyZXZlcnNlIiwibWluUmFkaXVzIiwibWF4UmFkaXVzIiwicGVyY2VudGFnZVNoaWZ0IiwiY29sb3JTdG9wIiwidG9MaXZlIiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsImluc3RhbmNlIiwic3ZnT3B0aW9ucyIsImNvbG9yU3RvcEVscyIsIl9fY29udmVydFBlcmNlbnRVbml0c1RvVmFsdWVzIiwicHJvcFZhbHVlIiwiZmluYWxWYWx1ZSIsInJlcGVhdCIsInBhdHRlcm5UcmFuc2Zvcm0iLCJzZXRPcHRpb25zIiwiaXNFcnJvciIsInBhdHRlcm5Tb3VyY2UiLCJwYXR0ZXJuV2lkdGgiLCJwYXR0ZXJuSGVpZ2h0IiwicGF0dGVybk9mZnNldFgiLCJwYXR0ZXJuT2Zmc2V0WSIsInBhdHRlcm5JbWdTcmMiLCJjb21wbGV0ZSIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaHQiLCJjcmVhdGVQYXR0ZXJuIiwiU2hhZG93IiwiYmx1ciIsImFmZmVjdFN0cm9rZSIsImluY2x1ZGVEZWZhdWx0VmFsdWVzIiwibm9uU2NhbGluZyIsIl9wYXJzZVNoYWRvdyIsInNoYWRvdyIsInNoYWRvd1N0ciIsIm9mZnNldHNBbmRCbHVyIiwicmVPZmZzZXRzQW5kQmx1ciIsImZCb3hYIiwiZkJveFkiLCJCTFVSX0JPWCIsIlN0YXRpY0NhbnZhcyIsIkNBTlZBU19JTklUX0VSUk9SIiwiRXJyb3IiLCJyZW5kZXJBbmRSZXNldEJvdW5kIiwicmVuZGVyQW5kUmVzZXQiLCJyZXF1ZXN0UmVuZGVyQWxsQm91bmQiLCJfaW5pdFN0YXRpYyIsImJhY2tncm91bmRDb2xvciIsImJhY2tncm91bmRJbWFnZSIsIm92ZXJsYXlDb2xvciIsIm92ZXJsYXlJbWFnZSIsInN0YXRlZnVsIiwiY29udHJvbHNBYm92ZU92ZXJsYXkiLCJhbGxvd1RvdWNoU2Nyb2xsaW5nIiwidmlld3BvcnRUcmFuc2Zvcm0iLCJiYWNrZ3JvdW5kVnB0Iiwib3ZlcmxheVZwdCIsImVuYWJsZVJldGluYVNjYWxpbmciLCJ2cHRDb29yZHMiLCJza2lwT2Zmc2NyZWVuIiwiY2IiLCJfY3JlYXRlTG93ZXJDYW52YXMiLCJfaW5pdE9wdGlvbnMiLCJpbnRlcmFjdGl2ZSIsIl9pbml0UmV0aW5hU2NhbGluZyIsInNldE92ZXJsYXlJbWFnZSIsInNldEJhY2tncm91bmRJbWFnZSIsInNldEJhY2tncm91bmRDb2xvciIsInNldE92ZXJsYXlDb2xvciIsImNhbGNPZmZzZXQiLCJfaXNSZXRpbmFTY2FsaW5nIiwiZ2V0UmV0aW5hU2NhbGluZyIsInNjYWxlUmF0aW8iLCJfX2luaXRSZXRpbmFTY2FsaW5nIiwibG93ZXJDYW52YXNFbCIsImNvbnRleHRDb250YWluZXIiLCJ1cHBlckNhbnZhc0VsIiwiY29udGV4dFRvcCIsIl9vZmZzZXQiLCJpbWFnZSIsIl9fc2V0QmdPdmVybGF5SW1hZ2UiLCJfX3NldEJnT3ZlcmxheUNvbG9yIiwiX2NyZWF0ZUNhbnZhc0VsZW1lbnQiLCJfb3JpZ2luYWxDYW52YXNTdHlsZSIsIl9hcHBseUNhbnZhc1N0eWxlIiwiZ2V0V2lkdGgiLCJnZXRIZWlnaHQiLCJzZXRXaWR0aCIsInNldERpbWVuc2lvbnMiLCJzZXRIZWlnaHQiLCJkaW1lbnNpb25zIiwiY3NzVmFsdWUiLCJjc3NPbmx5IiwiX3NldEJhY2tzdG9yZURpbWVuc2lvbiIsImhhc0xvc3RDb250ZXh0IiwiYmFja3N0b3JlT25seSIsIl9zZXRDc3NEaW1lbnNpb24iLCJfaXNDdXJyZW50bHlEcmF3aW5nIiwiZnJlZURyYXdpbmdCcnVzaCIsIl9zZXRCcnVzaFN0eWxlcyIsImNhY2hlQ2FudmFzRWwiLCJ3cmFwcGVyRWwiLCJzZXRWaWV3cG9ydFRyYW5zZm9ybSIsInZwdCIsImFjdGl2ZU9iamVjdCIsIl9hY3RpdmVPYmplY3QiLCJiYWNrZ3JvdW5kT2JqZWN0Iiwib3ZlcmxheU9iamVjdCIsImdyb3VwIiwic2V0Q29vcmRzIiwiY2FsY1ZpZXdwb3J0Qm91bmRhcmllcyIsInpvb21Ub1BvaW50IiwiYmVmb3JlIiwiYWZ0ZXIiLCJzZXRab29tIiwiYWJzb2x1dGVQYW4iLCJyZWxhdGl2ZVBhbiIsImdldEVsZW1lbnQiLCJzZXR1cFN0YXRlIiwiY2xlYXJDb250ZXh0IiwiY2xlYXJSZWN0IiwiY2xlYXIiLCJfaGFzSVRleHRIYW5kbGVycyIsIl9tb3VzZVVwSVRleHRIYW5kbGVyIiwiX2lUZXh0SW5zdGFuY2VzIiwicmVuZGVyQWxsIiwiY2FudmFzVG9EcmF3T24iLCJyZW5kZXJDYW52YXMiLCJpc1JlbmRlcmluZyIsImlWcHQiLCJjYW5jZWxSZXF1ZXN0ZWRSZW5kZXIiLCJfcmVuZGVyQmFja2dyb3VuZCIsIl9yZW5kZXJPYmplY3RzIiwiZHJhd0NvbnRyb2xzIiwic2hvdWxkQ2FjaGUiLCJfdHJhbnNmb3JtRG9uZSIsInJlbmRlckNhY2hlIiwiZm9yQ2xpcHBpbmciLCJkcmF3Q2xpcFBhdGhPbkNhbnZhcyIsIl9yZW5kZXJPdmVybGF5IiwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIiwiem9vbVgiLCJ6b29tWSIsIl9jYWNoZUNhbnZhcyIsImNhY2hlVHJhbnNsYXRpb25YIiwiY2FjaGVUcmFuc2xhdGlvblkiLCJfcmVuZGVyQmFja2dyb3VuZE9yT3ZlcmxheSIsIm5lZWRzVnB0IiwibW92ZVRvIiwibGluZVRvIiwiY2xvc2VQYXRoIiwiZ2V0Q2VudGVyIiwiY2VudGVyT2JqZWN0SCIsIl9jZW50ZXJPYmplY3QiLCJjZW50ZXJPYmplY3RWIiwiY2VudGVyT2JqZWN0Iiwidmlld3BvcnRDZW50ZXJPYmplY3QiLCJ2cENlbnRlciIsImdldFZwQ2VudGVyIiwidmlld3BvcnRDZW50ZXJPYmplY3RIIiwidmlld3BvcnRDZW50ZXJPYmplY3RWIiwidG9EYXRhbGVzc0pTT04iLCJ0b0RhdGFsZXNzT2JqZWN0IiwiX3RvT2JqZWN0TWV0aG9kIiwiX3RvT2JqZWN0cyIsImV4Y2x1ZGVGcm9tRXhwb3J0IiwiX3RvT2JqZWN0IiwiX19zZXJpYWxpemVCZ092ZXJsYXkiLCJvcmlnaW5hbFZhbHVlIiwiYmdJbWFnZSIsImJnQ29sb3IiLCJiYWNrZ3JvdW5kIiwib3ZlcmxheSIsInN2Z1ZpZXdwb3J0VHJhbnNmb3JtYXRpb24iLCJfc2V0U1ZHUHJlYW1ibGUiLCJfc2V0U1ZHSGVhZGVyIiwiY2xpcFBhdGhJZCIsIl9zZXRTVkdCZ092ZXJsYXlDb2xvciIsIl9zZXRTVkdCZ092ZXJsYXlJbWFnZSIsIl9zZXRTVkdPYmplY3RzIiwic3VwcHJlc3NQcmVhbWJsZSIsImVuY29kaW5nIiwidmlld0JveCIsImNyZWF0ZVNWR0ZvbnRGYWNlc01hcmt1cCIsImNyZWF0ZVNWR1JlZkVsZW1lbnRzTWFya3VwIiwiY3JlYXRlU1ZHQ2xpcFBhdGhNYXJrdXAiLCJ0b0NsaXBQYXRoU1ZHIiwic2hvdWxkVHJhbnNmb3JtIiwiZm9udExpc3QiLCJyb3ciLCJyb3dJbmRleCIsIl9jaGFyIiwiX3NldFNWR09iamVjdCIsImZpbmFsV2lkdGgiLCJmaW5hbEhlaWdodCIsInNob3VsZEludmVydCIsInNlbmRUb0JhY2siLCJhY3RpdmVTZWxlY3Rpb24iLCJvYmpzIiwidW5zaGlmdCIsImJyaW5nVG9Gcm9udCIsInNlbmRCYWNrd2FyZHMiLCJpbnRlcnNlY3RpbmciLCJuZXdJZHgiLCJvYmpzTW92ZWQiLCJfZmluZE5ld0xvd2VySW5kZXgiLCJpc0ludGVyc2VjdGluZyIsImludGVyc2VjdHNXaXRoT2JqZWN0IiwiaXNDb250YWluZWRXaXRoaW5PYmplY3QiLCJicmluZ0ZvcndhcmQiLCJfZmluZE5ld1VwcGVySW5kZXgiLCJkaXNwb3NlIiwiY2xhc3NMaXN0IiwiRGF0YVVSTEV4cG9ydGVyIiwiRU1QVFlfSlNPTiIsInN1cHBvcnRzIiwic2V0TGluZURhc2giLCJ0b0pTT04iLCJjcmVhdGVQTkdTdHJlYW0iLCJjcmVhdGVKUEVHU3RyZWFtIiwiQmFzZUJydXNoIiwic3Ryb2tlTGluZUNhcCIsInN0cm9rZURhc2hBcnJheSIsImxpbWl0ZWRUb0NhbnZhc1NpemUiLCJsaW5lQ2FwIiwibWl0ZXJMaW1pdCIsImxpbmVKb2luIiwiX3NhdmVBbmRUcmFuc2Zvcm0iLCJfc2V0U2hhZG93Iiwic2hhZG93Q29sb3IiLCJzaGFkb3dCbHVyIiwic2hhZG93T2Zmc2V0WCIsInNoYWRvd09mZnNldFkiLCJuZWVkc0Z1bGxSZW5kZXIiLCJfcmVzZXRTaGFkb3ciLCJfaXNPdXRTaWRlQ2FudmFzIiwiUGVuY2lsQnJ1c2giLCJkZWNpbWF0ZSIsImRyYXdTdHJhaWdodExpbmUiLCJzdHJhaWdodExpbmVLZXkiLCJfcG9pbnRzIiwiX2hhc1N0cmFpZ2h0TGluZSIsIl9kcmF3U2VnbWVudCIsInF1YWRyYXRpY0N1cnZlVG8iLCJvbk1vdXNlRG93biIsIl9pc01haW5FdmVudCIsIl9wcmVwYXJlRm9yRHJhd2luZyIsIl9jYXB0dXJlRHJhd2luZ1BhdGgiLCJfcmVuZGVyIiwib25Nb3VzZU1vdmUiLCJvbGRFbmQiLCJvbk1vdXNlVXAiLCJfZmluYWxpemVBbmRBZGRQYXRoIiwiX3Jlc2V0IiwiX2FkZFBvaW50IiwicG9pbnRlclBvaW50IiwiY29udmVydFBvaW50c1RvU1ZHUGF0aCIsIl9pc0VtcHR5U1ZHUGF0aCIsImNyZWF0ZVBhdGgiLCJQYXRoIiwiZGVjaW1hdGVQb2ludHMiLCJhZGp1c3RlZERpc3RhbmNlIiwibGFzdFBvaW50IiwibmV3UG9pbnRzIiwiY0Rpc3RhbmNlIiwiQ2lyY2xlQnJ1c2giLCJkcmF3RG90IiwiYWRkUG9pbnQiLCJkb3QiLCJyYWRpdXMiLCJvcmlnaW5hbFJlbmRlck9uQWRkUmVtb3ZlIiwiY2lyY2xlcyIsImNpcmNsZSIsIkNpcmNsZSIsImNpcmNsZVJhZGl1cyIsImNpcmNsZUNvbG9yIiwiU3ByYXlCcnVzaCIsImRlbnNpdHkiLCJkb3RXaWR0aCIsImRvdFdpZHRoVmFyaWFuY2UiLCJyYW5kb21PcGFjaXR5Iiwib3B0aW1pemVPdmVybGFwcGluZyIsInNwcmF5Q2h1bmtzIiwiYWRkU3ByYXlDaHVuayIsInNwcmF5Q2h1bmtQb2ludHMiLCJyZWN0cyIsImlsZW4iLCJzcHJheUNodW5rIiwicmVjdCIsIlJlY3QiLCJfZ2V0T3B0aW1pemVkUmVjdHMiLCJ1bmlxdWVSZWN0cyIsInVuaXF1ZVJlY3RzQXJyYXkiLCJnbG9iYWxBbHBoYSIsImZpbGxSZWN0IiwiUGF0dGVybkJydXNoIiwiZ2V0UGF0dGVyblNyYyIsImRvdERpc3RhbmNlIiwicGF0dGVybkNhbnZhcyIsInBhdHRlcm5DdHgiLCJnZXRQYXR0ZXJuU3JjRnVuY3Rpb24iLCJTdHJpbmciLCJnZXRQYXR0ZXJuIiwidG9wTGVmdCIsIl9nZXRMZWZ0VG9wQ29vcmRzIiwiX2luaXRJbnRlcmFjdGl2ZSIsIl9jcmVhdGVDYWNoZUNhbnZhcyIsImNlbnRlcmVkU2NhbGluZyIsImNlbnRlcmVkUm90YXRpb24iLCJjZW50ZXJlZEtleSIsInNlbGVjdGlvbiIsInNlbGVjdGlvbktleSIsImFsdFNlbGVjdGlvbktleSIsInNlbGVjdGlvbkNvbG9yIiwic2VsZWN0aW9uRGFzaEFycmF5Iiwic2VsZWN0aW9uQm9yZGVyQ29sb3IiLCJzZWxlY3Rpb25MaW5lV2lkdGgiLCJzZWxlY3Rpb25GdWxseUNvbnRhaW5lZCIsImhvdmVyQ3Vyc29yIiwibW92ZUN1cnNvciIsImRlZmF1bHRDdXJzb3IiLCJmcmVlRHJhd2luZ0N1cnNvciIsIm5vdEFsbG93ZWRDdXJzb3IiLCJjb250YWluZXJDbGFzcyIsInBlclBpeGVsVGFyZ2V0RmluZCIsInRhcmdldEZpbmRUb2xlcmFuY2UiLCJza2lwVGFyZ2V0RmluZCIsImlzRHJhd2luZ01vZGUiLCJwcmVzZXJ2ZU9iamVjdFN0YWNraW5nIiwic3RvcENvbnRleHRNZW51IiwiZmlyZVJpZ2h0Q2xpY2siLCJmaXJlTWlkZGxlQ2xpY2siLCJ0YXJnZXRzIiwiZW5hYmxlUG9pbnRlckV2ZW50cyIsIl9ob3ZlcmVkVGFyZ2V0IiwiX2hvdmVyZWRUYXJnZXRzIiwiX2N1cnJlbnRUcmFuc2Zvcm0iLCJfZ3JvdXBTZWxlY3RvciIsIl9pbml0V3JhcHBlckVsZW1lbnQiLCJfY3JlYXRlVXBwZXJDYW52YXMiLCJfaW5pdEV2ZW50TGlzdGVuZXJzIiwiX2Nob29zZU9iamVjdHNUb1JlbmRlciIsImFjdGl2ZU9iamVjdHMiLCJnZXRBY3RpdmVPYmplY3RzIiwib2Jqc1RvUmVuZGVyIiwiYWN0aXZlR3JvdXBPYmplY3RzIiwiY29udGV4dFRvcERpcnR5IiwicmVuZGVyVG9wTGF5ZXIiLCJfZHJhd1NlbGVjdGlvbiIsInJlbmRlclRvcCIsIl9ub3JtYWxpemVQb2ludGVyIiwiaW52ZXJ0ZWRNIiwidnB0UG9pbnRlciIsInJlc3RvcmVQb2ludGVyVnB0IiwiaXNUYXJnZXRUcmFuc3BhcmVudCIsIm5vcm1hbGl6ZWRQb2ludGVyIiwidGFyZ2V0UmVsYXRpdmVYIiwidGFyZ2V0UmVsYXRpdmVZIiwiX2NhY2hlQ29udGV4dCIsImNvbnRleHRDYWNoZSIsIm9yaWdpbmFsQ29sb3IiLCJzZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IiLCJfaXNTZWxlY3Rpb25LZXlQcmVzc2VkIiwic2VsZWN0aW9uS2V5UHJlc3NlZCIsIl9zaG91bGRDbGVhclNlbGVjdGlvbiIsImV2ZW50ZWQiLCJzZWxlY3RhYmxlIiwiX3Nob3VsZENlbnRlclRyYW5zZm9ybSIsImFjdGlvbiIsImFsdEtleSIsImNlbnRlclRyYW5zZm9ybSIsIl9nZXRPcmlnaW5Gcm9tQ29ybmVyIiwiX2dldEFjdGlvbkZyb21Db3JuZXIiLCJhbHJlYWR5U2VsZWN0ZWQiLCJfc2V0dXBDdXJyZW50VHJhbnNmb3JtIiwiX19jb3JuZXIiLCJsYXN0WCIsImxhc3RZIiwic2hpZnRLZXkiLCJfYmVmb3JlVHJhbnNmb3JtIiwic2V0Q3Vyc29yIiwiY3Vyc29yIiwidmlld3BvcnRTdGFydCIsInZpZXdwb3J0RXh0ZW50IiwiZXh0ZW50Iiwic3Ryb2tlT2Zmc2V0IiwiX3NldExpbmVEYXNoIiwiZmluZFRhcmdldCIsInNraXBHcm91cCIsImlnbm9yZVpvb20iLCJhT2JqZWN0cyIsImFjdGl2ZVRhcmdldCIsImFjdGl2ZVRhcmdldFN1YnMiLCJzaG91bGRMb29rRm9yQWN0aXZlIiwiX2ZpbmRUYXJnZXRDb3JuZXIiLCJfc2VhcmNoUG9zc2libGVUYXJnZXRzIiwiX2NoZWNrVGFyZ2V0IiwiZ2xvYmFsUG9pbnRlciIsImNvbnRhaW5zUG9pbnQiLCJpc0VkaXRpbmciLCJzdWJUYXJnZXQiLCJvYmpUb0NoZWNrIiwicG9pbnRlclRvVXNlIiwic3ViVGFyZ2V0Q2hlY2siLCJfYWJzb2x1dGVQb2ludGVyIiwiX3BvaW50ZXIiLCJib3VuZHNXaWR0aCIsImJvdW5kc0hlaWdodCIsImNzc1NjYWxlIiwicmV0aW5hU2NhbGluZyIsImxvd2VyQ2FudmFzQ2xhc3MiLCJfY29weUNhbnZhc1N0eWxlIiwiZ2V0VG9wQ29udGV4dCIsImZyb21FbCIsInRvRWwiLCJnZXRTZWxlY3Rpb25Db250ZXh0IiwiZ2V0U2VsZWN0aW9uRWxlbWVudCIsImdldEFjdGl2ZU9iamVjdCIsImFjdGl2ZSIsIl9kaXNjYXJkQWN0aXZlT2JqZWN0IiwiX2ZpcmVTZWxlY3Rpb25FdmVudHMiLCJvbGRPYmplY3RzIiwic29tZXRoaW5nQ2hhbmdlZCIsImFkZGVkIiwicmVtb3ZlZCIsIm9sZE9iamVjdCIsInNlbGVjdGVkIiwiZGVzZWxlY3RlZCIsInNldEFjdGl2ZU9iamVjdCIsImN1cnJlbnRBY3RpdmVzIiwiX3NldEFjdGl2ZU9iamVjdCIsIm9uU2VsZWN0Iiwib25EZXNlbGVjdCIsImRpc2NhcmRBY3RpdmVPYmplY3QiLCJyZW1vdmVMaXN0ZW5lcnMiLCJfcmVuZGVyQ29udHJvbHMiLCJvcmlnaW5hbFByb3BlcnRpZXMiLCJfcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3QiLCJfdW53aW5kR3JvdXBUcmFuc2Zvcm1Pbk9iamVjdCIsImxheW91dFByb3BzIiwib3JpZ2luYWxWYWx1ZXMiLCJjbGVhckNvbnRleHRUb3AiLCJSSUdIVF9DTElDSyIsIk1JRERMRV9DTElDSyIsIkxFRlRfQ0xJQ0siLCJhZGRFdmVudE9wdGlvbnMiLCJwYXNzaXZlIiwiY2hlY2tDbGljayIsImJ1dHRvbiIsIm1haW5Ub3VjaElkIiwiX2JpbmRFdmVudHMiLCJhZGRPclJlbW92ZSIsIl9nZXRFdmVudFByZWZpeCIsImZ1bmN0b3IiLCJldmVudGpzRnVuY3RvciIsImNhbnZhc0VsZW1lbnQiLCJldmVudFR5cGVQcmVmaXgiLCJfb25SZXNpemUiLCJfb25Nb3VzZURvd24iLCJfb25Nb3VzZU1vdmUiLCJfb25Nb3VzZU91dCIsIl9vbk1vdXNlRW50ZXIiLCJfb25Nb3VzZVdoZWVsIiwiX29uQ29udGV4dE1lbnUiLCJfb25Eb3VibGVDbGljayIsIl9vbkRyYWdPdmVyIiwiX29uRHJhZ0VudGVyIiwiX29uRHJhZ0xlYXZlIiwiX29uRHJvcCIsIl9vblRvdWNoU3RhcnQiLCJldmVudGpzIiwiX29uR2VzdHVyZSIsIl9vbkRyYWciLCJfb25PcmllbnRhdGlvbkNoYW5nZSIsIl9vblNoYWtlIiwiX29uTG9uZ1ByZXNzIiwiX29uTW91c2VVcCIsIl9vblRvdWNoRW5kIiwiZXZlbnRzQm91bmQiLCJfc2ltcGxlRXZlbnRIYW5kbGVyIiwic2VsZiIsIl9fb25UcmFuc2Zvcm1HZXN0dXJlIiwiX19vbkRyYWciLCJfX29uTW91c2VXaGVlbCIsIl90YXJnZXQiLCJfX29uT3JpZW50YXRpb25DaGFuZ2UiLCJfX29uU2hha2UiLCJfX29uTG9uZ1ByZXNzIiwicHJldmVudERlZmF1bHQiLCJfZmlyZUVudGVyTGVhdmVFdmVudHMiLCJzdG9wUHJvcGFnYXRpb24iLCJfY2FjaGVUcmFuc2Zvcm1FdmVudERhdGEiLCJfaGFuZGxlRXZlbnQiLCJfcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEiLCJnZXRQb2ludGVySWQiLCJldnQiLCJpZGVudGlmaWVyIiwicG9pbnRlcklkIiwiaXNQcmltYXJ5IiwidG91Y2hlcyIsIl9fb25Nb3VzZURvd24iLCJfX29uTW91c2VVcCIsIl93aWxsQWRkTW91c2VEb3duIiwiX19vbk1vdXNlTW92ZSIsIl9zaG91bGRSZW5kZXIiLCJncm91cFNlbGVjdG9yIiwic2hvdWxkUmVuZGVyIiwiaXNDbGljayIsIl9vbk1vdXNlVXBJbkRyYXdpbmdNb2RlIiwiX2ZpbmFsaXplQ3VycmVudFRyYW5zZm9ybSIsInRhcmdldFdhc0FjdGl2ZSIsIl9tYXliZUdyb3VwT2JqZWN0cyIsImFjdGl2ZU9uIiwiaXNNb3ZpbmciLCJvcmlnaW5hbENvbnRyb2wiLCJvcmlnaW5hbE1vdXNlVXBIYW5kbGVyIiwiX3NldEN1cnNvckZyb21FdmVudCIsImV2ZW50VHlwZSIsInN1YlRhcmdldHMiLCJhYnNvbHV0ZVBvaW50ZXIiLCJjdXJyZW50VGFyZ2V0IiwiY3VycmVudFN1YlRhcmdldHMiLCJfc2NhbGluZyIsImhhc1N0YXRlQ2hhbmdlZCIsIl9maXJlIiwiX29uTW91c2VEb3duSW5EcmF3aW5nTW9kZSIsIl9vbk1vdXNlTW92ZUluRHJhd2luZ01vZGUiLCJfcHJldmlvdXNQb2ludGVyIiwic2hvdWxkR3JvdXAiLCJfc2hvdWxkR3JvdXAiLCJfaGFuZGxlR3JvdXBpbmciLCJzYXZlU3RhdGUiLCJfZmlyZU92ZXJPdXRFdmVudHMiLCJfdHJhbnNmb3JtT2JqZWN0IiwiZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzIiwib2xkVGFyZ2V0IiwiZXZ0T3V0IiwiY2FudmFzRXZ0T3V0IiwiZXZ0SW4iLCJjYW52YXNFdnRJbiIsIl9kcmFnZ2Vkb3ZlclRhcmdldCIsImNvbmZpZyIsImluT3B0Iiwib3V0T3B0Iiwib3V0RmlyZXMiLCJpbkZpcmVzIiwidGFyZ2V0Q2hhbmdlZCIsInByZXZpb3VzVGFyZ2V0IiwibmV4dFRhcmdldCIsInJlc2V0IiwiX3BlcmZvcm1UcmFuc2Zvcm1BY3Rpb24iLCJnZXRDb3JuZXJDdXJzb3IiLCJfdXBkYXRlQWN0aXZlU2VsZWN0aW9uIiwiX2NyZWF0ZUFjdGl2ZVNlbGVjdGlvbiIsImN1cnJlbnRBY3RpdmVPYmplY3RzIiwicmVtb3ZlV2l0aFVwZGF0ZSIsImFkZFdpdGhVcGRhdGUiLCJfY3JlYXRlR3JvdXAiLCJpc0FjdGl2ZUxvd2VyIiwiZ3JvdXBPYmplY3RzIiwiZXhpdEVkaXRpbmciLCJBY3RpdmVTZWxlY3Rpb24iLCJfZ3JvdXBTZWxlY3RlZE9iamVjdHMiLCJfY29sbGVjdE9iamVjdHMiLCJhR3JvdXAiLCJjdXJyZW50T2JqZWN0Iiwic2VsZWN0aW9uWDFZMSIsInNlbGVjdGlvblgyWTIiLCJhbGxvd0ludGVyc2VjdCIsImludGVyc2VjdHNXaXRoUmVjdCIsImlzQ29udGFpbmVkV2l0aGluUmVjdCIsInRvQ2FudmFzRWxlbWVudCIsImNyb3BwaW5nIiwic2NhbGVkV2lkdGgiLCJzY2FsZWRIZWlnaHQiLCJvcmlnaW5hbFdpZHRoIiwib3JpZ2luYWxIZWlnaHQiLCJuZXdab29tIiwidnAiLCJvcmlnaW5hbEludGVyYWN0aXZlIiwibmV3VnAiLCJvcmlnaW5hbFJldGluYSIsIm9yaWdpbmFsQ29udGV4dFRvcCIsImxvYWRGcm9tSlNPTiIsImpzb24iLCJzZXJpYWxpemVkIiwiSlNPTiIsIl9lbmxpdmVuT2JqZWN0cyIsIl9zZXRCZ092ZXJsYXkiLCJlbmxpdmVuZWRDYW52YXNDbGlwIiwiX19zZXR1cENhbnZhcyIsImxvYWRlZCIsImNiSWZMb2FkZWQiLCJfX3NldEJnT3ZlcmxheSIsImVubGl2ZWRPYmplY3QiLCJfdG9EYXRhVVJMIiwiX3RvRGF0YVVSTFdpdGhNdWx0aXBsaWVyIiwidG9EYXRhVVJMV2l0aE11bHRpcGxpZXIiLCJzdHJpbmdpZnkiLCJjbG9uZVdpdGhvdXREYXRhIiwiYmFja2dyb3VuZEltYWdlT3BhY2l0eSIsImJhY2tncm91bmRJbWFnZVN0cmV0Y2giLCJvYmplY3RDYWNoaW5nIiwiQUxJQVNJTkdfTElNSVQiLCJ0b3VjaENvcm5lclNpemUiLCJib3JkZXJDb2xvciIsImJvcmRlckRhc2hBcnJheSIsImNvcm5lckRhc2hBcnJheSIsInN0cm9rZURhc2hPZmZzZXQiLCJib3JkZXJPcGFjaXR5V2hlbk1vdmluZyIsImJvcmRlclNjYWxlRmFjdG9yIiwibWluU2NhbGVMaW1pdCIsImhhc0NvbnRyb2xzIiwiaGFzQm9yZGVycyIsImxvY2tNb3ZlbWVudFgiLCJsb2NrTW92ZW1lbnRZIiwic3RhdGVmdWxsQ2FjaGUiLCJub1NjYWxlQ2FjaGUiLCJkaXJ0eSIsInBhaW50Rmlyc3QiLCJzdGF0ZVByb3BlcnRpZXMiLCJjYWNoZVByb3BlcnRpZXMiLCJjb2xvclByb3BlcnRpZXMiLCJhYnNvbHV0ZVBvc2l0aW9uZWQiLCJfY2FjaGVQcm9wZXJ0aWVzIiwiX3VwZGF0ZUNhY2hlQ2FudmFzIiwiX2xpbWl0Q2FjaGVTaXplIiwiZGltcyIsImxpbWl0ZWREaW1zIiwiY2FwcGVkIiwiX2dldENhY2hlQ2FudmFzRGltZW5zaW9ucyIsIm9iamVjdFNjYWxlIiwiZ2V0VG90YWxPYmplY3RTY2FsaW5nIiwibmVlZGVkWCIsIm5lZWRlZFkiLCJ0YXJnZXRDYW52YXMiLCJtaW5DYWNoZVNpemUiLCJkcmF3aW5nV2lkdGgiLCJkcmF3aW5nSGVpZ2h0IiwiZGltZW5zaW9uc0NoYW5nZWQiLCJjYWNoZVdpZHRoIiwiY2FjaGVIZWlnaHQiLCJ6b29tQ2hhbmdlZCIsInNob3VsZFJlZHJhdyIsImFkZGl0aW9uYWxXaWR0aCIsImFkZGl0aW9uYWxIZWlnaHQiLCJzaG91bGRSZXNpemVDYW52YXMiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsInNpemVHcm93aW5nIiwic2l6ZVNocmlua2luZyIsImdldEhlaWdodE9mTGluZSIsInNldFRyYW5zZm9ybSIsIm5lZWRGdWxsVHJhbnNmb3JtIiwiX3JlbW92ZURlZmF1bHRWYWx1ZXMiLCJnZXRPYmplY3RTY2FsaW5nIiwicmV0aW5hIiwiZ2V0T2JqZWN0T3BhY2l0eSIsInNob3VsZENvbnN0cmFpblZhbHVlIiwiaXNDaGFuZ2VkIiwiZ3JvdXBOZWVkc1VwZGF0ZSIsIl9jb25zdHJhaW5TY2FsZSIsImlzT25BQ2FjaGUiLCJzZXRPbkdyb3VwIiwiZ2V0Vmlld3BvcnRUcmFuc2Zvcm0iLCJpc05vdFZpc2libGUiLCJpc09uU2NyZWVuIiwiX3NldHVwQ29tcG9zaXRlT3BlcmF0aW9uIiwiZHJhd1NlbGVjdGlvbkJhY2tncm91bmQiLCJfc2V0T3BhY2l0eSIsImRyYXdDYWNoZU9uQ2FudmFzIiwiX3JlbW92ZUNhY2hlQ2FudmFzIiwiZHJhd09iamVjdCIsInByb3BlcnR5U2V0IiwiaXNDYWNoZURpcnR5IiwiaGFzU3Ryb2tlIiwiaGFzRmlsbCIsIm5lZWRzSXRzT3duQ2FjaGUiLCJvd25DYWNoaW5nIiwid2lsbERyYXdTaGFkb3ciLCJkcmF3Q2xpcFBhdGhPbkNhY2hlIiwib3JpZ2luYWxGaWxsIiwib3JpZ2luYWxTdHJva2UiLCJfc2V0Q2xpcHBpbmdQcm9wZXJ0aWVzIiwiX2RyYXdDbGlwUGF0aCIsInNraXBDYW52YXMiLCJfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zIiwiX3JlbW92ZVNoYWRvdyIsIl9zZXRTdHJva2VTdHlsZXMiLCJkZWNsIiwibGluZURhc2hPZmZzZXQiLCJfYXBwbHlQYXR0ZXJuRm9yVHJhbnNmb3JtZWRHcmFkaWVudCIsIl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybSIsIl9zZXRGaWxsU3R5bGVzIiwiZGFzaEFycmF5IiwiZHJhd0JvcmRlcnMiLCJmb3JBY3RpdmVTZWxlY3Rpb24iLCJkcmF3Qm9yZGVyc0luR3JvdXAiLCJzY2FsaW5nIiwibXVsdFgiLCJtdWx0WSIsIl9yZW5kZXJQYWludEluT3JkZXIiLCJfcmVuZGVyU3Ryb2tlIiwiX3JlbmRlckZpbGwiLCJwQ2FudmFzIiwicEN0eCIsIl9maW5kQ2VudGVyRnJvbUVsZW1lbnQiLCJfYXNzaWduVHJhbnNmb3JtTWF0cml4UHJvcHMiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucyIsImNyb3BYIiwiY3JvcFkiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwib2JqZWN0Rm9ybSIsIl9mcm9tT2JqZWN0IiwiY2xvbmVBc0ltYWdlIiwidXRpbHMiLCJvcmlnUGFyYW1zIiwib3JpZ2luYWxHcm91cCIsIm9yaWdpbmFsU2hhZG93Iiwid2l0aG91dFRyYW5zZm9ybSIsIndpdGhvdXRTaGFkb3ciLCJib3VuZGluZ1JlY3QiLCJnZXRCb3VuZGluZ1JlY3QiLCJzaGFkb3dPZmZzZXQiLCJvcmlnaW5hbENhbnZhcyIsImlzVHlwZSIsImluY2x1ZGVzIiwic2hvdWxkQ2VudGVyT3JpZ2luIiwiX3NldE9yaWdpblRvQ2VudGVyIiwiX3Jlc2V0T3JpZ2luIiwiY2VudGVySCIsInZpZXdwb3J0Q2VudGVySCIsImNlbnRlclYiLCJ2aWV3cG9ydENlbnRlclYiLCJ2aWV3cG9ydENlbnRlciIsImdldExvY2FsUG9pbnRlciIsInBDbGlja2VkIiwib2JqZWN0TGVmdFRvcCIsImNyZWF0ZUFjY2Vzc29ycyIsImV4dHJhUGFyYW0iLCJvcmlnaW5YT2Zmc2V0Iiwib3JpZ2luWU9mZnNldCIsInRyYW5zbGF0ZVRvR2l2ZW5PcmlnaW4iLCJmcm9tT3JpZ2luWCIsImZyb21PcmlnaW5ZIiwidG9PcmlnaW5YIiwidG9PcmlnaW5ZIiwidHJhbnNsYXRlVG9DZW50ZXJQb2ludCIsImxlZnRUb3AiLCJnZXRQb2ludEJ5T3JpZ2luIiwiYWRqdXN0UG9zaXRpb24iLCJoeXBvdEZ1bGwiLCJnZXRTY2FsZWRXaWR0aCIsInhGdWxsIiwieUZ1bGwiLCJvZmZzZXRGcm9tIiwib2Zmc2V0VG8iLCJfb3JpZ2luYWxPcmlnaW5YIiwiX29yaWdpbmFsT3JpZ2luWSIsIm9yaWdpblBvaW50IiwiYXJyYXlGcm9tQ29vcmRzIiwibXVsdGlwbHlNYXRyaWNlcyIsIm9Db29yZHMiLCJhQ29vcmRzIiwibGluZUNvb3JkcyIsIm93bk1hdHJpeENhY2hlIiwibWF0cml4Q2FjaGUiLCJfZ2V0Q29vcmRzIiwiYWJzb2x1dGUiLCJjYWxjdWxhdGUiLCJjYWxjQUNvb3JkcyIsImNhbGNMaW5lQ29vcmRzIiwiZ2V0Q29vcmRzIiwicG9pbnRUTCIsInBvaW50QlIiLCJpbnRlcnNlY3Rpb24iLCJvdGhlciIsIm90aGVyQ29vcmRzIiwibGluZXMiLCJfZ2V0SW1hZ2VMaW5lcyIsIl9maW5kQ3Jvc3NQb2ludHMiLCJfY29udGFpbnNDZW50ZXJPZkNhbnZhcyIsImlzUGFydGlhbGx5T25TY3JlZW4iLCJhbGxQb2ludHNBcmVPdXRzaWRlIiwiZXZlcnkiLCJ0b3BsaW5lIiwicmlnaHRsaW5lIiwiYm90dG9tbGluZSIsImxlZnRsaW5lIiwieGkiLCJ4Y291bnQiLCJpTGluZSIsImxpbmVLZXkiLCJnZXRTY2FsZWRIZWlnaHQiLCJzY2FsZVRvV2lkdGgiLCJib3VuZGluZ1JlY3RGYWN0b3IiLCJzY2FsZVRvSGVpZ2h0IiwiY29zUCIsInNpblAiLCJjb3NQU2luUCIsImNvc1BNaW51c1NpblAiLCJjYWxjT0Nvb3JkcyIsIl9jYWxjUm90YXRlTWF0cml4IiwiX2NhbGNUcmFuc2xhdGVNYXRyaXgiLCJzdGFydE1hdHJpeCIsIl9jYWxjdWxhdGVDdXJyZW50RGltZW5zaW9ucyIsImZvckVhY2hDb250cm9sIiwidyIsInNraXBDb3JuZXJzIiwiX3NldENvcm5lckNvb3JkcyIsInRyYW5zZm9ybU1hdHJpeEtleSIsInNlcCIsInByZWZpeCIsImNhY2hlIiwidE1hdHJpeCIsIm5vU2tldyIsIl9maW5hbGl6ZURpbWVuc2lvbnMiLCJnZXRTdmdDb2xvclN0cmluZyIsImdldFN2Z1N0eWxlcyIsInNraXBTaGFkb3ciLCJnZXRTdmdGaWx0ZXIiLCJnZXRTdmdTcGFuU3R5bGVzIiwidXNlV2hpdGVTcGFjZSIsInRlcm0iLCJ0ZXh0RGVjb3JhdGlvbiIsImdldFN2Z1RleHREZWNvcmF0aW9uIiwiZGVjb3JhdGlvbiIsImdldFN2Z0NvbW1vbnMiLCJnZXRTdmdUcmFuc2Zvcm0iLCJmdWxsIiwic3ZnVHJhbnNmb3JtIiwiX3NldFNWR0JnIiwidGV4dEJnUmVjdHMiLCJfZ2V0RmlsbEF0dHJpYnV0ZXMiLCJfY3JlYXRlQmFzZVNWR01hcmt1cCIsIl90b1NWRyIsIl9jcmVhdGVCYXNlQ2xpcFBhdGhTVkdNYXJrdXAiLCJvYmplY3RNYXJrdXAiLCJjb21tb25QaWVjZXMiLCJub1N0eWxlIiwic3R5bGVJbmZvIiwic2hhZG93SW5mbyIsIndpdGhTaGFkb3ciLCJ2ZWN0b3JFZmZlY3QiLCJhYnNvbHV0ZUNsaXBQYXRoIiwiY2xpcFBhdGhNYXJrdXAiLCJhZGRQYWludE9yZGVyIiwib3JpZ2luYWxTZXQiLCJzYXZlUHJvcHMiLCJwcm9wcyIsInRtcE9iaiIsIl9pc0VxdWFsIiwib3JpZ1ZhbHVlIiwiZmlyc3RQYXNzIiwiZGFzaGVkUHJvcGVydHlTZXQiLCJmb3JUb3VjaCIsImlzQ29udHJvbFZpc2libGUiLCJ0b3VjaENvcm5lciIsImZuIiwiY29udHJvbE9iamVjdCIsIndoIiwic2hvdWxkU3Ryb2tlIiwic2V0Q29udHJvbFZpc2libGUiLCJzZXRDb250cm9sc1Zpc2liaWxpdHkiLCJGWF9EVVJBVElPTiIsImZ4Q2VudGVyT2JqZWN0SCIsImNhbGxiYWNrcyIsImVtcHR5IiwiZnhDZW50ZXJPYmplY3RWIiwiZnhSZW1vdmUiLCJwcm9wc1RvQW5pbWF0ZSIsInNraXBDYWxsYmFja3MiLCJvdXQiLCJfYW5pbWF0ZSIsInByb3BQYWlyIiwicHJvcElzQ29sb3IiLCJ2YWx1ZVByb2dyZXNzIiwidGltZVByb2dyZXNzIiwiY29vcmRQcm9wcyIsIkxpbmUiLCJfc2V0V2lkdGhIZWlnaHQiLCJfZ2V0TGVmdFRvT3JpZ2luWCIsIl9nZXRUb3BUb09yaWdpblkiLCJtYWtlRWRnZVRvT3JpZ2luR2V0dGVyIiwiYXhpczEiLCJheGlzMiIsImRpbWVuc2lvbiIsIm5lYXJlc3QiLCJmYXJ0aGVzdCIsImNhbGNMaW5lUG9pbnRzIiwib3JpZ1N0cm9rZVN0eWxlIiwieE11bHQiLCJ5TXVsdCIsIkFUVFJJQlVURV9OQU1FUyIsInBhcnNlZEF0dHJpYnV0ZXMiLCJfY2FsbGJhY2siLCJwcm9wZXJ0eU5hbWVzIiwib3JpZ2luVmFsdWVzIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwic2V0UmFkaXVzIiwic3ZnU3RyaW5nIiwic3RhcnRYIiwic3RhcnRZIiwiZW5kWCIsImVuZFkiLCJsYXJnZUZsYWciLCJnZXRSYWRpdXNYIiwiZ2V0UmFkaXVzWSIsImlzVmFsaWRSYWRpdXMiLCJUcmlhbmdsZSIsIndpZHRoQnkyIiwiaGVpZ2h0QnkyIiwicGlCeTIiLCJFbGxpcHNlIiwiZ2V0UngiLCJnZXRSeSIsIl9pbml0UnhSeSIsImlzUm91bmRlZCIsImJlemllckN1cnZlVG8iLCJQb2x5bGluZSIsImV4YWN0Qm91bmRpbmdCb3giLCJfc2V0UG9zaXRpb25EaW1lbnNpb25zIiwiX3Byb2plY3RTdHJva2VPblBvaW50cyIsImNhbGNEaW0iLCJfY2FsY0RpbWVuc2lvbnMiLCJjb3JyZWN0TGVmdFRvcCIsImNvcnJlY3RTaXplIiwiZnJvbVNWRyIsImRpZmZYIiwiZGlmZlkiLCJjb21tb25SZW5kZXIiLCJmcm9tRWxlbWVudEdlbmVyYXRvciIsIl9jbGFzcyIsIlBvbHlnb24iLCJfc2V0UGF0aCIsIl9yZW5kZXJQYXRoQ29tbWFuZHMiLCJzdWJwYXRoU3RhcnRYIiwic3VicGF0aFN0YXJ0WSIsIl9nZXRPZmZzZXRUcmFuc2Zvcm0iLCJkaWdpdHMiLCJhWCIsImFZIiwiZGVsdGFYIiwicGF0aFVybCIsImVsaXZlbmVkT2JqZWN0cyIsInVzZVNldE9uR3JvdXAiLCJpc0FscmVhZHlHcm91cGVkIiwiX2NhbGNCb3VuZHMiLCJfdXBkYXRlT2JqZWN0c0Nvb3JkcyIsIl91cGRhdGVPYmplY3RzQUNvb3JkcyIsInNraXBDb250cm9scyIsIl91cGRhdGVPYmplY3RDb29yZHMiLCJvYmplY3RMZWZ0Iiwib2JqZWN0VG9wIiwibmVzdGVkIiwiX3Jlc3RvcmVPYmplY3RzU3RhdGUiLCJfaW5jbHVkZURlZmF1bHRWYWx1ZXMiLCJvYmpzVG9PYmplY3QiLCJvcmlnaW5hbERlZmF1bHRzIiwiX29iaiIsIm93bkNhY2hlIiwiZ3JvdXBNYXRyaXgiLCJkZXN0cm95IiwidG9BY3RpdmVTZWxlY3Rpb24iLCJ1bmdyb3VwT25DYW52YXMiLCJzZXRPYmplY3RzQ29vcmRzIiwib25seVdpZHRoSGVpZ2h0IiwiaUxlbiIsImpMZW4iLCJfZ2V0Qm91bmRzIiwibWluWFkiLCJtYXhYWSIsInRvR3JvdXAiLCJuZXdHcm91cCIsImNoaWxkcmVuT3ZlcnJpZGUiLCJzcmNGcm9tQXR0cmlidXRlIiwiX2xhc3RTY2FsZVgiLCJfbGFzdFNjYWxlWSIsIl9maWx0ZXJTY2FsaW5nWCIsIl9maWx0ZXJTY2FsaW5nWSIsIm1pbmltdW1TY2FsZVRyaWdnZXIiLCJjYWNoZUtleSIsImltYWdlU21vb3RoaW5nIiwiZmlsdGVycyIsIl9pbml0RWxlbWVudCIsIl9lbGVtZW50Iiwic2V0RWxlbWVudCIsInJlbW92ZVRleHR1cmUiLCJfaW5pdENvbmZpZyIsImFwcGx5RmlsdGVycyIsInJlc2l6ZUZpbHRlciIsImFwcGx5UmVzaXplRmlsdGVycyIsImJhY2tlbmQiLCJmaWx0ZXJCYWNrZW5kIiwiZXZpY3RDYWNoZXNGb3JLZXkiLCJnZXRDcm9zc09yaWdpbiIsImdldE9yaWdpbmFsU2l6ZSIsIl9zdHJva2UiLCJmaWx0ZXJPYmoiLCJnZXRTcmMiLCJoYXNDcm9wIiwiaW1hZ2VNYXJrdXAiLCJzdHJva2VTdmciLCJpbWFnZVJlbmRlcmluZyIsImdldFN2Z1NyYyIsIm9yaWdGaWxsIiwiZmlsdGVyZWQiLCJzZXRTcmMiLCJtaW5pbXVtU2NhbGUiLCJlbGVtZW50VG9GaWx0ZXIiLCJfZmlsdGVyZWRFbCIsInNvdXJjZVdpZHRoIiwic291cmNlSGVpZ2h0IiwiaXNOZXV0cmFsU3RhdGUiLCJpbWdFbGVtZW50IiwiX25lZWRzUmVzaXplIiwiZWxlbWVudFRvRHJhdyIsImVsV2lkdGgiLCJlbEhlaWdodCIsInNYIiwic1kiLCJzVyIsInNIIiwibWF4RGVzdFciLCJtYXhEZXN0SCIsIl9yZXNldFdpZHRoSGVpZ2h0IiwiQ1NTX0NBTlZBUyIsIl9pbml0RmlsdGVycyIsInBBUiIsInJXaWR0aCIsInJIZWlnaHQiLCJwV2lkdGgiLCJwSGVpZ2h0IiwiX29iamVjdCIsInJlc2l6ZUZpbHRlcnMiLCJmcm9tVVJMIiwiaW1nT3B0aW9ucyIsIl9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbiIsInN0cmFpZ2h0ZW4iLCJmeFN0cmFpZ2h0ZW4iLCJzdHJhaWdodGVuT2JqZWN0IiwiZnhTdHJhaWdodGVuT2JqZWN0IiwidGVzdFByZWNpc2lvbiIsImdsIiwicHJlY2lzaW9uIiwiZnJhZ21lbnRTb3VyY2UiLCJmcmFnbWVudFNoYWRlciIsImNyZWF0ZVNoYWRlciIsIkZSQUdNRU5UX1NIQURFUiIsInNoYWRlclNvdXJjZSIsImNvbXBpbGVTaGFkZXIiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsImlzU3VwcG9ydGVkIiwiZ2V0UGFyYW1ldGVyIiwiTUFYX1RFWFRVUkVfU0laRSIsInByZWNpc2lvbnMiLCJ3ZWJHbFByZWNpc2lvbiIsInNldHVwR0xDb250ZXh0IiwiY2FwdHVyZUdQVUluZm8iLCJjcmVhdGVXZWJHTENhbnZhcyIsImFQb3NpdGlvbiIsIkZsb2F0MzJBcnJheSIsImNob29zZUZhc3Rlc3RDb3B5R0xUbzJETWV0aG9kIiwiY2FuTWVhc3VyZVBlcmYiLCJwZXJmb3JtYW5jZSIsImNhblVzZUltYWdlRGF0YSIsIkltYWdlRGF0YSIsImNhblVzZUFycmF5QnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJjYW5Vc2VVaW50OENsYW1wZWQiLCJVaW50OENsYW1wZWRBcnJheSIsImltYWdlQnVmZmVyIiwiY29weUdMVG8yRCIsImNvcHlHTFRvMkRQdXRJbWFnZURhdGEiLCJ0ZXN0Q29udGV4dCIsImRlc3RpbmF0aW9uV2lkdGgiLCJkZXN0aW5hdGlvbkhlaWdodCIsInN0YXJ0VGltZSIsImRyYXdJbWFnZVRpbWUiLCJwdXRJbWFnZURhdGFUaW1lIiwibm93IiwiY29weUdMVG8yRERyYXdJbWFnZSIsImdsT3B0aW9ucyIsInByZW11bHRpcGxpZWRBbHBoYSIsImRlcHRoIiwic3RlbmNpbCIsImFudGlhbGlhcyIsImNsZWFyQ29sb3IiLCJjYWNoZWRUZXh0dXJlIiwiZ2V0Q2FjaGVkVGV4dHVyZSIsInBpcGVsaW5lU3RhdGUiLCJzb3VyY2VUZXh0dXJlIiwiY3JlYXRlVGV4dHVyZSIsInRhcmdldFRleHR1cmUiLCJvcmlnaW5hbFRleHR1cmUiLCJwYXNzZXMiLCJ3ZWJnbCIsInByb2dyYW1DYWNoZSIsInBhc3MiLCJ0ZW1wRmJvIiwiY3JlYXRlRnJhbWVidWZmZXIiLCJiaW5kRnJhbWVidWZmZXIiLCJGUkFNRUJVRkZFUiIsImFwcGx5VG8iLCJyZXNpemVDYW52YXNJZk5lZWRlZCIsImJpbmRUZXh0dXJlIiwiVEVYVFVSRV8yRCIsImRlbGV0ZVRleHR1cmUiLCJkZWxldGVGcmFtZWJ1ZmZlciIsImNsZWFyV2ViR0xDYWNoZXMiLCJ0ZXh0dXJlQ2FjaGUiLCJ0ZXh0dXJlSW1hZ2VTb3VyY2UiLCJmaWx0ZXJUeXBlIiwidGV4dHVyZSIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX01BR19GSUxURVIiLCJORUFSRVNUIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwiVEVYVFVSRV9XUkFQX1MiLCJDTEFNUF9UT19FREdFIiwiVEVYVFVSRV9XUkFQX1QiLCJ0ZXhJbWFnZTJEIiwiUkdCQSIsIlVOU0lHTkVEX0JZVEUiLCJ1bmlxdWVJZCIsImdwdUluZm8iLCJyZW5kZXJlciIsInZlbmRvciIsImV4dCIsImdldEV4dGVuc2lvbiIsIlVOTUFTS0VEX1JFTkRFUkVSX1dFQkdMIiwiVU5NQVNLRURfVkVORE9SX1dFQkdMIiwiZFdpZHRoIiwiZEhlaWdodCIsImdsQ2FudmFzIiwic291cmNlWSIsIm51bUJ5dGVzIiwidTgiLCJVaW50OEFycmF5IiwidThDbGFtcGVkIiwicmVhZFBpeGVscyIsImltZ0RhdGEiLCJwdXRJbWFnZURhdGEiLCJzb3VyY2VFbGVtZW50Iiwib3JpZ2luYWxJbWFnZURhdGEiLCJvcmlnaW5hbEVsIiwiQmFzZUZpbHRlciIsInZlcnRleFNvdXJjZSIsImNyZWF0ZVByb2dyYW0iLCJ2ZXJ0ZXhTaGFkZXIiLCJWRVJURVhfU0hBREVSIiwiZ2V0U2hhZGVySW5mb0xvZyIsInByb2dyYW0iLCJhdHRhY2hTaGFkZXIiLCJsaW5rUHJvZ3JhbSIsImdldFByb2dyYW1QYXJhbWV0ZXIiLCJMSU5LX1NUQVRVUyIsImdldFByb2dyYW1JbmZvTG9nIiwiYXR0cmlidXRlTG9jYXRpb25zIiwiZ2V0QXR0cmlidXRlTG9jYXRpb25zIiwidW5pZm9ybUxvY2F0aW9ucyIsImdldFVuaWZvcm1Mb2NhdGlvbnMiLCJ1U3RlcFciLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJ1U3RlcEgiLCJnZXRBdHRyaWJMb2NhdGlvbiIsInNlbmRBdHRyaWJ1dGVEYXRhIiwiYVBvc2l0aW9uRGF0YSIsImF0dHJpYnV0ZUxvY2F0aW9uIiwiYnVmZmVyIiwiY3JlYXRlQnVmZmVyIiwiYmluZEJ1ZmZlciIsIkFSUkFZX0JVRkZFUiIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwidmVydGV4QXR0cmliUG9pbnRlciIsIkZMT0FUIiwiYnVmZmVyRGF0YSIsIlNUQVRJQ19EUkFXIiwiX3NldHVwRnJhbWVCdWZmZXIiLCJmcmFtZWJ1ZmZlclRleHR1cmUyRCIsIkNPTE9SX0FUVEFDSE1FTlQwIiwiX3N3YXBUZXh0dXJlcyIsIm1haW4iLCJtYWluUGFyYW1ldGVyIiwiYXBwbHlUb1dlYkdMIiwiYXBwbHlUbzJkIiwicmV0cmlldmVTaGFkZXIiLCJzaGFkZXIiLCJ1c2VQcm9ncmFtIiwidW5pZm9ybTFmIiwic2VuZFVuaWZvcm1EYXRhIiwidmlld3BvcnQiLCJkcmF3QXJyYXlzIiwiVFJJQU5HTEVfU1RSSVAiLCJiaW5kQWRkaXRpb25hbFRleHR1cmUiLCJ0ZXh0dXJlVW5pdCIsImFjdGl2ZVRleHR1cmUiLCJURVhUVVJFMCIsInVuYmluZEFkZGl0aW9uYWxUZXh0dXJlIiwiZ2V0TWFpblBhcmFtZXRlciIsInNldE1haW5QYXJhbWV0ZXIiLCJjcmVhdGVIZWxwTGF5ZXIiLCJoZWxwTGF5ZXIiLCJtYWluUCIsIkNvbG9yTWF0cml4IiwiY29sb3JzT25seSIsInVDb2xvck1hdHJpeCIsInVDb25zdGFudHMiLCJjb25zdGFudHMiLCJ1bmlmb3JtTWF0cml4NGZ2IiwidW5pZm9ybTRmdiIsIkJyaWdodG5lc3MiLCJicmlnaHRuZXNzIiwidUJyaWdodG5lc3MiLCJDb252b2x1dGUiLCJvcGFxdWUiLCJDb252b2x1dGVfM18xIiwiQ29udm9sdXRlXzNfMCIsIkNvbnZvbHV0ZV81XzEiLCJDb252b2x1dGVfNV8wIiwiQ29udm9sdXRlXzdfMSIsIkNvbnZvbHV0ZV83XzAiLCJDb252b2x1dGVfOV8xIiwiQ29udm9sdXRlXzlfMCIsIndlaWdodHMiLCJzaWRlIiwiaGFsZlNpZGUiLCJzdyIsInNoIiwib3V0cHV0IiwiY3JlYXRlSW1hZ2VEYXRhIiwiZHN0IiwiYWxwaGFGYWMiLCJkc3RPZmYiLCJzY3giLCJzY3kiLCJzcmNPZmYiLCJ3dCIsInVNYXRyaXgiLCJ1T3BhcXVlIiwidUhhbGZTaXplIiwidVNpemUiLCJ1bmlmb3JtMWZ2IiwiR3JheXNjYWxlIiwibGlnaHRuZXNzIiwibHVtaW5vc2l0eSIsIm1vZGUiLCJ1TW9kZSIsInVuaWZvcm0xaSIsIkludmVydCIsImludmVydCIsInVJbnZlcnQiLCJOb2lzZSIsIm5vaXNlIiwicmFuZCIsInVOb2lzZSIsInVTZWVkIiwiUGl4ZWxhdGUiLCJibG9ja3NpemUiLCJfaSIsIl9qIiwiX2lMZW4iLCJfakxlbiIsInVCbG9ja3NpemUiLCJSZW1vdmVDb2xvciIsInVzZUFscGhhIiwibG93QyIsImhpZ2hDIiwidUxvdyIsInVIaWdoIiwiQnJvd25pZSIsIlZpbnRhZ2UiLCJLb2RhY2hyb21lIiwiVGVjaG5pY29sb3IiLCJQb2xhcm9pZCIsIlNlcGlhIiwiQmxhY2tXaGl0ZSIsIkJsZW5kQ29sb3IiLCJzY3JlZW4iLCJkaWZmIiwibGlnaHRlbiIsImRhcmtlbiIsImV4Y2x1c2lvbiIsInRpbnQiLCJidWlsZFNvdXJjZSIsInRnIiwiYWxwaGExIiwidUNvbG9yIiwiQmxlbmRJbWFnZSIsIm1hc2siLCJURVhUVVJFMSIsImNhbGN1bGF0ZU1hdHJpeCIsImNhbnZhczEiLCJibGVuZERhdGEiLCJibGVuZEltYWdlIiwidVRyYW5zZm9ybU1hdHJpeCIsInVJbWFnZSIsInVuaWZvcm1NYXRyaXgzZnYiLCJSZXNpemUiLCJyZXNpemVUeXBlIiwibGFuY3pvc0xvYmVzIiwidURlbHRhIiwidVRhcHMiLCJ1bmlmb3JtMmZ2IiwiaG9yaXpvbnRhbCIsInRhcHMiLCJmaWx0ZXJXaW5kb3ciLCJnZXRGaWx0ZXJXaW5kb3ciLCJnZW5lcmF0ZVNoYWRlciIsInRlbXBTY2FsZSIsImdldFRhcHMiLCJsb2JlRnVuY3Rpb24iLCJsYW5jem9zQ3JlYXRlIiwib2Zmc2V0cyIsImZyYWdtZW50U291cmNlVE9QIiwiZFciLCJkSCIsImxvYmVzIiwieHgiLCJyY3BTY2FsZVgiLCJyY3BTY2FsZVkiLCJvVyIsIm9IIiwibmV3RGF0YSIsInNsaWNlQnlUd28iLCJoZXJtaXRlRmFzdFJlc2l6ZSIsImJpbGluZWFyRmlsdGVyaW5nIiwibGFuY3pvc1Jlc2l6ZSIsIm11bHQiLCJkb25lVyIsImRvbmVIIiwic3RlcFciLCJzdGVwSCIsInRtcENhbnZhcyIsImRYIiwiZFkiLCJwcm9jZXNzIiwidSIsIndlaWdodCIsImZYIiwiZlkiLCJyYXRpb1giLCJpY2VudGVyIiwicmF0aW9ZIiwicmFuZ2UyWCIsImNhY2hlTGFuYyIsInJhbmdlMlkiLCJsYW5jem9zIiwicmNwUmF0aW9YIiwicmNwUmF0aW9ZIiwic3JjRGF0YSIsImRlc3REYXRhIiwiZGVzdEltZyIsInhEaWZmIiwieURpZmYiLCJjaG5sIiwib3JpZ1BpeCIsInc0IiwicGl4ZWxzIiwiZGVzdEltYWdlIiwiZGVzdFBpeGVscyIsInJhdGlvVyIsInJhdGlvSCIsInJhdGlvV0hhbGYiLCJyYXRpb0hIYWxmIiwiaW1nMiIsImRhdGEyIiwid2VpZ2h0c0FscGhhIiwiZ3hSIiwiZ3hHIiwiZ3hCIiwiZ3hBIiwieXkiLCJ3MCIsIkNvbnRyYXN0IiwiY29udHJhc3QiLCJjb250cmFzdEYiLCJ1Q29udHJhc3QiLCJTYXR1cmF0aW9uIiwic2F0dXJhdGlvbiIsImFkanVzdCIsInVTYXR1cmF0aW9uIiwiVmlicmFuY2UiLCJ2aWJyYW5jZSIsImF2ZyIsImFtdCIsInVWaWJyYW5jZSIsIkJsdXIiLCJhc3BlY3RSYXRpbyIsInNpbXBsZUJsdXIiLCJjYW52YXMyIiwiYmx1ckxheWVyMSIsImJsdXJMYXllcjIiLCJjdHgxIiwiY3R4MiIsIm5TYW1wbGVzIiwicGVyY2VudCIsIm5ld0ltYWdlRGF0YSIsImRlbHRhIiwiY2hvb3NlUmlnaHREZWx0YSIsImJsdXJTY2FsZSIsIkdhbW1hIiwiZ2FtbWEiLCJySW52IiwiZ0ludiIsImJJbnYiLCJyVmFscyIsImdWYWxzIiwiYlZhbHMiLCJ1R2FtbWEiLCJ1bmlmb3JtM2Z2IiwiQ29tcG9zZWQiLCJzdWJGaWx0ZXJzIiwiSHVlUm90YXRpb24iLCJyb3RhdGlvbiIsInJhZCIsImFUaGlyZCIsImFUaGlyZFNxdFNpbiIsIk9uZU1pbnVzQ29zIiwiYWRkaXRpb25hbFByb3BzIiwiX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzIiwiX3JlTmV3bGluZSIsIl9yZVNwYWNlc0FuZFRhYnMiLCJfcmVTcGFjZUFuZFRhYiIsIl9yZVdvcmRzIiwidGV4dEFsaWduIiwic3VwZXJzY3JpcHQiLCJiYXNlbGluZSIsInN1YnNjcmlwdCIsInBhdGhTdGFydE9mZnNldCIsInBhdGhTaWRlIiwicGF0aEFsaWduIiwiX2ZvbnRTaXplRnJhY3Rpb24iLCJfZm9udFNpemVNdWx0IiwiY2hhclNwYWNpbmciLCJfbWVhc3VyaW5nQ29udGV4dCIsImRpcmVjdGlvbiIsIl9zdHlsZVByb3BlcnRpZXMiLCJfX2NoYXJCb3VuZHMiLCJDQUNIRV9GT05UX1NJWkUiLCJNSU5fVEVYVF9XSURUSCIsIl9fc2tpcERpbWVuc2lvbiIsInNldFBhdGhJbmZvIiwiaW5pdERpbWVuc2lvbnMiLCJzZWdtZW50c0luZm8iLCJnZXRNZWFzdXJpbmdDb250ZXh0IiwiX3NwbGl0VGV4dCIsIm5ld0xpbmVzIiwiX3NwbGl0VGV4dEludG9MaW5lcyIsIl90ZXh0TGluZXMiLCJncmFwaGVtZUxpbmVzIiwiX3Vud3JhcHBlZFRleHRMaW5lcyIsIl91bndyYXBwZWRMaW5lcyIsIl90ZXh0IiwiZ3JhcGhlbWVUZXh0IiwiX2NsZWFyQ2FjaGUiLCJjYWxjVGV4dFdpZHRoIiwiY3Vyc29yV2lkdGgiLCJjYWxjVGV4dEhlaWdodCIsImVubGFyZ2VTcGFjZXMiLCJkaWZmU3BhY2UiLCJjdXJyZW50TGluZVdpZHRoIiwibnVtYmVyT2ZTcGFjZXMiLCJhY2N1bXVsYXRlZFNwYWNlIiwibGluZSIsImNoYXJCb3VuZCIsInNwYWNlcyIsImlzRW5kT2ZXcmFwcGluZyIsImdldExpbmVXaWR0aCIsImtlcm5lZFdpZHRoIiwibGluZUluZGV4IiwibWlzc2luZ05ld2xpbmVPZmZzZXQiLCJfc2V0VGV4dFN0eWxlcyIsIl9yZW5kZXJUZXh0TGluZXNCYWNrZ3JvdW5kIiwiX3JlbmRlclRleHREZWNvcmF0aW9uIiwiX3JlbmRlclRleHQiLCJfcmVuZGVyVGV4dFN0cm9rZSIsIl9yZW5kZXJUZXh0RmlsbCIsImNoYXJTdHlsZSIsImZvck1lYXN1cmluZyIsInRleHRCYXNlbGluZSIsIl9nZXRGb250RGVjbGFyYXRpb24iLCJtYXhXaWR0aCIsIl9yZW5kZXJUZXh0TGluZSIsIl9yZW5kZXJDaGFycyIsInN0eWxlSGFzIiwiaGVpZ2h0T2ZMaW5lIiwibGluZUxlZnRPZmZzZXQiLCJsYXN0Q29sb3IiLCJsZWZ0T2Zmc2V0IiwiX2dldExlZnRPZmZzZXQiLCJsaW5lVG9wT2Zmc2V0IiwiX2dldFRvcE9mZnNldCIsImJveFN0YXJ0IiwiYm94V2lkdGgiLCJjaGFyQm94IiwiY3VycmVudENvbG9yIiwiZHJhd1N0YXJ0IiwiX2dldExpbmVMZWZ0T2Zmc2V0IiwiZ2V0VmFsdWVPZlByb3BlcnR5QXQiLCJyZW5kZXJMZWZ0IiwiZ2V0Rm9udENhY2hlIiwiY2FjaGVQcm9wIiwiX21lYXN1cmVDaGFyIiwicHJldmlvdXNDaGFyIiwicHJldkNoYXJTdHlsZSIsImZvbnRDYWNoZSIsImZvbnREZWNsYXJhdGlvbiIsInByZXZpb3VzRm9udERlY2xhcmF0aW9uIiwiY291cGxlIiwic3R5bGVzQXJlRXF1YWwiLCJjb3VwbGVXaWR0aCIsInByZXZpb3VzV2lkdGgiLCJmb250TXVsdGlwbGllciIsIm1lYXN1cmVUZXh0IiwiZ2V0SGVpZ2h0T2ZDaGFyIiwibWVhc3VyZUxpbmUiLCJsaW5lSW5mbyIsIl9tZWFzdXJlTGluZSIsIl9nZXRXaWR0aE9mQ2hhclNwYWNpbmciLCJncmFwaGVtZSIsInByZXZHcmFwaGVtZSIsImdyYXBoZW1lSW5mbyIsIm51bU9mU3BhY2VzIiwibGluZUJvdW5kcyIsInBvc2l0aW9uSW5QYXRoIiwic3RhcnRpbmdQb2ludCIsInRvdGFsUGF0aExlbmd0aCIsIl9nZXRHcmFwaGVtZUJveCIsIl9zZXRHcmFwaGVtZU9uUGF0aCIsImNlbnRlclBvc2l0aW9uIiwic2tpcExlZnQiLCJnZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24iLCJwcmV2aW91c0JveCIsIl9fbGluZUhlaWdodHMiLCJtYXhIZWlnaHQiLCJfcmVuZGVyVGV4dENvbW1vbiIsImxpbmVIZWlnaHRzIiwiaXNFbXB0eVN0eWxlcyIsImlzSnVzdGlmeSIsImFjdHVhbFN0eWxlIiwibmV4dFN0eWxlIiwiY2hhcnNUb1JlbmRlciIsInRpbWVUb1JlbmRlciIsInNob3J0Q3V0IiwiaXNMdHIiLCJkcmF3aW5nTGVmdCIsImN1cnJlbnREaXJlY3Rpb24iLCJfcmVuZGVyQ2hhciIsIl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybVRleHQiLCJoYW5kbGVGaWxsZXIiLCJfZ2V0U3R5bGVEZWNsYXJhdGlvbiIsImZ1bGxEZWNsIiwic2hvdWxkRmlsbCIsImZpbGxPZmZzZXRzIiwic3Ryb2tlT2Zmc2V0cyIsImZpbGxUZXh0Iiwic3Ryb2tlVGV4dCIsInNldFN1cGVyc2NyaXB0IiwiX3NldFNjcmlwdCIsInNldFN1YnNjcmlwdCIsInNjaGVtYSIsImxvYyIsImdldDJEQ3Vyc29yTG9jYXRpb24iLCJzZXRTZWxlY3Rpb25TdHlsZXMiLCJsaW5lRGlmZiIsIl9fbGluZVdpZHRocyIsIl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlIiwic2hvdWxkQ2xlYXIiLCJfZm9yY2VDbGVhckNhY2hlIiwiX3NpemUiLCJfZHkiLCJsYXN0RGVjb3JhdGlvbiIsInRvcE9mZnNldCIsImN1cnJlbnREZWNvcmF0aW9uIiwiY3VycmVudEZpbGwiLCJsYXN0RmlsbCIsInN0eWxlT2JqZWN0IiwiZmFtaWx5IiwiZm9udElzR2VuZXJpYyIsImdlbmVyaWNGb250cyIsIm5ld0xpbmUiLCJuZXdUZXh0IiwiYWxsUHJvcGVydGllcyIsIm5lZWRzRGltcyIsImlzQWRkaW5nUGF0aCIsIl9rZXkiLCJwYXJzZWRBbmNob3IiLCJ0ZXh0QW5jaG9yIiwib3JpZ2luYWxTdHJva2VXaWR0aCIsInRleHRIZWlnaHRTY2FsZUZhY3RvciIsImxpbmVIZWlnaHREaWZmIiwic2NhbGVkRGlmZiIsInRleHRIZWlnaHQiLCJvZmZYIiwib2JqZWN0Q29weSIsInRleHRJbnN0YW5jZSIsInBhdGhJbnN0YW5jZSIsInAzIiwiY2xlYW5TdHlsZSIsInN0eWxlc0NvdW50IiwibGV0dGVyQ291bnQiLCJzdHlsZVByb3BlcnR5VmFsdWUiLCJhbGxTdHlsZU9iamVjdFByb3BlcnRpZXNNYXRjaCIsImdyYXBoZW1lQ291bnQiLCJzdHlsZVByb3BlcnR5SGFzQmVlblNldCIsInJlbW92ZVN0eWxlIiwibGluZU51bSIsImNoYXJOdW0iLCJfZXh0ZW5kU3R5bGVzIiwiX2dldExpbmVTdHlsZSIsIl9zZXRMaW5lU3R5bGUiLCJfc2V0U3R5bGVEZWNsYXJhdGlvbiIsInNlbGVjdGlvblN0YXJ0Iiwic2tpcFdyYXBwaW5nIiwiZ2V0U2VsZWN0aW9uU3R5bGVzIiwic3RhcnRJbmRleCIsImVuZEluZGV4Iiwic2VsZWN0aW9uRW5kIiwiZ2V0U3R5bGVBdFBvc2l0aW9uIiwibGluZVN0eWxlIiwiX2RlbGV0ZVN0eWxlRGVjbGFyYXRpb24iLCJfZGVsZXRlTGluZVN0eWxlIiwicGFyc2VEZWNvcmF0aW9uIiwiSVRleHQiLCJlZGl0YWJsZSIsImVkaXRpbmdCb3JkZXJDb2xvciIsImN1cnNvckNvbG9yIiwiY3Vyc29yRGVsYXkiLCJjdXJzb3JEdXJhdGlvbiIsImNhY2hpbmciLCJoaWRkZW5UZXh0YXJlYUNvbnRhaW5lciIsIl9yZVNwYWNlIiwiX2N1cnJlbnRDdXJzb3JPcGFjaXR5IiwiX3NlbGVjdGlvbkRpcmVjdGlvbiIsIl9hYm9ydEN1cnNvckFuaW1hdGlvbiIsIl9fd2lkdGhPZlNwYWNlIiwiaW5Db21wb3NpdGlvbk1vZGUiLCJpbml0QmVoYXZpb3IiLCJzZXRTZWxlY3Rpb25TdGFydCIsIl91cGRhdGVBbmRGaXJlIiwic2V0U2VsZWN0aW9uRW5kIiwiX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkIiwiX3VwZGF0ZVRleHRhcmVhIiwiaW5pdERlbGF5ZWRDdXJzb3IiLCJjdXJzb3JPZmZzZXRDYWNoZSIsInJlbmRlckN1cnNvck9yU2VsZWN0aW9uIiwic2tpcFJlc3RvcmUiLCJfY2xlYXJUZXh0QXJlYSIsImJvdW5kYXJpZXMiLCJfZ2V0Q3Vyc29yQm91bmRhcmllcyIsInJlbmRlckN1cnNvciIsInJlbmRlclNlbGVjdGlvbiIsIl9nZXRDdXJzb3JCb3VuZGFyaWVzT2Zmc2V0cyIsImN1cnNvclBvc2l0aW9uIiwiYm91bmQiLCJjdXJzb3JMb2NhdGlvbiIsImNoYXJIZWlnaHQiLCJfX2lzTW91c2Vkb3duIiwiaGlkZGVuVGV4dGFyZWEiLCJzdGFydExpbmUiLCJlbmRMaW5lIiwic3RhcnRDaGFyIiwiZW5kQ2hhciIsImxpbmVPZmZzZXQiLCJyZWFsTGluZUhlaWdodCIsImJveEVuZCIsImRyYXdXaWR0aCIsImRyYXdIZWlnaHQiLCJleHRyYVRvcCIsImNvbXBvc2l0aW9uQ29sb3IiLCJnZXRDdXJyZW50Q2hhckZvbnRTaXplIiwiY3AiLCJfZ2V0Q3VycmVudENoYXJJbmRleCIsImdldEN1cnJlbnRDaGFyQ29sb3IiLCJvYmpDb3B5IiwiaW5pdEFkZGVkSGFuZGxlciIsImluaXRSZW1vdmVkSGFuZGxlciIsImluaXRDdXJzb3JTZWxlY3Rpb25IYW5kbGVycyIsImluaXREb3VibGVDbGlja1NpbXVsYXRpb24iLCJtb3VzZU1vdmVIYW5kbGVyIiwiX2luaXRDYW52YXNIYW5kbGVycyIsIl9yZW1vdmVDYW52YXNIYW5kbGVycyIsIl90aWNrIiwiX2N1cnJlbnRUaWNrU3RhdGUiLCJfYW5pbWF0ZUN1cnNvciIsInRhcmdldE9wYWNpdHkiLCJjb21wbGV0ZU1ldGhvZCIsInRpY2tTdGF0ZSIsImlzQWJvcnRlZCIsIl9vblRpY2tDb21wbGV0ZSIsIl9jdXJzb3JUaW1lb3V0MSIsIl9jdXJyZW50VGlja0NvbXBsZXRlU3RhdGUiLCJyZXN0YXJ0IiwiZGVsYXkiLCJhYm9ydEN1cnNvckFuaW1hdGlvbiIsIl9jdXJzb3JUaW1lb3V0MiIsInNlbGVjdEFsbCIsImdldFNlbGVjdGVkVGV4dCIsImZpbmRXb3JkQm91bmRhcnlMZWZ0Iiwic3RhcnRGcm9tIiwiZmluZFdvcmRCb3VuZGFyeVJpZ2h0IiwiZmluZExpbmVCb3VuZGFyeUxlZnQiLCJmaW5kTGluZUJvdW5kYXJ5UmlnaHQiLCJzZWFyY2hXb3JkQm91bmRhcnkiLCJzZWxlY3RXb3JkIiwibmV3U2VsZWN0aW9uU3RhcnQiLCJuZXdTZWxlY3Rpb25FbmQiLCJzZWxlY3RMaW5lIiwiZW50ZXJFZGl0aW5nIiwiZXhpdEVkaXRpbmdPbk90aGVycyIsImluaXRIaWRkZW5UZXh0YXJlYSIsImZvY3VzIiwiX3NhdmVFZGl0aW5nUHJvcHMiLCJfc2V0RWRpdGluZ1Byb3BzIiwiX3RleHRCZWZvcmVFZGl0IiwiaW5pdE1vdXNlTW92ZUhhbmRsZXIiLCJhY3RpdmVFbGVtZW50IiwiZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlciIsImN1cnJlbnRTdGFydCIsImN1cnJlbnRFbmQiLCJfX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd24iLCJyZXN0YXJ0Q3Vyc29ySWZOZWVkZWQiLCJmcm9tU3RyaW5nVG9HcmFwaGVtZVNlbGVjdGlvbiIsInNtYWxsZXJUZXh0U3RhcnQiLCJncmFwaGVtZVN0YXJ0Iiwic21hbGxlclRleHRFbmQiLCJncmFwaGVtZUVuZCIsImZyb21HcmFwaGVtZVRvU3RyaW5nU2VsZWN0aW9uIiwibmV3U2VsZWN0aW9uIiwidXBkYXRlVGV4dGFyZWFQb3NpdGlvbiIsInVwZGF0ZUZyb21UZXh0QXJlYSIsIl9jYWxjVGV4dGFyZWFQb3NpdGlvbiIsImRlc2lyZWRQb3NpdGlvbiIsImNvbXBvc2l0aW9uU3RhcnQiLCJ1cHBlckNhbnZhcyIsInVwcGVyQ2FudmFzV2lkdGgiLCJ1cHBlckNhbnZhc0hlaWdodCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiX3NhdmVkUHJvcHMiLCJfcmVzdG9yZUVkaXRpbmdQcm9wcyIsImlzVGV4dENoYW5nZWQiLCJfcmVtb3ZlRXh0cmFuZW91c1N0eWxlcyIsInJlbW92ZVN0eWxlRnJvbVRvIiwiY3Vyc29yU3RhcnQiLCJjdXJzb3JFbmQiLCJsaW5lU3RhcnQiLCJjaGFyU3RhcnQiLCJsaW5lRW5kIiwiY2hhckVuZCIsInN0eWxlT2JqIiwic2hpZnRMaW5lU3R5bGVzIiwibnVtZXJpY0NoYXIiLCJjbG9uZWRTdHlsZXMiLCJudW1lcmljTGluZSIsImluc2VydE5ld2xpbmVTdHlsZU9iamVjdCIsInF0eSIsImNvcGllZFN0eWxlIiwiY3VycmVudENoYXJTdHlsZSIsIm5ld0xpbmVTdHlsZXMiLCJzb21ldGhpbmdBZGRlZCIsImlzRW5kT2ZMaW5lIiwibnVtSW5kZXgiLCJzdHlsZUNhcnJpZWRPdmVyIiwiaW5zZXJ0Q2hhclN0eWxlT2JqZWN0IiwicXVhbnRpdHkiLCJjdXJyZW50TGluZVN0eWxlcyIsImN1cnJlbnRMaW5lU3R5bGVzQ2xvbmVkIiwibnVtZXJpY0luZGV4IiwibmV3U3R5bGUiLCJpbnNlcnROZXdTdHlsZUJsb2NrIiwiaW5zZXJ0ZWRUZXh0IiwiY3Vyc29yTG9jIiwiYWRkZWRMaW5lcyIsImxpbmVzTGVuZ3RoIiwic2V0U2VsZWN0aW9uU3RhcnRFbmRXaXRoU2hpZnQiLCJzZXRTZWxlY3Rpb25JbkJvdW5kYXJpZXMiLCJfX2xhc3RDbGlja1RpbWUiLCJfX2xhc3RMYXN0Q2xpY2tUaW1lIiwiX19sYXN0UG9pbnRlciIsIl9fbmV3Q2xpY2tUaW1lIiwibmV3UG9pbnRlciIsImlzVHJpcGxlQ2xpY2siLCJfc3RvcEV2ZW50IiwiX19sYXN0SXNFZGl0aW5nIiwiX19sYXN0U2VsZWN0ZWQiLCJpbml0TW91c2Vkb3duSGFuZGxlciIsImluaXRNb3VzZXVwSGFuZGxlciIsImluaXRDbGlja3MiLCJkb3VibGVDbGlja0hhbmRsZXIiLCJ0cmlwbGVDbGlja0hhbmRsZXIiLCJfbW91c2VEb3duSGFuZGxlciIsInNldEN1cnNvckJ5Q2xpY2siLCJfbW91c2VEb3duSGFuZGxlckJlZm9yZSIsImN1cnJlbnRBY3RpdmUiLCJtb3VzZU9mZnNldCIsInByZXZXaWR0aCIsIl9nZXROZXdTZWxlY3Rpb25TdGFydEZyb21PZmZzZXQiLCJkaXN0YW5jZUJ0d0xhc3RDaGFyQW5kQ3Vyc29yIiwiZGlzdGFuY2VCdHdOZXh0Q2hhckFuZEN1cnNvciIsIm9uS2V5RG93biIsIm9uS2V5VXAiLCJvbklucHV0IiwiY29weSIsInBhc3RlIiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvblVwZGF0ZSIsIm9uQ29tcG9zaXRpb25FbmQiLCJfY2xpY2tIYW5kbGVySW5pdGlhbGl6ZWQiLCJvbkNsaWNrIiwia2V5c01hcCIsImtleXNNYXBSdGwiLCJjdHJsS2V5c01hcFVwIiwiY3RybEtleXNNYXBEb3duIiwia2V5TWFwIiwia2V5Q29kZSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiX2NvcHlEb25lIiwiZnJvbVBhc3RlIiwibmV4dFRleHQiLCJjaGFyQ291bnQiLCJuZXh0Q2hhckNvdW50IiwicmVtb3ZlZFRleHQiLCJjaGFyRGlmZiIsInJlbW92ZUZyb20iLCJyZW1vdmVUbyIsInRleHRhcmVhU2VsZWN0aW9uIiwiYmFja0RlbGV0ZSIsImNvcGllZFRleHQiLCJjb3BpZWRUZXh0U3R5bGUiLCJjb21wb3NpdGlvbkVuZCIsIl9nZXRDbGlwYm9hcmREYXRhIiwiY2xpcGJvYXJkRGF0YSIsIl9nZXRXaWR0aEJlZm9yZUN1cnNvciIsIndpZHRoQmVmb3JlQ3Vyc29yIiwiZ2V0RG93bkN1cnNvck9mZnNldCIsImlzUmlnaHQiLCJzZWxlY3Rpb25Qcm9wIiwiX2dldFNlbGVjdGlvbkZvck9mZnNldCIsImluZGV4T25PdGhlckxpbmUiLCJfZ2V0SW5kZXhPbkxpbmUiLCJ0ZXh0QWZ0ZXJDdXJzb3IiLCJnZXRVcEN1cnNvck9mZnNldCIsInRleHRCZWZvcmVDdXJzb3IiLCJ3aWR0aE9mQ2hhcnNPbkxpbmUiLCJpbmRleE9uTGluZSIsImNoYXJXaWR0aCIsImZvdW5kTWF0Y2giLCJsZWZ0RWRnZSIsInJpZ2h0RWRnZSIsIm9mZnNldEZyb21MZWZ0RWRnZSIsIm9mZnNldEZyb21SaWdodEVkZ2UiLCJtb3ZlQ3Vyc29yRG93biIsIl9tb3ZlQ3Vyc29yVXBPckRvd24iLCJtb3ZlQ3Vyc29yVXAiLCJtb3ZlQ3Vyc29yV2l0aFNoaWZ0IiwibW92ZUN1cnNvcldpdGhvdXRTaGlmdCIsIm1vdmVDdXJzb3JMZWZ0IiwiX21vdmVDdXJzb3JMZWZ0T3JSaWdodCIsIl9tb3ZlIiwiX21vdmVMZWZ0IiwiX21vdmVSaWdodCIsIm1vdmVDdXJzb3JMZWZ0V2l0aG91dFNoaWZ0IiwiY2hhbmdlIiwibW92ZUN1cnNvckxlZnRXaXRoU2hpZnQiLCJtb3ZlQ3Vyc29yUmlnaHQiLCJtb3ZlQ3Vyc29yUmlnaHRXaXRoU2hpZnQiLCJtb3ZlQ3Vyc29yUmlnaHRXaXRob3V0U2hpZnQiLCJjaGFuZ2VkIiwicmVtb3ZlQ2hhcnMiLCJpbnNlcnRDaGFycyIsIm11bHRpcGxlU3BhY2VzUmVnZXgiLCJfZ2V0U1ZHTGVmdFRvcE9mZnNldHMiLCJ0ZXh0QW5kQmciLCJfZ2V0U1ZHVGV4dEFuZEJnIiwidGV4dFRvcCIsInRleHRMZWZ0IiwiX3dyYXBTVkdUZXh0QW5kQmciLCJsaW5lVG9wIiwibm9TaGFkb3ciLCJ0ZXh0U3BhbnMiLCJ0ZXh0VG9wT2Zmc2V0IiwidGV4dExlZnRPZmZzZXQiLCJfc2V0U1ZHVGV4dExpbmVCZyIsIl9zZXRTVkdUZXh0TGluZVRleHQiLCJfY3JlYXRlVGV4dENoYXJTcGFuIiwic3R5bGVEZWNsIiwic2hvdWxkVXNlV2hpdGVzcGFjZSIsInN0eWxlUHJvcHMiLCJmaWxsU3R5bGVzIiwiZHlTcGFuIiwiX3B1c2hUZXh0QmdSZWN0IiwiZmlsbENvbG9yIiwiX2dldFNWR0xpbmVUb3BPZmZzZXQiLCJsYXN0SGVpZ2h0Iiwic3ZnU3R5bGUiLCJUZXh0Ym94IiwibWluV2lkdGgiLCJkeW5hbWljTWluV2lkdGgiLCJfX2NhY2hlZExpbmVzIiwiX3dvcmRKb2luZXJzIiwic3BsaXRCeUdyYXBoZW1lIiwiX3N0eWxlTWFwIiwiX2dlbmVyYXRlU3R5bGVNYXAiLCJ0ZXh0SW5mbyIsInJlYWxMaW5lQ291bnQiLCJyZWFsTGluZUNoYXJDb3VudCIsImlzV3JhcHBpbmciLCJuZXh0TGluZUluZGV4IiwibmV4dE9mZnNldCIsInNob3VsZExpbWl0IiwibWFwTmV4dExpbmUiLCJfd3JhcFRleHQiLCJkZXNpcmVkV2lkdGgiLCJ3cmFwcGVkIiwiX3dyYXBMaW5lIiwiX21lYXN1cmVXb3JkIiwid29yZCIsImNoYXJPZmZzZXQiLCJfbGluZSIsInJlc2VydmVkU3BhY2UiLCJ3b3JkcyIsImluZml4Iiwid29yZFdpZHRoIiwiaW5maXhXaWR0aCIsImxhcmdlc3RXb3JkV2lkdGgiLCJsaW5lSnVzdFN0YXJ0ZWQiLCJhZGRpdGlvbmFsU3BhY2UiLCJnZXRNaW5XaWR0aCIsImxpbmVzVG9LZWVwIiwic2NhbGVTa2V3U3R5bGVIYW5kbGVyIiwic2NhbGVTdHlsZUhhbmRsZXIiLCJvYmplY3RDb250cm9scyIsIm1sIiwibXIiLCJtYiIsIm10ciIsInRleHRCb3hDb250cm9scyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fabric/dist/fabric.js\n");

/***/ })

};
;