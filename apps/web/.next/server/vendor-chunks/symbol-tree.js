"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/symbol-tree";
exports.ids = ["vendor-chunks/symbol-tree"];
exports.modules = {

/***/ "(ssr)/../../node_modules/symbol-tree/lib/SymbolTree.js":
/*!********************************************************!*\
  !*** ../../node_modules/symbol-tree/lib/SymbolTree.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * @module symbol-tree\n * @author Joris van der Wel <joris@jorisvanderwel.com>\n */ const SymbolTreeNode = __webpack_require__(/*! ./SymbolTreeNode */ \"(ssr)/../../node_modules/symbol-tree/lib/SymbolTreeNode.js\");\nconst TreePosition = __webpack_require__(/*! ./TreePosition */ \"(ssr)/../../node_modules/symbol-tree/lib/TreePosition.js\");\nconst TreeIterator = __webpack_require__(/*! ./TreeIterator */ \"(ssr)/../../node_modules/symbol-tree/lib/TreeIterator.js\");\nfunction returnTrue() {\n    return true;\n}\nfunction reverseArrayIndex(array, reverseIndex) {\n    return array[array.length - 1 - reverseIndex]; // no need to check `index >= 0`\n}\nclass SymbolTree {\n    /**\n         * @constructor\n         * @alias module:symbol-tree\n         * @param {string} [description='SymbolTree data'] Description used for the Symbol\n         */ constructor(description){\n        this.symbol = Symbol(description || \"SymbolTree data\");\n    }\n    /**\n         * You can use this function to (optionally) initialize an object right after its creation,\n         * to take advantage of V8's fast properties. Also useful if you would like to\n         * freeze your object.\n         *\n         * `O(1)`\n         *\n         * @method\n         * @alias module:symbol-tree#initialize\n         * @param {Object} object\n         * @return {Object} object\n         */ initialize(object) {\n        this._node(object);\n        return object;\n    }\n    _node(object) {\n        if (!object) {\n            return null;\n        }\n        const node = object[this.symbol];\n        if (node) {\n            return node;\n        }\n        return object[this.symbol] = new SymbolTreeNode();\n    }\n    /**\n         * Returns `true` if the object has any children. Otherwise it returns `false`.\n         *\n         * * `O(1)`\n         *\n         * @method hasChildren\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Boolean}\n         */ hasChildren(object) {\n        return this._node(object).hasChildren;\n    }\n    /**\n         * Returns the first child of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method firstChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */ firstChild(object) {\n        return this._node(object).firstChild;\n    }\n    /**\n         * Returns the last child of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method lastChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */ lastChild(object) {\n        return this._node(object).lastChild;\n    }\n    /**\n         * Returns the previous sibling of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method previousSibling\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */ previousSibling(object) {\n        return this._node(object).previousSibling;\n    }\n    /**\n         * Returns the next sibling of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method nextSibling\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */ nextSibling(object) {\n        return this._node(object).nextSibling;\n    }\n    /**\n         * Return the parent of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method parent\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */ parent(object) {\n        return this._node(object).parent;\n    }\n    /**\n         * Find the inclusive descendant that is last in tree order of the given object.\n         *\n         * * `O(n)` (worst case) where `n` is the depth of the subtree of `object`\n         *\n         * @method lastInclusiveDescendant\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */ lastInclusiveDescendant(object) {\n        let lastChild;\n        let current = object;\n        while(lastChild = this._node(current).lastChild){\n            current = lastChild;\n        }\n        return current;\n    }\n    /**\n         * Find the preceding object (A) of the given object (B).\n         * An object A is preceding an object B if A and B are in the same tree\n         * and A comes before B in tree order.\n         *\n         * * `O(n)` (worst case)\n         * * `O(1)` (amortized when walking the entire tree)\n         *\n         * @method preceding\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @param {Object} [options]\n         * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n         *        of the return value (or else null is returned). This check _assumes_\n         *        that `root` is also an inclusive ancestor of the given `object`\n         * @return {?Object}\n         */ preceding(object, options) {\n        const treeRoot = options && options.root;\n        if (object === treeRoot) {\n            return null;\n        }\n        const previousSibling = this._node(object).previousSibling;\n        if (previousSibling) {\n            return this.lastInclusiveDescendant(previousSibling);\n        }\n        // if there is no previous sibling return the parent (might be null)\n        return this._node(object).parent;\n    }\n    /**\n         * Find the following object (A) of the given object (B).\n         * An object A is following an object B if A and B are in the same tree\n         * and A comes after B in tree order.\n         *\n         * * `O(n)` (worst case) where `n` is the amount of objects in the entire tree\n         * * `O(1)` (amortized when walking the entire tree)\n         *\n         * @method following\n         * @memberOf module:symbol-tree#\n         * @param {!Object} object\n         * @param {Object} [options]\n         * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n         *        of the return value (or else null is returned). This check _assumes_\n         *        that `root` is also an inclusive ancestor of the given `object`\n         * @param {Boolean} [options.skipChildren=false] If set, ignore the children of `object`\n         * @return {?Object}\n         */ following(object, options) {\n        const treeRoot = options && options.root;\n        const skipChildren = options && options.skipChildren;\n        const firstChild = !skipChildren && this._node(object).firstChild;\n        if (firstChild) {\n            return firstChild;\n        }\n        let current = object;\n        do {\n            if (current === treeRoot) {\n                return null;\n            }\n            const nextSibling = this._node(current).nextSibling;\n            if (nextSibling) {\n                return nextSibling;\n            }\n            current = this._node(current).parent;\n        }while (current);\n        return null;\n    }\n    /**\n         * Append all children of the given object to an array.\n         *\n         * * `O(n)` where `n` is the amount of children of the given `parent`\n         *\n         * @method childrenToArray\n         * @memberOf module:symbol-tree#\n         * @param {Object} parent\n         * @param {Object} [options]\n         * @param {Object[]} [options.array=[]]\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\n         *                            Invoked with arguments (object). Should return `true` if an object\n         *                            is to be included.\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n         * @return {Object[]}\n         */ childrenToArray(parent, options) {\n        const array = options && options.array || [];\n        const filter = options && options.filter || returnTrue;\n        const thisArg = options && options.thisArg || undefined;\n        const parentNode = this._node(parent);\n        let object = parentNode.firstChild;\n        let index = 0;\n        while(object){\n            const node = this._node(object);\n            node.setCachedIndex(parentNode, index);\n            if (filter.call(thisArg, object)) {\n                array.push(object);\n            }\n            object = node.nextSibling;\n            ++index;\n        }\n        return array;\n    }\n    /**\n         * Append all inclusive ancestors of the given object to an array.\n         *\n         * * `O(n)` where `n` is the amount of ancestors of the given `object`\n         *\n         * @method ancestorsToArray\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @param {Object} [options]\n         * @param {Object[]} [options.array=[]]\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\n         *                            Invoked with arguments (object). Should return `true` if an object\n         *                            is to be included.\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n         * @return {Object[]}\n         */ ancestorsToArray(object, options) {\n        const array = options && options.array || [];\n        const filter = options && options.filter || returnTrue;\n        const thisArg = options && options.thisArg || undefined;\n        let ancestor = object;\n        while(ancestor){\n            if (filter.call(thisArg, ancestor)) {\n                array.push(ancestor);\n            }\n            ancestor = this._node(ancestor).parent;\n        }\n        return array;\n    }\n    /**\n         * Append all descendants of the given object to an array (in tree order).\n         *\n         * * `O(n)` where `n` is the amount of objects in the sub-tree of the given `object`\n         *\n         * @method treeToArray\n         * @memberOf module:symbol-tree#\n         * @param {Object} root\n         * @param {Object} [options]\n         * @param {Object[]} [options.array=[]]\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\n         *                            Invoked with arguments (object). Should return `true` if an object\n         *                            is to be included.\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n         * @return {Object[]}\n         */ treeToArray(root, options) {\n        const array = options && options.array || [];\n        const filter = options && options.filter || returnTrue;\n        const thisArg = options && options.thisArg || undefined;\n        let object = root;\n        while(object){\n            if (filter.call(thisArg, object)) {\n                array.push(object);\n            }\n            object = this.following(object, {\n                root: root\n            });\n        }\n        return array;\n    }\n    /**\n         * Iterate over all children of the given object\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method childrenIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} parent\n         * @param {Object} [options]\n         * @param {Boolean} [options.reverse=false]\n         * @return {Object} An iterable iterator (ES6)\n         */ childrenIterator(parent, options) {\n        const reverse = options && options.reverse;\n        const parentNode = this._node(parent);\n        return new TreeIterator(this, parent, reverse ? parentNode.lastChild : parentNode.firstChild, reverse ? TreeIterator.PREV : TreeIterator.NEXT);\n    }\n    /**\n         * Iterate over all the previous siblings of the given object. (in reverse tree order)\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method previousSiblingsIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object} An iterable iterator (ES6)\n         */ previousSiblingsIterator(object) {\n        return new TreeIterator(this, object, this._node(object).previousSibling, TreeIterator.PREV);\n    }\n    /**\n         * Iterate over all the next siblings of the given object. (in tree order)\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method nextSiblingsIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object} An iterable iterator (ES6)\n         */ nextSiblingsIterator(object) {\n        return new TreeIterator(this, object, this._node(object).nextSibling, TreeIterator.NEXT);\n    }\n    /**\n         * Iterate over all inclusive ancestors of the given object\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method ancestorsIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object} An iterable iterator (ES6)\n         */ ancestorsIterator(object) {\n        return new TreeIterator(this, object, object, TreeIterator.PARENT);\n    }\n    /**\n         * Iterate over all descendants of the given object (in tree order).\n         *\n         * Where `n` is the amount of objects in the sub-tree of the given `root`:\n         *\n         * * `O(n)` (worst case for a single iteration)\n         * * `O(n)` (amortized, when completing the iterator)\n         *\n         * @method treeIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} root\n         * @param {Object} options\n         * @param {Boolean} [options.reverse=false]\n         * @return {Object} An iterable iterator (ES6)\n         */ treeIterator(root, options) {\n        const reverse = options && options.reverse;\n        return new TreeIterator(this, root, reverse ? this.lastInclusiveDescendant(root) : root, reverse ? TreeIterator.PRECEDING : TreeIterator.FOLLOWING);\n    }\n    /**\n         * Find the index of the given object (the number of preceding siblings).\n         *\n         * * `O(n)` where `n` is the amount of preceding siblings\n         * * `O(1)` (amortized, if the tree is not modified)\n         *\n         * @method index\n         * @memberOf module:symbol-tree#\n         * @param {Object} child\n         * @return {Number} The number of preceding siblings, or -1 if the object has no parent\n         */ index(child) {\n        const childNode = this._node(child);\n        const parentNode = this._node(childNode.parent);\n        if (!parentNode) {\n            // In principal, you could also find out the number of preceding siblings\n            // for objects that do not have a parent. This method limits itself only to\n            // objects that have a parent because that lets us optimize more.\n            return -1;\n        }\n        let currentIndex = childNode.getCachedIndex(parentNode);\n        if (currentIndex >= 0) {\n            return currentIndex;\n        }\n        currentIndex = 0;\n        let object = parentNode.firstChild;\n        if (parentNode.childIndexCachedUpTo) {\n            const cachedUpToNode = this._node(parentNode.childIndexCachedUpTo);\n            object = cachedUpToNode.nextSibling;\n            currentIndex = cachedUpToNode.getCachedIndex(parentNode) + 1;\n        }\n        while(object){\n            const node = this._node(object);\n            node.setCachedIndex(parentNode, currentIndex);\n            if (object === child) {\n                break;\n            }\n            ++currentIndex;\n            object = node.nextSibling;\n        }\n        parentNode.childIndexCachedUpTo = child;\n        return currentIndex;\n    }\n    /**\n         * Calculate the number of children.\n         *\n         * * `O(n)` where `n` is the amount of children\n         * * `O(1)` (amortized, if the tree is not modified)\n         *\n         * @method childrenCount\n         * @memberOf module:symbol-tree#\n         * @param {Object} parent\n         * @return {Number}\n         */ childrenCount(parent) {\n        const parentNode = this._node(parent);\n        if (!parentNode.lastChild) {\n            return 0;\n        }\n        return this.index(parentNode.lastChild) + 1;\n    }\n    /**\n         * Compare the position of an object relative to another object. A bit set is returned:\n         *\n         * <ul>\n         *     <li>DISCONNECTED : 1</li>\n         *     <li>PRECEDING : 2</li>\n         *     <li>FOLLOWING : 4</li>\n         *     <li>CONTAINS : 8</li>\n         *     <li>CONTAINED_BY : 16</li>\n         * </ul>\n         *\n         * The semantics are the same as compareDocumentPosition in DOM, with the exception that\n         * DISCONNECTED never occurs with any other bit.\n         *\n         * where `n` and `m` are the amount of ancestors of `left` and `right`;\n         * where `o` is the amount of children of the lowest common ancestor of `left` and `right`:\n         *\n         * * `O(n + m + o)` (worst case)\n         * * `O(n + m)` (amortized, if the tree is not modified)\n         *\n         * @method compareTreePosition\n         * @memberOf module:symbol-tree#\n         * @param {Object} left\n         * @param {Object} right\n         * @return {Number}\n         */ compareTreePosition(left, right) {\n        // In DOM terms:\n        // left = reference / context object\n        // right = other\n        if (left === right) {\n            return 0;\n        }\n        /* jshint -W016 */ const leftAncestors = [];\n        {\n            let leftAncestor = left;\n            while(leftAncestor){\n                if (leftAncestor === right) {\n                    return TreePosition.CONTAINS | TreePosition.PRECEDING;\n                // other is ancestor of reference\n                }\n                leftAncestors.push(leftAncestor);\n                leftAncestor = this.parent(leftAncestor);\n            }\n        }\n        const rightAncestors = [];\n        {\n            let rightAncestor = right;\n            while(rightAncestor){\n                if (rightAncestor === left) {\n                    return TreePosition.CONTAINED_BY | TreePosition.FOLLOWING;\n                }\n                rightAncestors.push(rightAncestor);\n                rightAncestor = this.parent(rightAncestor);\n            }\n        }\n        const root = reverseArrayIndex(leftAncestors, 0);\n        if (!root || root !== reverseArrayIndex(rightAncestors, 0)) {\n            // note: unlike DOM, preceding / following is not set here\n            return TreePosition.DISCONNECTED;\n        }\n        // find the lowest common ancestor\n        let commonAncestorIndex = 0;\n        const ancestorsMinLength = Math.min(leftAncestors.length, rightAncestors.length);\n        for(let i = 0; i < ancestorsMinLength; ++i){\n            const leftAncestor = reverseArrayIndex(leftAncestors, i);\n            const rightAncestor = reverseArrayIndex(rightAncestors, i);\n            if (leftAncestor !== rightAncestor) {\n                break;\n            }\n            commonAncestorIndex = i;\n        }\n        // indexes within the common ancestor\n        const leftIndex = this.index(reverseArrayIndex(leftAncestors, commonAncestorIndex + 1));\n        const rightIndex = this.index(reverseArrayIndex(rightAncestors, commonAncestorIndex + 1));\n        return rightIndex < leftIndex ? TreePosition.PRECEDING : TreePosition.FOLLOWING;\n    }\n    /**\n         * Remove the object from this tree.\n         * Has no effect if already removed.\n         *\n         * * `O(1)`\n         *\n         * @method remove\n         * @memberOf module:symbol-tree#\n         * @param {Object} removeObject\n         * @return {Object} removeObject\n         */ remove(removeObject) {\n        const removeNode = this._node(removeObject);\n        const parentNode = this._node(removeNode.parent);\n        const prevNode = this._node(removeNode.previousSibling);\n        const nextNode = this._node(removeNode.nextSibling);\n        if (parentNode) {\n            if (parentNode.firstChild === removeObject) {\n                parentNode.firstChild = removeNode.nextSibling;\n            }\n            if (parentNode.lastChild === removeObject) {\n                parentNode.lastChild = removeNode.previousSibling;\n            }\n        }\n        if (prevNode) {\n            prevNode.nextSibling = removeNode.nextSibling;\n        }\n        if (nextNode) {\n            nextNode.previousSibling = removeNode.previousSibling;\n        }\n        removeNode.parent = null;\n        removeNode.previousSibling = null;\n        removeNode.nextSibling = null;\n        removeNode.cachedIndex = -1;\n        removeNode.cachedIndexVersion = NaN;\n        if (parentNode) {\n            parentNode.childrenChanged();\n        }\n        return removeObject;\n    }\n    /**\n         * Insert the given object before the reference object.\n         * `newObject` is now the previous sibling of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method insertBefore\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */ insertBefore(referenceObject, newObject) {\n        const referenceNode = this._node(referenceObject);\n        const prevNode = this._node(referenceNode.previousSibling);\n        const newNode = this._node(newObject);\n        const parentNode = this._node(referenceNode.parent);\n        if (newNode.isAttached) {\n            throw Error(\"Given object is already present in this SymbolTree, remove it first\");\n        }\n        newNode.parent = referenceNode.parent;\n        newNode.previousSibling = referenceNode.previousSibling;\n        newNode.nextSibling = referenceObject;\n        referenceNode.previousSibling = newObject;\n        if (prevNode) {\n            prevNode.nextSibling = newObject;\n        }\n        if (parentNode && parentNode.firstChild === referenceObject) {\n            parentNode.firstChild = newObject;\n        }\n        if (parentNode) {\n            parentNode.childrenChanged();\n        }\n        return newObject;\n    }\n    /**\n         * Insert the given object after the reference object.\n         * `newObject` is now the next sibling of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method insertAfter\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */ insertAfter(referenceObject, newObject) {\n        const referenceNode = this._node(referenceObject);\n        const nextNode = this._node(referenceNode.nextSibling);\n        const newNode = this._node(newObject);\n        const parentNode = this._node(referenceNode.parent);\n        if (newNode.isAttached) {\n            throw Error(\"Given object is already present in this SymbolTree, remove it first\");\n        }\n        newNode.parent = referenceNode.parent;\n        newNode.previousSibling = referenceObject;\n        newNode.nextSibling = referenceNode.nextSibling;\n        referenceNode.nextSibling = newObject;\n        if (nextNode) {\n            nextNode.previousSibling = newObject;\n        }\n        if (parentNode && parentNode.lastChild === referenceObject) {\n            parentNode.lastChild = newObject;\n        }\n        if (parentNode) {\n            parentNode.childrenChanged();\n        }\n        return newObject;\n    }\n    /**\n         * Insert the given object as the first child of the given reference object.\n         * `newObject` is now the first child of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method prependChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */ prependChild(referenceObject, newObject) {\n        const referenceNode = this._node(referenceObject);\n        const newNode = this._node(newObject);\n        if (newNode.isAttached) {\n            throw Error(\"Given object is already present in this SymbolTree, remove it first\");\n        }\n        if (referenceNode.hasChildren) {\n            this.insertBefore(referenceNode.firstChild, newObject);\n        } else {\n            newNode.parent = referenceObject;\n            referenceNode.firstChild = newObject;\n            referenceNode.lastChild = newObject;\n            referenceNode.childrenChanged();\n        }\n        return newObject;\n    }\n    /**\n         * Insert the given object as the last child of the given reference object.\n         * `newObject` is now the last child of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method appendChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */ appendChild(referenceObject, newObject) {\n        const referenceNode = this._node(referenceObject);\n        const newNode = this._node(newObject);\n        if (newNode.isAttached) {\n            throw Error(\"Given object is already present in this SymbolTree, remove it first\");\n        }\n        if (referenceNode.hasChildren) {\n            this.insertAfter(referenceNode.lastChild, newObject);\n        } else {\n            newNode.parent = referenceObject;\n            referenceNode.firstChild = newObject;\n            referenceNode.lastChild = newObject;\n            referenceNode.childrenChanged();\n        }\n        return newObject;\n    }\n}\nmodule.exports = SymbolTree;\nSymbolTree.TreePosition = TreePosition;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3N5bWJvbC10cmVlL2xpYi9TeW1ib2xUcmVlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUE7OztDQUdDLEdBRUQsTUFBTUEsaUJBQWlCQyxtQkFBT0EsQ0FBQztBQUMvQixNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQztBQUM3QixNQUFNRSxlQUFlRixtQkFBT0EsQ0FBQztBQUU3QixTQUFTRztJQUNELE9BQU87QUFDZjtBQUVBLFNBQVNDLGtCQUFrQkMsS0FBSyxFQUFFQyxZQUFZO0lBQ3RDLE9BQU9ELEtBQUssQ0FBQ0EsTUFBTUUsTUFBTSxHQUFHLElBQUlELGFBQWEsRUFBRSxnQ0FBZ0M7QUFDdkY7QUFFQSxNQUFNRTtJQUVFOzs7O1NBSUMsR0FDREMsWUFBWUMsV0FBVyxDQUFFO1FBQ2pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHQyxPQUFPRixlQUFlO0lBQzVDO0lBRUE7Ozs7Ozs7Ozs7O1NBV0MsR0FDREcsV0FBV0MsTUFBTSxFQUFFO1FBQ1gsSUFBSSxDQUFDQyxLQUFLLENBQUNEO1FBRVgsT0FBT0E7SUFDZjtJQUVBQyxNQUFNRCxNQUFNLEVBQUU7UUFDTixJQUFJLENBQUNBLFFBQVE7WUFDTCxPQUFPO1FBQ2Y7UUFFQSxNQUFNRSxPQUFPRixNQUFNLENBQUMsSUFBSSxDQUFDSCxNQUFNLENBQUM7UUFFaEMsSUFBSUssTUFBTTtZQUNGLE9BQU9BO1FBQ2Y7UUFFQSxPQUFRRixNQUFNLENBQUMsSUFBSSxDQUFDSCxNQUFNLENBQUMsR0FBRyxJQUFJWjtJQUMxQztJQUVBOzs7Ozs7Ozs7U0FTQyxHQUNEa0IsWUFBWUgsTUFBTSxFQUFFO1FBQ1osT0FBTyxJQUFJLENBQUNDLEtBQUssQ0FBQ0QsUUFBUUcsV0FBVztJQUM3QztJQUVBOzs7Ozs7Ozs7U0FTQyxHQUNEQyxXQUFXSixNQUFNLEVBQUU7UUFDWCxPQUFPLElBQUksQ0FBQ0MsS0FBSyxDQUFDRCxRQUFRSSxVQUFVO0lBQzVDO0lBRUE7Ozs7Ozs7OztTQVNDLEdB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RCxPQUNLO1lBQ0dFLFFBQVFyRSxNQUFNLEdBQUdrRTtZQUNqQkUsY0FBY3hFLFVBQVUsR0FBR3VFO1lBQzNCQyxjQUFjdkUsU0FBUyxHQUFHc0U7WUFDMUJDLGNBQWNKLGVBQWU7UUFDckM7UUFFQSxPQUFPRztJQUNmO0FBQ1I7QUFFQVEsT0FBT0MsT0FBTyxHQUFHMUY7QUFDakJBLFdBQVdQLFlBQVksR0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AY292ZXItY3JhZnQvd2ViLy4uLy4uL25vZGVfbW9kdWxlcy9zeW1ib2wtdHJlZS9saWIvU3ltYm9sVHJlZS5qcz9lMmVmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbW9kdWxlIHN5bWJvbC10cmVlXG4gKiBAYXV0aG9yIEpvcmlzIHZhbiBkZXIgV2VsIDxqb3Jpc0Bqb3Jpc3ZhbmRlcndlbC5jb20+XG4gKi9cblxuY29uc3QgU3ltYm9sVHJlZU5vZGUgPSByZXF1aXJlKCcuL1N5bWJvbFRyZWVOb2RlJyk7XG5jb25zdCBUcmVlUG9zaXRpb24gPSByZXF1aXJlKCcuL1RyZWVQb3NpdGlvbicpO1xuY29uc3QgVHJlZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi9UcmVlSXRlcmF0b3InKTtcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldmVyc2VBcnJheUluZGV4KGFycmF5LCByZXZlcnNlSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDEgLSByZXZlcnNlSW5kZXhdOyAvLyBubyBuZWVkIHRvIGNoZWNrIGBpbmRleCA+PSAwYFxufVxuXG5jbGFzcyBTeW1ib2xUcmVlIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBhbGlhcyBtb2R1bGU6c3ltYm9sLXRyZWVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtkZXNjcmlwdGlvbj0nU3ltYm9sVHJlZSBkYXRhJ10gRGVzY3JpcHRpb24gdXNlZCBmb3IgdGhlIFN5bWJvbFxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN5bWJvbCA9IFN5bWJvbChkZXNjcmlwdGlvbiB8fCAnU3ltYm9sVHJlZSBkYXRhJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogWW91IGNhbiB1c2UgdGhpcyBmdW5jdGlvbiB0byAob3B0aW9uYWxseSkgaW5pdGlhbGl6ZSBhbiBvYmplY3QgcmlnaHQgYWZ0ZXIgaXRzIGNyZWF0aW9uLFxuICAgICAgICAgKiB0byB0YWtlIGFkdmFudGFnZSBvZiBWOCdzIGZhc3QgcHJvcGVydGllcy4gQWxzbyB1c2VmdWwgaWYgeW91IHdvdWxkIGxpa2UgdG9cbiAgICAgICAgICogZnJlZXplIHlvdXIgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBgTygxKWBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAYWxpYXMgbW9kdWxlOnN5bWJvbC10cmVlI2luaXRpYWxpemVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZShvYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlKG9iamVjdCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgX25vZGUob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBvYmplY3RbdGhpcy5zeW1ib2xdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAob2JqZWN0W3RoaXMuc3ltYm9sXSA9IG5ldyBTeW1ib2xUcmVlTm9kZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0IGhhcyBhbnkgY2hpbGRyZW4uIE90aGVyd2lzZSBpdCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8oMSlgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgaGFzQ2hpbGRyZW5cbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaGFzQ2hpbGRyZW4ob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUob2JqZWN0KS5oYXNDaGlsZHJlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKDEpYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGZpcnN0Q2hpbGRcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBmaXJzdENoaWxkKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlKG9iamVjdCkuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBsYXN0IGNoaWxkIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8oMSlgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgbGFzdENoaWxkXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbGFzdENoaWxkKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlKG9iamVjdCkubGFzdENoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTygxKWBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcmV2aW91c1NpYmxpbmdcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBwcmV2aW91c1NpYmxpbmcob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUob2JqZWN0KS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8oMSlgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgbmV4dFNpYmxpbmdcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBuZXh0U2libGluZyhvYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZShvYmplY3QpLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgcGFyZW50IG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8oMSlgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcGFyZW50XG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgcGFyZW50KG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlKG9iamVjdCkucGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmQgdGhlIGluY2x1c2l2ZSBkZXNjZW5kYW50IHRoYXQgaXMgbGFzdCBpbiB0cmVlIG9yZGVyIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8obilgICh3b3JzdCBjYXNlKSB3aGVyZSBgbmAgaXMgdGhlIGRlcHRoIG9mIHRoZSBzdWJ0cmVlIG9mIGBvYmplY3RgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgbGFzdEluY2x1c2l2ZURlc2NlbmRhbnRcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBsYXN0SW5jbHVzaXZlRGVzY2VuZGFudChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdENoaWxkO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50ID0gb2JqZWN0O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKChsYXN0Q2hpbGQgPSB0aGlzLl9ub2RlKGN1cnJlbnQpLmxhc3RDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBsYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCB0aGUgcHJlY2VkaW5nIG9iamVjdCAoQSkgb2YgdGhlIGdpdmVuIG9iamVjdCAoQikuXG4gICAgICAgICAqIEFuIG9iamVjdCBBIGlzIHByZWNlZGluZyBhbiBvYmplY3QgQiBpZiBBIGFuZCBCIGFyZSBpbiB0aGUgc2FtZSB0cmVlXG4gICAgICAgICAqIGFuZCBBIGNvbWVzIGJlZm9yZSBCIGluIHRyZWUgb3JkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8obilgICh3b3JzdCBjYXNlKVxuICAgICAgICAgKiAqIGBPKDEpYCAoYW1vcnRpemVkIHdoZW4gd2Fsa2luZyB0aGUgZW50aXJlIHRyZWUpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJlY2VkaW5nXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucm9vdF0gSWYgc2V0LCBgcm9vdGAgbXVzdCBiZSBhbiBpbmNsdXNpdmUgYW5jZXN0b3JcbiAgICAgICAgICogICAgICAgIG9mIHRoZSByZXR1cm4gdmFsdWUgKG9yIGVsc2UgbnVsbCBpcyByZXR1cm5lZCkuIFRoaXMgY2hlY2sgX2Fzc3VtZXNfXG4gICAgICAgICAqICAgICAgICB0aGF0IGByb290YCBpcyBhbHNvIGFuIGluY2x1c2l2ZSBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gYG9iamVjdGBcbiAgICAgICAgICogQHJldHVybiB7P09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHByZWNlZGluZyhvYmplY3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmVlUm9vdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yb290O1xuXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCA9PT0gdHJlZVJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzU2libGluZyA9IHRoaXMuX25vZGUob2JqZWN0KS5wcmV2aW91c1NpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYXN0SW5jbHVzaXZlRGVzY2VuZGFudChwcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIHByZXZpb3VzIHNpYmxpbmcgcmV0dXJuIHRoZSBwYXJlbnQgKG1pZ2h0IGJlIG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUob2JqZWN0KS5wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCB0aGUgZm9sbG93aW5nIG9iamVjdCAoQSkgb2YgdGhlIGdpdmVuIG9iamVjdCAoQikuXG4gICAgICAgICAqIEFuIG9iamVjdCBBIGlzIGZvbGxvd2luZyBhbiBvYmplY3QgQiBpZiBBIGFuZCBCIGFyZSBpbiB0aGUgc2FtZSB0cmVlXG4gICAgICAgICAqIGFuZCBBIGNvbWVzIGFmdGVyIEIgaW4gdHJlZSBvcmRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTyhuKWAgKHdvcnN0IGNhc2UpIHdoZXJlIGBuYCBpcyB0aGUgYW1vdW50IG9mIG9iamVjdHMgaW4gdGhlIGVudGlyZSB0cmVlXG4gICAgICAgICAqICogYE8oMSlgIChhbW9ydGl6ZWQgd2hlbiB3YWxraW5nIHRoZSBlbnRpcmUgdHJlZSlcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBmb2xsb3dpbmdcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHshT2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucm9vdF0gSWYgc2V0LCBgcm9vdGAgbXVzdCBiZSBhbiBpbmNsdXNpdmUgYW5jZXN0b3JcbiAgICAgICAgICogICAgICAgIG9mIHRoZSByZXR1cm4gdmFsdWUgKG9yIGVsc2UgbnVsbCBpcyByZXR1cm5lZCkuIFRoaXMgY2hlY2sgX2Fzc3VtZXNfXG4gICAgICAgICAqICAgICAgICB0aGF0IGByb290YCBpcyBhbHNvIGFuIGluY2x1c2l2ZSBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gYG9iamVjdGBcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwQ2hpbGRyZW49ZmFsc2VdIElmIHNldCwgaWdub3JlIHRoZSBjaGlsZHJlbiBvZiBgb2JqZWN0YFxuICAgICAgICAgKiBAcmV0dXJuIHs/T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZm9sbG93aW5nKG9iamVjdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyZWVSb290ID0gb3B0aW9ucyAmJiBvcHRpb25zLnJvb3Q7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2tpcENoaWxkcmVuID0gb3B0aW9ucyAmJiBvcHRpb25zLnNraXBDaGlsZHJlbjtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSAhc2tpcENoaWxkcmVuICYmIHRoaXMuX25vZGUob2JqZWN0KS5maXJzdENoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50ID0gb2JqZWN0O1xuXG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHRyZWVSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2libGluZyA9IHRoaXMuX25vZGUoY3VycmVudCkubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLl9ub2RlKGN1cnJlbnQpLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChjdXJyZW50KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGVuZCBhbGwgY2hpbGRyZW4gb2YgdGhlIGdpdmVuIG9iamVjdCB0byBhbiBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTyhuKWAgd2hlcmUgYG5gIGlzIHRoZSBhbW91bnQgb2YgY2hpbGRyZW4gb2YgdGhlIGdpdmVuIGBwYXJlbnRgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgY2hpbGRyZW5Ub0FycmF5XG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBbb3B0aW9ucy5hcnJheT1bXV1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZmlsdGVyXSBGdW5jdGlvbiB0byB0ZXN0IGVhY2ggb2JqZWN0IGJlZm9yZSBpdCBpcyBhZGRlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIEludm9rZWQgd2l0aCBhcmd1bWVudHMgKG9iamVjdCkuIFNob3VsZCByZXR1cm4gYHRydWVgIGlmIGFuIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB0byBiZSBpbmNsdWRlZC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy50aGlzQXJnXSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBmaWx0ZXJgLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuVG9BcnJheShwYXJlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheSAgID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5hcnJheSkgfHwgW107XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyICA9IChvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyKSB8fCByZXR1cm5UcnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNBcmcgPSAob3B0aW9ucyAmJiBvcHRpb25zLnRoaXNBcmcpIHx8IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSB0aGlzLl9ub2RlKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgbGV0IG9iamVjdCA9IHBhcmVudE5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGUob2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0Q2FjaGVkSW5kZXgocGFyZW50Tm9kZSwgaW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLmNhbGwodGhpc0FyZywgb2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmQgYWxsIGluY2x1c2l2ZSBhbmNlc3RvcnMgb2YgdGhlIGdpdmVuIG9iamVjdCB0byBhbiBhcnJheS5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTyhuKWAgd2hlcmUgYG5gIGlzIHRoZSBhbW91bnQgb2YgYW5jZXN0b3JzIG9mIHRoZSBnaXZlbiBgb2JqZWN0YFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGFuY2VzdG9yc1RvQXJyYXlcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0W119IFtvcHRpb25zLmFycmF5PVtdXVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5maWx0ZXJdIEZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBvYmplY3QgYmVmb3JlIGl0IGlzIGFkZGVkIHRvIHRoZSBhcnJheS5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSW52b2tlZCB3aXRoIGFyZ3VtZW50cyAob2JqZWN0KS4gU2hvdWxkIHJldHVybiBgdHJ1ZWAgaWYgYW4gb2JqZWN0XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRvIGJlIGluY2x1ZGVkLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLnRoaXNBcmddIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGZpbHRlcmAuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgYW5jZXN0b3JzVG9BcnJheShvYmplY3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheSAgID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5hcnJheSkgfHwgW107XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyICA9IChvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyKSB8fCByZXR1cm5UcnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNBcmcgPSAob3B0aW9ucyAmJiBvcHRpb25zLnRoaXNBcmcpIHx8IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIGxldCBhbmNlc3RvciA9IG9iamVjdDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlci5jYWxsKHRoaXNBcmcsIGFuY2VzdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yID0gdGhpcy5fbm9kZShhbmNlc3RvcikucGFyZW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmQgYWxsIGRlc2NlbmRhbnRzIG9mIHRoZSBnaXZlbiBvYmplY3QgdG8gYW4gYXJyYXkgKGluIHRyZWUgb3JkZXIpLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKG4pYCB3aGVyZSBgbmAgaXMgdGhlIGFtb3VudCBvZiBvYmplY3RzIGluIHRoZSBzdWItdHJlZSBvZiB0aGUgZ2l2ZW4gYG9iamVjdGBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCB0cmVlVG9BcnJheVxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcm9vdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0W119IFtvcHRpb25zLmFycmF5PVtdXVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5maWx0ZXJdIEZ1bmN0aW9uIHRvIHRlc3QgZWFjaCBvYmplY3QgYmVmb3JlIGl0IGlzIGFkZGVkIHRvIHRoZSBhcnJheS5cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSW52b2tlZCB3aXRoIGFyZ3VtZW50cyAob2JqZWN0KS4gU2hvdWxkIHJldHVybiBgdHJ1ZWAgaWYgYW4gb2JqZWN0XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRvIGJlIGluY2x1ZGVkLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zLnRoaXNBcmddIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGZpbHRlcmAuXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgdHJlZVRvQXJyYXkocm9vdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5ICAgPSAob3B0aW9ucyAmJiBvcHRpb25zLmFycmF5KSB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5maWx0ZXIpIHx8IHJldHVyblRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdGhpc0FyZyA9IChvcHRpb25zICYmIG9wdGlvbnMudGhpc0FyZykgfHwgdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgbGV0IG9iamVjdCA9IHJvb3Q7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyLmNhbGwodGhpc0FyZywgb2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSB0aGlzLmZvbGxvd2luZyhvYmplY3QsIHtyb290OiByb290fSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgb3ZlciBhbGwgY2hpbGRyZW4gb2YgdGhlIGdpdmVuIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKDEpYCBmb3IgYSBzaW5nbGUgaXRlcmF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgY2hpbGRyZW5JdGVyYXRvclxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZXZlcnNlPWZhbHNlXVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGl0ZXJhYmxlIGl0ZXJhdG9yIChFUzYpXG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbkl0ZXJhdG9yKHBhcmVudCwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldmVyc2UgPSBvcHRpb25zICYmIG9wdGlvbnMucmV2ZXJzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gdGhpcy5fbm9kZShwYXJlbnQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlSXRlcmF0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZSA/IHBhcmVudE5vZGUubGFzdENoaWxkIDogcGFyZW50Tm9kZS5maXJzdENoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZSA/IFRyZWVJdGVyYXRvci5QUkVWIDogVHJlZUl0ZXJhdG9yLk5FWFRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHByZXZpb3VzIHNpYmxpbmdzIG9mIHRoZSBnaXZlbiBvYmplY3QuIChpbiByZXZlcnNlIHRyZWUgb3JkZXIpXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8oMSlgIGZvciBhIHNpbmdsZSBpdGVyYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBwcmV2aW91c1NpYmxpbmdzSXRlcmF0b3JcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGl0ZXJhYmxlIGl0ZXJhdG9yIChFUzYpXG4gICAgICAgICAqL1xuICAgICAgICBwcmV2aW91c1NpYmxpbmdzSXRlcmF0b3Iob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlSXRlcmF0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm9kZShvYmplY3QpLnByZXZpb3VzU2libGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFRyZWVJdGVyYXRvci5QUkVWXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSBuZXh0IHNpYmxpbmdzIG9mIHRoZSBnaXZlbiBvYmplY3QuIChpbiB0cmVlIG9yZGVyKVxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKDEpYCBmb3IgYSBzaW5nbGUgaXRlcmF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgbmV4dFNpYmxpbmdzSXRlcmF0b3JcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGl0ZXJhYmxlIGl0ZXJhdG9yIChFUzYpXG4gICAgICAgICAqL1xuICAgICAgICBuZXh0U2libGluZ3NJdGVyYXRvcihvYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVJdGVyYXRvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub2RlKG9iamVjdCkubmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBUcmVlSXRlcmF0b3IuTkVYVFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0ZSBvdmVyIGFsbCBpbmNsdXNpdmUgYW5jZXN0b3JzIG9mIHRoZSBnaXZlbiBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTygxKWAgZm9yIGEgc2luZ2xlIGl0ZXJhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGFuY2VzdG9yc0l0ZXJhdG9yXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBpdGVyYWJsZSBpdGVyYXRvciAoRVM2KVxuICAgICAgICAgKi9cbiAgICAgICAgYW5jZXN0b3JzSXRlcmF0b3Iob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlSXRlcmF0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgVHJlZUl0ZXJhdG9yLlBBUkVOVFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0ZSBvdmVyIGFsbCBkZXNjZW5kYW50cyBvZiB0aGUgZ2l2ZW4gb2JqZWN0IChpbiB0cmVlIG9yZGVyKS5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlcmUgYG5gIGlzIHRoZSBhbW91bnQgb2Ygb2JqZWN0cyBpbiB0aGUgc3ViLXRyZWUgb2YgdGhlIGdpdmVuIGByb290YDpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTyhuKWAgKHdvcnN0IGNhc2UgZm9yIGEgc2luZ2xlIGl0ZXJhdGlvbilcbiAgICAgICAgICogKiBgTyhuKWAgKGFtb3J0aXplZCwgd2hlbiBjb21wbGV0aW5nIHRoZSBpdGVyYXRvcilcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCB0cmVlSXRlcmF0b3JcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJvb3RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZXZlcnNlPWZhbHNlXVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIGl0ZXJhYmxlIGl0ZXJhdG9yIChFUzYpXG4gICAgICAgICAqL1xuICAgICAgICB0cmVlSXRlcmF0b3Iocm9vdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldmVyc2UgPSBvcHRpb25zICYmIG9wdGlvbnMucmV2ZXJzZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZUl0ZXJhdG9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlID8gdGhpcy5sYXN0SW5jbHVzaXZlRGVzY2VuZGFudChyb290KSA6IHJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlID8gVHJlZUl0ZXJhdG9yLlBSRUNFRElORyA6IFRyZWVJdGVyYXRvci5GT0xMT1dJTkdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBvYmplY3QgKHRoZSBudW1iZXIgb2YgcHJlY2VkaW5nIHNpYmxpbmdzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTyhuKWAgd2hlcmUgYG5gIGlzIHRoZSBhbW91bnQgb2YgcHJlY2VkaW5nIHNpYmxpbmdzXG4gICAgICAgICAqICogYE8oMSlgIChhbW9ydGl6ZWQsIGlmIHRoZSB0cmVlIGlzIG5vdCBtb2RpZmllZClcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBpbmRleFxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hpbGRcbiAgICAgICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIHByZWNlZGluZyBzaWJsaW5ncywgb3IgLTEgaWYgdGhlIG9iamVjdCBoYXMgbm8gcGFyZW50XG4gICAgICAgICAqL1xuICAgICAgICBpbmRleChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IHRoaXMuX25vZGUoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSB0aGlzLl9ub2RlKGNoaWxkTm9kZS5wYXJlbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBwcmluY2lwYWwsIHlvdSBjb3VsZCBhbHNvIGZpbmQgb3V0IHRoZSBudW1iZXIgb2YgcHJlY2VkaW5nIHNpYmxpbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3Igb2JqZWN0cyB0aGF0IGRvIG5vdCBoYXZlIGEgcGFyZW50LiBUaGlzIG1ldGhvZCBsaW1pdHMgaXRzZWxmIG9ubHkgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgdGhhdCBoYXZlIGEgcGFyZW50IGJlY2F1c2UgdGhhdCBsZXRzIHVzIG9wdGltaXplIG1vcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IGNoaWxkTm9kZS5nZXRDYWNoZWRJbmRleChwYXJlbnROb2RlKTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGxldCBvYmplY3QgPSBwYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZS5jaGlsZEluZGV4Q2FjaGVkVXBUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkVXBUb05vZGUgPSB0aGlzLl9ub2RlKHBhcmVudE5vZGUuY2hpbGRJbmRleENhY2hlZFVwVG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gY2FjaGVkVXBUb05vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXggPSBjYWNoZWRVcFRvTm9kZS5nZXRDYWNoZWRJbmRleChwYXJlbnROb2RlKSArIDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGUob2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0Q2FjaGVkSW5kZXgocGFyZW50Tm9kZSwgY3VycmVudEluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdCA9PT0gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICsrY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkSW5kZXhDYWNoZWRVcFRvID0gY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKG4pYCB3aGVyZSBgbmAgaXMgdGhlIGFtb3VudCBvZiBjaGlsZHJlblxuICAgICAgICAgKiAqIGBPKDEpYCAoYW1vcnRpemVkLCBpZiB0aGUgdHJlZSBpcyBub3QgbW9kaWZpZWQpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgY2hpbGRyZW5Db3VudFxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkcmVuQ291bnQocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHRoaXMuX25vZGUocGFyZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50Tm9kZS5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4KHBhcmVudE5vZGUubGFzdENoaWxkKSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcGFyZSB0aGUgcG9zaXRpb24gb2YgYW4gb2JqZWN0IHJlbGF0aXZlIHRvIGFub3RoZXIgb2JqZWN0LiBBIGJpdCBzZXQgaXMgcmV0dXJuZWQ6XG4gICAgICAgICAqXG4gICAgICAgICAqIDx1bD5cbiAgICAgICAgICogICAgIDxsaT5ESVNDT05ORUNURUQgOiAxPC9saT5cbiAgICAgICAgICogICAgIDxsaT5QUkVDRURJTkcgOiAyPC9saT5cbiAgICAgICAgICogICAgIDxsaT5GT0xMT1dJTkcgOiA0PC9saT5cbiAgICAgICAgICogICAgIDxsaT5DT05UQUlOUyA6IDg8L2xpPlxuICAgICAgICAgKiAgICAgPGxpPkNPTlRBSU5FRF9CWSA6IDE2PC9saT5cbiAgICAgICAgICogPC91bD5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHNlbWFudGljcyBhcmUgdGhlIHNhbWUgYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb24gaW4gRE9NLCB3aXRoIHRoZSBleGNlcHRpb24gdGhhdFxuICAgICAgICAgKiBESVNDT05ORUNURUQgbmV2ZXIgb2NjdXJzIHdpdGggYW55IG90aGVyIGJpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogd2hlcmUgYG5gIGFuZCBgbWAgYXJlIHRoZSBhbW91bnQgb2YgYW5jZXN0b3JzIG9mIGBsZWZ0YCBhbmQgYHJpZ2h0YDtcbiAgICAgICAgICogd2hlcmUgYG9gIGlzIHRoZSBhbW91bnQgb2YgY2hpbGRyZW4gb2YgdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3Igb2YgYGxlZnRgIGFuZCBgcmlnaHRgOlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKG4gKyBtICsgbylgICh3b3JzdCBjYXNlKVxuICAgICAgICAgKiAqIGBPKG4gKyBtKWAgKGFtb3J0aXplZCwgaWYgdGhlIHRyZWUgaXMgbm90IG1vZGlmaWVkKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGNvbXBhcmVUcmVlUG9zaXRpb25cbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGxlZnRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJpZ2h0XG4gICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbXBhcmVUcmVlUG9zaXRpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBET00gdGVybXM6XG4gICAgICAgICAgICAgICAgLy8gbGVmdCA9IHJlZmVyZW5jZSAvIGNvbnRleHQgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gcmlnaHQgPSBvdGhlclxuXG4gICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgLVcwMTYgKi9cblxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRBbmNlc3RvcnMgPSBbXTsgeyAvLyBpbmNsdXNpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsZWZ0QW5jZXN0b3IgPSBsZWZ0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGVmdEFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0QW5jZXN0b3IgPT09IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRyZWVQb3NpdGlvbi5DT05UQUlOUyB8IFRyZWVQb3NpdGlvbi5QUkVDRURJTkc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXIgaXMgYW5jZXN0b3Igb2YgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QW5jZXN0b3JzLnB1c2gobGVmdEFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFuY2VzdG9yID0gdGhpcy5wYXJlbnQobGVmdEFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0QW5jZXN0b3JzID0gW107IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByaWdodEFuY2VzdG9yID0gcmlnaHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyaWdodEFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWdodEFuY2VzdG9yID09PSBsZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRyZWVQb3NpdGlvbi5DT05UQUlORURfQlkgfCBUcmVlUG9zaXRpb24uRk9MTE9XSU5HO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRBbmNlc3RvcnMucHVzaChyaWdodEFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHRBbmNlc3RvciA9IHRoaXMucGFyZW50KHJpZ2h0QW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdCA9IHJldmVyc2VBcnJheUluZGV4KGxlZnRBbmNlc3RvcnMsIDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyb290IHx8IHJvb3QgIT09IHJldmVyc2VBcnJheUluZGV4KHJpZ2h0QW5jZXN0b3JzLCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90ZTogdW5saWtlIERPTSwgcHJlY2VkaW5nIC8gZm9sbG93aW5nIGlzIG5vdCBzZXQgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRyZWVQb3NpdGlvbi5ESVNDT05ORUNURUQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvclxuICAgICAgICAgICAgICAgIGxldCBjb21tb25BbmNlc3RvckluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNlc3RvcnNNaW5MZW5ndGggPSBNYXRoLm1pbihsZWZ0QW5jZXN0b3JzLmxlbmd0aCwgcmlnaHRBbmNlc3RvcnMubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYW5jZXN0b3JzTWluTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRBbmNlc3RvciAgPSByZXZlcnNlQXJyYXlJbmRleChsZWZ0QW5jZXN0b3JzLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0QW5jZXN0b3IgPSByZXZlcnNlQXJyYXlJbmRleChyaWdodEFuY2VzdG9ycywgaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0QW5jZXN0b3IgIT09IHJpZ2h0QW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbkFuY2VzdG9ySW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGluZGV4ZXMgd2l0aGluIHRoZSBjb21tb24gYW5jZXN0b3JcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0SW5kZXggID0gdGhpcy5pbmRleChyZXZlcnNlQXJyYXlJbmRleChsZWZ0QW5jZXN0b3JzLCBjb21tb25BbmNlc3RvckluZGV4ICsgMSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0SW5kZXggPSB0aGlzLmluZGV4KHJldmVyc2VBcnJheUluZGV4KHJpZ2h0QW5jZXN0b3JzLCBjb21tb25BbmNlc3RvckluZGV4ICsgMSkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0SW5kZXggPCBsZWZ0SW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gVHJlZVBvc2l0aW9uLlBSRUNFRElOR1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBUcmVlUG9zaXRpb24uRk9MTE9XSU5HO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhpcyB0cmVlLlxuICAgICAgICAgKiBIYXMgbm8gZWZmZWN0IGlmIGFscmVhZHkgcmVtb3ZlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTygxKWBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCByZW1vdmVcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlbW92ZU9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHJlbW92ZU9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlKHJlbW92ZU9iamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW92ZU5vZGUgPSB0aGlzLl9ub2RlKHJlbW92ZU9iamVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHRoaXMuX25vZGUocmVtb3ZlTm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZOb2RlID0gdGhpcy5fbm9kZShyZW1vdmVOb2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dE5vZGUgPSB0aGlzLl9ub2RlKHJlbW92ZU5vZGUubmV4dFNpYmxpbmcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlLmZpcnN0Q2hpbGQgPT09IHJlbW92ZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmZpcnN0Q2hpbGQgPSByZW1vdmVOb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZS5sYXN0Q2hpbGQgPT09IHJlbW92ZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmxhc3RDaGlsZCA9IHJlbW92ZU5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwcmV2Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldk5vZGUubmV4dFNpYmxpbmcgPSByZW1vdmVOb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuZXh0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUucHJldmlvdXNTaWJsaW5nID0gcmVtb3ZlTm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZS5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUucHJldmlvdXNTaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlLm5leHRTaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlLmNhY2hlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZS5jYWNoZWRJbmRleFZlcnNpb24gPSBOYU47XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbkNoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlT2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydCB0aGUgZ2l2ZW4gb2JqZWN0IGJlZm9yZSB0aGUgcmVmZXJlbmNlIG9iamVjdC5cbiAgICAgICAgICogYG5ld09iamVjdGAgaXMgbm93IHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIGByZWZlcmVuY2VPYmplY3RgLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKDEpYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGluc2VydEJlZm9yZVxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdPYmplY3RcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBuZXdPYmplY3QgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoaXMgU3ltYm9sVHJlZVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG5ld09iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaW5zZXJ0QmVmb3JlKHJlZmVyZW5jZU9iamVjdCwgbmV3T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlTm9kZSA9IHRoaXMuX25vZGUocmVmZXJlbmNlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Tm9kZSA9IHRoaXMuX25vZGUocmVmZXJlbmNlTm9kZS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB0aGlzLl9ub2RlKG5ld09iamVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHRoaXMuX25vZGUocmVmZXJlbmNlTm9kZS5wYXJlbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ld05vZGUuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0dpdmVuIG9iamVjdCBpcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhpcyBTeW1ib2xUcmVlLCByZW1vdmUgaXQgZmlyc3QnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdOb2RlLnBhcmVudCA9IHJlZmVyZW5jZU5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgIG5ld05vZGUucHJldmlvdXNTaWJsaW5nID0gcmVmZXJlbmNlTm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5uZXh0U2libGluZyA9IHJlZmVyZW5jZU9iamVjdDtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VOb2RlLnByZXZpb3VzU2libGluZyA9IG5ld09iamVjdDtcblxuICAgICAgICAgICAgICAgIGlmIChwcmV2Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldk5vZGUubmV4dFNpYmxpbmcgPSBuZXdPYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5maXJzdENoaWxkID09PSByZWZlcmVuY2VPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuZmlyc3RDaGlsZCA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZHJlbkNoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3T2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydCB0aGUgZ2l2ZW4gb2JqZWN0IGFmdGVyIHRoZSByZWZlcmVuY2Ugb2JqZWN0LlxuICAgICAgICAgKiBgbmV3T2JqZWN0YCBpcyBub3cgdGhlIG5leHQgc2libGluZyBvZiBgcmVmZXJlbmNlT2JqZWN0YC5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTygxKWBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBpbnNlcnRBZnRlclxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdPYmplY3RcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBuZXdPYmplY3QgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoaXMgU3ltYm9sVHJlZVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG5ld09iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaW5zZXJ0QWZ0ZXIocmVmZXJlbmNlT2JqZWN0LCBuZXdPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2VOb2RlID0gdGhpcy5fbm9kZShyZWZlcmVuY2VPYmplY3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gdGhpcy5fbm9kZShyZWZlcmVuY2VOb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdOb2RlID0gdGhpcy5fbm9kZShuZXdPYmplY3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSB0aGlzLl9ub2RlKHJlZmVyZW5jZU5vZGUucGFyZW50KTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXdOb2RlLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdHaXZlbiBvYmplY3QgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoaXMgU3ltYm9sVHJlZSwgcmVtb3ZlIGl0IGZpcnN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5wYXJlbnQgPSByZWZlcmVuY2VOb2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICBuZXdOb2RlLnByZXZpb3VzU2libGluZyA9IHJlZmVyZW5jZU9iamVjdDtcbiAgICAgICAgICAgICAgICBuZXdOb2RlLm5leHRTaWJsaW5nID0gcmVmZXJlbmNlTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VOb2RlLm5leHRTaWJsaW5nID0gbmV3T2JqZWN0O1xuXG4gICAgICAgICAgICAgICAgaWYgKG5leHROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZS5wcmV2aW91c1NpYmxpbmcgPSBuZXdPYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5sYXN0Q2hpbGQgPT09IHJlZmVyZW5jZU9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5sYXN0Q2hpbGQgPSBuZXdPYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW5DaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld09iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnQgdGhlIGdpdmVuIG9iamVjdCBhcyB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIGdpdmVuIHJlZmVyZW5jZSBvYmplY3QuXG4gICAgICAgICAqIGBuZXdPYmplY3RgIGlzIG5vdyB0aGUgZmlyc3QgY2hpbGQgb2YgYHJlZmVyZW5jZU9iamVjdGAuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8oMSlgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJlcGVuZENoaWxkXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld09iamVjdFxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG5ld09iamVjdCBpcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhpcyBTeW1ib2xUcmVlXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gbmV3T2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBwcmVwZW5kQ2hpbGQocmVmZXJlbmNlT2JqZWN0LCBuZXdPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2VOb2RlID0gdGhpcy5fbm9kZShyZWZlcmVuY2VPYmplY3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB0aGlzLl9ub2RlKG5ld09iamVjdCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3Tm9kZS5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignR2l2ZW4gb2JqZWN0IGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGlzIFN5bWJvbFRyZWUsIHJlbW92ZSBpdCBmaXJzdCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZWZlcmVuY2VOb2RlLmhhc0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydEJlZm9yZShyZWZlcmVuY2VOb2RlLmZpcnN0Q2hpbGQsIG5ld09iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5wYXJlbnQgPSByZWZlcmVuY2VPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VOb2RlLmZpcnN0Q2hpbGQgPSBuZXdPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VOb2RlLmxhc3RDaGlsZCA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUuY2hpbGRyZW5DaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld09iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnQgdGhlIGdpdmVuIG9iamVjdCBhcyB0aGUgbGFzdCBjaGlsZCBvZiB0aGUgZ2l2ZW4gcmVmZXJlbmNlIG9iamVjdC5cbiAgICAgICAgICogYG5ld09iamVjdGAgaXMgbm93IHRoZSBsYXN0IGNoaWxkIG9mIGByZWZlcmVuY2VPYmplY3RgLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKDEpYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGFwcGVuZENoaWxkXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld09iamVjdFxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG5ld09iamVjdCBpcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhpcyBTeW1ib2xUcmVlXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gbmV3T2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRDaGlsZChyZWZlcmVuY2VPYmplY3QsIG5ld09iamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZU5vZGUgPSB0aGlzLl9ub2RlKHJlZmVyZW5jZU9iamVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHRoaXMuX25vZGUobmV3T2JqZWN0KTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXdOb2RlLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdHaXZlbiBvYmplY3QgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoaXMgU3ltYm9sVHJlZSwgcmVtb3ZlIGl0IGZpcnN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlZmVyZW5jZU5vZGUuaGFzQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0QWZ0ZXIocmVmZXJlbmNlTm9kZS5sYXN0Q2hpbGQsIG5ld09iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5wYXJlbnQgPSByZWZlcmVuY2VPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VOb2RlLmZpcnN0Q2hpbGQgPSBuZXdPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VOb2RlLmxhc3RDaGlsZCA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUuY2hpbGRyZW5DaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld09iamVjdDtcbiAgICAgICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbFRyZWU7XG5TeW1ib2xUcmVlLlRyZWVQb3NpdGlvbiA9IFRyZWVQb3NpdGlvbjtcbiJdLCJuYW1lcyI6WyJTeW1ib2xUcmVlTm9kZSIsInJlcXVpcmUiLCJUcmVlUG9zaXRpb24iLCJUcmVlSXRlcmF0b3IiLCJyZXR1cm5UcnVlIiwicmV2ZXJzZUFycmF5SW5kZXgiLCJhcnJheSIsInJldmVyc2VJbmRleCIsImxlbmd0aCIsIlN5bWJvbFRyZWUiLCJjb25zdHJ1Y3RvciIsImRlc2NyaXB0aW9uIiwic3ltYm9sIiwiU3ltYm9sIiwiaW5pdGlhbGl6ZSIsIm9iamVjdCIsIl9ub2RlIiwibm9kZSIsImhhc0NoaWxkcmVuIiwiZmlyc3RDaGlsZCIsImxhc3RDaGlsZCIsInByZXZpb3VzU2libGluZyIsIm5leHRTaWJsaW5nIiwicGFyZW50IiwibGFzdEluY2x1c2l2ZURlc2NlbmRhbnQiLCJjdXJyZW50IiwicHJlY2VkaW5nIiwib3B0aW9ucyIsInRyZWVSb290Iiwicm9vdCIsImZvbGxvd2luZyIsInNraXBDaGlsZHJlbiIsImNoaWxkcmVuVG9BcnJheSIsImZpbHRlciIsInRoaXNBcmciLCJ1bmRlZmluZWQiLCJwYXJlbnROb2RlIiwiaW5kZXgiLCJzZXRDYWNoZWRJbmRleCIsImNhbGwiLCJwdXNoIiwiYW5jZXN0b3JzVG9BcnJheSIsImFuY2VzdG9yIiwidHJlZVRvQXJyYXkiLCJjaGlsZHJlbkl0ZXJhdG9yIiwicmV2ZXJzZSIsIlBSRVYiLCJORVhUIiwicHJldmlvdXNTaWJsaW5nc0l0ZXJhdG9yIiwibmV4dFNpYmxpbmdzSXRlcmF0b3IiLCJhbmNlc3RvcnNJdGVyYXRvciIsIlBBUkVOVCIsInRyZWVJdGVyYXRvciIsIlBSRUNFRElORyIsIkZPTExPV0lORyIsImNoaWxkIiwiY2hpbGROb2RlIiwiY3VycmVudEluZGV4IiwiZ2V0Q2FjaGVkSW5kZXgiLCJjaGlsZEluZGV4Q2FjaGVkVXBUbyIsImNhY2hlZFVwVG9Ob2RlIiwiY2hpbGRyZW5Db3VudCIsImNvbXBhcmVUcmVlUG9zaXRpb24iLCJsZWZ0IiwicmlnaHQiLCJsZWZ0QW5jZXN0b3JzIiwibGVmdEFuY2VzdG9yIiwiQ09OVEFJTlMiLCJyaWdodEFuY2VzdG9ycyIsInJpZ2h0QW5jZXN0b3IiLCJDT05UQUlORURfQlkiLCJESVNDT05ORUNURUQiLCJjb21tb25BbmNlc3RvckluZGV4IiwiYW5jZXN0b3JzTWluTGVuZ3RoIiwiTWF0aCIsIm1pbiIsImkiLCJsZWZ0SW5kZXgiLCJyaWdodEluZGV4IiwicmVtb3ZlIiwicmVtb3ZlT2JqZWN0IiwicmVtb3ZlTm9kZSIsInByZXZOb2RlIiwibmV4dE5vZGUiLCJjYWNoZWRJbmRleCIsImNhY2hlZEluZGV4VmVyc2lvbiIsIk5hTiIsImNoaWxkcmVuQ2hhbmdlZCIsImluc2VydEJlZm9yZSIsInJlZmVyZW5jZU9iamVjdCIsIm5ld09iamVjdCIsInJlZmVyZW5jZU5vZGUiLCJuZXdOb2RlIiwiaXNBdHRhY2hlZCIsIkVycm9yIiwiaW5zZXJ0QWZ0ZXIiLCJwcmVwZW5kQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/symbol-tree/lib/SymbolTree.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/symbol-tree/lib/SymbolTreeNode.js":
/*!************************************************************!*\
  !*** ../../node_modules/symbol-tree/lib/SymbolTreeNode.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = class SymbolTreeNode {\n    constructor(){\n        this.parent = null;\n        this.previousSibling = null;\n        this.nextSibling = null;\n        this.firstChild = null;\n        this.lastChild = null;\n        /** This value is incremented anytime a children is added or removed */ this.childrenVersion = 0;\n        /** The last child object which has a cached index */ this.childIndexCachedUpTo = null;\n        /** This value represents the cached node index, as long as\n                 * cachedIndexVersion matches with the childrenVersion of the parent */ this.cachedIndex = -1;\n        this.cachedIndexVersion = NaN; // NaN is never equal to anything\n    }\n    get isAttached() {\n        return Boolean(this.parent || this.previousSibling || this.nextSibling);\n    }\n    get hasChildren() {\n        return Boolean(this.firstChild);\n    }\n    childrenChanged() {\n        /* jshint -W016 */ // integer wrap around\n        this.childrenVersion = this.childrenVersion + 1 & 0xFFFFFFFF;\n        this.childIndexCachedUpTo = null;\n    }\n    getCachedIndex(parentNode) {\n        // (assumes parentNode is actually the parent)\n        if (this.cachedIndexVersion !== parentNode.childrenVersion) {\n            this.cachedIndexVersion = NaN;\n            // cachedIndex is no longer valid\n            return -1;\n        }\n        return this.cachedIndex; // -1 if not cached\n    }\n    setCachedIndex(parentNode, index) {\n        // (assumes parentNode is actually the parent)\n        this.cachedIndexVersion = parentNode.childrenVersion;\n        this.cachedIndex = index;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3N5bWJvbC10cmVlL2xpYi9TeW1ib2xUcmVlTm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUcsTUFBTUM7SUFDZkMsYUFBYztRQUNOLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFFbkIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFFakIscUVBQXFFLEdBQ3JFLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLG1EQUFtRCxHQUNuRCxJQUFJLENBQUNDLG9CQUFvQixHQUFHO1FBRTVCO3FGQUNxRSxHQUNyRSxJQUFJLENBQUNDLFdBQVcsR0FBRyxDQUFDO1FBQ3BCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUdDLEtBQUssaUNBQWlDO0lBQ3hFO0lBRUEsSUFBSUMsYUFBYTtRQUNULE9BQU9DLFFBQVEsSUFBSSxDQUFDWCxNQUFNLElBQUksSUFBSSxDQUFDQyxlQUFlLElBQUksSUFBSSxDQUFDQyxXQUFXO0lBQzlFO0lBRUEsSUFBSVUsY0FBYztRQUNWLE9BQU9ELFFBQVEsSUFBSSxDQUFDUixVQUFVO0lBQ3RDO0lBRUFVLGtCQUFrQjtRQUNWLGdCQUFnQixHQUNoQixzQkFBc0I7UUFDdEIsSUFBSSxDQUFDUixlQUFlLEdBQUcsSUFBSyxDQUFDQSxlQUFlLEdBQUcsSUFBSztRQUNwRCxJQUFJLENBQUNDLG9CQUFvQixHQUFHO0lBQ3BDO0lBRUFRLGVBQWVDLFVBQVUsRUFBRTtRQUNuQiw4Q0FBOEM7UUFDOUMsSUFBSSxJQUFJLENBQUNQLGtCQUFrQixLQUFLTyxXQUFXVixlQUFlLEVBQUU7WUFDcEQsSUFBSSxDQUFDRyxrQkFBa0IsR0FBR0M7WUFDMUIsaUNBQWlDO1lBQ2pDLE9BQU8sQ0FBQztRQUNoQjtRQUVBLE9BQU8sSUFBSSxDQUFDRixXQUFXLEVBQUUsbUJBQW1CO0lBQ3BEO0lBRUFTLGVBQWVELFVBQVUsRUFBRUUsS0FBSyxFQUFFO1FBQzFCLDhDQUE4QztRQUM5QyxJQUFJLENBQUNULGtCQUFrQixHQUFHTyxXQUFXVixlQUFlO1FBQ3BELElBQUksQ0FBQ0UsV0FBVyxHQUFHVTtJQUMzQjtBQUNSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGNvdmVyLWNyYWZ0L3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvc3ltYm9sLXRyZWUvbGliL1N5bWJvbFRyZWVOb2RlLmpzPzBiNTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFN5bWJvbFRyZWVOb2RlIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNTaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTaWJsaW5nID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLyoqIFRoaXMgdmFsdWUgaXMgaW5jcmVtZW50ZWQgYW55dGltZSBhIGNoaWxkcmVuIGlzIGFkZGVkIG9yIHJlbW92ZWQgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuVmVyc2lvbiA9IDA7XG4gICAgICAgICAgICAgICAgLyoqIFRoZSBsYXN0IGNoaWxkIG9iamVjdCB3aGljaCBoYXMgYSBjYWNoZWQgaW5kZXggKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkSW5kZXhDYWNoZWRVcFRvID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8qKiBUaGlzIHZhbHVlIHJlcHJlc2VudHMgdGhlIGNhY2hlZCBub2RlIGluZGV4LCBhcyBsb25nIGFzXG4gICAgICAgICAgICAgICAgICogY2FjaGVkSW5kZXhWZXJzaW9uIG1hdGNoZXMgd2l0aCB0aGUgY2hpbGRyZW5WZXJzaW9uIG9mIHRoZSBwYXJlbnQgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRJbmRleFZlcnNpb24gPSBOYU47IC8vIE5hTiBpcyBuZXZlciBlcXVhbCB0byBhbnl0aGluZ1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0IGlzQXR0YWNoZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5wYXJlbnQgfHwgdGhpcy5wcmV2aW91c1NpYmxpbmcgfHwgdGhpcy5uZXh0U2libGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBnZXQgaGFzQ2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkcmVuQ2hhbmdlZCgpIHtcbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgLVcwMTYgKi9cbiAgICAgICAgICAgICAgICAvLyBpbnRlZ2VyIHdyYXAgYXJvdW5kXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblZlcnNpb24gPSAodGhpcy5jaGlsZHJlblZlcnNpb24gKyAxKSAmIDB4RkZGRkZGRkY7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZEluZGV4Q2FjaGVkVXBUbyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRDYWNoZWRJbmRleChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gKGFzc3VtZXMgcGFyZW50Tm9kZSBpcyBhY3R1YWxseSB0aGUgcGFyZW50KVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlZEluZGV4VmVyc2lvbiAhPT0gcGFyZW50Tm9kZS5jaGlsZHJlblZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkSW5kZXhWZXJzaW9uID0gTmFOO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FjaGVkSW5kZXggaXMgbm8gbG9uZ2VyIHZhbGlkXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkSW5kZXg7IC8vIC0xIGlmIG5vdCBjYWNoZWRcbiAgICAgICAgfVxuXG4gICAgICAgIHNldENhY2hlZEluZGV4KHBhcmVudE5vZGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gKGFzc3VtZXMgcGFyZW50Tm9kZSBpcyBhY3R1YWxseSB0aGUgcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkSW5kZXhWZXJzaW9uID0gcGFyZW50Tm9kZS5jaGlsZHJlblZlcnNpb247XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRJbmRleCA9IGluZGV4O1xuICAgICAgICB9XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJTeW1ib2xUcmVlTm9kZSIsImNvbnN0cnVjdG9yIiwicGFyZW50IiwicHJldmlvdXNTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJmaXJzdENoaWxkIiwibGFzdENoaWxkIiwiY2hpbGRyZW5WZXJzaW9uIiwiY2hpbGRJbmRleENhY2hlZFVwVG8iLCJjYWNoZWRJbmRleCIsImNhY2hlZEluZGV4VmVyc2lvbiIsIk5hTiIsImlzQXR0YWNoZWQiLCJCb29sZWFuIiwiaGFzQ2hpbGRyZW4iLCJjaGlsZHJlbkNoYW5nZWQiLCJnZXRDYWNoZWRJbmRleCIsInBhcmVudE5vZGUiLCJzZXRDYWNoZWRJbmRleCIsImluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/symbol-tree/lib/SymbolTreeNode.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/symbol-tree/lib/TreeIterator.js":
/*!**********************************************************!*\
  !*** ../../node_modules/symbol-tree/lib/TreeIterator.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\nconst TREE = Symbol();\nconst ROOT = Symbol();\nconst NEXT = Symbol();\nconst ITERATE_FUNC = Symbol();\nclass TreeIterator {\n    constructor(tree, root, firstResult, iterateFunction){\n        this[TREE] = tree;\n        this[ROOT] = root;\n        this[NEXT] = firstResult;\n        this[ITERATE_FUNC] = iterateFunction;\n    }\n    next() {\n        const tree = this[TREE];\n        const iterateFunc = this[ITERATE_FUNC];\n        const root = this[ROOT];\n        if (!this[NEXT]) {\n            return {\n                done: true,\n                value: root\n            };\n        }\n        const value = this[NEXT];\n        if (iterateFunc === 1) {\n            this[NEXT] = tree._node(value).previousSibling;\n        } else if (iterateFunc === 2) {\n            this[NEXT] = tree._node(value).nextSibling;\n        } else if (iterateFunc === 3) {\n            this[NEXT] = tree._node(value).parent;\n        } else if (iterateFunc === 4) {\n            this[NEXT] = tree.preceding(value, {\n                root: root\n            });\n        } else /* if (iterateFunc === 5)*/ {\n            this[NEXT] = tree.following(value, {\n                root: root\n            });\n        }\n        return {\n            done: false,\n            value: value\n        };\n    }\n}\nObject.defineProperty(TreeIterator.prototype, Symbol.iterator, {\n    value: function() {\n        return this;\n    },\n    writable: false\n});\nTreeIterator.PREV = 1;\nTreeIterator.NEXT = 2;\nTreeIterator.PARENT = 3;\nTreeIterator.PRECEDING = 4;\nTreeIterator.FOLLOWING = 5;\nObject.freeze(TreeIterator);\nObject.freeze(TreeIterator.prototype);\nmodule.exports = TreeIterator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3N5bWJvbC10cmVlL2xpYi9UcmVlSXRlcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxPQUFPQztBQUNiLE1BQU1DLE9BQU9EO0FBQ2IsTUFBTUUsT0FBT0Y7QUFDYixNQUFNRyxlQUFlSDtBQUVyQixNQUFNSTtJQUNFQyxZQUFZQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsV0FBVyxFQUFFQyxlQUFlLENBQUU7UUFDOUMsSUFBSSxDQUFDVixLQUFLLEdBQUdPO1FBQ2IsSUFBSSxDQUFDTCxLQUFLLEdBQUdNO1FBQ2IsSUFBSSxDQUFDTCxLQUFLLEdBQUdNO1FBQ2IsSUFBSSxDQUFDTCxhQUFhLEdBQUdNO0lBQzdCO0lBRUFDLE9BQU87UUFDQyxNQUFNSixPQUFPLElBQUksQ0FBQ1AsS0FBSztRQUN2QixNQUFNWSxjQUFjLElBQUksQ0FBQ1IsYUFBYTtRQUN0QyxNQUFNSSxPQUFPLElBQUksQ0FBQ04sS0FBSztRQUV2QixJQUFJLENBQUMsSUFBSSxDQUFDQyxLQUFLLEVBQUU7WUFDVCxPQUFPO2dCQUNDVSxNQUFNO2dCQUNOQyxPQUFPTjtZQUNmO1FBQ1I7UUFFQSxNQUFNTSxRQUFRLElBQUksQ0FBQ1gsS0FBSztRQUV4QixJQUFJUyxnQkFBZ0IsR0FBRztZQUNmLElBQUksQ0FBQ1QsS0FBSyxHQUFHSSxLQUFLUSxLQUFLLENBQUNELE9BQU9FLGVBQWU7UUFDdEQsT0FDSyxJQUFJSixnQkFBZ0IsR0FBRztZQUNwQixJQUFJLENBQUNULEtBQUssR0FBR0ksS0FBS1EsS0FBSyxDQUFDRCxPQUFPRyxXQUFXO1FBQ2xELE9BQ0ssSUFBSUwsZ0JBQWdCLEdBQUc7WUFDcEIsSUFBSSxDQUFDVCxLQUFLLEdBQUdJLEtBQUtRLEtBQUssQ0FBQ0QsT0FBT0ksTUFBTTtRQUM3QyxPQUNLLElBQUlOLGdCQUFnQixHQUFHO1lBQ3BCLElBQUksQ0FBQ1QsS0FBSyxHQUFHSSxLQUFLWSxTQUFTLENBQUNMLE9BQU87Z0JBQUNOLE1BQU1BO1lBQUk7UUFDdEQsT0FDSyx5QkFBeUIsR0FBRztZQUN6QixJQUFJLENBQUNMLEtBQUssR0FBR0ksS0FBS2EsU0FBUyxDQUFDTixPQUFPO2dCQUFDTixNQUFNQTtZQUFJO1FBQ3REO1FBRUEsT0FBTztZQUNDSyxNQUFNO1lBQ05DLE9BQU9BO1FBQ2Y7SUFDUjtBQUNSO0FBRUFPLE9BQU9DLGNBQWMsQ0FBQ2pCLGFBQWFrQixTQUFTLEVBQUV0QixPQUFPdUIsUUFBUSxFQUFFO0lBQ3ZEVixPQUFPO1FBQ0MsT0FBTyxJQUFJO0lBQ25CO0lBQ0FXLFVBQVU7QUFDbEI7QUFFQXBCLGFBQWFxQixJQUFJLEdBQUc7QUFDcEJyQixhQUFhRixJQUFJLEdBQUc7QUFDcEJFLGFBQWFzQixNQUFNLEdBQUc7QUFDdEJ0QixhQUFhdUIsU0FBUyxHQUFHO0FBQ3pCdkIsYUFBYXdCLFNBQVMsR0FBRztBQUV6QlIsT0FBT1MsTUFBTSxDQUFDekI7QUFDZGdCLE9BQU9TLE1BQU0sQ0FBQ3pCLGFBQWFrQixTQUFTO0FBRXBDUSxPQUFPQyxPQUFPLEdBQUczQiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bjb3Zlci1jcmFmdC93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzL3N5bWJvbC10cmVlL2xpYi9UcmVlSXRlcmF0b3IuanM/YmRmZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFRSRUUgPSBTeW1ib2woKTtcbmNvbnN0IFJPT1QgPSBTeW1ib2woKTtcbmNvbnN0IE5FWFQgPSBTeW1ib2woKTtcbmNvbnN0IElURVJBVEVfRlVOQyA9IFN5bWJvbCgpO1xuXG5jbGFzcyBUcmVlSXRlcmF0b3Ige1xuICAgICAgICBjb25zdHJ1Y3Rvcih0cmVlLCByb290LCBmaXJzdFJlc3VsdCwgaXRlcmF0ZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tUUkVFXSA9IHRyZWU7XG4gICAgICAgICAgICAgICAgdGhpc1tST09UXSA9IHJvb3Q7XG4gICAgICAgICAgICAgICAgdGhpc1tORVhUXSA9IGZpcnN0UmVzdWx0O1xuICAgICAgICAgICAgICAgIHRoaXNbSVRFUkFURV9GVU5DXSA9IGl0ZXJhdGVGdW5jdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJlZSA9IHRoaXNbVFJFRV07XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlcmF0ZUZ1bmMgPSB0aGlzW0lURVJBVEVfRlVOQ107XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXNbUk9PVF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXNbTkVYVF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNbTkVYVF07XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0ZUZ1bmMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbTkVYVF0gPSB0cmVlLl9ub2RlKHZhbHVlKS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0ZXJhdGVGdW5jID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW05FWFRdID0gdHJlZS5fbm9kZSh2YWx1ZSkubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0ZXJhdGVGdW5jID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW05FWFRdID0gdHJlZS5fbm9kZSh2YWx1ZSkucGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdGVyYXRlRnVuYyA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tORVhUXSA9IHRyZWUucHJlY2VkaW5nKHZhbHVlLCB7cm9vdDogcm9vdH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIC8qIGlmIChpdGVyYXRlRnVuYyA9PT0gNSkqLyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW05FWFRdID0gdHJlZS5mb2xsb3dpbmcodmFsdWUsIHtyb290OiByb290fSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyZWVJdGVyYXRvci5wcm90b3R5cGUsIFN5bWJvbC5pdGVyYXRvciwge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbn0pO1xuXG5UcmVlSXRlcmF0b3IuUFJFViA9IDE7XG5UcmVlSXRlcmF0b3IuTkVYVCA9IDI7XG5UcmVlSXRlcmF0b3IuUEFSRU5UID0gMztcblRyZWVJdGVyYXRvci5QUkVDRURJTkcgPSA0O1xuVHJlZUl0ZXJhdG9yLkZPTExPV0lORyA9IDU7XG5cbk9iamVjdC5mcmVlemUoVHJlZUl0ZXJhdG9yKTtcbk9iamVjdC5mcmVlemUoVHJlZUl0ZXJhdG9yLnByb3RvdHlwZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJlZUl0ZXJhdG9yO1xuIl0sIm5hbWVzIjpbIlRSRUUiLCJTeW1ib2wiLCJST09UIiwiTkVYVCIsIklURVJBVEVfRlVOQyIsIlRyZWVJdGVyYXRvciIsImNvbnN0cnVjdG9yIiwidHJlZSIsInJvb3QiLCJmaXJzdFJlc3VsdCIsIml0ZXJhdGVGdW5jdGlvbiIsIm5leHQiLCJpdGVyYXRlRnVuYyIsImRvbmUiLCJ2YWx1ZSIsIl9ub2RlIiwicHJldmlvdXNTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJwYXJlbnQiLCJwcmVjZWRpbmciLCJmb2xsb3dpbmciLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvdHlwZSIsIml0ZXJhdG9yIiwid3JpdGFibGUiLCJQUkVWIiwiUEFSRU5UIiwiUFJFQ0VESU5HIiwiRk9MTE9XSU5HIiwiZnJlZXplIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/symbol-tree/lib/TreeIterator.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/symbol-tree/lib/TreePosition.js":
/*!**********************************************************!*\
  !*** ../../node_modules/symbol-tree/lib/TreePosition.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\n/* eslint-disable sort-keys */ module.exports = Object.freeze({\n    // same as DOM DOCUMENT_POSITION_\n    DISCONNECTED: 1,\n    PRECEDING: 2,\n    FOLLOWING: 4,\n    CONTAINS: 8,\n    CONTAINED_BY: 16\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3N5bWJvbC10cmVlL2xpYi9UcmVlUG9zaXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSw0QkFBNEIsR0FDNUJBLE9BQU9DLE9BQU8sR0FBR0MsT0FBT0MsTUFBTSxDQUFDO0lBQ3ZCLGlDQUFpQztJQUNqQ0MsY0FBYztJQUNkQyxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsVUFBVTtJQUNWQyxjQUFjO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGNvdmVyLWNyYWZ0L3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvc3ltYm9sLXRyZWUvbGliL1RyZWVQb3NpdGlvbi5qcz82YmY1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWRpc2FibGUgc29ydC1rZXlzICovXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAvLyBzYW1lIGFzIERPTSBET0NVTUVOVF9QT1NJVElPTl9cbiAgICAgICAgRElTQ09OTkVDVEVEOiAxLFxuICAgICAgICBQUkVDRURJTkc6IDIsXG4gICAgICAgIEZPTExPV0lORzogNCxcbiAgICAgICAgQ09OVEFJTlM6IDgsXG4gICAgICAgIENPTlRBSU5FRF9CWTogMTYsXG59KTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiT2JqZWN0IiwiZnJlZXplIiwiRElTQ09OTkVDVEVEIiwiUFJFQ0VESU5HIiwiRk9MTE9XSU5HIiwiQ09OVEFJTlMiLCJDT05UQUlORURfQlkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/symbol-tree/lib/TreePosition.js\n");

/***/ })

};
;